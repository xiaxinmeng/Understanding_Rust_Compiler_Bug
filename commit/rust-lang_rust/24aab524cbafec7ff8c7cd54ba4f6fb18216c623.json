{"sha": "24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "node_id": "C_kwDOAAsO6NoAKDI0YWFiNTI0Y2JhZmVjN2ZmOGM3Y2Q1NGJhNGY2ZmIxODIxNmM2MjM", "commit": {"author": {"name": "Matthew Kelly", "email": "matthew.kelly2@gmail.com", "date": "2022-09-26T23:59:52Z"}, "committer": {"name": "Matthew Kelly", "email": "matthew.kelly2@gmail.com", "date": "2022-09-26T23:59:52Z"}, "message": "Merge remote-tracking branch 'origin/master' into mpk/add-long-error-message-for-E0311", "tree": {"sha": "b0fd92c686ed3fe2b3a5a010c0dc32a6a54d3ea1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0fd92c686ed3fe2b3a5a010c0dc32a6a54d3ea1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "html_url": "https://github.com/rust-lang/rust/commit/24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/comments", "author": {"login": "MatthewPeterKelly", "id": 8137529, "node_id": "MDQ6VXNlcjgxMzc1Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/8137529?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MatthewPeterKelly", "html_url": "https://github.com/MatthewPeterKelly", "followers_url": "https://api.github.com/users/MatthewPeterKelly/followers", "following_url": "https://api.github.com/users/MatthewPeterKelly/following{/other_user}", "gists_url": "https://api.github.com/users/MatthewPeterKelly/gists{/gist_id}", "starred_url": "https://api.github.com/users/MatthewPeterKelly/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MatthewPeterKelly/subscriptions", "organizations_url": "https://api.github.com/users/MatthewPeterKelly/orgs", "repos_url": "https://api.github.com/users/MatthewPeterKelly/repos", "events_url": "https://api.github.com/users/MatthewPeterKelly/events{/privacy}", "received_events_url": "https://api.github.com/users/MatthewPeterKelly/received_events", "type": "User", "site_admin": false}, "committer": {"login": "MatthewPeterKelly", "id": 8137529, "node_id": "MDQ6VXNlcjgxMzc1Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/8137529?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MatthewPeterKelly", "html_url": "https://github.com/MatthewPeterKelly", "followers_url": "https://api.github.com/users/MatthewPeterKelly/followers", "following_url": "https://api.github.com/users/MatthewPeterKelly/following{/other_user}", "gists_url": "https://api.github.com/users/MatthewPeterKelly/gists{/gist_id}", "starred_url": "https://api.github.com/users/MatthewPeterKelly/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MatthewPeterKelly/subscriptions", "organizations_url": "https://api.github.com/users/MatthewPeterKelly/orgs", "repos_url": "https://api.github.com/users/MatthewPeterKelly/repos", "events_url": "https://api.github.com/users/MatthewPeterKelly/events{/privacy}", "received_events_url": "https://api.github.com/users/MatthewPeterKelly/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "url": "https://api.github.com/repos/rust-lang/rust/commits/eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "html_url": "https://github.com/rust-lang/rust/commit/eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "8b705839cd656d202e920efa8769cbe43a5ee269", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b705839cd656d202e920efa8769cbe43a5ee269", "html_url": "https://github.com/rust-lang/rust/commit/8b705839cd656d202e920efa8769cbe43a5ee269"}], "stats": {"total": 173399, "additions": 132677, "deletions": 40722}, "files": [{"sha": "771cef6e4d0d630bd5e1f0b58b14e5845bb2b8c5", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -25,11 +25,15 @@ name: CI\n   pull_request:\n     branches:\n       - \"**\"\n+permissions:\n+  contents: read\n defaults:\n   run:\n     shell: bash\n jobs:\n   pr:\n+    permissions:\n+      actions: write\n     name: PR\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n@@ -142,6 +146,8 @@ jobs:\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n         if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n   auto:\n+    permissions:\n+      actions: write\n     name: auto\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n@@ -291,7 +297,7 @@ jobs:\n             os: ubuntu-20.04-xl\n           - name: dist-x86_64-apple\n             env:\n-              SCRIPT: \"./x.py dist --host=x86_64-apple-darwin --target=x86_64-apple-darwin\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths --host=x86_64-apple-darwin --target=x86_64-apple-darwin\"\n               RUST_CONFIGURE_ARGS: \"--enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n@@ -302,7 +308,7 @@ jobs:\n             os: macos-latest\n           - name: dist-apple-various\n             env:\n-              SCRIPT: \"./x.py dist --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n               RUST_CONFIGURE_ARGS: \"--enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n@@ -312,7 +318,7 @@ jobs:\n             os: macos-latest\n           - name: dist-x86_64-apple-alt\n             env:\n-              SCRIPT: \"./x.py dist\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths\"\n               RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n@@ -344,7 +350,7 @@ jobs:\n             os: macos-latest\n           - name: dist-aarch64-apple\n             env:\n-              SCRIPT: \"./x.py dist --stage 2\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths --stage 2\"\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --host=aarch64-apple-darwin --target=aarch64-apple-darwin --enable-full-tools --enable-sanitizers --enable-profiler --disable-docs --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               USE_XCODE_CLANG: 1\n@@ -418,33 +424,33 @@ jobs:\n           - name: dist-x86_64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n-              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist\n+              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n           - name: dist-i686-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc --host=i686-pc-windows-msvc --target=i686-pc-windows-msvc,i586-pc-windows-msvc --enable-full-tools --enable-profiler\"\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n           - name: dist-aarch64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n               WINDOWS_SDK_20348_HACK: 1\n             os: windows-latest-xl\n           - name: dist-i686-mingw\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --enable-full-tools --enable-profiler --set llvm.allow-old-toolchain\"\n               NO_DOWNLOAD_CI_LLVM: 1\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n               CUSTOM_MINGW: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n           - name: dist-x86_64-mingw\n             env:\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler --set llvm.allow-old-toolchain\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n@@ -453,7 +459,7 @@ jobs:\n           - name: dist-x86_64-msvc-alt\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\"\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n             os: windows-latest-xl\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n@@ -547,6 +553,8 @@ jobs:\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n         if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n   try:\n+    permissions:\n+      actions: write\n     name: try\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\""}, {"sha": "37972532b361429f281f8d52f34ea4d1ca621540", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -46,6 +46,7 @@ no_llvm_build\n /dist/\n /unicode-downloads\n /target\n+/src/bootstrap/target\n /src/tools/x/target\n # Created by default with `src/ci/docker/run.sh`\n /obj/"}, {"sha": "c85049378061317bd6fe82f2fcc0a574a8318c89", "filename": ".gitmodules", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -13,9 +13,6 @@\n [submodule \"src/doc/book\"]\n \tpath = src/doc/book\n \turl = https://github.com/rust-lang/book.git\n-[submodule \"src/tools/miri\"]\n-\tpath = src/tools/miri\n-\turl = https://github.com/rust-lang/miri.git\n [submodule \"src/doc/rust-by-example\"]\n \tpath = src/doc/rust-by-example\n \turl = https://github.com/rust-lang/rust-by-example.git"}, {"sha": "16c0b644e4f709d441658fd2a75c5e3c127cc27f", "filename": "Cargo.lock", "status": "modified", "additions": 132, "deletions": 187, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -103,9 +103,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.60\"\n+version = \"1.0.65\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c794e162a5eff65c72ef524dfe393eb923c354e350bb78b9c7383df13f3bc142\"\n+checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n \n [[package]]\n name = \"array_tool\"\n@@ -209,34 +209,13 @@ dependencies = [\n  \"typenum\",\n ]\n \n-[[package]]\n-name = \"block-buffer\"\n-version = \"0.7.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c0940dc441f31689269e10ac70eb1002a3a1d3ad1390e030043662eb7fe4688b\"\n-dependencies = [\n- \"block-padding\",\n- \"byte-tools\",\n- \"byteorder\",\n- \"generic-array 0.12.4\",\n-]\n-\n [[package]]\n name = \"block-buffer\"\n version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0bf7fe51849ea569fd452f37822f606a5cabb684dc918707a0193fd4664ff324\"\n dependencies = [\n- \"generic-array 0.14.4\",\n-]\n-\n-[[package]]\n-name = \"block-padding\"\n-version = \"0.1.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fa79dedbb091f449f1f39e53edf88d5dbe95f895dae6135a8d7b881fb5af73f5\"\n-dependencies = [\n- \"byte-tools\",\n+ \"generic-array\",\n ]\n \n [[package]]\n@@ -277,12 +256,6 @@ dependencies = [\n  \"toml\",\n ]\n \n-[[package]]\n-name = \"byte-tools\"\n-version = \"0.3.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e3b5ca7a04898ad4bcd41c90c5285445ff5b791899bb1b0abdd2a2aa791211d7\"\n-\n [[package]]\n name = \"bytecount\"\n version = \"0.6.2\"\n@@ -292,12 +265,6 @@ dependencies = [\n  \"packed_simd_2\",\n ]\n \n-[[package]]\n-name = \"byteorder\"\n-version = \"1.3.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"08c48aae112d48ed9f069b33538ea9e3e90aa263cfa3d1c24309612b1f7472de\"\n-\n [[package]]\n name = \"bytes\"\n version = \"1.0.1\"\n@@ -540,6 +507,10 @@ name = \"cfg-if\"\n version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+]\n \n [[package]]\n name = \"chalk-derive\"\n@@ -610,9 +581,9 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"3.2.5\"\n+version = \"3.2.20\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d53da17d37dba964b9b3ecb5c5a1f193a2762c700e6829201e645b9381c99dc7\"\n+checksum = \"23b71c3ce99b7611011217b366d923f1d0a7e07a92bb2dbf1e84508c673ca3bd\"\n dependencies = [\n  \"atty\",\n  \"bitflags\",\n@@ -636,9 +607,9 @@ dependencies = [\n \n [[package]]\n name = \"clap_derive\"\n-version = \"3.2.5\"\n+version = \"3.2.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c11d40217d16aee8508cc8e5fde8b4ff24639758608e5374e731b53f85749fb9\"\n+checksum = \"ea0c8bce528c4be4da13ea6fead8965e95b6073585a2f05204bd8f4119f82a65\"\n dependencies = [\n  \"heck\",\n  \"proc-macro-error\",\n@@ -727,6 +698,7 @@ version = \"0.1.65\"\n dependencies = [\n  \"arrayvec\",\n  \"if_chain\",\n+ \"itertools\",\n  \"rustc-semver\",\n ]\n \n@@ -770,9 +742,9 @@ dependencies = [\n \n [[package]]\n name = \"combine\"\n-version = \"4.6.3\"\n+version = \"4.6.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"50b727aacc797f9fc28e355d21f34709ac4fc9adecfe470ad07b8f4464f53062\"\n+checksum = \"35ed6e9d84f0b51a7f52daf1c7d71dd136fd7a3f41a8462b8cdb8c78d920fad4\"\n dependencies = [\n  \"bytes\",\n  \"memchr\",\n@@ -1010,7 +982,7 @@ version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a4600d695eb3f6ce1cd44e6e291adceb2cc3ab12f20a33777ecd0bf6eba34e06\"\n dependencies = [\n- \"generic-array 0.14.4\",\n+ \"generic-array\",\n ]\n \n [[package]]\n@@ -1035,16 +1007,6 @@ dependencies = [\n  \"quote\",\n ]\n \n-[[package]]\n-name = \"ctor\"\n-version = \"0.1.22\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f877be4f7c9f246b183111634f75baa039715e3f46ce860677d3b19a69fb229c\"\n-dependencies = [\n- \"quote\",\n- \"syn\",\n-]\n-\n [[package]]\n name = \"curl\"\n version = \"0.4.43\"\n@@ -1105,22 +1067,13 @@ version = \"2.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n \n-[[package]]\n-name = \"digest\"\n-version = \"0.8.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f3d0c8c8752312f9713efd397ff63acb9f85585afbf179282e720e7704954dd5\"\n-dependencies = [\n- \"generic-array 0.12.4\",\n-]\n-\n [[package]]\n name = \"digest\"\n version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8cb780dce4f9a8f5c087362b3a4595936b2019e7c8b30f2c3e9a7e94e6ae9837\"\n dependencies = [\n- \"block-buffer 0.10.2\",\n+ \"block-buffer\",\n  \"crypto-common\",\n ]\n \n@@ -1268,7 +1221,7 @@ dependencies = [\n name = \"error_index_generator\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustdoc\",\n+ \"mdbook\",\n ]\n \n [[package]]\n@@ -1299,12 +1252,6 @@ dependencies = [\n  \"once_cell\",\n ]\n \n-[[package]]\n-name = \"fake-simd\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n-\n [[package]]\n name = \"fallible-iterator\"\n version = \"0.2.0\"\n@@ -1419,9 +1366,9 @@ dependencies = [\n \n [[package]]\n name = \"fs-err\"\n-version = \"2.5.0\"\n+version = \"2.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bcd1163ae48bda72a20ae26d66a04d3094135cadab911cff418ae5e33f253431\"\n+checksum = \"64db3e262960f0662f43a6366788d5f10f7f244b8f7d7d987f560baf5ded5c50\"\n \n [[package]]\n name = \"fs_extra\"\n@@ -1538,15 +1485,6 @@ dependencies = [\n  \"termcolor\",\n ]\n \n-[[package]]\n-name = \"generic-array\"\n-version = \"0.12.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ffdf9f34f1447443d37393cc6c2b8313aebddcd96906caf34e54c68d8e57d7bd\"\n-dependencies = [\n- \"typenum\",\n-]\n-\n [[package]]\n name = \"generic-array\"\n version = \"0.14.4\"\n@@ -1681,16 +1619,16 @@ dependencies = [\n \n [[package]]\n name = \"handlebars\"\n-version = \"4.1.0\"\n+version = \"4.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72a0ffab8c36d0436114310c7e10b59b3307e650ddfabf6d006028e29a70c6e6\"\n+checksum = \"360d9740069b2f6cbb63ce2dbaa71a20d3185350cbb990d7bebeb9318415eb17\"\n dependencies = [\n  \"log\",\n  \"pest\",\n  \"pest_derive\",\n- \"quick-error 2.0.0\",\n  \"serde\",\n  \"serde_json\",\n+ \"thiserror\",\n ]\n \n [[package]]\n@@ -1722,12 +1660,13 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.0\"\n+version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1ab7905ea95c6d9af62940f9d7dd9596d54c334ae2c15300c482051292d5637f\"\n+checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n+ \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n@@ -1780,7 +1719,7 @@ version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df004cfca50ef23c36850aaaa59ad52cc70d0e90243c3c7737a4dd32dc7a3c4f\"\n dependencies = [\n- \"quick-error 1.2.3\",\n+ \"quick-error\",\n ]\n \n [[package]]\n@@ -1826,13 +1765,13 @@ dependencies = [\n \n [[package]]\n name = \"im-rc\"\n-version = \"15.0.0\"\n+version = \"15.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ca8957e71f04a205cb162508f9326aea04676c8dfd0711220190d6b83664f3f\"\n+checksum = \"af1955a75fa080c677d3972822ec4bad316169ab1cfc6c257a942c2265dbe5fe\"\n dependencies = [\n  \"bitmaps\",\n- \"rand_core 0.5.1\",\n- \"rand_xoshiro 0.4.0\",\n+ \"rand_core 0.6.2\",\n+ \"rand_xoshiro\",\n  \"sized-chunks\",\n  \"typenum\",\n  \"version_check\",\n@@ -1956,6 +1895,16 @@ dependencies = [\n  \"shlex\",\n ]\n \n+[[package]]\n+name = \"jsondoclint\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"fs-err\",\n+ \"rustdoc-json-types\",\n+ \"serde_json\",\n+]\n+\n [[package]]\n name = \"jsonpath_lib\"\n version = \"0.2.6\"\n@@ -1999,6 +1948,25 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"libffi\"\n+version = \"3.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e454b3efb16fba3b17810ae5e41df02b649e564ab3c5a34b3b93ed07ad287e6\"\n+dependencies = [\n+ \"libc\",\n+ \"libffi-sys\",\n+]\n+\n+[[package]]\n+name = \"libffi-sys\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ab4106b7f09d7b87d021334d5618fac1dfcfb824d4c5fe111ff0074dfd242e15\"\n+dependencies = [\n+ \"cc\",\n+]\n+\n [[package]]\n name = \"libgit2-sys\"\n version = \"0.14.0+1.5.0\"\n@@ -2169,7 +2137,7 @@ version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e6a38fc55c8bbc10058782919516f88826e70320db6d206aebc49611d24216ae\"\n dependencies = [\n- \"digest 0.10.2\",\n+ \"digest\",\n ]\n \n [[package]]\n@@ -2293,6 +2261,8 @@ dependencies = [\n  \"getrandom 0.2.0\",\n  \"lazy_static\",\n  \"libc\",\n+ \"libffi\",\n+ \"libloading\",\n  \"log\",\n  \"measureme\",\n  \"rand 0.8.5\",\n@@ -2395,12 +2365,6 @@ version = \"1.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7709cef83f0c1f58f666e746a08b21e0085f7440fa6a29cc194d68aac97a4225\"\n \n-[[package]]\n-name = \"opaque-debug\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2839e79665f131bdb5782e51f2c6c9599c133c6098982a54c794358bf432529c\"\n-\n [[package]]\n name = \"opener\"\n version = \"0.5.0\"\n@@ -2471,15 +2435,6 @@ version = \"6.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8e22443d1643a904602595ba1cd8f7d896afe56d26712531c5ff73a15b2fbf64\"\n \n-[[package]]\n-name = \"output_vt100\"\n-version = \"0.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"628223faebab4e3e40667ee0b2336d34a5b960ff60ea743ddfdbcf7770bcfb66\"\n-dependencies = [\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"owo-colors\"\n version = \"3.4.0\"\n@@ -2590,28 +2545,29 @@ dependencies = [\n \n [[package]]\n name = \"pest\"\n-version = \"2.1.3\"\n+version = \"2.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"10f4872ae94d7b90ae48754df22fd42ad52ce740b8f370b03da4835417403e53\"\n+checksum = \"4b0560d531d1febc25a3c9398a62a71256c0178f2e3443baedd9ad4bb8c9deb4\"\n dependencies = [\n+ \"thiserror\",\n  \"ucd-trie\",\n ]\n \n [[package]]\n name = \"pest_derive\"\n-version = \"2.1.0\"\n+version = \"2.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"833d1ae558dc601e9a60366421196a8d94bc0ac980476d0b67e1d0988d72b2d0\"\n+checksum = \"905708f7f674518498c1f8d644481440f476d39ca6ecae83319bba7c6c12da91\"\n dependencies = [\n  \"pest\",\n  \"pest_generator\",\n ]\n \n [[package]]\n name = \"pest_generator\"\n-version = \"2.1.3\"\n+version = \"2.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99b8db626e31e5b81787b9783425769681b347011cc59471e33ea46d2ea0cf55\"\n+checksum = \"5803d8284a629cc999094ecd630f55e91b561a1d1ba75e233b00ae13b91a69ad\"\n dependencies = [\n  \"pest\",\n  \"pest_meta\",\n@@ -2622,13 +2578,13 @@ dependencies = [\n \n [[package]]\n name = \"pest_meta\"\n-version = \"2.1.3\"\n+version = \"2.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"54be6e404f5317079812fc8f9f5279de376d8856929e21c184ecf6bbd692a11d\"\n+checksum = \"1538eb784f07615c6d9a8ab061089c6c54a344c5b4301db51990ca1c241e8c04\"\n dependencies = [\n- \"maplit\",\n+ \"once_cell\",\n  \"pest\",\n- \"sha-1 0.8.2\",\n+ \"sha-1\",\n ]\n \n [[package]]\n@@ -2720,18 +2676,6 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"925383efa346730478fb4838dbe9137d2a47675ad789c546d150a6e1dd4ab31c\"\n \n-[[package]]\n-name = \"pretty_assertions\"\n-version = \"1.2.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c89f989ac94207d048d92db058e4f6ec7342b0971fc58d1271ca148b799b3563\"\n-dependencies = [\n- \"ansi_term\",\n- \"ctor\",\n- \"diff\",\n- \"output_vt100\",\n-]\n-\n [[package]]\n name = \"pretty_env_logger\"\n version = \"0.4.0\"\n@@ -2830,12 +2774,6 @@ version = \"1.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0\"\n \n-[[package]]\n-name = \"quick-error\"\n-version = \"2.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ac73b1112776fc109b2e61909bc46c7e1bf0d7f690ffb1676553acce16d5cda\"\n-\n [[package]]\n name = \"quine-mc_cluskey\"\n version = \"0.2.4\"\n@@ -2931,15 +2869,6 @@ dependencies = [\n  \"rand_core 0.5.1\",\n ]\n \n-[[package]]\n-name = \"rand_xoshiro\"\n-version = \"0.4.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a9fcdd2e881d02f1d9390ae47ad8e5696a9e4be7b547a1da2afbc61973217004\"\n-dependencies = [\n- \"rand_core 0.5.1\",\n-]\n-\n [[package]]\n name = \"rand_xoshiro\"\n version = \"0.6.0\"\n@@ -3172,7 +3101,6 @@ dependencies = [\n  \"bstr\",\n  \"clap\",\n  \"libz-sys\",\n- \"memchr\",\n  \"regex\",\n  \"serde_json\",\n  \"syn\",\n@@ -3207,6 +3135,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"smallvec\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -3228,6 +3157,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -3322,6 +3252,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -3332,7 +3263,6 @@ dependencies = [\n  \"bitflags\",\n  \"cstr\",\n  \"libc\",\n- \"libloading\",\n  \"measureme\",\n  \"object 0.29.0\",\n  \"rustc-demangle\",\n@@ -3446,6 +3376,7 @@ dependencies = [\n  \"stable_deref_trait\",\n  \"stacker\",\n  \"tempfile\",\n+ \"thin-vec\",\n  \"tracing\",\n  \"winapi\",\n ]\n@@ -3514,6 +3445,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n+ \"rustc_target\",\n  \"serde\",\n  \"serde_json\",\n  \"termcolor\",\n@@ -3807,7 +3739,7 @@ dependencies = [\n  \"gsgdt\",\n  \"polonius-engine\",\n  \"rand 0.8.5\",\n- \"rand_xoshiro 0.6.0\",\n+ \"rand_xoshiro\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n  \"rustc_apfloat\",\n@@ -3828,6 +3760,7 @@ dependencies = [\n  \"rustc_target\",\n  \"rustc_type_ir\",\n  \"smallvec\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -4017,6 +3950,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -4038,7 +3972,9 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"smallvec\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -4094,6 +4030,7 @@ dependencies = [\n  \"indexmap\",\n  \"rustc_macros\",\n  \"smallvec\",\n+ \"thin-vec\",\n ]\n \n [[package]]\n@@ -4142,7 +4079,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"scoped-tls\",\n- \"sha-1 0.10.0\",\n+ \"sha-1\",\n  \"sha2\",\n  \"tracing\",\n  \"unicode-width\",\n@@ -4172,6 +4109,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n  \"rustc_data_structures\",\n+ \"rustc_feature\",\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n@@ -4234,6 +4172,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"itertools\",\n  \"rustc_data_structures\",\n+ \"rustc_hir\",\n  \"rustc_infer\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n@@ -4330,6 +4269,7 @@ dependencies = [\n  \"serde_json\",\n  \"smallvec\",\n  \"tempfile\",\n+ \"thin-vec\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n@@ -4519,28 +4459,16 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.83\"\n+version = \"1.0.85\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"38dd04e3c8279e75b31ef29dbdceebfe5ad89f4d0937213c53f7d49d01b3d5a7\"\n+checksum = \"e55a28e3aaef9d5ce0506d0a14dbba8054ddc7e499ef522dd8b26859ec9d4a44\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\",\n  \"ryu\",\n  \"serde\",\n ]\n \n-[[package]]\n-name = \"sha-1\"\n-version = \"0.8.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f7d94d0bede923b3cea61f3f1ff57ff8cdfd77b400fb8f9998949e0cf04163df\"\n-dependencies = [\n- \"block-buffer 0.7.3\",\n- \"digest 0.8.1\",\n- \"fake-simd\",\n- \"opaque-debug\",\n-]\n-\n [[package]]\n name = \"sha-1\"\n version = \"0.10.0\"\n@@ -4549,7 +4477,7 @@ checksum = \"028f48d513f9678cda28f6e4064755b3fbb2af6acd672f2c209b62323f7aea0f\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n  \"cpufeatures\",\n- \"digest 0.10.2\",\n+ \"digest\",\n ]\n \n [[package]]\n@@ -4560,7 +4488,7 @@ checksum = \"99c3bd8169c58782adad9290a9af5939994036b76187f7b4f0e6de91dbbfc0ec\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n  \"cpufeatures\",\n- \"digest 0.10.2\",\n+ \"digest\",\n ]\n \n [[package]]\n@@ -4689,13 +4617,13 @@ version = \"0.0.0\"\n dependencies = [\n  \"addr2line 0.16.0\",\n  \"alloc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n  \"hashbrown\",\n- \"hermit-abi 0.2.0\",\n+ \"hermit-abi 0.2.6\",\n  \"libc\",\n  \"miniz_oxide 0.4.0\",\n  \"object 0.26.2\",\n@@ -4713,7 +4641,7 @@ dependencies = [\n name = \"std_detect\"\n version = \"0.1.5\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"libc\",\n  \"rustc-std-workspace-alloc\",\n@@ -4883,20 +4811,26 @@ version = \"0.15.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b1141d4d61095b28419e22cb0bbf02755f5e54e0526f97f1e3d1d160e60885fb\"\n \n+[[package]]\n+name = \"thin-vec\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"104c2cb3180b6fb6d5b2278768e9b88b578d32ba751ea6e8d026688a40d7ed87\"\n+\n [[package]]\n name = \"thiserror\"\n-version = \"1.0.30\"\n+version = \"1.0.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"854babe52e4df1653706b98fcfc05843010039b406875930a70e4d9644e5c417\"\n+checksum = \"3d0a539a918745651435ac7db7a18761589a94cd7e94cd56999f828bf73c8a57\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.30\"\n+version = \"1.0.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"aa32fd3f627f367fe16f893e2597ae3c05020f8bba2666a4e6ea73d377e5714b\"\n+checksum = \"c251e90f708e16c49a16f4917dc2131e75222b72edfa9cb7f7c58ae56aae0c09\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -4956,9 +4890,18 @@ checksum = \"29738eedb4388d9ea620eeab9384884fc3f06f586a2eddb56bedc5885126c7c1\"\n \n [[package]]\n name = \"tinyvec\"\n-version = \"0.3.4\"\n+version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"238ce071d267c5710f9d31451efec16c5ee22de34df17cc05e56cbc92e967117\"\n+checksum = \"87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50\"\n+dependencies = [\n+ \"tinyvec_macros\",\n+]\n+\n+[[package]]\n+name = \"tinyvec_macros\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cda74da7e1a664f795bb1f8a87ec406fb89a02522cf6e50620d016add6dbbf5c\"\n \n [[package]]\n name = \"tokio\"\n@@ -5119,14 +5062,16 @@ checksum = \"56dee185309b50d1f11bfedef0fe6d036842e3fb77413abef29f8f8d1c5d4c1c\"\n \n [[package]]\n name = \"ui_test\"\n-version = \"0.1.0\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7d1f546a5883ae78da735bba529ec1116661e2f73582f23920d994dc97da3a22\"\n dependencies = [\n  \"cargo_metadata 0.15.0\",\n  \"color-eyre\",\n  \"colored\",\n  \"crossbeam\",\n+ \"diff\",\n  \"lazy_static\",\n- \"pretty_assertions\",\n  \"regex\",\n  \"rustc_version\",\n  \"serde\",\n@@ -5244,40 +5189,40 @@ dependencies = [\n \n [[package]]\n name = \"unicode-normalization\"\n-version = \"0.1.13\"\n+version = \"0.1.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6fb19cf769fa8c6a80a162df694621ebeb4dafb606470b2b2fce0be40a98a977\"\n+checksum = \"5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921\"\n dependencies = [\n  \"tinyvec\",\n ]\n \n [[package]]\n name = \"unicode-script\"\n-version = \"0.5.3\"\n+version = \"0.5.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"098ec66172ce21cd55f8bcc786ee209dd20e04eff70acfca30cb79924d173ae9\"\n+checksum = \"7d817255e1bed6dfd4ca47258685d14d2bdcfbc64fdc9e3819bd5848057b8ecc\"\n \n [[package]]\n name = \"unicode-security\"\n-version = \"0.0.5\"\n+version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5d87c28edc5b263377e448d6cdcb935c06b95413d8013ba6fae470558ccab18f\"\n+checksum = \"9ef5756b3097992b934b06608c69f48448a0fbe804bb1e72b982f6d7983e9e63\"\n dependencies = [\n  \"unicode-normalization\",\n  \"unicode-script\",\n ]\n \n [[package]]\n name = \"unicode-segmentation\"\n-version = \"1.9.0\"\n+version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7e8820f5d777f6224dc4be3632222971ac30164d4a258d595640799554ebfd99\"\n+checksum = \"0fdbf052a0783de01e944a6ce7a8cb939e295b1e7be835a1112c3b9a7f047a5a\"\n \n [[package]]\n name = \"unicode-width\"\n-version = \"0.1.8\"\n+version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9337591893a19b88d8d87f2cec1e73fad5cdfd10e5a6f349f498ad6ea2ffb1e3\"\n+checksum = \"c0edd1e5b14653f783770bce4a4dabb4a5108a5370a5f5d8cfe8710c361f6c8b\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -5286,9 +5231,9 @@ dependencies = [\n \n [[package]]\n name = \"unicode-xid\"\n-version = \"0.2.2\"\n+version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8ccb82d61f80a663efe1f787a51b16b5a51e3314d6ac365b08639f52387b33f3\"\n+checksum = \"f962df74c8c05a667b5ee8bcf162993134c104e96440b663c8daa176dc772d8c\"\n \n [[package]]\n name = \"unicode_categories\""}, {"sha": "e49fe5e2f6356b302552384d5b0b7a3d7e8aa8e0", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -33,6 +33,7 @@ members = [\n   \"src/tools/unicode-table-generator\",\n   \"src/tools/expand-yaml-anchors\",\n   \"src/tools/jsondocck\",\n+  \"src/tools/jsondoclint\",\n   \"src/tools/html-checker\",\n   \"src/tools/bump-stage0\",\n   \"src/tools/replace-version-placeholder\","}, {"sha": "27e7145c5a99e4afadff029b4685473f0423ac5f", "filename": "README.md", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -22,7 +22,7 @@ Read [\"Installation\"] from [The Book].\n ## Installing from Source\n \n The Rust build system uses a Python script called `x.py` to build the compiler,\n-which manages the bootstrapping process. It lives in the root of the project.\n+which manages the bootstrapping process. It lives at the root of the project.\n \n The `x.py` command can be run directly on most systems in the following format:\n \n@@ -32,7 +32,7 @@ The `x.py` command can be run directly on most systems in the following format:\n \n This is how the documentation and examples assume you are running `x.py`.\n \n-Systems such as Ubuntu 20.04 LTS do not create the necessary `python` command by default when Python is installed that allows `x.py` to be run directly. In that case you can either create a symlink for `python` (Ubuntu provides the `python-is-python3` package for this), or run `x.py` using Python itself:\n+Systems such as Ubuntu 20.04 LTS do not create the necessary `python` command by default when Python is installed that allows `x.py` to be run directly. In that case, you can either create a symlink for `python` (Ubuntu provides the `python-is-python3` package for this), or run `x.py` using Python itself:\n \n ```sh\n # Python 3\n@@ -103,22 +103,21 @@ by running it with the `--help` flag or reading the [rustc dev guide][rustcguide\n ### Building on Windows\n \n There are two prominent ABIs in use on Windows: the native (MSVC) ABI used by\n-Visual Studio, and the GNU ABI used by the GCC toolchain. Which version of Rust\n-you need depends largely on what C/C++ libraries you want to interoperate with:\n-for interop with software produced by Visual Studio use the MSVC build of Rust;\n-for interop with GNU software built using the MinGW/MSYS2 toolchain use the GNU\n-build.\n+Visual Studio and the GNU ABI used by the GCC toolchain. Which version of Rust\n+you need depends largely on what C/C++ libraries you want to interoperate with.\n+Use the MSVC build of Rust to interop with software produced by Visual Studio and\n+the GNU build to interop with GNU software built using the MinGW/MSYS2 toolchain.\n \n #### MinGW\n \n [MSYS2][msys2] can be used to easily build Rust on Windows:\n \n [msys2]: https://www.msys2.org/\n \n-1. Grab the latest [MSYS2 installer][msys2] and go through the installer.\n+1. Download the latest [MSYS2 installer][msys2] and go through the installer.\n \n-2. Run `mingw32_shell.bat` or `mingw64_shell.bat` from wherever you installed\n-   MSYS2 (i.e. `C:\\msys64`), depending on whether you want 32-bit or 64-bit\n+2. Run `mingw32_shell.bat` or `mingw64_shell.bat` from the MSYS2 installation\n+   directory (e.g. `C:\\msys64`), depending on whether you want 32-bit or 64-bit\n    Rust. (As of the latest version of MSYS2 you have to run `msys2_shell.cmd\n    -mingw32` or `msys2_shell.cmd -mingw64` from the command line instead)\n \n@@ -168,7 +167,7 @@ shell with:\n python x.py build\n ```\n \n-Currently, building Rust only works with some known versions of Visual Studio. If\n+Right now, building Rust only works with some known versions of Visual Studio. If\n you have a more recent version installed and the build system doesn't understand,\n you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n@@ -225,7 +224,7 @@ the ABI used. I.e., if the ABI was `x86_64-pc-windows-msvc`, the directory will\n \n Since the Rust compiler is written in Rust, it must be built by a\n precompiled \"snapshot\" version of itself (made in an earlier stage of\n-development). As such, source builds require a connection to the Internet, to\n+development). As such, source builds require an Internet connection to\n fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n Snapshot binaries are currently built and tested on several platforms:"}, {"sha": "694bd09658f75e31e98f668e0820f79e583bff29", "filename": "RELEASES.md", "status": "modified", "additions": 145, "deletions": 2, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,3 +1,144 @@\n+Version 1.64.0 (2022-09-22)\n+===========================\n+\n+Language\n+--------\n+- [Unions with mutable references or tuples of allowed types are now allowed](https://github.com/rust-lang/rust/pull/97995/)\n+- It is now considered valid to deallocate memory pointed to by a shared reference `&T` [if every byte in `T` is inside an `UnsafeCell`](https://github.com/rust-lang/rust/pull/98017/)\n+- Unused tuple struct fields are now warned against in an allow-by-default lint, [`unused_tuple_struct_fields`](https://github.com/rust-lang/rust/pull/95977/), similar to the existing warning for unused struct fields. This lint will become warn-by-default in the future.\n+\n+Compiler\n+--------\n+- [Add Nintendo Switch as tier 3 target](https://github.com/rust-lang/rust/pull/88991/)\n+  - Refer to Rust's [platform support page][platform-support-doc] for more\n+    information on Rust's tiered platform support.\n+- [Only compile `#[used]` as llvm.compiler.used for ELF targets](https://github.com/rust-lang/rust/pull/93718/)\n+- [Add the `--diagnostic-width` compiler flag to define the terminal width.](https://github.com/rust-lang/rust/pull/95635/)\n+- [Add support for link-flavor `rust-lld` for iOS, tvOS and watchOS](https://github.com/rust-lang/rust/pull/98771/)\n+\n+Libraries\n+---------\n+- [Remove restrictions on compare-exchange memory ordering.](https://github.com/rust-lang/rust/pull/98383/)\n+- You can now `write!` or `writeln!` into an `OsString`: [Implement `fmt::Write` for `OsString`](https://github.com/rust-lang/rust/pull/97915/)\n+- [Make RwLockReadGuard covariant](https://github.com/rust-lang/rust/pull/96820/)\n+- [Implement `FusedIterator` for `std::net::[Into]Incoming`](https://github.com/rust-lang/rust/pull/97300/)\n+- [`impl<T: AsRawFd> AsRawFd for {Arc,Box}<T>`](https://github.com/rust-lang/rust/pull/97437/)\n+- [`ptr::copy` and `ptr::swap` are doing untyped copies](https://github.com/rust-lang/rust/pull/97712/)\n+- [Add cgroupv1 support to `available_parallelism`](https://github.com/rust-lang/rust/pull/97925/)\n+- [Mitigate many incorrect uses of `mem::uninitialized`](https://github.com/rust-lang/rust/pull/99182/)\n+\n+Stabilized APIs\n+---------------\n+\n+- [`future::IntoFuture`](https://doc.rust-lang.org/stable/std/future/trait.IntoFuture.html)\n+- [`future::poll_fn`](https://doc.rust-lang.org/stable/std/future/fn.poll_fn.html)\n+- [`task::ready!`](https://doc.rust-lang.org/stable/std/task/macro.ready.html)\n+- [`num::NonZero*::checked_mul`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_mul)\n+- [`num::NonZero*::checked_pow`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_pow)\n+- [`num::NonZero*::saturating_mul`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_mul)\n+- [`num::NonZero*::saturating_pow`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_pow)\n+- [`num::NonZeroI*::abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.abs)\n+- [`num::NonZeroI*::checked_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.checked_abs)\n+- [`num::NonZeroI*::overflowing_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.overflowing_abs)\n+- [`num::NonZeroI*::saturating_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.saturating_abs)\n+- [`num::NonZeroI*::unsigned_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.unsigned_abs)\n+- [`num::NonZeroI*::wrapping_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.wrapping_abs)\n+- [`num::NonZeroU*::checked_add`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_add)\n+- [`num::NonZeroU*::checked_next_power_of_two`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_next_power_of_two)\n+- [`num::NonZeroU*::saturating_add`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_add)\n+- [`os::unix::process::CommandExt::process_group`](https://doc.rust-lang.org/stable/std/os/unix/process/trait.CommandExt.html#tymethod.process_group)\n+- [`os::windows::fs::FileTypeExt::is_symlink_dir`](https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_dir)\n+- [`os::windows::fs::FileTypeExt::is_symlink_file`](https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_file)\n+\n+These types were previously stable in `std::ffi`, but are now also available in `core` and `alloc`:\n+\n+- [`core::ffi::CStr`](https://doc.rust-lang.org/stable/core/ffi/struct.CStr.html)\n+- [`core::ffi::FromBytesWithNulError`](https://doc.rust-lang.org/stable/core/ffi/struct.FromBytesWithNulError.html)\n+- [`alloc::ffi::CString`](https://doc.rust-lang.org/stable/alloc/ffi/struct.CString.html)\n+- [`alloc::ffi::FromVecWithNulError`](https://doc.rust-lang.org/stable/alloc/ffi/struct.FromVecWithNulError.html)\n+- [`alloc::ffi::IntoStringError`](https://doc.rust-lang.org/stable/alloc/ffi/struct.IntoStringError.html)\n+- [`alloc::ffi::NulError`](https://doc.rust-lang.org/stable/alloc/ffi/struct.NulError.html)\n+\n+These types were previously stable in `std::os::raw`, but are now also available in `core::ffi` and `std::ffi`:\n+\n+- [`ffi::c_char`](https://doc.rust-lang.org/stable/std/ffi/type.c_char.html)\n+- [`ffi::c_double`](https://doc.rust-lang.org/stable/std/ffi/type.c_double.html)\n+- [`ffi::c_float`](https://doc.rust-lang.org/stable/std/ffi/type.c_float.html)\n+- [`ffi::c_int`](https://doc.rust-lang.org/stable/std/ffi/type.c_int.html)\n+- [`ffi::c_long`](https://doc.rust-lang.org/stable/std/ffi/type.c_long.html)\n+- [`ffi::c_longlong`](https://doc.rust-lang.org/stable/std/ffi/type.c_longlong.html)\n+- [`ffi::c_schar`](https://doc.rust-lang.org/stable/std/ffi/type.c_schar.html)\n+- [`ffi::c_short`](https://doc.rust-lang.org/stable/std/ffi/type.c_short.html)\n+- [`ffi::c_uchar`](https://doc.rust-lang.org/stable/std/ffi/type.c_uchar.html)\n+- [`ffi::c_uint`](https://doc.rust-lang.org/stable/std/ffi/type.c_uint.html)\n+- [`ffi::c_ulong`](https://doc.rust-lang.org/stable/std/ffi/type.c_ulong.html)\n+- [`ffi::c_ulonglong`](https://doc.rust-lang.org/stable/std/ffi/type.c_ulonglong.html)\n+- [`ffi::c_ushort`](https://doc.rust-lang.org/stable/std/ffi/type.c_ushort.html)\n+\n+These APIs are now usable in const contexts:\n+\n+- [`slice::from_raw_parts`](https://doc.rust-lang.org/stable/core/slice/fn.from_raw_parts.html)\n+\n+Cargo\n+-----\n+- [Packages can now inherit settings from the workspace so that the settings\n+  can be centralized in one place.](https://github.com/rust-lang/cargo/pull/10859) See\n+  [`workspace.package`](https://doc.rust-lang.org/nightly/cargo/reference/workspaces.html#the-workspacepackage-table)\n+  and\n+  [`workspace.dependencies`](https://doc.rust-lang.org/nightly/cargo/reference/workspaces.html#the-workspacedependencies-table)\n+  for more details on how to define these common settings.\n+- [Cargo commands can now accept multiple `--target` flags to build for\n+  multiple targets at once](https://github.com/rust-lang/cargo/pull/10766), and the\n+  [`build.target`](https://doc.rust-lang.org/nightly/cargo/reference/config.html#buildtarget)\n+  config option may now take an array of multiple targets.\n+- [The `--jobs` argument can now take a negative number to count backwards from\n+  the max CPUs.](https://github.com/rust-lang/cargo/pull/10844)\n+- [`cargo add` will now update `Cargo.lock`.](https://github.com/rust-lang/cargo/pull/10902)\n+- [Added](https://github.com/rust-lang/cargo/pull/10838) the\n+  [`--crate-type`](https://doc.rust-lang.org/nightly/cargo/commands/cargo-rustc.html#option-cargo-rustc---crate-type)\n+  flag to `cargo rustc` to override the crate type.\n+- [Significantly improved the performance fetching git dependencies from GitHub\n+  when using a hash in the `rev` field.](https://github.com/rust-lang/cargo/pull/10079)\n+\n+Misc\n+----\n+- [The `rust-analyzer` rustup component is now available on the stable channel.](https://github.com/rust-lang/rust/pull/98640/)\n+\n+Compatibility Notes\n+-------------------\n+- The minimum required versions for all `-linux-gnu` targets are now at least kernel 3.2 and glibc 2.17, for targets that previously supported older versions: [Increase the minimum linux-gnu versions](https://github.com/rust-lang/rust/pull/95026/)\n+- [Network primitives are now implemented with the ideal Rust layout, not the C system layout](https://github.com/rust-lang/rust/pull/78802/). This can cause problems when transmuting the types.\n+- [Add assertion that `transmute_copy`'s `U` is not larger than `T`](https://github.com/rust-lang/rust/pull/98839/)\n+- [A soundness bug in `BTreeMap` was fixed](https://github.com/rust-lang/rust/pull/99413/) that allowed data it was borrowing to be dropped before the container.\n+- [The Drop behavior of C-like enums cast to ints has changed](https://github.com/rust-lang/rust/pull/96862/). These are already discouraged by a compiler warning.\n+- [Relate late-bound closure lifetimes to parent fn in NLL](https://github.com/rust-lang/rust/pull/98835/)\n+- [Errors at const-eval time are now in future incompatibility reports](https://github.com/rust-lang/rust/pull/97743/)\n+- On the `thumbv6m-none-eabi` target, some incorrect `asm!` statements were erroneously accepted if they used the high registers (r8 to r14) as an input/output operand. [This is no longer accepted](https://github.com/rust-lang/rust/pull/99155/).\n+- [`impl Trait` was accidentally accepted as the associated type value of return-position `impl Trait`](https://github.com/rust-lang/rust/pull/97346/), without fulfilling all the trait bounds of that associated type, as long as the hidden type satisfies said bounds. This has been fixed.\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- Windows builds now use profile-guided optimization, providing 10-20% improvements to compiler performance: [Utilize PGO for windows x64 rustc dist builds](https://github.com/rust-lang/rust/pull/96978/)\n+- [Stop keeping metadata in memory before writing it to disk](https://github.com/rust-lang/rust/pull/96544/)\n+- [compiletest: strip debuginfo by default for mode=ui](https://github.com/rust-lang/rust/pull/98140/)\n+- Many improvements to generated code for derives, including performance improvements:\n+  - [Don't use match-destructuring for derived ops on structs.](https://github.com/rust-lang/rust/pull/98446/)\n+  - [Many small deriving cleanups](https://github.com/rust-lang/rust/pull/98741/)\n+  - [More derive output improvements](https://github.com/rust-lang/rust/pull/98758/)\n+  - [Clarify deriving code](https://github.com/rust-lang/rust/pull/98915/)\n+  - [Final derive output improvements](https://github.com/rust-lang/rust/pull/99046/)\n+  - [Stop injecting `#[allow(unused_qualifications)]` in generated `derive` implementations](https://github.com/rust-lang/rust/pull/99485/)\n+  - [Improve `derive(Debug)`](https://github.com/rust-lang/rust/pull/98190/)\n+- [Bump to clap 3](https://github.com/rust-lang/rust/pull/98213/)\n+- [fully move dropck to mir](https://github.com/rust-lang/rust/pull/98641/)\n+- [Optimize `Vec::insert` for the case where `index == len`.](https://github.com/rust-lang/rust/pull/98755/)\n+- [Convert rust-analyzer to an in-tree tool](https://github.com/rust-lang/rust/pull/99603/)\n+\n Version 1.63.0 (2022-08-11)\n ==========================\n \n@@ -217,6 +358,7 @@ Language\n - [Fix constants not getting dropped if part of a diverging expression][94775]\n - [Support unit struct/enum variant in destructuring assignment][95380]\n - [Remove mutable_borrow_reservation_conflict lint and allow the code pattern][96268]\n+- [`const` functions may now specify `extern \"C\"` or `extern \"Rust\"`][95346]\n \n Compiler\n --------\n@@ -306,6 +448,7 @@ and related tools.\n [94872]: https://github.com/rust-lang/rust/pull/94872/\n [95006]: https://github.com/rust-lang/rust/pull/95006/\n [95035]: https://github.com/rust-lang/rust/pull/95035/\n+[95346]: https://github.com/rust-lang/rust/pull/95346/\n [95372]: https://github.com/rust-lang/rust/pull/95372/\n [95380]: https://github.com/rust-lang/rust/pull/95380/\n [95431]: https://github.com/rust-lang/rust/pull/95431/\n@@ -1442,7 +1585,7 @@ Compatibility Notes\n - [Mixing Option and Result via `?` is no longer permitted in closures for inferred types.][86831]\n - [Previously unsound code is no longer permitted where different constructors in branches\n   could require different lifetimes.][85574]\n-- As previously mentioned the [`std::arch` instrinsics now uses stricter const checking][83278]\n+- As previously mentioned the [`std::arch` intrinsics now uses stricter const checking][83278]\n   than before and may reject some previously accepted code.\n - [`i128` multiplication on Cortex M0+ platforms currently unconditionally causes overflow\n    when compiled with `codegen-units = 1`.][86063]\n@@ -2520,7 +2663,7 @@ Compatibility Notes\n - [Fixed a regression parsing `{} && false` in tail expressions.][74650]\n - [Added changes to how proc-macros are expanded in `macro_rules!` that should\n   help to preserve more span information.][73084] These changes may cause\n-  compiliation errors if your macro was unhygenic or didn't correctly handle\n+  compilation errors if your macro was unhygenic or didn't correctly handle\n   `Delimiter::None`.\n - [Moved support for the CloudABI target to tier 3.][75568]\n - [`linux-gnu` targets now require minimum kernel 2.6.32 and glibc 2.11.][74163]"}, {"sha": "c24180bacfc1b05207ebfbc0b7ccbfd06a558678", "filename": "compiler/rustc_ast/Cargo.toml", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2FCargo.toml?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -7,12 +7,13 @@ edition = \"2021\"\n doctest = false\n \n [dependencies]\n-rustc_serialize = { path = \"../rustc_serialize\" }\n-tracing = \"0.1\"\n-rustc_span = { path = \"../rustc_span\" }\n+bitflags = \"1.2.1\"\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_macros = { path = \"../rustc_macros\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_span = { path = \"../rustc_span\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-bitflags = \"1.2.1\"\n+thin-vec = \"0.2.8\"\n+tracing = \"0.1\""}, {"sha": "0efde1e7b212443f1879d998d795628437f759b0", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 90, "deletions": 85, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -24,22 +24,19 @@ pub use UnsafeSource::*;\n \n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter};\n-use crate::tokenstream::{DelimSpan, LazyTokenStream, TokenStream};\n-\n+use crate::tokenstream::{DelimSpan, LazyAttrTokenStream, TokenStream};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n-\n-use std::cmp::Ordering;\n use std::convert::TryFrom;\n use std::fmt;\n use std::mem;\n+use thin_vec::ThinVec;\n \n /// A \"Label\" is an identifier of some point in sources,\n /// e.g. in the following code:\n@@ -94,7 +91,7 @@ pub struct Path {\n     /// The segments in the path: the things separated by `::`.\n     /// Global paths begin with `kw::PathRoot`.\n     pub segments: Vec<PathSegment>,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n impl PartialEq<Symbol> for Path {\n@@ -326,46 +323,17 @@ pub type GenericBounds = Vec<GenericBound>;\n /// Specifies the enforced ordering for generic parameters. In the future,\n /// if we wanted to relax this order, we could override `PartialEq` and\n /// `PartialOrd`, to allow the kinds to be unordered.\n-#[derive(Hash, Clone, Copy)]\n+#[derive(Hash, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub enum ParamKindOrd {\n     Lifetime,\n-    Type,\n-    Const,\n-    // `Infer` is not actually constructed directly from the AST, but is implicitly constructed\n-    // during HIR lowering, and `ParamKindOrd` will implicitly order inferred variables last.\n-    Infer,\n-}\n-\n-impl Ord for ParamKindOrd {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        use ParamKindOrd::*;\n-        let to_int = |v| match v {\n-            Lifetime => 0,\n-            Infer | Type | Const => 1,\n-        };\n-\n-        to_int(*self).cmp(&to_int(*other))\n-    }\n-}\n-impl PartialOrd for ParamKindOrd {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-impl PartialEq for ParamKindOrd {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.cmp(other) == Ordering::Equal\n-    }\n+    TypeOrConst,\n }\n-impl Eq for ParamKindOrd {}\n \n impl fmt::Display for ParamKindOrd {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ParamKindOrd::Lifetime => \"lifetime\".fmt(f),\n-            ParamKindOrd::Type => \"type\".fmt(f),\n-            ParamKindOrd::Const { .. } => \"const\".fmt(f),\n-            ParamKindOrd::Infer => \"infer\".fmt(f),\n+            ParamKindOrd::TypeOrConst => \"type and const\".fmt(f),\n         }\n     }\n }\n@@ -566,7 +534,7 @@ pub struct Block {\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n     pub span: Span,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n     /// The following *isn't* a parse error, but will cause multiple errors in following stages.\n     /// ```compile_fail\n     /// let x = {\n@@ -585,7 +553,7 @@ pub struct Pat {\n     pub id: NodeId,\n     pub kind: PatKind,\n     pub span: Span,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n impl Pat {\n@@ -596,7 +564,7 @@ impl Pat {\n             // In a type expression `_` is an inference variable.\n             PatKind::Wild => TyKind::Infer,\n             // An IDENT pattern with no binding mode would be valid as path to a type. E.g. `u32`.\n-            PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None) => {\n+            PatKind::Ident(BindingAnnotation::NONE, ident, None) => {\n                 TyKind::Path(None, Path::from_ident(*ident))\n             }\n             PatKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n@@ -683,10 +651,43 @@ pub struct PatField {\n     pub is_placeholder: bool,\n }\n \n-#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n-pub enum BindingMode {\n-    ByRef(Mutability),\n-    ByValue(Mutability),\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n+pub enum ByRef {\n+    Yes,\n+    No,\n+}\n+\n+impl From<bool> for ByRef {\n+    fn from(b: bool) -> ByRef {\n+        match b {\n+            false => ByRef::No,\n+            true => ByRef::Yes,\n+        }\n+    }\n+}\n+\n+/// Explicit binding annotations given in the HIR for a binding. Note\n+/// that this is not the final binding *mode* that we infer after type\n+/// inference.\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n+pub struct BindingAnnotation(pub ByRef, pub Mutability);\n+\n+impl BindingAnnotation {\n+    pub const NONE: Self = Self(ByRef::No, Mutability::Not);\n+    pub const REF: Self = Self(ByRef::Yes, Mutability::Not);\n+    pub const MUT: Self = Self(ByRef::No, Mutability::Mut);\n+    pub const REF_MUT: Self = Self(ByRef::Yes, Mutability::Mut);\n+\n+    pub fn prefix_str(self) -> &'static str {\n+        match self {\n+            Self::NONE => \"\",\n+            Self::REF => \"ref \",\n+            Self::MUT => \"mut \",\n+            Self::REF_MUT => \"ref mut \",\n+        }\n+    }\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -715,7 +716,7 @@ pub enum PatKind {\n     /// or a unit struct/variant pattern, or a const pattern (in the last two cases the third\n     /// field must be `None`). Disambiguation cannot be done with parser alone, so it happens\n     /// during name resolution.\n-    Ident(BindingMode, Ident, Option<P<Pat>>),\n+    Ident(BindingAnnotation, Ident, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -936,8 +937,8 @@ impl Stmt {\n     /// a trailing semicolon.\n     ///\n     /// This only modifies the parsed AST struct, not the attached\n-    /// `LazyTokenStream`. The parser is responsible for calling\n-    /// `CreateTokenStream::add_trailing_semi` when there is actually\n+    /// `LazyAttrTokenStream`. The parser is responsible for calling\n+    /// `ToAttrTokenStream::add_trailing_semi` when there is actually\n     /// a semicolon in the tokenstream.\n     pub fn add_trailing_semicolon(mut self) -> Self {\n         self.kind = match self.kind {\n@@ -983,7 +984,7 @@ pub struct MacCallStmt {\n     pub mac: P<MacCall>,\n     pub style: MacStmtStyle,\n     pub attrs: AttrVec,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n@@ -1008,7 +1009,7 @@ pub struct Local {\n     pub kind: LocalKind,\n     pub span: Span,\n     pub attrs: AttrVec,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -1107,7 +1108,7 @@ pub struct Expr {\n     pub kind: ExprKind,\n     pub span: Span,\n     pub attrs: AttrVec,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n impl Expr {\n@@ -1966,7 +1967,7 @@ pub struct Ty {\n     pub id: NodeId,\n     pub kind: TyKind,\n     pub span: Span,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n impl Clone for Ty {\n@@ -2071,6 +2072,7 @@ impl TyKind {\n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum TraitObjectSyntax {\n     Dyn,\n+    DynStar,\n     None,\n }\n \n@@ -2086,15 +2088,15 @@ pub enum InlineAsmRegOrRegClass {\n bitflags::bitflags! {\n     #[derive(Encodable, Decodable, HashStable_Generic)]\n     pub struct InlineAsmOptions: u16 {\n-        const PURE = 1 << 0;\n-        const NOMEM = 1 << 1;\n-        const READONLY = 1 << 2;\n+        const PURE            = 1 << 0;\n+        const NOMEM           = 1 << 1;\n+        const READONLY        = 1 << 2;\n         const PRESERVES_FLAGS = 1 << 3;\n-        const NORETURN = 1 << 4;\n-        const NOSTACK = 1 << 5;\n-        const ATT_SYNTAX = 1 << 6;\n-        const RAW = 1 << 7;\n-        const MAY_UNWIND = 1 << 8;\n+        const NORETURN        = 1 << 4;\n+        const NOSTACK         = 1 << 5;\n+        const ATT_SYNTAX      = 1 << 6;\n+        const RAW             = 1 << 7;\n+        const MAY_UNWIND      = 1 << 8;\n     }\n }\n \n@@ -2230,7 +2232,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n impl Param {\n     /// Attempts to cast parameter to `ExplicitSelf`.\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.kind {\n+        if let PatKind::Ident(BindingAnnotation(ByRef::No, mutbl), ident, _) = self.pat.kind {\n             if ident.name == kw::SelfLower {\n                 return match self.ty.kind {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n@@ -2260,31 +2262,31 @@ impl Param {\n     pub fn from_self(attrs: AttrVec, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty { id: DUMMY_NODE_ID, kind: TyKind::ImplicitSelf, span, tokens: None });\n-        let param = |mutbl, ty| Param {\n+        let (mutbl, ty) = match eself.node {\n+            SelfKind::Explicit(ty, mutbl) => (mutbl, ty),\n+            SelfKind::Value(mutbl) => (mutbl, infer_ty),\n+            SelfKind::Region(lt, mutbl) => (\n+                Mutability::Not,\n+                P(Ty {\n+                    id: DUMMY_NODE_ID,\n+                    kind: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl }),\n+                    span,\n+                    tokens: None,\n+                }),\n+            ),\n+        };\n+        Param {\n             attrs,\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n-                kind: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n+                kind: PatKind::Ident(BindingAnnotation(ByRef::No, mutbl), eself_ident, None),\n                 span,\n                 tokens: None,\n             }),\n             span,\n             ty,\n             id: DUMMY_NODE_ID,\n             is_placeholder: false,\n-        };\n-        match eself.node {\n-            SelfKind::Explicit(ty, mutbl) => param(mutbl, ty),\n-            SelfKind::Value(mutbl) => param(mutbl, infer_ty),\n-            SelfKind::Region(lt, mutbl) => param(\n-                Mutability::Not,\n-                P(Ty {\n-                    id: DUMMY_NODE_ID,\n-                    kind: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl }),\n-                    span,\n-                    tokens: None,\n-                }),\n-            ),\n         }\n     }\n }\n@@ -2336,9 +2338,9 @@ impl Async {\n     }\n \n     /// In this case this is an `async` return, the `NodeId` for the generated `impl Trait` item.\n-    pub fn opt_return_id(self) -> Option<NodeId> {\n+    pub fn opt_return_id(self) -> Option<(NodeId, Span)> {\n         match self {\n-            Async::Yes { return_impl_trait_id, .. } => Some(return_impl_trait_id),\n+            Async::Yes { return_impl_trait_id, span, .. } => Some((return_impl_trait_id, span)),\n             Async::No => None,\n         }\n     }\n@@ -2522,16 +2524,16 @@ impl<S: Encoder> Encodable<S> for AttrId {\n }\n \n impl<D: Decoder> Decodable<D> for AttrId {\n-    fn decode(_: &mut D) -> AttrId {\n-        crate::attr::mk_attr_id()\n+    default fn decode(_: &mut D) -> AttrId {\n+        panic!(\"cannot decode `AttrId` with `{}`\", std::any::type_name::<D>());\n     }\n }\n \n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct AttrItem {\n     pub path: Path,\n     pub args: MacArgs,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n /// A list of attributes.\n@@ -2551,7 +2553,7 @@ pub struct Attribute {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct NormalAttr {\n     pub item: AttrItem,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -2602,7 +2604,7 @@ impl PolyTraitRef {\n pub struct Visibility {\n     pub kind: VisibilityKind,\n     pub span: Span,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -2688,7 +2690,7 @@ pub struct Item<K = ItemKind> {\n     ///\n     /// Note that the tokens here do not include the outer attributes, but will\n     /// include inner attributes.\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n impl Item {\n@@ -3044,16 +3046,19 @@ mod size_asserts {\n     static_assert_size!(Block, 48);\n     static_assert_size!(Expr, 104);\n     static_assert_size!(ExprKind, 72);\n-    static_assert_size!(Fn, 192);\n+    static_assert_size!(Fn, 184);\n     static_assert_size!(ForeignItem, 96);\n     static_assert_size!(ForeignItemKind, 24);\n+    static_assert_size!(GenericArg, 24);\n     static_assert_size!(GenericBound, 88);\n     static_assert_size!(Generics, 72);\n     static_assert_size!(Impl, 200);\n     static_assert_size!(Item, 184);\n     static_assert_size!(ItemKind, 112);\n     static_assert_size!(Lit, 48);\n     static_assert_size!(LitKind, 24);\n+    static_assert_size!(Local, 72);\n+    static_assert_size!(Param, 40);\n     static_assert_size!(Pat, 120);\n     static_assert_size!(PatKind, 96);\n     static_assert_size!(Path, 40);"}, {"sha": "1b31be07f7ad1b1cc8cdb93b80fc463ab7d8e64b", "filename": "compiler/rustc_ast/src/ast_traits.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -4,7 +4,7 @@\n \n use crate::ptr::P;\n use crate::token::Nonterminal;\n-use crate::tokenstream::LazyTokenStream;\n+use crate::tokenstream::LazyAttrTokenStream;\n use crate::{Arm, Crate, ExprField, FieldDef, GenericParam, Param, PatField, Variant};\n use crate::{AssocItem, Expr, ForeignItem, Item, NodeId};\n use crate::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n@@ -124,18 +124,18 @@ impl HasSpan for AttrItem {\n \n /// A trait for AST nodes having (or not having) collected tokens.\n pub trait HasTokens {\n-    fn tokens(&self) -> Option<&LazyTokenStream>;\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>>;\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream>;\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>>;\n }\n \n macro_rules! impl_has_tokens {\n     ($($T:ty),+ $(,)?) => {\n         $(\n             impl HasTokens for $T {\n-                fn tokens(&self) -> Option<&LazyTokenStream> {\n+                fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n                     self.tokens.as_ref()\n                 }\n-                fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n                     Some(&mut self.tokens)\n                 }\n             }\n@@ -147,10 +147,10 @@ macro_rules! impl_has_tokens_none {\n     ($($T:ty),+ $(,)?) => {\n         $(\n             impl HasTokens for $T {\n-                fn tokens(&self) -> Option<&LazyTokenStream> {\n+                fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n                     None\n                 }\n-                fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n                     None\n                 }\n             }\n@@ -162,25 +162,25 @@ impl_has_tokens!(AssocItem, AttrItem, Block, Expr, ForeignItem, Item, Pat, Path,\n impl_has_tokens_none!(Arm, ExprField, FieldDef, GenericParam, Param, PatField, Variant);\n \n impl<T: AstDeref<Target: HasTokens>> HasTokens for T {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         self.ast_deref().tokens()\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         self.ast_deref_mut().tokens_mut()\n     }\n }\n \n impl<T: HasTokens> HasTokens for Option<T> {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         self.as_ref().and_then(|inner| inner.tokens())\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         self.as_mut().and_then(|inner| inner.tokens_mut())\n     }\n }\n \n impl HasTokens for StmtKind {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         match self {\n             StmtKind::Local(local) => local.tokens.as_ref(),\n             StmtKind::Item(item) => item.tokens(),\n@@ -189,7 +189,7 @@ impl HasTokens for StmtKind {\n             StmtKind::MacCall(mac) => mac.tokens.as_ref(),\n         }\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         match self {\n             StmtKind::Local(local) => Some(&mut local.tokens),\n             StmtKind::Item(item) => item.tokens_mut(),\n@@ -201,24 +201,24 @@ impl HasTokens for StmtKind {\n }\n \n impl HasTokens for Stmt {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         self.kind.tokens()\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         self.kind.tokens_mut()\n     }\n }\n \n impl HasTokens for Attribute {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         match &self.kind {\n             AttrKind::Normal(normal) => normal.tokens.as_ref(),\n             kind @ AttrKind::DocComment(..) => {\n                 panic!(\"Called tokens on doc comment attr {:?}\", kind)\n             }\n         }\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         Some(match &mut self.kind {\n             AttrKind::Normal(normal) => &mut normal.tokens,\n             kind @ AttrKind::DocComment(..) => {\n@@ -229,7 +229,7 @@ impl HasTokens for Attribute {\n }\n \n impl HasTokens for Nonterminal {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         match self {\n             Nonterminal::NtItem(item) => item.tokens(),\n             Nonterminal::NtStmt(stmt) => stmt.tokens(),\n@@ -243,7 +243,7 @@ impl HasTokens for Nonterminal {\n             Nonterminal::NtIdent(..) | Nonterminal::NtLifetime(..) => None,\n         }\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         match self {\n             Nonterminal::NtItem(item) => item.tokens_mut(),\n             Nonterminal::NtStmt(stmt) => stmt.tokens_mut(),\n@@ -279,6 +279,7 @@ macro_rules! impl_has_attrs {\n             impl HasAttrs for $T {\n                 const SUPPORTS_CUSTOM_INNER_ATTRS: bool = $inner;\n \n+                #[inline]\n                 fn attrs(&self) -> &[Attribute] {\n                     &self.attrs\n                 }"}, {"sha": "990f4f8f1329f2ab2d53171088527d02491ae0d8", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 75, "deletions": 26, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -7,17 +7,22 @@ use crate::ast::{MacArgs, MacArgsEq, MacDelimiter, MetaItem, MetaItemKind, Neste\n use crate::ast::{Path, PathSegment};\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter, Token};\n-use crate::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n-use crate::tokenstream::{LazyTokenStream, TokenStream};\n+use crate::tokenstream::{LazyAttrTokenStream, TokenStream};\n use crate::util::comments;\n \n+use rustc_data_structures::sync::WorkerLocal;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::source_map::BytePos;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n+use std::cell::Cell;\n use std::iter;\n+#[cfg(debug_assertions)]\n+use std::ops::BitXor;\n+#[cfg(debug_assertions)]\n+use std::sync::atomic::{AtomicU32, Ordering};\n \n pub struct MarkedAttrs(GrowableBitSet<AttrId>);\n \n@@ -232,13 +237,21 @@ impl AttrItem {\n }\n \n impl Attribute {\n+    /// Returns `true` if it is a sugared doc comment (`///` or `//!` for example).\n+    /// So `#[doc = \"doc\"]` (which is a doc comment) and `#[doc(...)]` (which is not\n+    /// a doc comment) will return `false`.\n     pub fn is_doc_comment(&self) -> bool {\n         match self.kind {\n             AttrKind::Normal(..) => false,\n             AttrKind::DocComment(..) => true,\n         }\n     }\n \n+    /// Returns the documentation and its kind if this is a doc comment or a sugared doc comment.\n+    /// * `///doc` returns `Some((\"doc\", CommentKind::Line))`.\n+    /// * `/** doc */` returns `Some((\"doc\", CommentKind::Block))`.\n+    /// * `#[doc = \"doc\"]` returns `Some((\"doc\", CommentKind::Line))`.\n+    /// * `#[doc(...)]` returns `None`.\n     pub fn doc_str_and_comment_kind(&self) -> Option<(Symbol, CommentKind)> {\n         match self.kind {\n             AttrKind::DocComment(kind, data) => Some((data, kind)),\n@@ -251,6 +264,10 @@ impl Attribute {\n         }\n     }\n \n+    /// Returns the documentation if this is a doc comment or a sugared doc comment.\n+    /// * `///doc` returns `Some(\"doc\")`.\n+    /// * `#[doc = \"doc\"]` returns `Some(\"doc\")`.\n+    /// * `#[doc(...)]` returns `None`.\n     pub fn doc_str(&self) -> Option<Symbol> {\n         match self.kind {\n             AttrKind::DocComment(.., data) => Some(data),\n@@ -294,20 +311,18 @@ impl Attribute {\n         }\n     }\n \n-    pub fn tokens(&self) -> AttrAnnotatedTokenStream {\n+    pub fn tokens(&self) -> TokenStream {\n         match self.kind {\n             AttrKind::Normal(ref normal) => normal\n                 .tokens\n                 .as_ref()\n                 .unwrap_or_else(|| panic!(\"attribute is missing tokens: {:?}\", self))\n-                .create_token_stream(),\n-            AttrKind::DocComment(comment_kind, data) => AttrAnnotatedTokenStream::from((\n-                AttrAnnotatedTokenTree::Token(Token::new(\n-                    token::DocComment(comment_kind, self.style, data),\n-                    self.span,\n-                )),\n+                .to_attr_token_stream()\n+                .to_tokenstream(),\n+            AttrKind::DocComment(comment_kind, data) => TokenStream::new(vec![TokenTree::Token(\n+                Token::new(token::DocComment(comment_kind, self.style, data), self.span),\n                 Spacing::Alone,\n-            )),\n+            )]),\n         }\n     }\n }\n@@ -337,52 +352,86 @@ pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n     NestedMetaItem::MetaItem(mk_word_item(ident))\n }\n \n-pub(crate) fn mk_attr_id() -> AttrId {\n-    use std::sync::atomic::AtomicU32;\n-    use std::sync::atomic::Ordering;\n+pub struct AttrIdGenerator(WorkerLocal<Cell<u32>>);\n \n-    static NEXT_ATTR_ID: AtomicU32 = AtomicU32::new(0);\n+#[cfg(debug_assertions)]\n+static MAX_ATTR_ID: AtomicU32 = AtomicU32::new(u32::MAX);\n \n-    let id = NEXT_ATTR_ID.fetch_add(1, Ordering::SeqCst);\n-    assert!(id != u32::MAX);\n-    AttrId::from_u32(id)\n+impl AttrIdGenerator {\n+    pub fn new() -> Self {\n+        // We use `(index as u32).reverse_bits()` to initialize the\n+        // starting value of AttrId in each worker thread.\n+        // The `index` is the index of the worker thread.\n+        // This ensures that the AttrId generated in each thread is unique.\n+        AttrIdGenerator(WorkerLocal::new(|index| {\n+            let index: u32 = index.try_into().unwrap();\n+\n+            #[cfg(debug_assertions)]\n+            {\n+                let max_id = ((index + 1).next_power_of_two() - 1).bitxor(u32::MAX).reverse_bits();\n+                MAX_ATTR_ID.fetch_min(max_id, Ordering::Release);\n+            }\n+\n+            Cell::new(index.reverse_bits())\n+        }))\n+    }\n+\n+    pub fn mk_attr_id(&self) -> AttrId {\n+        let id = self.0.get();\n+\n+        // Ensure the assigned attr_id does not overlap the bits\n+        // representing the number of threads.\n+        #[cfg(debug_assertions)]\n+        assert!(id <= MAX_ATTR_ID.load(Ordering::Acquire));\n+\n+        self.0.set(id + 1);\n+        AttrId::from_u32(id)\n+    }\n }\n \n-pub fn mk_attr(style: AttrStyle, path: Path, args: MacArgs, span: Span) -> Attribute {\n-    mk_attr_from_item(AttrItem { path, args, tokens: None }, None, style, span)\n+pub fn mk_attr(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    path: Path,\n+    args: MacArgs,\n+    span: Span,\n+) -> Attribute {\n+    mk_attr_from_item(g, AttrItem { path, args, tokens: None }, None, style, span)\n }\n \n pub fn mk_attr_from_item(\n+    g: &AttrIdGenerator,\n     item: AttrItem,\n-    tokens: Option<LazyTokenStream>,\n+    tokens: Option<LazyAttrTokenStream>,\n     style: AttrStyle,\n     span: Span,\n ) -> Attribute {\n     Attribute {\n         kind: AttrKind::Normal(P(ast::NormalAttr { item, tokens })),\n-        id: mk_attr_id(),\n+        id: g.mk_attr_id(),\n         style,\n         span,\n     }\n }\n \n /// Returns an inner attribute with the given value and span.\n-pub fn mk_attr_inner(item: MetaItem) -> Attribute {\n-    mk_attr(AttrStyle::Inner, item.path, item.kind.mac_args(item.span), item.span)\n+pub fn mk_attr_inner(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n+    mk_attr(g, AttrStyle::Inner, item.path, item.kind.mac_args(item.span), item.span)\n }\n \n /// Returns an outer attribute with the given value and span.\n-pub fn mk_attr_outer(item: MetaItem) -> Attribute {\n-    mk_attr(AttrStyle::Outer, item.path, item.kind.mac_args(item.span), item.span)\n+pub fn mk_attr_outer(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n+    mk_attr(g, AttrStyle::Outer, item.path, item.kind.mac_args(item.span), item.span)\n }\n \n pub fn mk_doc_comment(\n+    g: &AttrIdGenerator,\n     comment_kind: CommentKind,\n     style: AttrStyle,\n     data: Symbol,\n     span: Span,\n ) -> Attribute {\n-    Attribute { kind: AttrKind::DocComment(comment_kind, data), id: mk_attr_id(), style, span }\n+    Attribute { kind: AttrKind::DocComment(comment_kind, data), id: g.mk_attr_id(), style, span }\n }\n \n pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {"}, {"sha": "eeb7e56e2b12448e3b465fd29cfd6c716a76b468", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -13,7 +13,6 @@\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(if_let_guard)]\n-#![cfg_attr(bootstrap, feature(label_break_value))]\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(negative_impls)]\n@@ -26,6 +25,9 @@\n #[macro_use]\n extern crate rustc_macros;\n \n+#[macro_use]\n+extern crate tracing;\n+\n pub mod util {\n     pub mod classify;\n     pub mod comments;"}, {"sha": "ad68d6e755e0287d5eedda3eef87d57e9e72798f", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -642,17 +642,17 @@ pub fn noop_flat_map_param<T: MutVisitor>(mut param: Param, vis: &mut T) -> Smal\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_attr_annotated_tt<T: MutVisitor>(tt: &mut AttrAnnotatedTokenTree, vis: &mut T) {\n+pub fn visit_attr_tt<T: MutVisitor>(tt: &mut AttrTokenTree, vis: &mut T) {\n     match tt {\n-        AttrAnnotatedTokenTree::Token(token) => {\n+        AttrTokenTree::Token(token, _) => {\n             visit_token(token, vis);\n         }\n-        AttrAnnotatedTokenTree::Delimited(DelimSpan { open, close }, _delim, tts) => {\n+        AttrTokenTree::Delimited(DelimSpan { open, close }, _delim, tts) => {\n             vis.visit_span(open);\n             vis.visit_span(close);\n-            visit_attr_annotated_tts(tts, vis);\n+            visit_attr_tts(tts, vis);\n         }\n-        AttrAnnotatedTokenTree::Attributes(data) => {\n+        AttrTokenTree::Attributes(data) => {\n             for attr in &mut *data.attrs {\n                 match &mut attr.kind {\n                     AttrKind::Normal(normal) => {\n@@ -690,27 +690,27 @@ pub fn visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &mut T)\n     }\n }\n \n-pub fn visit_attr_annotated_tts<T: MutVisitor>(\n-    AttrAnnotatedTokenStream(tts): &mut AttrAnnotatedTokenStream,\n-    vis: &mut T,\n-) {\n+pub fn visit_attr_tts<T: MutVisitor>(AttrTokenStream(tts): &mut AttrTokenStream, vis: &mut T) {\n     if T::VISIT_TOKENS && !tts.is_empty() {\n         let tts = Lrc::make_mut(tts);\n-        visit_vec(tts, |(tree, _is_joint)| visit_attr_annotated_tt(tree, vis));\n+        visit_vec(tts, |tree| visit_attr_tt(tree, vis));\n     }\n }\n \n-pub fn visit_lazy_tts_opt_mut<T: MutVisitor>(lazy_tts: Option<&mut LazyTokenStream>, vis: &mut T) {\n+pub fn visit_lazy_tts_opt_mut<T: MutVisitor>(\n+    lazy_tts: Option<&mut LazyAttrTokenStream>,\n+    vis: &mut T,\n+) {\n     if T::VISIT_TOKENS {\n         if let Some(lazy_tts) = lazy_tts {\n-            let mut tts = lazy_tts.create_token_stream();\n-            visit_attr_annotated_tts(&mut tts, vis);\n-            *lazy_tts = LazyTokenStream::new(tts);\n+            let mut tts = lazy_tts.to_attr_token_stream();\n+            visit_attr_tts(&mut tts, vis);\n+            *lazy_tts = LazyAttrTokenStream::new(tts);\n         }\n     }\n }\n \n-pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyTokenStream>, vis: &mut T) {\n+pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyAttrTokenStream>, vis: &mut T) {\n     visit_lazy_tts_opt_mut(lazy_tts.as_mut(), vis);\n }\n "}, {"sha": "7b5acc3f4859624c4d48baf3a99a346b00fae8f8", "filename": "compiler/rustc_ast/src/node_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -13,7 +13,7 @@ rustc_index::newtype_index! {\n     }\n }\n \n-rustc_data_structures::define_id_collections!(NodeMap, NodeSet, NodeId);\n+rustc_data_structures::define_id_collections!(NodeMap, NodeSet, NodeMapEntry, NodeId);\n \n /// The [`NodeId`] used to represent the root of the crate.\n pub const CRATE_NODE_ID: NodeId = NodeId::from_u32(0);"}, {"sha": "97dfb7837674fdcaacbe6e4b660ba5065f0dcab1", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -398,6 +398,30 @@ impl Token {\n         }\n     }\n \n+    /// Returns `true` if the token can appear at the start of an pattern.\n+    ///\n+    /// Shamelessly borrowed from `can_begin_expr`, only used for diagnostics right now.\n+    pub fn can_begin_pattern(&self) -> bool {\n+        match self.uninterpolate().kind {\n+            Ident(name, is_raw)              =>\n+                ident_can_begin_expr(name, self.span, is_raw), // value name or keyword\n+            | OpenDelim(Delimiter::Bracket | Delimiter::Parenthesis)  // tuple or array\n+            | Literal(..)                        // literal\n+            | BinOp(Minus)                       // unary minus\n+            | BinOp(And)                         // reference\n+            | AndAnd                             // double reference\n+            // DotDotDot is no longer supported\n+            | DotDot | DotDotDot | DotDotEq      // ranges\n+            | Lt | BinOp(Shl)                    // associated path\n+            | ModSep                    => true, // global path\n+            Interpolated(ref nt) => matches!(**nt, NtLiteral(..) |\n+                NtPat(..)     |\n+                NtBlock(..)   |\n+                NtPath(..)),\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if the token can appear at the start of a type.\n     pub fn can_begin_type(&self) -> bool {\n         match self.uninterpolate().kind {\n@@ -449,6 +473,7 @@ impl Token {\n                 kw::Extern,\n                 kw::Impl,\n                 kw::Unsafe,\n+                kw::Const,\n                 kw::Static,\n                 kw::Union,\n                 kw::Macro,"}, {"sha": "875cd620dfc6ccb759f8394803651620168f382c", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 56, "deletions": 71, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -121,12 +121,12 @@ where\n     }\n }\n \n-pub trait CreateTokenStream: sync::Send + sync::Sync {\n-    fn create_token_stream(&self) -> AttrAnnotatedTokenStream;\n+pub trait ToAttrTokenStream: sync::Send + sync::Sync {\n+    fn to_attr_token_stream(&self) -> AttrTokenStream;\n }\n \n-impl CreateTokenStream for AttrAnnotatedTokenStream {\n-    fn create_token_stream(&self) -> AttrAnnotatedTokenStream {\n+impl ToAttrTokenStream for AttrTokenStream {\n+    fn to_attr_token_stream(&self) -> AttrTokenStream {\n         self.clone()\n     }\n }\n@@ -135,100 +135,96 @@ impl CreateTokenStream for AttrAnnotatedTokenStream {\n /// of an actual `TokenStream` until it is needed.\n /// `Box` is here only to reduce the structure size.\n #[derive(Clone)]\n-pub struct LazyTokenStream(Lrc<Box<dyn CreateTokenStream>>);\n+pub struct LazyAttrTokenStream(Lrc<Box<dyn ToAttrTokenStream>>);\n \n-impl LazyTokenStream {\n-    pub fn new(inner: impl CreateTokenStream + 'static) -> LazyTokenStream {\n-        LazyTokenStream(Lrc::new(Box::new(inner)))\n+impl LazyAttrTokenStream {\n+    pub fn new(inner: impl ToAttrTokenStream + 'static) -> LazyAttrTokenStream {\n+        LazyAttrTokenStream(Lrc::new(Box::new(inner)))\n     }\n \n-    pub fn create_token_stream(&self) -> AttrAnnotatedTokenStream {\n-        self.0.create_token_stream()\n+    pub fn to_attr_token_stream(&self) -> AttrTokenStream {\n+        self.0.to_attr_token_stream()\n     }\n }\n \n-impl fmt::Debug for LazyTokenStream {\n+impl fmt::Debug for LazyAttrTokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"LazyTokenStream({:?})\", self.create_token_stream())\n+        write!(f, \"LazyAttrTokenStream({:?})\", self.to_attr_token_stream())\n     }\n }\n \n-impl<S: Encoder> Encodable<S> for LazyTokenStream {\n+impl<S: Encoder> Encodable<S> for LazyAttrTokenStream {\n     fn encode(&self, s: &mut S) {\n         // Used by AST json printing.\n-        Encodable::encode(&self.create_token_stream(), s);\n+        Encodable::encode(&self.to_attr_token_stream(), s);\n     }\n }\n \n-impl<D: Decoder> Decodable<D> for LazyTokenStream {\n+impl<D: Decoder> Decodable<D> for LazyAttrTokenStream {\n     fn decode(_d: &mut D) -> Self {\n-        panic!(\"Attempted to decode LazyTokenStream\");\n+        panic!(\"Attempted to decode LazyAttrTokenStream\");\n     }\n }\n \n-impl<CTX> HashStable<CTX> for LazyTokenStream {\n+impl<CTX> HashStable<CTX> for LazyAttrTokenStream {\n     fn hash_stable(&self, _hcx: &mut CTX, _hasher: &mut StableHasher) {\n-        panic!(\"Attempted to compute stable hash for LazyTokenStream\");\n+        panic!(\"Attempted to compute stable hash for LazyAttrTokenStream\");\n     }\n }\n \n-/// A `AttrAnnotatedTokenStream` is similar to a `TokenStream`, but with extra\n+/// An `AttrTokenStream` is similar to a `TokenStream`, but with extra\n /// information about the tokens for attribute targets. This is used\n /// during expansion to perform early cfg-expansion, and to process attributes\n /// during proc-macro invocations.\n #[derive(Clone, Debug, Default, Encodable, Decodable)]\n-pub struct AttrAnnotatedTokenStream(pub Lrc<Vec<(AttrAnnotatedTokenTree, Spacing)>>);\n+pub struct AttrTokenStream(pub Lrc<Vec<AttrTokenTree>>);\n \n-/// Like `TokenTree`, but for `AttrAnnotatedTokenStream`\n+/// Like `TokenTree`, but for `AttrTokenStream`.\n #[derive(Clone, Debug, Encodable, Decodable)]\n-pub enum AttrAnnotatedTokenTree {\n-    Token(Token),\n-    Delimited(DelimSpan, Delimiter, AttrAnnotatedTokenStream),\n+pub enum AttrTokenTree {\n+    Token(Token, Spacing),\n+    Delimited(DelimSpan, Delimiter, AttrTokenStream),\n     /// Stores the attributes for an attribute target,\n     /// along with the tokens for that attribute target.\n     /// See `AttributesData` for more information\n     Attributes(AttributesData),\n }\n \n-impl AttrAnnotatedTokenStream {\n-    pub fn new(tokens: Vec<(AttrAnnotatedTokenTree, Spacing)>) -> AttrAnnotatedTokenStream {\n-        AttrAnnotatedTokenStream(Lrc::new(tokens))\n+impl AttrTokenStream {\n+    pub fn new(tokens: Vec<AttrTokenTree>) -> AttrTokenStream {\n+        AttrTokenStream(Lrc::new(tokens))\n     }\n \n-    /// Converts this `AttrAnnotatedTokenStream` to a plain `TokenStream\n-    /// During conversion, `AttrAnnotatedTokenTree::Attributes` get 'flattened'\n+    /// Converts this `AttrTokenStream` to a plain `TokenStream`.\n+    /// During conversion, `AttrTokenTree::Attributes` get 'flattened'\n     /// back to a `TokenStream` of the form `outer_attr attr_target`.\n     /// If there are inner attributes, they are inserted into the proper\n     /// place in the attribute target tokens.\n     pub fn to_tokenstream(&self) -> TokenStream {\n         let trees: Vec<_> = self\n             .0\n             .iter()\n-            .flat_map(|tree| match &tree.0 {\n-                AttrAnnotatedTokenTree::Token(inner) => {\n-                    smallvec![TokenTree::Token(inner.clone(), tree.1)].into_iter()\n+            .flat_map(|tree| match &tree {\n+                AttrTokenTree::Token(inner, spacing) => {\n+                    smallvec![TokenTree::Token(inner.clone(), *spacing)].into_iter()\n                 }\n-                AttrAnnotatedTokenTree::Delimited(span, delim, stream) => {\n+                AttrTokenTree::Delimited(span, delim, stream) => {\n                     smallvec![TokenTree::Delimited(*span, *delim, stream.to_tokenstream()),]\n                         .into_iter()\n                 }\n-                AttrAnnotatedTokenTree::Attributes(data) => {\n+                AttrTokenTree::Attributes(data) => {\n                     let mut outer_attrs = Vec::new();\n                     let mut inner_attrs = Vec::new();\n                     for attr in &data.attrs {\n                         match attr.style {\n-                            crate::AttrStyle::Outer => {\n-                                outer_attrs.push(attr);\n-                            }\n-                            crate::AttrStyle::Inner => {\n-                                inner_attrs.push(attr);\n-                            }\n+                            crate::AttrStyle::Outer => outer_attrs.push(attr),\n+                            crate::AttrStyle::Inner => inner_attrs.push(attr),\n                         }\n                     }\n \n                     let mut target_tokens: Vec<_> = data\n                         .tokens\n-                        .create_token_stream()\n+                        .to_attr_token_stream()\n                         .to_tokenstream()\n                         .0\n                         .iter()\n@@ -239,9 +235,9 @@ impl AttrAnnotatedTokenStream {\n                         // Check the last two trees (to account for a trailing semi)\n                         for tree in target_tokens.iter_mut().rev().take(2) {\n                             if let TokenTree::Delimited(span, delim, delim_tokens) = tree {\n-                                // Inner attributes are only supported on extern blocks, functions, impls,\n-                                // and modules. All of these have their inner attributes placed at\n-                                // the beginning of the rightmost outermost braced group:\n+                                // Inner attributes are only supported on extern blocks, functions,\n+                                // impls, and modules. All of these have their inner attributes\n+                                // placed at the beginning of the rightmost outermost braced group:\n                                 // e.g. fn foo() { #![my_attr} }\n                                 //\n                                 // Therefore, we can insert them back into the right location\n@@ -255,7 +251,7 @@ impl AttrAnnotatedTokenStream {\n \n                                 let mut builder = TokenStreamBuilder::new();\n                                 for inner_attr in inner_attrs {\n-                                    builder.push(inner_attr.tokens().to_tokenstream());\n+                                    builder.push(inner_attr.tokens());\n                                 }\n                                 builder.push(delim_tokens.clone());\n                                 *tree = TokenTree::Delimited(*span, *delim, builder.build());\n@@ -273,7 +269,7 @@ impl AttrAnnotatedTokenStream {\n                     let mut flat: SmallVec<[_; 1]> = SmallVec::new();\n                     for attr in outer_attrs {\n                         // FIXME: Make this more efficient\n-                        flat.extend(attr.tokens().to_tokenstream().0.clone().iter().cloned());\n+                        flat.extend(attr.tokens().0.clone().iter().cloned());\n                     }\n                     flat.extend(target_tokens);\n                     flat.into_iter()\n@@ -300,7 +296,7 @@ pub struct AttributesData {\n     pub attrs: AttrVec,\n     /// The underlying tokens for the attribute target that `attrs`\n     /// are applied to\n-    pub tokens: LazyTokenStream,\n+    pub tokens: LazyAttrTokenStream,\n }\n \n /// A `TokenStream` is an abstract sequence of tokens, organized into [`TokenTree`]s.\n@@ -363,12 +359,6 @@ impl TokenStream {\n     }\n }\n \n-impl From<(AttrAnnotatedTokenTree, Spacing)> for AttrAnnotatedTokenStream {\n-    fn from((tree, spacing): (AttrAnnotatedTokenTree, Spacing)) -> AttrAnnotatedTokenStream {\n-        AttrAnnotatedTokenStream::new(vec![(tree, spacing)])\n-    }\n-}\n-\n impl iter::FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(iter: I) -> Self {\n         TokenStream::new(iter.into_iter().collect::<Vec<TokenTree>>())\n@@ -420,21 +410,6 @@ impl TokenStream {\n         TokenStream(Lrc::new(self.0.iter().enumerate().map(|(i, tree)| f(i, tree)).collect()))\n     }\n \n-    fn opt_from_ast(node: &(impl HasAttrs + HasTokens)) -> Option<TokenStream> {\n-        let tokens = node.tokens()?;\n-        let attrs = node.attrs();\n-        let attr_annotated = if attrs.is_empty() {\n-            tokens.create_token_stream()\n-        } else {\n-            let attr_data = AttributesData { attrs: attrs.to_vec().into(), tokens: tokens.clone() };\n-            AttrAnnotatedTokenStream::new(vec![(\n-                AttrAnnotatedTokenTree::Attributes(attr_data),\n-                Spacing::Alone,\n-            )])\n-        };\n-        Some(attr_annotated.to_tokenstream())\n-    }\n-\n     // Create a token stream containing a single token with alone spacing.\n     pub fn token_alone(kind: TokenKind, span: Span) -> TokenStream {\n         TokenStream::new(vec![TokenTree::token_alone(kind, span)])\n@@ -451,8 +426,18 @@ impl TokenStream {\n     }\n \n     pub fn from_ast(node: &(impl HasAttrs + HasSpan + HasTokens + fmt::Debug)) -> TokenStream {\n-        TokenStream::opt_from_ast(node)\n-            .unwrap_or_else(|| panic!(\"missing tokens for node at {:?}: {:?}\", node.span(), node))\n+        let Some(tokens) = node.tokens() else {\n+            panic!(\"missing tokens for node at {:?}: {:?}\", node.span(), node);\n+        };\n+        let attrs = node.attrs();\n+        let attr_stream = if attrs.is_empty() {\n+            tokens.to_attr_token_stream()\n+        } else {\n+            let attr_data =\n+                AttributesData { attrs: attrs.iter().cloned().collect(), tokens: tokens.clone() };\n+            AttrTokenStream::new(vec![AttrTokenTree::Attributes(attr_data)])\n+        };\n+        attr_stream.to_tokenstream()\n     }\n \n     pub fn from_nonterminal_ast(nt: &Nonterminal) -> TokenStream {\n@@ -555,7 +540,7 @@ impl TokenStreamBuilder {\n \n                 // Get the first stream, which will become the result stream.\n                 // If it's `None`, create an empty stream.\n-                let mut iter = streams.drain(..);\n+                let mut iter = streams.into_iter();\n                 let mut res_stream_lrc = iter.next().unwrap().0;\n \n                 // Append the subsequent elements to the result stream, after"}, {"sha": "536b385606c69c5fa98c91a2c4f23eb4558d6b71", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -9,7 +9,6 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n use std::ascii;\n-use tracing::debug;\n \n pub enum LitError {\n     NotLiteral,\n@@ -164,12 +163,7 @@ impl LitKind {\n             }\n             LitKind::Str(symbol, ast::StrStyle::Raw(n)) => (token::StrRaw(n), symbol, None),\n             LitKind::ByteStr(ref bytes) => {\n-                let string = bytes\n-                    .iter()\n-                    .cloned()\n-                    .flat_map(ascii::escape_default)\n-                    .map(Into::<char>::into)\n-                    .collect::<String>();\n+                let string = bytes.escape_ascii().to_string();\n                 (token::ByteStr, Symbol::intern(&string), None)\n             }\n             LitKind::Byte(byte) => {"}, {"sha": "b40ad6f700e82e8abda0d851f2f241f830c4d2ce", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -297,11 +297,11 @@ impl ExprPrecedence {\n         match self {\n             ExprPrecedence::Closure => PREC_CLOSURE,\n \n-            ExprPrecedence::Break |\n-            ExprPrecedence::Continue |\n-            ExprPrecedence::Ret |\n-            ExprPrecedence::Yield |\n-            ExprPrecedence::Yeet => PREC_JUMP,\n+            ExprPrecedence::Break\n+            | ExprPrecedence::Continue\n+            | ExprPrecedence::Ret\n+            | ExprPrecedence::Yield\n+            | ExprPrecedence::Yeet => PREC_JUMP,\n \n             // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to\n             // parse, instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence\n@@ -318,43 +318,43 @@ impl ExprPrecedence {\n             ExprPrecedence::AssignOp => AssocOp::Assign.precedence() as i8,\n \n             // Unary, prefix\n-            ExprPrecedence::Box |\n-            ExprPrecedence::AddrOf |\n+            ExprPrecedence::Box\n+            | ExprPrecedence::AddrOf\n             // Here `let pats = expr` has `let pats =` as a \"unary\" prefix of `expr`.\n             // However, this is not exactly right. When `let _ = a` is the LHS of a binop we\n             // need parens sometimes. E.g. we can print `(let _ = a) && b` as `let _ = a && b`\n             // but we need to print `(let _ = a) < b` as-is with parens.\n-            ExprPrecedence::Let |\n-            ExprPrecedence::Unary => PREC_PREFIX,\n+            | ExprPrecedence::Let\n+            | ExprPrecedence::Unary => PREC_PREFIX,\n \n             // Unary, postfix\n-            ExprPrecedence::Await |\n-            ExprPrecedence::Call |\n-            ExprPrecedence::MethodCall |\n-            ExprPrecedence::Field |\n-            ExprPrecedence::Index |\n-            ExprPrecedence::Try |\n-            ExprPrecedence::InlineAsm |\n-            ExprPrecedence::Mac => PREC_POSTFIX,\n+            ExprPrecedence::Await\n+            | ExprPrecedence::Call\n+            | ExprPrecedence::MethodCall\n+            | ExprPrecedence::Field\n+            | ExprPrecedence::Index\n+            | ExprPrecedence::Try\n+            | ExprPrecedence::InlineAsm\n+            | ExprPrecedence::Mac => PREC_POSTFIX,\n \n             // Never need parens\n-            ExprPrecedence::Array |\n-            ExprPrecedence::Repeat |\n-            ExprPrecedence::Tup |\n-            ExprPrecedence::Lit |\n-            ExprPrecedence::Path |\n-            ExprPrecedence::Paren |\n-            ExprPrecedence::If |\n-            ExprPrecedence::While |\n-            ExprPrecedence::ForLoop |\n-            ExprPrecedence::Loop |\n-            ExprPrecedence::Match |\n-            ExprPrecedence::ConstBlock |\n-            ExprPrecedence::Block |\n-            ExprPrecedence::TryBlock |\n-            ExprPrecedence::Async |\n-            ExprPrecedence::Struct |\n-            ExprPrecedence::Err => PREC_PAREN,\n+            ExprPrecedence::Array\n+            | ExprPrecedence::Repeat\n+            | ExprPrecedence::Tup\n+            | ExprPrecedence::Lit\n+            | ExprPrecedence::Path\n+            | ExprPrecedence::Paren\n+            | ExprPrecedence::If\n+            | ExprPrecedence::While\n+            | ExprPrecedence::ForLoop\n+            | ExprPrecedence::Loop\n+            | ExprPrecedence::Match\n+            | ExprPrecedence::ConstBlock\n+            | ExprPrecedence::Block\n+            | ExprPrecedence::TryBlock\n+            | ExprPrecedence::Async\n+            | ExprPrecedence::Struct\n+            | ExprPrecedence::Err => PREC_PAREN,\n         }\n     }\n }"}, {"sha": "a71e055a4b3e54100ca1dc7f6fa94778543beabf", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -156,8 +156,8 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n         walk_where_predicate(self, p)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'ast>, s: Span, _: NodeId) {\n-        walk_fn(self, fk, s)\n+    fn visit_fn(&mut self, fk: FnKind<'ast>, _: Span, _: NodeId) {\n+        walk_fn(self, fk)\n     }\n     fn visit_assoc_item(&mut self, i: &'ast AssocItem, ctxt: AssocCtxt) {\n         walk_assoc_item(self, i, ctxt)\n@@ -201,11 +201,11 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_use_tree(&mut self, use_tree: &'ast UseTree, id: NodeId, _nested: bool) {\n         walk_use_tree(self, use_tree, id)\n     }\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n-        walk_path_segment(self, path_span, path_segment)\n+    fn visit_path_segment(&mut self, path_segment: &'ast PathSegment) {\n+        walk_path_segment(self, path_segment)\n     }\n-    fn visit_generic_args(&mut self, path_span: Span, generic_args: &'ast GenericArgs) {\n-        walk_generic_args(self, path_span, generic_args)\n+    fn visit_generic_args(&mut self, generic_args: &'ast GenericArgs) {\n+        walk_generic_args(self, generic_args)\n     }\n     fn visit_generic_arg(&mut self, generic_arg: &'ast GenericArg) {\n         walk_generic_arg(self, generic_arg)\n@@ -435,7 +435,7 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n \n pub fn walk_path<'a, V: Visitor<'a>>(visitor: &mut V, path: &'a Path) {\n     for segment in &path.segments {\n-        visitor.visit_path_segment(path.span, segment);\n+        visitor.visit_path_segment(segment);\n     }\n }\n \n@@ -457,18 +457,14 @@ pub fn walk_use_tree<'a, V: Visitor<'a>>(visitor: &mut V, use_tree: &'a UseTree,\n     }\n }\n \n-pub fn walk_path_segment<'a, V: Visitor<'a>>(\n-    visitor: &mut V,\n-    path_span: Span,\n-    segment: &'a PathSegment,\n-) {\n+pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V, segment: &'a PathSegment) {\n     visitor.visit_ident(segment.ident);\n     if let Some(ref args) = segment.args {\n-        visitor.visit_generic_args(path_span, args);\n+        visitor.visit_generic_args(args);\n     }\n }\n \n-pub fn walk_generic_args<'a, V>(visitor: &mut V, _path_span: Span, generic_args: &'a GenericArgs)\n+pub fn walk_generic_args<'a, V>(visitor: &mut V, generic_args: &'a GenericArgs)\n where\n     V: Visitor<'a>,\n {\n@@ -502,7 +498,7 @@ where\n pub fn walk_assoc_constraint<'a, V: Visitor<'a>>(visitor: &mut V, constraint: &'a AssocConstraint) {\n     visitor.visit_ident(constraint.ident);\n     if let Some(ref gen_args) = constraint.gen_args {\n-        visitor.visit_generic_args(gen_args.span(), gen_args);\n+        visitor.visit_generic_args(gen_args);\n     }\n     match constraint.kind {\n         AssocConstraintKind::Equality { ref term } => match term {\n@@ -659,7 +655,7 @@ pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &\n     visitor.visit_fn_ret_ty(&function_declaration.output);\n }\n \n-pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>, _span: Span) {\n+pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>) {\n     match kind {\n         FnKind::Fn(_, _, sig, _, generics, body) => {\n             visitor.visit_generics(generics);\n@@ -800,7 +796,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             walk_list!(visitor, visit_expr, arguments);\n         }\n         ExprKind::MethodCall(ref segment, ref receiver, ref arguments, _span) => {\n-            visitor.visit_path_segment(expression.span, segment);\n+            visitor.visit_path_segment(segment);\n             visitor.visit_expr(receiver);\n             walk_list!(visitor, visit_expr, arguments);\n         }"}, {"sha": "ce1c8d4997d745b3c4760649db7786ef48bfccef", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -8,17 +8,18 @@ doctest = false\n \n [dependencies]\n rustc_arena = { path = \"../rustc_arena\" }\n-tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n-rustc_hir = { path = \"../rustc_hir\" }\n-rustc_target = { path = \"../rustc_target\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n-rustc_span = { path = \"../rustc_span\" }\n-rustc_errors = { path = \"../rustc_errors\" }\n rustc_session = { path = \"../rustc_session\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n+thin-vec = \"0.2.8\"\n+tracing = \"0.1\""}, {"sha": "85306d7184d893fa5657b8d4c3712eb1ac562694", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -155,26 +155,26 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let op = match *op {\n                     InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n                         reg: lower_reg(reg),\n-                        expr: self.lower_expr_mut(expr),\n+                        expr: self.lower_expr(expr),\n                     },\n                     InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n                         reg: lower_reg(reg),\n                         late,\n-                        expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                        expr: expr.as_ref().map(|expr| self.lower_expr(expr)),\n                     },\n                     InlineAsmOperand::InOut { reg, late, ref expr } => {\n                         hir::InlineAsmOperand::InOut {\n                             reg: lower_reg(reg),\n                             late,\n-                            expr: self.lower_expr_mut(expr),\n+                            expr: self.lower_expr(expr),\n                         }\n                     }\n                     InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n                             reg: lower_reg(reg),\n                             late,\n-                            in_expr: self.lower_expr_mut(in_expr),\n-                            out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                            in_expr: self.lower_expr(in_expr),\n+                            out_expr: out_expr.as_ref().map(|expr| self.lower_expr(expr)),\n                         }\n                     }\n                     InlineAsmOperand::Const { ref anon_const } => {\n@@ -220,7 +220,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 &sym.qself,\n                                 &sym.path,\n                                 ParamMode::Optional,\n-                                ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                             );\n                             hir::InlineAsmOperand::SymStatic { path, def_id }\n                         } else {\n@@ -237,7 +237,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             // Wrap the expression in an AnonConst.\n                             let parent_def_id = self.current_hir_id_owner;\n                             let node_id = self.next_node_id();\n-                            self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n+                            self.create_def(parent_def_id.def_id, node_id, DefPathData::AnonConst);\n                             let anon_const = AnonConst { id: node_id, value: P(expr) };\n                             hir::InlineAsmOperand::SymFn {\n                                 anon_const: self.lower_anon_const(&anon_const),"}, {"sha": "12a0cc0d25508654b3f8d7e1663087bb441d9c4d", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,8 +1,6 @@\n use crate::{ImplTraitContext, ImplTraitPosition, LoweringContext};\n use rustc_ast::{Block, BlockCheckMode, Local, LocalKind, Stmt, StmtKind};\n use rustc_hir as hir;\n-use rustc_session::parse::feature_err;\n-use rustc_span::sym;\n \n use smallvec::SmallVec;\n \n@@ -87,20 +85,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let ty = l\n             .ty\n             .as_ref()\n-            .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Variable)));\n+            .map(|t| self.lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::Variable)));\n         let init = l.kind.init().map(|init| self.lower_expr(init));\n         let hir_id = self.lower_node_id(l.id);\n         let pat = self.lower_pat(&l.pat);\n         let els = if let LocalKind::InitElse(_, els) = &l.kind {\n-            if !self.tcx.features().let_else {\n-                feature_err(\n-                    &self.tcx.sess.parse_sess,\n-                    sym::let_else,\n-                    l.span,\n-                    \"`let...else` statements are unstable\",\n-                )\n-                .emit();\n-            }\n             Some(self.lower_block(els, false))\n         } else {\n             None"}, {"sha": "63ff64b00bed617fc009d611398c0ff30e67cac4", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,8 +1,8 @@\n-use rustc_errors::{fluent, AddSubdiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay};\n-use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay};\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::generic_type_with_parentheses, code = \"E0214\")]\n pub struct GenericTypeWithParentheses {\n     #[primary_span]\n@@ -18,7 +18,7 @@ pub struct UseAngleBrackets {\n     pub close_param: Span,\n }\n \n-impl AddSubdiagnostic for UseAngleBrackets {\n+impl AddToDiagnostic for UseAngleBrackets {\n     fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n         diag.multipart_suggestion(\n             fluent::ast_lowering::use_angle_brackets,\n@@ -28,18 +28,32 @@ impl AddSubdiagnostic for UseAngleBrackets {\n     }\n }\n \n-#[derive(SessionDiagnostic)]\n-#[help]\n+#[derive(Diagnostic)]\n #[diag(ast_lowering::invalid_abi, code = \"E0703\")]\n+#[note]\n pub struct InvalidAbi {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     pub abi: Symbol,\n-    pub valid_abis: String,\n+    pub command: String,\n+    #[subdiagnostic]\n+    pub suggestion: Option<InvalidAbiSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    ast_lowering::invalid_abi_suggestion,\n+    code = \"{suggestion}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct InvalidAbiSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n+    pub suggestion: String,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::assoc_ty_parentheses)]\n pub struct AssocTyParentheses {\n     #[primary_span]\n@@ -54,7 +68,7 @@ pub enum AssocTyParenthesesSub {\n     NotEmpty { open_param: Span, close_param: Span },\n }\n \n-impl AddSubdiagnostic for AssocTyParenthesesSub {\n+impl AddToDiagnostic for AssocTyParenthesesSub {\n     fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n         match self {\n             Self::Empty { parentheses_span } => diag.multipart_suggestion(\n@@ -71,38 +85,38 @@ impl AddSubdiagnostic for AssocTyParenthesesSub {\n     }\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_lowering::misplaced_impl_trait, code = \"E0562\")]\n pub struct MisplacedImplTrait<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub position: DiagnosticArgFromDisplay<'a>,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::rustc_box_attribute_error)]\n pub struct RustcBoxAttributeError {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::underscore_expr_lhs_assign)]\n pub struct UnderscoreExprLhsAssign {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::base_expression_double_dot)]\n pub struct BaseExpressionDoubleDot {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::await_only_in_async_fn_and_blocks, code = \"E0728\")]\n pub struct AwaitOnlyInAsyncFnAndBlocks {\n     #[primary_span]\n@@ -112,58 +126,58 @@ pub struct AwaitOnlyInAsyncFnAndBlocks {\n     pub item_span: Option<Span>,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::generator_too_many_parameters, code = \"E0628\")]\n pub struct GeneratorTooManyParameters {\n     #[primary_span]\n     pub fn_decl_span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::closure_cannot_be_static, code = \"E0697\")]\n pub struct ClosureCannotBeStatic {\n     #[primary_span]\n     pub fn_decl_span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[help]\n #[diag(ast_lowering::async_non_move_closure_not_supported, code = \"E0708\")]\n pub struct AsyncNonMoveClosureNotSupported {\n     #[primary_span]\n     pub fn_decl_span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::functional_record_update_destructuring_assignment)]\n pub struct FunctionalRecordUpdateDestructuringAssignemnt {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::async_generators_not_supported, code = \"E0727\")]\n pub struct AsyncGeneratorsNotSupported {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::inline_asm_unsupported_target, code = \"E0472\")]\n pub struct InlineAsmUnsupportedTarget {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::att_syntax_only_x86)]\n pub struct AttSyntaxOnlyX86 {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::abi_specified_multiple_times)]\n pub struct AbiSpecifiedMultipleTimes {\n     #[primary_span]\n@@ -175,14 +189,14 @@ pub struct AbiSpecifiedMultipleTimes {\n     pub equivalent: Option<()>,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::clobber_abi_not_supported)]\n pub struct ClobberAbiNotSupported {\n     #[primary_span]\n     pub abi_span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[note]\n #[diag(ast_lowering::invalid_abi_clobber_abi)]\n pub struct InvalidAbiClobberAbi {\n@@ -191,7 +205,7 @@ pub struct InvalidAbiClobberAbi {\n     pub supported_abis: String,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::invalid_register)]\n pub struct InvalidRegister<'a> {\n     #[primary_span]\n@@ -200,7 +214,7 @@ pub struct InvalidRegister<'a> {\n     pub error: &'a str,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::invalid_register_class)]\n pub struct InvalidRegisterClass<'a> {\n     #[primary_span]\n@@ -209,7 +223,7 @@ pub struct InvalidRegisterClass<'a> {\n     pub error: &'a str,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_lowering::invalid_asm_template_modifier_reg_class)]\n pub struct InvalidAsmTemplateModifierRegClass {\n     #[primary_span]\n@@ -221,15 +235,15 @@ pub struct InvalidAsmTemplateModifierRegClass {\n     pub sub: InvalidAsmTemplateModifierRegClassSub,\n }\n \n-#[derive(SessionSubdiagnostic)]\n+#[derive(Subdiagnostic)]\n pub enum InvalidAsmTemplateModifierRegClassSub {\n     #[note(ast_lowering::support_modifiers)]\n     SupportModifier { class_name: Symbol, modifiers: String },\n     #[note(ast_lowering::does_not_support_modifiers)]\n     DoesNotSupportModifier { class_name: Symbol },\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::invalid_asm_template_modifier_const)]\n pub struct InvalidAsmTemplateModifierConst {\n     #[primary_span]\n@@ -239,7 +253,7 @@ pub struct InvalidAsmTemplateModifierConst {\n     pub op_span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::invalid_asm_template_modifier_sym)]\n pub struct InvalidAsmTemplateModifierSym {\n     #[primary_span]\n@@ -249,15 +263,15 @@ pub struct InvalidAsmTemplateModifierSym {\n     pub op_span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::register_class_only_clobber)]\n pub struct RegisterClassOnlyClobber {\n     #[primary_span]\n     pub op_span: Span,\n     pub reg_class_name: Symbol,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::register_conflict)]\n pub struct RegisterConflict<'a> {\n     #[primary_span]\n@@ -271,7 +285,7 @@ pub struct RegisterConflict<'a> {\n     pub in_out: Option<Span>,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[help]\n #[diag(ast_lowering::sub_tuple_binding)]\n pub struct SubTupleBinding<'a> {\n@@ -288,7 +302,7 @@ pub struct SubTupleBinding<'a> {\n     pub ctx: &'a str,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::extra_double_dot)]\n pub struct ExtraDoubleDot<'a> {\n     #[primary_span]\n@@ -299,38 +313,49 @@ pub struct ExtraDoubleDot<'a> {\n     pub ctx: &'a str,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[note]\n #[diag(ast_lowering::misplaced_double_dot)]\n pub struct MisplacedDoubleDot {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::misplaced_relax_trait_bound)]\n pub struct MisplacedRelaxTraitBound {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::not_supported_for_lifetime_binder_async_closure)]\n pub struct NotSupportedForLifetimeBinderAsyncClosure {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::arbitrary_expression_in_pattern)]\n pub struct ArbitraryExpressionInPattern {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic, Clone, Copy)]\n+#[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering::inclusive_range_with_no_end)]\n pub struct InclusiveRangeWithNoEnd {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering::trait_fn_async, code = \"E0706\")]\n+#[note]\n+#[note(ast_lowering::note2)]\n+pub struct TraitFnAsync {\n+    #[primary_span]\n+    pub fn_span: Span,\n+    #[label]\n+    pub span: Span,\n+}"}, {"sha": "94137391568c926354a21e1b5b2ee222b4b0fea4", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 43, "deletions": 32, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -7,7 +7,6 @@ use super::errors::{\n use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n use crate::{FnDeclKind, ImplTraitPosition};\n-\n use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n use rustc_ast::*;\n@@ -18,6 +17,7 @@ use rustc_hir::definitions::DefPathData;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::DUMMY_SP;\n+use thin_vec::thin_vec;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n@@ -66,12 +66,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         seg,\n                         ParamMode::Optional,\n                         ParenthesizedGenericArgs::Err,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     ));\n-                    let args = self.arena.alloc_from_iter(\n-                        [&*receiver].into_iter().chain(args.iter()).map(|x| self.lower_expr_mut(x)),\n-                    );\n-                    hir::ExprKind::MethodCall(hir_seg, args, self.lower_span(span))\n+                    let receiver = self.lower_expr(receiver);\n+                    let args =\n+                        self.arena.alloc_from_iter(args.iter().map(|x| self.lower_expr_mut(x)));\n+                    hir::ExprKind::MethodCall(hir_seg, receiver, args, self.lower_span(span))\n                 }\n                 ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                     let binop = self.lower_binop(binop);\n@@ -90,13 +90,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::Cast(ref expr, ref ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n-                        self.lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ExprKind::Cast(expr, ty)\n                 }\n                 ExprKind::Type(ref expr, ref ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n-                        self.lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ExprKind::Type(expr, ty)\n                 }\n                 ExprKind::AddrOf(k, m, ref ohs) => {\n@@ -146,13 +146,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n                     ),\n                 ExprKind::Await(ref expr) => {\n-                    let span = if expr.span.hi() < e.span.hi() {\n-                        expr.span.shrink_to_hi().with_hi(e.span.hi())\n+                    let dot_await_span = if expr.span.hi() < e.span.hi() {\n+                        let span_with_whitespace = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_extend_while(expr.span, char::is_whitespace)\n+                            .unwrap_or(expr.span);\n+                        span_with_whitespace.shrink_to_hi().with_hi(e.span.hi())\n                     } else {\n                         // this is a recovered `await expr`\n                         e.span\n                     };\n-                    self.lower_expr_await(span, expr)\n+                    self.lower_expr_await(dot_await_span, expr)\n                 }\n                 ExprKind::Closure(\n                     ref binder,\n@@ -219,7 +225,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         qself,\n                         path,\n                         ParamMode::Optional,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     );\n                     hir::ExprKind::Path(qpath)\n                 }\n@@ -253,7 +259,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             &se.qself,\n                             &se.path,\n                             ParamMode::Optional,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                         )),\n                         self.arena\n                             .alloc_from_iter(se.fields.iter().map(|x| self.lower_expr_field(x))),\n@@ -353,7 +359,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let node_id = self.next_node_id();\n \n                 // Add a definition for the in-band const def.\n-                self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n+                self.create_def(parent_def_id.def_id, node_id, DefPathData::AnonConst);\n \n                 let anon_const = AnonConst { id: node_id, value: arg };\n                 generic_args.push(AngleBracketedArg::Arg(GenericArg::Const(anon_const)));\n@@ -552,7 +558,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         let output = match ret_ty {\n             Some(ty) => hir::FnRetTy::Return(\n-                self.lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock)),\n+                self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock)),\n             ),\n             None => hir::FnRetTy::DefaultReturn(self.lower_span(span)),\n         };\n@@ -577,7 +583,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let (pat, task_context_hid) = self.pat_ident_binding_mode(\n             span,\n             Ident::with_dummy_span(sym::_task_context),\n-            hir::BindingAnnotation::Mutable,\n+            hir::BindingAnnotation::MUT,\n         );\n         let param = hir::Param {\n             hir_id: self.next_id(),\n@@ -671,7 +677,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // this name to identify what is being awaited by a suspended async functions.\n         let awaitee_ident = Ident::with_dummy_span(sym::__awaitee);\n         let (awaitee_pat, awaitee_pat_hid) =\n-            self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::Mutable);\n+            self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::MUT);\n \n         let task_context_ident = Ident::with_dummy_span(sym::_task_context);\n \n@@ -849,7 +855,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let bound_generic_params = self.lower_lifetime_binder(closure_id, generic_params);\n         // Lower outside new scope to preserve `is_in_loop_condition`.\n-        let fn_decl = self.lower_fn_decl(decl, None, FnDeclKind::Closure, None);\n+        let fn_decl = self.lower_fn_decl(decl, None, fn_decl_span, FnDeclKind::Closure, None);\n \n         let c = self.arena.alloc(hir::Closure {\n             binder: binder_clause,\n@@ -949,11 +955,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         });\n \n         let bound_generic_params = self.lower_lifetime_binder(closure_id, generic_params);\n-\n         // We need to lower the declaration outside the new scope, because we\n         // have to conserve the state of being inside a loop condition for the\n         // closure argument types.\n-        let fn_decl = self.lower_fn_decl(&outer_decl, None, FnDeclKind::Closure, None);\n+        let fn_decl =\n+            self.lower_fn_decl(&outer_decl, None, fn_decl_span, FnDeclKind::Closure, None);\n \n         let c = self.arena.alloc(hir::Closure {\n             binder: binder_clause,\n@@ -1123,11 +1129,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         qself,\n                         path,\n                         ParamMode::Optional,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     );\n                     // Destructure like a tuple struct.\n-                    let tuple_struct_pat =\n-                        hir::PatKind::TupleStruct(qpath, pats, rest.map(|r| r.0));\n+                    let tuple_struct_pat = hir::PatKind::TupleStruct(\n+                        qpath,\n+                        pats,\n+                        hir::DotDotPos::new(rest.map(|r| r.0)),\n+                    );\n                     return self.pat_without_dbm(lhs.span, tuple_struct_pat);\n                 }\n             }\n@@ -1139,7 +1148,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         qself,\n                         path,\n                         ParamMode::Optional,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     );\n                     // Destructure like a unit struct.\n                     let unit_struct_pat = hir::PatKind::Path(qpath);\n@@ -1163,7 +1172,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     &se.qself,\n                     &se.path,\n                     ParamMode::Optional,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                 );\n                 let fields_omitted = match &se.rest {\n                     StructRest::Base(e) => {\n@@ -1182,13 +1191,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ExprKind::Tup(elements) => {\n                 let (pats, rest) =\n                     self.destructure_sequence(elements, \"tuple\", eq_sign_span, assignments);\n-                let tuple_pat = hir::PatKind::Tuple(pats, rest.map(|r| r.0));\n+                let tuple_pat = hir::PatKind::Tuple(pats, hir::DotDotPos::new(rest.map(|r| r.0)));\n                 return self.pat_without_dbm(lhs.span, tuple_pat);\n             }\n             ExprKind::Paren(e) => {\n                 // We special-case `(..)` for consistency with patterns.\n                 if let ExprKind::Range(None, None, RangeLimits::HalfOpen) = e.kind {\n-                    let tuple_pat = hir::PatKind::Tuple(&[], Some(0));\n+                    let tuple_pat = hir::PatKind::Tuple(&[], hir::DotDotPos::new(Some(0)));\n                     return self.pat_without_dbm(lhs.span, tuple_pat);\n                 } else {\n                     return self.destructure_assign_mut(e, eq_sign_span, assignments);\n@@ -1433,7 +1442,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `mut iter`\n         let iter = Ident::with_dummy_span(sym::iter);\n         let (iter_pat, iter_pat_nid) =\n-            self.pat_ident_binding_mode(head_span, iter, hir::BindingAnnotation::Mutable);\n+            self.pat_ident_binding_mode(head_span, iter, hir::BindingAnnotation::MUT);\n \n         // `match Iterator::next(&mut iter) { ... }`\n         let match_expr = {\n@@ -1539,9 +1548,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let uc_nested = attr::mk_nested_word_item(uc_ident);\n                 attr::mk_list_item(allow_ident, vec![uc_nested])\n             };\n-            attr::mk_attr_outer(allow)\n+            attr::mk_attr_outer(&self.tcx.sess.parse_sess.attr_id_generator, allow)\n         };\n-        let attrs: AttrVec = vec![attr].into();\n+        let attrs: AttrVec = thin_vec![attr];\n \n         // `ControlFlow::Continue(val) => #[allow(unreachable_code)] val,`\n         let continue_arm = {\n@@ -1776,12 +1785,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         binding: hir::HirId,\n         attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n+        let hir_id = self.next_id();\n+        let res = Res::Local(binding);\n         let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n             None,\n             self.arena.alloc(hir::Path {\n                 span: self.lower_span(span),\n-                res: Res::Local(binding),\n-                segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n+                res,\n+                segments: arena_vec![self; hir::PathSegment::new(ident, hir_id, res)],\n             }),\n         ));\n "}, {"sha": "6d71679634331e90039ada4f32c9bd02cb0d67e3", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -11,8 +11,6 @@ use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{Span, DUMMY_SP};\n \n-use tracing::debug;\n-\n /// A visitor that walks over the HIR and collects `Node`s into a HIR map.\n pub(super) struct NodeCollector<'a, 'hir> {\n     /// Source map\n@@ -26,12 +24,12 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The parent of this node\n     parent_node: hir::ItemLocalId,\n \n-    owner: LocalDefId,\n+    owner: OwnerId,\n \n     definitions: &'a definitions::Definitions,\n }\n \n-#[tracing::instrument(level = \"debug\", skip(sess, definitions, bodies))]\n+#[instrument(level = \"debug\", skip(sess, definitions, bodies))]\n pub(super) fn index_hir<'hir>(\n     sess: &Session,\n     definitions: &definitions::Definitions,\n@@ -67,10 +65,11 @@ pub(super) fn index_hir<'hir>(\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n         debug_assert_eq!(self.owner, hir_id.owner);\n         debug_assert_ne!(hir_id.local_id.as_u32(), 0);\n+        debug_assert_ne!(hir_id.local_id, self.parent_node);\n \n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n@@ -82,9 +81,9 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n                     self.source_map.span_to_diagnostic_string(span),\n                     node,\n-                    self.definitions.def_path(self.owner).to_string_no_crate_verbose(),\n+                    self.definitions.def_path(self.owner.def_id).to_string_no_crate_verbose(),\n                     self.owner,\n-                    self.definitions.def_path(hir_id.owner).to_string_no_crate_verbose(),\n+                    self.definitions.def_path(hir_id.owner.def_id).to_string_no_crate_verbose(),\n                     hir_id.owner,\n                 )\n             }\n@@ -113,19 +112,19 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        self.insert_nested(item.def_id);\n+        self.insert_nested(item.def_id.def_id);\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n-        self.insert_nested(item_id.def_id);\n+        self.insert_nested(item_id.def_id.def_id);\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        self.insert_nested(item_id.def_id);\n+        self.insert_nested(item_id.def_id.def_id);\n     }\n \n     fn visit_nested_foreign_item(&mut self, foreign_id: ForeignItemId) {\n-        self.insert_nested(foreign_id.def_id);\n+        self.insert_nested(foreign_id.def_id.def_id);\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n@@ -142,7 +141,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug_assert_eq!(i.def_id, self.owner);\n         self.with_parent(i.hir_id(), |this| {\n@@ -156,7 +155,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn visit_foreign_item(&mut self, fi: &'hir ForeignItem<'hir>) {\n         debug_assert_eq!(fi.def_id, self.owner);\n         self.with_parent(fi.hir_id(), |this| {\n@@ -175,15 +174,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         })\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n         debug_assert_eq!(ti.def_id, self.owner);\n         self.with_parent(ti.hir_id(), |this| {\n             intravisit::walk_trait_item(this, ti);\n         });\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n         debug_assert_eq!(ii.def_id, self.owner);\n         self.with_parent(ii.hir_id(), |this| {\n@@ -247,11 +246,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'hir PathSegment<'hir>) {\n-        if let Some(hir_id) = path_segment.hir_id {\n-            self.insert(path_span, hir_id, Node::PathSegment(path_segment));\n-        }\n-        intravisit::walk_path_segment(self, path_span, path_segment);\n+    fn visit_path_segment(&mut self, path_segment: &'hir PathSegment<'hir>) {\n+        self.insert(path_segment.ident.span, path_segment.hir_id, Node::PathSegment(path_segment));\n+        intravisit::walk_path_segment(self, path_segment);\n     }\n \n     fn visit_ty(&mut self, ty: &'hir Ty<'hir>) {\n@@ -283,12 +280,12 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         fk: intravisit::FnKind<'hir>,\n         fd: &'hir FnDecl<'hir>,\n         b: BodyId,\n-        s: Span,\n+        _: Span,\n         id: HirId,\n     ) {\n         assert_eq!(self.owner, id.owner);\n         assert_eq!(self.parent_node, id.local_id);\n-        intravisit::walk_fn(self, fk, fd, b, s, id);\n+        intravisit::walk_fn(self, fk, fd, b, id);\n     }\n \n     fn visit_block(&mut self, block: &'hir Block<'hir>) {"}, {"sha": "d9b18d68e537f3b2250da035f28030fade1f8cf9", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 117, "deletions": 79, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,6 +1,6 @@\n-use super::errors::{InvalidAbi, MisplacedRelaxTraitBound};\n+use super::errors::{InvalidAbi, InvalidAbiSuggestion, MisplacedRelaxTraitBound};\n use super::ResolverAstLoweringExt;\n-use super::{AstOwner, ImplTraitContext, ImplTraitPosition};\n+use super::{Arena, AstOwner, ImplTraitContext, ImplTraitPosition};\n use super::{FnDeclKind, LoweringContext, ParamMode};\n \n use rustc_ast::ptr::P;\n@@ -14,9 +14,10 @@ use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::PredicateOrigin;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::{DefIdTree, ResolverAstLowering, TyCtxt};\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use rustc_target::spec::abi;\n use smallvec::{smallvec, SmallVec};\n \n@@ -25,6 +26,7 @@ use std::iter;\n pub(super) struct ItemLowerer<'a, 'hir> {\n     pub(super) tcx: TyCtxt<'hir>,\n     pub(super) resolver: &'a mut ResolverAstLowering,\n+    pub(super) ast_arena: &'a Arena<'static>,\n     pub(super) ast_index: &'a IndexVec<LocalDefId, AstOwner<'a>>,\n     pub(super) owners: &'a mut IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n }\n@@ -60,12 +62,13 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             tcx: self.tcx,\n             resolver: self.resolver,\n             arena: self.tcx.hir_arena,\n+            ast_arena: self.ast_arena,\n \n             // HirId handling.\n             bodies: Vec::new(),\n             attrs: SortedMap::default(),\n             children: FxHashMap::default(),\n-            current_hir_id_owner: CRATE_DEF_ID,\n+            current_hir_id_owner: hir::CRATE_OWNER_ID,\n             item_local_id_counter: hir::ItemLocalId::new(0),\n             node_id_to_local_id: Default::default(),\n             local_id_to_def_id: SortedMap::new(),\n@@ -85,6 +88,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             allow_try_trait: Some([sym::try_trait_v2, sym::yeet_desugar_details][..].into()),\n             allow_gen_future: Some([sym::gen_future][..].into()),\n             allow_into_future: Some([sym::into_future][..].into()),\n+            generics_def_id_map: Default::default(),\n         };\n         lctx.with_hir_id_owner(owner, |lctx| f(lctx));\n \n@@ -120,7 +124,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n         self.with_lctx(CRATE_NODE_ID, |lctx| {\n             let module = lctx.lower_mod(&c.items, &c.spans);\n             lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n-            hir::OwnerNode::Crate(lctx.arena.alloc(module))\n+            hir::OwnerNode::Crate(module)\n         })\n     }\n \n@@ -158,18 +162,23 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n }\n \n impl<'hir> LoweringContext<'_, 'hir> {\n-    pub(super) fn lower_mod(&mut self, items: &[P<Item>], spans: &ModSpans) -> hir::Mod<'hir> {\n-        hir::Mod {\n+    pub(super) fn lower_mod(\n+        &mut self,\n+        items: &[P<Item>],\n+        spans: &ModSpans,\n+    ) -> &'hir hir::Mod<'hir> {\n+        self.arena.alloc(hir::Mod {\n             spans: hir::ModSpans {\n                 inner_span: self.lower_span(spans.inner_span),\n                 inject_use_span: self.lower_span(spans.inject_use_span),\n             },\n             item_ids: self.arena.alloc_from_iter(items.iter().flat_map(|x| self.lower_item_ref(x))),\n-        }\n+        })\n     }\n \n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        let mut node_ids = smallvec![hir::ItemId { def_id: self.local_def_id(i.id) }];\n+        let mut node_ids =\n+            smallvec![hir::ItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n         if let ItemKind::Use(ref use_tree) = &i.kind {\n             self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n         }\n@@ -185,7 +194,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match tree.kind {\n             UseTreeKind::Nested(ref nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n-                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n+                    vec.push(hir::ItemId {\n+                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                    });\n                     self.lower_item_id_use_tree(nested, id, vec);\n                 }\n             }\n@@ -194,7 +205,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 for (_, &id) in\n                     iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n-                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n+                    vec.push(hir::ItemId {\n+                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                    });\n                 }\n             }\n         }\n@@ -259,10 +272,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let body_id =\n                         this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n \n-                    let itctx = ImplTraitContext::Universal;\n-                    let (generics, decl) = this.lower_generics(generics, id, itctx, |this| {\n+                    let mut itctx = ImplTraitContext::Universal;\n+                    let (generics, decl) = this.lower_generics(generics, id, &mut itctx, |this| {\n                         let ret_id = asyncness.opt_return_id();\n-                        this.lower_fn_decl(&decl, Some(id), FnDeclKind::Fn, ret_id)\n+                        this.lower_fn_decl(&decl, Some(id), fn_sig_span, FnDeclKind::Fn, ret_id)\n                     });\n                     let sig = hir::FnSig {\n                         decl,\n@@ -306,8 +319,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, ty) = self.lower_generics(\n                     &generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    |this| this.lower_ty(ty, ImplTraitContext::TypeAliasesOpaqueTy),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    |this| this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy),\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n@@ -319,7 +332,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, ty) = self.lower_generics(\n                     &generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| this.arena.alloc(this.ty(span, hir::TyKind::Err)),\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n@@ -328,7 +341,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, variants) = self.lower_generics(\n                     generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         this.arena.alloc_from_iter(\n                             enum_definition.variants.iter().map(|x| this.lower_variant(x)),\n@@ -341,7 +354,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, struct_def) = self.lower_generics(\n                     generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| this.lower_variant_data(hir_id, struct_def),\n                 );\n                 hir::ItemKind::Struct(struct_def, generics)\n@@ -350,7 +363,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, vdata) = self.lower_generics(\n                     generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| this.lower_variant_data(hir_id, vdata),\n                 );\n                 hir::ItemKind::Union(vdata, generics)\n@@ -378,18 +391,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // method, it will not be considered an in-band\n                 // lifetime to be added, but rather a reference to a\n                 // parent lifetime.\n-                let itctx = ImplTraitContext::Universal;\n+                let mut itctx = ImplTraitContext::Universal;\n                 let (generics, (trait_ref, lowered_ty)) =\n-                    self.lower_generics(ast_generics, id, itctx, |this| {\n+                    self.lower_generics(ast_generics, id, &mut itctx, |this| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n                             this.lower_trait_ref(\n                                 trait_ref,\n-                                ImplTraitContext::Disallowed(ImplTraitPosition::Trait),\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::Trait),\n                             )\n                         });\n \n                         let lowered_ty = this\n-                            .lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                            .lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n \n                         (trait_ref, lowered_ty)\n                     });\n@@ -428,11 +441,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, (unsafety, items, bounds)) = self.lower_generics(\n                     generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         let bounds = this.lower_param_bounds(\n                             bounds,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                         );\n                         let items = this.arena.alloc_from_iter(\n                             items.iter().map(|item| this.lower_trait_item_ref(item)),\n@@ -447,11 +460,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, bounds) = self.lower_generics(\n                     generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         this.lower_param_bounds(\n                             bounds,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                         )\n                     },\n                 );\n@@ -474,7 +487,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         body: Option<&Expr>,\n     ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n-        let ty = self.lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+        let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n         (ty, self.lower_const_body(span, body))\n     }\n \n@@ -545,7 +558,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: new_id,\n+                            def_id: hir::OwnerId { def_id: new_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -619,7 +632,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: new_hir_id,\n+                            def_id: hir::OwnerId { def_id: new_hir_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -647,12 +660,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             kind: match i.kind {\n                 ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n                     let fdec = &sig.decl;\n-                    let itctx = ImplTraitContext::Universal;\n+                    let mut itctx = ImplTraitContext::Universal;\n                     let (generics, (fn_dec, fn_args)) =\n-                        self.lower_generics(generics, i.id, itctx, |this| {\n+                        self.lower_generics(generics, i.id, &mut itctx, |this| {\n                             (\n                                 // Disallow `impl Trait` in foreign items.\n-                                this.lower_fn_decl(fdec, None, FnDeclKind::ExternFn, None),\n+                                this.lower_fn_decl(\n+                                    fdec,\n+                                    None,\n+                                    sig.span,\n+                                    FnDeclKind::ExternFn,\n+                                    None,\n+                                ),\n                                 this.lower_fn_params_to_names(fdec),\n                             )\n                         });\n@@ -661,7 +680,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ForeignItemKind::Static(ref t, m, _) => {\n                     let ty =\n-                        self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        self.lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ForeignItemKind::Static(ty, m)\n                 }\n                 ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n@@ -675,7 +694,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: self.local_def_id(i.id) },\n+            id: hir::ForeignItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n         }\n@@ -729,11 +748,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 qself,\n                 path,\n                 ParamMode::ExplicitNamed, // no `'_` in declarations (Issue #61124)\n-                ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n             );\n             self.arena.alloc(t)\n         } else {\n-            self.lower_ty(&f.ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+            self.lower_ty(&f.ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n         };\n         let hir_id = self.lower_node_id(f.id);\n         self.lower_attrs(hir_id, &f.attrs);\n@@ -756,14 +775,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let (generics, kind, has_default) = match i.kind {\n             AssocItemKind::Const(_, ref ty, ref default) => {\n-                let ty = self.lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n                 (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body), body.is_some())\n             }\n             AssocItemKind::Fn(box Fn { ref sig, ref generics, body: None, .. }) => {\n+                let asyncness = sig.header.asyncness;\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n-                let (generics, sig) =\n-                    self.lower_method_sig(generics, sig, i.id, FnDeclKind::Trait, None);\n+                let (generics, sig) = self.lower_method_sig(\n+                    generics,\n+                    sig,\n+                    i.id,\n+                    FnDeclKind::Trait,\n+                    asyncness.opt_return_id(),\n+                );\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Required(names)), false)\n             }\n             AssocItemKind::Fn(box Fn { ref sig, ref generics, body: Some(ref body), .. }) => {\n@@ -791,15 +816,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, kind) = self.lower_generics(\n                     &generics,\n                     i.id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         let ty = ty.as_ref().map(|x| {\n-                            this.lower_ty(x, ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+                            this.lower_ty(x, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n                         });\n                         hir::TraitItemKind::Type(\n                             this.lower_param_bounds(\n                                 bounds,\n-                                ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                             ),\n                             ty,\n                         )\n@@ -831,7 +856,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { def_id: self.local_def_id(i.id) };\n+        let id = hir::TraitItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } };\n         hir::TraitItemRef {\n             id,\n             ident: self.lower_ident(i.ident),\n@@ -852,7 +877,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let (generics, kind) = match &i.kind {\n             AssocItemKind::Const(_, ty, expr) => {\n-                let ty = self.lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 (\n                     hir::Generics::empty(),\n                     hir::ImplItemKind::Const(ty, self.lower_const_body(i.span, expr.as_deref())),\n@@ -879,14 +904,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_generics(\n                     &generics,\n                     i.id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| match ty {\n                         None => {\n                             let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err));\n                             hir::ImplItemKind::TyAlias(ty)\n                         }\n                         Some(ty) => {\n-                            let ty = this.lower_ty(ty, ImplTraitContext::TypeAliasesOpaqueTy);\n+                            let ty = this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy);\n                             hir::ImplItemKind::TyAlias(ty)\n                         }\n                     },\n@@ -911,7 +936,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: self.local_def_id(i.id) },\n+            id: hir::ImplItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n             kind: match &i.kind {\n@@ -947,7 +972,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         params: &'hir [hir::Param<'hir>],\n         value: hir::Expr<'hir>,\n     ) -> hir::BodyId {\n-        let body = hir::Body { generator_kind: self.generator_kind, params, value };\n+        let body = hir::Body {\n+            generator_kind: self.generator_kind,\n+            params,\n+            value: self.arena.alloc(value),\n+        };\n         let id = body.id();\n         debug_assert_eq!(id.hir_id.owner, self.current_hir_id_owner);\n         self.bodies.push((id.hir_id.local_id, self.arena.alloc(body)));\n@@ -1026,9 +1055,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         asyncness: Async,\n         body: Option<&Block>,\n     ) -> hir::BodyId {\n-        let closure_id = match asyncness {\n-            Async::Yes { closure_id, .. } => closure_id,\n-            Async::No => return self.lower_fn_body_block(span, decl, body),\n+        let (closure_id, body) = match (asyncness, body) {\n+            (Async::Yes { closure_id, .. }, Some(body)) => (closure_id, body),\n+            _ => return self.lower_fn_body_block(span, decl, body),\n         };\n \n         self.lower_body(|this| {\n@@ -1074,12 +1103,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n                 // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n                 let (ident, is_simple_parameter) = match parameter.pat.kind {\n-                    hir::PatKind::Binding(\n-                        hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable,\n-                        _,\n-                        ident,\n-                        _,\n-                    ) => (ident, true),\n+                    hir::PatKind::Binding(hir::BindingAnnotation(ByRef::No, _), _, ident, _) => {\n+                        (ident, true)\n+                    }\n                     // For `ref mut` or wildcard arguments, we can't reuse the binding, but\n                     // we can keep the same name for the parameter.\n                     // This lets rustdoc render it correctly in documentation.\n@@ -1144,7 +1170,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let (move_pat, move_id) = this.pat_ident_binding_mode(\n                         desugared_span,\n                         ident,\n-                        hir::BindingAnnotation::Mutable,\n+                        hir::BindingAnnotation::MUT,\n                     );\n                     let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n@@ -1173,16 +1199,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 parameters.push(new_parameter);\n             }\n \n-            let body_span = body.map_or(span, |b| b.span);\n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value,\n                 closure_id,\n                 None,\n-                body_span,\n+                body.span,\n                 hir::AsyncGeneratorKind::Fn,\n                 |this| {\n                     // Create a block from the user's function body:\n-                    let user_body = this.lower_block_expr_opt(body_span, body);\n+                    let user_body = this.lower_block_expr(body);\n \n                     // Transform into `drop-temps { <user-body> }`, an expression:\n                     let desugared_span =\n@@ -1214,7 +1239,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             (\n                 this.arena.alloc_from_iter(parameters),\n-                this.expr(body_span, async_expr, AttrVec::new()),\n+                this.expr(body.span, async_expr, AttrVec::new()),\n             )\n         })\n     }\n@@ -1225,12 +1250,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         sig: &FnSig,\n         id: NodeId,\n         kind: FnDeclKind,\n-        is_async: Option<NodeId>,\n+        is_async: Option<(NodeId, Span)>,\n     ) -> (&'hir hir::Generics<'hir>, hir::FnSig<'hir>) {\n         let header = self.lower_fn_header(sig.header);\n-        let itctx = ImplTraitContext::Universal;\n-        let (generics, decl) = self.lower_generics(generics, id, itctx, |this| {\n-            this.lower_fn_decl(&sig.decl, Some(id), kind, is_async)\n+        let mut itctx = ImplTraitContext::Universal;\n+        let (generics, decl) = self.lower_generics(generics, id, &mut itctx, |this| {\n+            this.lower_fn_decl(&sig.decl, Some(id), sig.span, kind, is_async)\n         });\n         (generics, hir::FnSig { header, decl, span: self.lower_span(sig.span) })\n     }\n@@ -1260,10 +1285,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn error_on_invalid_abi(&self, abi: StrLit) {\n+        let abi_names = abi::enabled_names(self.tcx.features(), abi.span)\n+            .iter()\n+            .map(|s| Symbol::intern(s))\n+            .collect::<Vec<_>>();\n+        let suggested_name = find_best_match_for_name(&abi_names, abi.symbol_unescaped, None);\n         self.tcx.sess.emit_err(InvalidAbi {\n+            abi: abi.symbol_unescaped,\n             span: abi.span,\n-            abi: abi.symbol,\n-            valid_abis: abi::all_names().join(\", \"),\n+            suggestion: suggested_name.map(|suggested_name| InvalidAbiSuggestion {\n+                span: abi.span,\n+                suggestion: format!(\"\\\"{suggested_name}\\\"\"),\n+            }),\n+            command: \"rustc --print=calling-conventions\".to_string(),\n         });\n     }\n \n@@ -1295,7 +1329,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         generics: &Generics,\n         parent_node_id: NodeId,\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> (&'hir hir::Generics<'hir>, T) {\n         debug_assert!(self.impl_trait_defs.is_empty());\n@@ -1400,7 +1434,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         kind: &GenericParamKind,\n         bounds: &[GenericBound],\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n         origin: PredicateOrigin,\n     ) -> Option<hir::WherePredicate<'hir>> {\n         // Do not create a clause if we do not have anything inside it.\n@@ -1431,10 +1465,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             GenericParamKind::Const { .. } => None,\n             GenericParamKind::Type { .. } => {\n                 let def_id = self.local_def_id(id).to_def_id();\n+                let hir_id = self.next_id();\n+                let res = Res::Def(DefKind::TyParam, def_id);\n                 let ty_path = self.arena.alloc(hir::Path {\n                     span: param_span,\n-                    res: Res::Def(DefKind::TyParam, def_id),\n-                    segments: self.arena.alloc_from_iter([hir::PathSegment::from_ident(ident)]),\n+                    res,\n+                    segments: self\n+                        .arena\n+                        .alloc_from_iter([hir::PathSegment::new(ident, hir_id, res)]),\n                 });\n                 let ty_id = self.next_id();\n                 let bounded_ty =\n@@ -1472,11 +1510,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                 bound_generic_params: self.lower_generic_params(bound_generic_params),\n                 bounded_ty: self\n-                    .lower_ty(bounded_ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                    .lower_ty(bounded_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n                 bounds: self.arena.alloc_from_iter(bounds.iter().map(|bound| {\n                     self.lower_param_bound(\n                         bound,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                     )\n                 })),\n                 span: self.lower_span(span),\n@@ -1491,16 +1529,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 lifetime: self.lower_lifetime(lifetime),\n                 bounds: self.lower_param_bounds(\n                     bounds,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                 ),\n                 in_where_clause: true,\n             }),\n             WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, span }) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     lhs_ty: self\n-                        .lower_ty(lhs_ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                        .lower_ty(lhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n                     rhs_ty: self\n-                        .lower_ty(rhs_ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                        .lower_ty(rhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n                     span: self.lower_span(span),\n                 })\n             }"}, {"sha": "275ceed30d7da0cb70f93eaccb4c388ef9adb06c", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 248, "deletions": 156, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -32,7 +32,6 @@\n \n #![feature(box_patterns)]\n #![feature(let_chains)]\n-#![feature(let_else)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n@@ -42,8 +41,9 @@\n #[macro_use]\n extern crate tracing;\n \n-use crate::errors::{AssocTyParentheses, AssocTyParenthesesSub, MisplacedImplTrait};\n+use crate::errors::{AssocTyParentheses, AssocTyParenthesesSub, MisplacedImplTrait, TraitFnAsync};\n \n+use rustc_arena::declare_arena;\n use rustc_ast::ptr::P;\n use rustc_ast::visit;\n use rustc_ast::{self as ast, *};\n@@ -95,6 +95,13 @@ struct LoweringContext<'a, 'hir> {\n     /// Used to allocate HIR nodes.\n     arena: &'hir hir::Arena<'hir>,\n \n+    /// Used to allocate temporary AST nodes for use during lowering.\n+    /// This allows us to create \"fake\" AST -- these nodes can sometimes\n+    /// be allocated on the stack, but other times we need them to live longer\n+    /// than the current stack frame, so they can be collected into vectors\n+    /// and things like that.\n+    ast_arena: &'a Arena<'static>,\n+\n     /// Bodies inside the owner being lowered.\n     bodies: Vec<(hir::ItemLocalId, &'hir hir::Body<'hir>)>,\n     /// Attributes inside the owner being lowered.\n@@ -118,7 +125,7 @@ struct LoweringContext<'a, 'hir> {\n     is_in_trait_impl: bool,\n     is_in_dyn_type: bool,\n \n-    current_hir_id_owner: LocalDefId,\n+    current_hir_id_owner: hir::OwnerId,\n     item_local_id_counter: hir::ItemLocalId,\n     local_id_to_def_id: SortedMap<ItemLocalId, LocalDefId>,\n     trait_map: FxHashMap<ItemLocalId, Box<[TraitCandidate]>>,\n@@ -132,8 +139,23 @@ struct LoweringContext<'a, 'hir> {\n     allow_try_trait: Option<Lrc<[Symbol]>>,\n     allow_gen_future: Option<Lrc<[Symbol]>>,\n     allow_into_future: Option<Lrc<[Symbol]>>,\n+\n+    /// Mapping from generics `def_id`s to TAIT generics `def_id`s.\n+    /// For each captured lifetime (e.g., 'a), we create a new lifetime parameter that is a generic\n+    /// defined on the TAIT, so we have type Foo<'a1> = ... and we establish a mapping in this\n+    /// field from the original parameter 'a to the new parameter 'a1.\n+    generics_def_id_map: Vec<FxHashMap<LocalDefId, LocalDefId>>,\n }\n \n+declare_arena!([\n+    [] tys: rustc_ast::Ty,\n+    [] aba: rustc_ast::AngleBracketedArgs,\n+    [] ptr: rustc_ast::PolyTraitRef,\n+    // This _marker field is needed because `declare_arena` creates `Arena<'tcx>` and we need to\n+    // use `'tcx`. If we don't have this we get a compile error.\n+    [] _marker: std::marker::PhantomData<&'tcx ()>,\n+]);\n+\n trait ResolverAstLoweringExt {\n     fn legacy_const_generic_args(&self, expr: &Expr) -> Option<Vec<usize>>;\n     fn get_partial_res(&self, id: NodeId) -> Option<PartialRes>;\n@@ -142,12 +164,6 @@ trait ResolverAstLoweringExt {\n     fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes>;\n     fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)>;\n     fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind;\n-    /// Record the map from `from` local def id to `to` local def id, on `generics_def_id_map`\n-    /// field.\n-    fn record_def_id_remap(&mut self, from: LocalDefId, to: LocalDefId);\n-    /// Get the previously recorded `to` local def id given the `from` local def id, obtained using\n-    /// `generics_def_id_map` field.\n-    fn get_remapped_def_id(&self, local_def_id: LocalDefId) -> LocalDefId;\n }\n \n impl ResolverAstLoweringExt for ResolverAstLowering {\n@@ -215,41 +231,6 @@ impl ResolverAstLoweringExt for ResolverAstLowering {\n     fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind {\n         self.builtin_macro_kinds.get(&def_id).copied().unwrap_or(MacroKind::Bang)\n     }\n-\n-    /// Push a remapping into the top-most map.\n-    /// Panics if no map has been pushed.\n-    /// Remapping is used when creating lowering `-> impl Trait` return\n-    /// types to create the resulting opaque type.\n-    #[tracing::instrument(level = \"debug\", skip(self))]\n-    fn record_def_id_remap(&mut self, from: LocalDefId, to: LocalDefId) {\n-        self.generics_def_id_map.last_mut().expect(\"no map pushed\").insert(from, to);\n-    }\n-\n-    fn get_remapped_def_id(&self, mut local_def_id: LocalDefId) -> LocalDefId {\n-        // `generics_def_id_map` is a stack of mappings. As we go deeper in impl traits nesting we\n-        // push new mappings so we need to try first the latest mappings, hence `iter().rev()`.\n-        //\n-        // Consider:\n-        //\n-        // `fn test<'a, 'b>() -> impl Trait<&'a u8, Ty = impl Sized + 'b> {}`\n-        //\n-        // We would end with a generics_def_id_map like:\n-        //\n-        // `[[fn#'b -> impl_trait#'b], [fn#'b -> impl_sized#'b]]`\n-        //\n-        // for the opaque type generated on `impl Sized + 'b`, We want the result to be:\n-        // impl_sized#'b, so iterating forward is the wrong thing to do.\n-        for map in self.generics_def_id_map.iter().rev() {\n-            if let Some(r) = map.get(&local_def_id) {\n-                debug!(\"def_id_remapper: remapping from `{local_def_id:?}` to `{r:?}`\");\n-                local_def_id = *r;\n-            } else {\n-                debug!(\"def_id_remapper: no remapping for `{local_def_id:?}` found in map\");\n-            }\n-        }\n-\n-        local_def_id\n-    }\n }\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n@@ -270,6 +251,7 @@ enum ImplTraitContext {\n     ReturnPositionOpaqueTy {\n         /// Origin: Either OpaqueTyOrigin::FnReturn or OpaqueTyOrigin::AsyncFn,\n         origin: hir::OpaqueTyOrigin,\n+        in_trait: bool,\n     },\n     /// Impl trait in type aliases.\n     TypeAliasesOpaqueTy,\n@@ -329,7 +311,7 @@ impl std::fmt::Display for ImplTraitPosition {\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq)]\n enum FnDeclKind {\n     Fn,\n     Inherent,\n@@ -341,9 +323,20 @@ enum FnDeclKind {\n }\n \n impl FnDeclKind {\n-    fn impl_trait_return_allowed(&self) -> bool {\n+    fn impl_trait_allowed(&self, tcx: TyCtxt<'_>) -> bool {\n+        match self {\n+            FnDeclKind::Fn | FnDeclKind::Inherent => true,\n+            FnDeclKind::Impl if tcx.features().return_position_impl_trait_in_trait => true,\n+            FnDeclKind::Trait if tcx.features().return_position_impl_trait_in_trait => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn async_fn_allowed(&self, tcx: TyCtxt<'_>) -> bool {\n         match self {\n             FnDeclKind::Fn | FnDeclKind::Inherent => true,\n+            FnDeclKind::Impl if tcx.features().async_fn_in_trait => true,\n+            FnDeclKind::Trait if tcx.features().async_fn_in_trait => true,\n             _ => false,\n         }\n     }\n@@ -436,10 +429,13 @@ pub fn lower_to_hir<'hir>(tcx: TyCtxt<'hir>, (): ()) -> hir::Crate<'hir> {\n         tcx.definitions_untracked().def_index_count(),\n     );\n \n+    let ast_arena = Arena::default();\n+\n     for def_id in ast_index.indices() {\n         item::ItemLowerer {\n             tcx,\n             resolver: &mut resolver,\n+            ast_arena: &ast_arena,\n             ast_index: &ast_index,\n             owners: &mut owners,\n         }\n@@ -522,13 +518,41 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.resolver\n             .node_id_to_def_id\n             .get(&node)\n-            .map(|local_def_id| self.resolver.get_remapped_def_id(*local_def_id))\n+            .map(|local_def_id| self.get_remapped_def_id(*local_def_id))\n     }\n \n     fn local_def_id(&self, node: NodeId) -> LocalDefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n     }\n \n+    /// Get the previously recorded `to` local def id given the `from` local def id, obtained using\n+    /// `generics_def_id_map` field.\n+    fn get_remapped_def_id(&self, mut local_def_id: LocalDefId) -> LocalDefId {\n+        // `generics_def_id_map` is a stack of mappings. As we go deeper in impl traits nesting we\n+        // push new mappings so we need to try first the latest mappings, hence `iter().rev()`.\n+        //\n+        // Consider:\n+        //\n+        // `fn test<'a, 'b>() -> impl Trait<&'a u8, Ty = impl Sized + 'b> {}`\n+        //\n+        // We would end with a generics_def_id_map like:\n+        //\n+        // `[[fn#'b -> impl_trait#'b], [fn#'b -> impl_sized#'b]]`\n+        //\n+        // for the opaque type generated on `impl Sized + 'b`, We want the result to be:\n+        // impl_sized#'b, so iterating forward is the wrong thing to do.\n+        for map in self.generics_def_id_map.iter().rev() {\n+            if let Some(r) = map.get(&local_def_id) {\n+                debug!(\"def_id_remapper: remapping from `{local_def_id:?}` to `{r:?}`\");\n+                local_def_id = *r;\n+            } else {\n+                debug!(\"def_id_remapper: no remapping for `{local_def_id:?}` found in map\");\n+            }\n+        }\n+\n+        local_def_id\n+    }\n+\n     /// Freshen the `LoweringContext` and ready it to lower a nested item.\n     /// The lowered item is registered into `self.children`.\n     ///\n@@ -547,7 +571,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let current_node_ids = std::mem::take(&mut self.node_id_to_local_id);\n         let current_id_to_def_id = std::mem::take(&mut self.local_id_to_def_id);\n         let current_trait_map = std::mem::take(&mut self.trait_map);\n-        let current_owner = std::mem::replace(&mut self.current_hir_id_owner, def_id);\n+        let current_owner =\n+            std::mem::replace(&mut self.current_hir_id_owner, hir::OwnerId { def_id });\n         let current_local_counter =\n             std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n         let current_impl_trait_defs = std::mem::take(&mut self.impl_trait_defs);\n@@ -562,7 +587,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug_assert_eq!(_old, None);\n \n         let item = f(self);\n-        debug_assert_eq!(def_id, item.def_id());\n+        debug_assert_eq!(def_id, item.def_id().def_id);\n         // `f` should have consumed all the elements in these vectors when constructing `item`.\n         debug_assert!(self.impl_trait_defs.is_empty());\n         debug_assert!(self.impl_trait_bounds.is_empty());\n@@ -597,9 +622,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         remap: FxHashMap<LocalDefId, LocalDefId>,\n         f: impl FnOnce(&mut Self) -> R,\n     ) -> R {\n-        self.resolver.generics_def_id_map.push(remap);\n+        self.generics_def_id_map.push(remap);\n         let res = f(self);\n-        self.resolver.generics_def_id_map.pop();\n+        self.generics_def_id_map.pop();\n         res\n     }\n \n@@ -667,6 +692,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// actually used in the HIR, as that would trigger an assertion in the\n     /// `HirIdValidator` later on, which makes sure that all `NodeId`s got mapped\n     /// properly. Calling the method twice with the same `NodeId` is fine though.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn lower_node_id(&mut self, ast_node_id: NodeId) -> hir::HirId {\n         assert_ne!(ast_node_id, DUMMY_NODE_ID);\n \n@@ -700,6 +726,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Generate a new `HirId` without a backing `NodeId`.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn next_id(&mut self) -> hir::HirId {\n         let owner = self.current_hir_id_owner;\n         let local_id = self.item_local_id_counter;\n@@ -759,7 +786,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Mark a span as relative to the current owning item.\n     fn lower_span(&self, span: Span) -> Span {\n         if self.tcx.sess.opts.unstable_opts.incremental_relative_spans {\n-            span.with_parent(Some(self.current_hir_id_owner))\n+            span.with_parent(Some(self.current_hir_id_owner.def_id))\n         } else {\n             // Do not make spans relative when not using incremental compilation.\n             span\n@@ -771,7 +798,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Converts a lifetime into a new generic parameter.\n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn lifetime_res_to_generic_param(\n         &mut self,\n         ident: Ident,\n@@ -785,7 +812,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             LifetimeRes::Fresh { param, .. } => {\n                 // Late resolution delegates to us the creation of the `LocalDefId`.\n                 let _def_id = self.create_def(\n-                    self.current_hir_id_owner,\n+                    self.current_hir_id_owner.def_id,\n                     param,\n                     DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n                 );\n@@ -815,7 +842,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// name resolver owing to lifetime elision; this also populates the resolver's node-id->def-id\n     /// map, so that later calls to `opt_node_id_to_def_id` that refer to these extra lifetime\n     /// parameters will be successful.\n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     #[inline]\n     fn lower_lifetime_binder(\n         &mut self,\n@@ -960,7 +987,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_assoc_ty_constraint(\n         &mut self,\n         constraint: &AssocConstraint,\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::TypeBinding<'hir> {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n         // lower generic arguments of identifier in constraint\n@@ -971,18 +998,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 GenericArgs::Parenthesized(ref data) => {\n                     self.emit_bad_parenthesized_trait_in_assoc_ty(data);\n-                    self.lower_angle_bracketed_parameter_data(\n-                        &data.as_angle_bracketed_args(),\n-                        ParamMode::Explicit,\n-                        itctx,\n-                    )\n-                    .0\n+                    let aba = self.ast_arena.aba.alloc(data.as_angle_bracketed_args());\n+                    self.lower_angle_bracketed_parameter_data(aba, ParamMode::Explicit, itctx).0\n                 }\n             };\n             gen_args_ctor.into_generic_args(self)\n         } else {\n             self.arena.alloc(hir::GenericArgs::none())\n         };\n+        let itctx_tait = &ImplTraitContext::TypeAliasesOpaqueTy;\n \n         let kind = match constraint.kind {\n             AssocConstraintKind::Equality { ref term } => {\n@@ -1020,9 +1044,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // then to an opaque type).\n                     //\n                     // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n-                    ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => {\n-                        (true, ImplTraitContext::TypeAliasesOpaqueTy)\n-                    }\n+                    ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => (true, itctx_tait),\n \n                     // We are in the parameter position, but not within a dyn type:\n                     //\n@@ -1040,19 +1062,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                     let parent_def_id = self.current_hir_id_owner;\n                     let impl_trait_node_id = self.next_node_id();\n-                    self.create_def(parent_def_id, impl_trait_node_id, DefPathData::ImplTrait);\n+                    self.create_def(\n+                        parent_def_id.def_id,\n+                        impl_trait_node_id,\n+                        DefPathData::ImplTrait,\n+                    );\n \n                     self.with_dyn_type_scope(false, |this| {\n                         let node_id = this.next_node_id();\n-                        let ty = this.lower_ty(\n-                            &Ty {\n-                                id: node_id,\n-                                kind: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n-                                span: this.lower_span(constraint.span),\n-                                tokens: None,\n-                            },\n-                            itctx,\n-                        );\n+                        let ty = this.ast_arena.tys.alloc(Ty {\n+                            id: node_id,\n+                            kind: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n+                            span: this.lower_span(constraint.span),\n+                            tokens: None,\n+                        });\n+                        let ty = this.lower_ty(ty, itctx);\n \n                         hir::TypeBindingKind::Equality { term: ty.into() }\n                     })\n@@ -1103,7 +1127,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_generic_arg(\n         &mut self,\n         arg: &ast::GenericArg,\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::GenericArg<'hir> {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n@@ -1134,7 +1158,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 let node_id = self.next_node_id();\n \n                                 // Add a definition for the in-band const def.\n-                                self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n+                                self.create_def(\n+                                    parent_def_id.def_id,\n+                                    node_id,\n+                                    DefPathData::AnonConst,\n+                                );\n \n                                 let span = self.lower_span(ty.span);\n                                 let path_expr = Expr {\n@@ -1155,7 +1183,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                     _ => {}\n                 }\n-                GenericArg::Type(self.lower_ty_direct(&ty, itctx))\n+                GenericArg::Type(self.lower_ty(&ty, itctx))\n             }\n             ast::GenericArg::Const(ct) => GenericArg::Const(ConstArg {\n                 value: self.lower_anon_const(&ct),\n@@ -1165,7 +1193,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext) -> &'hir hir::Ty<'hir> {\n+    fn lower_ty(&mut self, t: &Ty, itctx: &ImplTraitContext) -> &'hir hir::Ty<'hir> {\n         self.arena.alloc(self.lower_ty_direct(t, itctx))\n     }\n \n@@ -1175,11 +1203,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         qself: &Option<QSelf>,\n         path: &Path,\n         param_mode: ParamMode,\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::Ty<'hir> {\n         // Check whether we should interpret this as a bare trait object.\n         // This check mirrors the one in late resolution.  We only introduce this special case in\n-        // the rare occurence we need to lower `Fresh` anonymous lifetimes.\n+        // the rare occurrence we need to lower `Fresh` anonymous lifetimes.\n         // The other cases when a qpath should be opportunistically made a trait object are handled\n         // by `ty_path`.\n         if qself.is_none()\n@@ -1188,19 +1216,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             && let Res::Def(DefKind::Trait | DefKind::TraitAlias, _) = partial_res.base_res()\n         {\n             let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n+                let poly_trait_ref = this.ast_arena.ptr.alloc(PolyTraitRef {\n+                    bound_generic_params: vec![],\n+                    trait_ref: TraitRef { path: path.clone(), ref_id: t.id },\n+                    span: t.span\n+                });\n                 let bound = this.lower_poly_trait_ref(\n-                    &PolyTraitRef {\n-                        bound_generic_params: vec![],\n-                        trait_ref: TraitRef { path: path.clone(), ref_id: t.id },\n-                        span: t.span\n-                    },\n+                    poly_trait_ref,\n                     itctx,\n                 );\n                 let bounds = this.arena.alloc_from_iter([bound]);\n                 let lifetime_bound = this.elided_dyn_bound(t.span);\n                 (bounds, lifetime_bound)\n             });\n-            let kind = hir::TyKind::TraitObject(bounds, lifetime_bound, TraitObjectSyntax::None);\n+            let kind = hir::TyKind::TraitObject(bounds, &lifetime_bound, TraitObjectSyntax::None);\n             return hir::Ty { kind, span: self.lower_span(t.span), hir_id: self.next_id() };\n         }\n \n@@ -1217,7 +1246,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.ty(span, hir::TyKind::Tup(tys))\n     }\n \n-    fn lower_ty_direct(&mut self, t: &Ty, itctx: ImplTraitContext) -> hir::Ty<'hir> {\n+    fn lower_ty_direct(&mut self, t: &Ty, itctx: &ImplTraitContext) -> hir::Ty<'hir> {\n         let kind = match t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n@@ -1245,7 +1274,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     generic_params,\n                     unsafety: self.lower_unsafety(f.unsafety),\n                     abi: self.lower_extern(f.ext),\n-                    decl: self.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n+                    decl: self.lower_fn_decl(&f.decl, None, t.span, FnDeclKind::Pointer, None),\n                     param_names: self.lower_fn_params_to_names(&f.decl),\n                 }))\n             }\n@@ -1260,14 +1289,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 return self.lower_path_ty(t, qself, path, ParamMode::Explicit, itctx);\n             }\n             TyKind::ImplicitSelf => {\n+                let hir_id = self.next_id();\n                 let res = self.expect_full_res(t.id);\n                 let res = self.lower_res(res);\n                 hir::TyKind::Path(hir::QPath::Resolved(\n                     None,\n                     self.arena.alloc(hir::Path {\n                         res,\n-                        segments: arena_vec![self; hir::PathSegment::from_ident(\n-                            Ident::with_dummy_span(kw::SelfUpper)\n+                        segments: arena_vec![self; hir::PathSegment::new(\n+                            Ident::with_dummy_span(kw::SelfUpper),\n+                            hir_id,\n+                            res\n                         )],\n                         span: self.lower_span(t.span),\n                     }),\n@@ -1310,19 +1342,23 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n-                    ImplTraitContext::ReturnPositionOpaqueTy { origin } => {\n-                        self.lower_opaque_impl_trait(span, origin, def_node_id, bounds, itctx)\n-                    }\n-                    ImplTraitContext::TypeAliasesOpaqueTy => {\n-                        let nested_itctx = ImplTraitContext::TypeAliasesOpaqueTy;\n-                        self.lower_opaque_impl_trait(\n+                    ImplTraitContext::ReturnPositionOpaqueTy { origin, in_trait } => self\n+                        .lower_opaque_impl_trait(\n                             span,\n-                            hir::OpaqueTyOrigin::TyAlias,\n+                            *origin,\n                             def_node_id,\n                             bounds,\n-                            nested_itctx,\n-                        )\n-                    }\n+                            *in_trait,\n+                            itctx,\n+                        ),\n+                    ImplTraitContext::TypeAliasesOpaqueTy => self.lower_opaque_impl_trait(\n+                        span,\n+                        hir::OpaqueTyOrigin::TyAlias,\n+                        def_node_id,\n+                        bounds,\n+                        false,\n+                        &ImplTraitContext::TypeAliasesOpaqueTy,\n+                    ),\n                     ImplTraitContext::Universal => {\n                         let span = t.span;\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n@@ -1334,6 +1370,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                         path\n                     }\n+                    ImplTraitContext::Disallowed(\n+                        position @ (ImplTraitPosition::TraitReturn | ImplTraitPosition::ImplReturn),\n+                    ) => {\n+                        self.tcx\n+                            .sess\n+                            .create_feature_err(\n+                                MisplacedImplTrait {\n+                                    span: t.span,\n+                                    position: DiagnosticArgFromDisplay(&position),\n+                                },\n+                                sym::return_position_impl_trait_in_trait,\n+                            )\n+                            .emit();\n+                        hir::TyKind::Err\n+                    }\n                     ImplTraitContext::Disallowed(position) => {\n                         self.tcx.sess.emit_err(MisplacedImplTrait {\n                             span: t.span,\n@@ -1385,14 +1436,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// added explicitly in the HIR). But this includes all the lifetimes, and we only want to\n     /// capture the lifetimes that are referenced in the bounds. Therefore, we add *extra* lifetime parameters\n     /// for the lifetimes that get captured (`'x`, in our example above) and reference those.\n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn lower_opaque_impl_trait(\n         &mut self,\n         span: Span,\n         origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n         bounds: &GenericBounds,\n-        itctx: ImplTraitContext,\n+        in_trait: bool,\n+        itctx: &ImplTraitContext,\n     ) -> hir::TyKind<'hir> {\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n@@ -1480,6 +1532,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }),\n                     bounds: hir_bounds,\n                     origin,\n+                    in_trait,\n                 };\n                 debug!(?opaque_ty_item);\n \n@@ -1506,7 +1559,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug!(?lifetimes);\n \n         // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-        hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, lifetimes)\n+        hir::TyKind::OpaqueDef(\n+            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n+            lifetimes,\n+            in_trait,\n+        )\n     }\n \n     /// Registers a new opaque type with the proper `NodeId`s and\n@@ -1522,7 +1579,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Generate an `type Foo = impl Trait;` declaration.\n         trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n         let opaque_ty_item = hir::Item {\n-            def_id: opaque_ty_id,\n+            def_id: hir::OwnerId { def_id: opaque_ty_id },\n             ident: Ident::empty(),\n             kind: opaque_ty_item_kind,\n             vis_span: self.lower_span(span.shrink_to_lo()),\n@@ -1565,8 +1622,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 LifetimeRes::Fresh { param, binder: _ } => {\n                     debug_assert_eq!(lifetime.ident.name, kw::UnderscoreLifetime);\n-                    let old_def_id = self.local_def_id(param);\n-                    if remapping.get(&old_def_id).is_none() {\n+                    if let Some(old_def_id) = self.opt_local_def_id(param) && remapping.get(&old_def_id).is_none() {\n                         let node_id = self.next_node_id();\n \n                         let new_def_id = self.create_def(\n@@ -1615,19 +1671,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // `fn_def_id`: if `Some`, impl Trait arguments are lowered into generic parameters on the\n     //      given DefId, otherwise impl Trait is disallowed. Must be `Some` if\n     //      `make_ret_async` is also `Some`.\n-    // `impl_trait_return_allow`: determines whether `impl Trait` can be used in return position.\n-    //      This guards against trait declarations and implementations where `impl Trait` is\n-    //      disallowed.\n     // `make_ret_async`: if `Some`, converts `-> T` into `-> impl Future<Output = T>` in the\n     //      return type. This is used for `async fn` declarations. The `NodeId` is the ID of the\n-    //      return type `impl Trait` item.\n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    //      return type `impl Trait` item, and the `Span` points to the `async` keyword.\n+    #[instrument(level = \"debug\", skip(self))]\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n         fn_node_id: Option<NodeId>,\n+        fn_span: Span,\n         kind: FnDeclKind,\n-        make_ret_async: Option<NodeId>,\n+        make_ret_async: Option<(NodeId, Span)>,\n     ) -> &'hir hir::FnDecl<'hir> {\n         let c_variadic = decl.c_variadic();\n \n@@ -1640,11 +1694,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n         let inputs = self.arena.alloc_from_iter(inputs.iter().map(|param| {\n             if fn_node_id.is_some() {\n-                self.lower_ty_direct(&param.ty, ImplTraitContext::Universal)\n+                self.lower_ty_direct(&param.ty, &ImplTraitContext::Universal)\n             } else {\n                 self.lower_ty_direct(\n                     &param.ty,\n-                    ImplTraitContext::Disallowed(match kind {\n+                    &ImplTraitContext::Disallowed(match kind {\n                         FnDeclKind::Fn | FnDeclKind::Inherent => {\n                             unreachable!(\"fn should allow in-band lifetimes\")\n                         }\n@@ -1658,20 +1712,39 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }));\n \n-        let output = if let Some(ret_id) = make_ret_async {\n+        let output = if let Some((ret_id, span)) = make_ret_async {\n+            if !kind.async_fn_allowed(self.tcx) {\n+                match kind {\n+                    FnDeclKind::Trait | FnDeclKind::Impl => {\n+                        self.tcx\n+                            .sess\n+                            .create_feature_err(\n+                                TraitFnAsync { fn_span, span },\n+                                sym::async_fn_in_trait,\n+                            )\n+                            .emit();\n+                    }\n+                    _ => {\n+                        self.tcx.sess.emit_err(TraitFnAsync { fn_span, span });\n+                    }\n+                }\n+            }\n+\n             self.lower_async_fn_ret_ty(\n                 &decl.output,\n                 fn_node_id.expect(\"`make_ret_async` but no `fn_def_id`\"),\n                 ret_id,\n+                matches!(kind, FnDeclKind::Trait),\n             )\n         } else {\n             match decl.output {\n                 FnRetTy::Ty(ref ty) => {\n-                    let context = match fn_node_id {\n-                        Some(fn_node_id) if kind.impl_trait_return_allowed() => {\n+                    let mut context = match fn_node_id {\n+                        Some(fn_node_id) if kind.impl_trait_allowed(self.tcx) => {\n                             let fn_def_id = self.local_def_id(fn_node_id);\n                             ImplTraitContext::ReturnPositionOpaqueTy {\n                                 origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n+                                in_trait: matches!(kind, FnDeclKind::Trait),\n                             }\n                         }\n                         _ => ImplTraitContext::Disallowed(match kind {\n@@ -1685,7 +1758,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             FnDeclKind::Impl => ImplTraitPosition::ImplReturn,\n                         }),\n                     };\n-                    hir::FnRetTy::Return(self.lower_ty(ty, context))\n+                    hir::FnRetTy::Return(self.lower_ty(ty, &mut context))\n                 }\n                 FnRetTy::Default(span) => hir::FnRetTy::DefaultReturn(self.lower_span(span)),\n             }\n@@ -1696,10 +1769,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             output,\n             c_variadic,\n             implicit_self: decl.inputs.get(0).map_or(hir::ImplicitSelfKind::None, |arg| {\n-                use BindingMode::{ByRef, ByValue};\n                 let is_mutable_pat = matches!(\n                     arg.pat.kind,\n-                    PatKind::Ident(ByValue(Mutability::Mut) | ByRef(Mutability::Mut), ..)\n+                    PatKind::Ident(hir::BindingAnnotation(_, Mutability::Mut), ..)\n                 );\n \n                 match arg.ty.kind {\n@@ -1730,12 +1802,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // `output`: unlowered output type (`T` in `-> T`)\n     // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n     // `opaque_ty_node_id`: `NodeId` of the opaque `impl Trait` type that should be created\n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn lower_async_fn_ret_ty(\n         &mut self,\n         output: &FnRetTy,\n         fn_node_id: NodeId,\n         opaque_ty_node_id: NodeId,\n+        in_trait: bool,\n     ) -> hir::FnRetTy<'hir> {\n         let span = output.span();\n \n@@ -1862,8 +1935,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 //\n                 // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n                 // hence the elision takes place at the fn site.\n-                let future_bound =\n-                    this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span);\n+                let future_bound = this.lower_async_fn_output_type_to_future_bound(\n+                    output,\n+                    span,\n+                    if in_trait && !this.tcx.features().return_position_impl_trait_in_trait {\n+                        ImplTraitContext::Disallowed(ImplTraitPosition::TraitReturn)\n+                    } else {\n+                        ImplTraitContext::ReturnPositionOpaqueTy {\n+                            origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n+                            in_trait,\n+                        }\n+                    },\n+                );\n \n                 let generic_params = this.arena.alloc_from_iter(collected_lifetimes.iter().map(\n                     |&(new_node_id, lifetime, _)| {\n@@ -1901,6 +1984,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }),\n                     bounds: arena_vec![this; future_bound],\n                     origin: hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n+                    in_trait,\n                 };\n \n                 trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n@@ -1937,17 +2021,19 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let res = res.unwrap_or(\n                     self.resolver.get_lifetime_res(lifetime.id).unwrap_or(LifetimeRes::Error),\n                 );\n-                let l = self.new_named_lifetime_with_res(id, span, ident, res);\n-                hir::GenericArg::Lifetime(l)\n+                hir::GenericArg::Lifetime(self.new_named_lifetime_with_res(id, span, ident, res))\n             },\n         ));\n \n         // Create the `Foo<...>` reference itself. Note that the `type\n         // Foo = impl Trait` is, internally, created as a child of the\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n-        let opaque_ty_ref =\n-            hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, generic_args);\n+        let opaque_ty_ref = hir::TyKind::OpaqueDef(\n+            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n+            generic_args,\n+            in_trait,\n+        );\n         let opaque_ty = self.ty(opaque_ty_span, opaque_ty_ref);\n         hir::FnRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n@@ -1956,19 +2042,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_async_fn_output_type_to_future_bound(\n         &mut self,\n         output: &FnRetTy,\n-        fn_def_id: LocalDefId,\n         span: Span,\n+        mut nested_impl_trait_context: ImplTraitContext,\n     ) -> hir::GenericBound<'hir> {\n         // Compute the `T` in `Future<Output = T>` from the return type.\n         let output_ty = match output {\n             FnRetTy::Ty(ty) => {\n                 // Not `OpaqueTyOrigin::AsyncFn`: that's only used for the\n                 // `impl Future` opaque type that `async fn` implicitly\n                 // generates.\n-                let context = ImplTraitContext::ReturnPositionOpaqueTy {\n-                    origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n-                };\n-                self.lower_ty(ty, context)\n+                self.lower_ty(ty, &mut nested_impl_trait_context)\n             }\n             FnRetTy::Default(ret_ty_span) => self.arena.alloc(self.ty_tup(*ret_ty_span, &[])),\n         };\n@@ -1994,7 +2077,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_param_bound(\n         &mut self,\n         tpb: &GenericBound,\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::GenericBound<'hir> {\n         match tpb {\n             GenericBound::Trait(p, modifier) => hir::GenericBound::Trait(\n@@ -2007,24 +2090,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n+    fn lower_lifetime(&mut self, l: &Lifetime) -> &'hir hir::Lifetime {\n         let span = self.lower_span(l.ident.span);\n         let ident = self.lower_ident(l.ident);\n         self.new_named_lifetime(l.id, l.id, span, ident)\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn new_named_lifetime_with_res(\n         &mut self,\n         id: NodeId,\n         span: Span,\n         ident: Ident,\n         res: LifetimeRes,\n-    ) -> hir::Lifetime {\n+    ) -> &'hir hir::Lifetime {\n         let name = match res {\n             LifetimeRes::Param { param, .. } => {\n                 let p_name = ParamName::Plain(ident);\n-                let param = self.resolver.get_remapped_def_id(param);\n+                let param = self.get_remapped_def_id(param);\n \n                 hir::LifetimeName::Param(param, p_name)\n             }\n@@ -2041,17 +2124,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         };\n \n         debug!(?name);\n-        hir::Lifetime { hir_id: self.lower_node_id(id), span: self.lower_span(span), name }\n+        self.arena.alloc(hir::Lifetime {\n+            hir_id: self.lower_node_id(id),\n+            span: self.lower_span(span),\n+            name,\n+        })\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn new_named_lifetime(\n         &mut self,\n         id: NodeId,\n         new_id: NodeId,\n         span: Span,\n         ident: Ident,\n-    ) -> hir::Lifetime {\n+    ) -> &'hir hir::Lifetime {\n         let res = self.resolver.get_lifetime_res(id).unwrap_or(LifetimeRes::Error);\n         self.new_named_lifetime_with_res(new_id, span, ident, res)\n     }\n@@ -2106,15 +2193,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             GenericParamKind::Type { ref default, .. } => {\n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n-                        self.lower_ty(x, ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+                        self.lower_ty(x, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n                     }),\n                     synthetic: false,\n                 };\n \n                 (hir::ParamName::Plain(self.lower_ident(param.ident)), kind)\n             }\n             GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n-                let ty = self.lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty = self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 let default = default.as_ref().map(|def| self.lower_anon_const(def));\n                 (\n                     hir::ParamName::Plain(self.lower_ident(param.ident)),\n@@ -2124,46 +2211,48 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_trait_ref(&mut self, p: &TraitRef, itctx: ImplTraitContext) -> hir::TraitRef<'hir> {\n+    fn lower_trait_ref(&mut self, p: &TraitRef, itctx: &ImplTraitContext) -> hir::TraitRef<'hir> {\n         let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit, itctx) {\n             hir::QPath::Resolved(None, path) => path,\n             qpath => panic!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath),\n         };\n         hir::TraitRef { path, hir_ref_id: self.lower_node_id(p.ref_id) }\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn lower_poly_trait_ref(\n         &mut self,\n         p: &PolyTraitRef,\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::PolyTraitRef<'hir> {\n         let bound_generic_params =\n             self.lower_lifetime_binder(p.trait_ref.ref_id, &p.bound_generic_params);\n         let trait_ref = self.lower_trait_ref(&p.trait_ref, itctx);\n         hir::PolyTraitRef { bound_generic_params, trait_ref, span: self.lower_span(p.span) }\n     }\n \n-    fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext) -> hir::MutTy<'hir> {\n+    fn lower_mt(&mut self, mt: &MutTy, itctx: &ImplTraitContext) -> hir::MutTy<'hir> {\n         hir::MutTy { ty: self.lower_ty(&mt.ty, itctx), mutbl: mt.mutbl }\n     }\n \n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn lower_param_bounds(\n         &mut self,\n         bounds: &[GenericBound],\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::GenericBounds<'hir> {\n         self.arena.alloc_from_iter(self.lower_param_bounds_mut(bounds, itctx))\n     }\n \n     fn lower_param_bounds_mut<'s>(\n         &'s mut self,\n         bounds: &'s [GenericBound],\n-        itctx: ImplTraitContext,\n+        itctx: &'s ImplTraitContext,\n     ) -> impl Iterator<Item = hir::GenericBound<'hir>> + Captures<'s> + Captures<'a> {\n         bounds.iter().map(move |bound| self.lower_param_bound(bound, itctx))\n     }\n \n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn lower_generic_and_bounds(\n         &mut self,\n         node_id: NodeId,\n@@ -2189,16 +2278,19 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             node_id,\n             &GenericParamKind::Type { default: None },\n             bounds,\n-            ImplTraitContext::Universal,\n+            &ImplTraitContext::Universal,\n             hir::PredicateOrigin::ImplTrait,\n         );\n \n+        let hir_id = self.next_id();\n+        let res = Res::Def(DefKind::TyParam, def_id.to_def_id());\n         let ty = hir::TyKind::Path(hir::QPath::Resolved(\n             None,\n             self.arena.alloc(hir::Path {\n                 span: self.lower_span(span),\n-                res: Res::Def(DefKind::TyParam, def_id.to_def_id()),\n-                segments: arena_vec![self; hir::PathSegment::from_ident(self.lower_ident(ident))],\n+                res,\n+                segments:\n+                    arena_vec![self; hir::PathSegment::new(self.lower_ident(ident), hir_id, res)],\n             }),\n         ));\n \n@@ -2361,11 +2453,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn pat_ident(&mut self, span: Span, ident: Ident) -> (&'hir hir::Pat<'hir>, hir::HirId) {\n-        self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::Unannotated)\n+        self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::NONE)\n     }\n \n     fn pat_ident_mut(&mut self, span: Span, ident: Ident) -> (hir::Pat<'hir>, hir::HirId) {\n-        self.pat_ident_binding_mode_mut(span, ident, hir::BindingAnnotation::Unannotated)\n+        self.pat_ident_binding_mode_mut(span, ident, hir::BindingAnnotation::NONE)\n     }\n \n     fn pat_ident_binding_mode(\n@@ -2454,14 +2546,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// bound, like the bound in `Box<dyn Debug>`. This method is not invoked\n     /// when the bound is written, even if it is written with `'_` like in\n     /// `Box<dyn Debug + '_>`. In those cases, `lower_lifetime` is invoked.\n-    fn elided_dyn_bound(&mut self, span: Span) -> hir::Lifetime {\n+    fn elided_dyn_bound(&mut self, span: Span) -> &'hir hir::Lifetime {\n         let r = hir::Lifetime {\n             hir_id: self.next_id(),\n             span: self.lower_span(span),\n             name: hir::LifetimeName::ImplicitObjectLifetimeDefault,\n         };\n         debug!(\"elided_dyn_bound: r={:?}\", r);\n-        r\n+        self.arena.alloc(r)\n     }\n }\n "}, {"sha": "914fc5f58da140a7110f3a380b9e0788ad4db42c", "filename": "compiler/rustc_ast_lowering/src/lifetime_collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -63,9 +63,9 @@ impl<'ast> Visitor<'ast> for LifetimeCollectVisitor<'ast> {\n         self.record_lifetime_use(*lifetime);\n     }\n \n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n-        self.record_elided_anchor(path_segment.id, path_span);\n-        visit::walk_path_segment(self, path_span, path_segment);\n+    fn visit_path_segment(&mut self, path_segment: &'ast PathSegment) {\n+        self.record_elided_anchor(path_segment.id, path_segment.ident.span);\n+        visit::walk_path_segment(self, path_segment);\n     }\n \n     fn visit_poly_trait_ref(&mut self, t: &'ast PolyTraitRef) {"}, {"sha": "1ea76fdbfcbbbab5996de26b9a163f8229d37792", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let node = loop {\n                 match pattern.kind {\n                     PatKind::Wild => break hir::PatKind::Wild,\n-                    PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                    PatKind::Ident(binding_mode, ident, ref sub) => {\n                         let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n                         break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n                     }\n@@ -37,7 +37,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             qself,\n                             path,\n                             ParamMode::Optional,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                            &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                         );\n                         let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n                         break hir::PatKind::TupleStruct(qpath, pats, ddpos);\n@@ -53,7 +53,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             qself,\n                             path,\n                             ParamMode::Optional,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                            &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                         );\n                         break hir::PatKind::Path(qpath);\n                     }\n@@ -63,7 +63,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             qself,\n                             path,\n                             ParamMode::Optional,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                            &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                         );\n \n                         let fs = self.arena.alloc_from_iter(fields.iter().map(|f| {\n@@ -116,7 +116,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         pats: &[P<Pat>],\n         ctx: &str,\n-    ) -> (&'hir [hir::Pat<'hir>], Option<usize>) {\n+    ) -> (&'hir [hir::Pat<'hir>], hir::DotDotPos) {\n         let mut elems = Vec::with_capacity(pats.len());\n         let mut rest = None;\n \n@@ -160,7 +160,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n \n-        (self.arena.alloc_from_iter(elems), rest.map(|(ddpos, _)| ddpos))\n+        (self.arena.alloc_from_iter(elems), hir::DotDotPos::new(rest.map(|(ddpos, _)| ddpos)))\n     }\n \n     /// Lower a slice pattern of form `[pat_0, ..., pat_n]` into\n@@ -176,9 +176,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut prev_rest_span = None;\n \n         // Lowers `$bm $ident @ ..` to `$bm $ident @ _`.\n-        let lower_rest_sub = |this: &mut Self, pat, bm, ident, sub| {\n+        let lower_rest_sub = |this: &mut Self, pat, ann, ident, sub| {\n             let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n-            let node = this.lower_pat_ident(pat, bm, ident, lower_sub);\n+            let node = this.lower_pat_ident(pat, ann, ident, lower_sub);\n             this.pat_with_node_id_of(pat, node)\n         };\n \n@@ -194,9 +194,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n                 // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n-                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n                     prev_rest_span = Some(sub.span);\n-                    slice = Some(self.arena.alloc(lower_rest_sub(self, pat, bm, ident, sub)));\n+                    slice = Some(self.arena.alloc(lower_rest_sub(self, pat, ann, ident, sub)));\n                     break;\n                 }\n                 // It was not a subslice pattern so lower it normally.\n@@ -209,9 +209,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // There was a previous subslice pattern; make sure we don't allow more.\n             let rest_span = match pat.kind {\n                 PatKind::Rest => Some(pat.span),\n-                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n                     // #69103: Lower into `binding @ _` as above to avoid ICEs.\n-                    after.push(lower_rest_sub(self, pat, bm, ident, sub));\n+                    after.push(lower_rest_sub(self, pat, ann, ident, sub));\n                     Some(sub.span)\n                 }\n                 _ => None,\n@@ -235,7 +235,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_pat_ident(\n         &mut self,\n         p: &Pat,\n-        binding_mode: &BindingMode,\n+        annotation: BindingAnnotation,\n         ident: Ident,\n         lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n     ) -> hir::PatKind<'hir> {\n@@ -248,29 +248,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 };\n \n                 hir::PatKind::Binding(\n-                    self.lower_binding_mode(binding_mode),\n+                    annotation,\n                     self.lower_node_id(canonical_id),\n                     self.lower_ident(ident),\n                     lower_sub(self),\n                 )\n             }\n-            Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n-                None,\n-                self.arena.alloc(hir::Path {\n-                    span: self.lower_span(ident.span),\n-                    res: self.lower_res(res),\n-                    segments: arena_vec![self; hir::PathSegment::from_ident(self.lower_ident(ident))],\n-                }),\n-            )),\n-        }\n-    }\n-\n-    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n-        match *b {\n-            BindingMode::ByValue(Mutability::Not) => hir::BindingAnnotation::Unannotated,\n-            BindingMode::ByRef(Mutability::Not) => hir::BindingAnnotation::Ref,\n-            BindingMode::ByValue(Mutability::Mut) => hir::BindingAnnotation::Mutable,\n-            BindingMode::ByRef(Mutability::Mut) => hir::BindingAnnotation::RefMut,\n+            Some(res) => {\n+                let hir_id = self.next_id();\n+                let res = self.lower_res(res);\n+                hir::PatKind::Path(hir::QPath::Resolved(\n+                    None,\n+                    self.arena.alloc(hir::Path {\n+                        span: self.lower_span(ident.span),\n+                        res,\n+                        segments: arena_vec![self; hir::PathSegment::new(self.lower_ident(ident), hir_id, res)],\n+                    }),\n+            ))\n+            }\n         }\n     }\n "}, {"sha": "6bb1bb9eace8b9c1b5f056e2a76a06b8d6f6090e", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -13,7 +13,6 @@ use rustc_span::symbol::{kw, Ident};\n use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use smallvec::smallvec;\n-use tracing::debug;\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     #[instrument(level = \"trace\", skip(self))]\n@@ -23,7 +22,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         qself: &Option<QSelf>,\n         p: &Path,\n         param_mode: ParamMode,\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::QPath<'hir> {\n         let qself_position = qself.as_ref().map(|q| q.position);\n         let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx));\n@@ -157,7 +156,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     segment,\n                     param_mode,\n                     ParenthesizedGenericArgs::Err,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                 )\n             })),\n             span: self.lower_span(p.span),\n@@ -181,7 +180,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         segment: &PathSegment,\n         param_mode: ParamMode,\n         parenthesized_generic_args: ParenthesizedGenericArgs,\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> hir::PathSegment<'hir> {\n         debug!(\"path_span: {:?}, lower_path_segment(segment: {:?})\", path_span, segment,);\n         let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n@@ -251,16 +250,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         let res = self.expect_full_res(segment.id);\n-        let id = self.lower_node_id(segment.id);\n+        let hir_id = self.lower_node_id(segment.id);\n         debug!(\n             \"lower_path_segment: ident={:?} original-id={:?} new-id={:?}\",\n-            segment.ident, segment.id, id,\n+            segment.ident, segment.id, hir_id,\n         );\n \n         hir::PathSegment {\n             ident: self.lower_ident(segment.ident),\n-            hir_id: Some(id),\n-            res: Some(self.lower_res(res)),\n+            hir_id,\n+            res: self.lower_res(res),\n             infer_args,\n             args: if generic_args.is_empty() && generic_args.span.is_empty() {\n                 None\n@@ -317,7 +316,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         data: &AngleBracketedArgs,\n         param_mode: ParamMode,\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n     ) -> (GenericArgsCtor<'hir>, bool) {\n         let has_non_lt_args = data.args.iter().any(|arg| match arg {\n             AngleBracketedArg::Arg(ast::GenericArg::Lifetime(_))\n@@ -351,15 +350,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // we generally don't permit such things (see #51008).\n         let ParenthesizedArgs { span, inputs, inputs_span, output } = data;\n         let inputs = self.arena.alloc_from_iter(inputs.iter().map(|ty| {\n-            self.lower_ty_direct(ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam))\n+            self.lower_ty_direct(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam))\n         }));\n         let output_ty = match output {\n             FnRetTy::Ty(ty) => {\n-                self.lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn))\n+                self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn))\n             }\n             FnRetTy::Default(_) => self.arena.alloc(self.ty_tup(*span, &[])),\n         };\n-        let args = smallvec![GenericArg::Type(self.ty_tup(*inputs_span, inputs))];\n+        let args = smallvec![GenericArg::Type(self.arena.alloc(self.ty_tup(*inputs_span, inputs)))];\n         let binding = self.output_ty_binding(output_ty.span, output_ty);\n         (\n             GenericArgsCtor {"}, {"sha": "ecf74c7602027e370e2147f7bf6ef6ede56100ff", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -223,11 +223,9 @@ impl<'a> AstValidator<'a> {\n                 for (i, segment) in path.segments.iter().enumerate() {\n                     // Allow `impl Trait` iff we're on the final path segment\n                     if i == path.segments.len() - 1 {\n-                        self.visit_path_segment(path.span, segment);\n+                        self.visit_path_segment(segment);\n                     } else {\n-                        self.with_banned_impl_trait(|this| {\n-                            this.visit_path_segment(path.span, segment)\n-                        });\n+                        self.with_banned_impl_trait(|this| this.visit_path_segment(segment));\n                     }\n                 }\n             }\n@@ -281,21 +279,15 @@ impl<'a> AstValidator<'a> {\n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, Option<Ident>, bool)) {\n         for Param { pat, .. } in &decl.inputs {\n             match pat.kind {\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, None) | PatKind::Wild => {}\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ident, None) => {\n+                PatKind::Ident(BindingAnnotation::NONE, _, None) | PatKind::Wild => {}\n+                PatKind::Ident(BindingAnnotation::MUT, ident, None) => {\n                     report_err(pat.span, Some(ident), true)\n                 }\n                 _ => report_err(pat.span, None, false),\n             }\n         }\n     }\n \n-    fn check_trait_fn_not_async(&self, fn_span: Span, asyncness: Async) {\n-        if let Async::Yes { span, .. } = asyncness {\n-            self.session.emit_err(TraitFnAsync { fn_span, span });\n-        }\n-    }\n-\n     fn check_trait_fn_not_const(&self, constness: Const) {\n         if let Const::Yes(span) = constness {\n             self.session.emit_err(TraitFnConst { span });\n@@ -845,10 +837,10 @@ fn validate_generic_param_order(\n         let (kind, bounds, span) = (&param.kind, &param.bounds, ident.span);\n         let (ord_kind, ident) = match &param.kind {\n             GenericParamKind::Lifetime => (ParamKindOrd::Lifetime, ident.to_string()),\n-            GenericParamKind::Type { default: _ } => (ParamKindOrd::Type, ident.to_string()),\n+            GenericParamKind::Type { default: _ } => (ParamKindOrd::TypeOrConst, ident.to_string()),\n             GenericParamKind::Const { ref ty, kw_span: _, default: _ } => {\n                 let ty = pprust::ty_to_string(ty);\n-                (ParamKindOrd::Const, format!(\"const {}: {}\", ident, ty))\n+                (ParamKindOrd::TypeOrConst, format!(\"const {}: {}\", ident, ty))\n             }\n         };\n         param_idents.push((kind, ord_kind, bounds, idx, ident));\n@@ -1299,7 +1291,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     // Mirrors `visit::walk_generic_args`, but tracks relevant state.\n-    fn visit_generic_args(&mut self, _: Span, generic_args: &'a GenericArgs) {\n+    fn visit_generic_args(&mut self, generic_args: &'a GenericArgs) {\n         match *generic_args {\n             GenericArgs::AngleBracketed(ref data) => {\n                 self.check_generic_args_before_constraints(data);\n@@ -1423,7 +1415,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     if !self.is_tilde_const_allowed {\n                         self.err_handler()\n                             .struct_span_err(bound.span(), \"`~const` is not allowed here\")\n-                            .note(\"only allowed on bounds on traits' associated types and functions, const fns, const impls and its associated functions\")\n+                            .note(\"only allowed on bounds on functions, traits' associated types and functions, const impls and its associated functions\")\n                             .emit();\n                     }\n                 }\n@@ -1531,11 +1523,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             });\n         }\n \n-        let tilde_const_allowed =\n-            matches!(fk.header(), Some(FnHeader { constness: Const::Yes(_), .. }))\n-                || matches!(fk.ctxt(), Some(FnCtxt::Assoc(_)));\n+        let tilde_const_allowed = matches!(fk.header(), Some(FnHeader { .. }))\n+            || matches!(fk.ctxt(), Some(FnCtxt::Assoc(_)));\n \n-        self.with_tilde_const(tilde_const_allowed, |this| visit::walk_fn(this, fk, span));\n+        self.with_tilde_const(tilde_const_allowed, |this| visit::walk_fn(this, fk));\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n@@ -1596,7 +1587,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.invalid_visibility(&item.vis, None);\n             if let AssocItemKind::Fn(box Fn { sig, .. }) = &item.kind {\n                 self.check_trait_fn_not_const(sig.header.constness);\n-                self.check_trait_fn_not_async(item.span, sig.header.asyncness);\n             }\n         }\n \n@@ -1800,7 +1790,7 @@ pub(crate) enum ForbiddenLetReason {\n     NotSupportedOr(Span),\n     /// A let chain with invalid parentheses\n     ///\n-    /// For exemple, `let 1 = 1 && (expr && expr)` is allowed\n+    /// For example, `let 1 = 1 && (expr && expr)` is allowed\n     /// but `(let 1 = 1 && (let 1 = 1 && (let 1 = 1))) && let a = 1` is not\n     NotSupportedParentheses(Span),\n }"}, {"sha": "035f0ce1cbc42c758406e121d7147ec25c8f97bd", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,12 +1,12 @@\n //! Errors emitted by ast_passes.\n \n-use rustc_errors::{fluent, AddSubdiagnostic, Applicability, Diagnostic};\n-use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic};\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{Span, Symbol};\n \n use crate::ast_validation::ForbiddenLetReason;\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::forbidden_let)]\n #[note]\n pub struct ForbiddenLet {\n@@ -16,7 +16,7 @@ pub struct ForbiddenLet {\n     pub(crate) reason: ForbiddenLetReason,\n }\n \n-impl AddSubdiagnostic for ForbiddenLetReason {\n+impl AddToDiagnostic for ForbiddenLetReason {\n     fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n         match self {\n             Self::GenericForbidden => {}\n@@ -30,37 +30,37 @@ impl AddSubdiagnostic for ForbiddenLetReason {\n     }\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::forbidden_let_stable)]\n #[note]\n pub struct ForbiddenLetStable {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::forbidden_assoc_constraint)]\n pub struct ForbiddenAssocConstraint {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::keyword_lifetime)]\n pub struct KeywordLifetime {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::invalid_label)]\n pub struct InvalidLabel {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::invalid_visibility, code = \"E0449\")]\n pub struct InvalidVisibility {\n     #[primary_span]\n@@ -71,85 +71,74 @@ pub struct InvalidVisibility {\n     pub note: Option<InvalidVisibilityNote>,\n }\n \n-#[derive(SessionSubdiagnostic)]\n+#[derive(Subdiagnostic)]\n pub enum InvalidVisibilityNote {\n     #[note(ast_passes::individual_impl_items)]\n     IndividualImplItems,\n     #[note(ast_passes::individual_foreign_items)]\n     IndividualForeignItems,\n }\n \n-#[derive(SessionDiagnostic)]\n-#[diag(ast_passes::trait_fn_async, code = \"E0706\")]\n-#[note]\n-#[note(ast_passes::note2)]\n-pub struct TraitFnAsync {\n-    #[primary_span]\n-    pub fn_span: Span,\n-    #[label]\n-    pub span: Span,\n-}\n-\n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::trait_fn_const, code = \"E0379\")]\n pub struct TraitFnConst {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::forbidden_lifetime_bound)]\n pub struct ForbiddenLifetimeBound {\n     #[primary_span]\n     pub spans: Vec<Span>,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::forbidden_non_lifetime_param)]\n pub struct ForbiddenNonLifetimeParam {\n     #[primary_span]\n     pub spans: Vec<Span>,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::fn_param_too_many)]\n pub struct FnParamTooMany {\n     #[primary_span]\n     pub span: Span,\n     pub max_num_args: usize,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::fn_param_c_var_args_only)]\n pub struct FnParamCVarArgsOnly {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::fn_param_c_var_args_not_last)]\n pub struct FnParamCVarArgsNotLast {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::fn_param_doc_comment)]\n pub struct FnParamDocComment {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::fn_param_forbidden_attr)]\n pub struct FnParamForbiddenAttr {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::fn_param_forbidden_self)]\n #[note]\n pub struct FnParamForbiddenSelf {\n@@ -158,7 +147,7 @@ pub struct FnParamForbiddenSelf {\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::forbidden_default)]\n pub struct ForbiddenDefault {\n     #[primary_span]\n@@ -167,7 +156,7 @@ pub struct ForbiddenDefault {\n     pub def_span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::assoc_const_without_body)]\n pub struct AssocConstWithoutBody {\n     #[primary_span]\n@@ -176,7 +165,7 @@ pub struct AssocConstWithoutBody {\n     pub replace_span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::assoc_fn_without_body)]\n pub struct AssocFnWithoutBody {\n     #[primary_span]\n@@ -185,7 +174,7 @@ pub struct AssocFnWithoutBody {\n     pub replace_span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::assoc_type_without_body)]\n pub struct AssocTypeWithoutBody {\n     #[primary_span]\n@@ -194,7 +183,7 @@ pub struct AssocTypeWithoutBody {\n     pub replace_span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::const_without_body)]\n pub struct ConstWithoutBody {\n     #[primary_span]\n@@ -203,7 +192,7 @@ pub struct ConstWithoutBody {\n     pub replace_span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::static_without_body)]\n pub struct StaticWithoutBody {\n     #[primary_span]\n@@ -212,7 +201,7 @@ pub struct StaticWithoutBody {\n     pub replace_span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::ty_alias_without_body)]\n pub struct TyAliasWithoutBody {\n     #[primary_span]\n@@ -221,7 +210,7 @@ pub struct TyAliasWithoutBody {\n     pub replace_span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(ast_passes::fn_without_body)]\n pub struct FnWithoutBody {\n     #[primary_span]\n@@ -238,7 +227,7 @@ pub struct ExternBlockSuggestion {\n     pub abi: Option<Symbol>,\n }\n \n-impl AddSubdiagnostic for ExternBlockSuggestion {\n+impl AddToDiagnostic for ExternBlockSuggestion {\n     fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n         let start_suggestion = if let Some(abi) = self.abi {\n             format!(\"extern \\\"{}\\\" {{\", abi)"}, {"sha": "0017a28cf1b184bbab7f21a9ffa0ebf42a9b9519", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 23, "deletions": 226, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -3,15 +3,13 @@ use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd, VariantData};\n use rustc_errors::{struct_span_err, Applicability, StashKey};\n-use rustc_feature::Features;\n-use rustc_feature::{AttributeGate, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n-use rustc_session::parse::{feature_err, feature_warn};\n+use rustc_feature::{AttributeGate, BuiltinAttribute, Features, GateIssue, BUILTIN_ATTRIBUTE_MAP};\n+use rustc_session::parse::{feature_err, feature_err_issue, feature_warn};\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-\n-use tracing::debug;\n+use rustc_target::spec::abi;\n \n macro_rules! gate_feature_fn {\n     ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $help: expr) => {{\n@@ -86,210 +84,26 @@ impl<'a> PostExpansionVisitor<'a> {\n             }\n         }\n \n-        match symbol_unescaped.as_str() {\n-            // Stable\n-            \"Rust\" | \"C\" | \"cdecl\" | \"stdcall\" | \"fastcall\" | \"aapcs\" | \"win64\" | \"sysv64\"\n-            | \"system\" => {}\n-            \"rust-intrinsic\" => {\n-                gate_feature_post!(&self, intrinsics, span, \"intrinsics are subject to change\");\n-            }\n-            \"platform-intrinsic\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    platform_intrinsics,\n-                    span,\n-                    \"platform intrinsics are experimental and possibly buggy\"\n-                );\n-            }\n-            \"vectorcall\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_vectorcall,\n-                    span,\n-                    \"vectorcall is experimental and subject to change\"\n-                );\n-            }\n-            \"thiscall\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_thiscall,\n-                    span,\n-                    \"thiscall is experimental and subject to change\"\n-                );\n-            }\n-            \"rust-call\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    unboxed_closures,\n-                    span,\n-                    \"rust-call ABI is subject to change\"\n-                );\n-            }\n-            \"rust-cold\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    rust_cold_cc,\n-                    span,\n-                    \"rust-cold is experimental and subject to change\"\n-                );\n-            }\n-            \"ptx-kernel\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_ptx,\n-                    span,\n-                    \"PTX ABIs are experimental and subject to change\"\n-                );\n-            }\n-            \"unadjusted\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_unadjusted,\n-                    span,\n-                    \"unadjusted ABI is an implementation detail and perma-unstable\"\n-                );\n-            }\n-            \"msp430-interrupt\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_msp430_interrupt,\n-                    span,\n-                    \"msp430-interrupt ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"x86-interrupt\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_x86_interrupt,\n-                    span,\n-                    \"x86-interrupt ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"amdgpu-kernel\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_amdgpu_kernel,\n-                    span,\n-                    \"amdgpu-kernel ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"avr-interrupt\" | \"avr-non-blocking-interrupt\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_avr_interrupt,\n-                    span,\n-                    \"avr-interrupt and avr-non-blocking-interrupt ABIs are experimental and subject to change\"\n-                );\n-            }\n-            \"efiapi\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_efiapi,\n-                    span,\n-                    \"efiapi ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"C-cmse-nonsecure-call\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_c_cmse_nonsecure_call,\n-                    span,\n-                    \"C-cmse-nonsecure-call ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"C-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"C-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"stdcall-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"stdcall-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"system-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"system-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"thiscall-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n+        match abi::is_enabled(&self.features, span, symbol_unescaped.as_str()) {\n+            Ok(()) => (),\n+            Err(abi::AbiDisabled::Unstable { feature, explain }) => {\n+                feature_err_issue(\n+                    &self.sess.parse_sess,\n+                    feature,\n                     span,\n-                    \"thiscall-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"cdecl-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"cdecl-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"fastcall-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"fastcall-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"vectorcall-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"vectorcall-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"aapcs-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"aapcs-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"win64-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"win64-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"sysv64-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"sysv64-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"wasm\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    wasm_abi,\n-                    span,\n-                    \"wasm ABI is experimental and subject to change\"\n-                );\n+                    GateIssue::Language,\n+                    explain,\n+                )\n+                .emit();\n             }\n-            abi => {\n+            Err(abi::AbiDisabled::Unrecognized) => {\n                 if self.sess.opts.pretty.map_or(true, |ppm| ppm.needs_hir()) {\n                     self.sess.parse_sess.span_diagnostic.delay_span_bug(\n                         span,\n-                        &format!(\"unrecognized ABI not caught in lowering: {}\", abi),\n+                        &format!(\n+                            \"unrecognized ABI not caught in lowering: {}\",\n+                            symbol_unescaped.as_str()\n+                        ),\n                     );\n                 }\n             }\n@@ -342,25 +156,6 @@ impl<'a> PostExpansionVisitor<'a> {\n         }\n     }\n \n-    fn check_gat(&self, generics: &ast::Generics, span: Span) {\n-        if !generics.params.is_empty() {\n-            gate_feature_post!(\n-                &self,\n-                generic_associated_types,\n-                span,\n-                \"generic associated types are unstable\"\n-            );\n-        }\n-        if !generics.where_clause.predicates.is_empty() {\n-            gate_feature_post!(\n-                &self,\n-                generic_associated_types,\n-                span,\n-                \"where clauses on associated types are unstable\"\n-            );\n-        }\n-    }\n-\n     /// Feature gate `impl Trait` inside `type Alias = $type_expr;`.\n     fn check_impl_trait(&self, ty: &ast::Ty) {\n         struct ImplTraitVisitor<'a> {\n@@ -575,6 +370,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::TyKind::Never => {\n                 gate_feature_post!(&self, never_type, ty.span, \"the `!` type is experimental\");\n             }\n+            ast::TyKind::TraitObject(_, ast::TraitObjectSyntax::DynStar, ..) => {\n+                gate_feature_post!(&self, dyn_star, ty.span, \"dyn* trait objects are unstable\");\n+            }\n             _ => {}\n         }\n         visit::walk_ty(self, ty)\n@@ -701,7 +499,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             gate_feature_post!(&self, c_variadic, span, \"C-variadic functions are unstable\");\n         }\n \n-        visit::walk_fn(self, fn_kind, span)\n+        visit::walk_fn(self, fn_kind)\n     }\n \n     fn visit_assoc_constraint(&mut self, constraint: &'a AssocConstraint) {\n@@ -719,7 +517,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_assoc_item(&mut self, i: &'a ast::AssocItem, ctxt: AssocCtxt) {\n         let is_fn = match i.kind {\n             ast::AssocItemKind::Fn(_) => true,\n-            ast::AssocItemKind::TyAlias(box ast::TyAlias { ref generics, ref ty, .. }) => {\n+            ast::AssocItemKind::TyAlias(box ast::TyAlias { ref ty, .. }) => {\n                 if let (Some(_), AssocCtxt::Trait) = (ty, ctxt) {\n                     gate_feature_post!(\n                         &self,\n@@ -731,7 +529,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 if let Some(ty) = ty {\n                     self.check_impl_trait(ty);\n                 }\n-                self.check_gat(generics, i.span);\n                 false\n             }\n             _ => false,"}, {"sha": "f58fffc917200a2bcd1d605c02c58f7622b8cbf1", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -9,9 +9,11 @@\n #![feature(if_let_guard)]\n #![feature(iter_is_partitioned)]\n #![feature(let_chains)]\n-#![feature(let_else)]\n #![recursion_limit = \"256\"]\n \n+#[macro_use]\n+extern crate tracing;\n+\n pub mod ast_validation;\n mod errors;\n pub mod feature_gate;"}, {"sha": "fa42f87786de913c477daf8ebcb1d764e6a4196f", "filename": "compiler/rustc_ast_passes/src/node_count.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -63,9 +63,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_generics(self, g)\n     }\n-    fn visit_fn(&mut self, fk: visit::FnKind<'_>, s: Span, _: NodeId) {\n+    fn visit_fn(&mut self, fk: visit::FnKind<'_>, _: Span, _: NodeId) {\n         self.count += 1;\n-        walk_fn(self, fk, s)\n+        walk_fn(self, fk)\n     }\n     fn visit_assoc_item(&mut self, ti: &AssocItem, ctxt: AssocCtxt) {\n         self.count += 1;\n@@ -115,9 +115,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_use_tree(self, use_tree, id)\n     }\n-    fn visit_generic_args(&mut self, path_span: Span, generic_args: &GenericArgs) {\n+    fn visit_generic_args(&mut self, generic_args: &GenericArgs) {\n         self.count += 1;\n-        walk_generic_args(self, path_span, generic_args)\n+        walk_generic_args(self, generic_args)\n     }\n     fn visit_assoc_constraint(&mut self, constraint: &AssocConstraint) {\n         self.count += 1;"}, {"sha": "b87c6f78d7285434845e94b3d788a88064a658a7", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -11,8 +11,8 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser;\n-use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n-use rustc_ast::{attr, Term};\n+use rustc_ast::{self as ast, BlockCheckMode, Mutability, PatKind, RangeEnd, RangeSyntax};\n+use rustc_ast::{attr, BindingAnnotation, ByRef, Term};\n use rustc_ast::{GenericArg, MacArgs, MacArgsEq};\n use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n@@ -22,6 +22,7 @@ use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, IdentPrinter, Symbol};\n use rustc_span::{BytePos, FileName, Span};\n \n+use rustc_ast::attr::AttrIdGenerator;\n use std::borrow::Cow;\n \n pub use self::delimited::IterDelimited;\n@@ -107,6 +108,7 @@ pub fn print_crate<'a>(\n     ann: &'a dyn PpAnn,\n     is_expanded: bool,\n     edition: Edition,\n+    g: &AttrIdGenerator,\n ) -> String {\n     let mut s =\n         State { s: pp::Printer::new(), comments: Some(Comments::new(sm, filename, input)), ann };\n@@ -120,15 +122,15 @@ pub fn print_crate<'a>(\n         // `#![feature(prelude_import)]`\n         let pi_nested = attr::mk_nested_word_item(Ident::with_dummy_span(sym::prelude_import));\n         let list = attr::mk_list_item(Ident::with_dummy_span(sym::feature), vec![pi_nested]);\n-        let fake_attr = attr::mk_attr_inner(list);\n+        let fake_attr = attr::mk_attr_inner(g, list);\n         s.print_attribute(&fake_attr);\n \n         // Currently, in Rust 2018 we don't have `extern crate std;` at the crate\n         // root, so this is not needed, and actually breaks things.\n         if edition == Edition::Edition2015 {\n             // `#![no_std]`\n             let no_std_meta = attr::mk_word_item(Ident::with_dummy_span(sym::no_std));\n-            let fake_attr = attr::mk_attr_inner(no_std_meta);\n+            let fake_attr = attr::mk_attr_inner(g, no_std_meta);\n             s.print_attribute(&fake_attr);\n         }\n     }\n@@ -1399,16 +1401,12 @@ impl<'a> State<'a> {\n         is that it doesn't matter */\n         match pat.kind {\n             PatKind::Wild => self.word(\"_\"),\n-            PatKind::Ident(binding_mode, ident, ref sub) => {\n-                match binding_mode {\n-                    ast::BindingMode::ByRef(mutbl) => {\n-                        self.word_nbsp(\"ref\");\n-                        self.print_mutability(mutbl, false);\n-                    }\n-                    ast::BindingMode::ByValue(ast::Mutability::Not) => {}\n-                    ast::BindingMode::ByValue(ast::Mutability::Mut) => {\n-                        self.word_nbsp(\"mut\");\n-                    }\n+            PatKind::Ident(BindingAnnotation(by_ref, mutbl), ident, ref sub) => {\n+                if by_ref == ByRef::Yes {\n+                    self.word_nbsp(\"ref\");\n+                }\n+                if mutbl == Mutability::Mut {\n+                    self.word_nbsp(\"mut\");\n                 }\n                 self.print_ident(ident);\n                 if let Some(ref p) = *sub {\n@@ -1487,12 +1485,10 @@ impl<'a> State<'a> {\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n                 self.word(\"&\");\n-                if mutbl == ast::Mutability::Mut {\n+                if mutbl == Mutability::Mut {\n                     self.word(\"mut \");\n                 }\n-                if let PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Mut), ..) =\n-                    inner.kind\n-                {\n+                if let PatKind::Ident(ast::BindingAnnotation::MUT, ..) = inner.kind {\n                     self.popen();\n                     self.print_pat(inner);\n                     self.pclose();"}, {"sha": "54bac29a6cee0fd7fe05a7445367f920e910c42d", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -218,6 +218,8 @@ impl<'a> State<'a> {\n             ast::ItemKind::GlobalAsm(ref asm) => {\n                 self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n                 self.print_inline_asm(asm);\n+                self.word(\";\");\n+                self.end();\n                 self.end();\n             }\n             ast::ItemKind::TyAlias(box ast::TyAlias {"}, {"sha": "753f62dd589d05f048bd805da0e042c952cd2088", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -15,6 +15,18 @@ use std::num::NonZeroU32;\n \n use crate::session_diagnostics::{self, IncorrectReprFormatGenericCause};\n \n+/// The version placeholder that recently stabilized features contain inside the\n+/// `since` field of the `#[stable]` attribute.\n+///\n+/// For more, see [this pull request](https://github.com/rust-lang/rust/pull/100591).\n+pub const VERSION_PLACEHOLDER: &str = \"CURRENT_RUSTC_VERSION\";\n+\n+pub fn rust_version_symbol() -> Symbol {\n+    let version = option_env!(\"CFG_VERSION\").unwrap_or(\"<current>\");\n+    let version = version.split(' ').next().unwrap();\n+    Symbol::intern(&version)\n+}\n+\n pub fn is_builtin_attr(attr: &Attribute) -> bool {\n     attr.is_doc_comment() || attr.ident().filter(|ident| is_builtin_attr_name(ident.name)).is_some()\n }\n@@ -57,7 +69,12 @@ fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n             sess.emit_err(session_diagnostics::MultipleStabilityLevels { span });\n         }\n         AttrError::UnsupportedLiteral(reason, is_bytestr) => {\n-            sess.emit_err(session_diagnostics::UnsupportedLiteral { span, reason, is_bytestr });\n+            sess.emit_err(session_diagnostics::UnsupportedLiteral {\n+                span,\n+                reason,\n+                is_bytestr,\n+                start_point_span: sess.source_map().start_point(span),\n+            });\n         }\n     }\n }\n@@ -483,6 +500,10 @@ where\n                         }\n                     }\n \n+                    if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n+                        since = Some(rust_version_symbol());\n+                    }\n+\n                     match (feature, since) {\n                         (Some(feature), Some(since)) => {\n                             let level = Stable { since, allowed_through_unstable_modules: false };\n@@ -1028,18 +1049,16 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                                 &name,\n                             ),\n                         });\n-                    } else {\n-                        if matches!(\n-                            meta_item.name_or_empty(),\n-                            sym::C | sym::simd | sym::transparent\n-                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                        {\n-                            recognised = true;\n-                            sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n-                                span: meta_item.span,\n-                                name: meta_item.name_or_empty().to_ident_string(),\n-                            });\n-                        }\n+                    } else if matches!(\n+                        meta_item.name_or_empty(),\n+                        sym::C | sym::simd | sym::transparent\n+                    ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                    {\n+                        recognised = true;\n+                        sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n+                            span: meta_item.span,\n+                            name: meta_item.name_or_empty().to_ident_string(),\n+                        });\n                     }\n                 } else if let MetaItemKind::List(_) = meta_item.kind {\n                     if meta_item.has_name(sym::align) {"}, {"sha": "4580ffcc6d8be694004fcdcf3c1a673be14ee02e", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -5,7 +5,6 @@\n //! to this crate.\n \n #![feature(let_chains)]\n-#![feature(let_else)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n "}, {"sha": "d3e9a16a9a809bc79f79d1aea659f05ff0e982e6", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,21 +1,22 @@\n use std::num::IntErrorKind;\n \n use rustc_ast as ast;\n-use rustc_errors::{error_code, fluent, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n-use rustc_macros::SessionDiagnostic;\n-use rustc_session::{parse::ParseSess, SessionDiagnostic};\n+use rustc_errors::{\n+    error_code, fluent, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic,\n+};\n+use rustc_macros::Diagnostic;\n use rustc_span::{Span, Symbol};\n \n use crate::UnsupportedLiteralReason;\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::expected_one_cfg_pattern, code = \"E0536\")]\n pub(crate) struct ExpectedOneCfgPattern {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::invalid_predicate, code = \"E0537\")]\n pub(crate) struct InvalidPredicate {\n     #[primary_span]\n@@ -24,7 +25,7 @@ pub(crate) struct InvalidPredicate {\n     pub predicate: String,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::multiple_item, code = \"E0538\")]\n pub(crate) struct MultipleItem {\n     #[primary_span]\n@@ -33,7 +34,7 @@ pub(crate) struct MultipleItem {\n     pub item: String,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::incorrect_meta_item, code = \"E0539\")]\n pub(crate) struct IncorrectMetaItem {\n     #[primary_span]\n@@ -48,10 +49,10 @@ pub(crate) struct UnknownMetaItem<'a> {\n }\n \n // Manual implementation to be able to format `expected` items correctly.\n-impl<'a> SessionDiagnostic<'a> for UnknownMetaItem<'_> {\n-    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+impl<'a> IntoDiagnostic<'a> for UnknownMetaItem<'_> {\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let expected = self.expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n-        let mut diag = sess.span_diagnostic.struct_span_err_with_code(\n+        let mut diag = handler.struct_span_err_with_code(\n             self.span,\n             fluent::attr::unknown_meta_item,\n             error_code!(E0541),\n@@ -63,28 +64,28 @@ impl<'a> SessionDiagnostic<'a> for UnknownMetaItem<'_> {\n     }\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::missing_since, code = \"E0542\")]\n pub(crate) struct MissingSince {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::missing_note, code = \"E0543\")]\n pub(crate) struct MissingNote {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::multiple_stability_levels, code = \"E0544\")]\n pub(crate) struct MultipleStabilityLevels {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::invalid_issue_string, code = \"E0545\")]\n pub(crate) struct InvalidIssueString {\n     #[primary_span]\n@@ -96,7 +97,7 @@ pub(crate) struct InvalidIssueString {\n \n // The error kinds of `IntErrorKind` are duplicated here in order to allow the messages to be\n // translatable.\n-#[derive(SessionSubdiagnostic)]\n+#[derive(Subdiagnostic)]\n pub(crate) enum InvalidIssueStringCause {\n     #[label(attr::must_not_be_zero)]\n     MustNotBeZero {\n@@ -142,21 +143,21 @@ impl InvalidIssueStringCause {\n     }\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::missing_feature, code = \"E0546\")]\n pub(crate) struct MissingFeature {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::non_ident_feature, code = \"E0546\")]\n pub(crate) struct NonIdentFeature {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::missing_issue, code = \"E0547\")]\n pub(crate) struct MissingIssue {\n     #[primary_span]\n@@ -165,7 +166,7 @@ pub(crate) struct MissingIssue {\n \n // FIXME: This diagnostic is identical to `IncorrectMetaItem`, barring the error code. Consider\n // changing this to `IncorrectMetaItem`. See #51489.\n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::incorrect_meta_item, code = \"E0551\")]\n pub(crate) struct IncorrectMetaItem2 {\n     #[primary_span]\n@@ -174,14 +175,14 @@ pub(crate) struct IncorrectMetaItem2 {\n \n // FIXME: Why is this the same error code as `InvalidReprHintNoParen` and `InvalidReprHintNoValue`?\n // It is more similar to `IncorrectReprFormatGeneric`.\n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::incorrect_repr_format_packed_one_or_zero_arg, code = \"E0552\")]\n pub(crate) struct IncorrectReprFormatPackedOneOrZeroArg {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::invalid_repr_hint_no_paren, code = \"E0552\")]\n pub(crate) struct InvalidReprHintNoParen {\n     #[primary_span]\n@@ -190,7 +191,7 @@ pub(crate) struct InvalidReprHintNoParen {\n     pub name: String,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::invalid_repr_hint_no_value, code = \"E0552\")]\n pub(crate) struct InvalidReprHintNoValue {\n     #[primary_span]\n@@ -204,11 +205,12 @@ pub(crate) struct UnsupportedLiteral {\n     pub span: Span,\n     pub reason: UnsupportedLiteralReason,\n     pub is_bytestr: bool,\n+    pub start_point_span: Span,\n }\n \n-impl<'a> SessionDiagnostic<'a> for UnsupportedLiteral {\n-    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let mut diag = sess.span_diagnostic.struct_span_err_with_code(\n+impl<'a> IntoDiagnostic<'a> for UnsupportedLiteral {\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n             self.span,\n             match self.reason {\n                 UnsupportedLiteralReason::Generic => fluent::attr::unsupported_literal_generic,\n@@ -224,7 +226,7 @@ impl<'a> SessionDiagnostic<'a> for UnsupportedLiteral {\n         );\n         if self.is_bytestr {\n             diag.span_suggestion(\n-                sess.source_map().start_point(self.span),\n+                self.start_point_span,\n                 fluent::attr::unsupported_literal_suggestion,\n                 \"\",\n                 Applicability::MaybeIncorrect,\n@@ -234,15 +236,15 @@ impl<'a> SessionDiagnostic<'a> for UnsupportedLiteral {\n     }\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::invalid_repr_align_need_arg, code = \"E0589\")]\n pub(crate) struct InvalidReprAlignNeedArg {\n     #[primary_span]\n     #[suggestion(code = \"align(...)\", applicability = \"has-placeholders\")]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::invalid_repr_generic, code = \"E0589\")]\n pub(crate) struct InvalidReprGeneric<'a> {\n     #[primary_span]\n@@ -252,14 +254,14 @@ pub(crate) struct InvalidReprGeneric<'a> {\n     pub error_part: &'a str,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::incorrect_repr_format_align_one_arg, code = \"E0693\")]\n pub(crate) struct IncorrectReprFormatAlignOneArg {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::incorrect_repr_format_generic, code = \"E0693\")]\n pub(crate) struct IncorrectReprFormatGeneric<'a> {\n     #[primary_span]\n@@ -271,7 +273,7 @@ pub(crate) struct IncorrectReprFormatGeneric<'a> {\n     pub cause: Option<IncorrectReprFormatGenericCause<'a>>,\n }\n \n-#[derive(SessionSubdiagnostic)]\n+#[derive(Subdiagnostic)]\n pub(crate) enum IncorrectReprFormatGenericCause<'a> {\n     #[suggestion(attr::suggestion, code = \"{name}({int})\", applicability = \"machine-applicable\")]\n     Int {\n@@ -314,28 +316,28 @@ impl<'a> IncorrectReprFormatGenericCause<'a> {\n     }\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::rustc_promotable_pairing, code = \"E0717\")]\n pub(crate) struct RustcPromotablePairing {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::rustc_allowed_unstable_pairing, code = \"E0789\")]\n pub(crate) struct RustcAllowedUnstablePairing {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::cfg_predicate_identifier)]\n pub(crate) struct CfgPredicateIdentifier {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::deprecated_item_suggestion)]\n pub(crate) struct DeprecatedItemSuggestion {\n     #[primary_span]\n@@ -348,21 +350,21 @@ pub(crate) struct DeprecatedItemSuggestion {\n     pub details: (),\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::expected_single_version_literal)]\n pub(crate) struct ExpectedSingleVersionLiteral {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::expected_version_literal)]\n pub(crate) struct ExpectedVersionLiteral {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::expects_feature_list)]\n pub(crate) struct ExpectsFeatureList {\n     #[primary_span]\n@@ -371,7 +373,7 @@ pub(crate) struct ExpectsFeatureList {\n     pub name: String,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::expects_features)]\n pub(crate) struct ExpectsFeatures {\n     #[primary_span]\n@@ -380,14 +382,14 @@ pub(crate) struct ExpectsFeatures {\n     pub name: String,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::soft_no_args)]\n pub(crate) struct SoftNoArgs {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(attr::unknown_version_literal)]\n pub(crate) struct UnknownVersionLiteral {\n     #[primary_span]"}, {"sha": "df04128135b8986c2a976af99df433447e1f1af2", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -21,10 +21,7 @@ pub(crate) struct OutlivesConstraintSet<'tcx> {\n \n impl<'tcx> OutlivesConstraintSet<'tcx> {\n     pub(crate) fn push(&mut self, constraint: OutlivesConstraint<'tcx>) {\n-        debug!(\n-            \"OutlivesConstraintSet::push({:?}: {:?} @ {:?}\",\n-            constraint.sup, constraint.sub, constraint.locations\n-        );\n+        debug!(\"OutlivesConstraintSet::push({:?})\", constraint);\n         if constraint.sup == constraint.sub {\n             // 'a: 'a is pretty uninteresting\n             return;\n@@ -73,7 +70,7 @@ impl<'tcx> Index<OutlivesConstraintIndex> for OutlivesConstraintSet<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n pub struct OutlivesConstraint<'tcx> {\n     // NB. The ordering here is not significant for correctness, but\n     // it is for convenience. Before we dump the constraints in the"}, {"sha": "9f7a4d49989ab6b3aeddac712161c6168a120de3", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -391,7 +391,7 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n             | mir::StatementKind::Retag { .. }\n             | mir::StatementKind::AscribeUserType(..)\n             | mir::StatementKind::Coverage(..)\n-            | mir::StatementKind::CopyNonOverlapping(..)\n+            | mir::StatementKind::Intrinsic(..)\n             | mir::StatementKind::Nop => {}\n         }\n     }"}, {"sha": "a1b34e94dbfe2571e313354d224bb4a92ac04a41", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 76, "deletions": 4, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::mir::{\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, subst::Subst, suggest_constraining_type_params, PredicateKind, Ty};\n+use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty};\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n@@ -198,7 +198,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     move_span,\n                     move_spans,\n                     *moved_place,\n-                    Some(used_place),\n                     partially_str,\n                     loop_message,\n                     move_msg,\n@@ -258,7 +257,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = place.ty(self.body, self.infcx.tcx).ty;\n \n             // If we're in pattern, we do nothing in favor of the previous suggestion (#80913).\n-            if is_loop_move & !in_pattern {\n+            // Same for if we're in a loop, see #101119.\n+            if is_loop_move & !in_pattern && !matches!(use_spans, UseSpans::ClosureUse { .. }) {\n                 if let ty::Ref(_, _, hir::Mutability::Mut) = ty.kind() {\n                     // We have a `&mut` ref, we need to reborrow on each iteration (#62112).\n                     err.span_suggestion_verbose(\n@@ -368,6 +368,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut visitor = ConditionVisitor { spans: &spans, name: &name, errors: vec![] };\n         visitor.visit_body(&body);\n \n+        let mut show_assign_sugg = false;\n         let isnt_initialized = if let InitializationRequiringAction::PartialAssignment\n         | InitializationRequiringAction::Assignment = desired_action\n         {\n@@ -395,6 +396,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .count()\n             == 0\n         {\n+            show_assign_sugg = true;\n             \"isn't initialized\"\n         } else {\n             \"is possibly-uninitialized\"\n@@ -445,10 +447,78 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n         }\n+\n         err.span_label(decl_span, \"binding declared here but left uninitialized\");\n+        if show_assign_sugg {\n+            struct LetVisitor {\n+                decl_span: Span,\n+                sugg_span: Option<Span>,\n+            }\n+\n+            impl<'v> Visitor<'v> for LetVisitor {\n+                fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n+                    if self.sugg_span.is_some() {\n+                        return;\n+                    }\n+                    if let hir::StmtKind::Local(hir::Local {\n+                            span, ty, init: None, ..\n+                        }) = &ex.kind && span.contains(self.decl_span) {\n+                            self.sugg_span = ty.map_or(Some(self.decl_span), |ty| Some(ty.span));\n+                    }\n+                    hir::intravisit::walk_stmt(self, ex);\n+                }\n+            }\n+\n+            let mut visitor = LetVisitor { decl_span, sugg_span: None };\n+            visitor.visit_body(&body);\n+            if let Some(span) = visitor.sugg_span {\n+                self.suggest_assign_value(&mut err, moved_place, span);\n+            }\n+        }\n         err\n     }\n \n+    fn suggest_assign_value(\n+        &self,\n+        err: &mut Diagnostic,\n+        moved_place: PlaceRef<'tcx>,\n+        sugg_span: Span,\n+    ) {\n+        let ty = moved_place.ty(self.body, self.infcx.tcx).ty;\n+        debug!(\"ty: {:?}, kind: {:?}\", ty, ty.kind());\n+\n+        let tcx = self.infcx.tcx;\n+        let implements_default = |ty, param_env| {\n+            let Some(default_trait) = tcx.get_diagnostic_item(sym::Default) else {\n+                return false;\n+            };\n+            tcx.infer_ctxt().enter(|infcx| {\n+                infcx\n+                    .type_implements_trait(default_trait, ty, ty::List::empty(), param_env)\n+                    .may_apply()\n+            })\n+        };\n+\n+        let assign_value = match ty.kind() {\n+            ty::Bool => \"false\",\n+            ty::Float(_) => \"0.0\",\n+            ty::Int(_) | ty::Uint(_) => \"0\",\n+            ty::Never | ty::Error(_) => \"\",\n+            ty::Adt(def, _) if Some(def.did()) == tcx.get_diagnostic_item(sym::Vec) => \"vec![]\",\n+            ty::Adt(_, _) if implements_default(ty, self.param_env) => \"Default::default()\",\n+            _ => \"todo!()\",\n+        };\n+\n+        if !assign_value.is_empty() {\n+            err.span_suggestion_verbose(\n+                sugg_span.shrink_to_hi(),\n+                format!(\"consider assigning a value\"),\n+                format!(\" = {}\", assign_value),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+\n     fn suggest_borrow_fn_like(\n         &self,\n         err: &mut Diagnostic,\n@@ -2145,7 +2215,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                             StorageDeadOrDrop::Destructor(_) => kind,\n                         },\n-                        ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n+                        ProjectionElem::OpaqueCast { .. }\n+                        | ProjectionElem::Field(..)\n+                        | ProjectionElem::Downcast(..) => {\n                             match place_ty.ty.kind() {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     // Report the outermost adt with a destructor"}, {"sha": "1c01e78abd422ed097b440c49ce32bb56a54863b", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, RegionVid, TyCtxt};\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{sym, DesugaringKind, Span};\n \n-use crate::region_infer::BlameConstraint;\n+use crate::region_infer::{BlameConstraint, ExtraConstraintInfo};\n use crate::{\n     borrow_set::BorrowData, nll::ConstraintDescription, region_infer::Cause, MirBorrowckCtxt,\n     WriteKind,\n@@ -38,6 +38,7 @@ pub(crate) enum BorrowExplanation<'tcx> {\n         span: Span,\n         region_name: RegionName,\n         opt_place_desc: Option<String>,\n+        extra_info: Vec<ExtraConstraintInfo>,\n     },\n     Unexplained,\n }\n@@ -243,6 +244,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 ref region_name,\n                 ref opt_place_desc,\n                 from_closure: _,\n+                ref extra_info,\n             } => {\n                 region_name.highlight_region_name(err);\n \n@@ -268,6 +270,14 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     );\n                 };\n \n+                for extra in extra_info {\n+                    match extra {\n+                        ExtraConstraintInfo::PlaceholderFromPredicate(span) => {\n+                            err.span_note(*span, format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\"));\n+                        }\n+                    }\n+                }\n+\n                 self.add_lifetime_bound_suggestion_to_diagnostic(err, &category, span, region_name);\n             }\n             _ => {}\n@@ -309,18 +319,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n-    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>) {\n-        let BlameConstraint { category, from_closure, cause, variance_info: _ } =\n-            self.regioncx.best_blame_constraint(\n-                &self.body,\n-                borrow_region,\n-                NllRegionVariableOrigin::FreeRegion,\n-                |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n-            );\n+    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>, Vec<ExtraConstraintInfo>) {\n+        let (blame_constraint, extra_info) = self.regioncx.best_blame_constraint(\n+            borrow_region,\n+            NllRegionVariableOrigin::FreeRegion,\n+            |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n+        );\n+        let BlameConstraint { category, from_closure, cause, .. } = blame_constraint;\n \n         let outlived_fr_name = self.give_region_a_name(outlived_region);\n \n-        (category, from_closure, cause.span, outlived_fr_name)\n+        (category, from_closure, cause.span, outlived_fr_name, extra_info)\n     }\n \n     /// Returns structured explanation for *why* the borrow contains the\n@@ -392,7 +401,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             None => {\n                 if let Some(region) = self.to_error_region_vid(borrow_region_vid) {\n-                    let (category, from_closure, span, region_name) =\n+                    let (category, from_closure, span, region_name, extra_info) =\n                         self.free_region_constraint_info(borrow_region_vid, region);\n                     if let Some(region_name) = region_name {\n                         let opt_place_desc = self.describe_place(borrow.borrowed_place.as_ref());\n@@ -402,6 +411,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             span,\n                             region_name,\n                             opt_place_desc,\n+                            extra_info,\n                         }\n                     } else {\n                         debug!(\"Could not generate a region name\");"}, {"sha": "7ccb679d88b2dc021e8fb445d4be31c6177bd920", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -237,6 +237,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 ProjectionElem::Downcast(..) if opt.including_downcast => return None,\n                 ProjectionElem::Downcast(..) => (),\n+                ProjectionElem::OpaqueCast(..) => (),\n                 ProjectionElem::Field(field, _ty) => {\n                     // FIXME(project-rfc_2229#36): print capture precisely here.\n                     if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n@@ -317,6 +318,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     PlaceRef { local, projection: proj_base }.ty(self.body, self.infcx.tcx)\n                 }\n                 ProjectionElem::Downcast(..) => place.ty(self.body, self.infcx.tcx),\n+                ProjectionElem::OpaqueCast(ty) => PlaceTy::from_ty(*ty),\n                 ProjectionElem::Field(_, field_type) => PlaceTy::from_ty(*field_type),\n             },\n         };\n@@ -970,7 +972,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         move_span: Span,\n         move_spans: UseSpans<'tcx>,\n         moved_place: Place<'tcx>,\n-        used_place: Option<PlaceRef<'tcx>>,\n         partially_str: &str,\n         loop_message: &str,\n         move_msg: &str,\n@@ -1058,9 +1059,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 place_name, partially_str, loop_message\n                             ),\n                         );\n-                        // If we have a `&mut` ref, we need to reborrow.\n-                        if let Some(ty::Ref(_, _, hir::Mutability::Mut)) = used_place\n-                            .map(|used_place| used_place.ty(self.body, self.infcx.tcx).ty.kind())\n+                        // If the moved place was a `&mut` ref, then we can\n+                        // suggest to reborrow it where it was moved, so it\n+                        // will still be valid by the time we get to the usage.\n+                        if let ty::Ref(_, _, hir::Mutability::Mut) =\n+                            moved_place.ty(self.body, self.infcx.tcx).ty.kind()\n                         {\n                             // If we are in a loop this will be suggested later.\n                             if !is_loop_move {"}, {"sha": "5a47f45677ecbfd1b546f4f74f5ec83e833687cf", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -360,7 +360,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 diag.span_label(upvar_span, \"captured outer variable\");\n                 diag.span_label(\n-                    self.body.span,\n+                    self.infcx.tcx.def_span(def_id),\n                     format!(\"captured by this `{closure_kind}` closure\"),\n                 );\n \n@@ -401,7 +401,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         if let Some(use_spans) = use_spans {\n             self.explain_captures(\n-                &mut err, span, span, use_spans, move_place, None, \"\", \"\", \"\", false, true,\n+                &mut err, span, span, use_spans, move_place, \"\", \"\", \"\", false, true,\n             );\n         }\n         err"}, {"sha": "8ad40c0aa0a5d032f3e2f5b9af56a6ee3cacc189", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -9,10 +9,7 @@ use rustc_middle::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::{\n     hir::place::PlaceBase,\n-    mir::{\n-        self, BindingForm, ClearCrossCrate, ImplicitSelfKind, Local, LocalDecl, LocalInfo,\n-        LocalKind, Location,\n-    },\n+    mir::{self, BindingForm, ClearCrossCrate, Local, LocalDecl, LocalInfo, LocalKind, Location},\n };\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, Symbol};\n@@ -172,6 +169,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         ..,\n                         ProjectionElem::Index(_)\n                         | ProjectionElem::ConstantIndex { .. }\n+                        | ProjectionElem::OpaqueCast { .. }\n                         | ProjectionElem::Subslice { .. }\n                         | ProjectionElem::Downcast(..),\n                     ],\n@@ -312,7 +310,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     && !matches!(\n                         decl.local_info,\n                         Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(\n-                            ImplicitSelfKind::MutRef\n+                            hir::ImplicitSelfKind::MutRef\n                         ))))\n                     )\n                 {\n@@ -367,7 +365,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if let Some(Node::Pat(pat)) = self.infcx.tcx.hir().find(upvar_hir_id)\n                     && let hir::PatKind::Binding(\n-                        hir::BindingAnnotation::Unannotated,\n+                        hir::BindingAnnotation::NONE,\n                         _,\n                         upvar_ident,\n                         _,\n@@ -711,8 +709,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                         self.suggested = true;\n-                    } else if let hir::ExprKind::MethodCall(_path, args @ [_, ..], sp) = expr.kind\n-                        && let hir::ExprKind::Index(val, index) = args[0].kind\n+                    } else if let hir::ExprKind::MethodCall(_path, receiver, _, sp) = expr.kind\n+                        && let hir::ExprKind::Index(val, index) = receiver.kind\n                         && expr.span == self.assign_span\n                     {\n                         // val[index].path(args..);\n@@ -724,7 +722,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     \".get_mut(\".to_string(),\n                                 ),\n                                 (\n-                                    index.span.shrink_to_hi().with_hi(args[0].span.hi()),\n+                                    index.span.shrink_to_hi().with_hi(receiver.span.hi()),\n                                     \").map(|val| val\".to_string(),\n                                 ),\n                                 (sp.shrink_to_hi(), \")\".to_string()),\n@@ -911,11 +909,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                                         [\n                                                             Expr {\n                                                                 kind:\n-                                                                    MethodCall(\n-                                                                        path_segment,\n-                                                                        _args,\n-                                                                        span,\n-                                                                    ),\n+                                                                    MethodCall(path_segment, _, _, span),\n                                                                 hir_id,\n                                                                 ..\n                                                             },\n@@ -935,10 +929,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 _,\n             ) = hir_map.body(fn_body_id).value.kind\n             {\n-                let opt_suggestions = path_segment\n-                    .hir_id\n-                    .map(|path_hir_id| self.infcx.tcx.typeck(path_hir_id.owner))\n-                    .and_then(|typeck| typeck.type_dependent_def_id(*hir_id))\n+                let opt_suggestions = self\n+                    .infcx\n+                    .tcx\n+                    .typeck(path_segment.hir_id.owner.def_id)\n+                    .type_dependent_def_id(*hir_id)\n                     .and_then(|def_id| self.infcx.tcx.impl_of_method(def_id))\n                     .map(|def_id| self.infcx.tcx.associated_items(def_id))\n                     .map(|assoc_items| {\n@@ -976,6 +971,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         let hir = self.infcx.tcx.hir();\n         let closure_id = self.mir_hir_id();\n+        let closure_span = self.infcx.tcx.def_span(self.mir_def_id());\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n         let def_id = hir.enclosing_body_owner(fn_call_id);\n@@ -1027,7 +1023,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if let Some(span) = arg {\n                     err.span_label(span, \"change this to accept `FnMut` instead of `Fn`\");\n                     err.span_label(func.span, \"expects `Fn` instead of `FnMut`\");\n-                    err.span_label(self.body.span, \"in this closure\");\n+                    err.span_label(closure_span, \"in this closure\");\n                     look_at_return = false;\n                 }\n             }\n@@ -1036,7 +1032,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if look_at_return && hir.get_return_block(closure_id).is_some() {\n             // ...otherwise we are probably in the tail expression of the function, point at the\n             // return type.\n-            match hir.get_by_def_id(hir.get_parent_item(fn_call_id)) {\n+            match hir.get_by_def_id(hir.get_parent_item(fn_call_id).def_id) {\n                 hir::Node::Item(hir::Item { ident, kind: hir::ItemKind::Fn(sig, ..), .. })\n                 | hir::Node::TraitItem(hir::TraitItem {\n                     ident,\n@@ -1053,7 +1049,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         sig.decl.output.span(),\n                         \"change this to return `FnMut` instead of `Fn`\",\n                     );\n-                    err.span_label(self.body.span, \"in this closure\");\n+                    err.span_label(closure_span, \"in this closure\");\n                 }\n                 _ => {}\n             }\n@@ -1077,7 +1073,7 @@ fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symb\n             //\n             // Deliberately fall into this case for all implicit self types,\n             // so that we don't fall in to the next case with them.\n-            *kind == mir::ImplicitSelfKind::MutRef\n+            *kind == hir::ImplicitSelfKind::MutRef\n         }\n         _ if Some(kw::SelfLower) == local_name => {\n             // Otherwise, check if the name is the `self` keyword - in which case"}, {"sha": "35c3df768995a0d2907db1cb174122666596a9cc", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -6,7 +6,6 @@ use rustc_errors::Diagnostic;\n use rustc_middle::ty::RegionVid;\n use smallvec::SmallVec;\n use std::collections::BTreeMap;\n-use tracing::debug;\n \n use crate::MirBorrowckCtxt;\n "}, {"sha": "43d67bfa72991eb70bd330b539c39fb3552337dc", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -31,7 +31,7 @@ use crate::session_diagnostics::{\n };\n \n use super::{OutlivesSuggestionBuilder, RegionName};\n-use crate::region_infer::BlameConstraint;\n+use crate::region_infer::{BlameConstraint, ExtraConstraintInfo};\n use crate::{\n     nll::ConstraintDescription,\n     region_infer::{values::RegionElement, TypeTest},\n@@ -234,7 +234,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                     // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n                     let (_, cause) = self.regioncx.find_outlives_blame_span(\n-                        &self.body,\n                         longer_fr,\n                         NllRegionVariableOrigin::Placeholder(placeholder),\n                         error_vid,\n@@ -282,7 +281,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match tcx.hir().get_if_local(def_id) {\n             Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id())) {\n+                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n+                {\n                     Some(Node::Item(Item {\n                         kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n                         ..\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n             Some(Node::TraitItem(trait_item)) => {\n                 let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did) {\n+                match tcx.hir().find_by_def_id(trait_did.def_id) {\n                     Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n                         // The method being called is defined in the `trait`, but the `'static`\n                         // obligation comes from the `impl`. Find that `impl` so that we can point\n@@ -355,10 +355,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"report_region_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let BlameConstraint { category, cause, variance_info, from_closure: _ } =\n-            self.regioncx.best_blame_constraint(&self.body, fr, fr_origin, |r| {\n+        let (blame_constraint, extra_info) =\n+            self.regioncx.best_blame_constraint(fr, fr_origin, |r| {\n                 self.regioncx.provides_universal_region(r, fr, outlived_fr)\n             });\n+        let BlameConstraint { category, cause, variance_info, .. } = blame_constraint;\n \n         debug!(\"report_region_error: category={:?} {:?} {:?}\", category, cause, variance_info);\n \n@@ -467,6 +468,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         }\n \n+        for extra in extra_info {\n+            match extra {\n+                ExtraConstraintInfo::PlaceholderFromPredicate(span) => {\n+                    diag.span_note(span, format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\"));\n+                }\n+            }\n+        }\n+\n         self.buffer_error(diag);\n     }\n \n@@ -558,6 +567,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// LL |     ref_obj(x)\n     ///    |     ^^^^^^^^^^ `x` escapes the function body here\n     /// ```\n+    #[instrument(level = \"debug\", skip(self))]\n     fn report_escaping_data_error(\n         &self,\n         errci: &ErrorConstraintInfo<'tcx>,\n@@ -900,18 +910,25 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut closure_span = None::<rustc_span::Span>;\n         match expr.kind {\n             hir::ExprKind::MethodCall(.., args, _) => {\n-                // only the first closre parameter of the method. args[0] is MethodCall PathSegment\n-                for i in 1..args.len() {\n-                    if let hir::ExprKind::Closure(..) = args[i].kind {\n-                        closure_span = Some(args[i].span.shrink_to_lo());\n+                for arg in args {\n+                    if let hir::ExprKind::Closure(hir::Closure {\n+                        capture_clause: hir::CaptureBy::Ref,\n+                        ..\n+                    }) = arg.kind\n+                    {\n+                        closure_span = Some(arg.span.shrink_to_lo());\n                         break;\n                     }\n                 }\n             }\n             hir::ExprKind::Block(blk, _) => {\n                 if let Some(ref expr) = blk.expr {\n                     // only when the block is a closure\n-                    if let hir::ExprKind::Closure(..) = expr.kind {\n+                    if let hir::ExprKind::Closure(hir::Closure {\n+                        capture_clause: hir::CaptureBy::Ref,\n+                        ..\n+                    }) = expr.kind\n+                    {\n                         closure_span = Some(expr.span.shrink_to_lo());\n                     }\n                 }\n@@ -921,7 +938,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let Some(closure_span) = closure_span {\n             diag.span_suggestion_verbose(\n                 closure_span,\n-                format!(\"consider adding 'move' keyword before the nested closure\"),\n+                \"consider adding 'move' keyword before the nested closure\",\n                 \"move \",\n                 Applicability::MaybeIncorrect,\n             );"}, {"sha": "419e6c817915f0d6163ed0f93ac89bc02d41a158", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -265,7 +265,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// *user* has a name for. In that case, we'll be able to map\n     /// `fr` to a `Region<'tcx>`, and that region will be one of\n     /// named variants.\n-    #[tracing::instrument(level = \"trace\", skip(self))]\n+    #[instrument(level = \"trace\", skip(self))]\n     fn give_name_from_error_region(&self, fr: RegionVid) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n@@ -357,11 +357,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 ty::BoundRegionKind::BrAnon(_) => None,\n             },\n \n-            ty::ReLateBound(..)\n-            | ty::ReVar(..)\n-            | ty::RePlaceholder(..)\n-            | ty::ReEmpty(_)\n-            | ty::ReErased => None,\n+            ty::ReLateBound(..) | ty::ReVar(..) | ty::RePlaceholder(..) | ty::ReErased => None,\n         }\n     }\n \n@@ -373,7 +369,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ///  | fn foo(x: &u32) { .. }\n     ///           ------- fully elaborated type of `x` is `&'1 u32`\n     /// ```\n-    #[tracing::instrument(level = \"trace\", skip(self))]\n+    #[instrument(level = \"trace\", skip(self))]\n     fn give_name_if_anonymous_region_appears_in_arguments(\n         &self,\n         fr: RegionVid,\n@@ -662,7 +658,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ///  | let x = Some(&22);\n     ///        - fully elaborated type of `x` is `Option<&'1 u32>`\n     /// ```\n-    #[tracing::instrument(level = \"trace\", skip(self))]\n+    #[instrument(level = \"trace\", skip(self))]\n     fn give_name_if_anonymous_region_appears_in_upvars(&self, fr: RegionVid) -> Option<RegionName> {\n         let upvar_index = self.regioncx.get_upvar_index_for_region(self.infcx.tcx, fr)?;\n         let (upvar_name, upvar_span) = self.regioncx.get_upvar_name_and_span_for_region(\n@@ -682,7 +678,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// must be a closure since, in a free fn, such an argument would\n     /// have to either also appear in an argument (if using elision)\n     /// or be early bound (named, not in argument).\n-    #[tracing::instrument(level = \"trace\", skip(self))]\n+    #[instrument(level = \"trace\", skip(self))]\n     fn give_name_if_anonymous_region_appears_in_output(&self, fr: RegionVid) -> Option<RegionName> {\n         let tcx = self.infcx.tcx;\n         let hir = tcx.hir();\n@@ -711,7 +707,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         hir::AsyncGeneratorKind::Block => \" of async block\",\n                         hir::AsyncGeneratorKind::Closure => \" of async closure\",\n                         hir::AsyncGeneratorKind::Fn => {\n-                            let parent_item = hir.get_by_def_id(hir.get_parent_item(mir_hir_id));\n+                            let parent_item =\n+                                hir.get_by_def_id(hir.get_parent_item(mir_hir_id).def_id);\n                             let output = &parent_item\n                                 .fn_decl()\n                                 .expect(\"generator lowered from async fn should be in fn\")\n@@ -772,7 +769,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     fn get_future_inner_return_ty(&self, hir_ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n         let hir = self.infcx.tcx.hir();\n \n-        let hir::TyKind::OpaqueDef(id, _) = hir_ty.kind else {\n+        let hir::TyKind::OpaqueDef(id, _, _) = hir_ty.kind else {\n             span_bug!(\n                 hir_ty.span,\n                 \"lowered return type of async fn is not OpaqueDef: {:?}\",\n@@ -814,7 +811,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         }\n     }\n \n-    #[tracing::instrument(level = \"trace\", skip(self))]\n+    #[instrument(level = \"trace\", skip(self))]\n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n         fr: RegionVid,"}, {"sha": "3157f861d93bec9fc047fd81d750d218d2248f7b", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::visit::Visitor;\n-use rustc_middle::mir::{BasicBlock, Body, Location, Place, Rvalue};\n+use rustc_middle::mir::{self, BasicBlock, Body, Location, NonDivergingIntrinsic, Place, Rvalue};\n use rustc_middle::mir::{BorrowKind, Mutability, Operand};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::mir::{Statement, StatementKind};\n@@ -63,23 +63,24 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             StatementKind::FakeRead(box (_, _)) => {\n                 // Only relevant for initialized/liveness/safety checks.\n             }\n-            StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n+            StatementKind::Intrinsic(box NonDivergingIntrinsic::Assume(op)) => {\n+                self.consume_operand(location, op);\n+            }\n+            StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(mir::CopyNonOverlapping {\n                 ref src,\n                 ref dst,\n                 ref count,\n-            }) => {\n+            })) => {\n                 self.consume_operand(location, src);\n                 self.consume_operand(location, dst);\n                 self.consume_operand(location, count);\n             }\n-            StatementKind::Nop\n+            // Only relevant for mir typeck\n+            StatementKind::AscribeUserType(..)\n+            // Doesn't have any language semantics\n             | StatementKind::Coverage(..)\n-            | StatementKind::AscribeUserType(..)\n-            | StatementKind::Retag { .. }\n-            | StatementKind::StorageLive(..) => {\n-                // `Nop`, `AscribeUserType`, `Retag`, and `StorageLive` are irrelevant\n-                // to borrow check.\n-            }\n+            // Does not actually affect borrowck\n+            | StatementKind::StorageLive(..) => {}\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n                     location,\n@@ -88,7 +89,10 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }\n-            StatementKind::Deinit(..) | StatementKind::SetDiscriminant { .. } => {\n+            StatementKind::Nop\n+            | StatementKind::Retag { .. }\n+            | StatementKind::Deinit(..)\n+            | StatementKind::SetDiscriminant { .. } => {\n                 bug!(\"Statement not allowed in this MIR phase\")\n             }\n         }"}, {"sha": "a83840e10998ae594aa6f3294d53d655581644bc", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -3,7 +3,6 @@\n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(let_chains)]\n-#![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(rustc_attrs)]\n@@ -26,8 +25,8 @@ use rustc_index::bit_set::ChunkedBitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::{\n-    traversal, Body, ClearCrossCrate, Local, Location, Mutability, Operand, Place, PlaceElem,\n-    PlaceRef, VarDebugInfoContents,\n+    traversal, Body, ClearCrossCrate, Local, Location, Mutability, NonDivergingIntrinsic, Operand,\n+    Place, PlaceElem, PlaceRef, VarDebugInfoContents,\n };\n use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n@@ -134,7 +133,7 @@ fn mir_borrowck<'tcx>(\n \n     let opt_closure_req = tcx\n         .infer_ctxt()\n-        .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner))\n+        .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id))\n         .enter(|infcx| {\n             let input_body: &Body<'_> = &input_body.borrow();\n             let promoted: &IndexVec<_, _> = &promoted.borrow();\n@@ -591,22 +590,19 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                     flow_state,\n                 );\n             }\n-            StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n-                ..\n-            }) => {\n-                span_bug!(\n+            StatementKind::Intrinsic(box ref kind) => match kind {\n+                NonDivergingIntrinsic::Assume(op) => self.consume_operand(location, (op, span), flow_state),\n+                NonDivergingIntrinsic::CopyNonOverlapping(..) => span_bug!(\n                     span,\n                     \"Unexpected CopyNonOverlapping, should only appear after lower_intrinsics\",\n                 )\n             }\n-            StatementKind::Nop\n+            // Only relevant for mir typeck\n+            StatementKind::AscribeUserType(..)\n+            // Doesn't have any language semantics\n             | StatementKind::Coverage(..)\n-            | StatementKind::AscribeUserType(..)\n-            | StatementKind::Retag { .. }\n-            | StatementKind::StorageLive(..) => {\n-                // `Nop`, `AscribeUserType`, `Retag`, and `StorageLive` are irrelevant\n-                // to borrow check.\n-            }\n+            // Does not actually affect borrowck\n+            | StatementKind::StorageLive(..) => {}\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n                     location,\n@@ -616,7 +612,10 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                     flow_state,\n                 );\n             }\n-            StatementKind::Deinit(..) | StatementKind::SetDiscriminant { .. } => {\n+            StatementKind::Nop\n+            | StatementKind::Retag { .. }\n+            | StatementKind::Deinit(..)\n+            | StatementKind::SetDiscriminant { .. } => {\n                 bug!(\"Statement not allowed in this MIR phase\")\n             }\n         }\n@@ -1781,6 +1780,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         for (place_base, elem) in place.iter_projections().rev() {\n             match elem {\n                 ProjectionElem::Index(_/*operand*/) |\n+                ProjectionElem::OpaqueCast(_) |\n                 ProjectionElem::ConstantIndex { .. } |\n                 // assigning to P[i] requires P to be valid.\n                 ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n@@ -2172,6 +2172,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     | ProjectionElem::Index(..)\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n+                    | ProjectionElem::OpaqueCast { .. }\n                     | ProjectionElem::Downcast(..) => {\n                         let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {"}, {"sha": "877944d3d70cb961195ac89e926ca12a39ef2467", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -86,8 +86,7 @@ impl LocationTable {\n         let (block, &first_index) = self\n             .statements_before_block\n             .iter_enumerated()\n-            .filter(|(_, first_index)| **first_index <= point_index)\n-            .last()\n+            .rfind(|&(_, &first_index)| first_index <= point_index)\n             .unwrap();\n \n         let statement_index = (point_index - first_index) / 2;"}, {"sha": "12b2481cc7907ba6ec21a707632428a17945efeb", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -389,8 +389,9 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n     // viewing the intraprocedural state, the -Zdump-mir output is\n     // better.\n \n+    let def_span = tcx.def_span(body.source.def_id());\n     let mut err = if let Some(closure_region_requirements) = closure_region_requirements {\n-        let mut err = tcx.sess.diagnostic().span_note_diag(body.span, \"external requirements\");\n+        let mut err = tcx.sess.diagnostic().span_note_diag(def_span, \"external requirements\");\n \n         regioncx.annotate(tcx, &mut err);\n \n@@ -409,7 +410,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n \n         err\n     } else {\n-        let mut err = tcx.sess.diagnostic().span_note_diag(body.span, \"no external requirements\");\n+        let mut err = tcx.sess.diagnostic().span_note_diag(def_span, \"no external requirements\");\n         regioncx.annotate(tcx, &mut err);\n \n         err"}, {"sha": "0e71efd6f8d3e2ffc79b59bb06610ace769fa066", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -250,6 +250,7 @@ fn place_components_conflict<'tcx>(\n                 | (ProjectionElem::Index { .. }, _, _)\n                 | (ProjectionElem::ConstantIndex { .. }, _, _)\n                 | (ProjectionElem::Subslice { .. }, _, _)\n+                | (ProjectionElem::OpaqueCast { .. }, _, _)\n                 | (ProjectionElem::Downcast { .. }, _, _) => {\n                     // Recursive case. This can still be disjoint on a\n                     // further iteration if this a shallow access and\n@@ -317,6 +318,17 @@ fn place_projection_conflict<'tcx>(\n             debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n             Overlap::EqualOrDisjoint\n         }\n+        (ProjectionElem::OpaqueCast(v1), ProjectionElem::OpaqueCast(v2)) => {\n+            if v1 == v2 {\n+                // same type - recur.\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-OPAQUE\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                // Different types. Disjoint!\n+                debug!(\"place_element_conflict: DISJOINT-OPAQUE\");\n+                Overlap::Disjoint\n+            }\n+        }\n         (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n             if f1 == f2 {\n                 // same field (e.g., `a.y` vs. `a.y`) - recur.\n@@ -520,6 +532,7 @@ fn place_projection_conflict<'tcx>(\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(..)\n             | ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::OpaqueCast { .. }\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Downcast(..),\n             _,"}, {"sha": "2b50cbac9a02da128786fa86e3ed5d80dcfa8b44", "filename": "compiler/rustc_borrowck/src/prefixes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -81,6 +81,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         }\n                         ProjectionElem::Downcast(..)\n                         | ProjectionElem::Subslice { .. }\n+                        | ProjectionElem::OpaqueCast { .. }\n                         | ProjectionElem::ConstantIndex { .. }\n                         | ProjectionElem::Index(_) => {\n                             cursor = cursor_base;"}, {"sha": "244e6e3422d83d0dcdee8ff0b7214727e530cb1c", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 80, "deletions": 90, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -135,7 +135,6 @@ pub struct RegionInferenceContext<'tcx> {\n /// adds a new lower bound to the SCC it is analyzing: so you wind up\n /// with `'R: 'O` where `'R` is the pick-region and `'O` is the\n /// minimal viable option.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]\n pub(crate) struct AppliedMemberConstraint {\n     /// The SCC that was affected. (The \"member region\".)\n     ///\n@@ -246,6 +245,11 @@ enum Trace<'tcx> {\n     NotVisited,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum ExtraConstraintInfo {\n+    PlaceholderFromPredicate(Span),\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -591,13 +595,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // constraints were too strong, and if so, emit or propagate those errors.\n         if infcx.tcx.sess.opts.unstable_opts.polonius {\n             self.check_polonius_subset_errors(\n-                body,\n                 outlives_requirements.as_mut(),\n                 &mut errors_buffer,\n                 polonius_output.expect(\"Polonius output is unavailable despite `-Z polonius`\"),\n             );\n         } else {\n-            self.check_universal_regions(body, outlives_requirements.as_mut(), &mut errors_buffer);\n+            self.check_universal_regions(outlives_requirements.as_mut(), &mut errors_buffer);\n         }\n \n         if errors_buffer.is_empty() {\n@@ -1139,7 +1142,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///   include the CFG anyhow.\n     /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n     ///   a result `'y`.\n-    #[instrument(skip(self), level = \"debug\")]\n+    #[instrument(skip(self), level = \"debug\", ret)]\n     pub(crate) fn universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n         debug!(r = %self.region_value_str(r));\n \n@@ -1151,8 +1154,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n         }\n \n-        debug!(?lub);\n-\n         lub\n     }\n \n@@ -1333,15 +1334,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     // Evaluate whether `sup_region: sub_region`.\n-    #[instrument(skip(self), level = \"debug\")]\n+    #[instrument(skip(self), level = \"debug\", ret)]\n     fn eval_outlives(&self, sup_region: RegionVid, sub_region: RegionVid) -> bool {\n         debug!(\n-            \"eval_outlives: sup_region's value = {:?} universal={:?}\",\n+            \"sup_region's value = {:?} universal={:?}\",\n             self.region_value_str(sup_region),\n             self.universal_regions.is_universal_region(sup_region),\n         );\n         debug!(\n-            \"eval_outlives: sub_region's value = {:?} universal={:?}\",\n+            \"sub_region's value = {:?} universal={:?}\",\n             self.region_value_str(sub_region),\n             self.universal_regions.is_universal_region(sub_region),\n         );\n@@ -1354,7 +1355,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // true if `'sup` outlives static.\n         if !self.universe_compatible(sub_region_scc, sup_region_scc) {\n             debug!(\n-                \"eval_outlives: sub universe `{sub_region_scc:?}` is not nameable \\\n+                \"sub universe `{sub_region_scc:?}` is not nameable \\\n                 by super `{sup_region_scc:?}`, promoting to static\",\n             );\n \n@@ -1375,9 +1376,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             });\n \n         if !universal_outlives {\n-            debug!(\n-                \"eval_outlives: returning false because sub region contains a universal region not present in super\"\n-            );\n+            debug!(\"sub region contains a universal region not present in super\");\n             return false;\n         }\n \n@@ -1386,15 +1385,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         if self.universal_regions.is_universal_region(sup_region) {\n             // Micro-opt: universal regions contain all points.\n-            debug!(\n-                \"eval_outlives: returning true because super is universal and hence contains all points\"\n-            );\n+            debug!(\"super is universal and hence contains all points\");\n             return true;\n         }\n \n-        let result = self.scc_values.contains_points(sup_region_scc, sub_region_scc);\n-        debug!(\"returning {} because of comparison between points in sup/sub\", result);\n-        result\n+        debug!(\"comparison between points in sup/sub\");\n+\n+        self.scc_values.contains_points(sup_region_scc, sub_region_scc)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -1416,7 +1413,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// report them as errors.\n     fn check_universal_regions(\n         &self,\n-        body: &Body<'tcx>,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n@@ -1427,7 +1423,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     // they did not grow too large, accumulating any requirements\n                     // for our caller into the `outlives_requirements` vector.\n                     self.check_universal_region(\n-                        body,\n                         fr,\n                         &mut propagated_outlives_requirements,\n                         errors_buffer,\n@@ -1468,7 +1463,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// report them as errors.\n     fn check_polonius_subset_errors(\n         &self,\n-        body: &Body<'tcx>,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n         polonius_output: Rc<PoloniusOutput>,\n@@ -1515,7 +1509,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let propagated = self.try_propagate_universal_region_error(\n                 *longer_fr,\n                 *shorter_fr,\n-                body,\n                 &mut propagated_outlives_requirements,\n             );\n             if propagated == RegionRelationCheckResult::Error {\n@@ -1555,13 +1548,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Things that are to be propagated are accumulated into the\n     /// `outlives_requirements` vector.\n-    #[instrument(\n-        skip(self, body, propagated_outlives_requirements, errors_buffer),\n-        level = \"debug\"\n-    )]\n+    #[instrument(skip(self, propagated_outlives_requirements, errors_buffer), level = \"debug\")]\n     fn check_universal_region(\n         &self,\n-        body: &Body<'tcx>,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n@@ -1584,7 +1573,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let RegionRelationCheckResult::Error = self.check_universal_region_relation(\n                 longer_fr,\n                 representative,\n-                body,\n                 propagated_outlives_requirements,\n             ) {\n                 errors_buffer.push(RegionErrorKind::RegionError {\n@@ -1604,7 +1592,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let RegionRelationCheckResult::Error = self.check_universal_region_relation(\n                 longer_fr,\n                 shorter_fr,\n-                body,\n                 propagated_outlives_requirements,\n             ) {\n                 // We only report the first region error. Subsequent errors are hidden so as\n@@ -1629,7 +1616,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         longer_fr: RegionVid,\n         shorter_fr: RegionVid,\n-        body: &Body<'tcx>,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n     ) -> RegionRelationCheckResult {\n         // If it is known that `fr: o`, carry on.\n@@ -1645,7 +1631,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.try_propagate_universal_region_error(\n                 longer_fr,\n                 shorter_fr,\n-                body,\n                 propagated_outlives_requirements,\n             )\n         }\n@@ -1657,7 +1642,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         longer_fr: RegionVid,\n         shorter_fr: RegionVid,\n-        body: &Body<'tcx>,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n     ) -> RegionRelationCheckResult {\n         if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n@@ -1669,7 +1653,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 debug!(\"try_propagate_universal_region_error: fr_minus={:?}\", fr_minus);\n \n                 let blame_span_category = self.find_outlives_blame_span(\n-                    body,\n                     longer_fr,\n                     NllRegionVariableOrigin::FreeRegion,\n                     shorter_fr,\n@@ -1823,50 +1806,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     pub(crate) fn retrieve_closure_constraint_info(\n         &self,\n-        _body: &Body<'tcx>,\n-        constraint: &OutlivesConstraint<'tcx>,\n-    ) -> BlameConstraint<'tcx> {\n-        let loc = match constraint.locations {\n-            Locations::All(span) => {\n-                return BlameConstraint {\n-                    category: constraint.category,\n-                    from_closure: false,\n-                    cause: ObligationCause::dummy_with_span(span),\n-                    variance_info: constraint.variance_info,\n-                };\n+        constraint: OutlivesConstraint<'tcx>,\n+    ) -> Option<(ConstraintCategory<'tcx>, Span)> {\n+        match constraint.locations {\n+            Locations::All(_) => None,\n+            Locations::Single(loc) => {\n+                self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub)).copied()\n             }\n-            Locations::Single(loc) => loc,\n-        };\n-\n-        let opt_span_category =\n-            self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n-        opt_span_category\n-            .map(|&(category, span)| BlameConstraint {\n-                category,\n-                from_closure: true,\n-                cause: ObligationCause::dummy_with_span(span),\n-                variance_info: constraint.variance_info,\n-            })\n-            .unwrap_or(BlameConstraint {\n-                category: constraint.category,\n-                from_closure: false,\n-                cause: ObligationCause::dummy_with_span(constraint.span),\n-                variance_info: constraint.variance_info,\n-            })\n+        }\n     }\n \n     /// Finds a good `ObligationCause` to blame for the fact that `fr1` outlives `fr2`.\n     pub(crate) fn find_outlives_blame_span(\n         &self,\n-        body: &Body<'tcx>,\n         fr1: RegionVid,\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory<'tcx>, ObligationCause<'tcx>) {\n-        let BlameConstraint { category, cause, .. } =\n-            self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n-                self.provides_universal_region(r, fr1, fr2)\n-            });\n+        let BlameConstraint { category, cause, .. } = self\n+            .best_blame_constraint(fr1, fr1_origin, |r| self.provides_universal_region(r, fr1, fr2))\n+            .0;\n         (category, cause)\n     }\n \n@@ -1971,7 +1930,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Finds some region R such that `fr1: R` and `R` is live at `elem`.\n-    #[instrument(skip(self), level = \"trace\")]\n+    #[instrument(skip(self), level = \"trace\", ret)]\n     pub(crate) fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         trace!(scc = ?self.constraint_sccs.scc(fr1));\n         trace!(universe = ?self.scc_universes[self.constraint_sccs.scc(fr1)]);\n@@ -2052,11 +2011,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(level = \"debug\", skip(self, target_test))]\n     pub(crate) fn best_blame_constraint(\n         &self,\n-        body: &Body<'tcx>,\n         from_region: RegionVid,\n         from_region_origin: NllRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> BlameConstraint<'tcx> {\n+    ) -> (BlameConstraint<'tcx>, Vec<ExtraConstraintInfo>) {\n         // Find all paths\n         let (path, target_region) =\n             self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n@@ -2072,6 +2030,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .collect::<Vec<_>>()\n         );\n \n+        let mut extra_info = vec![];\n+        for constraint in path.iter() {\n+            let outlived = constraint.sub;\n+            let Some(origin) = self.var_infos.get(outlived) else { continue; };\n+            let RegionVariableOrigin::Nll(NllRegionVariableOrigin::Placeholder(p)) = origin.origin else { continue; };\n+            debug!(?constraint, ?p);\n+            let ConstraintCategory::Predicate(span) = constraint.category else { continue; };\n+            extra_info.push(ExtraConstraintInfo::PlaceholderFromPredicate(span));\n+            // We only want to point to one\n+            break;\n+        }\n+\n         // We try to avoid reporting a `ConstraintCategory::Predicate` as our best constraint.\n         // Instead, we use it to produce an improved `ObligationCauseCode`.\n         // FIXME - determine what we should do if we encounter multiple `ConstraintCategory::Predicate`\n@@ -2097,19 +2067,29 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut categorized_path: Vec<BlameConstraint<'tcx>> = path\n             .iter()\n             .map(|constraint| {\n-                if constraint.category == ConstraintCategory::ClosureBounds {\n-                    self.retrieve_closure_constraint_info(body, &constraint)\n-                } else {\n-                    BlameConstraint {\n-                        category: constraint.category,\n-                        from_closure: false,\n-                        cause: ObligationCause::new(\n-                            constraint.span,\n-                            CRATE_HIR_ID,\n-                            cause_code.clone(),\n-                        ),\n-                        variance_info: constraint.variance_info,\n-                    }\n+                let (category, span, from_closure, cause_code) =\n+                    if constraint.category == ConstraintCategory::ClosureBounds {\n+                        if let Some((category, span)) =\n+                            self.retrieve_closure_constraint_info(*constraint)\n+                        {\n+                            (category, span, true, ObligationCauseCode::MiscObligation)\n+                        } else {\n+                            (\n+                                constraint.category,\n+                                constraint.span,\n+                                false,\n+                                ObligationCauseCode::MiscObligation,\n+                            )\n+                        }\n+                    } else {\n+                        (constraint.category, constraint.span, false, cause_code.clone())\n+                    };\n+                BlameConstraint {\n+                    category,\n+                    from_closure,\n+                    cause: ObligationCause::new(span, CRATE_HIR_ID, cause_code),\n+                    variance_info: constraint.variance_info,\n+                    outlives_constraint: *constraint,\n                 }\n             })\n             .collect();\n@@ -2211,7 +2191,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let best_choice =\n             if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n \n-        debug!(?best_choice, ?blame_source);\n+        debug!(?best_choice, ?blame_source, ?extra_info);\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n@@ -2220,7 +2200,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 {\n                     // The return expression is being influenced by the return type being\n                     // impl Trait, point at the return type and not the return expr.\n-                    return next.clone();\n+                    return (next.clone(), extra_info);\n                 }\n             }\n \n@@ -2240,7 +2220,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n             }\n \n-            return categorized_path[i].clone();\n+            return (categorized_path[i].clone(), extra_info);\n         }\n \n         // If that search fails, that is.. unusual. Maybe everything\n@@ -2250,7 +2230,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         categorized_path.sort_by(|p0, p1| p0.category.cmp(&p1.category));\n         debug!(\"sorted_path={:#?}\", categorized_path);\n \n-        categorized_path.remove(0)\n+        (categorized_path.remove(0), extra_info)\n     }\n \n     pub(crate) fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n@@ -2332,7 +2312,13 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n                              outlives_requirement={:?}\",\n                             region, outlived_region, outlives_requirement,\n                         );\n-                        ty::Binder::dummy(ty::OutlivesPredicate(region.into(), outlived_region))\n+                        (\n+                            ty::Binder::dummy(ty::OutlivesPredicate(\n+                                region.into(),\n+                                outlived_region,\n+                            )),\n+                            ConstraintCategory::BoringNoLocation,\n+                        )\n                     }\n \n                     ClosureOutlivesSubject::Ty(ty) => {\n@@ -2342,7 +2328,10 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n                              outlives_requirement={:?}\",\n                             ty, outlived_region, outlives_requirement,\n                         );\n-                        ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region))\n+                        (\n+                            ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region)),\n+                            ConstraintCategory::BoringNoLocation,\n+                        )\n                     }\n                 }\n             })\n@@ -2356,4 +2345,5 @@ pub struct BlameConstraint<'tcx> {\n     pub from_closure: bool,\n     pub cause: ObligationCause<'tcx>,\n     pub variance_info: ty::VarianceDiagInfo<'tcx>,\n+    pub outlives_constraint: OutlivesConstraint<'tcx>,\n }"}, {"sha": "9d088642f7773eca6e2133cc4bff4eb0b19f5657", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Calling `universal_upper_bound` for such a region gives `fr_fn_body`,\n     /// which has no `external_name` in which case we use `'empty` as the\n     /// region to pass to `infer_opaque_definition_from_instantiation`.\n-    #[instrument(level = \"debug\", skip(self, infcx))]\n+    #[instrument(level = \"debug\", skip(self, infcx), ret)]\n     pub(crate) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -109,7 +109,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         .iter()\n                         .find(|ur_vid| self.eval_equal(vid, **ur_vid))\n                         .and_then(|ur_vid| self.definitions[*ur_vid].external_name)\n-                        .unwrap_or(infcx.tcx.lifetimes.re_root_empty),\n+                        .unwrap_or(infcx.tcx.lifetimes.re_erased),\n                     _ => region,\n                 });\n \n@@ -433,7 +433,7 @@ struct ReverseMapper<'tcx> {\n \n     key: ty::OpaqueTypeKey<'tcx>,\n     map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-    map_missing_regions_to_empty: bool,\n+    do_not_error: bool,\n \n     /// initially `Some`, set to `None` once error has been reported\n     hidden_ty: Option<Ty<'tcx>>,\n@@ -450,29 +450,19 @@ impl<'tcx> ReverseMapper<'tcx> {\n         hidden_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Self {\n-        Self {\n-            tcx,\n-            key,\n-            map,\n-            map_missing_regions_to_empty: false,\n-            hidden_ty: Some(hidden_ty),\n-            span,\n-        }\n+        Self { tcx, key, map, do_not_error: false, hidden_ty: Some(hidden_ty), span }\n     }\n \n-    fn fold_kind_mapping_missing_regions_to_empty(\n-        &mut self,\n-        kind: GenericArg<'tcx>,\n-    ) -> GenericArg<'tcx> {\n-        assert!(!self.map_missing_regions_to_empty);\n-        self.map_missing_regions_to_empty = true;\n+    fn fold_kind_no_missing_regions_error(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n+        assert!(!self.do_not_error);\n+        self.do_not_error = true;\n         let kind = kind.fold_with(self);\n-        self.map_missing_regions_to_empty = false;\n+        self.do_not_error = false;\n         kind\n     }\n \n     fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n-        assert!(!self.map_missing_regions_to_empty);\n+        assert!(!self.do_not_error);\n         kind.fold_with(self)\n     }\n }\n@@ -496,9 +486,9 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             ty::ReErased => return r,\n \n             // The regions that we expect from borrow checking.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {}\n \n-            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) => {\n+            ty::RePlaceholder(_) | ty::ReVar(_) => {\n                 // All of the regions in the type should either have been\n                 // erased by writeback, or mapped back to named regions by\n                 // borrow checking.\n@@ -510,7 +500,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n             Some(GenericArgKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None if self.map_missing_regions_to_empty => self.tcx.lifetimes.re_root_empty,\n+            None if self.do_not_error => self.tcx.lifetimes.re_static,\n             None if generics.parent.is_some() => {\n                 if let Some(hidden_ty) = self.hidden_ty.take() {\n                     unexpected_hidden_region_diagnostic(\n@@ -522,7 +512,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n                 }\n-                self.tcx.lifetimes.re_root_empty\n+                self.tcx.lifetimes.re_static\n             }\n             None => {\n                 self.tcx\n@@ -574,7 +564,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n                     if index < generics.parent_count {\n                         // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                        self.fold_kind_no_missing_regions_error(kind)\n                     } else {\n                         // ...but not elsewhere.\n                         self.fold_kind_normally(kind)\n@@ -589,7 +579,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n                     if index < generics.parent_count {\n                         // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                        self.fold_kind_no_missing_regions_error(kind)\n                     } else {\n                         // ...but not elsewhere.\n                         self.fold_kind_normally(kind)"}, {"sha": "63b2088f7fc099f7a0183dd7d6f3535ca54cd408", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -2,6 +2,7 @@ use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::mir::visit::{MutVisitor, TyContext};\n use rustc_middle::mir::{Body, Location, Promoted};\n+use rustc_middle::mir::{Constant, ConstantKind};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n@@ -37,6 +38,21 @@ where\n     })\n }\n \n+// FIXME(valtrees): This function is necessary because `fold_regions`\n+// panics for mir constants in the visitor.\n+//\n+// Once `visit_mir_constant` is removed we can also remove this function\n+// and just use `renumber_regions`.\n+fn renumber_regions_in_mir_constant<'tcx>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    value: ConstantKind<'tcx>,\n+) -> ConstantKind<'tcx> {\n+    infcx.tcx.super_fold_regions(value, |_region, _depth| {\n+        let origin = NllRegionVariableOrigin::Existential { from_forall: false };\n+        infcx.next_nll_region_var(origin)\n+    })\n+}\n+\n struct NllVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n }\n@@ -48,6 +64,13 @@ impl<'a, 'tcx> NllVisitor<'a, 'tcx> {\n     {\n         renumber_regions(self.infcx, value)\n     }\n+\n+    fn renumber_regions_in_mir_constant(\n+        &mut self,\n+        value: ConstantKind<'tcx>,\n+    ) -> ConstantKind<'tcx> {\n+        renumber_regions_in_mir_constant(self.infcx, value)\n+    }\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n@@ -77,7 +100,10 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n         debug!(?region);\n     }\n \n-    fn visit_const(&mut self, constant: &mut ty::Const<'tcx>, _location: Location) {\n-        *constant = self.renumber_regions(*constant);\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_constant(&mut self, constant: &mut Constant<'tcx>, _location: Location) {\n+        let literal = constant.literal;\n+        constant.literal = self.renumber_regions_in_mir_constant(literal);\n+        debug!(\"constant: {:#?}\", constant);\n     }\n }"}, {"sha": "9f19453a1a658717b41368436b21710530167fe0", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,11 +1,11 @@\n use rustc_errors::{IntoDiagnosticArg, MultiSpan};\n-use rustc_macros::{LintDiagnostic, SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n \n use crate::diagnostics::RegionName;\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(borrowck::move_unsized, code = \"E0161\")]\n pub(crate) struct MoveUnsized<'tcx> {\n     pub ty: Ty<'tcx>,\n@@ -14,7 +14,7 @@ pub(crate) struct MoveUnsized<'tcx> {\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(borrowck::higher_ranked_lifetime_error)]\n pub(crate) struct HigherRankedLifetimeError {\n     #[subdiagnostic]\n@@ -23,22 +23,22 @@ pub(crate) struct HigherRankedLifetimeError {\n     pub span: Span,\n }\n \n-#[derive(SessionSubdiagnostic)]\n+#[derive(Subdiagnostic)]\n pub(crate) enum HigherRankedErrorCause {\n     #[note(borrowck::could_not_prove)]\n     CouldNotProve { predicate: String },\n     #[note(borrowck::could_not_normalize)]\n     CouldNotNormalize { value: String },\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(borrowck::higher_ranked_subtype_error)]\n pub(crate) struct HigherRankedSubtypeError {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(borrowck::generic_does_not_live_long_enough)]\n pub(crate) struct GenericDoesNotLiveLongEnough {\n     pub kind: String,\n@@ -53,15 +53,15 @@ pub(crate) struct VarNeedNotMut {\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(borrowck::const_not_used_in_type_alias)]\n pub(crate) struct ConstNotUsedTraitAlias {\n     pub ct: String,\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(borrowck::var_cannot_escape_closure)]\n #[note]\n #[note(borrowck::cannot_escape)]\n@@ -72,7 +72,7 @@ pub(crate) struct FnMutError {\n     pub ty_err: FnMutReturnTypeErr,\n }\n \n-#[derive(SessionSubdiagnostic)]\n+#[derive(Subdiagnostic)]\n pub(crate) enum VarHereDenote {\n     #[label(borrowck::var_here_captured)]\n     Captured {\n@@ -91,7 +91,7 @@ pub(crate) enum VarHereDenote {\n     },\n }\n \n-#[derive(SessionSubdiagnostic)]\n+#[derive(Subdiagnostic)]\n pub(crate) enum FnMutReturnTypeErr {\n     #[label(borrowck::returned_closure_escaped)]\n     ReturnClosure {\n@@ -110,14 +110,14 @@ pub(crate) enum FnMutReturnTypeErr {\n     },\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(borrowck::lifetime_constraints_error)]\n pub(crate) struct LifetimeOutliveErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionSubdiagnostic)]\n+#[derive(Subdiagnostic)]\n pub(crate) enum LifetimeReturnCategoryErr<'a> {\n     #[label(borrowck::returned_lifetime_wrong)]\n     WrongReturn {\n@@ -149,7 +149,7 @@ impl IntoDiagnosticArg for RegionName {\n     }\n }\n \n-#[derive(SessionSubdiagnostic)]\n+#[derive(Subdiagnostic)]\n pub(crate) enum RequireStaticErr {\n     #[note(borrowck::used_impl_require_static)]\n     UsedImpl {"}, {"sha": "9271a2f4dc718f345fb32bad3814386fda2b2738", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// constraints should occur within this method so that those\n     /// constraints can be properly localized!**\n     #[instrument(skip(self, op), level = \"trace\")]\n-    pub(super) fn fully_perform_op<R, Op>(\n+    pub(super) fn fully_perform_op<R: fmt::Debug, Op>(\n         &mut self,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n@@ -39,6 +39,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n         let TypeOpOutput { output, constraints, error_info } = op.fully_perform(self.infcx)?;\n \n+        debug!(?output, ?constraints);\n+\n         if let Some(data) = constraints {\n             self.push_region_constraints(locations, category, data);\n         }\n@@ -102,6 +104,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn normalize_and_prove_instantiated_predicates(\n         &mut self,\n         // Keep this parameter for now, in case we start using\n@@ -116,8 +119,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             .zip(instantiated_predicates.spans.into_iter())\n         {\n             debug!(?predicate);\n-            let predicate = self.normalize(predicate, locations);\n-            self.prove_predicate(predicate, locations, ConstraintCategory::Predicate(span));\n+            let category = ConstraintCategory::Predicate(span);\n+            let predicate = self.normalize_with_category(predicate, locations, category);\n+            self.prove_predicate(predicate, locations, category);\n         }\n     }\n \n@@ -153,15 +157,27 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         })\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n     pub(super) fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n+    where\n+        T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,\n+    {\n+        self.normalize_with_category(value, location, ConstraintCategory::Boring)\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(super) fn normalize_with_category<T>(\n+        &mut self,\n+        value: T,\n+        location: impl NormalizeLocation,\n+        category: ConstraintCategory<'tcx>,\n+    ) -> T\n     where\n         T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,\n     {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             location.to_locations(),\n-            ConstraintCategory::Boring,\n+            category,\n             param_env.and(type_op::normalize::Normalize::new(value)),\n         )\n         .unwrap_or_else(|NoSolution| {"}, {"sha": "71eae0583cb483870b4a612d8442a36436602310", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n+    fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below.\n@@ -98,15 +98,18 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         // region constraints like `for<'a> 'a: 'b`. At some point\n         // when we move to universes, we will, and this assertion\n         // will start to fail.\n-        let ty::OutlivesPredicate(k1, r2) = query_constraint.no_bound_vars().unwrap_or_else(|| {\n-            bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n-        });\n+        let ty::OutlivesPredicate(k1, r2) =\n+            query_constraint.0.no_bound_vars().unwrap_or_else(|| {\n+                bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n+            });\n+\n+        let constraint_category = query_constraint.1;\n \n         match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n                 let r1_vid = self.to_region_vid(r1);\n                 let r2_vid = self.to_region_vid(r2);\n-                self.add_outlives(r1_vid, r2_vid);\n+                self.add_outlives(r1_vid, r2_vid, constraint_category);\n             }\n \n             GenericArgKind::Type(t1) => {\n@@ -121,7 +124,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                     Some(implicit_region_bound),\n                     param_env,\n                 )\n-                .type_must_outlive(origin, t1, r2);\n+                .type_must_outlive(origin, t1, r2, constraint_category);\n             }\n \n             GenericArgKind::Const(_) => {\n@@ -168,10 +171,19 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n+    fn add_outlives(\n+        &mut self,\n+        sup: ty::RegionVid,\n+        sub: ty::RegionVid,\n+        category: ConstraintCategory<'tcx>,\n+    ) {\n+        let category = match self.category {\n+            ConstraintCategory::Boring | ConstraintCategory::BoringNoLocation => category,\n+            _ => self.category,\n+        };\n         self.constraints.outlives_constraints.push(OutlivesConstraint {\n             locations: self.locations,\n-            category: self.category,\n+            category,\n             span: self.span,\n             sub,\n             sup,\n@@ -191,10 +203,11 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         _origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n+        constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         let b = self.to_region_vid(b);\n         let a = self.to_region_vid(a);\n-        self.add_outlives(b, a);\n+        self.add_outlives(b, a, constraint_category);\n     }\n \n     fn push_verify("}, {"sha": "e0140e281ee736cc07e072955fcaf5c8c87f7895", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -347,13 +347,6 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n \n             match outlives_bound {\n                 OutlivesBound::RegionSubRegion(r1, r2) => {\n-                    // `where Type:` is lowered to `where Type: 'empty` so that\n-                    // we check `Type` is well formed, but there's no use for\n-                    // this bound here.\n-                    if r1.is_empty() {\n-                        return;\n-                    }\n-\n                     // The bound says that `r1 <= r2`; we store `r2: r1`.\n                     let r1 = self.universal_regions.to_region_vid(r1);\n                     let r2 = self.universal_regions.to_region_vid(r2);\n@@ -369,6 +362,11 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                     self.region_bound_pairs\n                         .insert(ty::OutlivesPredicate(GenericKind::Projection(projection_b), r_a));\n                 }\n+\n+                OutlivesBound::RegionSubOpaque(r_a, def_id, substs) => {\n+                    self.region_bound_pairs\n+                        .insert(ty::OutlivesPredicate(GenericKind::Opaque(def_id, substs), r_a));\n+                }\n             }\n         }\n     }"}, {"sha": "d03f036964857d2434a20e4794a0d659a32c4c48", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 75, "deletions": 16, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -30,8 +30,9 @@ use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef, UserSubsts};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n-    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, OpaqueHiddenType,\n-    OpaqueTypeKey, RegionVid, ToPredicate, Ty, TyCtxt, UserType, UserTypeAnnotationIndex,\n+    self, Binder, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, Dynamic,\n+    OpaqueHiddenType, OpaqueTypeKey, RegionVid, ToPredicate, Ty, TyCtxt, UserType,\n+    UserTypeAnnotationIndex,\n };\n use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n@@ -311,6 +312,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n     }\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n+        debug!(?constant, ?location, \"visit_constant\");\n+\n         self.super_constant(constant, location);\n         let ty = self.sanitize_type(constant, constant.literal.ty());\n \n@@ -354,11 +357,15 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n             let tcx = self.tcx();\n             let maybe_uneval = match constant.literal {\n                 ConstantKind::Ty(ct) => match ct.kind() {\n-                    ty::ConstKind::Unevaluated(uv) => Some(uv),\n+                    ty::ConstKind::Unevaluated(_) => {\n+                        bug!(\"should not encounter unevaluated ConstantKind::Ty here, got {:?}\", ct)\n+                    }\n                     _ => None,\n                 },\n+                ConstantKind::Unevaluated(uv, _) => Some(uv),\n                 _ => None,\n             };\n+\n             if let Some(uv) = maybe_uneval {\n                 if let Some(promoted) = uv.promoted {\n                     let check_err = |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n@@ -421,12 +428,18 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n             }\n \n             if let ty::FnDef(def_id, substs) = *constant.literal.ty().kind() {\n+                // const_trait_impl: use a non-const param env when checking that a FnDef type is well formed.\n+                // this is because the well-formedness of the function does not need to be proved to have `const`\n+                // impls for trait bounds.\n                 let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n+                let prev = self.cx.param_env;\n+                self.cx.param_env = prev.without_const();\n                 self.cx.normalize_and_prove_instantiated_predicates(\n                     def_id,\n                     instantiated_predicates,\n                     locations,\n                 );\n+                self.cx.param_env = prev;\n             }\n         }\n     }\n@@ -757,6 +770,19 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }\n                 PlaceTy::from_ty(fty)\n             }\n+            ProjectionElem::OpaqueCast(ty) => {\n+                let ty = self.sanitize_type(place, ty);\n+                let ty = self.cx.normalize(ty, location);\n+                self.cx\n+                    .eq_types(\n+                        base.ty,\n+                        ty,\n+                        location.to_locations(),\n+                        ConstraintCategory::TypeAnnotation,\n+                    )\n+                    .unwrap();\n+                PlaceTy::from_ty(ty)\n+            }\n         }\n     }\n \n@@ -1163,10 +1189,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 tcx,\n                 self.param_env,\n                 proj,\n-                |this, field, ()| {\n+                |this, field, _| {\n                     let ty = this.field_ty(tcx, field);\n                     self.normalize(ty, locations)\n                 },\n+                |_, _| unreachable!(),\n             );\n             curr_projected_ty = projected_ty;\n         }\n@@ -1302,12 +1329,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n-                ..\n-            }) => span_bug!(\n-                stmt.source_info.span,\n-                \"Unexpected StatementKind::CopyNonOverlapping, should only appear after lowering_intrinsics\",\n-            ),\n+            StatementKind::Intrinsic(box ref kind) => match kind {\n+                NonDivergingIntrinsic::Assume(op) => self.check_operand(op, location),\n+                NonDivergingIntrinsic::CopyNonOverlapping(..) => span_bug!(\n+                    stmt.source_info.span,\n+                    \"Unexpected NonDivergingIntrinsic::CopyNonOverlapping, should only appear after lowering_intrinsics\",\n+                ),\n+            },\n             StatementKind::FakeRead(..)\n             | StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)\n@@ -1809,14 +1837,14 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     }\n \n     fn check_operand(&mut self, op: &Operand<'tcx>, location: Location) {\n+        debug!(?op, ?location, \"check_operand\");\n+\n         if let Operand::Constant(constant) = op {\n             let maybe_uneval = match constant.literal {\n-                ConstantKind::Ty(ct) => match ct.kind() {\n-                    ty::ConstKind::Unevaluated(uv) => Some(uv),\n-                    _ => None,\n-                },\n-                _ => None,\n+                ConstantKind::Val(..) | ConstantKind::Ty(_) => None,\n+                ConstantKind::Unevaluated(uv, _) => Some(uv),\n             };\n+\n             if let Some(uv) = maybe_uneval {\n                 if uv.promoted.is_none() {\n                     let tcx = self.tcx();\n@@ -2008,6 +2036,36 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         );\n                     }\n \n+                    CastKind::DynStar => {\n+                        // get the constraints from the target type (`dyn* Clone`)\n+                        //\n+                        // apply them to prove that the source type `Foo` implements `Clone` etc\n+                        let (existential_predicates, region) = match ty.kind() {\n+                            Dynamic(predicates, region, ty::DynStar) => (predicates, region),\n+                            _ => panic!(\"Invalid dyn* cast_ty\"),\n+                        };\n+\n+                        let self_ty = op.ty(body, tcx);\n+\n+                        self.prove_predicates(\n+                            existential_predicates\n+                                .iter()\n+                                .map(|predicate| predicate.with_self_ty(tcx, self_ty)),\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        );\n+\n+                        let outlives_predicate =\n+                            tcx.mk_predicate(Binder::dummy(ty::PredicateKind::TypeOutlives(\n+                                ty::OutlivesPredicate(self_ty, *region),\n+                            )));\n+                        self.prove_predicate(\n+                            outlives_predicate,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        );\n+                    }\n+\n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n                         let ty::RawPtr(ty::TypeAndMut {\n                             ty: ty_from,\n@@ -2465,6 +2523,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n                 ProjectionElem::Field(..)\n                 | ProjectionElem::Downcast(..)\n+                | ProjectionElem::OpaqueCast(..)\n                 | ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n                 | ProjectionElem::Subslice { .. } => {\n@@ -2559,7 +2618,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 .enumerate()\n                 .filter_map(|(idx, constraint)| {\n                     let ty::OutlivesPredicate(k1, r2) =\n-                        constraint.no_bound_vars().unwrap_or_else(|| {\n+                        constraint.0.no_bound_vars().unwrap_or_else(|| {\n                             bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n                         });\n "}, {"sha": "41fba8deb10e7bc832092d70310623e90104bd4e", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -22,8 +22,8 @@ use rustc_hir::{BodyOwnerKind, HirId};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::{self, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt};\n+use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use std::iter;\n \n use crate::nll::ToRegionVid;\n@@ -54,13 +54,6 @@ pub struct UniversalRegions<'tcx> {\n     /// The total number of universal region variables instantiated.\n     num_universals: usize,\n \n-    /// A special region variable created for the `'empty(U0)` region.\n-    /// Note that this is **not** a \"universal\" region, as it doesn't\n-    /// represent a universally bound placeholder or any such thing.\n-    /// But we do create it here in this type because it's a useful region\n-    /// to have around in a few limited cases.\n-    pub root_empty: RegionVid,\n-\n     /// The \"defining\" type for this function, with all universal\n     /// regions instantiated. For a closure or generator, this is the\n     /// closure type, but for a top-level function it's the `FnDef`.\n@@ -323,11 +316,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n     /// See `UniversalRegionIndices::to_region_vid`.\n     pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n-        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = *r {\n-            self.root_empty\n-        } else {\n-            self.indices.to_region_vid(r)\n-        }\n+        self.indices.to_region_vid(r)\n     }\n \n     /// As part of the NLL unit tests, you can annotate a function with\n@@ -501,16 +490,10 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             _ => None,\n         };\n \n-        let root_empty = self\n-            .infcx\n-            .next_nll_region_var(NllRegionVariableOrigin::Existential { from_forall: true })\n-            .to_region_vid();\n-\n         UniversalRegions {\n             indices,\n             fr_static,\n             fr_fn_body,\n-            root_empty,\n             first_extern_index,\n             first_local_index,\n             num_universals,\n@@ -768,10 +751,9 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) {\n-        debug!(\"replace_late_bound_regions_with_nll_infer_vars(mir_def_id={:?})\", mir_def_id);\n         let typeck_root_def_id = self.tcx.typeck_root_def_id(mir_def_id.to_def_id());\n         for_each_late_bound_region_defined_on(self.tcx, typeck_root_def_id, |r| {\n-            debug!(\"replace_late_bound_regions_with_nll_infer_vars: r={:?}\", r);\n+            debug!(?r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = self.next_nll_region_var(FR);\n                 debug!(?region_vid);"}, {"sha": "6469d0d7b88a68440c2b27735de6aede13a93f39", "filename": "compiler/rustc_builtin_macros/Cargo.toml", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2FCargo.toml?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -7,20 +7,21 @@ edition = \"2021\"\n doctest = false\n \n [dependencies]\n-rustc_parse_format = { path = \"../rustc_parse_format\" }\n-tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n+rustc_expand = { path = \"../rustc_expand\" }\n rustc_feature = { path = \"../rustc_feature\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n rustc_macros = { path = \"../rustc_macros\" }\n+rustc_parse_format = { path = \"../rustc_parse_format\" }\n rustc_parse = { path = \"../rustc_parse\" }\n-rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n-smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-rustc_ast = { path = \"../rustc_ast\" }\n-rustc_expand = { path = \"../rustc_expand\" }\n rustc_span = { path = \"../rustc_span\" }\n+rustc_target = { path = \"../rustc_target\" }\n+smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n+thin-vec = \"0.2.8\"\n+tracing = \"0.1\""}, {"sha": "973a8cb85c2b9c12b652f8f60e81cda603377550", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -13,6 +13,7 @@ use rustc_span::{\n     symbol::{sym, Ident, Symbol},\n     Span,\n };\n+use thin_vec::thin_vec;\n \n pub(super) struct Context<'cx, 'a> {\n     // An optimization.\n@@ -116,11 +117,10 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             self.cx.item(\n                 self.span,\n                 Ident::empty(),\n-                vec![self.cx.attribute(attr::mk_list_item(\n+                thin_vec![self.cx.attribute(attr::mk_list_item(\n                     Ident::new(sym::allow, self.span),\n                     vec![attr::mk_nested_word_item(Ident::new(sym::unused_imports, self.span))],\n-                ))]\n-                .into(),\n+                ))],\n                 ItemKind::Use(UseTree {\n                     prefix: self.cx.path(self.span, self.cx.std_path(&[sym::asserting])),\n                     kind: UseTreeKind::Nested(vec!["}, {"sha": "46b54eae384990e8a3792c82ca5cca5f85867289", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_attr as attr;\n use rustc_errors::PResult;\n use rustc_expand::base::{self, *};\n-use rustc_macros::SessionDiagnostic;\n+use rustc_macros::Diagnostic;\n use rustc_span::Span;\n \n pub fn expand_cfg(\n@@ -35,15 +35,15 @@ pub fn expand_cfg(\n     }\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(builtin_macros::requires_cfg_pattern)]\n struct RequiresCfgPattern {\n     #[primary_span]\n     #[label]\n     span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(builtin_macros::expected_one_cfg_pattern)]\n struct OneCfgPattern {\n     #[primary_span]"}, {"sha": "009f3c783d4c8d946cdd73f1fc011bce86a93611", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -7,6 +7,7 @@ use rustc_ast::visit::Visitor;\n use rustc_ast::NodeId;\n use rustc_ast::{mut_visit, visit};\n use rustc_ast::{Attribute, HasAttrs, HasTokens};\n+use rustc_errors::PResult;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_expand::config::StripUnconfigured;\n use rustc_expand::configure;\n@@ -144,33 +145,34 @@ impl CfgEval<'_, '_> {\n         // the location of `#[cfg]` and `#[cfg_attr]` in the token stream. The tokenization\n         // process is lossless, so this process is invisible to proc-macros.\n \n-        let parse_annotatable_with: fn(&mut Parser<'_>) -> _ = match annotatable {\n-            Annotatable::Item(_) => {\n-                |parser| Annotatable::Item(parser.parse_item(ForceCollect::Yes).unwrap().unwrap())\n-            }\n-            Annotatable::TraitItem(_) => |parser| {\n-                Annotatable::TraitItem(\n-                    parser.parse_trait_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n-                )\n-            },\n-            Annotatable::ImplItem(_) => |parser| {\n-                Annotatable::ImplItem(\n-                    parser.parse_impl_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n-                )\n-            },\n-            Annotatable::ForeignItem(_) => |parser| {\n-                Annotatable::ForeignItem(\n-                    parser.parse_foreign_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n-                )\n-            },\n-            Annotatable::Stmt(_) => |parser| {\n-                Annotatable::Stmt(P(parser.parse_stmt(ForceCollect::Yes).unwrap().unwrap()))\n-            },\n-            Annotatable::Expr(_) => {\n-                |parser| Annotatable::Expr(parser.parse_expr_force_collect().unwrap())\n-            }\n-            _ => unreachable!(),\n-        };\n+        let parse_annotatable_with: for<'a> fn(&mut Parser<'a>) -> PResult<'a, _> =\n+            match annotatable {\n+                Annotatable::Item(_) => {\n+                    |parser| Ok(Annotatable::Item(parser.parse_item(ForceCollect::Yes)?.unwrap()))\n+                }\n+                Annotatable::TraitItem(_) => |parser| {\n+                    Ok(Annotatable::TraitItem(\n+                        parser.parse_trait_item(ForceCollect::Yes)?.unwrap().unwrap(),\n+                    ))\n+                },\n+                Annotatable::ImplItem(_) => |parser| {\n+                    Ok(Annotatable::ImplItem(\n+                        parser.parse_impl_item(ForceCollect::Yes)?.unwrap().unwrap(),\n+                    ))\n+                },\n+                Annotatable::ForeignItem(_) => |parser| {\n+                    Ok(Annotatable::ForeignItem(\n+                        parser.parse_foreign_item(ForceCollect::Yes)?.unwrap().unwrap(),\n+                    ))\n+                },\n+                Annotatable::Stmt(_) => |parser| {\n+                    Ok(Annotatable::Stmt(P(parser.parse_stmt(ForceCollect::Yes)?.unwrap())))\n+                },\n+                Annotatable::Expr(_) => {\n+                    |parser| Ok(Annotatable::Expr(parser.parse_expr_force_collect()?))\n+                }\n+                _ => unreachable!(),\n+            };\n \n         // 'Flatten' all nonterminals (i.e. `TokenKind::Interpolated`)\n         // to `None`-delimited groups containing the corresponding tokens. This\n@@ -188,14 +190,20 @@ impl CfgEval<'_, '_> {\n         let orig_tokens = annotatable.to_tokens().flattened();\n \n         // Re-parse the tokens, setting the `capture_cfg` flag to save extra information\n-        // to the captured `AttrAnnotatedTokenStream` (specifically, we capture\n-        // `AttrAnnotatedTokenTree::AttributesData` for all occurrences of `#[cfg]` and `#[cfg_attr]`)\n+        // to the captured `AttrTokenStream` (specifically, we capture\n+        // `AttrTokenTree::AttributesData` for all occurrences of `#[cfg]` and `#[cfg_attr]`)\n         let mut parser =\n             rustc_parse::stream_to_parser(&self.cfg.sess.parse_sess, orig_tokens, None);\n         parser.capture_cfg = true;\n-        annotatable = parse_annotatable_with(&mut parser);\n+        match parse_annotatable_with(&mut parser) {\n+            Ok(a) => annotatable = a,\n+            Err(mut err) => {\n+                err.emit();\n+                return Some(annotatable);\n+            }\n+        }\n \n-        // Now that we have our re-parsed `AttrAnnotatedTokenStream`, recursively configuring\n+        // Now that we have our re-parsed `AttrTokenStream`, recursively configuring\n         // our attribute target will correctly the tokens as well.\n         flat_map_annotatable(self, annotatable)\n     }"}, {"sha": "db05c00d2118ab856151c294f0e0b463ed988301", "filename": "compiler/rustc_builtin_macros/src/cmdline_attrs.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -28,7 +28,13 @@ pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -\n             continue;\n         }\n \n-        krate.attrs.push(mk_attr(AttrStyle::Inner, path, args, start_span.to(end_span)));\n+        krate.attrs.push(mk_attr(\n+            &parse_sess.attr_id_generator,\n+            AttrStyle::Inner,\n+            path,\n+            args,\n+            start_span.to(end_span),\n+        ));\n     }\n \n     krate"}, {"sha": "e0fb7affb3498438de838549ceba3624654f3cd6", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -32,7 +32,8 @@ impl MultiItemModifier for Expander {\n             ecx.resolver.resolve_derives(ecx.current_expansion.id, ecx.force_mode, &|| {\n                 let template =\n                     AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n-                let attr = attr::mk_attr_outer(meta_item.clone());\n+                let attr =\n+                    attr::mk_attr_outer(&sess.parse_sess.attr_id_generator, meta_item.clone());\n                 validate_attr::check_builtin_attribute(\n                     &sess.parse_sess,\n                     &attr,"}, {"sha": "c7f2d95e72f0c45e817a06b5e149ecdd0f1ec1cf", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,12 +1,12 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n-\n use rustc_ast::{self as ast, Generics, ItemKind, MetaItem, VariantData};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n+use thin_vec::thin_vec;\n \n pub fn expand_deriving_clone(\n     cx: &mut ExtCtxt<'_>,\n@@ -68,7 +68,7 @@ pub fn expand_deriving_clone(\n     }\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)].into();\n+    let attrs = thin_vec![cx.attribute(inline)];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(clone::Clone),"}, {"sha": "5b556c5c9b9d1848c25193dcc1ecb64d0010c0a8", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -7,6 +7,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n+use thin_vec::thin_vec;\n \n pub fn expand_deriving_eq(\n     cx: &mut ExtCtxt<'_>,\n@@ -20,7 +21,7 @@ pub fn expand_deriving_eq(\n     let hidden = rustc_ast::attr::mk_nested_word_item(Ident::new(sym::hidden, span));\n     let doc = rustc_ast::attr::mk_list_item(Ident::new(sym::doc, span), vec![hidden]);\n     let no_coverage = cx.meta_word(span, sym::no_coverage);\n-    let attrs = vec![cx.attribute(inline), cx.attribute(doc), cx.attribute(no_coverage)].into();\n+    let attrs = thin_vec![cx.attribute(inline), cx.attribute(doc), cx.attribute(no_coverage)];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Eq),"}, {"sha": "72625869558119ec908051a5e21ca8d9e718c574", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,11 +1,11 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n-\n use rustc_ast::MetaItem;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n+use thin_vec::thin_vec;\n \n pub fn expand_deriving_ord(\n     cx: &mut ExtCtxt<'_>,\n@@ -15,7 +15,7 @@ pub fn expand_deriving_ord(\n     push: &mut dyn FnMut(Annotatable),\n ) {\n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)].into();\n+    let attrs = thin_vec![cx.attribute(inline)];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Ord),"}, {"sha": "42ee65b570a2a95a2fff7ee0f6ffe794661673ae", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,12 +1,12 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_local, path_std};\n-\n use rustc_ast::ptr::P;\n use rustc_ast::{BinOpKind, BorrowKind, Expr, ExprKind, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use thin_vec::thin_vec;\n \n pub fn expand_deriving_partial_eq(\n     cx: &mut ExtCtxt<'_>,\n@@ -68,7 +68,7 @@ pub fn expand_deriving_partial_eq(\n     // No need to generate `ne`, the default suffices, and not generating it is\n     // faster.\n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)].into();\n+    let attrs = thin_vec![cx.attribute(inline)];\n     let methods = vec![MethodDef {\n         name: sym::eq,\n         generics: Bounds::empty(),"}, {"sha": "516892aeda96f9da303e693e041542bf6ab8916b", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,11 +1,11 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n-\n use rustc_ast::MetaItem;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n+use thin_vec::thin_vec;\n \n pub fn expand_deriving_partial_ord(\n     cx: &mut ExtCtxt<'_>,\n@@ -19,7 +19,7 @@ pub fn expand_deriving_partial_ord(\n         Path(Path::new_(pathvec_std!(option::Option), vec![Box::new(ordering_ty)], PathKind::Std));\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)].into();\n+    let attrs = thin_vec![cx.attribute(inline)];\n \n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,"}, {"sha": "a94c8a996e6423fbf1151ace70f135a89f6cd6f0", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,6 +1,5 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n-\n use rustc_ast as ast;\n use rustc_ast::{walk_list, EnumDef, VariantData};\n use rustc_errors::Applicability;\n@@ -9,6 +8,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use smallvec::SmallVec;\n+use thin_vec::thin_vec;\n \n pub fn expand_deriving_default(\n     cx: &mut ExtCtxt<'_>,\n@@ -20,7 +20,7 @@ pub fn expand_deriving_default(\n     item.visit_with(&mut DetectNonVariantDefaultAttr { cx });\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)].into();\n+    let attrs = thin_vec![cx.attribute(inline)];\n     let trait_def = TraitDef {\n         span,\n         path: Path::new(vec![kw::Default, sym::Default]),"}, {"sha": "3cc160adb5397aa73ed3041e23e8f0d081db2fc5", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -162,22 +162,22 @@\n pub use StaticFields::*;\n pub use SubstructureFields::*;\n \n-use std::cell::RefCell;\n-use std::iter;\n-use std::vec;\n-\n+use crate::deriving;\n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, EnumDef, Expr, Generics, PatKind};\n+use rustc_ast::{\n+    self as ast, BindingAnnotation, ByRef, EnumDef, Expr, Generics, Mutability, PatKind,\n+};\n use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_attr as attr;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-\n+use std::cell::RefCell;\n+use std::iter;\n+use std::vec;\n+use thin_vec::thin_vec;\n use ty::{Bounds, Path, Ref, Self_, Ty};\n \n-use crate::deriving;\n-\n pub mod ty;\n \n pub struct TraitDef<'a> {\n@@ -715,7 +715,7 @@ impl<'a> TraitDef<'a> {\n         let self_type = cx.ty_path(path);\n \n         let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n-        let attrs = vec![attr].into();\n+        let attrs = thin_vec![attr];\n         let opt_trait_ref = Some(trait_ref);\n \n         cx.item(\n@@ -1065,9 +1065,9 @@ impl<'a> MethodDef<'a> {\n             let mut body = mk_body(cx, selflike_fields);\n \n             let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-            let use_ref_pat = is_packed && !always_copy;\n+            let by_ref = ByRef::from(is_packed && !always_copy);\n             let patterns =\n-                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, use_ref_pat);\n+                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, by_ref);\n \n             // Do the let-destructuring.\n             let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n@@ -1249,13 +1249,13 @@ impl<'a> MethodDef<'a> {\n \n                 let sp = variant.span.with_ctxt(trait_.span.ctxt());\n                 let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n-                let use_ref_pat = false; // because enums can't be repr(packed)\n+                let by_ref = ByRef::No; // because enums can't be repr(packed)\n                 let mut subpats: Vec<_> = trait_.create_struct_patterns(\n                     cx,\n                     variant_path,\n                     &variant.data,\n                     &prefixes,\n-                    use_ref_pat,\n+                    by_ref,\n                 );\n \n                 // `(VariantK, VariantK, ...)` or just `VariantK`.\n@@ -1416,25 +1416,27 @@ impl<'a> TraitDef<'a> {\n         struct_path: ast::Path,\n         struct_def: &'a VariantData,\n         prefixes: &[String],\n-        use_ref_pat: bool,\n+        by_ref: ByRef,\n     ) -> Vec<P<ast::Pat>> {\n         prefixes\n             .iter()\n             .map(|prefix| {\n                 let pieces_iter =\n                     struct_def.fields().iter().enumerate().map(|(i, struct_field)| {\n                         let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-                        let binding_mode = if use_ref_pat {\n-                            ast::BindingMode::ByRef(ast::Mutability::Not)\n-                        } else {\n-                            ast::BindingMode::ByValue(ast::Mutability::Not)\n-                        };\n                         let ident = self.mk_pattern_ident(prefix, i);\n                         let path = ident.with_span_pos(sp);\n                         (\n                             sp,\n                             struct_field.ident,\n-                            cx.pat(path.span, PatKind::Ident(binding_mode, path, None)),\n+                            cx.pat(\n+                                path.span,\n+                                PatKind::Ident(\n+                                    BindingAnnotation(by_ref, Mutability::Not),\n+                                    path,\n+                                    None,\n+                                ),\n+                            ),\n                         )\n                     });\n "}, {"sha": "45b9b8ab6b6410e0034793b06f8f77cfc4888504", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -9,6 +9,7 @@ use rustc_ast::{Fn, ItemKind, Mutability, Stmt, Ty, TyKind, Unsafe};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::thin_vec;\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n@@ -116,7 +117,7 @@ impl AllocFnFactory<'_, '_> {\n     fn attrs(&self) -> AttrVec {\n         let special = sym::rustc_std_internal_symbol;\n         let special = self.cx.meta_word(self.span, special);\n-        vec![self.cx.attribute(special)].into()\n+        thin_vec![self.cx.attribute(special)]\n     }\n \n     fn arg_ty("}, {"sha": "0de27d3d4070e70d83f7e784251ab15a4ec382f6", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -9,13 +9,15 @@\n #![feature(if_let_guard)]\n #![feature(is_sorted)]\n #![feature(let_chains)]\n-#![feature(let_else)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n #![recursion_limit = \"256\"]\n \n extern crate proc_macro;\n \n+#[macro_use]\n+extern crate tracing;\n+\n use crate::deriving::*;\n \n use rustc_expand::base::{MacroExpanderFn, ResolverExpand, SyntaxExtensionKind};"}, {"sha": "49ef538f04e14ab83ffe4ed173e5646b7ca40d30", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -6,6 +6,7 @@ use rustc_span::edition::Edition::*;\n use rustc_span::hygiene::AstPass;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n+use thin_vec::thin_vec;\n \n pub fn inject(\n     mut krate: ast::Crate,\n@@ -51,7 +52,7 @@ pub fn inject(\n             cx.item(\n                 span,\n                 ident,\n-                vec![cx.attribute(cx.meta_word(span, sym::macro_use))].into(),\n+                thin_vec![cx.attribute(cx.meta_word(span, sym::macro_use))],\n                 ast::ItemKind::ExternCrate(None),\n             ),\n         );\n@@ -78,7 +79,7 @@ pub fn inject(\n     let use_item = cx.item(\n         span,\n         Ident::empty(),\n-        vec![cx.attribute(cx.meta_word(span, sym::prelude_import))].into(),\n+        thin_vec![cx.attribute(cx.meta_word(span, sym::prelude_import))],\n         ast::ItemKind::Use(ast::UseTree {\n             prefix: cx.path(span, import_path),\n             kind: ast::UseTreeKind::Glob,"}, {"sha": "7efb6cc61eecbb2325525c4696b5b5b7c9040c8a", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,7 +1,6 @@\n /// The expansion from a test function to the appropriate test struct for libtest\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n use crate::util::{check_builtin_macro_attribute, warn_on_duplicate_attribute};\n-\n use rustc_ast as ast;\n use rustc_ast::attr;\n use rustc_ast::ptr::P;\n@@ -11,8 +10,8 @@ use rustc_expand::base::*;\n use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n-\n use std::iter;\n+use thin_vec::thin_vec;\n \n // #[test_case] is used by custom test authors to mark tests\n // When building for test, it needs to make the item public and gensym the name\n@@ -219,16 +218,15 @@ pub fn expand_test_or_bench(\n     let mut test_const = cx.item(\n         sp,\n         Ident::new(item.ident.name, sp),\n-        vec![\n+        thin_vec![\n             // #[cfg(test)]\n             cx.attribute(attr::mk_list_item(\n                 Ident::new(sym::cfg, attr_sp),\n                 vec![attr::mk_nested_word_item(Ident::new(sym::test, attr_sp))],\n             )),\n             // #[rustc_test_marker]\n             cx.attribute(cx.meta_word(attr_sp, sym::rustc_test_marker)),\n-        ]\n-        .into(),\n+        ],\n         // const $ident: test::TestDescAndFn =\n         ast::ItemKind::Const(\n             ast::Defaultness::Final,\n@@ -337,7 +335,7 @@ pub fn expand_test_or_bench(\n     // extern crate test\n     let test_extern = cx.item(sp, test_id, ast::AttrVec::new(), ast::ItemKind::ExternCrate(None));\n \n-    tracing::debug!(\"synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n+    debug!(\"synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n \n     if is_stmt {\n         vec!["}, {"sha": "561ca00c7197515f8a4672d0085a606f01599e79", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -14,7 +14,7 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::PanicStrategy;\n use smallvec::{smallvec, SmallVec};\n-use tracing::debug;\n+use thin_vec::thin_vec;\n \n use std::{iter, mem};\n \n@@ -187,7 +187,10 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n                     let dc_nested =\n                         attr::mk_nested_word_item(Ident::new(sym::dead_code, self.def_site));\n                     let allow_dead_code_item = attr::mk_list_item(allow_ident, vec![dc_nested]);\n-                    let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n+                    let allow_dead_code = attr::mk_attr_outer(\n+                        &self.sess.parse_sess.attr_id_generator,\n+                        allow_dead_code_item,\n+                    );\n                     let attrs = attrs\n                         .into_iter()\n                         .filter(|attr| {\n@@ -335,7 +338,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n \n     let main = P(ast::Item {\n         ident: main_id,\n-        attrs: vec![main_attr].into(),\n+        attrs: thin_vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         kind: main,\n         vis: ast::Visibility { span: sp, kind: ast::VisibilityKind::Public, tokens: None },"}, {"sha": "0497c2570e6228b3984b639805ebbdef0bd6d07b", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -342,7 +342,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n     let ret_place = codegen_place(fx, destination);\n \n-    // Handle special calls like instrinsics and empty drop glue.\n+    // Handle special calls like intrinsics and empty drop glue.\n     let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n         let instance = ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n             .unwrap()"}, {"sha": "11540d8008160324d74ad358c875fac72cfb1aea", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -701,6 +701,10 @@ fn codegen_stmt<'tcx>(\n                     let operand = codegen_operand(fx, operand);\n                     operand.unsize_value(fx, lval);\n                 }\n+                Rvalue::Cast(CastKind::DynStar, _, _) => {\n+                    // FIXME(dyn-star)\n+                    unimplemented!()\n+                }\n                 Rvalue::Discriminant(place) => {\n                     let place = codegen_place(fx, place);\n                     let value = place.to_cvalue(fx);\n@@ -794,20 +798,31 @@ fn codegen_stmt<'tcx>(\n         | StatementKind::AscribeUserType(..) => {}\n \n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),\n-        StatementKind::CopyNonOverlapping(inner) => {\n-            let dst = codegen_operand(fx, &inner.dst);\n-            let pointee = dst\n-                .layout()\n-                .pointee_info_at(fx, rustc_target::abi::Size::ZERO)\n-                .expect(\"Expected pointer\");\n-            let dst = dst.load_scalar(fx);\n-            let src = codegen_operand(fx, &inner.src).load_scalar(fx);\n-            let count = codegen_operand(fx, &inner.count).load_scalar(fx);\n-            let elem_size: u64 = pointee.size.bytes();\n-            let bytes =\n-                if elem_size != 1 { fx.bcx.ins().imul_imm(count, elem_size as i64) } else { count };\n-            fx.bcx.call_memcpy(fx.target_config, dst, src, bytes);\n-        }\n+        StatementKind::Intrinsic(ref intrinsic) => match &**intrinsic {\n+            // We ignore `assume` intrinsics, they are only useful for optimizations\n+            NonDivergingIntrinsic::Assume(_) => {}\n+            NonDivergingIntrinsic::CopyNonOverlapping(mir::CopyNonOverlapping {\n+                src,\n+                dst,\n+                count,\n+            }) => {\n+                let dst = codegen_operand(fx, dst);\n+                let pointee = dst\n+                    .layout()\n+                    .pointee_info_at(fx, rustc_target::abi::Size::ZERO)\n+                    .expect(\"Expected pointer\");\n+                let dst = dst.load_scalar(fx);\n+                let src = codegen_operand(fx, src).load_scalar(fx);\n+                let count = codegen_operand(fx, count).load_scalar(fx);\n+                let elem_size: u64 = pointee.size.bytes();\n+                let bytes = if elem_size != 1 {\n+                    fx.bcx.ins().imul_imm(count, elem_size as i64)\n+                } else {\n+                    count\n+                };\n+                fx.bcx.call_memcpy(fx.target_config, dst, src, bytes);\n+            }\n+        },\n     }\n }\n \n@@ -835,6 +850,7 @@ pub(crate) fn codegen_place<'tcx>(\n             PlaceElem::Deref => {\n                 cplace = cplace.place_deref(fx);\n             }\n+            PlaceElem::OpaqueCast(ty) => cplace = cplace.place_opaque_cast(fx, ty),\n             PlaceElem::Field(field, _ty) => {\n                 cplace = cplace.place_field(fx, field);\n             }"}, {"sha": "e12805b093cc7487f9e0774fdc531fe4be0c18a8", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 28, "deletions": 46, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -5,7 +5,6 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n     read_target_uint, AllocId, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n-use rustc_middle::ty::ConstKind;\n use rustc_span::DUMMY_SP;\n \n use cranelift_codegen::ir::GlobalValueData;\n@@ -41,36 +40,22 @@ impl ConstantCx {\n pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     let mut all_constants_ok = true;\n     for constant in &fx.mir.required_consts {\n-        let const_ = match fx.monomorphize(constant.literal) {\n-            ConstantKind::Ty(ct) => ct,\n+        let unevaluated = match fx.monomorphize(constant.literal) {\n+            ConstantKind::Ty(_) => unreachable!(),\n+            ConstantKind::Unevaluated(uv, _) => uv,\n             ConstantKind::Val(..) => continue,\n         };\n-        match const_.kind() {\n-            ConstKind::Value(_) => {}\n-            ConstKind::Unevaluated(unevaluated) => {\n-                if let Err(err) =\n-                    fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None)\n-                {\n-                    all_constants_ok = false;\n-                    match err {\n-                        ErrorHandled::Reported(_) | ErrorHandled::Linted => {\n-                            fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n-                        }\n-                        ErrorHandled::TooGeneric => {\n-                            span_bug!(\n-                                constant.span,\n-                                \"codgen encountered polymorphic constant: {:?}\",\n-                                err\n-                            );\n-                        }\n-                    }\n+\n+        if let Err(err) = fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None) {\n+            all_constants_ok = false;\n+            match err {\n+                ErrorHandled::Reported(_) | ErrorHandled::Linted => {\n+                    fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n+                }\n+                ErrorHandled::TooGeneric => {\n+                    span_bug!(constant.span, \"codegen encountered polymorphic constant: {:?}\", err);\n                 }\n             }\n-            ConstKind::Param(_)\n-            | ConstKind::Infer(_)\n-            | ConstKind::Bound(_, _)\n-            | ConstKind::Placeholder(_)\n-            | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n         }\n     }\n     all_constants_ok\n@@ -122,36 +107,28 @@ pub(crate) fn codegen_constant<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n-    let const_ = match fx.monomorphize(constant.literal) {\n-        ConstantKind::Ty(ct) => ct,\n-        ConstantKind::Val(val, ty) => return codegen_const_value(fx, val, ty),\n-    };\n-    let const_val = match const_.kind() {\n-        ConstKind::Value(valtree) => fx.tcx.valtree_to_const_val((const_.ty(), valtree)),\n-        ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n+    let (const_val, ty) = match fx.monomorphize(constant.literal) {\n+        ConstantKind::Ty(const_) => unreachable!(\"{:?}\", const_),\n+        ConstantKind::Unevaluated(mir::UnevaluatedConst { def, substs, promoted }, ty)\n             if fx.tcx.is_static(def.did) =>\n         {\n             assert!(substs.is_empty());\n             assert!(promoted.is_none());\n \n-            return codegen_static_ref(fx, def.did, fx.layout_of(const_.ty())).to_cvalue(fx);\n+            return codegen_static_ref(fx, def.did, fx.layout_of(ty)).to_cvalue(fx);\n         }\n-        ConstKind::Unevaluated(unevaluated) => {\n+        ConstantKind::Unevaluated(unevaluated, ty) => {\n             match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None) {\n-                Ok(const_val) => const_val,\n+                Ok(const_val) => (const_val, ty),\n                 Err(_) => {\n                     span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n                 }\n             }\n         }\n-        ConstKind::Param(_)\n-        | ConstKind::Infer(_)\n-        | ConstKind::Bound(_, _)\n-        | ConstKind::Placeholder(_)\n-        | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n+        ConstantKind::Val(val, ty) => (val, ty),\n     };\n \n-    codegen_const_value(fx, const_val, const_.ty())\n+    codegen_const_value(fx, const_val, ty)\n }\n \n pub(crate) fn codegen_const_value<'tcx>(\n@@ -496,6 +473,9 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                 .eval_for_mir(fx.tcx, ParamEnv::reveal_all())\n                 .try_to_value(fx.tcx),\n             ConstantKind::Val(val, _) => Some(val),\n+            ConstantKind::Unevaluated(uv, _) => {\n+                fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), uv, None).ok()\n+            }\n         },\n         // FIXME(rust-lang/rust#85105): Casts like `IMM8 as u32` result in the const being stored\n         // inside a temporary before being passed to the intrinsic requiring the const argument.\n@@ -536,9 +516,11 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                         {\n                             return None;\n                         }\n-                        StatementKind::CopyNonOverlapping(_) => {\n-                            return None;\n-                        } // conservative handling\n+                        StatementKind::Intrinsic(ref intrinsic) => match **intrinsic {\n+                            NonDivergingIntrinsic::CopyNonOverlapping(..) => return None,\n+                            NonDivergingIntrinsic::Assume(..) => {}\n+                        },\n+                        // conservative handling\n                         StatementKind::Assign(_)\n                         | StatementKind::FakeRead(_)\n                         | StatementKind::SetDiscriminant { .. }"}, {"sha": "463de6a91c74c62f620eaa69c715133b8707f3ad", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -68,9 +68,9 @@ impl DebugContext {\n     ) -> (Lrc<SourceFile>, u64, u64) {\n         // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n         // In order to have a good line stepping behavior in debugger, we overwrite debug\n-        // locations of macro expansions with that of the outermost expansion site\n-        // (unless the crate is being compiled with `-Z debug-macros`).\n-        let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n+        // locations of macro expansions with that of the outermost expansion site (when the macro is\n+        // annotated with `#[collapse_debuginfo]` or when `-Zdebug-macros` is provided).\n+        let span = if tcx.should_collapse_debuginfo(span) {\n             span\n         } else {\n             // Walk up the macro expansion chain until we reach a non-expanded span."}, {"sha": "97b395bcd05186b199e59026ddec9fda4472dc77", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -42,10 +42,10 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n         Variants::Multiple {\n             tag: _,\n             tag_field,\n-            tag_encoding: TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+            tag_encoding: TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n             variants: _,\n         } => {\n-            if variant_index != dataful_variant {\n+            if variant_index != untagged_variant {\n                 let niche = place.place_field(fx, mir::Field::new(tag_field));\n                 let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                 let niche_value = ty::ScalarInt::try_from_uint(\n@@ -113,7 +113,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             let res = CValue::by_val(val, dest_layout);\n             dest.write_cvalue(fx, res);\n         }\n-        TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+        TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n             // Rebase from niche values to discriminants, and check\n             // whether the result is in range for the niche variants.\n \n@@ -169,8 +169,9 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 fx.bcx.ins().iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n             };\n \n-            let dataful_variant = fx.bcx.ins().iconst(cast_to, i64::from(dataful_variant.as_u32()));\n-            let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n+            let untagged_variant =\n+                fx.bcx.ins().iconst(cast_to, i64::from(untagged_variant.as_u32()));\n+            let discr = fx.bcx.ins().select(is_niche, niche_discr, untagged_variant);\n             let res = CValue::by_val(discr, dest_layout);\n             dest.write_cvalue(fx, res);\n         }"}, {"sha": "2e4ca594f91bb1b63e775902e2ce9ffe2f772232", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -203,7 +203,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             sym::transmute => {\n                 crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", source_info);\n             }\n-            _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n+            _ => unimplemented!(\"unsupported intrinsic {}\", intrinsic),\n         }\n         return;\n     };\n@@ -357,9 +357,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n     let usize_layout = fx.layout_of(fx.tcx.types.usize);\n \n     match intrinsic {\n-        sym::assume => {\n-            intrinsic_args!(fx, args => (_a); intrinsic);\n-        }\n         sym::likely | sym::unlikely => {\n             intrinsic_args!(fx, args => (a); intrinsic);\n \n@@ -819,20 +816,13 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, val);\n         }\n \n-        sym::ptr_guaranteed_eq => {\n+        sym::ptr_guaranteed_cmp => {\n             intrinsic_args!(fx, args => (a, b); intrinsic);\n \n             let val = crate::num::codegen_ptr_binop(fx, BinOp::Eq, a, b);\n             ret.write_cvalue(fx, val);\n         }\n \n-        sym::ptr_guaranteed_ne => {\n-            intrinsic_args!(fx, args => (a, b); intrinsic);\n-\n-            let val = crate::num::codegen_ptr_binop(fx, BinOp::Ne, a, b);\n-            ret.write_cvalue(fx, val);\n-        }\n-\n         sym::caller_location => {\n             intrinsic_args!(fx, args => (); intrinsic);\n "}, {"sha": "3c024a84d9091f1fb3bf1533443d4ed5bed5a27d", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,7 +1,7 @@\n use rustc_hir::LangItem;\n use rustc_middle::ty::subst::GenericArg;\n use rustc_middle::ty::AssocKind;\n-use rustc_session::config::EntryFnType;\n+use rustc_session::config::{sigpipe, EntryFnType};\n use rustc_span::symbol::Ident;\n \n use crate::prelude::*;\n@@ -15,12 +15,12 @@ pub(crate) fn maybe_create_entry_wrapper(\n     is_jit: bool,\n     is_primary_cgu: bool,\n ) {\n-    let (main_def_id, is_main_fn) = match tcx.entry_fn(()) {\n+    let (main_def_id, (is_main_fn, sigpipe)) = match tcx.entry_fn(()) {\n         Some((def_id, entry_ty)) => (\n             def_id,\n             match entry_ty {\n-                EntryFnType::Main => true,\n-                EntryFnType::Start => false,\n+                EntryFnType::Main { sigpipe } => (true, sigpipe),\n+                EntryFnType::Start => (false, sigpipe::DEFAULT),\n             },\n         ),\n         None => return,\n@@ -35,7 +35,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n         return;\n     }\n \n-    create_entry_fn(tcx, module, unwind_context, main_def_id, is_jit, is_main_fn);\n+    create_entry_fn(tcx, module, unwind_context, main_def_id, is_jit, is_main_fn, sigpipe);\n \n     fn create_entry_fn(\n         tcx: TyCtxt<'_>,\n@@ -44,6 +44,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n         rust_main_def_id: DefId,\n         ignore_lang_start_wrapper: bool,\n         is_main_fn: bool,\n+        sigpipe: u8,\n     ) {\n         let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -83,6 +84,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n             bcx.switch_to_block(block);\n             let arg_argc = bcx.append_block_param(block, m.target_config().pointer_type());\n             let arg_argv = bcx.append_block_param(block, m.target_config().pointer_type());\n+            let arg_sigpipe = bcx.ins().iconst(types::I8, sigpipe as i64);\n \n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n@@ -143,7 +145,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 let main_val = bcx.ins().func_addr(m.target_config().pointer_type(), main_func_ref);\n \n                 let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n-                let call_inst = bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv]);\n+                let call_inst =\n+                    bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv, arg_sigpipe]);\n                 bcx.inst_results(call_inst)[0]\n             } else {\n                 // using user-defined start fn"}, {"sha": "3fa3e3657cb63ce13dc09f0edec5aed3e08e69ae", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -621,6 +621,14 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    pub(crate) fn place_opaque_cast(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> CPlace<'tcx> {\n+        CPlace { inner: self.inner, layout: fx.layout_of(ty) }\n+    }\n+\n     pub(crate) fn place_field(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,\n@@ -815,7 +823,8 @@ pub(crate) fn assert_assignable<'tcx>(\n             );\n             // fn(&T) -> for<'l> fn(&'l T) is allowed\n         }\n-        (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n+        (&ty::Dynamic(from_traits, _, _from_kind), &ty::Dynamic(to_traits, _, _to_kind)) => {\n+            // FIXME(dyn-star): Do the right thing with DynKinds\n             for (from, to) in from_traits.iter().zip(to_traits) {\n                 let from =\n                     fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);"}, {"sha": "aa1c271c31cb46d7695995756b2d09e69311bab4", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -158,10 +158,6 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         None\n     }\n \n-    fn zst_to_backend(&self, _ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.const_undef(self.type_ix(0))\n-    }\n-\n     fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, ty: Type<'gcc>) -> RValue<'gcc> {\n         let bitsize = if layout.is_bool() { 1 } else { layout.size(self).bits() };\n         match cv {"}, {"sha": "a068aa2ec6244e5bc1f93e880ac80f9016a0117b", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -11,7 +11,6 @@ doctest = false\n bitflags = \"1.0\"\n cstr = \"0.2\"\n libc = \"0.2\"\n-libloading = \"0.7.1\"\n measureme = \"10.0.0\"\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n tracing = \"0.1\""}, {"sha": "26f5225f6b445b820518fc74c26cada13e98308f", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -19,6 +19,7 @@ use rustc_target::abi::call::ArgAbi;\n pub use rustc_target::abi::call::*;\n use rustc_target::abi::{self, HasDataLayout, Int};\n pub use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::SanitizerSet;\n \n use libc::c_uint;\n use smallvec::SmallVec;\n@@ -90,6 +91,13 @@ fn get_attrs<'ll>(this: &ArgAttributes, cx: &CodegenCx<'ll, '_>) -> SmallVec<[&'\n         if regular.contains(ArgAttribute::NoAliasMutRef) && should_use_mutable_noalias(cx) {\n             attrs.push(llvm::AttributeKind::NoAlias.create_attr(cx.llcx));\n         }\n+    } else if cx.tcx.sess.opts.unstable_opts.sanitizer.contains(SanitizerSet::MEMORY) {\n+        // If we're not optimising, *but* memory sanitizer is on, emit noundef, since it affects\n+        // memory sanitizer's behavior.\n+\n+        if regular.contains(ArgAttribute::NoUndef) {\n+            attrs.push(llvm::AttributeKind::NoUndef.create_attr(cx.llcx));\n+        }\n     }\n \n     attrs"}, {"sha": "5202ac697e9496f4551bb265de5732ed542fed72", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -19,7 +19,6 @@ use rustc_target::asm::*;\n \n use libc::{c_char, c_uint};\n use smallvec::SmallVec;\n-use tracing::debug;\n \n impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n     fn codegen_inline_asm("}, {"sha": "eff2436d41cac65adbe930d1cd7a3e845ebafa65", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -35,6 +35,10 @@ pub fn apply_to_callsite(callsite: &Value, idx: AttributePlace, attrs: &[&Attrib\n /// Get LLVM attribute for the provided inline heuristic.\n #[inline]\n fn inline_attr<'ll>(cx: &CodegenCx<'ll, '_>, inline: InlineAttr) -> Option<&'ll Attribute> {\n+    if !cx.tcx.sess.opts.unstable_opts.inline_llvm {\n+        // disable LLVM inlining\n+        return Some(AttributeKind::NoInline.create_attr(cx.llcx));\n+    }\n     match inline {\n         InlineAttr::Hint => Some(AttributeKind::InlineHint.create_attr(cx.llcx)),\n         InlineAttr::Always => Some(AttributeKind::AlwaysInline.create_attr(cx.llcx)),\n@@ -386,7 +390,8 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n     ) {\n         let span = cx\n             .tcx\n-            .get_attr(instance.def_id(), sym::target_feature)\n+            .get_attrs(instance.def_id(), sym::target_feature)\n+            .next()\n             .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n         let msg = format!(\n             \"the target features {} must all be either enabled or disabled together\","}, {"sha": "38a366095b41da97c9fe8906b8ab626be71935e5", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -190,10 +190,10 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n \n             let output_path_z = rustc_fs_util::path_to_c_string(&output_path);\n \n-            tracing::trace!(\"invoking LLVMRustWriteImportLibrary\");\n-            tracing::trace!(\"  dll_name {:#?}\", dll_name_z);\n-            tracing::trace!(\"  output_path {}\", output_path.display());\n-            tracing::trace!(\n+            trace!(\"invoking LLVMRustWriteImportLibrary\");\n+            trace!(\"  dll_name {:#?}\", dll_name_z);\n+            trace!(\"  output_path {}\", output_path.display());\n+            trace!(\n                 \"  import names: {}\",\n                 dll_imports\n                     .iter()"}, {"sha": "2049422b79a304c523d933f85d2af47ad1e74e2b", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 6, "deletions": 61, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,8 +1,6 @@\n-use crate::back::write::{\n-    self, save_temp_bitcode, to_llvm_opt_settings, with_llvm_pmb, DiagnosticHandlers,\n-};\n-use crate::llvm::{self, build_string, False, True};\n-use crate::{llvm_util, LlvmCodegenBackend, ModuleLlvm};\n+use crate::back::write::{self, save_temp_bitcode, DiagnosticHandlers};\n+use crate::llvm::{self, build_string};\n+use crate::{LlvmCodegenBackend, ModuleLlvm};\n use object::read::archive::ArchiveFile;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n@@ -18,7 +16,6 @@ use rustc_middle::dep_graph::WorkProduct;\n use rustc_middle::middle::exported_symbols::{SymbolExportInfo, SymbolExportLevel};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{self, CrateType, Lto};\n-use tracing::{debug, info};\n \n use std::ffi::{CStr, CString};\n use std::fs::File;\n@@ -598,61 +595,9 @@ pub(crate) fn run_pass_manager(\n                 1,\n             );\n         }\n-        if llvm_util::should_use_new_llvm_pass_manager(\n-            &config.new_llvm_pass_manager,\n-            &cgcx.target_arch,\n-        ) {\n-            let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n-            let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n-            write::optimize_with_new_llvm_pass_manager(\n-                cgcx,\n-                diag_handler,\n-                module,\n-                config,\n-                opt_level,\n-                opt_stage,\n-            )?;\n-            debug!(\"lto done\");\n-            return Ok(());\n-        }\n-\n-        let pm = llvm::LLVMCreatePassManager();\n-        llvm::LLVMAddAnalysisPasses(module.module_llvm.tm, pm);\n-\n-        if config.verify_llvm_ir {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        let opt_level = config\n-            .opt_level\n-            .map(|x| to_llvm_opt_settings(x).0)\n-            .unwrap_or(llvm::CodeGenOptLevel::None);\n-        with_llvm_pmb(module.module_llvm.llmod(), config, opt_level, false, &mut |b| {\n-            if thin {\n-                llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm);\n-            } else {\n-                llvm::LLVMRustPassManagerBuilderPopulateLTOPassManager(\n-                    b, pm, /* Internalize = */ False, /* RunInliner = */ True,\n-                );\n-            }\n-        });\n-\n-        // We always generate bitcode through ThinLTOBuffers,\n-        // which do not support anonymous globals\n-        if config.bitcode_needed() {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"name-anon-globals\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        if config.verify_llvm_ir {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        llvm::LLVMRunPassManager(pm, module.module_llvm.llmod());\n-\n-        llvm::LLVMDisposePassManager(pm);\n+        let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n+        let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n+        write::llvm_optimize(cgcx, diag_handler, module, config, opt_level, opt_stage)?;\n     }\n     debug!(\"lto done\");\n     Ok(())"}, {"sha": "db526746fa70aeceb4cb61356a6c7be8890dc4f6", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 9, "deletions": 251, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -21,14 +21,12 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_errors::{FatalError, Handler, Level};\n use rustc_fs_util::{link_or_copy, path_to_c_string};\n-use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, Lto, OutputType, Passes, SplitDwarfKind, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n use rustc_target::spec::{CodeModel, RelocModel, SanitizerSet, SplitDebuginfo};\n-use tracing::debug;\n \n use libc::{c_char, c_int, c_uint, c_void, size_t};\n use std::ffi::CString;\n@@ -418,7 +416,7 @@ fn get_instr_profile_output_path(config: &ModuleConfig) -> Option<CString> {\n     }\n }\n \n-pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n+pub(crate) unsafe fn llvm_optimize(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n@@ -466,7 +464,7 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n     // FIXME: NewPM doesn't provide a facility to pass custom InlineParams.\n     // We would have to add upstream support for this first, before we can support\n     // config.inline_threshold and our more aggressive default thresholds.\n-    let result = llvm::LLVMRustOptimizeWithNewPassManager(\n+    let result = llvm::LLVMRustOptimize(\n         module.module_llvm.llmod(),\n         &*module.module_llvm.tm,\n         to_pass_builder_opt_level(opt_level),\n@@ -510,203 +508,29 @@ pub(crate) unsafe fn optimize(\n \n     let llmod = module.module_llvm.llmod();\n     let llcx = &*module.module_llvm.llcx;\n-    let tm = &*module.module_llvm.tm;\n     let _handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n     let module_name = module.name.clone();\n     let module_name = Some(&module_name[..]);\n \n-    if let Some(false) = config.new_llvm_pass_manager && llvm_util::get_version() >= (15, 0, 0) {\n-        diag_handler.warn(\n-            \"ignoring `-Z new-llvm-pass-manager=no`, which is no longer supported with LLVM 15\",\n-        );\n-    }\n-\n     if config.emit_no_opt_bc {\n         let out = cgcx.output_filenames.temp_path_ext(\"no-opt.bc\", module_name);\n         let out = path_to_c_string(&out);\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n     if let Some(opt_level) = config.opt_level {\n-        if llvm_util::should_use_new_llvm_pass_manager(\n-            &config.new_llvm_pass_manager,\n-            &cgcx.target_arch,\n-        ) {\n-            let opt_stage = match cgcx.lto {\n-                Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n-                Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n-                _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n-                _ => llvm::OptStage::PreLinkNoLTO,\n-            };\n-            return optimize_with_new_llvm_pass_manager(\n-                cgcx,\n-                diag_handler,\n-                module,\n-                config,\n-                opt_level,\n-                opt_stage,\n-            );\n-        }\n-\n-        if cgcx.prof.llvm_recording_enabled() {\n-            diag_handler\n-                .warn(\"`-Z self-profile-events = llvm` requires `-Z new-llvm-pass-manager`\");\n-        }\n-\n-        // Create the two optimizing pass managers. These mirror what clang\n-        // does, and are by populated by LLVM's default PassManagerBuilder.\n-        // Each manager has a different set of passes, but they also share\n-        // some common passes.\n-        let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n-        let mpm = llvm::LLVMCreatePassManager();\n-\n-        {\n-            let find_pass = |pass_name: &str| {\n-                let pass_name = SmallCStr::new(pass_name);\n-                llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr())\n-            };\n-\n-            if config.verify_llvm_ir {\n-                // Verification should run as the very first pass.\n-                llvm::LLVMRustAddPass(fpm, find_pass(\"verify\").unwrap());\n-            }\n-\n-            let mut extra_passes = Vec::new();\n-            let mut have_name_anon_globals_pass = false;\n-\n-            for pass_name in &config.passes {\n-                if pass_name == \"lint\" {\n-                    // Linting should also be performed early, directly on the generated IR.\n-                    llvm::LLVMRustAddPass(fpm, find_pass(\"lint\").unwrap());\n-                    continue;\n-                }\n-\n-                if let Some(pass) = find_pass(pass_name) {\n-                    extra_passes.push(pass);\n-                } else {\n-                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\", pass_name));\n-                }\n-\n-                if pass_name == \"name-anon-globals\" {\n-                    have_name_anon_globals_pass = true;\n-                }\n-            }\n-\n-            // Instrumentation must be inserted before optimization,\n-            // otherwise LLVM may optimize some functions away which\n-            // breaks llvm-cov.\n-            //\n-            // This mirrors what Clang does in lib/CodeGen/BackendUtil.cpp.\n-            if config.instrument_gcov {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"insert-gcov-profiling\").unwrap());\n-            }\n-            if config.instrument_coverage {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"instrprof\").unwrap());\n-            }\n-            if config.debug_info_for_profiling {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"add-discriminators\").unwrap());\n-            }\n-\n-            add_sanitizer_passes(config, &mut extra_passes);\n-\n-            // Some options cause LLVM bitcode to be emitted, which uses ThinLTOBuffers, so we need\n-            // to make sure we run LLVM's NameAnonGlobals pass when emitting bitcode; otherwise\n-            // we'll get errors in LLVM.\n-            let using_thin_buffers = config.bitcode_needed();\n-            if !config.no_prepopulate_passes {\n-                llvm::LLVMAddAnalysisPasses(tm, fpm);\n-                llvm::LLVMAddAnalysisPasses(tm, mpm);\n-                let opt_level = to_llvm_opt_settings(opt_level).0;\n-                let prepare_for_thin_lto = cgcx.lto == Lto::Thin\n-                    || cgcx.lto == Lto::ThinLocal\n-                    || (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n-                with_llvm_pmb(llmod, config, opt_level, prepare_for_thin_lto, &mut |b| {\n-                    llvm::LLVMRustAddLastExtensionPasses(\n-                        b,\n-                        extra_passes.as_ptr(),\n-                        extra_passes.len() as size_t,\n-                    );\n-                    llvm::LLVMRustPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n-                    llvm::LLVMRustPassManagerBuilderPopulateModulePassManager(b, mpm);\n-                });\n-\n-                have_name_anon_globals_pass = have_name_anon_globals_pass || prepare_for_thin_lto;\n-                if using_thin_buffers && !prepare_for_thin_lto {\n-                    llvm::LLVMRustAddPass(mpm, find_pass(\"name-anon-globals\").unwrap());\n-                    have_name_anon_globals_pass = true;\n-                }\n-            } else {\n-                // If we don't use the standard pipeline, directly populate the MPM\n-                // with the extra passes.\n-                for pass in extra_passes {\n-                    llvm::LLVMRustAddPass(mpm, pass);\n-                }\n-            }\n-\n-            if using_thin_buffers && !have_name_anon_globals_pass {\n-                // As described above, this will probably cause an error in LLVM\n-                if config.no_prepopulate_passes {\n-                    diag_handler.err(\n-                        \"The current compilation is going to use thin LTO buffers \\\n-                                      without running LLVM's NameAnonGlobals pass. \\\n-                                      This will likely cause errors in LLVM. Consider adding \\\n-                                      -C passes=name-anon-globals to the compiler command line.\",\n-                    );\n-                } else {\n-                    bug!(\n-                        \"We are using thin LTO buffers without running the NameAnonGlobals pass. \\\n-                          This will likely cause errors in LLVM and should never happen.\"\n-                    );\n-                }\n-            }\n-        }\n-\n-        diag_handler.abort_if_errors();\n-\n-        // Finally, run the actual optimization passes\n-        {\n-            let _timer = cgcx.prof.extra_verbose_generic_activity(\n-                \"LLVM_module_optimize_function_passes\",\n-                &*module.name,\n-            );\n-            llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n-        }\n-        {\n-            let _timer = cgcx.prof.extra_verbose_generic_activity(\n-                \"LLVM_module_optimize_module_passes\",\n-                &*module.name,\n-            );\n-            llvm::LLVMRunPassManager(mpm, llmod);\n-        }\n-\n-        // Deallocate managers that we're now done with\n-        llvm::LLVMDisposePassManager(fpm);\n-        llvm::LLVMDisposePassManager(mpm);\n+        let opt_stage = match cgcx.lto {\n+            Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n+            Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n+            _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n+            _ => llvm::OptStage::PreLinkNoLTO,\n+        };\n+        return llvm_optimize(cgcx, diag_handler, module, config, opt_level, opt_stage);\n     }\n     Ok(())\n }\n \n-unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static mut llvm::Pass>) {\n-    if config.sanitizer.contains(SanitizerSet::ADDRESS) {\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::ADDRESS);\n-        passes.push(llvm::LLVMRustCreateAddressSanitizerFunctionPass(recover));\n-        passes.push(llvm::LLVMRustCreateModuleAddressSanitizerPass(recover));\n-    }\n-    if config.sanitizer.contains(SanitizerSet::MEMORY) {\n-        let track_origins = config.sanitizer_memory_track_origins as c_int;\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::MEMORY);\n-        passes.push(llvm::LLVMRustCreateMemorySanitizerPass(track_origins, recover));\n-    }\n-    if config.sanitizer.contains(SanitizerSet::THREAD) {\n-        passes.push(llvm::LLVMRustCreateThreadSanitizerPass());\n-    }\n-    if config.sanitizer.contains(SanitizerSet::HWADDRESS) {\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::HWADDRESS);\n-        passes.push(llvm::LLVMRustCreateHWAddressSanitizerPass(recover));\n-    }\n-}\n-\n pub(crate) fn link(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n@@ -1073,72 +897,6 @@ unsafe fn embed_bitcode(\n     }\n }\n \n-pub unsafe fn with_llvm_pmb(\n-    llmod: &llvm::Module,\n-    config: &ModuleConfig,\n-    opt_level: llvm::CodeGenOptLevel,\n-    prepare_for_thin_lto: bool,\n-    f: &mut dyn FnMut(&llvm::PassManagerBuilder),\n-) {\n-    use std::ptr;\n-\n-    // Create the PassManagerBuilder for LLVM. We configure it with\n-    // reasonable defaults and prepare it to actually populate the pass\n-    // manager.\n-    let builder = llvm::LLVMRustPassManagerBuilderCreate();\n-    let opt_size = config.opt_size.map_or(llvm::CodeGenOptSizeNone, |x| to_llvm_opt_settings(x).1);\n-    let inline_threshold = config.inline_threshold;\n-    let pgo_gen_path = get_pgo_gen_path(config);\n-    let pgo_use_path = get_pgo_use_path(config);\n-    let pgo_sample_use_path = get_pgo_sample_use_path(config);\n-\n-    llvm::LLVMRustConfigurePassManagerBuilder(\n-        builder,\n-        opt_level,\n-        config.merge_functions,\n-        config.vectorize_slp,\n-        config.vectorize_loop,\n-        prepare_for_thin_lto,\n-        pgo_gen_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        pgo_use_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        pgo_sample_use_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        opt_size as c_int,\n-    );\n-\n-    llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, config.no_builtins);\n-\n-    // Here we match what clang does (kinda). For O0 we only inline\n-    // always-inline functions (but don't add lifetime intrinsics), at O1 we\n-    // inline with lifetime intrinsics, and O2+ we add an inliner with a\n-    // thresholds copied from clang.\n-    match (opt_level, opt_size, inline_threshold) {\n-        (.., Some(t)) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, t);\n-        }\n-        (llvm::CodeGenOptLevel::Aggressive, ..) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 275);\n-        }\n-        (_, llvm::CodeGenOptSizeDefault, _) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 75);\n-        }\n-        (_, llvm::CodeGenOptSizeAggressive, _) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 25);\n-        }\n-        (llvm::CodeGenOptLevel::None, ..) => {\n-            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n-        }\n-        (llvm::CodeGenOptLevel::Less, ..) => {\n-            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n-        }\n-        (llvm::CodeGenOptLevel::Default, ..) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n-        }\n-    }\n-\n-    f(builder);\n-    llvm::LLVMRustPassManagerBuilderDispose(builder);\n-}\n-\n // Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n // This is required to satisfy `dllimport` references to static data in .rlibs\n // when using MSVC linker.  We do this only for data, as linker can fix up"}, {"sha": "59b1c7fb5dbd040feb5405184e4cd7dd49d8802d", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,14 +1,13 @@\n use crate::attributes;\n use crate::common::Funclet;\n use crate::context::CodegenCx;\n-use crate::llvm::{self, BasicBlock, False};\n-use crate::llvm::{AtomicOrdering, AtomicRmwBinOp, SynchronizationScope};\n+use crate::llvm::{self, AtomicOrdering, AtomicRmwBinOp, BasicBlock};\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n use cstr::cstr;\n use libc::{c_char, c_uint};\n-use rustc_codegen_ssa::common::{IntPredicate, RealPredicate, TypeKind};\n+use rustc_codegen_ssa::common::{IntPredicate, RealPredicate, SynchronizationScope, TypeKind};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n@@ -27,7 +26,6 @@ use std::ffi::CStr;\n use std::iter;\n use std::ops::Deref;\n use std::ptr;\n-use tracing::{debug, instrument};\n \n // All Builders must have an llfn associated with them\n #[must_use]\n@@ -1043,15 +1041,17 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     ) -> &'ll Value {\n         let weak = if weak { llvm::True } else { llvm::False };\n         unsafe {\n-            llvm::LLVMRustBuildAtomicCmpXchg(\n+            let value = llvm::LLVMBuildAtomicCmpXchg(\n                 self.llbuilder,\n                 dst,\n                 cmp,\n                 src,\n                 AtomicOrdering::from_generic(order),\n                 AtomicOrdering::from_generic(failure_order),\n-                weak,\n-            )\n+                llvm::False, // SingleThreaded\n+            );\n+            llvm::LLVMSetWeak(value, weak);\n+            value\n         }\n     }\n     fn atomic_rmw(\n@@ -1068,21 +1068,26 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 dst,\n                 src,\n                 AtomicOrdering::from_generic(order),\n-                False,\n+                llvm::False, // SingleThreaded\n             )\n         }\n     }\n \n     fn atomic_fence(\n         &mut self,\n         order: rustc_codegen_ssa::common::AtomicOrdering,\n-        scope: rustc_codegen_ssa::common::SynchronizationScope,\n+        scope: SynchronizationScope,\n     ) {\n+        let single_threaded = match scope {\n+            SynchronizationScope::SingleThread => llvm::True,\n+            SynchronizationScope::CrossThread => llvm::False,\n+        };\n         unsafe {\n-            llvm::LLVMRustBuildAtomicFence(\n+            llvm::LLVMBuildFence(\n                 self.llbuilder,\n                 AtomicOrdering::from_generic(order),\n-                SynchronizationScope::from_generic(scope),\n+                single_threaded,\n+                UNNAMED,\n             );\n         }\n     }"}, {"sha": "b83c1e8f08f3182ee2178faa1a03b98862d3985c", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -11,7 +11,6 @@ use crate::context::CodegenCx;\n use crate::llvm;\n use crate::value::Value;\n use rustc_codegen_ssa::traits::*;\n-use tracing::debug;\n \n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n use rustc_middle::ty::{self, Instance, TypeVisitable};"}, {"sha": "acee9134fb96e48a26c3d4eb7a465c8d66ac6bf9", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -21,7 +21,6 @@ use rustc_target::spec::Target;\n \n use libc::{c_char, c_uint};\n use std::fmt::Write;\n-use tracing::debug;\n \n /*\n * A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n@@ -216,7 +215,11 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn const_to_opt_uint(&self, v: &'ll Value) -> Option<u64> {\n-        try_as_const_integral(v).map(|v| unsafe { llvm::LLVMConstIntGetZExtValue(v) })\n+        try_as_const_integral(v).and_then(|v| unsafe {\n+            let mut i = 0u64;\n+            let success = llvm::LLVMRustConstIntGetZExtValue(v, &mut i);\n+            success.then_some(i)\n+        })\n     }\n \n     fn const_to_opt_u128(&self, v: &'ll Value, sign_ext: bool) -> Option<u128> {\n@@ -227,10 +230,6 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         })\n     }\n \n-    fn zst_to_backend(&self, _llty: &'ll Type) -> &'ll Value {\n-        self.const_undef(self.type_ix(0))\n-    }\n-\n     fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, llty: &'ll Type) -> &'ll Value {\n         let bitsize = if layout.is_bool() { 1 } else { layout.size(self).bits() };\n         match cv {"}, {"sha": "a559f7f3d57035a58da56542d948fdad98a9274a", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -23,7 +23,6 @@ use rustc_target::abi::{\n     AddressSpace, Align, HasDataLayout, Primitive, Scalar, Size, WrappingRange,\n };\n use std::ops::Range;\n-use tracing::debug;\n \n pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<'_>) -> &'ll Value {\n     let alloc = alloc.inner();"}, {"sha": "0d1df6fb1acd99e437c9fbcf3d4bc59b984b4578", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -16,8 +16,6 @@ use rustc_middle::ty::TyCtxt;\n \n use std::ffi::CString;\n \n-use tracing::debug;\n-\n /// Generates and exports the Coverage Map.\n ///\n /// Rust Coverage Map generation supports LLVM Coverage Mapping Format versions"}, {"sha": "964a632b6eeddc77a68711eed82bc4eef8c20e73", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -28,7 +28,6 @@ use std::cell::RefCell;\n use std::ffi::CString;\n \n use std::iter;\n-use tracing::debug;\n \n pub mod mapgen;\n "}, {"sha": "163ccd9460c54b58c9f1326fd3d186ae60496d9f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -42,7 +42,6 @@ use rustc_span::{self, FileNameDisplayPreference, SourceFile};\n use rustc_symbol_mangling::typeid_for_trait_ref;\n use rustc_target::abi::{Align, Size};\n use smallvec::smallvec;\n-use tracing::debug;\n \n use libc::{c_char, c_longlong, c_uint};\n use std::borrow::Cow;\n@@ -51,7 +50,6 @@ use std::hash::{Hash, Hasher};\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::ptr;\n-use tracing::instrument;\n \n impl PartialEq for llvm::Metadata {\n     fn eq(&self, other: &Self) -> bool {"}, {"sha": "129e336c7e431c58dd68b2280188bce1ee199cfa", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -99,7 +99,7 @@ const SINGLE_VARIANT_VIRTUAL_DISR: u64 = 0;\n /// compiler versions.\n ///\n /// Niche-tag enums have one special variant, usually called the\n-/// \"dataful variant\". This variant has a field that\n+/// \"untagged variant\". This variant has a field that\n /// doubles as the tag of the enum. The variant is active when the value of\n /// that field is within a pre-defined range. Therefore the variant struct\n /// has a `DISCR_BEGIN` and `DISCR_END` field instead of `DISCR_EXACT` in\n@@ -249,7 +249,7 @@ pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n                     None,\n                 ),\n                 Variants::Multiple {\n-                    tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n+                    tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n                     ref variants,\n                     tag_field,\n                     ..\n@@ -260,7 +260,7 @@ pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n                     enum_type_di_node,\n                     variants.indices(),\n                     tag_field,\n-                    Some(dataful_variant),\n+                    Some(untagged_variant),\n                 ),\n             }\n         },\n@@ -391,7 +391,7 @@ fn build_union_fields_for_enum<'ll, 'tcx>(\n     enum_type_di_node: &'ll DIType,\n     variant_indices: impl Iterator<Item = VariantIdx> + Clone,\n     tag_field: usize,\n-    dataful_variant_index: Option<VariantIdx>,\n+    untagged_variant_index: Option<VariantIdx>,\n ) -> SmallVec<&'ll DIType> {\n     let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n \n@@ -436,7 +436,7 @@ fn build_union_fields_for_enum<'ll, 'tcx>(\n         variant_names_type_di_node,\n         tag_base_type,\n         tag_field,\n-        dataful_variant_index,\n+        untagged_variant_index,\n     )\n }\n \n@@ -472,7 +472,7 @@ fn build_variant_struct_wrapper_type_di_node<'ll, 'tcx>(\n     enum_or_generator_type_and_layout: TyAndLayout<'tcx>,\n     enum_or_generator_type_di_node: &'ll DIType,\n     variant_index: VariantIdx,\n-    dataful_variant_index: Option<VariantIdx>,\n+    untagged_variant_index: Option<VariantIdx>,\n     variant_struct_type_di_node: &'ll DIType,\n     variant_names_type_di_node: &'ll DIType,\n     tag_base_type_di_node: &'ll DIType,\n@@ -517,7 +517,7 @@ fn build_variant_struct_wrapper_type_di_node<'ll, 'tcx>(\n                     }\n                 }\n                 DiscrResult::Range(min, max) => {\n-                    assert_eq!(Some(variant_index), dataful_variant_index);\n+                    assert_eq!(Some(variant_index), untagged_variant_index);\n                     if is_128_bits {\n                         DiscrKind::Range128(min, max)\n                     } else {\n@@ -757,7 +757,7 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n     discr_type_di_node: &'ll DIType,\n     tag_base_type: Ty<'tcx>,\n     tag_field: usize,\n-    dataful_variant_index: Option<VariantIdx>,\n+    untagged_variant_index: Option<VariantIdx>,\n ) -> SmallVec<&'ll DIType> {\n     let tag_base_type_di_node = type_di_node(cx, tag_base_type);\n     let mut unions_fields = SmallVec::with_capacity(variant_field_infos.len() + 1);\n@@ -776,7 +776,7 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n             enum_type_and_layout,\n             enum_type_di_node,\n             variant_member_info.variant_index,\n-            dataful_variant_index,\n+            untagged_variant_index,\n             variant_member_info.variant_struct_type_di_node,\n             discr_type_di_node,\n             tag_base_type_di_node,"}, {"sha": "14044d0f99b987609ff17331b3ee50d4f2b83605", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -417,7 +417,7 @@ impl DiscrResult {\n /// Returns the discriminant value corresponding to the variant index.\n ///\n /// Will return `None` if there is less than two variants (because then the enum won't have)\n-/// a tag, and if this is the dataful variant of a niche-layout enum (because then there is no\n+/// a tag, and if this is the untagged variant of a niche-layout enum (because then there is no\n /// single discriminant value).\n fn compute_discriminant_value<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n@@ -430,11 +430,11 @@ fn compute_discriminant_value<'ll, 'tcx>(\n             enum_type_and_layout.ty.discriminant_for_variant(cx.tcx, variant_index).unwrap().val,\n         ),\n         &Variants::Multiple {\n-            tag_encoding: TagEncoding::Niche { ref niche_variants, niche_start, dataful_variant },\n+            tag_encoding: TagEncoding::Niche { ref niche_variants, niche_start, untagged_variant },\n             tag,\n             ..\n         } => {\n-            if variant_index == dataful_variant {\n+            if variant_index == untagged_variant {\n                 let valid_range = enum_type_and_layout\n                     .for_variant(cx, variant_index)\n                     .largest_niche"}, {"sha": "becbccc434d9ac33ee30091225aa0b87278986b7", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -378,7 +378,7 @@ fn build_discr_member_di_node<'ll, 'tcx>(\n ///\n /// The DW_AT_discr_value is optional, and is omitted if\n ///   - This is the only variant of a univariant enum (i.e. their is no discriminant)\n-///   - This is the \"dataful\" variant of a niche-layout enum\n+///   - This is the \"untagged\" variant of a niche-layout enum\n ///     (where only the other variants are identified by a single value)\n ///\n /// There is only ever a single member, the type of which is a struct that describes the"}, {"sha": "b23fe3fc9d5575ae8971c6dbb4b61cd1905512aa", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -39,7 +39,6 @@ use smallvec::SmallVec;\n use std::cell::OnceCell;\n use std::cell::RefCell;\n use std::iter;\n-use tracing::debug;\n \n mod create_scope_map;\n pub mod gdb;"}, {"sha": "a40cfc8b23fb32217f5b6b0897bea0e4f9e27373", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -6,7 +6,7 @@ use super::CodegenUnitDebugContext;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::{HasParamEnv, LayoutOf};\n use rustc_middle::ty::{self, DefIdTree, Ty};\n-use tracing::trace;\n+use trace;\n \n use crate::common::CodegenCx;\n use crate::llvm;"}, {"sha": "0f663a26732bba8abf5094a095a859784f6f9012", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -22,7 +22,6 @@ use rustc_codegen_ssa::traits::TypeMembershipMethods;\n use rustc_middle::ty::Ty;\n use rustc_symbol_mangling::typeid::typeid_for_fnabi;\n use smallvec::SmallVec;\n-use tracing::debug;\n \n /// Declare a function.\n ///"}, {"sha": "a640de42a6a86a3df51a5e5c3f48f7ae56acad91", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1705,6 +1705,97 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     bitwise_red!(simd_reduce_all: vector_reduce_and, true);\n     bitwise_red!(simd_reduce_any: vector_reduce_or, true);\n \n+    if name == sym::simd_cast_ptr {\n+        require_simd!(ret_ty, \"return\");\n+        let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == out_len,\n+            \"expected return type with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\",\n+            in_len,\n+            in_ty,\n+            ret_ty,\n+            out_len\n+        );\n+\n+        match in_elem.kind() {\n+            ty::RawPtr(p) => {\n+                let (metadata, check_sized) = p.ty.ptr_metadata_ty(bx.tcx, |ty| {\n+                    bx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), ty)\n+                });\n+                assert!(!check_sized); // we are in codegen, so we shouldn't see these types\n+                require!(metadata.is_unit(), \"cannot cast fat pointer `{}`\", in_elem)\n+            }\n+            _ => return_error!(\"expected pointer, got `{}`\", in_elem),\n+        }\n+        match out_elem.kind() {\n+            ty::RawPtr(p) => {\n+                let (metadata, check_sized) = p.ty.ptr_metadata_ty(bx.tcx, |ty| {\n+                    bx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), ty)\n+                });\n+                assert!(!check_sized); // we are in codegen, so we shouldn't see these types\n+                require!(metadata.is_unit(), \"cannot cast to fat pointer `{}`\", out_elem)\n+            }\n+            _ => return_error!(\"expected pointer, got `{}`\", out_elem),\n+        }\n+\n+        if in_elem == out_elem {\n+            return Ok(args[0].immediate());\n+        } else {\n+            return Ok(bx.pointercast(args[0].immediate(), llret_ty));\n+        }\n+    }\n+\n+    if name == sym::simd_expose_addr {\n+        require_simd!(ret_ty, \"return\");\n+        let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == out_len,\n+            \"expected return type with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\",\n+            in_len,\n+            in_ty,\n+            ret_ty,\n+            out_len\n+        );\n+\n+        match in_elem.kind() {\n+            ty::RawPtr(_) => {}\n+            _ => return_error!(\"expected pointer, got `{}`\", in_elem),\n+        }\n+        match out_elem.kind() {\n+            ty::Uint(ty::UintTy::Usize) => {}\n+            _ => return_error!(\"expected `usize`, got `{}`\", out_elem),\n+        }\n+\n+        return Ok(bx.ptrtoint(args[0].immediate(), llret_ty));\n+    }\n+\n+    if name == sym::simd_from_exposed_addr {\n+        require_simd!(ret_ty, \"return\");\n+        let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == out_len,\n+            \"expected return type with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\",\n+            in_len,\n+            in_ty,\n+            ret_ty,\n+            out_len\n+        );\n+\n+        match in_elem.kind() {\n+            ty::Uint(ty::UintTy::Usize) => {}\n+            _ => return_error!(\"expected `usize`, got `{}`\", in_elem),\n+        }\n+        match out_elem.kind() {\n+            ty::RawPtr(_) => {}\n+            _ => return_error!(\"expected pointer, got `{}`\", out_elem),\n+        }\n+\n+        return Ok(bx.inttoptr(args[0].immediate(), llret_ty));\n+    }\n+\n     if name == sym::simd_cast || name == sym::simd_as {\n         require_simd!(ret_ty, \"return\");\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());"}, {"sha": "15bfa8430460fb338e0fbbc6f6bbe4759ca68ef6", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -7,7 +7,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(hash_raw_entry)]\n #![feature(let_chains)]\n-#![feature(let_else)]\n #![feature(extern_types)]\n #![feature(once_cell)]\n #![feature(iter_intersperse)]\n@@ -16,6 +15,8 @@\n \n #[macro_use]\n extern crate rustc_macros;\n+#[macro_use]\n+extern crate tracing;\n \n use back::write::{create_informational_target_machine, create_target_machine};\n "}, {"sha": "42cb694c0e75a1b4cc382482bfee138a550b2a30", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 12, "deletions": 100, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -400,27 +400,6 @@ impl AtomicOrdering {\n     }\n }\n \n-/// LLVMRustSynchronizationScope\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum SynchronizationScope {\n-    SingleThread,\n-    CrossThread,\n-}\n-\n-impl SynchronizationScope {\n-    pub fn from_generic(sc: rustc_codegen_ssa::common::SynchronizationScope) -> Self {\n-        match sc {\n-            rustc_codegen_ssa::common::SynchronizationScope::SingleThread => {\n-                SynchronizationScope::SingleThread\n-            }\n-            rustc_codegen_ssa::common::SynchronizationScope::CrossThread => {\n-                SynchronizationScope::CrossThread\n-            }\n-        }\n-    }\n-}\n-\n /// LLVMRustFileType\n #[derive(Copy, Clone)]\n #[repr(C)]\n@@ -1096,7 +1075,7 @@ extern \"C\" {\n     pub fn LLVMConstInt(IntTy: &Type, N: c_ulonglong, SignExtend: Bool) -> &Value;\n     pub fn LLVMConstIntOfArbitraryPrecision(IntTy: &Type, Wn: c_uint, Ws: *const u64) -> &Value;\n     pub fn LLVMConstReal(RealTy: &Type, N: f64) -> &Value;\n-    pub fn LLVMConstIntGetZExtValue(ConstantVal: &ConstantInt) -> c_ulonglong;\n+    pub fn LLVMRustConstIntGetZExtValue(ConstantVal: &ConstantInt, Value: &mut u64) -> bool;\n     pub fn LLVMRustConstInt128Get(\n         ConstantVal: &ConstantInt,\n         SExt: bool,\n@@ -1782,16 +1761,18 @@ extern \"C\" {\n         Order: AtomicOrdering,\n     ) -> &'a Value;\n \n-    pub fn LLVMRustBuildAtomicCmpXchg<'a>(\n+    pub fn LLVMBuildAtomicCmpXchg<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         CMP: &'a Value,\n         RHS: &'a Value,\n         Order: AtomicOrdering,\n         FailureOrder: AtomicOrdering,\n-        Weak: Bool,\n+        SingleThreaded: Bool,\n     ) -> &'a Value;\n \n+    pub fn LLVMSetWeak(CmpXchgInst: &Value, IsWeak: Bool);\n+\n     pub fn LLVMBuildAtomicRMW<'a>(\n         B: &Builder<'a>,\n         Op: AtomicRmwBinOp,\n@@ -1801,27 +1782,19 @@ extern \"C\" {\n         SingleThreaded: Bool,\n     ) -> &'a Value;\n \n-    pub fn LLVMRustBuildAtomicFence(\n-        B: &Builder<'_>,\n+    pub fn LLVMBuildFence<'a>(\n+        B: &Builder<'a>,\n         Order: AtomicOrdering,\n-        Scope: SynchronizationScope,\n-    );\n+        SingleThreaded: Bool,\n+        Name: *const c_char,\n+    ) -> &'a Value;\n \n     /// Writes a module to the specified path. Returns 0 on success.\n     pub fn LLVMWriteBitcodeToFile(M: &Module, Path: *const c_char) -> c_int;\n \n-    /// Creates a pass manager.\n+    /// Creates a legacy pass manager -- only used for final codegen.\n     pub fn LLVMCreatePassManager<'a>() -> &'a mut PassManager<'a>;\n \n-    /// Creates a function-by-function pass manager\n-    pub fn LLVMCreateFunctionPassManagerForModule(M: &Module) -> &mut PassManager<'_>;\n-\n-    /// Disposes a pass manager.\n-    pub fn LLVMDisposePassManager<'a>(PM: &'a mut PassManager<'a>);\n-\n-    /// Runs a pass manager on a module.\n-    pub fn LLVMRunPassManager<'a>(PM: &PassManager<'a>, M: &'a Module) -> Bool;\n-\n     pub fn LLVMInitializePasses();\n \n     pub fn LLVMTimeTraceProfilerInitialize();\n@@ -1832,32 +1805,6 @@ extern \"C\" {\n \n     pub fn LLVMAddAnalysisPasses<'a>(T: &'a TargetMachine, PM: &PassManager<'a>);\n \n-    pub fn LLVMRustPassManagerBuilderCreate() -> &'static mut PassManagerBuilder;\n-    pub fn LLVMRustPassManagerBuilderDispose(PMB: &'static mut PassManagerBuilder);\n-    pub fn LLVMRustPassManagerBuilderUseInlinerWithThreshold(\n-        PMB: &PassManagerBuilder,\n-        threshold: c_uint,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateModulePassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-\n-    pub fn LLVMRustPassManagerBuilderPopulateFunctionPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateLTOPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-        Internalize: Bool,\n-        RunInliner: Bool,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-\n     pub fn LLVMGetHostCPUFeatures() -> *mut c_char;\n \n     pub fn LLVMDisposeMessage(message: *mut c_char);\n@@ -2262,22 +2209,6 @@ extern \"C\" {\n \n     pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&ConstantInt>;\n \n-    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;\n-    pub fn LLVMRustCreateAddressSanitizerFunctionPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustCreateModuleAddressSanitizerPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustCreateMemorySanitizerPass(\n-        TrackOrigins: c_int,\n-        Recover: bool,\n-    ) -> &'static mut Pass;\n-    pub fn LLVMRustCreateThreadSanitizerPass() -> &'static mut Pass;\n-    pub fn LLVMRustCreateHWAddressSanitizerPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustAddPass(PM: &PassManager<'_>, Pass: &'static mut Pass);\n-    pub fn LLVMRustAddLastExtensionPasses(\n-        PMB: &PassManagerBuilder,\n-        Passes: *const &'static mut Pass,\n-        NumPasses: size_t,\n-    );\n-\n     pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n \n     pub fn LLVMRustPrintTargetCPUs(T: &TargetMachine);\n@@ -2311,29 +2242,11 @@ extern \"C\" {\n         SplitDwarfFile: *const c_char,\n     ) -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n-    pub fn LLVMRustAddBuilderLibraryInfo<'a>(\n-        PMB: &'a PassManagerBuilder,\n-        M: &'a Module,\n-        DisableSimplifyLibCalls: bool,\n-    );\n-    pub fn LLVMRustConfigurePassManagerBuilder(\n-        PMB: &PassManagerBuilder,\n-        OptLevel: CodeGenOptLevel,\n-        MergeFunctions: bool,\n-        SLPVectorize: bool,\n-        LoopVectorize: bool,\n-        PrepareForThinLTO: bool,\n-        PGOGenPath: *const c_char,\n-        PGOUsePath: *const c_char,\n-        PGOSampleUsePath: *const c_char,\n-        SizeLevel: c_int,\n-    );\n     pub fn LLVMRustAddLibraryInfo<'a>(\n         PM: &PassManager<'a>,\n         M: &'a Module,\n         DisableSimplifyLibCalls: bool,\n     );\n-    pub fn LLVMRustRunFunctionPassManager<'a>(PM: &PassManager<'a>, M: &'a Module);\n     pub fn LLVMRustWriteOutputFile<'a>(\n         T: &'a TargetMachine,\n         PM: &PassManager<'a>,\n@@ -2342,7 +2255,7 @@ extern \"C\" {\n         DwoOutput: *const c_char,\n         FileType: FileType,\n     ) -> LLVMRustResult;\n-    pub fn LLVMRustOptimizeWithNewPassManager<'a>(\n+    pub fn LLVMRustOptimize<'a>(\n         M: &'a Module,\n         TM: &'a TargetMachine,\n         OptLevel: PassBuilderOptLevel,\n@@ -2380,7 +2293,6 @@ extern \"C\" {\n     pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n     pub fn LLVMRustPrintPasses();\n     pub fn LLVMRustSetNormalizedTarget(M: &Module, triple: *const c_char);\n-    pub fn LLVMRustAddAlwaysInlinePass(P: &PassManagerBuilder, AddLifetimes: bool);\n     pub fn LLVMRustRunRestrictionPass(M: &Module, syms: *const *const c_char, len: size_t);\n \n     pub fn LLVMRustOpenArchive(path: *const c_char) -> Option<&'static mut Archive>;"}, {"sha": "2fd58567c487406d6864849027ddd03ca44ccf07", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,7 +1,6 @@\n use crate::back::write::create_informational_target_machine;\n-use crate::{llvm, llvm_util};\n+use crate::llvm;\n use libc::c_int;\n-use libloading::Library;\n use rustc_codegen_ssa::target_features::{\n     supported_target_features, tied_target_features, RUSTC_SPECIFIC_FEATURES,\n };\n@@ -15,9 +14,7 @@ use rustc_span::symbol::Symbol;\n use rustc_target::spec::{MergeFunctions, PanicStrategy};\n use smallvec::{smallvec, SmallVec};\n use std::ffi::{CStr, CString};\n-use tracing::debug;\n \n-use std::mem;\n use std::path::Path;\n use std::ptr;\n use std::slice;\n@@ -121,22 +118,6 @@ unsafe fn configure_llvm(sess: &Session) {\n \n     llvm::LLVMInitializePasses();\n \n-    // Use the legacy plugin registration if we don't use the new pass manager\n-    if !should_use_new_llvm_pass_manager(\n-        &sess.opts.unstable_opts.new_llvm_pass_manager,\n-        &sess.target.arch,\n-    ) {\n-        // Register LLVM plugins by loading them into the compiler process.\n-        for plugin in &sess.opts.unstable_opts.llvm_plugins {\n-            let lib = Library::new(plugin).unwrap_or_else(|e| bug!(\"couldn't load plugin: {}\", e));\n-            debug!(\"LLVM plugin loaded successfully {:?} ({})\", lib, plugin);\n-\n-            // Intentionally leak the dynamic library. We can't ever unload it\n-            // since the library can make things that will live arbitrarily long.\n-            mem::forget(lib);\n-        }\n-    }\n-\n     rustc_llvm::initialize_available_targets();\n \n     llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int, llvm_args.as_ptr());\n@@ -155,6 +136,10 @@ pub fn time_trace_profiler_finish(file_name: &Path) {\n //\n // To find a list of LLVM's names, check llvm-project/llvm/include/llvm/Support/*TargetParser.def\n // where the * matches the architecture's name\n+//\n+// For targets not present in the above location, see llvm-project/llvm/lib/Target/{ARCH}/*.td\n+// where `{ARCH}` is the architecture name. Look for instances of `SubtargetFeature`.\n+//\n // Beware to not use the llvm github project for this, but check the git submodule\n // found in src/llvm-project\n // Though note that Rust can also be build with an external precompiled version of LLVM\n@@ -536,19 +521,3 @@ pub fn tune_cpu(sess: &Session) -> Option<&str> {\n     let name = sess.opts.unstable_opts.tune_cpu.as_ref()?;\n     Some(handle_native(name))\n }\n-\n-pub(crate) fn should_use_new_llvm_pass_manager(user_opt: &Option<bool>, target_arch: &str) -> bool {\n-    // The new pass manager is enabled by default for LLVM >= 13.\n-    // This matches Clang, which also enables it since Clang 13.\n-\n-    // Since LLVM 15, the legacy pass manager is no longer supported.\n-    if llvm_util::get_version() >= (15, 0, 0) {\n-        return true;\n-    }\n-\n-    // There are some perf issues with the new pass manager when targeting\n-    // s390x with LLVM 13, so enable the new pass manager only with LLVM 14.\n-    // See https://github.com/rust-lang/rust/issues/89609.\n-    let min_version = if target_arch == \"s390x\" { 14 } else { 13 };\n-    user_opt.unwrap_or_else(|| llvm_util::get_version() >= (min_version, 0, 0))\n-}"}, {"sha": "1eceb7f5c87beb362760851e5ce31ae40a66c75f", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -11,7 +11,6 @@ use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_middle::ty::{self, Instance, TypeVisitable};\n use rustc_session::config::CrateType;\n use rustc_target::spec::RelocModel;\n-use tracing::debug;\n \n impl<'tcx> PreDefineMethods<'tcx> for CodegenCx<'_, 'tcx> {\n     fn predefine_static("}, {"sha": "dc1165835e7ca271b38986619f20801fb8c5a71e", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -11,7 +11,6 @@ use rustc_target::abi::{Abi, AddressSpace, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{PointeeInfo, Scalar, Size, TyAbiInterface, Variants};\n use smallvec::{smallvec, SmallVec};\n-use tracing::debug;\n \n use std::fmt::Write;\n "}, {"sha": "bad58d0a8a0a14656e13c2803aaf366f3b446bc7", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,44 +1,16 @@\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::memmap::Mmap;\n use rustc_session::cstore::DllImport;\n use rustc_session::Session;\n+use rustc_span::symbol::Symbol;\n \n+use object::read::archive::ArchiveFile;\n+\n+use std::fmt::Display;\n+use std::fs::File;\n use std::io;\n use std::path::{Path, PathBuf};\n \n-pub(super) fn find_library(\n-    name: &str,\n-    verbatim: bool,\n-    search_paths: &[PathBuf],\n-    sess: &Session,\n-) -> PathBuf {\n-    // On Windows, static libraries sometimes show up as libfoo.a and other\n-    // times show up as foo.lib\n-    let oslibname = if verbatim {\n-        name.to_string()\n-    } else {\n-        format!(\"{}{}{}\", sess.target.staticlib_prefix, name, sess.target.staticlib_suffix)\n-    };\n-    let unixlibname = format!(\"lib{}.a\", name);\n-\n-    for path in search_paths {\n-        debug!(\"looking for {} inside {:?}\", name, path);\n-        let test = path.join(&oslibname);\n-        if test.exists() {\n-            return test;\n-        }\n-        if oslibname != unixlibname {\n-            let test = path.join(&unixlibname);\n-            if test.exists() {\n-                return test;\n-            }\n-        }\n-    }\n-    sess.fatal(&format!(\n-        \"could not find native static library `{}`, \\\n-                         perhaps an -L flag is missing?\",\n-        name\n-    ));\n-}\n-\n pub trait ArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a>;\n \n@@ -54,6 +26,36 @@ pub trait ArchiveBuilderBuilder {\n         dll_imports: &[DllImport],\n         tmpdir: &Path,\n     ) -> PathBuf;\n+\n+    fn extract_bundled_libs(\n+        &self,\n+        rlib: &Path,\n+        outdir: &Path,\n+        bundled_lib_file_names: &FxHashSet<Symbol>,\n+    ) -> Result<(), String> {\n+        let message = |msg: &str, e: &dyn Display| format!(\"{} '{}': {}\", msg, &rlib.display(), e);\n+        let archive_map = unsafe {\n+            Mmap::map(File::open(rlib).map_err(|e| message(\"failed to open file\", &e))?)\n+                .map_err(|e| message(\"failed to mmap file\", &e))?\n+        };\n+        let archive = ArchiveFile::parse(&*archive_map)\n+            .map_err(|e| message(\"failed to parse archive\", &e))?;\n+\n+        for entry in archive.members() {\n+            let entry = entry.map_err(|e| message(\"failed to read entry\", &e))?;\n+            let data = entry\n+                .data(&*archive_map)\n+                .map_err(|e| message(\"failed to get data from archive member\", &e))?;\n+            let name = std::str::from_utf8(entry.name())\n+                .map_err(|e| message(\"failed to convert name\", &e))?;\n+            if !bundled_lib_file_names.contains(&Symbol::intern(name)) {\n+                continue; // We need to extract only native libraries.\n+            }\n+            std::fs::write(&outdir.join(&name), data)\n+                .map_err(|e| message(\"failed to write file\", &e))?;\n+        }\n+        Ok(())\n+    }\n }\n \n pub trait ArchiveBuilder<'a> {"}, {"sha": "bb57fca74a21ecf06172febdaa438322c272bc21", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 152, "deletions": 120, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,11 +1,13 @@\n use rustc_arena::TypedArena;\n use rustc_ast::CRATE_NODE_ID;\n-use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n+use rustc_metadata::find_native_static_library;\n use rustc_metadata::fs::{emit_metadata, METADATA_FILENAME};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n@@ -24,7 +26,7 @@ use rustc_target::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n \n-use super::archive::{find_library, ArchiveBuilder, ArchiveBuilderBuilder};\n+use super::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use super::command::Command;\n use super::linker::{self, Linker};\n use super::metadata::{create_rmeta_file, MetadataPosition};\n@@ -44,7 +46,7 @@ use std::io::{BufWriter, Write};\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::process::{ExitStatus, Output, Stdio};\n-use std::{ascii, char, env, fmt, fs, io, mem, str};\n+use std::{env, fmt, fs, io, mem, str};\n \n pub fn ensure_removed(diag_handler: &Handler, path: &Path) {\n     if let Err(e) = fs::remove_file(path) {\n@@ -307,6 +309,9 @@ fn link_rlib<'a>(\n         }\n     }\n \n+    // Used if packed_bundled_libs flag enabled.\n+    let mut packed_bundled_libs = Vec::new();\n+\n     // Note that in this loop we are ignoring the value of `lib.cfg`. That is,\n     // we may not be configured to actually include a static library if we're\n     // adding it here. That's because later when we consume this rlib we'll\n@@ -325,6 +330,8 @@ fn link_rlib<'a>(\n     // metadata of the rlib we're generating somehow.\n     for lib in codegen_results.crate_info.used_libraries.iter() {\n         match lib.kind {\n+            NativeLibKind::Static { bundle: None | Some(true), whole_archive: Some(true) }\n+                if flavor == RlibFlavor::Normal && sess.opts.unstable_opts.packed_bundled_libs => {}\n             NativeLibKind::Static { bundle: None | Some(true), whole_archive: Some(true) }\n                 if flavor == RlibFlavor::Normal =>\n             {\n@@ -348,7 +355,16 @@ fn link_rlib<'a>(\n         }\n         if let Some(name) = lib.name {\n             let location =\n-                find_library(name.as_str(), lib.verbatim.unwrap_or(false), &lib_search_paths, sess);\n+                find_native_static_library(name.as_str(), lib.verbatim, &lib_search_paths, sess);\n+            if sess.opts.unstable_opts.packed_bundled_libs && flavor == RlibFlavor::Normal {\n+                packed_bundled_libs.push(find_native_static_library(\n+                    lib.filename.unwrap().as_str(),\n+                    Some(true),\n+                    &lib_search_paths,\n+                    sess,\n+                ));\n+                continue;\n+            }\n             ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|e| {\n                 sess.fatal(&format!(\n                     \"failed to add native library {}: {}\",\n@@ -403,6 +419,12 @@ fn link_rlib<'a>(\n         ab.add_file(&trailing_metadata);\n     }\n \n+    // Add all bundled static native library dependencies.\n+    // Archives added to the end of .rlib archive, see comment above for the reason.\n+    for lib in packed_bundled_libs {\n+        ab.add_file(&lib)\n+    }\n+\n     return Ok(ab);\n }\n \n@@ -552,14 +574,6 @@ fn link_staticlib<'a>(\n     Ok(())\n }\n \n-fn escape_stdout_stderr_string(s: &[u8]) -> String {\n-    str::from_utf8(s).map(|s| s.to_owned()).unwrap_or_else(|_| {\n-        let mut x = \"Non-UTF-8 output: \".to_string();\n-        x.extend(s.iter().flat_map(|&b| ascii::escape_default(b)).map(char::from));\n-        x\n-    })\n-}\n-\n /// Use `thorin` (rust implementation of a dwarf packaging utility) to link DWARF objects into a\n /// DWARF package.\n fn link_dwarf_object<'a>(\n@@ -866,7 +880,7 @@ fn link_natively<'a>(\n             if !prog.status.success() {\n                 let mut output = prog.stderr.clone();\n                 output.extend_from_slice(&prog.stdout);\n-                let escaped_output = escape_stdout_stderr_string(&output);\n+                let escaped_output = escape_string(&output);\n                 let mut err = sess.struct_err(&format!(\n                     \"linking with `{}` failed: {}\",\n                     linker_path.display(),\n@@ -934,8 +948,8 @@ fn link_natively<'a>(\n \n                 sess.abort_if_errors();\n             }\n-            info!(\"linker stderr:\\n{}\", escape_stdout_stderr_string(&prog.stderr));\n-            info!(\"linker stdout:\\n{}\", escape_stdout_stderr_string(&prog.stdout));\n+            info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr));\n+            info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout));\n         }\n         Err(e) => {\n             let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n@@ -1065,23 +1079,23 @@ fn strip_symbols_in_osx<'a>(sess: &'a Session, out_filename: &Path, option: Opti\n }\n \n fn escape_string(s: &[u8]) -> String {\n-    str::from_utf8(s).map(|s| s.to_owned()).unwrap_or_else(|_| {\n-        let mut x = \"Non-UTF-8 output: \".to_string();\n-        x.extend(s.iter().flat_map(|&b| ascii::escape_default(b)).map(char::from));\n-        x\n-    })\n+    match str::from_utf8(s) {\n+        Ok(s) => s.to_owned(),\n+        Err(_) => format!(\"Non-UTF-8 output: {}\", s.escape_ascii()),\n+    }\n }\n \n fn add_sanitizer_libraries(sess: &Session, crate_type: CrateType, linker: &mut dyn Linker) {\n     // On macOS the runtimes are distributed as dylibs which should be linked to\n     // both executables and dynamic shared objects. Everywhere else the runtimes\n     // are currently distributed as static libraries which should be linked to\n     // executables only.\n-    let needs_runtime = match crate_type {\n-        CrateType::Executable => true,\n-        CrateType::Dylib | CrateType::Cdylib | CrateType::ProcMacro => sess.target.is_like_osx,\n-        CrateType::Rlib | CrateType::Staticlib => false,\n-    };\n+    let needs_runtime = !sess.target.is_like_android\n+        && match crate_type {\n+            CrateType::Executable => true,\n+            CrateType::Dylib | CrateType::Cdylib | CrateType::ProcMacro => sess.target.is_like_osx,\n+            CrateType::Rlib | CrateType::Staticlib => false,\n+        };\n \n     if !needs_runtime {\n         return;\n@@ -1173,13 +1187,6 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n             // only the linker flavor is known; use the default linker for the selected flavor\n             (None, Some(flavor)) => Some((\n                 PathBuf::from(match flavor {\n-                    LinkerFlavor::Em => {\n-                        if cfg!(windows) {\n-                            \"emcc.bat\"\n-                        } else {\n-                            \"emcc\"\n-                        }\n-                    }\n                     LinkerFlavor::Gcc => {\n                         if cfg!(any(target_os = \"solaris\", target_os = \"illumos\")) {\n                             // On historical Solaris systems, \"cc\" may have\n@@ -1194,11 +1201,17 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                         }\n                     }\n                     LinkerFlavor::Ld => \"ld\",\n-                    LinkerFlavor::Msvc => \"link.exe\",\n                     LinkerFlavor::Lld(_) => \"lld\",\n-                    LinkerFlavor::PtxLinker => \"rust-ptx-linker\",\n-                    LinkerFlavor::BpfLinker => \"bpf-linker\",\n-                    LinkerFlavor::L4Bender => \"l4-bender\",\n+                    LinkerFlavor::Msvc => \"link.exe\",\n+                    LinkerFlavor::EmCc => {\n+                        if cfg!(windows) {\n+                            \"emcc.bat\"\n+                        } else {\n+                            \"emcc\"\n+                        }\n+                    }\n+                    LinkerFlavor::Bpf => \"bpf-linker\",\n+                    LinkerFlavor::Ptx => \"rust-ptx-linker\",\n                 }),\n                 flavor,\n             )),\n@@ -1208,7 +1221,7 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                 });\n \n                 let flavor = if stem == \"emcc\" {\n-                    LinkerFlavor::Em\n+                    LinkerFlavor::EmCc\n                 } else if stem == \"gcc\"\n                     || stem.ends_with(\"-gcc\")\n                     || stem == \"clang\"\n@@ -1236,7 +1249,8 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     // linker and linker flavor specified via command line have precedence over what the target\n     // specification specifies\n-    if let Some(ret) = infer_from(sess, sess.opts.cg.linker.clone(), sess.opts.cg.linker_flavor) {\n+    let linker_flavor = sess.opts.cg.linker_flavor.map(LinkerFlavor::from_cli);\n+    if let Some(ret) = infer_from(sess, sess.opts.cg.linker.clone(), linker_flavor) {\n         return ret;\n     }\n \n@@ -1714,6 +1728,13 @@ fn add_post_link_args(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor\n /// that are necessary for the linking. They are only present in symbol table but not actually\n /// used in any sections, so the linker will therefore pick relevant rlibs for linking, but\n /// unused `#[no_mangle]` or `#[used]` can still be discard by GC sections.\n+///\n+/// There's a few internal crates in the standard library (aka libcore and\n+/// libstd) which actually have a circular dependence upon one another. This\n+/// currently arises through \"weak lang items\" where libcore requires things\n+/// like `rust_begin_unwind` but libstd ends up defining it. To get this\n+/// circular dependence to work correctly we declare some of these things\n+/// in this synthetic object.\n fn add_linked_symbol_object(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n@@ -2113,11 +2134,11 @@ fn add_order_independent_options(\n         });\n     }\n \n-    if flavor == LinkerFlavor::PtxLinker {\n+    if flavor == LinkerFlavor::Ptx {\n         // Provide the linker with fallback to internal `target-cpu`.\n         cmd.arg(\"--fallback-arch\");\n         cmd.arg(&codegen_results.crate_info.target_cpu);\n-    } else if flavor == LinkerFlavor::BpfLinker {\n+    } else if flavor == LinkerFlavor::Bpf {\n         cmd.arg(\"--cpu\");\n         cmd.arg(&codegen_results.crate_info.target_cpu);\n         cmd.arg(\"--cpu-features\");\n@@ -2333,72 +2354,25 @@ fn add_upstream_rust_crates<'a>(\n     // crates.\n     let deps = &codegen_results.crate_info.used_crates;\n \n-    // There's a few internal crates in the standard library (aka libcore and\n-    // libstd) which actually have a circular dependence upon one another. This\n-    // currently arises through \"weak lang items\" where libcore requires things\n-    // like `rust_begin_unwind` but libstd ends up defining it. To get this\n-    // circular dependence to work correctly in all situations we'll need to be\n-    // sure to correctly apply the `--start-group` and `--end-group` options to\n-    // GNU linkers, otherwise if we don't use any other symbol from the standard\n-    // library it'll get discarded and the whole application won't link.\n-    //\n-    // In this loop we're calculating the `group_end`, after which crate to\n-    // pass `--end-group` and `group_start`, before which crate to pass\n-    // `--start-group`. We currently do this by passing `--end-group` after\n-    // the first crate (when iterating backwards) that requires a lang item\n-    // defined somewhere else. Once that's set then when we've defined all the\n-    // necessary lang items we'll pass `--start-group`.\n-    //\n-    // Note that this isn't amazing logic for now but it should do the trick\n-    // for the current implementation of the standard library.\n-    let mut group_end = None;\n-    let mut group_start = None;\n-    // Crates available for linking thus far.\n-    let mut available = FxHashSet::default();\n-    // Crates required to satisfy dependencies discovered so far.\n-    let mut required = FxHashSet::default();\n-\n-    let info = &codegen_results.crate_info;\n-    for &cnum in deps.iter().rev() {\n-        if let Some(missing) = info.missing_lang_items.get(&cnum) {\n-            let missing_crates = missing.iter().map(|i| info.lang_item_to_crate.get(i).copied());\n-            required.extend(missing_crates);\n-        }\n-\n-        required.insert(Some(cnum));\n-        available.insert(Some(cnum));\n-\n-        if required.len() > available.len() && group_end.is_none() {\n-            group_end = Some(cnum);\n-        }\n-        if required.len() == available.len() && group_end.is_some() {\n-            group_start = Some(cnum);\n-            break;\n-        }\n-    }\n-\n-    // If we didn't end up filling in all lang items from upstream crates then\n-    // we'll be filling it in with our crate. This probably means we're the\n-    // standard library itself, so skip this for now.\n-    if group_end.is_some() && group_start.is_none() {\n-        group_end = None;\n-    }\n-\n     let mut compiler_builtins = None;\n     let search_path = OnceCell::new();\n \n     for &cnum in deps.iter() {\n-        if group_start == Some(cnum) {\n-            cmd.group_start();\n-        }\n-\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n         let src = &codegen_results.crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n             _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n+                add_static_crate(\n+                    cmd,\n+                    sess,\n+                    archive_builder_builder,\n+                    codegen_results,\n+                    tmpdir,\n+                    cnum,\n+                    &Default::default(),\n+                );\n             }\n             // compiler-builtins are always placed last to ensure that they're\n             // linked correctly.\n@@ -2408,7 +2382,23 @@ fn add_upstream_rust_crates<'a>(\n             }\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n-                add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n+                let bundled_libs = if sess.opts.unstable_opts.packed_bundled_libs {\n+                    codegen_results.crate_info.native_libraries[&cnum]\n+                        .iter()\n+                        .filter_map(|lib| lib.filename)\n+                        .collect::<FxHashSet<_>>()\n+                } else {\n+                    Default::default()\n+                };\n+                add_static_crate(\n+                    cmd,\n+                    sess,\n+                    archive_builder_builder,\n+                    codegen_results,\n+                    tmpdir,\n+                    cnum,\n+                    &bundled_libs,\n+                );\n \n                 // Link static native libs with \"-bundle\" modifier only if the crate they originate from\n                 // is being linked statically to the current crate.  If it's linked dynamically\n@@ -2419,6 +2409,14 @@ fn add_upstream_rust_crates<'a>(\n                 // external build system already has the native dependencies defined, and it\n                 // will provide them to the linker itself.\n                 if sess.opts.unstable_opts.link_native_libraries {\n+                    if sess.opts.unstable_opts.packed_bundled_libs {\n+                        // If rlib contains native libs as archives, unpack them to tmpdir.\n+                        let rlib = &src.rlib.as_ref().unwrap().0;\n+                        archive_builder_builder\n+                            .extract_bundled_libs(rlib, tmpdir, &bundled_libs)\n+                            .unwrap_or_else(|e| sess.fatal(e));\n+                    }\n+\n                     let mut last = (None, NativeLibKind::Unspecified, None);\n                     for lib in &codegen_results.crate_info.native_libraries[&cnum] {\n                         let Some(name) = lib.name else {\n@@ -2451,6 +2449,14 @@ fn add_upstream_rust_crates<'a>(\n                                 bundle: Some(false),\n                                 whole_archive: Some(false) | None,\n                             } => {\n+                                // HACK/FIXME: Fixup a circular dependency between libgcc and libc\n+                                // with glibc. This logic should be moved to the libc crate.\n+                                if sess.target.os == \"linux\"\n+                                    && sess.target.env == \"gnu\"\n+                                    && name == \"c\"\n+                                {\n+                                    cmd.link_staticlib(\"gcc\", false);\n+                                }\n                                 cmd.link_staticlib(name, lib.verbatim.unwrap_or(false));\n                             }\n                             NativeLibKind::LinkArg => {\n@@ -2460,20 +2466,23 @@ fn add_upstream_rust_crates<'a>(\n                             | NativeLibKind::Framework { .. }\n                             | NativeLibKind::Unspecified\n                             | NativeLibKind::RawDylib => {}\n-                            NativeLibKind::Static {\n-                                bundle: Some(true) | None,\n-                                whole_archive: _,\n-                            } => {}\n+                            NativeLibKind::Static { bundle: Some(true) | None, whole_archive } => {\n+                                if sess.opts.unstable_opts.packed_bundled_libs {\n+                                    // If rlib contains native libs as archives, they are unpacked to tmpdir.\n+                                    let path = tmpdir.join(lib.filename.unwrap().as_str());\n+                                    if whole_archive == Some(true) {\n+                                        cmd.link_whole_rlib(&path);\n+                                    } else {\n+                                        cmd.link_rlib(&path);\n+                                    }\n+                                }\n+                            }\n                         }\n                     }\n                 }\n             }\n             Linkage::Dynamic => add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0),\n         }\n-\n-        if group_end == Some(cnum) {\n-            cmd.group_end();\n-        }\n     }\n \n     // compiler-builtins are always placed last to ensure that they're\n@@ -2482,7 +2491,15 @@ fn add_upstream_rust_crates<'a>(\n     // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n     // is used)\n     if let Some(cnum) = compiler_builtins {\n-        add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n+        add_static_crate(\n+            cmd,\n+            sess,\n+            archive_builder_builder,\n+            codegen_results,\n+            tmpdir,\n+            cnum,\n+            &Default::default(),\n+        );\n     }\n \n     // Converts a library file-stem into a cc -l argument\n@@ -2515,6 +2532,7 @@ fn add_upstream_rust_crates<'a>(\n         codegen_results: &CodegenResults,\n         tmpdir: &Path,\n         cnum: CrateNum,\n+        bundled_lib_file_names: &FxHashSet<Symbol>,\n     ) {\n         let src = &codegen_results.crate_info.used_crate_source[&cnum];\n         let cratepath = &src.rlib.as_ref().unwrap().0;\n@@ -2543,6 +2561,7 @@ fn add_upstream_rust_crates<'a>(\n         let dst = tmpdir.join(cratepath.file_name().unwrap());\n         let name = cratepath.file_name().unwrap().to_str().unwrap();\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+        let bundled_lib_file_names = bundled_lib_file_names.clone();\n \n         sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n             let canonical_name = name.replace('-', \"_\");\n@@ -2576,6 +2595,15 @@ fn add_upstream_rust_crates<'a>(\n                     let skip_because_lto =\n                         upstream_rust_objects_already_included && is_rust_object && is_builtins;\n \n+                    // We skip native libraries because:\n+                    // 1. This native libraries won't be used from the generated rlib,\n+                    //    so we can throw them away to avoid the copying work.\n+                    // 2. We can't allow it to be a single remaining entry in archive\n+                    //    as some linkers may complain on that.\n+                    if bundled_lib_file_names.contains(&Symbol::intern(f)) {\n+                        return true;\n+                    }\n+\n                     if skip_because_cfg_say_so || skip_because_lto {\n                         return true;\n                     }\n@@ -2797,20 +2825,24 @@ fn add_gcc_ld_path(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n         if let LinkerFlavor::Gcc = flavor {\n             match ld_impl {\n                 LdImpl::Lld => {\n-                    let tools_path = sess.get_tools_search_paths(false);\n-                    let gcc_ld_dir = tools_path\n-                        .into_iter()\n-                        .map(|p| p.join(\"gcc-ld\"))\n-                        .find(|p| {\n-                            p.join(if sess.host.is_like_windows { \"ld.exe\" } else { \"ld\" }).exists()\n-                        })\n-                        .unwrap_or_else(|| sess.fatal(\"rust-lld (as ld) not found\"));\n-                    cmd.arg({\n-                        let mut arg = OsString::from(\"-B\");\n-                        arg.push(gcc_ld_dir);\n-                        arg\n-                    });\n-                    cmd.arg(format!(\"-Wl,-rustc-lld-flavor={}\", sess.target.lld_flavor.as_str()));\n+                    // Implement the \"self-contained\" part of -Zgcc-ld\n+                    // by adding rustc distribution directories to the tool search path.\n+                    for path in sess.get_tools_search_paths(false) {\n+                        cmd.arg({\n+                            let mut arg = OsString::from(\"-B\");\n+                            arg.push(path.join(\"gcc-ld\"));\n+                            arg\n+                        });\n+                    }\n+                    // Implement the \"linker flavor\" part of -Zgcc-ld\n+                    // by asking cc to use some kind of lld.\n+                    cmd.arg(\"-fuse-ld=lld\");\n+                    if sess.target.lld_flavor != LldFlavor::Ld {\n+                        // Tell clang to use a non-default LLD flavor.\n+                        // Gcc doesn't understand the target option, but we currently assume\n+                        // that gcc is not used for Apple and Wasm targets (#97402).\n+                        cmd.arg(format!(\"--target={}\", sess.target.llvm_target));\n+                    }\n                 }\n             }\n         } else {"}, {"sha": "e0bd7a33f7373c6d93a217937906a00c04f4049b", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 23, "deletions": 62, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,4 +1,3 @@\n-use super::archive;\n use super::command::Command;\n use super::symbol_export;\n use rustc_span::symbol::sym;\n@@ -11,6 +10,7 @@ use std::path::{Path, PathBuf};\n use std::{env, mem, str};\n \n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc_metadata::find_native_static_library;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo, SymbolExportKind};\n use rustc_middle::ty::TyCtxt;\n@@ -126,29 +126,26 @@ pub fn get_linker<'a>(\n     // to the linker args construction.\n     assert!(cmd.get_args().is_empty() || sess.target.vendor == \"uwp\");\n     match flavor {\n-        LinkerFlavor::Lld(LldFlavor::Link) | LinkerFlavor::Msvc => {\n-            Box::new(MsvcLinker { cmd, sess }) as Box<dyn Linker>\n-        }\n-        LinkerFlavor::Em => Box::new(EmLinker { cmd, sess }) as Box<dyn Linker>,\n         LinkerFlavor::Gcc => {\n             Box::new(GccLinker { cmd, sess, target_cpu, hinted_static: false, is_ld: false })\n                 as Box<dyn Linker>\n         }\n-\n+        LinkerFlavor::Ld if sess.target.os == \"l4re\" => {\n+            Box::new(L4Bender::new(cmd, sess)) as Box<dyn Linker>\n+        }\n         LinkerFlavor::Lld(LldFlavor::Ld)\n         | LinkerFlavor::Lld(LldFlavor::Ld64)\n         | LinkerFlavor::Ld => {\n             Box::new(GccLinker { cmd, sess, target_cpu, hinted_static: false, is_ld: true })\n                 as Box<dyn Linker>\n         }\n-\n+        LinkerFlavor::Lld(LldFlavor::Link) | LinkerFlavor::Msvc => {\n+            Box::new(MsvcLinker { cmd, sess }) as Box<dyn Linker>\n+        }\n         LinkerFlavor::Lld(LldFlavor::Wasm) => Box::new(WasmLd::new(cmd, sess)) as Box<dyn Linker>,\n-\n-        LinkerFlavor::PtxLinker => Box::new(PtxLinker { cmd, sess }) as Box<dyn Linker>,\n-\n-        LinkerFlavor::BpfLinker => Box::new(BpfLinker { cmd, sess }) as Box<dyn Linker>,\n-\n-        LinkerFlavor::L4Bender => Box::new(L4Bender::new(cmd, sess)) as Box<dyn Linker>,\n+        LinkerFlavor::EmCc => Box::new(EmLinker { cmd, sess }) as Box<dyn Linker>,\n+        LinkerFlavor::Bpf => Box::new(BpfLinker { cmd, sess }) as Box<dyn Linker>,\n+        LinkerFlavor::Ptx => Box::new(PtxLinker { cmd, sess }) as Box<dyn Linker>,\n     }\n }\n \n@@ -186,8 +183,6 @@ pub trait Linker {\n     fn no_default_libraries(&mut self);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType, symbols: &[String]);\n     fn subsystem(&mut self, subsystem: &str);\n-    fn group_start(&mut self);\n-    fn group_end(&mut self);\n     fn linker_plugin_lto(&mut self);\n     fn add_eh_frame_header(&mut self) {}\n     fn add_no_exec(&mut self) {}\n@@ -444,7 +439,10 @@ impl<'a> Linker for GccLinker<'a> {\n             }\n         }\n         self.hint_dynamic();\n-        self.cmd.arg(format!(\"-l{}{}\", if verbatim { \":\" } else { \"\" }, lib));\n+        self.cmd.arg(format!(\n+            \"-l{}{lib}\",\n+            if verbatim && self.sess.target.linker_is_gnu { \":\" } else { \"\" },\n+        ));\n         if !as_needed {\n             if self.sess.target.is_like_osx {\n                 // See above FIXME comment\n@@ -455,7 +453,10 @@ impl<'a> Linker for GccLinker<'a> {\n     }\n     fn link_staticlib(&mut self, lib: &str, verbatim: bool) {\n         self.hint_static();\n-        self.cmd.arg(format!(\"-l{}{}\", if verbatim { \":\" } else { \"\" }, lib));\n+        self.cmd.arg(format!(\n+            \"-l{}{lib}\",\n+            if verbatim && self.sess.target.linker_is_gnu { \":\" } else { \"\" },\n+        ));\n     }\n     fn link_rlib(&mut self, lib: &Path) {\n         self.hint_static();\n@@ -509,17 +510,17 @@ impl<'a> Linker for GccLinker<'a> {\n         self.hint_static();\n         let target = &self.sess.target;\n         if !target.is_like_osx {\n-            self.linker_arg(\"--whole-archive\").cmd.arg(format!(\n-                \"-l{}{}\",\n-                if verbatim { \":\" } else { \"\" },\n-                lib\n+            self.linker_arg(\"--whole-archive\");\n+            self.cmd.arg(format!(\n+                \"-l{}{lib}\",\n+                if verbatim && self.sess.target.linker_is_gnu { \":\" } else { \"\" },\n             ));\n             self.linker_arg(\"--no-whole-archive\");\n         } else {\n             // -force_load is the macOS equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n             self.linker_arg(\"-force_load\");\n-            let lib = archive::find_library(lib, verbatim, search_path, &self.sess);\n+            let lib = find_native_static_library(lib, Some(verbatim), search_path, &self.sess);\n             self.linker_arg(&lib);\n         }\n     }\n@@ -733,18 +734,6 @@ impl<'a> Linker for GccLinker<'a> {\n         self.hint_dynamic(); // Reset to default before returning the composed command line.\n     }\n \n-    fn group_start(&mut self) {\n-        if self.takes_hints() {\n-            self.linker_arg(\"--start-group\");\n-        }\n-    }\n-\n-    fn group_end(&mut self) {\n-        if self.takes_hints() {\n-            self.linker_arg(\"--end-group\");\n-        }\n-    }\n-\n     fn linker_plugin_lto(&mut self) {\n         match self.sess.opts.cg.linker_plugin_lto {\n             LinkerPluginLto::Disabled => {\n@@ -1022,10 +1011,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n         }\n     }\n \n-    // MSVC doesn't need group indicators\n-    fn group_start(&mut self) {}\n-    fn group_end(&mut self) {}\n-\n     fn linker_plugin_lto(&mut self) {\n         // Do nothing\n     }\n@@ -1168,10 +1153,6 @@ impl<'a> Linker for EmLinker<'a> {\n         // noop\n     }\n \n-    // Appears not necessary on Emscripten\n-    fn group_start(&mut self) {}\n-    fn group_end(&mut self) {}\n-\n     fn linker_plugin_lto(&mut self) {\n         // Do nothing\n     }\n@@ -1347,10 +1328,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    // Not needed for now with LLD\n-    fn group_start(&mut self) {}\n-    fn group_end(&mut self) {}\n-\n     fn linker_plugin_lto(&mut self) {\n         // Do nothing for now\n     }\n@@ -1479,14 +1456,6 @@ impl<'a> Linker for L4Bender<'a> {\n         self.hint_static(); // Reset to default before returning the composed command line.\n     }\n \n-    fn group_start(&mut self) {\n-        self.cmd.arg(\"--start-group\");\n-    }\n-\n-    fn group_end(&mut self) {\n-        self.cmd.arg(\"--end-group\");\n-    }\n-\n     fn linker_plugin_lto(&mut self) {}\n \n     fn control_flow_guard(&mut self) {}\n@@ -1667,10 +1636,6 @@ impl<'a> Linker for PtxLinker<'a> {\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    fn group_start(&mut self) {}\n-\n-    fn group_end(&mut self) {}\n-\n     fn linker_plugin_lto(&mut self) {}\n }\n \n@@ -1780,9 +1745,5 @@ impl<'a> Linker for BpfLinker<'a> {\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    fn group_start(&mut self) {}\n-\n-    fn group_end(&mut self) {}\n-\n     fn linker_plugin_lto(&mut self) {}\n }"}, {"sha": "8d7e2c5cf3939a5cc5d907751f18ba1c94df1355", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -540,7 +540,7 @@ pub fn linking_symbol_name_for_instance_in_crate<'tcx>(\n         .map(|fnabi| (fnabi.conv, &fnabi.args[..]))\n         .unwrap_or((Conv::Rust, &[]));\n \n-    // Decorate symbols with prefices, suffices and total number of bytes of arguments.\n+    // Decorate symbols with prefixes, suffixes and total number of bytes of arguments.\n     // Reference: https://docs.microsoft.com/en-us/cpp/build/reference/decorated-names?view=msvc-170\n     let (prefix, suffix) = match conv {\n         Conv::X86Fastcall => (\"@\", \"@\"),"}, {"sha": "680b9b642d9b279bec3e16689c27787f83db823f", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -113,7 +113,6 @@ pub struct ModuleConfig {\n     pub vectorize_slp: bool,\n     pub merge_functions: bool,\n     pub inline_threshold: Option<u32>,\n-    pub new_llvm_pass_manager: Option<bool>,\n     pub emit_lifetime_markers: bool,\n     pub llvm_plugins: Vec<String>,\n }\n@@ -265,7 +264,6 @@ impl ModuleConfig {\n             },\n \n             inline_threshold: sess.opts.cg.inline_threshold,\n-            new_llvm_pass_manager: sess.opts.unstable_opts.new_llvm_pass_manager,\n             emit_lifetime_markers: sess.emit_lifetime_markers(),\n             llvm_plugins: if_regular!(sess.opts.unstable_opts.llvm_plugins.clone(), vec![]),\n         }"}, {"sha": "35fd86c173578e77b26b706b4d08a0d6c04d930a", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -12,7 +12,7 @@ use crate::traits::*;\n use crate::{CachedModuleCodegen, CompiledModule, CrateInfo, MemFlags, ModuleCodegen, ModuleKind};\n \n use rustc_attr as attr;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n \n use rustc_data_structures::sync::par_iter;\n@@ -21,10 +21,12 @@ use rustc_data_structures::sync::ParallelIterator;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n+use rustc_hir::weak_lang_items::WEAK_ITEMS_SYMBOLS;\n use rustc_index::vec::Idx;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols;\n+use rustc_middle::middle::exported_symbols::SymbolExportKind;\n use rustc_middle::middle::lang_items;\n use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, MonoItem};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, TyAndLayout};\n@@ -34,6 +36,7 @@ use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{self, CrateType, EntryFnType, OutputType};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n+use rustc_span::Symbol;\n use rustc_span::{DebuggerVisualizerFile, DebuggerVisualizerType};\n use rustc_target::abi::{Align, VariantIdx};\n \n@@ -163,6 +166,11 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             if let Some(entry_idx) = vptr_entry_idx {\n                 let ptr_ty = cx.type_i8p();\n                 let ptr_align = cx.tcx().data_layout.pointer_align.abi;\n+                let vtable_ptr_ty = cx.scalar_pair_element_backend_type(\n+                    cx.layout_of(cx.tcx().mk_mut_ptr(target)),\n+                    1,\n+                    true,\n+                );\n                 let llvtable = bx.pointercast(old_info, bx.type_ptr_to(ptr_ty));\n                 let gep = bx.inbounds_gep(\n                     ptr_ty,\n@@ -173,7 +181,7 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 bx.nonnull_metadata(new_vptr);\n                 // VTable loads are invariant.\n                 bx.set_invariant_load(new_vptr);\n-                new_vptr\n+                bx.pointercast(new_vptr, vtable_ptr_ty)\n             } else {\n                 old_info\n             }\n@@ -389,15 +397,14 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     let main_llfn = cx.get_fn_addr(instance);\n \n-    let use_start_lang_item = EntryFnType::Start != entry_type;\n-    let entry_fn = create_entry_fn::<Bx>(cx, main_llfn, main_def_id, use_start_lang_item);\n+    let entry_fn = create_entry_fn::<Bx>(cx, main_llfn, main_def_id, entry_type);\n     return Some(entry_fn);\n \n     fn create_entry_fn<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cx: &'a Bx::CodegenCx,\n         rust_main: Bx::Value,\n         rust_main_def_id: DefId,\n-        use_start_lang_item: bool,\n+        entry_type: EntryFnType,\n     ) -> Bx::Function {\n         // The entry function is either `int main(void)` or `int main(int argc, char **argv)`,\n         // depending on whether the target needs `argc` and `argv` to be passed in.\n@@ -442,7 +449,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let i8pp_ty = cx.type_ptr_to(cx.type_i8p());\n         let (arg_argc, arg_argv) = get_argc_argv(cx, &mut bx);\n \n-        let (start_fn, start_ty, args) = if use_start_lang_item {\n+        let (start_fn, start_ty, args) = if let EntryFnType::Main { sigpipe } = entry_type {\n             let start_def_id = cx.tcx().require_lang_item(LangItem::Start, None);\n             let start_fn = cx.get_fn_addr(\n                 ty::Instance::resolve(\n@@ -454,8 +461,13 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 .unwrap()\n                 .unwrap(),\n             );\n-            let start_ty = cx.type_func(&[cx.val_ty(rust_main), isize_ty, i8pp_ty], isize_ty);\n-            (start_fn, start_ty, vec![rust_main, arg_argc, arg_argv])\n+\n+            let i8_ty = cx.type_i8();\n+            let arg_sigpipe = bx.const_u8(sigpipe);\n+\n+            let start_ty =\n+                cx.type_func(&[cx.val_ty(rust_main), isize_ty, i8pp_ty, i8_ty], isize_ty);\n+            (start_fn, start_ty, vec![rust_main, arg_argc, arg_argv, arg_sigpipe])\n         } else {\n             debug!(\"using user-defined start fn\");\n             let start_ty = cx.type_func(&[isize_ty, i8pp_ty], isize_ty);\n@@ -811,21 +823,16 @@ impl CrateInfo {\n             crate_name: Default::default(),\n             used_crates,\n             used_crate_source: Default::default(),\n-            lang_item_to_crate: Default::default(),\n-            missing_lang_items: Default::default(),\n             dependency_formats: tcx.dependency_formats(()).clone(),\n             windows_subsystem,\n             natvis_debugger_visualizers: Default::default(),\n         };\n-        let lang_items = tcx.lang_items();\n-\n         let crates = tcx.crates(());\n \n         let n_crates = crates.len();\n         info.native_libraries.reserve(n_crates);\n         info.crate_name.reserve(n_crates);\n         info.used_crate_source.reserve(n_crates);\n-        info.missing_lang_items.reserve(n_crates);\n \n         for &cnum in crates.iter() {\n             info.native_libraries\n@@ -843,17 +850,37 @@ impl CrateInfo {\n             if tcx.is_no_builtins(cnum) {\n                 info.is_no_builtins.insert(cnum);\n             }\n-            let missing = tcx.missing_lang_items(cnum);\n-            for &item in missing.iter() {\n-                if let Ok(id) = lang_items.require(item) {\n-                    info.lang_item_to_crate.insert(item, id.krate);\n-                }\n-            }\n+        }\n \n-            // No need to look for lang items that don't actually need to exist.\n-            let missing =\n-                missing.iter().cloned().filter(|&l| lang_items::required(tcx, l)).collect();\n-            info.missing_lang_items.insert(cnum, missing);\n+        // Handle circular dependencies in the standard library.\n+        // See comment before `add_linked_symbol_object` function for the details.\n+        // With msvc-like linkers it's both unnecessary (they support circular dependencies),\n+        // and causes linking issues (when weak lang item symbols are \"privatized\" by LTO).\n+        let target = &tcx.sess.target;\n+        if !target.is_like_msvc {\n+            let missing_weak_lang_items: FxHashSet<&Symbol> = info\n+                .used_crates\n+                .iter()\n+                .flat_map(|cnum| {\n+                    tcx.missing_lang_items(*cnum)\n+                        .iter()\n+                        .filter(|l| lang_items::required(tcx, **l))\n+                        .filter_map(|item| WEAK_ITEMS_SYMBOLS.get(item))\n+                })\n+                .collect();\n+            let prefix = if target.is_like_windows && target.arch == \"x86\" { \"_\" } else { \"\" };\n+            info.linked_symbols\n+                .iter_mut()\n+                .filter(|(crate_type, _)| {\n+                    !matches!(crate_type, CrateType::Rlib | CrateType::Staticlib)\n+                })\n+                .for_each(|(_, linked_symbols)| {\n+                    linked_symbols.extend(\n+                        missing_weak_lang_items\n+                            .iter()\n+                            .map(|item| (format!(\"{prefix}{item}\"), SymbolExportKind::Text)),\n+                    )\n+                });\n         }\n \n         let embed_visualizers = tcx.sess.crate_types().iter().any(|&crate_type| match crate_type {\n@@ -874,7 +901,7 @@ impl CrateInfo {\n             }\n         });\n \n-        if tcx.sess.target.is_like_msvc && embed_visualizers {\n+        if target.is_like_msvc && embed_visualizers {\n             info.natvis_debugger_visualizers =\n                 collect_debugger_visualizers_transitive(tcx, DebuggerVisualizerType::Natvis);\n         }"}, {"sha": "3ef9a634e18576b822989808706a069bf1f950d6", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,7 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(try_blocks)]\n-#![feature(let_else)]\n #![feature(once_cell)]\n #![feature(associated_type_bounds)]\n #![feature(strict_provenance)]\n@@ -25,7 +24,6 @@ use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def_id::CrateNum;\n-use rustc_hir::LangItem;\n use rustc_middle::dep_graph::WorkProduct;\n use rustc_middle::middle::dependency_format::Dependencies;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n@@ -113,6 +111,7 @@ bitflags::bitflags! {\n pub struct NativeLib {\n     pub kind: NativeLibKind,\n     pub name: Option<Symbol>,\n+    pub filename: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n     pub verbatim: Option<bool>,\n     pub dll_imports: Vec<cstore::DllImport>,\n@@ -122,6 +121,7 @@ impl From<&cstore::NativeLib> for NativeLib {\n     fn from(lib: &cstore::NativeLib) -> Self {\n         NativeLib {\n             kind: lib.kind,\n+            filename: lib.filename,\n             name: lib.name,\n             cfg: lib.cfg.clone(),\n             verbatim: lib.verbatim,\n@@ -152,8 +152,6 @@ pub struct CrateInfo {\n     pub used_libraries: Vec<NativeLib>,\n     pub used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n     pub used_crates: Vec<CrateNum>,\n-    pub lang_item_to_crate: FxHashMap<LangItem, CrateNum>,\n-    pub missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n     pub dependency_formats: Lrc<Dependencies>,\n     pub windows_subsystem: Option<String>,\n     pub natvis_debugger_visualizers: BTreeSet<DebuggerVisualizerFile>,"}, {"sha": "cae46ebd2e9a7c366ab173be7226f136bb3cb05b", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> VirtualIndex {\n fn expect_dyn_trait_in_self<'tcx>(ty: Ty<'tcx>) -> ty::PolyExistentialTraitRef<'tcx> {\n     for arg in ty.peel_refs().walk() {\n         if let GenericArgKind::Type(ty) = arg.unpack() {\n-            if let ty::Dynamic(data, _) = ty.kind() {\n+            if let ty::Dynamic(data, _, _) = ty.kind() {\n                 return data.principal().expect(\"expected principal trait object\");\n             }\n         }\n@@ -86,15 +86,14 @@ fn expect_dyn_trait_in_self<'tcx>(ty: Ty<'tcx>) -> ty::PolyExistentialTraitRef<'\n /// The `trait_ref` encodes the erased self type. Hence if we are\n /// making an object `Foo<dyn Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T: Trait`.\n+#[instrument(level = \"debug\", skip(cx))]\n pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     cx: &Cx,\n     ty: Ty<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Cx::Value {\n     let tcx = cx.tcx();\n \n-    debug!(\"get_vtable(ty={:?}, trait_ref={:?})\", ty, trait_ref);\n-\n     // Check the cache.\n     if let Some(&val) = cx.vtables().borrow().get(&(ty, trait_ref)) {\n         return val;"}, {"sha": "a6b226ef72096db9ff11c86fa863fdcc4a09d4c8", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -13,8 +13,7 @@ use rustc_ast as ast;\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::AssertKind;\n-use rustc_middle::mir::{self, SwitchTargets};\n+use rustc_middle::mir::{self, AssertKind, SwitchTargets};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Instance, Ty, TypeVisitable};\n@@ -368,6 +367,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx.ret(llval);\n     }\n \n+    #[tracing::instrument(level = \"trace\", skip(self, helper, bx))]\n     fn codegen_drop_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n@@ -398,14 +398,75 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let (drop_fn, fn_abi) = match ty.kind() {\n             // FIXME(eddyb) perhaps move some of this logic into\n             // `Instance::resolve_drop_in_place`?\n-            ty::Dynamic(..) => {\n+            ty::Dynamic(_, _, ty::Dyn) => {\n+                // IN THIS ARM, WE HAVE:\n+                // ty = *mut (dyn Trait)\n+                // which is: exists<T> ( *mut T,    Vtable<T: Trait> )\n+                //                       args[0]    args[1]\n+                //\n+                // args = ( Data, Vtable )\n+                //                  |\n+                //                  v\n+                //                /-------\\\n+                //                | ...   |\n+                //                \\-------/\n+                //\n                 let virtual_drop = Instance {\n                     def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n                     substs: drop_fn.substs,\n                 };\n+                debug!(\"ty = {:?}\", ty);\n+                debug!(\"drop_fn = {:?}\", drop_fn);\n+                debug!(\"args = {:?}\", args);\n                 let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n                 let vtable = args[1];\n+                // Truncate vtable off of args list\n+                args = &args[..1];\n+                (\n+                    meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n+                        .get_fn(&mut bx, vtable, ty, &fn_abi),\n+                    fn_abi,\n+                )\n+            }\n+            ty::Dynamic(_, _, ty::DynStar) => {\n+                // IN THIS ARM, WE HAVE:\n+                // ty = *mut (dyn* Trait)\n+                // which is: *mut exists<T: sizeof(T) == sizeof(usize)> (T, Vtable<T: Trait>)\n+                //\n+                // args = [ * ]\n+                //          |\n+                //          v\n+                //      ( Data, Vtable )\n+                //                |\n+                //                v\n+                //              /-------\\\n+                //              | ...   |\n+                //              \\-------/\n+                //\n+                //\n+                // WE CAN CONVERT THIS INTO THE ABOVE LOGIC BY DOING\n+                //\n+                // data = &(*args[0]).0    // gives a pointer to Data above (really the same pointer)\n+                // vtable = (*args[0]).1   // loads the vtable out\n+                // (data, vtable)          // an equivalent Rust `*mut dyn Trait`\n+                //\n+                // SO THEN WE CAN USE THE ABOVE CODE.\n+                let virtual_drop = Instance {\n+                    def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n+                    substs: drop_fn.substs,\n+                };\n+                debug!(\"ty = {:?}\", ty);\n+                debug!(\"drop_fn = {:?}\", drop_fn);\n+                debug!(\"args = {:?}\", args);\n+                let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n+                let data = args[0];\n+                let data_ty = bx.cx().backend_type(place.layout);\n+                let vtable_ptr =\n+                    bx.gep(data_ty, data, &[bx.cx().const_i32(0), bx.cx().const_i32(1)]);\n+                let vtable = bx.load(bx.type_i8p(), vtable_ptr, abi::Align::ONE);\n+                // Truncate vtable off of args list\n                 args = &args[..1];\n+                debug!(\"args' = {:?}\", args);\n                 (\n                     meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n                         .get_fn(&mut bx, vtable, ty, &fn_abi),\n@@ -846,7 +907,30 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         llargs.push(data_ptr);\n                         continue;\n                     }\n-                    _ => span_bug!(span, \"can't codegen a virtual call on {:?}\", op),\n+                    Immediate(_) => {\n+                        let ty::Ref(_, ty, _) = op.layout.ty.kind() else {\n+                            span_bug!(span, \"can't codegen a virtual call on {:#?}\", op);\n+                        };\n+                        if !ty.is_dyn_star() {\n+                            span_bug!(span, \"can't codegen a virtual call on {:#?}\", op);\n+                        }\n+                        // FIXME(dyn-star): Make sure this is done on a &dyn* receiver\n+                        let place = op.deref(bx.cx());\n+                        let data_ptr = place.project_field(&mut bx, 0);\n+                        let meta_ptr = place.project_field(&mut bx, 1);\n+                        let meta = bx.load_operand(meta_ptr);\n+                        llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n+                            &mut bx,\n+                            meta.immediate(),\n+                            op.layout.ty,\n+                            &fn_abi,\n+                        ));\n+                        llargs.push(data_ptr.llval);\n+                        continue;\n+                    }\n+                    _ => {\n+                        span_bug!(span, \"can't codegen a virtual call on {:#?}\", op);\n+                    }\n                 }\n             }\n "}, {"sha": "4c6ab457c494557eb80cbea49cb1745a467b9d6a", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -25,26 +25,26 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<ConstValue<'tcx>, ErrorHandled> {\n         let ct = self.monomorphize(constant.literal);\n-        let ct = match ct {\n-            mir::ConstantKind::Ty(ct) => ct,\n+        let uv = match ct {\n+            mir::ConstantKind::Ty(ct) => match ct.kind() {\n+                ty::ConstKind::Unevaluated(uv) => uv.expand(),\n+                ty::ConstKind::Value(val) => {\n+                    return Ok(self.cx.tcx().valtree_to_const_val((ct.ty(), val)));\n+                }\n+                err => span_bug!(\n+                    constant.span,\n+                    \"encountered bad ConstKind after monomorphizing: {:?}\",\n+                    err\n+                ),\n+            },\n+            mir::ConstantKind::Unevaluated(uv, _) => uv,\n             mir::ConstantKind::Val(val, _) => return Ok(val),\n         };\n-        match ct.kind() {\n-            ty::ConstKind::Unevaluated(ct) => self\n-                .cx\n-                .tcx()\n-                .const_eval_resolve(ty::ParamEnv::reveal_all(), ct, None)\n-                .map_err(|err| {\n-                    self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n-                    err\n-                }),\n-            ty::ConstKind::Value(val) => Ok(self.cx.tcx().valtree_to_const_val((ct.ty(), val))),\n-            err => span_bug!(\n-                constant.span,\n-                \"encountered bad ConstKind after monomorphizing: {:?}\",\n-                err\n-            ),\n-        }\n+\n+        self.cx.tcx().const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None).map_err(|err| {\n+            self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n+            err\n+        })\n     }\n \n     /// process constant containing SIMD shuffle indices"}, {"sha": "157c1c82311dcff335adbf9aa5b10a54a7fa669e", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -3,7 +3,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir;\n use rustc_middle::ty;\n-use rustc_middle::ty::layout::LayoutOf;\n+use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_session::config::DebugInfo;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n@@ -93,15 +93,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n \n     /// In order to have a good line stepping behavior in debugger, we overwrite debug\n-    /// locations of macro expansions with that of the outermost expansion site\n-    /// (unless the crate is being compiled with `-Z debug-macros`).\n+    /// locations of macro expansions with that of the outermost expansion site (when the macro is\n+    /// annotated with `#[collapse_debuginfo]` or when `-Zdebug-macros` is provided).\n     fn adjust_span_for_debugging(&self, mut span: Span) -> Span {\n         // Bail out if debug info emission is not enabled.\n         if self.debug_context.is_none() {\n             return span;\n         }\n \n-        if span.from_expansion() && !self.cx.sess().opts.unstable_opts.debug_macros {\n+        if self.cx.tcx().should_collapse_debuginfo(span) {\n             // Walk up the macro expansion chain until we reach a non-expanded span.\n             // We also stop at the function body level because no line stepping can occur\n             // at the level above that."}, {"sha": "215edbe02c08e95244984fdf3ca817459f31ab73", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -77,10 +77,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let result = PlaceRef::new_sized(llresult, fn_abi.ret.layout);\n \n         let llval = match name {\n-            sym::assume => {\n-                bx.assume(args[0].immediate());\n-                return;\n-            }\n             sym::abort => {\n                 bx.abort();\n                 return;\n@@ -555,14 +551,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 return;\n             }\n \n-            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+            sym::ptr_guaranteed_cmp => {\n                 let a = args[0].immediate();\n                 let b = args[1].immediate();\n-                if name == sym::ptr_guaranteed_eq {\n-                    bx.icmp(IntPredicate::IntEQ, a, b)\n-                } else {\n-                    bx.icmp(IntPredicate::IntNE, a, b)\n-                }\n+                bx.icmp(IntPredicate::IntEQ, a, b)\n             }\n \n             sym::ptr_offset_from | sym::ptr_offset_from_unsigned => {"}, {"sha": "2b931bfc91d63b05c93717a42b522d87a9a4b127", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -191,7 +191,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 // errored or at least linted\n                 ErrorHandled::Reported(_) | ErrorHandled::Linted => {}\n                 ErrorHandled::TooGeneric => {\n-                    span_bug!(const_.span, \"codgen encountered polymorphic constant: {:?}\", err)\n+                    span_bug!(const_.span, \"codegen encountered polymorphic constant: {:?}\", err)\n                 }\n             }\n         }"}, {"sha": "37b1e036247bfcd8c4c2863c87bcd6385406816d", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -72,10 +72,6 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n     ) -> Self {\n         let layout = bx.layout_of(ty);\n \n-        if layout.is_zst() {\n-            return OperandRef::new_zst(bx, layout);\n-        }\n-\n         let val = match val {\n             ConstValue::Scalar(x) => {\n                 let Abi::Scalar(scalar) = layout.abi else {\n@@ -84,10 +80,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 let llval = bx.scalar_to_backend(x, scalar, bx.immediate_backend_type(layout));\n                 OperandValue::Immediate(llval)\n             }\n-            ConstValue::ZeroSized => {\n-                let llval = bx.zst_to_backend(bx.immediate_backend_type(layout));\n-                OperandValue::Immediate(llval)\n-            }\n+            ConstValue::ZeroSized => return OperandRef::new_zst(bx, layout),\n             ConstValue::Slice { data, start, end } => {\n                 let Abi::ScalarPair(a_scalar, _) = layout.abi else {\n                     bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout);"}, {"sha": "9c18df5643f1c51dc1889a5cec2a2b18b13e968c", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -4,7 +4,6 @@ use super::{FunctionCx, LocalRef};\n use crate::common::IntPredicate;\n use crate::glue;\n use crate::traits::*;\n-use crate::MemFlags;\n \n use rustc_middle::mir;\n use rustc_middle::mir::tcx::PlaceTy;\n@@ -245,7 +244,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 };\n                 bx.intcast(tag.immediate(), cast_to, signed)\n             }\n-            TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+            TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n                 // Rebase from niche values to discriminants, and check\n                 // whether the result is in range for the niche variants.\n                 let niche_llty = bx.cx().immediate_backend_type(tag.layout);\n@@ -303,7 +302,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 bx.select(\n                     is_niche,\n                     niche_discr,\n-                    bx.cx().const_uint(cast_to, dataful_variant.as_u32() as u64),\n+                    bx.cx().const_uint(cast_to, untagged_variant.as_u32() as u64),\n                 )\n             }\n         }\n@@ -338,21 +337,11 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             }\n             Variants::Multiple {\n                 tag_encoding:\n-                    TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+                    TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n                 tag_field,\n                 ..\n             } => {\n-                if variant_index != dataful_variant {\n-                    if bx.cx().sess().target.arch == \"arm\"\n-                        || bx.cx().sess().target.arch == \"aarch64\"\n-                    {\n-                        // FIXME(#34427): as workaround for LLVM bug on ARM,\n-                        // use memset of 0 before assigning niche value.\n-                        let fill_byte = bx.cx().const_u8(0);\n-                        let size = bx.cx().const_usize(self.layout.size.bytes());\n-                        bx.memset(self.llval, fill_byte, size, self.align, MemFlags::empty());\n-                    }\n-\n+                if variant_index != untagged_variant {\n                     let niche = self.project_field(bx, tag_field);\n                     let niche_llty = bx.cx().immediate_backend_type(niche.layout);\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n@@ -411,6 +400,21 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         downcast\n     }\n \n+    pub fn project_type<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        &self,\n+        bx: &mut Bx,\n+        ty: Ty<'tcx>,\n+    ) -> Self {\n+        let mut downcast = *self;\n+        downcast.layout = bx.cx().layout_of(ty);\n+\n+        // Cast to the appropriate type.\n+        let variant_ty = bx.cx().backend_type(downcast.layout);\n+        downcast.llval = bx.pointercast(downcast.llval, bx.cx().type_ptr_to(variant_ty));\n+\n+        downcast\n+    }\n+\n     pub fn storage_live<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &mut Bx) {\n         bx.lifetime_start(self.llval, self.layout.size);\n     }\n@@ -453,6 +457,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 mir::ProjectionElem::Field(ref field, _) => {\n                     cg_base.project_field(bx, field.index())\n                 }\n+                mir::ProjectionElem::OpaqueCast(ty) => cg_base.project_type(bx, ty),\n                 mir::ProjectionElem::Index(index) => {\n                     let index = &mir::Operand::Copy(mir::Place::from(index));\n                     let index = self.codegen_operand(bx, index);"}, {"sha": "56852b0fcc821e1107d918da2dbfd05f1f9745df", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -4,6 +4,7 @@ use super::{FunctionCx, LocalRef};\n \n use crate::base;\n use crate::common::{self, IntPredicate};\n+use crate::meth::get_vtable;\n use crate::traits::*;\n use crate::MemFlags;\n \n@@ -87,7 +88,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     let size = bx.const_usize(dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n-                    if bx.cx().const_to_opt_uint(v) == Some(0) {\n+                    if bx.cx().const_to_opt_u128(v, false) == Some(0) {\n                         let fill = bx.cx().const_u8(0);\n                         bx.memset(start, fill, size, dest.align, MemFlags::empty());\n                         return bx;\n@@ -271,6 +272,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             bug!(\"unexpected non-pair operand\");\n                         }\n                     }\n+                    mir::CastKind::DynStar => {\n+                        let data = match operand.val {\n+                            OperandValue::Ref(_, _, _) => todo!(),\n+                            OperandValue::Immediate(v) => v,\n+                            OperandValue::Pair(_, _) => todo!(),\n+                        };\n+                        let trait_ref =\n+                            if let ty::Dynamic(data, _, ty::DynStar) = cast.ty.kind() {\n+                                data.principal()\n+                            } else {\n+                                bug!(\"Only valid to do a DynStar cast into a DynStar type\")\n+                            };\n+                        let vtable = get_vtable(bx.cx(), source.ty(self.mir, bx.tcx()), trait_ref);\n+                        OperandValue::Pair(data, vtable)\n+                    }\n                     mir::CastKind::Pointer(\n                         PointerCast::MutToConstPointer | PointerCast::ArrayToPointer,\n                     )"}, {"sha": "1db0fb3a6f1b0381da9eb2a1ca06eb6e3689af75", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,4 +1,5 @@\n use rustc_middle::mir;\n+use rustc_middle::mir::NonDivergingIntrinsic;\n \n use super::FunctionCx;\n use super::LocalRef;\n@@ -73,11 +74,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 self.codegen_coverage(&mut bx, coverage.clone(), statement.source_info.scope);\n                 bx\n             }\n-            mir::StatementKind::CopyNonOverlapping(box mir::CopyNonOverlapping {\n-                ref src,\n-                ref dst,\n-                ref count,\n-            }) => {\n+            mir::StatementKind::Intrinsic(box NonDivergingIntrinsic::Assume(ref op)) => {\n+                let op_val = self.codegen_operand(&mut bx, op);\n+                bx.assume(op_val.immediate());\n+                bx\n+            }\n+            mir::StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(\n+                mir::CopyNonOverlapping { ref count, ref src, ref dst },\n+            )) => {\n                 let dst_val = self.codegen_operand(&mut bx, dst);\n                 let src_val = self.codegen_operand(&mut bx, src);\n                 let count = self.codegen_operand(&mut bx, count).immediate();"}, {"sha": "0e259bcd1a48dc1cddbb8f573a3f8c8dcf662935", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -210,8 +210,11 @@ const POWERPC_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"vsx\", Some(sym::powerpc_target_feature)),\n ];\n \n-const MIPS_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] =\n-    &[(\"fp64\", Some(sym::mips_target_feature)), (\"msa\", Some(sym::mips_target_feature))];\n+const MIPS_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"fp64\", Some(sym::mips_target_feature)),\n+    (\"msa\", Some(sym::mips_target_feature)),\n+    (\"virt\", Some(sym::mips_target_feature)),\n+];\n \n const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"m\", Some(sym::riscv_target_feature)),"}, {"sha": "fdc7a30e841ed1b7e4d64ff077a3fd6e1b26baf4", "filename": "compiler/rustc_codegen_ssa/src/traits/consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -29,7 +29,6 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn const_data_from_alloc(&self, alloc: ConstAllocation<'tcx>) -> Self::Value;\n \n     fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, llty: Self::Type) -> Self::Value;\n-    fn zst_to_backend(&self, llty: Self::Type) -> Self::Value;\n     fn from_const_alloc(\n         &self,\n         layout: TyAndLayout<'tcx>,"}, {"sha": "b52cc873f2e69745074dc5c3758ed8b79edd2938", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::pretty::display_allocation;\n use rustc_middle::traits::Reveal;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, subst::Subst, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::source_map::Span;\n use rustc_target::abi::{self, Abi};\n use std::borrow::Cow;\n@@ -197,7 +197,7 @@ pub(super) fn op_to_const<'tcx>(\n     }\n }\n \n-#[instrument(skip(tcx), level = \"debug\")]\n+#[instrument(skip(tcx), level = \"debug\", ret)]\n pub(crate) fn turn_into_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     constant: ConstAlloc<'tcx>,\n@@ -224,10 +224,7 @@ pub(crate) fn turn_into_const_value<'tcx>(\n     );\n \n     // Turn this into a proper constant.\n-    let const_val = op_to_const(&ecx, &mplace.into());\n-    debug!(?const_val);\n-\n-    const_val\n+    op_to_const(&ecx, &mplace.into())\n }\n \n #[instrument(skip(tcx), level = \"debug\")]"}, {"sha": "e5acacd9188888f670ec6498d97aee5b7e8558e8", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -35,21 +35,7 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n         // All `#[rustc_do_not_const_check]` functions should be hooked here.\n         let def_id = instance.def_id();\n \n-        if Some(def_id) == self.tcx.lang_items().const_eval_select() {\n-            // redirect to const_eval_select_ct\n-            if let Some(const_eval_select) = self.tcx.lang_items().const_eval_select_ct() {\n-                return Ok(Some(\n-                    ty::Instance::resolve(\n-                        *self.tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        const_eval_select,\n-                        instance.substs,\n-                    )\n-                    .unwrap()\n-                    .unwrap(),\n-                ));\n-            }\n-        } else if Some(def_id) == self.tcx.lang_items().panic_display()\n+        if Some(def_id) == self.tcx.lang_items().panic_display()\n             || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n         {\n             // &str or &&str\n@@ -205,34 +191,35 @@ impl interpret::MayLeak for ! {\n }\n \n impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n-    fn guaranteed_eq(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, bool> {\n+    /// See documentation on the `ptr_guaranteed_cmp` intrinsic.\n+    fn guaranteed_cmp(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, u8> {\n         Ok(match (a, b) {\n             // Comparisons between integers are always known.\n-            (Scalar::Int { .. }, Scalar::Int { .. }) => a == b,\n-            // Equality with integers can never be known for sure.\n-            (Scalar::Int { .. }, Scalar::Ptr(..)) | (Scalar::Ptr(..), Scalar::Int { .. }) => false,\n-            // FIXME: return `true` for when both sides are the same pointer, *except* that\n-            // some things (like functions and vtables) do not have stable addresses\n-            // so we need to be careful around them (see e.g. #73722).\n-            (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n-        })\n-    }\n-\n-    fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, bool> {\n-        Ok(match (a, b) {\n-            // Comparisons between integers are always known.\n-            (Scalar::Int(_), Scalar::Int(_)) => a != b,\n+            (Scalar::Int { .. }, Scalar::Int { .. }) => {\n+                if a == b {\n+                    1\n+                } else {\n+                    0\n+                }\n+            }\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n             // Inequality with integers other than null can never be known for sure.\n             (Scalar::Int(int), ptr @ Scalar::Ptr(..))\n-            | (ptr @ Scalar::Ptr(..), Scalar::Int(int)) => {\n-                int.is_null() && !self.scalar_may_be_null(ptr)?\n+            | (ptr @ Scalar::Ptr(..), Scalar::Int(int))\n+                if int.is_null() && !self.scalar_may_be_null(ptr)? =>\n+            {\n+                0\n             }\n-            // FIXME: return `true` for at least some comparisons where we can reliably\n+            // Equality with integers can never be known for sure.\n+            (Scalar::Int { .. }, Scalar::Ptr(..)) | (Scalar::Ptr(..), Scalar::Int { .. }) => 2,\n+            // FIXME: return a `1` for when both sides are the same pointer, *except* that\n+            // some things (like functions and vtables) do not have stable addresses\n+            // so we need to be careful around them (see e.g. #73722).\n+            // FIXME: return `0` for at least some comparisons where we can reliably\n             // determine the result of runtime inequality tests at compile-time.\n             // Examples include comparison of addresses in different static items.\n-            (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n+            (Scalar::Ptr(..), Scalar::Ptr(..)) => 2,\n         })\n     }\n }\n@@ -343,15 +330,11 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             throw_unsup_format!(\"intrinsic `{intrinsic_name}` is not supported at compile-time\");\n         };\n         match intrinsic_name {\n-            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+            sym::ptr_guaranteed_cmp => {\n                 let a = ecx.read_scalar(&args[0])?;\n                 let b = ecx.read_scalar(&args[1])?;\n-                let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n-                    ecx.guaranteed_eq(a, b)?\n-                } else {\n-                    ecx.guaranteed_ne(a, b)?\n-                };\n-                ecx.write_scalar(Scalar::from_bool(cmp), dest)?;\n+                let cmp = ecx.guaranteed_cmp(a, b)?;\n+                ecx.write_scalar(Scalar::from_u8(cmp), dest)?;\n             }\n             sym::const_allocate => {\n                 let size = ecx.read_scalar(&args[0])?.to_machine_usize(ecx)?;"}, {"sha": "1c33e7845cb0b0b813ac7fcb6cc8e45fb287f271", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -100,10 +100,10 @@ pub(crate) fn try_destructure_mir_constant<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     val: mir::ConstantKind<'tcx>,\n-) -> InterpResult<'tcx, mir::DestructuredMirConstant<'tcx>> {\n+) -> InterpResult<'tcx, mir::DestructuredConstant<'tcx>> {\n     trace!(\"destructure_mir_constant: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.mir_const_to_op(&val, None)?;\n+    let op = ecx.const_to_op(&val, None)?;\n \n     // We go to `usize` as we cannot allocate anything bigger anyway.\n     let (field_count, variant, down) = match val.ty().kind() {\n@@ -129,7 +129,7 @@ pub(crate) fn try_destructure_mir_constant<'tcx>(\n         .collect::<InterpResult<'tcx, Vec<_>>>()?;\n     let fields = tcx.arena.alloc_from_iter(fields_iter);\n \n-    Ok(mir::DestructuredMirConstant { variant, fields })\n+    Ok(mir::DestructuredConstant { variant, fields })\n }\n \n #[instrument(skip(tcx), level = \"debug\")]\n@@ -139,7 +139,7 @@ pub(crate) fn deref_mir_constant<'tcx>(\n     val: mir::ConstantKind<'tcx>,\n ) -> mir::ConstantKind<'tcx> {\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.mir_const_to_op(&val, None).unwrap();\n+    let op = ecx.const_to_op(&val, None).unwrap();\n     let mplace = ecx.deref_operand(&op).unwrap();\n     if let Some(alloc_id) = mplace.ptr.provenance {\n         assert_eq!("}, {"sha": "a964fe8465eeceefb96a68077e1297f34b577195", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -97,7 +97,7 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n         }\n \n         // Raw pointers are not allowed in type level constants, as we cannot properly test them for\n-        // equality at compile-time (see `ptr_guaranteed_eq`/`_ne`).\n+        // equality at compile-time (see `ptr_guaranteed_cmp`).\n         // Technically we could allow function pointers (represented as `ty::Instance`), but this is not guaranteed to\n         // agree with runtime equality tests.\n         ty::FnPtr(_) | ty::RawPtr(_) => Err(ValTreeCreationError::NonSupportedType),\n@@ -204,7 +204,7 @@ fn get_info_on_unsized_field<'tcx>(\n     (unsized_inner_ty, num_elems)\n }\n \n-#[instrument(skip(ecx), level = \"debug\")]\n+#[instrument(skip(ecx), level = \"debug\", ret)]\n fn create_pointee_place<'tcx>(\n     ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n     ty: Ty<'tcx>,\n@@ -237,14 +237,11 @@ fn create_pointee_place<'tcx>(\n         let ptr = ecx.allocate_ptr(size, align, MemoryKind::Stack).unwrap();\n         debug!(?ptr);\n \n-        let place = MPlaceTy::from_aligned_ptr_with_meta(\n+        MPlaceTy::from_aligned_ptr_with_meta(\n             ptr.into(),\n             layout,\n             MemPlaceMeta::Meta(Scalar::from_machine_usize(num_elems as u64, &tcx)),\n-        );\n-        debug!(?place);\n-\n-        place\n+        )\n     } else {\n         create_mplace_from_layout(ecx, ty)\n     }\n@@ -253,7 +250,7 @@ fn create_pointee_place<'tcx>(\n /// Converts a `ValTree` to a `ConstValue`, which is needed after mir\n /// construction has finished.\n // FIXME Merge `valtree_to_const_value` and `valtree_into_mplace` into one function\n-#[instrument(skip(tcx), level = \"debug\")]\n+#[instrument(skip(tcx), level = \"debug\", ret)]\n pub fn valtree_to_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n@@ -294,7 +291,7 @@ pub fn valtree_to_const_value<'tcx>(\n             dump_place(&ecx, place.into());\n             intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &place).unwrap();\n \n-            let const_val = match ty.kind() {\n+            match ty.kind() {\n                 ty::Ref(_, _, _) => {\n                     let ref_place = place.to_ref(&tcx);\n                     let imm =\n@@ -303,10 +300,7 @@ pub fn valtree_to_const_value<'tcx>(\n                     op_to_const(&ecx, &imm.into())\n                 }\n                 _ => op_to_const(&ecx, &place.into()),\n-            };\n-            debug!(?const_val);\n-\n-            const_val\n+            }\n         }\n         ty::Never\n         | ty::Error(_)"}, {"sha": "c6cb7a8b961ffbe9d7ea0742173ac0d465d85430", "filename": "compiler/rustc_const_eval/src/errors.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,8 +1,8 @@\n use rustc_hir::ConstContext;\n-use rustc_macros::SessionDiagnostic;\n+use rustc_macros::Diagnostic;\n use rustc_span::Span;\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::unstable_in_stable)]\n pub(crate) struct UnstableInStable {\n     pub gate: String,\n@@ -21,14 +21,14 @@ pub(crate) struct UnstableInStable {\n     pub attr_span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::thread_local_access, code = \"E0625\")]\n pub(crate) struct NonConstOpErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::static_access, code = \"E0013\")]\n #[help]\n pub(crate) struct StaticAccessErr {\n@@ -40,7 +40,7 @@ pub(crate) struct StaticAccessErr {\n     pub teach: Option<()>,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::raw_ptr_to_int)]\n #[note]\n #[note(const_eval::note2)]\n@@ -49,70 +49,70 @@ pub(crate) struct RawPtrToIntErr {\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::raw_ptr_comparison)]\n #[note]\n pub(crate) struct RawPtrComparisonErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::panic_non_str)]\n pub(crate) struct PanicNonStrErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::mut_deref, code = \"E0658\")]\n pub(crate) struct MutDerefErr {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::transient_mut_borrow, code = \"E0658\")]\n pub(crate) struct TransientMutBorrowErr {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::transient_mut_borrow_raw, code = \"E0658\")]\n pub(crate) struct TransientMutBorrowErrRaw {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::max_num_nodes_in_const)]\n pub(crate) struct MaxNumNodesInConstErr {\n     #[primary_span]\n     pub span: Span,\n     pub global_const_id: String,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::unallowed_fn_pointer_call)]\n pub(crate) struct UnallowedFnPointerCall {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::unstable_const_fn)]\n pub(crate) struct UnstableConstFn {\n     #[primary_span]\n     pub span: Span,\n     pub def_path: String,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::unallowed_mutable_refs, code = \"E0764\")]\n pub(crate) struct UnallowedMutableRefs {\n     #[primary_span]\n@@ -122,7 +122,7 @@ pub(crate) struct UnallowedMutableRefs {\n     pub teach: Option<()>,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::unallowed_mutable_refs_raw, code = \"E0764\")]\n pub(crate) struct UnallowedMutableRefsRaw {\n     #[primary_span]\n@@ -131,15 +131,15 @@ pub(crate) struct UnallowedMutableRefsRaw {\n     #[note(const_eval::teach_note)]\n     pub teach: Option<()>,\n }\n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::non_const_fmt_macro_call, code = \"E0015\")]\n pub(crate) struct NonConstFmtMacroCall {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::non_const_fn_call, code = \"E0015\")]\n pub(crate) struct NonConstFnCall {\n     #[primary_span]\n@@ -148,15 +148,15 @@ pub(crate) struct NonConstFnCall {\n     pub kind: ConstContext,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::unallowed_op_in_const_context)]\n pub(crate) struct UnallowedOpInConstContext {\n     #[primary_span]\n     pub span: Span,\n     pub msg: String,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::unallowed_heap_allocations, code = \"E0010\")]\n pub(crate) struct UnallowedHeapAllocations {\n     #[primary_span]\n@@ -167,15 +167,15 @@ pub(crate) struct UnallowedHeapAllocations {\n     pub teach: Option<()>,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::unallowed_inline_asm, code = \"E0015\")]\n pub(crate) struct UnallowedInlineAsm {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::interior_mutable_data_refer, code = \"E0492\")]\n pub(crate) struct InteriorMutableDataRefer {\n     #[primary_span]\n@@ -188,7 +188,7 @@ pub(crate) struct InteriorMutableDataRefer {\n     pub teach: Option<()>,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(const_eval::interior_mutability_borrow)]\n pub(crate) struct InteriorMutabilityBorrow {\n     #[primary_span]"}, {"sha": "cbe98548025bca306bdd0e82a1a0d60986d3235c", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -108,6 +108,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     _ => span_bug!(self.cur_span(), \"closure fn pointer on {:?}\", src.layout.ty),\n                 }\n             }\n+\n+            DynStar => {\n+                if let ty::Dynamic(data, _, ty::DynStar) = cast_ty.kind() {\n+                    // Initial cast from sized to dyn trait\n+                    let vtable = self.get_vtable_ptr(src.layout.ty, data.principal())?;\n+                    let vtable = Scalar::from_maybe_pointer(vtable, self);\n+                    let data = self.read_immediate(src)?.to_scalar();\n+                    let _assert_pointer_sized = data.to_pointer(self)?;\n+                    let val = Immediate::ScalarPair(data, vtable);\n+                    self.write_immediate(val, dest)?;\n+                } else {\n+                    bug!()\n+                }\n+            }\n         }\n         Ok(())\n     }\n@@ -312,7 +326,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let new_vptr = self.get_vtable_ptr(ty, data_b.principal())?;\n                 self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)\n             }\n-            (_, &ty::Dynamic(ref data, _)) => {\n+            (_, &ty::Dynamic(ref data, _, ty::Dyn)) => {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable_ptr(src_pointee_ty, data.principal())?;\n                 let ptr = self.read_scalar(src)?;"}, {"sha": "bdebfbb3ff51051a3a12e7be2dc75b327cbf7e3a", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -683,11 +683,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.stack_mut().push(frame);\n \n         // Make sure all the constants required by this frame evaluate successfully (post-monomorphization check).\n-        for const_ in &body.required_consts {\n-            let span = const_.span;\n-            let const_ =\n-                self.subst_from_current_frame_and_normalize_erasing_regions(const_.literal)?;\n-            self.mir_const_to_op(&const_, None).map_err(|err| {\n+        for ct in &body.required_consts {\n+            let span = ct.span;\n+            let ct = self.subst_from_current_frame_and_normalize_erasing_regions(ct.literal)?;\n+            self.const_to_op(&ct, None).map_err(|err| {\n                 // If there was an error, set the span of the current frame to this constant.\n                 // Avoiding doing this when evaluation succeeds.\n                 self.frame_mut().loc = Err(span);\n@@ -929,11 +928,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     #[must_use]\n-    pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n+    pub fn generate_stacktrace_from_stack(\n+        stack: &[Frame<'mir, 'tcx, M::Provenance, M::FrameExtra>],\n+    ) -> Vec<FrameInfo<'tcx>> {\n         let mut frames = Vec::new();\n         // This deliberately does *not* honor `requires_caller_location` since it is used for much\n         // more than just panics.\n-        for frame in self.stack().iter().rev() {\n+        for frame in stack.iter().rev() {\n             let lint_root = frame.current_source_info().and_then(|source_info| {\n                 match &frame.body.source_scopes[source_info.scope].local_data {\n                     mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n@@ -947,6 +948,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"generate stacktrace: {:#?}\", frames);\n         frames\n     }\n+\n+    #[must_use]\n+    pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n+        Self::generate_stacktrace_from_stack(self.stack())\n+    }\n }\n \n #[doc(hidden)]"}, {"sha": "24dbc769529c3665a6e30da12c750226a21ffd19", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -334,7 +334,7 @@ pub enum InternKind {\n /// tracks where in the value we are and thus can show much better error messages.\n /// Any errors here would anyway be turned into `const_err` lints, whereas validation failures\n /// are hard errors.\n-#[tracing::instrument(level = \"debug\", skip(ecx))]\n+#[instrument(level = \"debug\", skip(ecx))]\n pub fn intern_const_alloc_recursive<\n     'mir,\n     'tcx: 'mir,"}, {"sha": "8637d6a7767e4d14199d1aea8225d5d750c547f8", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n     self,\n     interpret::{ConstValue, GlobalId, InterpResult, PointerArithmetic, Scalar},\n-    BinOp,\n+    BinOp, NonDivergingIntrinsic,\n };\n use rustc_middle::ty;\n use rustc_middle::ty::layout::LayoutOf as _;\n@@ -79,9 +79,9 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n             ty::Projection(_)\n             | ty::Opaque(_, _)\n             | ty::Param(_)\n-            | ty::Bound(_, _)\n             | ty::Placeholder(_)\n             | ty::Infer(_) => throw_inval!(TooGeneric),\n+            ty::Bound(_, _) => bug!(\"bound ty during ctfe\"),\n             ty::Bool\n             | ty::Char\n             | ty::Int(_)\n@@ -95,7 +95,7 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n             | ty::Ref(_, _, _)\n             | ty::FnDef(_, _)\n             | ty::FnPtr(_)\n-            | ty::Dynamic(_, _)\n+            | ty::Dynamic(_, _, _)\n             | ty::Closure(_, _)\n             | ty::Generator(_, _, _)\n             | ty::GeneratorWitness(_)\n@@ -320,7 +320,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (a_offset, b_offset) =\n                     match (self.ptr_try_get_alloc_id(a), self.ptr_try_get_alloc_id(b)) {\n                         (Err(a), Err(b)) => {\n-                            // Neither poiner points to an allocation.\n+                            // Neither pointer points to an allocation.\n                             // If these are inequal or null, this *will* fail the deref check below.\n                             (a, b)\n                         }\n@@ -506,12 +506,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // These just return their argument\n                 self.copy_op(&args[0], dest, /*allow_transmute*/ false)?;\n             }\n-            sym::assume => {\n-                let cond = self.read_scalar(&args[0])?.to_bool()?;\n-                if !cond {\n-                    throw_ub_format!(\"`assume` intrinsic called with `false`\");\n-                }\n-            }\n             sym::raw_eq => {\n                 let result = self.raw_eq_intrinsic(&args[0], &args[1])?;\n                 self.write_scalar(result, dest)?;\n@@ -536,6 +530,32 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(true)\n     }\n \n+    pub(super) fn emulate_nondiverging_intrinsic(\n+        &mut self,\n+        intrinsic: &NonDivergingIntrinsic<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        match intrinsic {\n+            NonDivergingIntrinsic::Assume(op) => {\n+                let op = self.eval_operand(op, None)?;\n+                let cond = self.read_scalar(&op)?.to_bool()?;\n+                if !cond {\n+                    throw_ub_format!(\"`assume` called with `false`\");\n+                }\n+                Ok(())\n+            }\n+            NonDivergingIntrinsic::CopyNonOverlapping(mir::CopyNonOverlapping {\n+                count,\n+                src,\n+                dst,\n+            }) => {\n+                let src = self.eval_operand(src, None)?;\n+                let dst = self.eval_operand(dst, None)?;\n+                let count = self.eval_operand(count, None)?;\n+                self.copy_intrinsic(&src, &dst, &count, /* nonoverlapping */ true)\n+            }\n+        }\n+    }\n+\n     pub fn exact_div(\n         &mut self,\n         a: &ImmTy<'tcx, M::Provenance>,"}, {"sha": "0e3867557ada3c6694eee61948dabf5200830d68", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -4,7 +4,6 @@ use rustc_ast::Mutability;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::mir::TerminatorKind;\n use rustc_middle::ty::layout::LayoutOf;\n-use rustc_middle::ty::subst::Subst;\n use rustc_span::{Span, Symbol};\n \n use crate::interpret::{"}, {"sha": "7e4c5fcb031b0bdf8473c0a2f4e8294a261de4a1", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             | ty::FnPtr(_)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Dynamic(_, _) => self.pretty_print_type(ty),\n+            | ty::Dynamic(_, _, _) => self.pretty_print_type(ty),\n \n             // Placeholders (all printed as `_` to uniformize them).\n             ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error(_) => {"}, {"sha": "530e252b7c077ed0a0f4d0cfdb2c0d5c3357a62b", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -6,6 +6,7 @@ use std::borrow::{Borrow, Cow};\n use std::fmt::Debug;\n use std::hash::Hash;\n \n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::DefId;\n@@ -323,6 +324,15 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n     ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra>>>;\n \n+    fn eval_inline_asm(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _template: &'tcx [InlineAsmTemplatePiece],\n+        _operands: &[mir::InlineAsmOperand<'tcx>],\n+        _options: InlineAsmOptions,\n+    ) -> InterpResult<'tcx> {\n+        throw_unsup_format!(\"inline assembly is not supported\")\n+    }\n+\n     /// Hook for performing extra checks on a memory read access.\n     ///\n     /// Takes read-only access to the allocation so we can keep all the memory read"}, {"sha": "ed155fbfef087e3fab4b188b53efcda489cc295b", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -437,7 +437,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         msg,\n                     })\n                 }\n-                // Ensure we never consider the null pointer dereferencable.\n+                // Ensure we never consider the null pointer dereferenceable.\n                 if M::Provenance::OFFSET_IS_ADDR {\n                     assert_ne!(ptr.addr(), Size::ZERO);\n                 }\n@@ -914,7 +914,7 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n         self.write_scalar(alloc_range(offset, self.tcx.data_layout().pointer_size), val)\n     }\n \n-    /// Mark the entire referenced range as uninitalized\n+    /// Mark the entire referenced range as uninitialized\n     pub fn write_uninit(&mut self) -> InterpResult<'tcx> {\n         Ok(self\n             .alloc"}, {"sha": "510adde62962bac35727514cbf9a57902c969865", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -534,7 +534,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // * During ConstProp, with `TooGeneric` or since the `required_consts` were not all\n                 //   checked yet.\n                 // * During CTFE, since promoteds in `const`/`static` initializer bodies can fail.\n-                self.mir_const_to_op(&val, layout)?\n+                self.const_to_op(&val, layout)?\n             }\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n@@ -549,43 +549,47 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ops.iter().map(|op| self.eval_operand(op, None)).collect()\n     }\n \n-    // Used when the miri-engine runs into a constant and for extracting information from constants\n-    // in patterns via the `const_eval` module\n-    /// The `val` and `layout` are assumed to already be in our interpreter\n-    /// \"universe\" (param_env).\n     pub fn const_to_op(\n         &self,\n-        c: ty::Const<'tcx>,\n+        val: &mir::ConstantKind<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n-        match c.kind() {\n-            ty::ConstKind::Param(_) | ty::ConstKind::Bound(..) => throw_inval!(TooGeneric),\n-            ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => {\n-                throw_inval!(AlreadyReported(reported))\n+        match val {\n+            mir::ConstantKind::Ty(ct) => {\n+                match ct.kind() {\n+                    ty::ConstKind::Param(_) | ty::ConstKind::Placeholder(..) => {\n+                        throw_inval!(TooGeneric)\n+                    }\n+                    ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => {\n+                        throw_inval!(AlreadyReported(reported))\n+                    }\n+                    ty::ConstKind::Unevaluated(uv) => {\n+                        // NOTE: We evaluate to a `ValTree` here as a check to ensure\n+                        // we're working with valid constants, even though we never need it.\n+                        let instance = self.resolve(uv.def, uv.substs)?;\n+                        let cid = GlobalId { instance, promoted: None };\n+                        let _valtree = self\n+                            .tcx\n+                            .eval_to_valtree(self.param_env.and(cid))?\n+                            .unwrap_or_else(|| bug!(\"unable to create ValTree for {uv:?}\"));\n+\n+                        Ok(self.eval_to_allocation(cid)?.into())\n+                    }\n+                    ty::ConstKind::Bound(..) | ty::ConstKind::Infer(..) => {\n+                        span_bug!(self.cur_span(), \"unexpected ConstKind in ctfe: {ct:?}\")\n+                    }\n+                    ty::ConstKind::Value(valtree) => {\n+                        let ty = ct.ty();\n+                        let const_val = self.tcx.valtree_to_const_val((ty, valtree));\n+                        self.const_val_to_op(const_val, ty, layout)\n+                    }\n+                }\n             }\n-            ty::ConstKind::Unevaluated(uv) => {\n+            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, *ty, layout),\n+            mir::ConstantKind::Unevaluated(uv, _) => {\n                 let instance = self.resolve(uv.def, uv.substs)?;\n                 Ok(self.eval_to_allocation(GlobalId { instance, promoted: uv.promoted })?.into())\n             }\n-            ty::ConstKind::Infer(..) | ty::ConstKind::Placeholder(..) => {\n-                span_bug!(self.cur_span(), \"const_to_op: Unexpected ConstKind {:?}\", c)\n-            }\n-            ty::ConstKind::Value(valtree) => {\n-                let ty = c.ty();\n-                let const_val = self.tcx.valtree_to_const_val((ty, valtree));\n-                self.const_val_to_op(const_val, ty, layout)\n-            }\n-        }\n-    }\n-\n-    pub fn mir_const_to_op(\n-        &self,\n-        val: &mir::ConstantKind<'tcx>,\n-        layout: Option<TyAndLayout<'tcx>>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n-        match val {\n-            mir::ConstantKind::Ty(ct) => self.const_to_op(*ct, layout),\n-            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, *ty, layout),\n         }\n     }\n \n@@ -718,7 +722,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Return the cast value, and the index.\n                 (discr_val, index.0)\n             }\n-            TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+            TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n                 let tag_val = tag_val.to_scalar();\n                 // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n                 // discriminant (encoded in niche/tag) and variant index are the same.\n@@ -736,7 +740,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         if !ptr_valid {\n                             throw_ub!(InvalidTag(dbg_val))\n                         }\n-                        dataful_variant\n+                        untagged_variant\n                     }\n                     Ok(tag_bits) => {\n                         let tag_bits = tag_bits.assert_bits(tag_layout.size);\n@@ -766,7 +770,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             assert!(usize::try_from(variant_index).unwrap() < variants_len);\n                             VariantIdx::from_u32(variant_index)\n                         } else {\n-                            dataful_variant\n+                            untagged_variant\n                         }\n                     }\n                 };\n@@ -785,8 +789,8 @@ mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(Immediate, 56);\n-    static_assert_size!(ImmTy<'_>, 72);\n-    static_assert_size!(Operand, 64);\n-    static_assert_size!(OpTy<'_>, 88);\n+    static_assert_size!(Immediate, 48);\n+    static_assert_size!(ImmTy<'_>, 64);\n+    static_assert_size!(Operand, 56);\n+    static_assert_size!(OpTy<'_>, 80);\n }"}, {"sha": "7a01b85381a3fc3c9866083267bf056ec29af385", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -280,7 +280,7 @@ impl<'tcx, Prov: Provenance> PlaceTy<'tcx, Prov> {\n \n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Prov> {\n+    pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n         self.try_as_mplace().unwrap()\n     }\n }\n@@ -817,15 +817,15 @@ where\n             }\n             abi::Variants::Multiple {\n                 tag_encoding:\n-                    TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+                    TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n                 tag: tag_layout,\n                 tag_field,\n                 ..\n             } => {\n                 // No need to validate that the discriminant here because the\n                 // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n \n-                if variant_index != dataful_variant {\n+                if variant_index != untagged_variant {\n                     let variants_start = niche_variants.start().as_u32();\n                     let variant_index_relative = variant_index\n                         .as_u32()\n@@ -890,6 +890,6 @@ mod size_asserts {\n     static_assert_size!(MemPlaceMeta, 24);\n     static_assert_size!(MemPlace, 40);\n     static_assert_size!(MPlaceTy<'_>, 64);\n-    static_assert_size!(Place, 48);\n-    static_assert_size!(PlaceTy<'_>, 72);\n+    static_assert_size!(Place, 40);\n+    static_assert_size!(PlaceTy<'_>, 64);\n }"}, {"sha": "6b2e2bb8aca8c604ce9fde02652de85675af3b09", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,6 +1,6 @@\n //! This file implements \"place projections\"; basically a symmetric API for 3 types: MPlaceTy, OpTy, PlaceTy.\n //!\n-//! OpTy and PlaceTy genrally work by \"let's see if we are actually an MPlaceTy, and do something custom if not\".\n+//! OpTy and PlaceTy generally work by \"let's see if we are actually an MPlaceTy, and do something custom if not\".\n //! For PlaceTy, the custom thing is basically always to call `force_allocation` and then use the MPlaceTy logic anyway.\n //! For OpTy, the custom thing on field pojections has to be pretty clever (since `Operand::Immediate` can have fields),\n //! but for array/slice operations it only has to worry about `Operand::Uninit`. That makes the value part trivial,\n@@ -350,6 +350,11 @@ where\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::Provenance>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n+            OpaqueCast(ty) => {\n+                let mut place = base.clone();\n+                place.layout = self.layout_of(ty)?;\n+                place\n+            }\n             Field(field, _) => self.place_field(base, field.index())?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n             Deref => self.deref_operand(&self.place_to_op(base)?)?.into(),\n@@ -374,6 +379,11 @@ where\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n+            OpaqueCast(ty) => {\n+                let mut op = base.clone();\n+                op.layout = self.layout_of(ty)?;\n+                op\n+            }\n             Field(field, _) => self.operand_field(base, field.index())?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),"}, {"sha": "c6e04cbfb6bf344200dcc916378ad8df4adcd454", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -114,13 +114,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 M::retag(self, *kind, &dest)?;\n             }\n \n-            // Call CopyNonOverlapping\n-            CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping { src, dst, count }) => {\n-                let src = self.eval_operand(src, None)?;\n-                let dst = self.eval_operand(dst, None)?;\n-                let count = self.eval_operand(count, None)?;\n-                self.copy_intrinsic(&src, &dst, &count, /* nonoverlapping */ true)?;\n-            }\n+            Intrinsic(box ref intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n \n             // Statements we do not track.\n             AscribeUserType(..) => {}"}, {"sha": "50a82aa0e72c9c7fe55013f4f6e73cae8e55ba70", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,5 +1,6 @@\n use std::borrow::Cow;\n \n+use rustc_ast::ast::InlineAsmOptions;\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_middle::ty::Instance;\n use rustc_middle::{\n@@ -166,8 +167,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 terminator.kind\n             ),\n \n-            // Inline assembly can't be interpreted.\n-            InlineAsm { .. } => throw_unsup_format!(\"inline assembly is not supported\"),\n+            InlineAsm { template, ref operands, options, destination, .. } => {\n+                M::eval_inline_asm(self, template, operands, options)?;\n+                if options.contains(InlineAsmOptions::NORETURN) {\n+                    throw_ub_format!(\"returned from noreturn inline assembly\");\n+                }\n+                self.go_to_block(\n+                    destination\n+                        .expect(\"InlineAsm terminators without noreturn must have a destination\"),\n+                )\n+            }\n         }\n \n         Ok(())\n@@ -217,7 +226,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // When comparing the PassMode, we have to be smart about comparing the attributes.\n         let arg_attr_compat = |a1: &ArgAttributes, a2: &ArgAttributes| {\n             // There's only one regular attribute that matters for the call ABI: InReg.\n-            // Everything else is things like noalias, dereferencable, nonnull, ...\n+            // Everything else is things like noalias, dereferenceable, nonnull, ...\n             // (This also applies to pointee_size, pointee_align.)\n             if a1.regular.contains(ArgAttribute::InReg) != a2.regular.contains(ArgAttribute::InReg)\n             {\n@@ -556,7 +565,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     .tcx\n                     .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env);\n                 let ty::Dynamic(data, ..) = receiver_tail.kind() else {\n-                    span_bug!(self.cur_span(), \"dyanmic call on non-`dyn` type {}\", receiver_tail)\n+                    span_bug!(self.cur_span(), \"dynamic call on non-`dyn` type {}\", receiver_tail)\n                 };\n \n                 // Get the required information from the vtable."}, {"sha": "cab23b7241ffc2ea2649103b83552c091d00119a", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -32,7 +32,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(vtable_ptr.into())\n     }\n \n-    /// Returns a high-level representation of the entires of the given vtable.\n+    /// Returns a high-level representation of the entries of the given vtable.\n     pub fn get_vtable_entries(\n         &self,\n         vtable: Pointer<Option<M::Provenance>>,"}, {"sha": "14aaee6ac3f9ea1168dccb5c502aa6e90dc0c0b0", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -5,7 +5,7 @@\n //! to be const-safe.\n \n use std::convert::TryFrom;\n-use std::fmt::Write;\n+use std::fmt::{Display, Write};\n use std::num::NonZeroUsize;\n \n use rustc_ast::Mutability;\n@@ -311,7 +311,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     fn read_immediate(\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n-        expected: &str,\n+        expected: impl Display,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::Provenance>> {\n         Ok(try_validation!(\n             self.ecx.read_immediate(op),\n@@ -323,7 +323,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     fn read_scalar(\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n-        expected: &str,\n+        expected: impl Display,\n     ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n         Ok(self.read_immediate(op, expected)?.to_scalar())\n     }\n@@ -368,7 +368,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         value: &OpTy<'tcx, M::Provenance>,\n         kind: &str,\n     ) -> InterpResult<'tcx> {\n-        let place = self.ecx.ref_to_mplace(&self.read_immediate(value, &format!(\"a {kind}\"))?)?;\n+        let place =\n+            self.ecx.ref_to_mplace(&self.read_immediate(value, format_args!(\"a {kind}\"))?)?;\n         // Handle wide pointers.\n         // Check metadata early, for better diagnostics\n         if place.layout.is_unsized() {"}, {"sha": "7c4c7db1035b411cf29d6d832a721f1bb4fa835a", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -10,7 +10,6 @@ Rust MIR: a lowered representation of Rust.\n #![feature(decl_macro)]\n #![feature(exact_size_is_empty)]\n #![feature(let_chains)]\n-#![feature(let_else)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n #![feature(slice_ptr_get)]"}, {"sha": "b0dcbf76b01b0a62c4f53280d4e35eaeaf24e913", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -13,8 +13,11 @@ use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty,\n use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeVisitable};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n-use rustc_trait_selection::traits::SelectionContext;\n+use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::{\n+    self, ObligationCauseCode, SelectionContext, TraitEngine, TraitEngineExt,\n+};\n \n use std::mem;\n use std::ops::Deref;\n@@ -546,6 +549,10 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 // Since no pointer can ever get exposed (rejected above), this is easy to support.\n             }\n \n+            Rvalue::Cast(CastKind::DynStar, _, _) => {\n+                unimplemented!()\n+            }\n+\n             Rvalue::Cast(CastKind::Misc, _, _) => {}\n \n             Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) => {}\n@@ -652,6 +659,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n             ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Downcast(..)\n+            | ProjectionElem::OpaqueCast(..)\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(_) => {}\n@@ -678,7 +686,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             | StatementKind::Retag { .. }\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n-            | StatementKind::CopyNonOverlapping(..)\n+            | StatementKind::Intrinsic(..)\n             | StatementKind::Nop => {}\n         }\n     }\n@@ -734,6 +742,43 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                         selcx.select(&obligation)\n                     });\n \n+                    // do a well-formedness check on the trait method being called. This is because typeck only does a\n+                    // \"non-const\" check. This is required for correctness here.\n+                    tcx.infer_ctxt().enter(|infcx| {\n+                        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+                        let predicates = tcx.predicates_of(callee).instantiate(tcx, substs);\n+                        let hir_id = tcx\n+                            .hir()\n+                            .local_def_id_to_hir_id(self.body.source.def_id().expect_local());\n+                        let cause = || {\n+                            ObligationCause::new(\n+                                terminator.source_info.span,\n+                                hir_id,\n+                                ObligationCauseCode::ItemObligation(callee),\n+                            )\n+                        };\n+                        let normalized = infcx.partially_normalize_associated_types_in(\n+                            cause(),\n+                            param_env,\n+                            predicates,\n+                        );\n+\n+                        for p in normalized.obligations {\n+                            fulfill_cx.register_predicate_obligation(&infcx, p);\n+                        }\n+                        for obligation in traits::predicates_for_generics(\n+                            |_, _| cause(),\n+                            self.param_env,\n+                            normalized.value,\n+                        ) {\n+                            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+                        }\n+                        let errors = fulfill_cx.select_all_or_error(&infcx);\n+                        if !errors.is_empty() {\n+                            infcx.report_fulfillment_errors(&errors, None, false);\n+                        }\n+                    });\n+\n                     match implsrc {\n                         Ok(Some(ImplSource::Param(_, ty::BoundConstness::ConstIfConst))) => {\n                             debug!(\n@@ -964,7 +1009,10 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n                 if needs_non_const_drop {\n                     self.check_op_spanned(\n-                        ops::LiveDrop { dropped_at: Some(terminator.source_info.span) },\n+                        ops::LiveDrop {\n+                            dropped_at: Some(terminator.source_info.span),\n+                            dropped_ty: ty_of_dropped_place,\n+                        },\n                         err_span,\n                     );\n                 }"}, {"sha": "b56b230201ed406336aa145065b8086e445a4ccd", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -422,10 +422,11 @@ impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n }\n \n #[derive(Debug)]\n-pub struct LiveDrop {\n+pub struct LiveDrop<'tcx> {\n     pub dropped_at: Option<Span>,\n+    pub dropped_ty: Ty<'tcx>,\n }\n-impl<'tcx> NonConstOp<'tcx> for LiveDrop {\n+impl<'tcx> NonConstOp<'tcx> for LiveDrop<'tcx> {\n     fn build_error(\n         &self,\n         ccx: &ConstCx<'_, 'tcx>,\n@@ -435,9 +436,13 @@ impl<'tcx> NonConstOp<'tcx> for LiveDrop {\n             ccx.tcx.sess,\n             span,\n             E0493,\n-            \"destructors cannot be evaluated at compile-time\"\n+            \"destructor of `{}` cannot be evaluated at compile-time\",\n+            self.dropped_ty,\n+        );\n+        err.span_label(\n+            span,\n+            format!(\"the destructor for this type cannot be evaluated in {}s\", ccx.const_kind()),\n         );\n-        err.span_label(span, format!(\"{}s cannot evaluate destructors\", ccx.const_kind()));\n         if let Some(span) = self.dropped_at {\n             err.span_label(span, \"value is dropped here\");\n         }"}, {"sha": "d4570c59889145e3b885b41e5939649f7246ac4c", "filename": "compiler/rustc_const_eval/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,6 +1,6 @@\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{self, BasicBlock, Location};\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_span::{symbol::sym, Span};\n \n use super::check::Qualifs;\n@@ -58,9 +58,9 @@ impl<'mir, 'tcx> std::ops::Deref for CheckLiveDrops<'mir, 'tcx> {\n     }\n }\n \n-impl CheckLiveDrops<'_, '_> {\n-    fn check_live_drop(&self, span: Span) {\n-        ops::LiveDrop { dropped_at: None }.build_error(self.ccx, span).emit();\n+impl<'tcx> CheckLiveDrops<'_, 'tcx> {\n+    fn check_live_drop(&self, span: Span, dropped_ty: Ty<'tcx>) {\n+        ops::LiveDrop { dropped_at: None, dropped_ty }.build_error(self.ccx, span).emit();\n     }\n }\n \n@@ -90,7 +90,7 @@ impl<'tcx> Visitor<'tcx> for CheckLiveDrops<'_, 'tcx> {\n                 }\n \n                 if dropped_place.is_indirect() {\n-                    self.check_live_drop(terminator.source_info.span);\n+                    self.check_live_drop(terminator.source_info.span, dropped_ty);\n                     return;\n                 }\n \n@@ -101,7 +101,7 @@ impl<'tcx> Visitor<'tcx> for CheckLiveDrops<'_, 'tcx> {\n                 if self.qualifs.needs_non_const_drop(self.ccx, dropped_place.local, location) {\n                     // Use the span where the dropped local was declared for the error.\n                     let span = self.body.local_decls[dropped_place.local].source_info.span;\n-                    self.check_live_drop(span);\n+                    self.check_live_drop(span, dropped_ty);\n                 }\n             }\n "}, {"sha": "60deb0abd344db06d1a933b2c741c08b71050569", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -5,6 +5,7 @@\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::LangItem;\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_middle::mir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n@@ -308,6 +309,7 @@ where\n \n             ProjectionElem::Deref\n             | ProjectionElem::Field(_, _)\n+            | ProjectionElem::OpaqueCast(_)\n             | ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Downcast(_, _)\n@@ -346,31 +348,36 @@ where\n     };\n \n     // Check the qualifs of the value of `const` items.\n-    if let Some(ct) = constant.literal.const_for_ty() {\n-        if let ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs: _, promoted }) = ct.kind()\n-        {\n-            // Use qualifs of the type for the promoted. Promoteds in MIR body should be possible\n-            // only for `NeedsNonConstDrop` with precise drop checking. This is the only const\n-            // check performed after the promotion. Verify that with an assertion.\n-            assert!(promoted.is_none() || Q::ALLOW_PROMOTED);\n-            // Don't peek inside trait associated constants.\n-            if promoted.is_none() && cx.tcx.trait_of_item(def.did).is_none() {\n-                let qualifs = if let Some((did, param_did)) = def.as_const_arg() {\n-                    cx.tcx.at(constant.span).mir_const_qualif_const_arg((did, param_did))\n-                } else {\n-                    cx.tcx.at(constant.span).mir_const_qualif(def.did)\n-                };\n-\n-                if !Q::in_qualifs(&qualifs) {\n-                    return false;\n-                }\n+    // FIXME(valtrees): check whether const qualifs should behave the same\n+    // way for type and mir constants.\n+    let uneval = match constant.literal {\n+        ConstantKind::Ty(ct) if matches!(ct.kind(), ty::ConstKind::Param(_)) => None,\n+        ConstantKind::Ty(c) => bug!(\"expected ConstKind::Param here, found {:?}\", c),\n+        ConstantKind::Unevaluated(uv, _) => Some(uv),\n+        ConstantKind::Val(..) => None,\n+    };\n+\n+    if let Some(mir::UnevaluatedConst { def, substs: _, promoted }) = uneval {\n+        // Use qualifs of the type for the promoted. Promoteds in MIR body should be possible\n+        // only for `NeedsNonConstDrop` with precise drop checking. This is the only const\n+        // check performed after the promotion. Verify that with an assertion.\n+        assert!(promoted.is_none() || Q::ALLOW_PROMOTED);\n+\n+        // Don't peek inside trait associated constants.\n+        if promoted.is_none() && cx.tcx.trait_of_item(def.did).is_none() {\n+            assert_eq!(def.const_param_did, None, \"expected associated const: {def:?}\");\n+            let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def.did);\n \n-                // Just in case the type is more specific than\n-                // the definition, e.g., impl associated const\n-                // with type parameters, take it into account.\n+            if !Q::in_qualifs(&qualifs) {\n+                return false;\n             }\n+\n+            // Just in case the type is more specific than\n+            // the definition, e.g., impl associated const\n+            // with type parameters, take it into account.\n         }\n     }\n+\n     // Otherwise use the qualifs of the type.\n     Q::in_any_value_of_ty(cx, constant.literal.ty())\n }"}, {"sha": "4b219300739c0812a42d38daf9a1d362d3b380a5", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -13,6 +13,7 @@\n //! move analysis runs after promotion on broken MIR.\n \n use rustc_hir as hir;\n+use rustc_middle::mir;\n use rustc_middle::mir::traversal::ReversePostorderIter;\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n@@ -361,7 +362,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             return Err(Unpromotable);\n                         }\n                     }\n-                    ProjectionElem::Downcast(..) => {\n+                    ProjectionElem::OpaqueCast(..) | ProjectionElem::Downcast(..) => {\n                         return Err(Unpromotable);\n                     }\n \n@@ -840,21 +841,15 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 promoted.span = span;\n                 promoted.local_decls[RETURN_PLACE] = LocalDecl::new(ty, span);\n                 let substs = tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def.did));\n-                let _const = tcx.mk_const(ty::ConstS {\n-                    ty,\n-                    kind: ty::ConstKind::Unevaluated(ty::Unevaluated {\n-                        def,\n-                        substs,\n-                        promoted: Some(promoted_id),\n-                    }),\n-                });\n+                let uneval = mir::UnevaluatedConst { def, substs, promoted: Some(promoted_id) };\n \n                 Operand::Constant(Box::new(Constant {\n                     span,\n                     user_ty: None,\n-                    literal: ConstantKind::from_const(_const, tcx),\n+                    literal: ConstantKind::Unevaluated(uneval, ty),\n                 }))\n             };\n+\n             let blocks = self.source.basic_blocks.as_mut();\n             let local_decls = &mut self.source.local_decls;\n             let loc = candidate.location;"}, {"sha": "9c95ffca19bc035c8ce5e39d009927ac80e5df6f", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -7,12 +7,12 @@ use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n-    traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, CastKind, Local, Location,\n-    MirPass, MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, RuntimePhase, Rvalue,\n-    SourceScope, Statement, StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n+    traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, CastKind, CopyNonOverlapping,\n+    Local, Location, MirPass, MirPhase, NonDivergingIntrinsic, Operand, Place, PlaceElem, PlaceRef,\n+    ProjectionElem, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n+    TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::fold::BottomUpFolder;\n-use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n@@ -89,20 +89,21 @@ pub fn equal_up_to_regions<'tcx>(\n \n     // Normalize lifetimes away on both sides, then compare.\n     let normalize = |ty: Ty<'tcx>| {\n-        let ty = ty.fold_with(&mut BottomUpFolder {\n-            tcx,\n-            // FIXME: We erase all late-bound lifetimes, but this is not fully correct.\n-            // If you have a type like `<for<'a> fn(&'a u32) as SomeTrait>::Assoc`,\n-            // this is not necessarily equivalent to `<fn(&'static u32) as SomeTrait>::Assoc`,\n-            // since one may have an `impl SomeTrait for fn(&32)` and\n-            // `impl SomeTrait for fn(&'static u32)` at the same time which\n-            // specify distinct values for Assoc. (See also #56105)\n-            lt_op: |_| tcx.lifetimes.re_erased,\n-            // Leave consts and types unchanged.\n-            ct_op: |ct| ct,\n-            ty_op: |ty| ty,\n-        });\n-        tcx.try_normalize_erasing_regions(param_env, ty).unwrap_or(ty)\n+        tcx.try_normalize_erasing_regions(param_env, ty).unwrap_or(ty).fold_with(\n+            &mut BottomUpFolder {\n+                tcx,\n+                // FIXME: We erase all late-bound lifetimes, but this is not fully correct.\n+                // If you have a type like `<for<'a> fn(&'a u32) as SomeTrait>::Assoc`,\n+                // this is not necessarily equivalent to `<fn(&'static u32) as SomeTrait>::Assoc`,\n+                // since one may have an `impl SomeTrait for fn(&32)` and\n+                // `impl SomeTrait for fn(&'static u32)` at the same time which\n+                // specify distinct values for Assoc. (See also #56105)\n+                lt_op: |_| tcx.lifetimes.re_erased,\n+                // Leave consts and types unchanged.\n+                ct_op: |ct| ct,\n+                ty_op: |ty| ty,\n+            },\n+        )\n     };\n     tcx.infer_ctxt().enter(|infcx| infcx.can_eq(param_env, normalize(src), normalize(dest)).is_ok())\n }\n@@ -181,16 +182,23 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if (src, dest).has_opaque_types() {\n             return true;\n         }\n-        // Normalize projections and things like that.\n-        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n-        let src = self.tcx.normalize_erasing_regions(param_env, src);\n-        let dest = self.tcx.normalize_erasing_regions(param_env, dest);\n \n+        // Normalize projections and things like that.\n         // Type-changing assignments can happen when subtyping is used. While\n         // all normal lifetimes are erased, higher-ranked types with their\n         // late-bound lifetimes are still around and can lead to type\n         // differences. So we compare ignoring lifetimes.\n-        equal_up_to_regions(self.tcx, param_env, src, dest)\n+\n+        // First, try with reveal_all. This might not work in some cases, as the predicates\n+        // can be cleared in reveal_all mode. We try the reveal first anyways as it is used\n+        // by some other passes like inlining as well.\n+        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n+        if equal_up_to_regions(self.tcx, param_env, src, dest) {\n+            return true;\n+        }\n+\n+        // If this fails, we can try it without the reveal.\n+        equal_up_to_regions(self.tcx, self.param_env, src, dest)\n     }\n }\n \n@@ -560,6 +568,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                             );\n                         }\n                     }\n+                    CastKind::DynStar => {\n+                        // FIXME(dyn-star): make sure nothing needs to be done here.\n+                    }\n                     // Nothing to check here\n                     CastKind::PointerFromExposedAddress\n                     | CastKind::PointerExposeAddress\n@@ -629,11 +640,18 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n-                ref src,\n-                ref dst,\n-                ref count,\n-            }) => {\n+            StatementKind::Intrinsic(box NonDivergingIntrinsic::Assume(op)) => {\n+                let ty = op.ty(&self.body.local_decls, self.tcx);\n+                if !ty.is_bool() {\n+                    self.fail(\n+                        location,\n+                        format!(\"`assume` argument must be `bool`, but got: `{}`\", ty),\n+                    );\n+                }\n+            }\n+            StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(\n+                CopyNonOverlapping { src, dst, count },\n+            )) => {\n                 let src_ty = src.ty(&self.body.local_decls, self.tcx);\n                 let op_src_ty = if let Some(src_deref) = src_ty.builtin_deref(true) {\n                     src_deref.ty"}, {"sha": "2d8658db5e6aacb45eed5283d42b1c67d148b41d", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -8,25 +8,26 @@ doctest = false\n \n [dependencies]\n arrayvec = { version = \"0.7\", default-features = false }\n+bitflags = \"1.2.1\"\n+cfg-if = \"0.1.2\"\n ena = \"0.14\"\n indexmap = { version = \"1.9.1\" }\n-tracing = \"0.1\"\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n-rustc_macros = { path = \"../rustc_macros\" }\n-rustc_graphviz = { path = \"../rustc_graphviz\" }\n-cfg-if = \"0.1.2\"\n-stable_deref_trait = \"1.0.0\"\n-rayon = { version = \"0.4.0\", package = \"rustc-rayon\", optional = true }\n+libc = \"0.2\"\n+measureme = \"10.0.0\"\n rayon-core = { version = \"0.4.0\", package = \"rustc-rayon-core\", optional = true }\n+rayon = { version = \"0.4.0\", package = \"rustc-rayon\", optional = true }\n+rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc-hash = \"1.1.0\"\n-smallvec = { version = \"1.8.1\", features = [\"const_generics\", \"union\", \"may_dangle\"] }\n rustc_index = { path = \"../rustc_index\", package = \"rustc_index\" }\n-bitflags = \"1.2.1\"\n-measureme = \"10.0.0\"\n-libc = \"0.2\"\n+rustc_macros = { path = \"../rustc_macros\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+smallvec = { version = \"1.8.1\", features = [\"const_generics\", \"union\", \"may_dangle\"] }\n+stable_deref_trait = \"1.0.0\"\n stacker = \"0.1.14\"\n tempfile = \"3.2\"\n+thin-vec = \"0.2.8\"\n+tracing = \"0.1\"\n \n [dependencies.parking_lot]\n version = \"0.11\""}, {"sha": "a39178016ce20617dda20a517959ae7843ade27b", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -29,7 +29,7 @@ impl Fingerprint {\n         // quality hash values, let's still combine the two values because the\n         // Fingerprints in DefPathHash have the StableCrateId portion which is\n         // the same for all DefPathHashes from the same crate. Combining the\n-        // two halfs makes sure we get a good quality hash in such cases too.\n+        // two halves makes sure we get a good quality hash in such cases too.\n         self.0.wrapping_mul(3).wrapping_add(self.1)\n     }\n \n@@ -120,7 +120,7 @@ impl FingerprintHasher for crate::unhash::Unhasher {\n         // quality hash values, let's still combine the two values because the\n         // Fingerprints in DefPathHash have the StableCrateId portion which is\n         // the same for all DefPathHashes from the same crate. Combining the\n-        // two halfs makes sure we get a good quality hash in such cases too.\n+        // two halves makes sure we get a good quality hash in such cases too.\n         //\n         // Since `Unhasher` is used only in the context of HashMaps, it is OK\n         // to combine the two components in an order-independent way (which is"}, {"sha": "0d0c51b6819460f58ddfd8f8faec421d451f6829", "filename": "compiler/rustc_data_structures/src/fx.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -2,13 +2,26 @@ use std::hash::BuildHasherDefault;\n \n pub use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n \n+pub type StdEntry<'a, K, V> = std::collections::hash_map::Entry<'a, K, V>;\n+\n pub type FxIndexMap<K, V> = indexmap::IndexMap<K, V, BuildHasherDefault<FxHasher>>;\n pub type FxIndexSet<V> = indexmap::IndexSet<V, BuildHasherDefault<FxHasher>>;\n+pub type IndexEntry<'a, K, V> = indexmap::map::Entry<'a, K, V>;\n \n #[macro_export]\n macro_rules! define_id_collections {\n-    ($map_name:ident, $set_name:ident, $key:ty) => {\n+    ($map_name:ident, $set_name:ident, $entry_name:ident, $key:ty) => {\n         pub type $map_name<T> = $crate::fx::FxHashMap<$key, T>;\n         pub type $set_name = $crate::fx::FxHashSet<$key>;\n+        pub type $entry_name<'a, T> = $crate::fx::StdEntry<'a, $key, T>;\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! define_stable_id_collections {\n+    ($map_name:ident, $set_name:ident, $entry_name:ident, $key:ty) => {\n+        pub type $map_name<T> = $crate::fx::FxIndexMap<$key, T>;\n+        pub type $set_name = $crate::fx::FxIndexSet<$key>;\n+        pub type $entry_name<'a, T> = $crate::fx::IndexEntry<'a, $key, T>;\n     };\n }"}, {"sha": "467ac401d086b3f35b21506bf2ec05167b47b548", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -13,7 +13,6 @@\n #![feature(cell_leak)]\n #![feature(control_flow_enum)]\n #![feature(extend_one)]\n-#![feature(let_else)]\n #![feature(hash_raw_entry)]\n #![feature(hasher_prefixfree_extras)]\n #![feature(maybe_uninit_uninit_array)]\n@@ -75,7 +74,6 @@ pub mod profiling;\n pub mod sharded;\n pub mod stack;\n pub mod sync;\n-pub mod thin_vec;\n pub mod tiny_list;\n pub mod transitive_relation;\n pub mod vec_linked_list;"}, {"sha": "a0d4b7ade1f33385e751e48b4379fa9323183f1c", "filename": "compiler/rustc_data_structures/src/map_in_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,6 +1,6 @@\n-use crate::thin_vec::ThinVec;\n use smallvec::{Array, SmallVec};\n use std::ptr;\n+use thin_vec::ThinVec;\n \n pub trait MapInPlace<T>: Sized {\n     fn map_in_place<F>(&mut self, mut f: F)"}, {"sha": "10e673cd9297bda67fddcec349af9f5657a7eaf5", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -95,6 +95,10 @@ pub trait ForestObligation: Clone + Debug {\n pub trait ObligationProcessor {\n     type Obligation: ForestObligation;\n     type Error: Debug;\n+    type OUT: OutcomeTrait<\n+        Obligation = Self::Obligation,\n+        Error = Error<Self::Obligation, Self::Error>,\n+    >;\n \n     fn needs_process_obligation(&self, obligation: &Self::Obligation) -> bool;\n \n@@ -111,12 +115,20 @@ pub trait ObligationProcessor {\n     /// In other words, if we had O1 which required O2 which required\n     /// O3 which required O1, we would give an iterator yielding O1,\n     /// O2, O3 (O1 is not yielded twice).\n-    fn process_backedge<'c, I>(&mut self, cycle: I, _marker: PhantomData<&'c Self::Obligation>)\n+    fn process_backedge<'c, I>(\n+        &mut self,\n+        cycle: I,\n+        _marker: PhantomData<&'c Self::Obligation>,\n+    ) -> Result<(), Self::Error>\n     where\n         I: Clone + Iterator<Item = &'c Self::Obligation>;\n }\n \n /// The result type used by `process_obligation`.\n+// `repr(C)` to inhibit the niche filling optimization. Otherwise, the `match` appearing\n+// in `process_obligations` is significantly slower, which can substantially affect\n+// benchmarks like `rustc-perf`'s inflate and keccak.\n+#[repr(C)]\n #[derive(Debug)]\n pub enum ProcessResult<O, E> {\n     Unchanged,\n@@ -398,12 +410,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     /// Performs a fixpoint computation over the obligation list.\n     #[inline(never)]\n-    pub fn process_obligations<P, OUT>(&mut self, processor: &mut P) -> OUT\n+    pub fn process_obligations<P>(&mut self, processor: &mut P) -> P::OUT\n     where\n         P: ObligationProcessor<Obligation = O>,\n-        OUT: OutcomeTrait<Obligation = O, Error = Error<O, P::Error>>,\n     {\n-        let mut outcome = OUT::new();\n+        let mut outcome = P::OUT::new();\n \n         // Fixpoint computation: we repeat until the inner loop stalls.\n         loop {\n@@ -469,7 +480,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             }\n \n             self.mark_successes();\n-            self.process_cycles(processor);\n+            self.process_cycles(processor, &mut outcome);\n             self.compress(|obl| outcome.record_completed(obl));\n         }\n \n@@ -554,7 +565,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     /// Report cycles between all `Success` nodes, and convert all `Success`\n     /// nodes to `Done`. This must be called after `mark_successes`.\n-    fn process_cycles<P>(&mut self, processor: &mut P)\n+    fn process_cycles<P>(&mut self, processor: &mut P, outcome: &mut P::OUT)\n     where\n         P: ObligationProcessor<Obligation = O>,\n     {\n@@ -564,16 +575,21 @@ impl<O: ForestObligation> ObligationForest<O> {\n             // to handle the no-op cases immediately to avoid the cost of the\n             // function call.\n             if node.state.get() == NodeState::Success {\n-                self.find_cycles_from_node(&mut stack, processor, index);\n+                self.find_cycles_from_node(&mut stack, processor, index, outcome);\n             }\n         }\n \n         debug_assert!(stack.is_empty());\n         self.reused_node_vec = stack;\n     }\n \n-    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)\n-    where\n+    fn find_cycles_from_node<P>(\n+        &self,\n+        stack: &mut Vec<usize>,\n+        processor: &mut P,\n+        index: usize,\n+        outcome: &mut P::OUT,\n+    ) where\n         P: ObligationProcessor<Obligation = O>,\n     {\n         let node = &self.nodes[index];\n@@ -582,17 +598,20 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 None => {\n                     stack.push(index);\n                     for &dep_index in node.dependents.iter() {\n-                        self.find_cycles_from_node(stack, processor, dep_index);\n+                        self.find_cycles_from_node(stack, processor, dep_index, outcome);\n                     }\n                     stack.pop();\n                     node.state.set(NodeState::Done);\n                 }\n                 Some(rpos) => {\n                     // Cycle detected.\n-                    processor.process_backedge(\n+                    let result = processor.process_backedge(\n                         stack[rpos..].iter().map(|&i| &self.nodes[i].obligation),\n                         PhantomData,\n                     );\n+                    if let Err(err) = result {\n+                        outcome.record_error(Error { error: err, backtrace: self.error_at(index) });\n+                    }\n                 }\n             }\n         }"}, {"sha": "bc252f772a1683afe5df1a9a7febe086623727b6", "filename": "compiler/rustc_data_structures/src/obligation_forest/tests.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -64,6 +64,7 @@ where\n {\n     type Obligation = O;\n     type Error = E;\n+    type OUT = TestOutcome<O, E>;\n \n     fn needs_process_obligation(&self, _obligation: &Self::Obligation) -> bool {\n         true\n@@ -76,10 +77,15 @@ where\n         (self.process_obligation)(obligation)\n     }\n \n-    fn process_backedge<'c, I>(&mut self, _cycle: I, _marker: PhantomData<&'c Self::Obligation>)\n+    fn process_backedge<'c, I>(\n+        &mut self,\n+        _cycle: I,\n+        _marker: PhantomData<&'c Self::Obligation>,\n+    ) -> Result<(), Self::Error>\n     where\n         I: Clone + Iterator<Item = &'c Self::Obligation>,\n     {\n+        Ok(())\n     }\n }\n "}, {"sha": "937cb671573a1c97b2096d3dab4382075365a97e", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -164,7 +164,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n     /// It is up to the caller to make sure that the elements are sorted by key\n     /// and that there are no duplicates.\n     #[inline]\n-    pub fn insert_presorted(&mut self, mut elements: Vec<(K, V)>) {\n+    pub fn insert_presorted(&mut self, elements: Vec<(K, V)>) {\n         if elements.is_empty() {\n             return;\n         }\n@@ -173,28 +173,28 @@ impl<K: Ord, V> SortedMap<K, V> {\n \n         let start_index = self.lookup_index_for(&elements[0].0);\n \n-        let drain = match start_index {\n+        let elements = match start_index {\n             Ok(index) => {\n-                let mut drain = elements.drain(..);\n-                self.data[index] = drain.next().unwrap();\n-                drain\n+                let mut elements = elements.into_iter();\n+                self.data[index] = elements.next().unwrap();\n+                elements\n             }\n             Err(index) => {\n                 if index == self.data.len() || elements.last().unwrap().0 < self.data[index].0 {\n                     // We can copy the whole range without having to mix with\n                     // existing elements.\n-                    self.data.splice(index..index, elements.drain(..));\n+                    self.data.splice(index..index, elements.into_iter());\n                     return;\n                 }\n \n-                let mut drain = elements.drain(..);\n-                self.data.insert(index, drain.next().unwrap());\n-                drain\n+                let mut elements = elements.into_iter();\n+                self.data.insert(index, elements.next().unwrap());\n+                elements\n             }\n         };\n \n         // Insert the rest\n-        for (k, v) in drain {\n+        for (k, v) in elements {\n             self.insert(k, v);\n         }\n     }"}, {"sha": "9c0fb8265cff71da9557cdad785c662156f79fc2", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -48,7 +48,7 @@ cfg_if! {\n         /// the native atomic types.\n         /// You should use this type through the `AtomicU64`, `AtomicUsize`, etc, type aliases\n         /// as it's not intended to be used separately.\n-        #[derive(Debug)]\n+        #[derive(Debug, Default)]\n         pub struct Atomic<T: Copy>(Cell<T>);\n \n         impl<T: Copy> Atomic<T> {"}, {"sha": "fce42e709ab74cfefcf6d81ebff7d2ddc164ea32", "filename": "compiler/rustc_data_structures/src/thin_vec.rs", "status": "removed", "additions": 0, "deletions": 180, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,180 +0,0 @@\n-use crate::stable_hasher::{HashStable, StableHasher};\n-\n-use std::iter::FromIterator;\n-\n-/// A vector type optimized for cases where this size is usually 0 (cf. `SmallVec`).\n-/// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n-/// which uses only a single (null) pointer.\n-#[derive(Clone, Encodable, Decodable, Debug, Hash, Eq, PartialEq)]\n-pub struct ThinVec<T>(Option<Box<Vec<T>>>);\n-\n-impl<T> ThinVec<T> {\n-    pub fn new() -> Self {\n-        ThinVec(None)\n-    }\n-\n-    pub fn iter(&self) -> std::slice::Iter<'_, T> {\n-        self.into_iter()\n-    }\n-\n-    pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, T> {\n-        self.into_iter()\n-    }\n-\n-    pub fn push(&mut self, item: T) {\n-        match *self {\n-            ThinVec(Some(ref mut vec)) => vec.push(item),\n-            ThinVec(None) => *self = vec![item].into(),\n-        }\n-    }\n-\n-    /// Note: if `set_len(0)` is called on a non-empty `ThinVec`, it will\n-    /// remain in the `Some` form. This is required for some code sequences\n-    /// (such as the one in `flat_map_in_place`) that call `set_len(0)` before\n-    /// an operation that might panic, and then call `set_len(n)` again\n-    /// afterwards.\n-    pub unsafe fn set_len(&mut self, new_len: usize) {\n-        match *self {\n-            ThinVec(None) => {\n-                // A prerequisite of `Vec::set_len` is that `new_len` must be\n-                // less than or equal to capacity(). The same applies here.\n-                if new_len != 0 {\n-                    panic!(\"unsafe ThinVec::set_len({})\", new_len);\n-                }\n-            }\n-            ThinVec(Some(ref mut vec)) => vec.set_len(new_len),\n-        }\n-    }\n-\n-    pub fn insert(&mut self, index: usize, value: T) {\n-        match *self {\n-            ThinVec(None) => {\n-                if index == 0 {\n-                    *self = vec![value].into();\n-                } else {\n-                    panic!(\"invalid ThinVec::insert\");\n-                }\n-            }\n-            ThinVec(Some(ref mut vec)) => vec.insert(index, value),\n-        }\n-    }\n-\n-    pub fn remove(&mut self, index: usize) -> T {\n-        match self {\n-            ThinVec(None) => panic!(\"invalid ThinVec::remove\"),\n-            ThinVec(Some(vec)) => vec.remove(index),\n-        }\n-    }\n-\n-    pub fn as_slice(&self) -> &[T] {\n-        match self {\n-            ThinVec(None) => &[],\n-            ThinVec(Some(vec)) => vec.as_slice(),\n-        }\n-    }\n-}\n-\n-impl<T> From<Vec<T>> for ThinVec<T> {\n-    fn from(vec: Vec<T>) -> Self {\n-        if vec.is_empty() { ThinVec(None) } else { ThinVec(Some(Box::new(vec))) }\n-    }\n-}\n-\n-impl<T> Into<Vec<T>> for ThinVec<T> {\n-    fn into(self) -> Vec<T> {\n-        match self {\n-            ThinVec(None) => Vec::new(),\n-            ThinVec(Some(vec)) => *vec,\n-        }\n-    }\n-}\n-\n-impl<T> ::std::ops::Deref for ThinVec<T> {\n-    type Target = [T];\n-    fn deref(&self) -> &[T] {\n-        match *self {\n-            ThinVec(None) => &[],\n-            ThinVec(Some(ref vec)) => vec,\n-        }\n-    }\n-}\n-\n-impl<T> ::std::ops::DerefMut for ThinVec<T> {\n-    fn deref_mut(&mut self) -> &mut [T] {\n-        match *self {\n-            ThinVec(None) => &mut [],\n-            ThinVec(Some(ref mut vec)) => vec,\n-        }\n-    }\n-}\n-\n-impl<T> FromIterator<T> for ThinVec<T> {\n-    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n-        // `Vec::from_iter()` should not allocate if the iterator is empty.\n-        let vec: Vec<_> = iter.into_iter().collect();\n-        if vec.is_empty() { ThinVec(None) } else { ThinVec(Some(Box::new(vec))) }\n-    }\n-}\n-\n-impl<T> IntoIterator for ThinVec<T> {\n-    type Item = T;\n-    type IntoIter = std::vec::IntoIter<T>;\n-\n-    fn into_iter(self) -> Self::IntoIter {\n-        // This is still performant because `Vec::new()` does not allocate.\n-        self.0.map_or_else(Vec::new, |ptr| *ptr).into_iter()\n-    }\n-}\n-\n-impl<'a, T> IntoIterator for &'a ThinVec<T> {\n-    type Item = &'a T;\n-    type IntoIter = std::slice::Iter<'a, T>;\n-\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.as_ref().iter()\n-    }\n-}\n-\n-impl<'a, T> IntoIterator for &'a mut ThinVec<T> {\n-    type Item = &'a mut T;\n-    type IntoIter = std::slice::IterMut<'a, T>;\n-\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.as_mut().iter_mut()\n-    }\n-}\n-\n-impl<T> Extend<T> for ThinVec<T> {\n-    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n-        match *self {\n-            ThinVec(Some(ref mut vec)) => vec.extend(iter),\n-            ThinVec(None) => *self = iter.into_iter().collect::<Vec<_>>().into(),\n-        }\n-    }\n-\n-    fn extend_one(&mut self, item: T) {\n-        self.push(item)\n-    }\n-\n-    fn extend_reserve(&mut self, additional: usize) {\n-        match *self {\n-            ThinVec(Some(ref mut vec)) => vec.reserve(additional),\n-            ThinVec(None) => *self = Vec::with_capacity(additional).into(),\n-        }\n-    }\n-}\n-\n-impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ThinVec<T> {\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        (**self).hash_stable(hcx, hasher)\n-    }\n-}\n-\n-impl<T> Default for ThinVec<T> {\n-    fn default() -> Self {\n-        Self(None)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "0221b9912bbdcdc0af0f8a291a84ce4dba8a9bde", "filename": "compiler/rustc_data_structures/src/thin_vec/tests.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,42 +0,0 @@\n-use super::*;\n-\n-impl<T> ThinVec<T> {\n-    fn into_vec(self) -> Vec<T> {\n-        self.into()\n-    }\n-}\n-\n-#[test]\n-fn test_from_iterator() {\n-    assert_eq!(std::iter::empty().collect::<ThinVec<String>>().into_vec(), Vec::<String>::new());\n-    assert_eq!(std::iter::once(42).collect::<ThinVec<_>>().into_vec(), vec![42]);\n-    assert_eq!([1, 2].into_iter().collect::<ThinVec<_>>().into_vec(), vec![1, 2]);\n-    assert_eq!([1, 2, 3].into_iter().collect::<ThinVec<_>>().into_vec(), vec![1, 2, 3]);\n-}\n-\n-#[test]\n-fn test_into_iterator_owned() {\n-    assert_eq!(ThinVec::new().into_iter().collect::<Vec<String>>(), Vec::<String>::new());\n-    assert_eq!(ThinVec::from(vec![1]).into_iter().collect::<Vec<_>>(), vec![1]);\n-    assert_eq!(ThinVec::from(vec![1, 2]).into_iter().collect::<Vec<_>>(), vec![1, 2]);\n-    assert_eq!(ThinVec::from(vec![1, 2, 3]).into_iter().collect::<Vec<_>>(), vec![1, 2, 3]);\n-}\n-\n-#[test]\n-fn test_into_iterator_ref() {\n-    assert_eq!(ThinVec::new().iter().collect::<Vec<&String>>(), Vec::<&String>::new());\n-    assert_eq!(ThinVec::from(vec![1]).iter().collect::<Vec<_>>(), vec![&1]);\n-    assert_eq!(ThinVec::from(vec![1, 2]).iter().collect::<Vec<_>>(), vec![&1, &2]);\n-    assert_eq!(ThinVec::from(vec![1, 2, 3]).iter().collect::<Vec<_>>(), vec![&1, &2, &3]);\n-}\n-\n-#[test]\n-fn test_into_iterator_ref_mut() {\n-    assert_eq!(ThinVec::new().iter_mut().collect::<Vec<&mut String>>(), Vec::<&mut String>::new());\n-    assert_eq!(ThinVec::from(vec![1]).iter_mut().collect::<Vec<_>>(), vec![&mut 1]);\n-    assert_eq!(ThinVec::from(vec![1, 2]).iter_mut().collect::<Vec<_>>(), vec![&mut 1, &mut 2]);\n-    assert_eq!(\n-        ThinVec::from(vec![1, 2, 3]).iter_mut().collect::<Vec<_>>(),\n-        vec![&mut 1, &mut 2, &mut 3],\n-    );\n-}"}, {"sha": "d1d02ed73f9595a3847d38d96eb8665fc56badbc", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -7,7 +7,7 @@ edition = \"2021\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-tracing = { version = \"0.1.28\" }\n+tracing = { version = \"0.1.35\" }\n serde_json = \"1.0.59\"\n rustc_log = { path = \"../rustc_log\" }\n rustc_middle = { path = \"../rustc_middle\" }"}, {"sha": "fcd49f5d01567e8ff106784879055a26a8c3d0d3", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -5,7 +5,6 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(let_else)]\n #![feature(once_cell)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n@@ -742,6 +741,11 @@ fn print_crate_info(\n                     println!(\"{}\", cfg);\n                 }\n             }\n+            CallingConventions => {\n+                let mut calling_conventions = rustc_target::spec::abi::all_names();\n+                calling_conventions.sort_unstable();\n+                println!(\"{}\", calling_conventions.join(\"\\n\"));\n+            }\n             RelocationModels\n             | CodeModels\n             | TlsModels\n@@ -1119,22 +1123,25 @@ fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n     while let Some(arg) = args.next() {\n         if let Some(a) = ICE_REPORT_COMPILER_FLAGS.iter().find(|a| arg.starts_with(*a)) {\n             let content = if arg.len() == a.len() {\n+                // A space-separated option, like `-C incremental=foo` or `--crate-type rlib`\n                 match args.next() {\n                     Some(arg) => arg.to_string(),\n                     None => continue,\n                 }\n             } else if arg.get(a.len()..a.len() + 1) == Some(\"=\") {\n+                // An equals option, like `--crate-type=rlib`\n                 arg[a.len() + 1..].to_string()\n             } else {\n+                // A non-space option, like `-Cincremental=foo`\n                 arg[a.len()..].to_string()\n             };\n-            if ICE_REPORT_COMPILER_FLAGS_EXCLUDE.iter().any(|exc| content.starts_with(exc)) {\n+            let option = content.split_once('=').map(|s| s.0).unwrap_or(&content);\n+            if ICE_REPORT_COMPILER_FLAGS_EXCLUDE.iter().any(|exc| option == *exc) {\n                 excluded_cargo_defaults = true;\n             } else {\n                 result.push(a.to_string());\n-                match ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.iter().find(|s| content.starts_with(*s))\n-                {\n-                    Some(s) => result.push(s.to_string()),\n+                match ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.iter().find(|s| option == **s) {\n+                    Some(s) => result.push(format!(\"{}=[REDACTED]\", s)),\n                     None => result.push(content),\n                 }\n             }"}, {"sha": "e97da4322fa01483536018949d0cb70b77cc07bd", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,5 +1,6 @@\n //! The various pretty-printing routines.\n \n+use crate::session_diagnostics::UnprettyDumpFail;\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_errors::ErrorGuaranteed;\n@@ -328,7 +329,7 @@ impl<'tcx> pprust_hir::PpAnn for TypedAnnotation<'tcx> {\n             let typeck_results = self.maybe_typeck_results.get().or_else(|| {\n                 self.tcx\n                     .hir()\n-                    .maybe_body_owned_by(expr.hir_id.owner)\n+                    .maybe_body_owned_by(expr.hir_id.owner.def_id)\n                     .map(|body_id| self.tcx.typeck_body(body_id))\n             });\n \n@@ -357,12 +358,15 @@ fn get_source(input: &Input, sess: &Session) -> (String, FileName) {\n     (src, src_name)\n }\n \n-fn write_or_print(out: &str, ofile: Option<&Path>) {\n+fn write_or_print(out: &str, ofile: Option<&Path>, sess: &Session) {\n     match ofile {\n         None => print!(\"{}\", out),\n         Some(p) => {\n             if let Err(e) = std::fs::write(p, out) {\n-                panic!(\"print-print failed to write {} due to {}\", p.display(), e);\n+                sess.emit_fatal(UnprettyDumpFail {\n+                    path: p.display().to_string(),\n+                    err: e.to_string(),\n+                });\n             }\n         }\n     }\n@@ -392,6 +396,7 @@ pub fn print_after_parsing(\n                     annotation.pp_ann(),\n                     false,\n                     parse.edition,\n+                    &sess.parse_sess.attr_id_generator,\n                 )\n             })\n         }\n@@ -402,7 +407,7 @@ pub fn print_after_parsing(\n         _ => unreachable!(),\n     };\n \n-    write_or_print(&out, ofile);\n+    write_or_print(&out, ofile, sess);\n }\n \n pub fn print_after_hir_lowering<'tcx>(\n@@ -434,6 +439,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                     annotation.pp_ann(),\n                     true,\n                     parse.edition,\n+                    &sess.parse_sess.attr_id_generator,\n                 )\n             })\n         }\n@@ -468,7 +474,7 @@ pub fn print_after_hir_lowering<'tcx>(\n         _ => unreachable!(),\n     };\n \n-    write_or_print(&out, ofile);\n+    write_or_print(&out, ofile, tcx.sess);\n }\n \n // In an ideal world, this would be a public function called by the driver after\n@@ -512,7 +518,7 @@ fn print_with_analysis(\n         _ => unreachable!(),\n     };\n \n-    write_or_print(&out, ofile);\n+    write_or_print(&out, ofile, tcx.sess);\n \n     Ok(())\n }"}, {"sha": "289baf17773731e0891dc26f99e825987c887d21", "filename": "compiler/rustc_driver/src/session_diagnostics.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,33 +1,40 @@\n-use rustc_macros::SessionDiagnostic;\n+use rustc_macros::Diagnostic;\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(driver::rlink_unable_to_read)]\n pub(crate) struct RlinkUnableToRead {\n     pub err: std::io::Error,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(driver::rlink_wrong_file_type)]\n pub(crate) struct RLinkWrongFileType;\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(driver::rlink_empty_version_number)]\n pub(crate) struct RLinkEmptyVersionNumber;\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(driver::rlink_encoding_version_mismatch)]\n pub(crate) struct RLinkEncodingVersionMismatch {\n     pub version_array: String,\n     pub rlink_version: u32,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(driver::rlink_rustc_version_mismatch)]\n pub(crate) struct RLinkRustcVersionMismatch<'a> {\n     pub rustc_version: String,\n     pub current_version: &'a str,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(driver::rlink_no_a_file)]\n pub(crate) struct RlinkNotAFile;\n+\n+#[derive(Diagnostic)]\n+#[diag(driver::unpretty_dump_fail)]\n+pub(crate) struct UnprettyDumpFail {\n+    pub path: String,\n+    pub err: String,\n+}"}, {"sha": "03c88c6c0ebe56d29af6545a277a57b00143bec8", "filename": "compiler/rustc_error_messages/locales/en-US/ast_lowering.ftl", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -7,7 +7,9 @@ ast_lowering_use_angle_brackets = use angle brackets instead\n ast_lowering_invalid_abi =\n     invalid ABI: found `{$abi}`\n     .label = invalid ABI\n-    .help = valid ABIs: {$valid_abis}\n+    .note = invoke `{$command}` for a full list of supported calling conventions.\n+\n+ast_lowering_invalid_abi_suggestion = did you mean\n \n ast_lowering_assoc_ty_parentheses =\n     parenthesized generic arguments cannot be used in associated type constraints\n@@ -131,3 +133,9 @@ ast_lowering_arbitrary_expression_in_pattern =\n     arbitrary expressions aren't allowed in patterns\n \n ast_lowering_inclusive_range_with_no_end = inclusive range with no end\n+\n+ast_lowering_trait_fn_async =\n+    functions in traits cannot be declared `async`\n+    .label = `async` because of this\n+    .note = `async` trait functions are not currently supported\n+    .note2 = consider using the `async-trait` crate: https://crates.io/crates/async-trait"}, {"sha": "e5cd1142b20c8c8738055ac3d52d845fb801b24d", "filename": "compiler/rustc_error_messages/locales/en-US/ast_passes.ftl", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -26,12 +26,6 @@ ast_passes_invalid_visibility =\n     .individual_impl_items = place qualifiers on individual impl items instead\n     .individual_foreign_items = place qualifiers on individual foreign items instead\n \n-ast_passes_trait_fn_async =\n-    functions in traits cannot be declared `async`\n-    .label = `async` because of this\n-    .note = `async` trait functions are not currently supported\n-    .note2 = consider using the `async-trait` crate: https://crates.io/crates/async-trait\n-\n ast_passes_trait_fn_const =\n     functions in traits cannot be declared const\n     .label = functions in traits cannot be const"}, {"sha": "8ad198c86c933460a359e9e8b9aaaae7b7b05a44", "filename": "compiler/rustc_error_messages/locales/en-US/driver.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -9,3 +9,5 @@ driver_rlink_encoding_version_mismatch = .rlink file was produced with encoding\n driver_rlink_rustc_version_mismatch = .rlink file was produced by rustc version `{$rustc_version}`, but the current version is `{$current_version}`\n \n driver_rlink_no_a_file = rlink must be a file\n+\n+driver_unpretty_dump_fail = pretty-print failed to write `{$path}` due to error `{$err}`"}, {"sha": "65371a285911e22f03a45c7cb8a1811b9593f63c", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -104,9 +104,68 @@ infer_relate_object_bound = ...so that it can be closed over into an object\n infer_data_borrowed = ...so that the type `{$name}` is not borrowed for too long\n infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n-[true] ...\n-*[false] {\"\"}\n+    [true] ...\n+    *[false] {\"\"}\n }\n infer_relate_param_bound_2 = ...that is required by this bound\n infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n+infer_ascribe_user_type_prove_predicate = ...so that the where clause holds\n+\n+infer_nothing = {\"\"}\n+\n+infer_lifetime_mismatch = lifetime mismatch\n+\n+infer_declared_different = this parameter and the return type are declared with different lifetimes...\n+infer_data_returned = ...but data{$label_var1_exists ->\n+    [true] {\" \"}from `{$label_var1}`\n+    *[false] {\"\"}\n+} is returned here\n+\n+infer_data_lifetime_flow = ...but data with one lifetime flows into the other here\n+infer_declared_multiple = this type is declared with multiple lifetimes...\n+infer_types_declared_different = these two types are declared with different lifetimes...\n+infer_data_flows = ...but data{$label_var1_exists ->\n+    [true] -> {\" \"}from `{$label_var1}`\n+    *[false] -> {\"\"}\n+} flows{$label_var2_exists ->\n+    [true] -> {\" \"}into `{$label_var2}`\n+    *[false] -> {\"\"}\n+} here\n+\n+infer_lifetime_param_suggestion = consider introducing a named lifetime parameter{$is_impl ->\n+    [true] {\" \"}and update trait if needed\n+    *[false] {\"\"}\n+}\n+infer_lifetime_param_suggestion_elided = each elided lifetime in input position becomes a distinct lifetime\n+\n+infer_region_explanation = {$pref_kind ->\n+    *[should_not_happen] [{$pref_kind}]\n+    [empty] {\"\"}\n+}{$pref_kind ->\n+    [empty] {\"\"}\n+    *[other] {\" \"}\n+}{$desc_kind ->\n+    *[should_not_happen] [{$desc_kind}]\n+    [restatic] the static lifetime\n+    [reempty] the empty lifetime\n+    [reemptyuni] the empty lifetime in universe {$desc_arg}\n+    [revar] lifetime {$desc_arg}\n+\n+    [as_defined] the lifetime `{$desc_arg}` as defined here\n+    [as_defined_anon] the anonymous lifetime as defined here\n+    [defined_here] the anonymous lifetime defined here\n+    [anon_num_here] the anonymous lifetime #{$desc_num_arg} defined here\n+    [defined_here_reg] the lifetime `{$desc_arg}` as defined here\n+}{$suff_kind ->\n+    *[should_not_happen] [{$suff_kind}]\n+    [empty]{\"\"}\n+    [continues] ...\n+}\n+\n+infer_mismatched_static_lifetime = incompatible lifetime on type\n+infer_msl_impl_note = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+infer_msl_introduces_static = introduces a `'static` lifetime requirement\n+infer_msl_unmet_req = because this has an unmet lifetime requirement\n+infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n+infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement"}, {"sha": "80b0b1a8904a1d003ab04315ee305f36358ff543", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -51,7 +51,7 @@ lint_non_existant_doc_keyword = found non-existing keyword `{$keyword}` used in\n     .help = only existing keywords are allowed in core/std\n \n lint_diag_out_of_impl =\n-    diagnostics should only be created in `SessionDiagnostic`/`AddSubdiagnostic` impls\n+    diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n \n lint_untranslatable_diag = diagnostics should be created using translatable messages\n \n@@ -354,6 +354,12 @@ lint_builtin_unreachable_pub = unreachable `pub` {$what}\n     .suggestion = consider restricting its visibility\n     .help = or consider exporting it for use by other crates\n \n+lint_builtin_unexpected_cli_config_name = unexpected `{$name}` as condition name\n+    .help = was set with `--cfg` but isn't in the `--check-cfg` expected names\n+\n+lint_builtin_unexpected_cli_config_value = unexpected condition value `{$value}` for condition name `{$name}`\n+    .help = was set with `--cfg` but isn't in the `--check-cfg` expected values\n+\n lint_builtin_type_alias_bounds_help = use fully disambiguated paths (i.e., `<T as Trait>::Assoc`) to refer to associated types in type aliases\n \n lint_builtin_type_alias_where_clause = where clauses are not enforced in type aliases"}, {"sha": "d27100c56aff5bbd3611642f9f15e9b4f3c156f8", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -0,0 +1,275 @@\n+metadata_rlib_required =\n+    crate `{$crate_name}` required to be available in rlib format, but was not found in this form\n+\n+metadata_lib_required =\n+    crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n+\n+metadata_crate_dep_multiple =\n+    cannot satisfy dependencies so `{$crate_name}` only shows up once\n+    .help = having upstream crates all available in one format will likely make this go away\n+\n+metadata_two_panic_runtimes =\n+    cannot link together two panic runtimes: {$prev_name} and {$cur_name}\n+\n+metadata_bad_panic_strategy =\n+    the linked panic runtime `{$runtime}` is not compiled with this crate's panic strategy `{$strategy}`\n+\n+metadata_required_panic_strategy =\n+    the crate `{$crate_name}` requires panic strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n+\n+metadata_incompatible_panic_in_drop_strategy =\n+    the crate `{$crate_name}` is compiled with the panic-in-drop strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n+\n+metadata_multiple_names_in_link =\n+    multiple `name` arguments in a single `#[link]` attribute\n+\n+metadata_multiple_kinds_in_link =\n+    multiple `kind` arguments in a single `#[link]` attribute\n+\n+metadata_link_name_form =\n+    link name must be of the form `name = \"string\"`\n+\n+metadata_link_kind_form =\n+    link kind must be of the form `kind = \"string\"`\n+\n+metadata_link_modifiers_form =\n+    link modifiers must be of the form `modifiers = \"string\"`\n+\n+metadata_link_cfg_form =\n+    link cfg must be of the form `cfg(/* predicate */)`\n+\n+metadata_wasm_import_form =\n+    wasm import module must be of the form `wasm_import_module = \"string\"`\n+\n+metadata_empty_link_name =\n+    link name must not be empty\n+    .label = empty link name\n+\n+metadata_link_framework_apple =\n+    link kind `framework` is only supported on Apple targets\n+\n+metadata_framework_only_windows =\n+    link kind `raw-dylib` is only supported on Windows targets\n+\n+metadata_unknown_link_kind =\n+    unknown link kind `{$kind}`, expected one of: static, dylib, framework, raw-dylib\n+    .label = unknown link kind\n+\n+metadata_multiple_link_modifiers =\n+    multiple `modifiers` arguments in a single `#[link]` attribute\n+\n+metadata_multiple_cfgs =\n+    multiple `cfg` arguments in a single `#[link]` attribute\n+\n+metadata_link_cfg_single_predicate =\n+    link cfg must have a single predicate argument\n+\n+metadata_multiple_wasm_import =\n+    multiple `wasm_import_module` arguments in a single `#[link]` attribute\n+\n+metadata_unexpected_link_arg =\n+    unexpected `#[link]` argument, expected one of: name, kind, modifiers, cfg, wasm_import_module, import_name_type\n+\n+metadata_invalid_link_modifier =\n+    invalid linking modifier syntax, expected '+' or '-' prefix before one of: bundle, verbatim, whole-archive, as-needed\n+\n+metadata_multiple_modifiers =\n+    multiple `{$modifier}` modifiers in a single `modifiers` argument\n+\n+metadata_bundle_needs_static =\n+    linking modifier `bundle` is only compatible with `static` linking kind\n+\n+metadata_whole_archive_needs_static =\n+    linking modifier `whole-archive` is only compatible with `static` linking kind\n+\n+metadata_as_needed_compatibility =\n+    linking modifier `as-needed` is only compatible with `dylib` and `framework` linking kinds\n+\n+metadata_unknown_link_modifier =\n+    unknown linking modifier `{$modifier}`, expected one of: bundle, verbatim, whole-archive, as-needed\n+\n+metadata_incompatible_wasm_link =\n+    `wasm_import_module` is incompatible with other arguments in `#[link]` attributes\n+\n+metadata_link_requires_name =\n+    `#[link]` attribute requires a `name = \"string\"` argument\n+    .label = missing `name` argument\n+\n+metadata_raw_dylib_no_nul =\n+    link name must not contain NUL characters if link kind is `raw-dylib`\n+\n+metadata_link_ordinal_raw_dylib =\n+    `#[link_ordinal]` is only supported if link kind is `raw-dylib`\n+\n+metadata_lib_framework_apple =\n+    library kind `framework` is only supported on Apple targets\n+\n+metadata_empty_renaming_target =\n+    an empty renaming target was specified for library `{$lib_name}`\n+\n+metadata_renaming_no_link =\n+    renaming of the library `{$lib_name}` was specified, however this crate contains no `#[link(...)]` attributes referencing this library\n+\n+metadata_multiple_renamings =\n+    multiple renamings were specified for library `{$lib_name}`\n+\n+metadata_no_link_mod_override =\n+    overriding linking modifiers from command line is not supported\n+\n+metadata_unsupported_abi_i686 =\n+    ABI not supported by `#[link(kind = \"raw-dylib\")]` on i686\n+\n+metadata_unsupported_abi =\n+    ABI not supported by `#[link(kind = \"raw-dylib\")]` on this architecture\n+\n+metadata_fail_create_file_encoder =\n+    failed to create file encoder: {$err}\n+\n+metadata_fail_seek_file =\n+    failed to seek the file: {$err}\n+\n+metadata_fail_write_file =\n+    failed to write to the file: {$err}\n+\n+metadata_crate_not_panic_runtime =\n+    the crate `{$crate_name}` is not a panic runtime\n+\n+metadata_no_panic_strategy =\n+    the crate `{$crate_name}` does not have the panic strategy `{$strategy}`\n+\n+metadata_profiler_builtins_needs_core =\n+    `profiler_builtins` crate (required by compiler options) is not compatible with crate attribute `#![no_core]`\n+\n+metadata_not_profiler_runtime =\n+    the crate `{$crate_name}` is not a profiler runtime\n+\n+metadata_no_multiple_global_alloc =\n+    cannot define multiple global allocators\n+    .label = cannot define a new global allocator\n+\n+metadata_prev_global_alloc =\n+    previous global allocator defined here\n+\n+metadata_conflicting_global_alloc =\n+    the `#[global_allocator]` in {$other_crate_name} conflicts with global allocator in: {$crate_name}\n+\n+metadata_global_alloc_required =\n+    no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n+\n+metadata_no_transitive_needs_dep =\n+    the crate `{$crate_name}` cannot depend on a crate that needs {$needs_crate_name}, but it depends on `{$deps_crate_name}`\n+\n+metadata_failed_write_error =\n+    failed to write {$filename}: {$err}\n+\n+metadata_missing_native_library =\n+    could not find native static library `{$libname}`, perhaps an -L flag is missing?\n+\n+metadata_failed_create_tempdir =\n+    couldn't create a temp dir: {$err}\n+\n+metadata_failed_create_file =\n+    failed to create the file {$filename}: {$err}\n+\n+metadata_failed_create_encoded_metadata =\n+    failed to create encoded metadata from file: {$err}\n+\n+metadata_non_ascii_name =\n+    cannot load a crate with a non-ascii name `{$crate_name}`\n+\n+metadata_extern_location_not_exist =\n+    extern location for {$crate_name} does not exist: {$location}\n+\n+metadata_extern_location_not_file =\n+    extern location for {$crate_name} is not a file: {$location}\n+\n+metadata_multiple_candidates =\n+    multiple {$flavor} candidates for `{$crate_name}` found\n+\n+metadata_multiple_matching_crates =\n+    multiple matching crates for `{$crate_name}`\n+    .note = candidates:{$candidates}\n+\n+metadata_symbol_conflicts_current =\n+    the current crate is indistinguishable from one of its dependencies: it has the same crate-name `{$crate_name}` and was compiled with the same `-C metadata` arguments. This will result in symbol conflicts between the two.\n+\n+metadata_symbol_conflicts_others =\n+    found two different crates with name `{$crate_name}` that are not distinguished by differing `-C metadata`. This will result in symbol conflicts between the two.\n+\n+metadata_stable_crate_id_collision =\n+    found crates (`{$crate_name0}` and `{$crate_name1}`) with colliding StableCrateId values.\n+\n+metadata_dl_error =\n+    {$err}\n+\n+metadata_newer_crate_version =\n+    found possibly newer version of crate `{$crate_name}`{$add_info}\n+    .note = perhaps that crate needs to be recompiled?\n+\n+metadata_found_crate_versions =\n+    the following crate versions were found:{$found_crates}\n+\n+metadata_no_crate_with_triple =\n+    couldn't find crate `{$crate_name}` with expected target triple {$locator_triple}{$add_info}\n+\n+metadata_found_staticlib =\n+    found staticlib `{$crate_name}` instead of rlib or dylib{$add_info}\n+    .help = please recompile that crate using --crate-type lib\n+\n+metadata_incompatible_rustc =\n+    found crate `{$crate_name}` compiled by an incompatible version of rustc{$add_info}\n+    .help = please recompile that crate using this compiler ({$rustc_version}) (consider running `cargo clean` first)\n+\n+metadata_invalid_meta_files =\n+    found invalid metadata files for crate `{$crate_name}`{$add_info}\n+\n+metadata_cannot_find_crate =\n+    can't find crate for `{$crate_name}`{$add_info}\n+\n+metadata_no_dylib_plugin =\n+    plugin `{$crate_name}` only found in rlib format, but must be available in dylib format\n+\n+metadata_target_not_installed =\n+    the `{$locator_triple}` target may not be installed\n+\n+metadata_target_no_std_support =\n+    the `{$locator_triple}` target may not support the standard library\n+\n+metadata_consider_downloading_target =\n+    consider downloading the target with `rustup target add {$locator_triple}`\n+\n+metadata_std_required =\n+    `std` is required by `{$current_crate}` because it does not declare `#![no_std]`\n+\n+metadata_consider_building_std =\n+    consider building the standard library from source with `cargo build -Zbuild-std`\n+\n+metadata_compiler_missing_profiler =\n+    the compiler may have been built without the profiler runtime\n+\n+metadata_install_missing_components =\n+    maybe you need to install the missing components with: `rustup component add rust-src rustc-dev llvm-tools-preview`\n+\n+metadata_cant_find_crate =\n+    can't find crate\n+\n+metadata_crate_location_unknown_type =\n+    extern location for {$crate_name} is of an unknown type: {$path}\n+\n+metadata_lib_filename_form =\n+    file name should be lib*.rlib or {dll_prefix}*.{dll_suffix}\n+\n+metadata_multiple_import_name_type =\n+    multiple `import_name_type` arguments in a single `#[link]` attribute\n+\n+metadata_import_name_type_form =\n+    import name type must be of the form `import_name_type = \"string\"`\n+\n+metadata_import_name_type_x86 =\n+    import name type is only supported on x86\n+\n+metadata_unknown_import_name_type =\n+    unknown import name type `{$import_name_type}`, expected one of: decorated, noprefix, undecorated\n+\n+metadata_import_name_type_raw =\n+    import name type can only be used with link kind `raw-dylib`"}, {"sha": "ed834886453ceabe94defffb0ae2111068e1e89e", "filename": "compiler/rustc_error_messages/locales/en-US/middle.ftl", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -0,0 +1,17 @@\n+middle_drop_check_overflow =\n+    overflow while adding drop-check rules for {$ty}\n+    .note = overflowed on {$overflow_ty}\n+\n+middle_opaque_hidden_type_mismatch =\n+    concrete type differs from previous defining opaque type use\n+    .label = expected `{$self_ty}`, got `{$other_ty}`\n+\n+middle_conflict_types =\n+    this expression supplies two conflicting concrete types for the same opaque type\n+\n+middle_previous_use_here =\n+    previous use here\n+\n+middle_limit_invalid =\n+    `limit` must be a non-negative integer\n+    .label = {$error_str}"}, {"sha": "07dd03e6e504e57bcdc8a1c9d1a5f6eaf228effc", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -47,15 +47,17 @@ parser_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n     .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n \n parser_invalid_logical_operator = `{$incorrect}` is not a logical operator\n-    .note = unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n+    .note = unlike in e.g., Python and PHP, `&&` and `||` are used for logical operators\n     .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n     .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n \n parser_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n     .suggestion = use `!` to perform bitwise not\n \n parser_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n-    .suggestion = use `!` to perform logical negation\n+parser_unexpected_token_after_not_bitwise = use `!` to perform bitwise not\n+parser_unexpected_token_after_not_logical = use `!` to perform logical negation\n+parser_unexpected_token_after_not_default = use `!` to perform logical negation or bitwise not\n \n parser_malformed_loop_label = malformed loop label\n     .suggestion = use the correct loop label format\n@@ -150,3 +152,12 @@ parser_dotdotdot = unexpected token: `...`\n \n parser_left_arrow_operator = unexpected token: `<-`\n     .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`\n+\n+parser_remove_let = expected pattern, found `let`\n+    .suggestion = remove the unnecessary `let` keyword\n+\n+parser_use_eq_instead = unexpected `==`\n+    .suggestion = try using `=` instead\n+\n+parser_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n+    .suggestion = try using { \"`{}`\" } instead"}, {"sha": "995ad4fe2585986a8b28a91fe92ea59050c61817", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -265,3 +265,9 @@ passes_rustc_lint_opt_deny_field_access = `#[rustc_lint_opt_deny_field_access]`\n \n passes_link_ordinal = attribute should be applied to a foreign function or static\n     .label = not a foreign function or static\n+\n+passes_collapse_debuginfo = `collapse_debuginfo` attribute should be applied to macro definitions\n+    .label = not a macro definition\n+\n+passes_deprecated_annotation_has_no_effect = this `#[deprecated]` annotation has no effect\n+    .suggestion = remove the unnecessary deprecation attribute"}, {"sha": "a26d1b2b381e83024f1bd110aab18d0e3753821d", "filename": "compiler/rustc_error_messages/locales/en-US/privacy.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -11,6 +11,8 @@ privacy_in_public_interface = {$vis_descr} {$kind} `{$descr}` in public interfac\n     .label = can't leak {$vis_descr} {$kind}\n     .visibility_label = `{$descr}` declared as {$vis_descr}\n \n+privacy_report_effective_visibility = {$descr}\n+\n privacy_from_private_dep_in_public_interface =\n     {$kind} `{$descr}` from private dependency '{$krate}' in public interface\n "}, {"sha": "b914ba52a7353ac219710beaae0eea3814102cef", "filename": "compiler/rustc_error_messages/locales/en-US/query_system.ftl", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -0,0 +1,28 @@\n+query_system_reentrant = internal compiler error: re-entrant incremental verify failure, suppressing message\n+\n+query_system_increment_compilation = internal compiler error: encountered incremental compilation error with {$dep_node}\n+    .help = This is a known issue with the compiler. Run {$run_cmd} to allow your project to compile\n+\n+query_system_increment_compilation_note1 = Please follow the instructions below to create a bug report with the provided information\n+query_system_increment_compilation_note2 = See <https://github.com/rust-lang/rust/issues/84970> for more information\n+\n+query_system_cycle = cycle detected when {$stack_bottom}\n+\n+query_system_cycle_usage = cycle used when {$usage}\n+\n+query_system_cycle_stack_single = ...which immediately requires {$stack_bottom} again\n+\n+query_system_cycle_stack_multiple = ...which again requires {$stack_bottom}, completing the cycle\n+\n+query_system_cycle_recursive_ty_alias = type aliases cannot be recursive\n+query_system_cycle_recursive_ty_alias_help1 = consider using a struct, enum, or union instead to break the cycle\n+query_system_cycle_recursive_ty_alias_help2 = see <https://doc.rust-lang.org/reference/types.html#recursive-types> for more information\n+\n+query_system_cycle_recursive_trait_alias = trait aliases cannot be recursive\n+\n+query_system_cycle_which_requires = ...which requires {$desc}...\n+\n+query_system_query_overflow = queries overflow the depth limit!\n+    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n+\n+query_system_layout_of_depth = query depth increased by {$depth} when {$desc}"}, {"sha": "76cae3c81e45182d192b23a5cc636402e93f060f", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -14,3 +14,55 @@ session_feature_diagnostic_for_issue =\n \n session_feature_diagnostic_help =\n     add `#![feature({$feature})]` to the crate attributes to enable\n+\n+session_not_circumvent_feature = `-Zunleash-the-miri-inside-of-you` may not be used to circumvent feature gates, except when testing error paths in the CTFE engine\n+\n+session_profile_use_file_does_not_exist = file `{$path}` passed to `-C profile-use` does not exist.\n+\n+session_linker_plugin_lto_windows_not_supported = linker plugin based LTO is not supported together with `-C prefer-dynamic` when targeting Windows-like targets\n+\n+session_profile_sample_use_file_does_not_exist = file `{$path}` passed to `-C profile-sample-use` does not exist.\n+\n+session_target_requires_unwind_tables = target requires unwind tables, they cannot be disabled with `-C force-unwind-tables=no`\n+\n+session_sanitizer_not_supported = {$us} sanitizer is not supported for this target\n+\n+session_sanitizers_not_supported = {$us} sanitizers are not supported for this target\n+\n+session_cannot_mix_and_match_sanitizers = `-Zsanitizer={$first}` is incompatible with `-Zsanitizer={$second}`\n+\n+session_cannot_enable_crt_static_linux = sanitizer is incompatible with statically linked libc, disable it using `-C target-feature=-crt-static`\n+\n+session_sanitizer_cfi_enabled = `-Zsanitizer=cfi` requires `-Clto`\n+\n+session_unstable_virtual_function_elimination = `-Zvirtual-function-elimination` requires `-Clto`\n+\n+session_unsupported_dwarf_version = requested DWARF version {$dwarf_version} is greater than 5\n+\n+session_target_invalid_address_space = invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n+\n+session_target_invalid_bits = invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}\n+\n+session_target_missing_alignment = missing alignment for `{$cause}` in \"data-layout\"\n+\n+session_target_invalid_alignment = invalid alignment for `{$cause}` in \"data-layout\": {$err}\n+\n+session_target_inconsistent_architecture = inconsistent target specification: \"data-layout\" claims architecture is {$dl}-endian, while \"target-endian\" is `{$target}`\n+\n+session_target_inconsistent_pointer_width = inconsistent target specification: \"data-layout\" claims pointers are {$pointer_size}-bit, while \"target-pointer-width\" is `{$target}`\n+\n+session_target_invalid_bits_size = {$err}\n+\n+session_target_stack_protector_not_supported = `-Z stack-protector={$stack_protector}` is not supported for target {$target_triple} and will be ignored\n+\n+session_split_debuginfo_unstable_platform = `-Csplit-debuginfo={$debuginfo}` is unstable on this platform\n+\n+session_file_is_not_writeable = output file {$file} is not writeable -- check its permissions\n+\n+session_crate_name_does_not_match = `--crate-name` and `#[crate_name]` are required to match, but `{$s}` != `{$name}`\n+\n+session_crate_name_invalid = crate names cannot start with a `-`, but `{$s}` has a leading hyphen\n+\n+session_crate_name_empty = crate name must not be empty\n+\n+session_invalid_character_in_create_name = invalid character `{$character}` in crate name: `{$crate_name}`"}, {"sha": "b7d48280f46198d3b72e42a9f8937723d8b2a10e", "filename": "compiler/rustc_error_messages/locales/en-US/symbol_mangling.ftl", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsymbol_mangling.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsymbol_mangling.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsymbol_mangling.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,7 +1 @@\n-symbol_mangling_invalid_symbol_name = symbol-name({$mangled_formatted})\n-\n-symbol_mangling_invalid_trait_item = demangling({$demangling_formatted})\n-\n-symbol_mangling_alt_invalid_trait_item = demangling-alt({$alt_demangling_formatted})\n-\n-symbol_mangling_invalid_def_path = def-path({$def_path})\n+symbol_mangling_test_output = {$kind}({$content})"}, {"sha": "004e0ab18969469f04dd1c91d70dfe70e1bc791f", "filename": "compiler/rustc_error_messages/locales/en-US/trait_selection.ftl", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftrait_selection.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftrait_selection.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftrait_selection.ftl?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -0,0 +1,26 @@\n+trait_selection_dump_vtable_entries = vtable entries for `{$trait_ref}`: {$entries}\n+\n+trait_selection_unable_to_construct_constant_value = unable to construct a constant value for the unevaluated constant {$unevaluated}\n+\n+trait_selection_auto_deref_reached_recursion_limit = reached the recursion limit while auto-dereferencing `{$ty}`\n+    .label = deref recursion limit reached\n+    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n+\n+trait_selection_empty_on_clause_in_rustc_on_unimplemented = empty `on`-clause in `#[rustc_on_unimplemented]`\n+    .label = empty on-clause here\n+\n+trait_selection_invalid_on_clause_in_rustc_on_unimplemented = invalid `on`-clause in `#[rustc_on_unimplemented]`\n+    .label = invalid on-clause here\n+\n+trait_selection_no_value_in_rustc_on_unimplemented = this attribute must have a valid value\n+    .label = expected value here\n+    .note = eg `#[rustc_on_unimplemented(message=\"foo\")]`\n+\n+trait_selection_negative_positive_conflict = found both positive and negative implementation of trait `{$trait_desc}`{$self_desc ->\n+        [none] {\"\"}\n+       *[default] {\" \"}for type `{$self_desc}`\n+    }:\n+    .negative_implementation_here = negative implementation here\n+    .negative_implementation_in_crate = negative implementation in crate `{$negative_impl_cname}`\n+    .positive_implementation_here = positive implementation here\n+    .positive_implementation_in_crate = positive implementation in crate `{$positive_impl_cname}`"}, {"sha": "ff33ae7e8f224edd0971202b11807c08a75422cf", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -5,6 +5,9 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n+#[macro_use]\n+extern crate tracing;\n+\n use fluent_bundle::FluentResource;\n use fluent_syntax::parser::ParserError;\n use rustc_data_structures::sync::Lrc;\n@@ -16,7 +19,6 @@ use std::fmt;\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n-use tracing::{instrument, trace};\n \n #[cfg(not(parallel_compiler))]\n use std::cell::LazyCell as Lazy;\n@@ -45,11 +47,15 @@ fluent_messages! {\n     interface => \"../locales/en-US/interface.ftl\",\n     infer => \"../locales/en-US/infer.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n+    middle => \"../locales/en-US/middle.ftl\",\n     monomorphize => \"../locales/en-US/monomorphize.ftl\",\n+    metadata => \"../locales/en-US/metadata.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n     passes => \"../locales/en-US/passes.ftl\",\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n+    query_system => \"../locales/en-US/query_system.ftl\",\n+    trait_selection => \"../locales/en-US/trait_selection.ftl\",\n     save_analysis => \"../locales/en-US/save_analysis.ftl\",\n     ty_utils => \"../locales/en-US/ty_utils.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\",\n@@ -262,14 +268,14 @@ type FluentId = Cow<'static, str>;\n /// Translatable messages for subdiagnostics are typically attributes attached to a larger Fluent\n /// message so messages of this type must be combined with a `DiagnosticMessage` (using\n /// `DiagnosticMessage::with_subdiagnostic_message`) before rendering. However, subdiagnostics from\n-/// the `SessionSubdiagnostic` derive refer to Fluent identifiers directly.\n+/// the `Subdiagnostic` derive refer to Fluent identifiers directly.\n #[rustc_diagnostic_item = \"SubdiagnosticMessage\"]\n pub enum SubdiagnosticMessage {\n     /// Non-translatable diagnostic message.\n     // FIXME(davidtwco): can a `Cow<'static, str>` be used here?\n     Str(String),\n     /// Identifier of a Fluent message. Instances of this variant are generated by the\n-    /// `SessionSubdiagnostic` derive.\n+    /// `Subdiagnostic` derive.\n     FluentIdentifier(FluentId),\n     /// Attribute of a Fluent message. Needs to be combined with a Fluent identifier to produce an\n     /// actual translated message. Instances of this variant are generated by the `fluent_messages`"}, {"sha": "c36ca11fad6f214ea43a0216f6db5c4fb2d3d847", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -13,15 +13,16 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_target = { path = \"../rustc_target\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n annotate-snippets = \"0.9\"\n termize = \"0.1.1\"\n-serde = { version = \"1.0.125\", features = [\"derive\"] }\n+serde = { version = \"1.0.125\", features = [ \"derive\" ] }\n serde_json = \"1.0.59\"\n \n [target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [\"handleapi\", \"synchapi\", \"winbase\"] }\n+winapi = { version = \"0.3\", features = [ \"handleapi\", \"synchapi\", \"winbase\" ] }"}, {"sha": "1c440a0a07efcac6a1b40f1adc11cb604fdf99c8", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -10,9 +10,11 @@ use rustc_lint_defs::{Applicability, LintExpectationId};\n use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n use rustc_span::{edition::Edition, Span, DUMMY_SP};\n+use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n+use std::num::ParseIntError;\n use std::path::{Path, PathBuf};\n \n /// Error type for `Diagnostic`'s `suggestions` field, indicating that\n@@ -33,7 +35,7 @@ pub enum DiagnosticArgValue<'source> {\n     Number(usize),\n }\n \n-/// Converts a value of a type into a `DiagnosticArg` (typically a field of a `SessionDiagnostic`\n+/// Converts a value of a type into a `DiagnosticArg` (typically a field of an `IntoDiagnostic`\n /// struct). Implemented as a custom trait rather than `From` so that it is implemented on the type\n /// being converted rather than on `DiagnosticArgValue`, which enables types from other `rustc_*`\n /// crates to implement this.\n@@ -90,6 +92,10 @@ into_diagnostic_arg_using_display!(\n     Edition,\n     Ident,\n     MacroRulesNormalizedIdent,\n+    ParseIntError,\n+    StackProtector,\n+    &TargetTriple,\n+    SplitDebuginfo\n );\n \n impl IntoDiagnosticArg for bool {\n@@ -144,6 +150,12 @@ impl IntoDiagnosticArg for usize {\n     }\n }\n \n+impl IntoDiagnosticArg for PanicStrategy {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.desc().to_string()))\n+    }\n+}\n+\n impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n     fn into(self) -> FluentValue<'source> {\n         match self {\n@@ -164,9 +176,10 @@ impl IntoDiagnosticArg for hir::ConstContext {\n }\n \n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n-/// `#[derive(SessionSubdiagnostic)]` -- see [rustc_macros::SessionSubdiagnostic].\n-#[rustc_diagnostic_item = \"AddSubdiagnostic\"]\n-pub trait AddSubdiagnostic {\n+/// `#[derive(Subdiagnostic)]` -- see [rustc_macros::Subdiagnostic].\n+#[cfg_attr(bootstrap, rustc_diagnostic_item = \"AddSubdiagnostic\")]\n+#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"AddToDiagnostic\")]\n+pub trait AddToDiagnostic {\n     /// Add a subdiagnostic to an existing diagnostic.\n     fn add_to_diagnostic(self, diag: &mut Diagnostic);\n }\n@@ -878,9 +891,9 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Add a subdiagnostic from a type that implements `SessionSubdiagnostic` - see\n-    /// [rustc_macros::SessionSubdiagnostic].\n-    pub fn subdiagnostic(&mut self, subdiagnostic: impl AddSubdiagnostic) -> &mut Self {\n+    /// Add a subdiagnostic from a type that implements `Subdiagnostic` - see\n+    /// [rustc_macros::Subdiagnostic].\n+    pub fn subdiagnostic(&mut self, subdiagnostic: impl AddToDiagnostic) -> &mut Self {\n         subdiagnostic.add_to_diagnostic(self);\n         self\n     }\n@@ -974,12 +987,12 @@ impl Diagnostic {\n     fn sub_with_highlights<M: Into<SubdiagnosticMessage>>(\n         &mut self,\n         level: Level,\n-        mut message: Vec<(M, Style)>,\n+        message: Vec<(M, Style)>,\n         span: MultiSpan,\n         render_span: Option<MultiSpan>,\n     ) {\n         let message = message\n-            .drain(..)\n+            .into_iter()\n             .map(|m| (self.subdiagnostic_message_to_diagnostic_message(m.0), m.1))\n             .collect();\n         let sub = SubDiagnostic { level, message, span, render_span };"}, {"sha": "b4ba65ca96d3b7486a561fc8e3611c99dab1b100", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -12,7 +12,16 @@ use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n use std::thread::panicking;\n-use tracing::debug;\n+\n+/// Trait implemented by error types. This should not be implemented manually. Instead, use\n+/// `#[derive(Diagnostic)]` -- see [rustc_macros::Diagnostic].\n+#[cfg_attr(bootstrap, rustc_diagnostic_item = \"SessionDiagnostic\")]\n+#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"IntoDiagnostic\")]\n+pub trait IntoDiagnostic<'a, T: EmissionGuarantee = ErrorGuaranteed> {\n+    /// Write out as a diagnostic out of `Handler`.\n+    #[must_use]\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, T>;\n+}\n \n /// Used for emitting structured error messages and other diagnostic information.\n ///\n@@ -571,7 +580,7 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n \n     forward!(pub fn subdiagnostic(\n         &mut self,\n-        subdiagnostic: impl crate::AddSubdiagnostic\n+        subdiagnostic: impl crate::AddToDiagnostic\n     ) -> &mut Self);\n }\n "}, {"sha": "66fbb8f1213e0a9b633a2eb4377bd640b731f627", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -22,7 +22,7 @@ use crate::{\n \n use rustc_lint_defs::pluralize;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_data_structures::sync::Lrc;\n use rustc_error_messages::FluentArgs;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -34,7 +34,6 @@ use std::iter;\n use std::path::Path;\n use termcolor::{Ansi, BufferWriter, ColorChoice, ColorSpec, StandardStream};\n use termcolor::{Buffer, Color, WriteColor};\n-use tracing::*;\n \n /// Default column width, used in tests and when terminal dimensions cannot be determined.\n const DEFAULT_COLUMN_WIDTH: usize = 140;\n@@ -1488,7 +1487,7 @@ impl EmitterWriter {\n                 );\n \n                 // Contains the vertical lines' positions for active multiline annotations\n-                let mut multilines = FxHashMap::default();\n+                let mut multilines = FxIndexMap::default();\n \n                 // Get the left-side margin to remove it\n                 let mut whitespace_margin = usize::MAX;\n@@ -1705,7 +1704,7 @@ impl EmitterWriter {\n         {\n             notice_capitalization |= only_capitalization;\n \n-            let has_deletion = parts.iter().any(|p| p.is_deletion());\n+            let has_deletion = parts.iter().any(|p| p.is_deletion(sm));\n             let is_multiline = complete.lines().count() > 1;\n \n             if let Some(span) = span.primary_span() {\n@@ -1881,16 +1880,23 @@ impl EmitterWriter {\n                     let span_start_pos = sm.lookup_char_pos(part.span.lo()).col_display;\n                     let span_end_pos = sm.lookup_char_pos(part.span.hi()).col_display;\n \n+                    // If this addition is _only_ whitespace, then don't trim it,\n+                    // or else we're just not rendering anything.\n+                    let is_whitespace_addition = part.snippet.trim().is_empty();\n+\n                     // Do not underline the leading...\n-                    let start = part.snippet.len().saturating_sub(part.snippet.trim_start().len());\n+                    let start = if is_whitespace_addition {\n+                        0\n+                    } else {\n+                        part.snippet.len().saturating_sub(part.snippet.trim_start().len())\n+                    };\n                     // ...or trailing spaces. Account for substitutions containing unicode\n                     // characters.\n-                    let sub_len: usize = part\n-                        .snippet\n-                        .trim()\n-                        .chars()\n-                        .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n-                        .sum();\n+                    let sub_len: usize =\n+                        if is_whitespace_addition { &part.snippet } else { part.snippet.trim() }\n+                            .chars()\n+                            .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n+                            .sum();\n \n                     let offset: isize = offsets\n                         .iter()\n@@ -2131,7 +2137,7 @@ impl EmitterWriter {\n     }\n }\n \n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n enum DisplaySuggestion {\n     Underline,\n     Diff,"}, {"sha": "4d262ae0f5ec8ccc29e45567b6c7f1b22377332b", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -7,12 +7,10 @@\n #![feature(if_let_guard)]\n #![feature(adt_const_params)]\n #![feature(let_chains)]\n-#![feature(let_else)]\n #![feature(never_type)]\n #![feature(result_option_inspect)]\n #![feature(rustc_attrs)]\n #![allow(incomplete_features)]\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -27,7 +25,7 @@ use Level::*;\n \n use emitter::{is_case_difference, Emitter, EmitterWriter};\n use registry::Registry;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{self, Lock, Lrc};\n use rustc_data_structures::AtomicRef;\n@@ -61,6 +59,7 @@ mod snippet;\n mod styled_buffer;\n pub mod translation;\n \n+pub use diagnostic_builder::IntoDiagnostic;\n pub use snippet::Style;\n \n pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a, ErrorGuaranteed>>;\n@@ -70,7 +69,7 @@ pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a, ErrorGuaranteed>>;\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(PResult<'_, ()>, 16);\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(PResult<'_, bool>, 24);\n+rustc_data_structures::static_assert_size!(PResult<'_, bool>, 16);\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, Encodable, Decodable)]\n pub enum SuggestionStyle {\n@@ -151,21 +150,20 @@ pub struct SubstitutionHighlight {\n \n impl SubstitutionPart {\n     pub fn is_addition(&self, sm: &SourceMap) -> bool {\n-        !self.snippet.is_empty()\n-            && sm\n-                .span_to_snippet(self.span)\n-                .map_or(self.span.is_empty(), |snippet| snippet.trim().is_empty())\n+        !self.snippet.is_empty() && !self.replaces_meaningful_content(sm)\n     }\n \n-    pub fn is_deletion(&self) -> bool {\n-        self.snippet.trim().is_empty()\n+    pub fn is_deletion(&self, sm: &SourceMap) -> bool {\n+        self.snippet.trim().is_empty() && self.replaces_meaningful_content(sm)\n     }\n \n     pub fn is_replacement(&self, sm: &SourceMap) -> bool {\n-        !self.snippet.is_empty()\n-            && sm\n-                .span_to_snippet(self.span)\n-                .map_or(!self.span.is_empty(), |snippet| !snippet.trim().is_empty())\n+        !self.snippet.is_empty() && self.replaces_meaningful_content(sm)\n+    }\n+\n+    fn replaces_meaningful_content(&self, sm: &SourceMap) -> bool {\n+        sm.span_to_snippet(self.span)\n+            .map_or(!self.span.is_empty(), |snippet| !snippet.trim().is_empty())\n     }\n }\n \n@@ -372,7 +370,7 @@ impl fmt::Display for ExplicitBug {\n impl error::Error for ExplicitBug {}\n \n pub use diagnostic::{\n-    AddSubdiagnostic, DecorateLint, Diagnostic, DiagnosticArg, DiagnosticArgFromDisplay,\n+    AddToDiagnostic, DecorateLint, Diagnostic, DiagnosticArg, DiagnosticArgFromDisplay,\n     DiagnosticArgValue, DiagnosticId, DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, LintDiagnosticBuilder};\n@@ -413,7 +411,7 @@ struct HandlerInner {\n     taught_diagnostics: FxHashSet<DiagnosticId>,\n \n     /// Used to suggest rustc --explain <error code>\n-    emitted_diagnostic_codes: FxHashSet<DiagnosticId>,\n+    emitted_diagnostic_codes: FxIndexSet<DiagnosticId>,\n \n     /// This set contains a hash of every diagnostic that has been emitted by\n     /// this handler. These hashes is used to avoid emitting the same error\n@@ -438,11 +436,11 @@ struct HandlerInner {\n     /// have been converted.\n     check_unstable_expect_diagnostics: bool,\n \n-    /// Expected [`Diagnostic`]s store a [`LintExpectationId`] as part of\n+    /// Expected [`Diagnostic`][diagnostic::Diagnostic]s store a [`LintExpectationId`] as part of\n     /// the lint level. [`LintExpectationId`]s created early during the compilation\n     /// (before `HirId`s have been defined) are not stable and can therefore not be\n     /// stored on disk. This buffer stores these diagnostics until the ID has been\n-    /// replaced by a stable [`LintExpectationId`]. The [`Diagnostic`]s are the\n+    /// replaced by a stable [`LintExpectationId`]. The [`Diagnostic`][diagnostic::Diagnostic]s are the\n     /// submitted for storage and added to the list of fulfilled expectations.\n     unstable_expect_diagnostics: Vec<Diagnostic>,\n \n@@ -456,7 +454,7 @@ struct HandlerInner {\n }\n \n /// A key denoting where from a diagnostic was stashed.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum StashKey {\n     ItemNoType,\n     UnderscoreForArrayLengths,\n@@ -637,6 +635,10 @@ impl Handler {\n         inner.steal((span, key)).map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n     }\n \n+    pub fn has_stashed_diagnostic(&self, span: Span, key: StashKey) -> bool {\n+        self.inner.borrow().stashed_diagnostics.get(&(span, key)).is_some()\n+    }\n+\n     /// Emit all stashed diagnostics.\n     pub fn emit_stashed_diagnostics(&self) -> Option<ErrorGuaranteed> {\n         self.inner.borrow_mut().emit_stashed_diagnostics()\n@@ -1026,6 +1028,39 @@ impl Handler {\n         self.inner.borrow_mut().emit_diagnostic(diagnostic)\n     }\n \n+    pub fn emit_err<'a>(&'a self, err: impl IntoDiagnostic<'a>) -> ErrorGuaranteed {\n+        self.create_err(err).emit()\n+    }\n+\n+    pub fn create_err<'a>(\n+        &'a self,\n+        err: impl IntoDiagnostic<'a>,\n+    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        err.into_diagnostic(self)\n+    }\n+\n+    pub fn create_warning<'a>(\n+        &'a self,\n+        warning: impl IntoDiagnostic<'a, ()>,\n+    ) -> DiagnosticBuilder<'a, ()> {\n+        warning.into_diagnostic(self)\n+    }\n+\n+    pub fn emit_warning<'a>(&'a self, warning: impl IntoDiagnostic<'a, ()>) {\n+        self.create_warning(warning).emit()\n+    }\n+\n+    pub fn create_fatal<'a>(\n+        &'a self,\n+        fatal: impl IntoDiagnostic<'a, !>,\n+    ) -> DiagnosticBuilder<'a, !> {\n+        fatal.into_diagnostic(self)\n+    }\n+\n+    pub fn emit_fatal<'a>(&'a self, fatal: impl IntoDiagnostic<'a, !>) -> ! {\n+        self.create_fatal(fatal).emit()\n+    }\n+\n     fn emit_diag_at_span(\n         &self,\n         mut diag: Diagnostic,\n@@ -1250,14 +1285,14 @@ impl HandlerInner {\n \n     fn treat_err_as_bug(&self) -> bool {\n         self.flags.treat_err_as_bug.map_or(false, |c| {\n-            self.err_count()\n-                + self.lint_err_count\n-                + self.delayed_span_bugs.len()\n-                + self.delayed_good_path_bugs.len()\n-                >= c.get()\n+            self.err_count() + self.lint_err_count + self.delayed_bug_count() >= c.get()\n         })\n     }\n \n+    fn delayed_bug_count(&self) -> usize {\n+        self.delayed_span_bugs.len() + self.delayed_good_path_bugs.len()\n+    }\n+\n     fn print_error_count(&mut self, registry: &Registry) {\n         self.emit_stashed_diagnostics();\n \n@@ -1412,12 +1447,7 @@ impl HandlerInner {\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n         // FIXME: Would be nice to increment err_count in a more coherent way.\n         if self.flags.treat_err_as_bug.map_or(false, |c| {\n-            self.err_count()\n-                + self.lint_err_count\n-                + self.delayed_span_bugs.len()\n-                + self.delayed_good_path_bugs.len()\n-                + 1\n-                >= c.get()\n+            self.err_count() + self.lint_err_count + self.delayed_bug_count() + 1 >= c.get()\n         }) {\n             // FIXME: don't abort here if report_delayed_bugs is off\n             self.span_bug(sp, msg);\n@@ -1518,14 +1548,24 @@ impl HandlerInner {\n         if self.treat_err_as_bug() {\n             match (\n                 self.err_count() + self.lint_err_count,\n+                self.delayed_bug_count(),\n                 self.flags.treat_err_as_bug.map(|c| c.get()).unwrap_or(0),\n             ) {\n-                (1, 1) => panic!(\"aborting due to `-Z treat-err-as-bug=1`\"),\n-                (0 | 1, _) => {}\n-                (count, as_bug) => panic!(\n-                    \"aborting after {} errors due to `-Z treat-err-as-bug={}`\",\n-                    count, as_bug,\n-                ),\n+                (1, 0, 1) => panic!(\"aborting due to `-Z treat-err-as-bug=1`\"),\n+                (0, 1, 1) => panic!(\"aborting due delayed bug with `-Z treat-err-as-bug=1`\"),\n+                (count, delayed_count, as_bug) => {\n+                    if delayed_count > 0 {\n+                        panic!(\n+                            \"aborting after {} errors and {} delayed bugs due to `-Z treat-err-as-bug={}`\",\n+                            count, delayed_count, as_bug,\n+                        )\n+                    } else {\n+                        panic!(\n+                            \"aborting after {} errors due to `-Z treat-err-as-bug={}`\",\n+                            count, as_bug,\n+                        )\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "4f407badb3f9eb777e3857ac835dccc9cdab1993", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -21,7 +21,7 @@ pub trait Translate {\n     /// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n     /// passed around as a reference thereafter.\n     fn to_fluent_args<'arg>(&self, args: &[DiagnosticArg<'arg>]) -> FluentArgs<'arg> {\n-        FromIterator::from_iter(args.to_vec().drain(..))\n+        FromIterator::from_iter(args.iter().cloned())\n     }\n \n     /// Convert `DiagnosticMessage`s to a string, performing translation if necessary."}, {"sha": "cd8a525e062c5430f6c27f38ebe2e674defd12c2", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -10,11 +10,13 @@ use rustc_ast::{self as ast, AttrVec, Attribute, HasAttrs, Item, NodeId, PatKind\n use rustc_attr::{self as attr, Deprecation, Stability};\n use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::sync::{self, Lrc};\n-use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, MultiSpan, PResult};\n+use rustc_errors::{\n+    Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, MultiSpan, PResult,\n+};\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n-use rustc_session::{parse::ParseSess, Limit, Session, SessionDiagnostic};\n+use rustc_session::{parse::ParseSess, Limit, Session};\n use rustc_span::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnKind, LocalExpnId};\n@@ -693,10 +695,6 @@ pub struct SyntaxExtension {\n     pub span: Span,\n     /// List of unstable features that are treated as stable inside this macro.\n     pub allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-    /// Suppresses the `unsafe_code` lint for code produced by this macro.\n-    pub allow_internal_unsafe: bool,\n-    /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n-    pub local_inner_macros: bool,\n     /// The macro's stability info.\n     pub stability: Option<Stability>,\n     /// The macro's deprecation info.\n@@ -708,6 +706,13 @@ pub struct SyntaxExtension {\n     /// Built-in macros have a couple of special properties like availability\n     /// in `#[no_implicit_prelude]` modules, so we have to keep this flag.\n     pub builtin_name: Option<Symbol>,\n+    /// Suppresses the `unsafe_code` lint for code produced by this macro.\n+    pub allow_internal_unsafe: bool,\n+    /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n+    pub local_inner_macros: bool,\n+    /// Should debuginfo for the macro be collapsed to the outermost expansion site (in other\n+    /// words, was the macro definition annotated with `#[collapse_debuginfo]`)?\n+    pub collapse_debuginfo: bool,\n }\n \n impl SyntaxExtension {\n@@ -729,14 +734,15 @@ impl SyntaxExtension {\n         SyntaxExtension {\n             span: DUMMY_SP,\n             allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n             stability: None,\n             deprecation: None,\n             helper_attrs: Vec::new(),\n             edition,\n             builtin_name: None,\n             kind,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            collapse_debuginfo: false,\n         }\n     }\n \n@@ -754,12 +760,13 @@ impl SyntaxExtension {\n         let allow_internal_unstable =\n             attr::allow_internal_unstable(sess, &attrs).collect::<Vec<Symbol>>();\n \n-        let mut local_inner_macros = false;\n-        if let Some(macro_export) = sess.find_by_name(attrs, sym::macro_export) {\n-            if let Some(l) = macro_export.meta_item_list() {\n-                local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n-            }\n-        }\n+        let allow_internal_unsafe = sess.contains_name(attrs, sym::allow_internal_unsafe);\n+        let local_inner_macros = sess\n+            .find_by_name(attrs, sym::macro_export)\n+            .and_then(|macro_export| macro_export.meta_item_list())\n+            .map_or(false, |l| attr::list_contains_name(&l, sym::local_inner_macros));\n+        let collapse_debuginfo = sess.contains_name(attrs, sym::collapse_debuginfo);\n+        tracing::debug!(?local_inner_macros, ?collapse_debuginfo, ?allow_internal_unsafe);\n \n         let (builtin_name, helper_attrs) = sess\n             .find_by_name(attrs, sym::rustc_builtin_macro)\n@@ -801,13 +808,14 @@ impl SyntaxExtension {\n             span,\n             allow_internal_unstable: (!allow_internal_unstable.is_empty())\n                 .then(|| allow_internal_unstable.into()),\n-            allow_internal_unsafe: sess.contains_name(attrs, sym::allow_internal_unsafe),\n-            local_inner_macros,\n             stability: stability.map(|(s, _)| s),\n             deprecation: attr::find_deprecation(&sess, attrs).map(|(d, _)| d),\n             helper_attrs,\n             edition,\n             builtin_name,\n+            allow_internal_unsafe,\n+            local_inner_macros,\n+            collapse_debuginfo,\n         }\n     }\n \n@@ -852,11 +860,12 @@ impl SyntaxExtension {\n             call_site,\n             self.span,\n             self.allow_internal_unstable.clone(),\n-            self.allow_internal_unsafe,\n-            self.local_inner_macros,\n             self.edition,\n             macro_def_id,\n             parent_module,\n+            self.allow_internal_unsafe,\n+            self.local_inner_macros,\n+            self.collapse_debuginfo,\n         )\n     }\n }\n@@ -1102,12 +1111,12 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn create_err(\n         &self,\n-        err: impl SessionDiagnostic<'a>,\n+        err: impl IntoDiagnostic<'a>,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         self.sess.create_err(err)\n     }\n \n-    pub fn emit_err(&self, err: impl SessionDiagnostic<'a>) -> ErrorGuaranteed {\n+    pub fn emit_err(&self, err: impl IntoDiagnostic<'a>) -> ErrorGuaranteed {\n         self.sess.emit_err(err)\n     }\n "}, {"sha": "50d2be3cee5e0b3d71cbb0c861f14d78a4fdbbe4", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -178,8 +178,7 @@ impl<'a> ExtCtxt<'a> {\n         ex: P<ast::Expr>,\n     ) -> ast::Stmt {\n         let pat = if mutbl {\n-            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mut);\n-            self.pat_ident_binding_mode(sp, ident, binding_mode)\n+            self.pat_ident_binding_mode(sp, ident, ast::BindingAnnotation::MUT)\n         } else {\n             self.pat_ident(sp, ident)\n         };\n@@ -445,17 +444,16 @@ impl<'a> ExtCtxt<'a> {\n         self.pat(span, PatKind::Lit(expr))\n     }\n     pub fn pat_ident(&self, span: Span, ident: Ident) -> P<ast::Pat> {\n-        let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Not);\n-        self.pat_ident_binding_mode(span, ident, binding_mode)\n+        self.pat_ident_binding_mode(span, ident, ast::BindingAnnotation::NONE)\n     }\n \n     pub fn pat_ident_binding_mode(\n         &self,\n         span: Span,\n         ident: Ident,\n-        bm: ast::BindingMode,\n+        ann: ast::BindingAnnotation,\n     ) -> P<ast::Pat> {\n-        let pat = PatKind::Ident(bm, ident.with_span_pos(span), None);\n+        let pat = PatKind::Ident(ann, ident.with_span_pos(span), None);\n         self.pat(span, pat)\n     }\n     pub fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat> {\n@@ -618,7 +616,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {\n-        attr::mk_attr_outer(mi)\n+        attr::mk_attr_outer(&self.sess.parse_sess.attr_id_generator, mi)\n     }\n \n     pub fn meta_word(&self, sp: Span, w: Symbol) -> ast::MetaItem {"}, {"sha": "8d4e3640748631250921c9a57068c142e5a59a1b", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -2,9 +2,9 @@\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{Delimiter, Token, TokenKind};\n-use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n+use rustc_ast::tokenstream::{AttrTokenStream, AttrTokenTree};\n use rustc_ast::tokenstream::{DelimSpan, Spacing};\n-use rustc_ast::tokenstream::{LazyTokenStream, TokenTree};\n+use rustc_ast::tokenstream::{LazyAttrTokenStream, TokenTree};\n use rustc_ast::NodeId;\n use rustc_ast::{self as ast, AttrStyle, Attribute, HasAttrs, HasTokens, MetaItem};\n use rustc_attr as attr;\n@@ -259,8 +259,8 @@ impl<'a> StripUnconfigured<'a> {\n     fn try_configure_tokens<T: HasTokens>(&self, node: &mut T) {\n         if self.config_tokens {\n             if let Some(Some(tokens)) = node.tokens_mut() {\n-                let attr_annotated_tokens = tokens.create_token_stream();\n-                *tokens = LazyTokenStream::new(self.configure_tokens(&attr_annotated_tokens));\n+                let attr_stream = tokens.to_attr_token_stream();\n+                *tokens = LazyAttrTokenStream::new(self.configure_tokens(&attr_stream));\n             }\n         }\n     }\n@@ -270,16 +270,16 @@ impl<'a> StripUnconfigured<'a> {\n         if self.in_cfg(&attrs) { Some(attrs) } else { None }\n     }\n \n-    /// Performs cfg-expansion on `stream`, producing a new `AttrAnnotatedTokenStream`.\n+    /// Performs cfg-expansion on `stream`, producing a new `AttrTokenStream`.\n     /// This is only used during the invocation of `derive` proc-macros,\n     /// which require that we cfg-expand their entire input.\n     /// Normal cfg-expansion operates on parsed AST nodes via the `configure` method\n-    fn configure_tokens(&self, stream: &AttrAnnotatedTokenStream) -> AttrAnnotatedTokenStream {\n-        fn can_skip(stream: &AttrAnnotatedTokenStream) -> bool {\n-            stream.0.iter().all(|(tree, _spacing)| match tree {\n-                AttrAnnotatedTokenTree::Attributes(_) => false,\n-                AttrAnnotatedTokenTree::Token(_) => true,\n-                AttrAnnotatedTokenTree::Delimited(_, _, inner) => can_skip(inner),\n+    fn configure_tokens(&self, stream: &AttrTokenStream) -> AttrTokenStream {\n+        fn can_skip(stream: &AttrTokenStream) -> bool {\n+            stream.0.iter().all(|tree| match tree {\n+                AttrTokenTree::Attributes(_) => false,\n+                AttrTokenTree::Token(..) => true,\n+                AttrTokenTree::Delimited(_, _, inner) => can_skip(inner),\n             })\n         }\n \n@@ -290,36 +290,36 @@ impl<'a> StripUnconfigured<'a> {\n         let trees: Vec<_> = stream\n             .0\n             .iter()\n-            .flat_map(|(tree, spacing)| match tree.clone() {\n-                AttrAnnotatedTokenTree::Attributes(mut data) => {\n+            .flat_map(|tree| match tree.clone() {\n+                AttrTokenTree::Attributes(mut data) => {\n                     data.attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n \n                     if self.in_cfg(&data.attrs) {\n-                        data.tokens = LazyTokenStream::new(\n-                            self.configure_tokens(&data.tokens.create_token_stream()),\n+                        data.tokens = LazyAttrTokenStream::new(\n+                            self.configure_tokens(&data.tokens.to_attr_token_stream()),\n                         );\n-                        Some((AttrAnnotatedTokenTree::Attributes(data), *spacing)).into_iter()\n+                        Some(AttrTokenTree::Attributes(data)).into_iter()\n                     } else {\n                         None.into_iter()\n                     }\n                 }\n-                AttrAnnotatedTokenTree::Delimited(sp, delim, mut inner) => {\n+                AttrTokenTree::Delimited(sp, delim, mut inner) => {\n                     inner = self.configure_tokens(&inner);\n-                    Some((AttrAnnotatedTokenTree::Delimited(sp, delim, inner), *spacing))\n+                    Some(AttrTokenTree::Delimited(sp, delim, inner))\n                         .into_iter()\n                 }\n-                AttrAnnotatedTokenTree::Token(ref token) if let TokenKind::Interpolated(ref nt) = token.kind => {\n+                AttrTokenTree::Token(ref token, _) if let TokenKind::Interpolated(ref nt) = token.kind => {\n                     panic!(\n                         \"Nonterminal should have been flattened at {:?}: {:?}\",\n                         token.span, nt\n                     );\n                 }\n-                AttrAnnotatedTokenTree::Token(token) => {\n-                    Some((AttrAnnotatedTokenTree::Token(token), *spacing)).into_iter()\n+                AttrTokenTree::Token(token, spacing) => {\n+                    Some(AttrTokenTree::Token(token, spacing)).into_iter()\n                 }\n             })\n             .collect();\n-        AttrAnnotatedTokenStream::new(trees)\n+        AttrTokenStream::new(trees)\n     }\n \n     /// Parse and expand all `cfg_attr` attributes into a list of attributes\n@@ -388,7 +388,7 @@ impl<'a> StripUnconfigured<'a> {\n         attr: &Attribute,\n         (item, item_span): (ast::AttrItem, Span),\n     ) -> Attribute {\n-        let orig_tokens = attr.tokens().to_tokenstream();\n+        let orig_tokens = attr.tokens();\n \n         // We are taking an attribute of the form `#[cfg_attr(pred, attr)]`\n         // and producing an attribute of the form `#[attr]`. We\n@@ -404,27 +404,33 @@ impl<'a> StripUnconfigured<'a> {\n         };\n         let pound_span = pound_token.span;\n \n-        let mut trees = vec![(AttrAnnotatedTokenTree::Token(pound_token), Spacing::Alone)];\n+        let mut trees = vec![AttrTokenTree::Token(pound_token, Spacing::Alone)];\n         if attr.style == AttrStyle::Inner {\n             // For inner attributes, we do the same thing for the `!` in `#![some_attr]`\n             let TokenTree::Token(bang_token @ Token { kind: TokenKind::Not, .. }, _) = orig_trees.next().unwrap() else {\n                 panic!(\"Bad tokens for attribute {:?}\", attr);\n             };\n-            trees.push((AttrAnnotatedTokenTree::Token(bang_token), Spacing::Alone));\n+            trees.push(AttrTokenTree::Token(bang_token, Spacing::Alone));\n         }\n         // We don't really have a good span to use for the synthesized `[]`\n         // in `#[attr]`, so just use the span of the `#` token.\n-        let bracket_group = AttrAnnotatedTokenTree::Delimited(\n+        let bracket_group = AttrTokenTree::Delimited(\n             DelimSpan::from_single(pound_span),\n             Delimiter::Bracket,\n             item.tokens\n                 .as_ref()\n                 .unwrap_or_else(|| panic!(\"Missing tokens for {:?}\", item))\n-                .create_token_stream(),\n+                .to_attr_token_stream(),\n+        );\n+        trees.push(bracket_group);\n+        let tokens = Some(LazyAttrTokenStream::new(AttrTokenStream::new(trees)));\n+        let attr = attr::mk_attr_from_item(\n+            &self.sess.parse_sess.attr_id_generator,\n+            item,\n+            tokens,\n+            attr.style,\n+            item_span,\n         );\n-        trees.push((bracket_group, Spacing::Alone));\n-        let tokens = Some(LazyTokenStream::new(AttrAnnotatedTokenStream::new(trees)));\n-        let attr = attr::mk_attr_from_item(item, tokens, attr.style, item_span);\n         if attr.has_name(sym::crate_type) {\n             self.sess.parse_sess.buffer_lint(\n                 rustc_lint_defs::builtin::DEPRECATED_CFG_ATTR_CRATE_TYPE_NAME,"}, {"sha": "bd93f0717f5801f7df0aa410faf9dedb7729870b", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,45 +1,45 @@\n-use rustc_macros::SessionDiagnostic;\n+use rustc_macros::Diagnostic;\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(expand::expr_repeat_no_syntax_vars)]\n pub(crate) struct NoSyntaxVarsExprRepeat {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(expand::must_repeat_once)]\n pub(crate) struct MustRepeatOnce {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(expand::count_repetition_misplaced)]\n pub(crate) struct CountRepetitionMisplaced {\n     #[primary_span]\n     pub span: Span,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(expand::meta_var_expr_unrecognized_var)]\n pub(crate) struct MetaVarExprUnrecognizedVar {\n     #[primary_span]\n     pub span: Span,\n     pub key: MacroRulesNormalizedIdent,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(expand::var_still_repeating)]\n pub(crate) struct VarStillRepeating {\n     #[primary_span]\n     pub span: Span,\n     pub ident: MacroRulesNormalizedIdent,\n }\n \n-#[derive(SessionDiagnostic)]\n+#[derive(Diagnostic)]\n #[diag(expand::meta_var_dif_seq_matchers)]\n pub(crate) struct MetaVarsDifSeqMatchers {\n     #[primary_span]"}, {"sha": "b34de94fb7db4a43579cf08200ccf1b0399d012b", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -3,7 +3,6 @@\n #![feature(associated_type_defaults)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n-#![feature(let_else)]\n #![feature(macro_metavar_expr)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]\n@@ -15,6 +14,9 @@\n #[macro_use]\n extern crate rustc_macros;\n \n+#[macro_use]\n+extern crate tracing;\n+\n extern crate proc_macro as pm;\n \n mod placeholders;"}, {"sha": "c8bdc39311c6550c7c206eb0b24e6bc1fc099b22", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -430,7 +430,7 @@ impl TtParser {\n                     }\n                 }\n                 MatcherLoc::Delimited => {\n-                    // Entering the delimeter is trivial.\n+                    // Entering the delimiter is trivial.\n                     mp.idx += 1;\n                     self.cur_mps.push(mp);\n                 }"}, {"sha": "6d2c7aac6af495c4fd017f77be0af978ce4b28d1", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -32,7 +32,6 @@ use rustc_span::Span;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n-use tracing::debug;\n \n pub(crate) struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n@@ -594,7 +593,7 @@ pub fn compile_declarative_macro(\n     (mk_syn_ext(expander), rule_spans)\n }\n \n-#[derive(SessionSubdiagnostic)]\n+#[derive(Subdiagnostic)]\n enum ExplainDocComment {\n     #[label(expand::explain_doc_comment_inner)]\n     Inner {\n@@ -976,7 +975,7 @@ impl<'tt> TokenSet<'tt> {\n         self.maybe_empty = false;\n     }\n \n-    // Adds `tok` to the set for `self`, marking sequence as non-empy.\n+    // Adds `tok` to the set for `self`, marking sequence as non-empty.\n     fn add_one(&mut self, tt: TtHandle<'tt>) {\n         if !self.tokens.contains(&tt) {\n             self.tokens.push(tt);"}, {"sha": "59a7b668a83ce96d1da7811bef686cd23980a242", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::tokenstream::{self, Spacing::*, TokenStream};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Diagnostic, MultiSpan, PResult};\n+use rustc_errors::{MultiSpan, PResult};\n use rustc_parse::lexer::nfc_normalize;\n use rustc_parse::parse_stream_from_source_str;\n use rustc_session::parse::ParseSess;\n@@ -15,7 +15,7 @@ use rustc_span::symbol::{self, sym, Symbol};\n use rustc_span::{BytePos, FileName, Pos, SourceFile, Span};\n \n use pm::bridge::{\n-    server, DelimSpan, ExpnGlobals, Group, Ident, LitKind, Literal, Punct, TokenTree,\n+    server, DelimSpan, Diagnostic, ExpnGlobals, Group, Ident, LitKind, Literal, Punct, TokenTree,\n };\n use pm::{Delimiter, Level, LineColumn};\n use std::ops::Bound;\n@@ -368,8 +368,6 @@ impl server::Types for Rustc<'_, '_> {\n     type FreeFunctions = FreeFunctions;\n     type TokenStream = TokenStream;\n     type SourceFile = Lrc<SourceFile>;\n-    type MultiSpan = Vec<Span>;\n-    type Diagnostic = Diagnostic;\n     type Span = Span;\n     type Symbol = Symbol;\n }\n@@ -436,6 +434,21 @@ impl server::FreeFunctions for Rustc<'_, '_> {\n             span: self.call_site,\n         })\n     }\n+\n+    fn emit_diagnostic(&mut self, diagnostic: Diagnostic<Self::Span>) {\n+        let mut diag =\n+            rustc_errors::Diagnostic::new(diagnostic.level.to_internal(), diagnostic.message);\n+        diag.set_span(MultiSpan::from_spans(diagnostic.spans));\n+        for child in diagnostic.children {\n+            diag.sub(\n+                child.level.to_internal(),\n+                child.message,\n+                MultiSpan::from_spans(child.spans),\n+                None,\n+            );\n+        }\n+        self.sess().span_diagnostic.emit_diagnostic(&mut diag);\n+    }\n }\n \n impl server::TokenStream for Rustc<'_, '_> {\n@@ -583,38 +596,6 @@ impl server::SourceFile for Rustc<'_, '_> {\n     }\n }\n \n-impl server::MultiSpan for Rustc<'_, '_> {\n-    fn new(&mut self) -> Self::MultiSpan {\n-        vec![]\n-    }\n-\n-    fn push(&mut self, spans: &mut Self::MultiSpan, span: Self::Span) {\n-        spans.push(span)\n-    }\n-}\n-\n-impl server::Diagnostic for Rustc<'_, '_> {\n-    fn new(&mut self, level: Level, msg: &str, spans: Self::MultiSpan) -> Self::Diagnostic {\n-        let mut diag = Diagnostic::new(level.to_internal(), msg);\n-        diag.set_span(MultiSpan::from_spans(spans));\n-        diag\n-    }\n-\n-    fn sub(\n-        &mut self,\n-        diag: &mut Self::Diagnostic,\n-        level: Level,\n-        msg: &str,\n-        spans: Self::MultiSpan,\n-    ) {\n-        diag.sub(level.to_internal(), msg, MultiSpan::from_spans(spans), None);\n-    }\n-\n-    fn emit(&mut self, mut diag: Self::Diagnostic) {\n-        self.sess().span_diagnostic.emit_diagnostic(&mut diag);\n-    }\n-}\n-\n impl server::Span for Rustc<'_, '_> {\n     fn debug(&mut self, span: Self::Span) -> String {\n         if self.ecx.ecfg.span_debug {"}, {"sha": "8efb7ccc1c71c7f60fbcac255e816ed4516d7b69", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -161,6 +161,8 @@ declare_features! (\n     (accepted, fn_must_use, \"1.27.0\", Some(43302), None),\n     /// Allows capturing variables in scope using format_args!\n     (accepted, format_args_capture, \"1.58.0\", Some(67984), None),\n+    /// Allows associated types to be generic, e.g., `type Foo<T>;` (RFC 1598).\n+    (accepted, generic_associated_types, \"1.65.0\", Some(44265), None),\n     /// Allows attributes on lifetime/type formal parameters in generics (RFC 1327).\n     (accepted, generic_param_attrs, \"1.27.0\", Some(48848), None),\n     /// Allows the `#[global_allocator]` attribute.\n@@ -187,7 +189,9 @@ declare_features! (\n     /// especially around globs and shadowing (RFC 1560).\n     (accepted, item_like_imports, \"1.15.0\", Some(35120), None),\n     /// Allows `'a: { break 'a; }`.\n-    (accepted, label_break_value, \"CURRENT_RUSTC_VERSION\", Some(48594), None),\n+    (accepted, label_break_value, \"1.65.0\", Some(48594), None),\n+    /// Allows `let...else` statements.\n+    (accepted, let_else, \"1.65.0\", Some(87335), None),\n     /// Allows `break {expr}` with a value inside `loop`s.\n     (accepted, loop_break_value, \"1.19.0\", Some(37339), None),\n     /// Allows use of `?` as the Kleene \"at most one\" operator in macros."}, {"sha": "71ad54291b2863f8b244e3b720d1fa714365194d", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -221,6 +221,8 @@ declare_features! (\n     (active, rustc_private, \"1.0.0\", Some(27812), None),\n     /// Allows using internal rustdoc features like `doc(primitive)` or `doc(keyword)`.\n     (active, rustdoc_internals, \"1.58.0\", Some(90418), None),\n+    /// Allows using the `rustdoc::missing_doc_code_examples` lint\n+    (active, rustdoc_missing_doc_code_examples, \"1.31.0\", Some(101730), None),\n     /// Allows using `#[start]` on a function indicating that it is the program entrypoint.\n     (active, start, \"1.0.0\", Some(29633), None),\n     /// Allows using `#[structural_match]` which indicates that a type is structurally matchable.\n@@ -310,6 +312,8 @@ declare_features! (\n     (active, associated_type_defaults, \"1.2.0\", Some(29661), None),\n     /// Allows `async || body` closures.\n     (active, async_closure, \"1.37.0\", Some(62290), None),\n+    /// Alows async functions to be declared, implemented, and used in traits.\n+    (incomplete, async_fn_in_trait, \"CURRENT_RUSTC_VERSION\", Some(91611), None),\n     /// Allows `extern \"C-unwind\" fn` to enable unwinding across ABI boundaries.\n     (active, c_unwind, \"1.52.0\", Some(74990), None),\n     /// Allows using C-variadics.\n@@ -336,6 +340,8 @@ declare_features! (\n     (active, closure_track_caller, \"1.57.0\", Some(87417), None),\n     /// Allows to use the `#[cmse_nonsecure_entry]` attribute.\n     (active, cmse_nonsecure_entry, \"1.48.0\", Some(75835), None),\n+    /// Allows use of the `#[collapse_debuginfo]` attribute.\n+    (active, collapse_debuginfo, \"1.65.0\", Some(100758), None),\n     /// Allows `async {}` expressions in const contexts.\n     (active, const_async_blocks, \"1.53.0\", Some(85368), None),\n     // Allows limiting the evaluation steps of const expressions\n@@ -380,6 +386,8 @@ declare_features! (\n     (active, doc_cfg_hide, \"1.57.0\", Some(43781), None),\n     /// Allows `#[doc(masked)]`.\n     (active, doc_masked, \"1.21.0\", Some(44027), None),\n+    /// Allows `dyn* Trait` objects.\n+    (incomplete, dyn_star, \"1.65.0\", Some(91611), None),\n     /// Allows `X..Y` patterns.\n     (active, exclusive_range_pattern, \"1.11.0\", Some(37854), None),\n     /// Allows exhaustive pattern matching on types that contain uninhabited types.\n@@ -394,12 +402,12 @@ declare_features! (\n     (active, ffi_returns_twice, \"1.34.0\", Some(58314), None),\n     /// Allows using `#[repr(align(...))]` on function items\n     (active, fn_align, \"1.53.0\", Some(82232), None),\n+    /// Allows generators to be cloned.\n+    (active, generator_clone, \"1.65.0\", Some(95360), None),\n     /// Allows defining generators.\n     (active, generators, \"1.21.0\", Some(43122), None),\n     /// Infer generic args for both consts and types.\n     (active, generic_arg_infer, \"1.55.0\", Some(85077), None),\n-    /// Allows associated types to be generic, e.g., `type Foo<T>;` (RFC 1598).\n-    (active, generic_associated_types, \"1.23.0\", Some(44265), None),\n     /// An extension to the `generic_associated_types` feature, allowing incomplete features.\n     (incomplete, generic_associated_types_extended, \"1.61.0\", Some(95451), None),\n     /// Allows non-trivial generic constants which have to have wfness manually propagated to callers\n@@ -424,8 +432,6 @@ declare_features! (\n     (active, large_assignments, \"1.52.0\", Some(83518), None),\n     /// Allows `if/while p && let q = r && ...` chains.\n     (active, let_chains, \"1.37.0\", Some(53667), None),\n-    /// Allows `let...else` statements.\n-    (active, let_else, \"1.56.0\", Some(87335), None),\n     /// Allows `#[link(..., cfg(..))]`.\n     (active, link_cfg, \"1.14.0\", Some(37406), None),\n     /// Allows using `reason` in lint attributes and the `#[expect(lint)]` lint check.\n@@ -478,7 +484,7 @@ declare_features! (\n     /// Allows macro attributes on expressions, statements and non-inline modules.\n     (active, proc_macro_hygiene, \"1.30.0\", Some(54727), None),\n     /// Allows the use of raw-dylibs (RFC 2627).\n-    (incomplete, raw_dylib, \"1.40.0\", Some(58713), None),\n+    (active, raw_dylib, \"1.65.0\", Some(58713), None),\n     /// Allows `&raw const $place_expr` and `&raw mut $place_expr` expressions.\n     (active, raw_ref_op, \"1.41.0\", Some(64490), None),\n     /// Allows using the `#[register_tool]` attribute.\n@@ -487,6 +493,8 @@ declare_features! (\n     (incomplete, repr128, \"1.16.0\", Some(56071), None),\n     /// Allows `repr(simd)` and importing the various simd intrinsics.\n     (active, repr_simd, \"1.4.0\", Some(27731), None),\n+    /// Allows return-position `impl Trait` in traits.\n+    (incomplete, return_position_impl_trait_in_trait, \"1.65.0\", Some(91611), None),\n     /// Allows `extern \"rust-cold\"`.\n     (active, rust_cold_cc, \"1.63.0\", Some(97544), None),\n     /// Allows the use of SIMD types in functions declared in `extern` blocks.\n@@ -519,6 +527,8 @@ declare_features! (\n     /// Allows creation of instances of a struct by moving fields that have\n     /// not changed from prior instances of the same struct (RFC #2528)\n     (active, type_changing_struct_update, \"1.58.0\", Some(86555), None),\n+    /// Enables rustc to generate code that instructs libstd to NOT ignore SIGPIPE.\n+    (active, unix_sigpipe, \"1.65.0\", Some(97889), None),\n     /// Allows unsized fn parameters.\n     (active, unsized_fn_params, \"1.49.0\", Some(48055), None),\n     /// Allows unsized rvalues at arguments and parameters."}, {"sha": "700d9dab64be760343ebe29379cd44cc741392e6", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -345,6 +345,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(link_section, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n     ungated!(no_mangle, Normal, template!(Word), WarnFollowing, @only_local: true),\n     ungated!(used, Normal, template!(Word, List: \"compiler|linker\"), WarnFollowing, @only_local: true),\n+    ungated!(link_ordinal, Normal, template!(List: \"ordinal\"), ErrorPreceding),\n \n     // Limits:\n     ungated!(recursion_limit, CrateLevel, template!(NameValueStr: \"N\"), FutureWarnFollowing),\n@@ -359,6 +360,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n \n     // Entry point:\n+    gated!(unix_sigpipe, Normal, template!(Word, NameValueStr: \"inherit|sig_ign|sig_dfl\"), ErrorFollowing, experimental!(unix_sigpipe)),\n     ungated!(start, Normal, template!(Word), WarnFollowing),\n     ungated!(no_start, CrateLevel, template!(Word), WarnFollowing),\n     ungated!(no_main, CrateLevel, template!(Word), WarnFollowing),\n@@ -405,10 +407,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     // Linking:\n     gated!(naked, Normal, template!(Word), WarnFollowing, @only_local: true, naked_functions, experimental!(naked)),\n-    gated!(\n-        link_ordinal, Normal, template!(List: \"ordinal\"), ErrorPreceding, raw_dylib,\n-        experimental!(link_ordinal)\n-    ),\n \n     // Plugins:\n     BuiltinAttribute {\n@@ -470,7 +468,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // RFC 2632\n     gated!(\n         const_trait, Normal, template!(Word), WarnFollowing, const_trait_impl,\n-        \"`const` is a temporary placeholder for marking a trait that is suitable for `const` \\\n+        \"`const_trait` is a temporary placeholder for marking a trait that is suitable for `const` \\\n         `impls` and all default bodies as `const`, which may be removed or renamed in the \\\n         future.\"\n     ),\n@@ -480,6 +478,12 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         experimental!(deprecated_safe),\n     ),\n \n+    // `#[collapse_debuginfo]`\n+    gated!(\n+        collapse_debuginfo, Normal, template!(Word), WarnFollowing,\n+        experimental!(collapse_debuginfo)\n+    ),\n+\n     // ==========================================================================\n     // Internal attributes: Stability, deprecation, and unsafe:\n     // ==========================================================================\n@@ -758,6 +762,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Internal attributes, Testing:\n     // ==========================================================================\n \n+    rustc_attr!(TEST, rustc_effective_visibility, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_outlives, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_capture_analysis, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_insignificant_dtor, Normal, template!(Word), WarnFollowing),\n@@ -821,6 +826,14 @@ pub fn is_builtin_only_local(name: Symbol) -> bool {\n     BUILTIN_ATTRIBUTE_MAP.get(&name).map_or(false, |attr| attr.only_local)\n }\n \n+pub fn is_valid_for_get_attr(name: Symbol) -> bool {\n+    BUILTIN_ATTRIBUTE_MAP.get(&name).map_or(false, |attr| match attr.duplicates {\n+        WarnFollowing | ErrorFollowing | ErrorPreceding | FutureWarnFollowing\n+        | FutureWarnPreceding => true,\n+        DuplicatesOk | WarnFollowingWordOnly => false,\n+    })\n+}\n+\n pub static BUILTIN_ATTRIBUTE_MAP: LazyLock<FxHashMap<Symbol, &BuiltinAttribute>> =\n     LazyLock::new(|| {\n         let mut map = FxHashMap::default();"}, {"sha": "bdaa0ee88eba19792cd89fdd7d5104ce271fdfe9", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -151,7 +151,7 @@ pub use active::{Features, ACTIVE_FEATURES, INCOMPATIBLE_FEATURES};\n pub use builtin_attrs::AttributeDuplicates;\n pub use builtin_attrs::{\n     deprecated_attributes, find_gated_cfg, is_builtin_attr_name, is_builtin_only_local,\n-    AttributeGate, AttributeTemplate, AttributeType, BuiltinAttribute, GatedCfg,\n-    BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n+    is_valid_for_get_attr, AttributeGate, AttributeTemplate, AttributeType, BuiltinAttribute,\n+    GatedCfg, BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n };\n pub use removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};"}, {"sha": "79a12801de29db5bf1d23615dd36cd28732a93ae", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -164,7 +164,7 @@ declare_features! (\n     (removed, quote, \"1.33.0\", Some(29601), None, None),\n     (removed, reflect, \"1.0.0\", Some(27749), None, None),\n     /// Allows using the `#[register_attr]` attribute.\n-    (removed, register_attr, \"CURRENT_RUSTC_VERSION\", Some(66080), None,\n+    (removed, register_attr, \"1.65.0\", Some(66080), None,\n      Some(\"removed in favor of `#![register_tool]`\")),\n     /// Allows using the macros:\n     /// + `__diagnostic_used`"}, {"sha": "e7c26bd726fbfd69fa45532d5658d752de9a4232", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -109,6 +109,8 @@ pub enum DefKind {\n     InlineConst,\n     /// Opaque type, aka `impl Trait`.\n     OpaqueTy,\n+    /// A return-position `impl Trait` in a trait definition\n+    ImplTraitPlaceholder,\n     Field,\n     /// Lifetime parameter: the `'a` in `struct Foo<'a> { ... }`\n     LifetimeParam,\n@@ -138,6 +140,7 @@ impl DefKind {\n                 panic!(\"impossible struct constructor\")\n             }\n             DefKind::OpaqueTy => \"opaque type\",\n+            DefKind::ImplTraitPlaceholder => \"opaque type in trait\",\n             DefKind::TyAlias => \"type alias\",\n             DefKind::TraitAlias => \"trait alias\",\n             DefKind::AssocTy => \"associated type\",\n@@ -217,7 +220,8 @@ impl DefKind {\n             | DefKind::Use\n             | DefKind::ForeignMod\n             | DefKind::GlobalAsm\n-            | DefKind::Impl => None,\n+            | DefKind::Impl\n+            | DefKind::ImplTraitPlaceholder => None,\n         }\n     }\n \n@@ -254,6 +258,7 @@ impl DefKind {\n             | DefKind::Use\n             | DefKind::ForeignMod\n             | DefKind::OpaqueTy\n+            | DefKind::ImplTraitPlaceholder\n             | DefKind::Impl\n             | DefKind::Field\n             | DefKind::TyParam\n@@ -308,6 +313,7 @@ pub enum Res<Id = hir::HirId> {\n     ///\n     /// **Belongs to the type namespace.**\n     PrimTy(hir::PrimTy),\n+\n     /// The `Self` type, optionally with the [`DefId`] of the trait it belongs to and\n     /// optionally with the [`DefId`] of the item introducing the `Self` type alias.\n     ///\n@@ -355,7 +361,8 @@ pub enum Res<Id = hir::HirId> {\n     /// const fn baz<T>() -> usize { 10 }\n     /// ```\n     /// We do however allow `Self` in repeat expression even if it is generic to not break code\n-    /// which already works on stable while causing the `const_evaluatable_unchecked` future compat lint:\n+    /// which already works on stable while causing the `const_evaluatable_unchecked` future compat\n+    /// lint:\n     /// ```\n     /// fn foo<T>() {\n     ///     let _bar = [1_u8; std::mem::size_of::<*mut T>()];\n@@ -370,6 +377,7 @@ pub enum Res<Id = hir::HirId> {\n         /// from mentioning generics (i.e. when used in an anonymous constant).\n         alias_to: Option<(DefId, bool)>,\n     },\n+\n     /// A tool attribute module; e.g., the `rustfmt` in `#[rustfmt::skip]`.\n     ///\n     /// **Belongs to the type namespace.**\n@@ -383,6 +391,7 @@ pub enum Res<Id = hir::HirId> {\n     ///\n     /// *See also [`Res::SelfTy`].*\n     SelfCtor(DefId),\n+\n     /// A local variable or function parameter.\n     ///\n     /// **Belongs to the value namespace.**\n@@ -453,7 +462,7 @@ impl PartialRes {\n \n /// Different kinds of symbols can coexist even if they share the same textual name.\n /// Therefore, they each have a separate universe (known as a \"namespace\").\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Namespace {\n     /// The type namespace includes `struct`s, `enum`s, `union`s, `trait`s, and `mod`s\n     /// (and, by extension, crates)."}, {"sha": "d85ac960f9b2f10b415cb0a43d2eaa7de8bfc102", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -15,7 +15,6 @@ use rustc_span::symbol::{kw, sym, Symbol};\n \n use std::fmt::{self, Write};\n use std::hash::Hash;\n-use tracing::debug;\n \n /// The `DefPathTable` maps `DefIndex`es to `DefKey`s and vice versa.\n /// Internally the `DefPathTable` holds a tree of `DefKey`s, where each `DefKey`"}, {"sha": "c1948052e3c513ca31bc0db03de9e7a7f5cf4550", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 132, "deletions": 98, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,13 +1,13 @@\n use crate::def::{CtorKind, DefKind, Res};\n use crate::def_id::DefId;\n-pub(crate) use crate::hir_id::{HirId, ItemLocalId};\n+pub(crate) use crate::hir_id::{HirId, ItemLocalId, OwnerId};\n use crate::intravisit::FnKind;\n use crate::LangItem;\n \n use rustc_ast as ast;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_ast::{Attribute, FloatTy, IntTy, Label, LitKind, TraitObjectSyntax, UintTy};\n-pub use rustc_ast::{BorrowKind, ImplPolarity, IsAuto};\n+pub use rustc_ast::{BindingAnnotation, BorrowKind, ByRef, ImplPolarity, IsAuto};\n pub use rustc_ast::{CaptureBy, Movability, Mutability};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -139,11 +139,10 @@ impl LifetimeName {\n         match self {\n             LifetimeName::ImplicitObjectLifetimeDefault | LifetimeName::Infer => true,\n \n-            // It might seem surprising that `Fresh` counts as\n-            // *not* elided -- but this is because, as far as the code\n-            // in the compiler is concerned -- `Fresh` variants act\n-            // equivalently to \"some fresh name\". They correspond to\n-            // early-bound regions on an impl, in other words.\n+            // It might seem surprising that `Fresh` counts as not *elided*\n+            // -- but this is because, as far as the code in the compiler is\n+            // concerned -- `Fresh` variants act equivalently to \"some fresh name\".\n+            // They correspond to early-bound regions on an impl, in other words.\n             LifetimeName::Error | LifetimeName::Param(..) | LifetimeName::Static => false,\n         }\n     }\n@@ -202,13 +201,8 @@ impl Path<'_> {\n pub struct PathSegment<'hir> {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n-    // `id` and `res` are optional. We currently only use these in save-analysis,\n-    // any path segments without these will not have save-analysis info and\n-    // therefore will not have 'jump to def' in IDEs, but otherwise will not be\n-    // affected. (In general, we don't bother to get the defs for synthesized\n-    // segments, only for segments which have come from the AST).\n-    pub hir_id: Option<HirId>,\n-    pub res: Option<Res>,\n+    pub hir_id: HirId,\n+    pub res: Res,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n@@ -226,12 +220,12 @@ pub struct PathSegment<'hir> {\n \n impl<'hir> PathSegment<'hir> {\n     /// Converts an identifier to the corresponding segment.\n-    pub fn from_ident(ident: Ident) -> PathSegment<'hir> {\n-        PathSegment { ident, hir_id: None, res: None, infer_args: true, args: None }\n+    pub fn new(ident: Ident, hir_id: HirId, res: Res) -> PathSegment<'hir> {\n+        PathSegment { ident, hir_id, res, infer_args: true, args: None }\n     }\n \n     pub fn invalid() -> Self {\n-        Self::from_ident(Ident::empty())\n+        Self::new(Ident::empty(), HirId::INVALID, Res::Err)\n     }\n \n     pub fn args(&self) -> &GenericArgs<'hir> {\n@@ -264,8 +258,8 @@ impl InferArg {\n \n #[derive(Debug, HashStable_Generic)]\n pub enum GenericArg<'hir> {\n-    Lifetime(Lifetime),\n-    Type(Ty<'hir>),\n+    Lifetime(&'hir Lifetime),\n+    Type(&'hir Ty<'hir>),\n     Const(ConstArg),\n     Infer(InferArg),\n }\n@@ -280,7 +274,7 @@ impl GenericArg<'_> {\n         }\n     }\n \n-    pub fn id(&self) -> HirId {\n+    pub fn hir_id(&self) -> HirId {\n         match self {\n             GenericArg::Lifetime(l) => l.hir_id,\n             GenericArg::Type(t) => t.hir_id,\n@@ -305,9 +299,9 @@ impl GenericArg<'_> {\n     pub fn to_ord(&self) -> ast::ParamKindOrd {\n         match self {\n             GenericArg::Lifetime(_) => ast::ParamKindOrd::Lifetime,\n-            GenericArg::Type(_) => ast::ParamKindOrd::Type,\n-            GenericArg::Const(_) => ast::ParamKindOrd::Const,\n-            GenericArg::Infer(_) => ast::ParamKindOrd::Infer,\n+            GenericArg::Type(_) | GenericArg::Const(_) | GenericArg::Infer(_) => {\n+                ast::ParamKindOrd::TypeOrConst\n+            }\n         }\n     }\n \n@@ -435,7 +429,7 @@ pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     // FIXME(davidtwco): Introduce `PolyTraitRef::LangItem`\n     LangItemTrait(LangItem, Span, HirId, &'hir GenericArgs<'hir>),\n-    Outlives(Lifetime),\n+    Outlives(&'hir Lifetime),\n }\n \n impl GenericBound<'_> {\n@@ -581,8 +575,7 @@ impl<'hir> Generics<'hir> {\n         if self.has_where_clause_predicates {\n             self.predicates\n                 .iter()\n-                .filter(|p| p.in_where_clause())\n-                .last()\n+                .rfind(|&p| p.in_where_clause())\n                 .map_or(end, |p| p.span())\n                 .shrink_to_hi()\n                 .to(end)\n@@ -761,7 +754,7 @@ impl<'hir> WhereBoundPredicate<'hir> {\n pub struct WhereRegionPredicate<'hir> {\n     pub span: Span,\n     pub in_where_clause: bool,\n-    pub lifetime: Lifetime,\n+    pub lifetime: &'hir Lifetime,\n     pub bounds: GenericBounds<'hir>,\n }\n \n@@ -840,7 +833,16 @@ impl<'tcx> OwnerNodes<'tcx> {\n impl fmt::Debug for OwnerNodes<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"OwnerNodes\")\n+            // Do not print all the pointers to all the nodes, as it would be unreadable.\n             .field(\"node\", &self.nodes[ItemLocalId::from_u32(0)])\n+            .field(\n+                \"parents\",\n+                &self\n+                    .nodes\n+                    .iter_enumerated()\n+                    .map(|(id, parented_node)| (id, parented_node.as_ref().map(|node| node.parent)))\n+                    .collect::<Vec<_>>(),\n+            )\n             .field(\"bodies\", &self.bodies)\n             .field(\"local_id_to_def_id\", &self.local_id_to_def_id)\n             .field(\"hash_without_bodies\", &self.hash_without_bodies)\n@@ -1049,30 +1051,6 @@ pub struct PatField<'hir> {\n     pub span: Span,\n }\n \n-/// Explicit binding annotations given in the HIR for a binding. Note\n-/// that this is not the final binding *mode* that we infer after type\n-/// inference.\n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n-pub enum BindingAnnotation {\n-    /// No binding annotation given: this means that the final binding mode\n-    /// will depend on whether we have skipped through a `&` reference\n-    /// when matching. For example, the `x` in `Some(x)` will have binding\n-    /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n-    /// ultimately be inferred to be by-reference.\n-    ///\n-    /// Note that implicit reference skipping is not implemented yet (#42640).\n-    Unannotated,\n-\n-    /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n-    Mutable,\n-\n-    /// Annotated as `ref`, like `ref x`\n-    Ref,\n-\n-    /// Annotated as `ref mut x`.\n-    RefMut,\n-}\n-\n #[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum RangeEnd {\n     Included,\n@@ -1088,6 +1066,35 @@ impl fmt::Display for RangeEnd {\n     }\n }\n \n+// Equivalent to `Option<usize>`. That type takes up 16 bytes on 64-bit, but\n+// this type only takes up 4 bytes, at the cost of being restricted to a\n+// maximum value of `u32::MAX - 1`. In practice, this is more than enough.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, HashStable_Generic)]\n+pub struct DotDotPos(u32);\n+\n+impl DotDotPos {\n+    // Panics if n >= u32::MAX.\n+    pub fn new(n: Option<usize>) -> Self {\n+        match n {\n+            Some(n) => {\n+                assert!(n < u32::MAX as usize);\n+                Self(n as u32)\n+            }\n+            None => Self(u32::MAX),\n+        }\n+    }\n+\n+    pub fn as_opt_usize(&self) -> Option<usize> {\n+        if self.0 == u32::MAX { None } else { Some(self.0 as usize) }\n+    }\n+}\n+\n+impl fmt::Debug for DotDotPos {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.as_opt_usize().fmt(f)\n+    }\n+}\n+\n #[derive(Debug, HashStable_Generic)]\n pub enum PatKind<'hir> {\n     /// Represents a wildcard pattern (i.e., `_`).\n@@ -1104,9 +1111,9 @@ pub enum PatKind<'hir> {\n     Struct(QPath<'hir>, &'hir [PatField<'hir>], bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n-    /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n+    /// If the `..` pattern fragment is present, then `DotDotPos` denotes its position.\n     /// `0 <= position <= subpats.len()`\n-    TupleStruct(QPath<'hir>, &'hir [Pat<'hir>], Option<usize>),\n+    TupleStruct(QPath<'hir>, &'hir [Pat<'hir>], DotDotPos),\n \n     /// An or-pattern `A | B | C`.\n     /// Invariant: `pats.len() >= 2`.\n@@ -1118,7 +1125,7 @@ pub enum PatKind<'hir> {\n     /// A tuple pattern (e.g., `(a, b)`).\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// `0 <= position <= subpats.len()`\n-    Tuple(&'hir [Pat<'hir>], Option<usize>),\n+    Tuple(&'hir [Pat<'hir>], DotDotPos),\n \n     /// A `box` pattern.\n     Box(&'hir Pat<'hir>),\n@@ -1321,7 +1328,7 @@ pub enum StmtKind<'hir> {\n     Semi(&'hir Expr<'hir>),\n }\n \n-/// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n+/// Represents a `let` statement (i.e., `let <pat>:<ty> = <init>;`).\n #[derive(Debug, HashStable_Generic)]\n pub struct Local<'hir> {\n     pub pat: &'hir Pat<'hir>,\n@@ -1438,7 +1445,7 @@ pub struct BodyId {\n #[derive(Debug, HashStable_Generic)]\n pub struct Body<'hir> {\n     pub params: &'hir [Param<'hir>],\n-    pub value: Expr<'hir>,\n+    pub value: &'hir Expr<'hir>,\n     pub generator_kind: Option<GeneratorKind>,\n }\n \n@@ -1881,19 +1888,19 @@ pub enum ExprKind<'hir> {\n     ///\n     /// The `PathSegment` represents the method name and its generic arguments\n     /// (within the angle brackets).\n-    /// The first element of the `&[Expr]` is the expression that evaluates\n+    /// The `&Expr` is the expression that evaluates\n     /// to the object on which the method is being called on (the receiver),\n-    /// and the remaining elements are the rest of the arguments.\n+    /// and the `&[Expr]` is the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n-    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d], span)`.\n+    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, x, [a, b, c, d], span)`.\n     /// The final `Span` represents the span of the function and arguments\n     /// (e.g. `foo::<Bar, Baz>(a, b, c, d)` in `x.foo::<Bar, Baz>(a, b, c, d)`\n     ///\n     /// To resolve the called method to a `DefId`, call [`type_dependent_def_id`] with\n     /// the `hir_id` of the `MethodCall` node itself.\n     ///\n     /// [`type_dependent_def_id`]: ../../rustc_middle/ty/struct.TypeckResults.html#method.type_dependent_def_id\n-    MethodCall(&'hir PathSegment<'hir>, &'hir [Expr<'hir>], Span),\n+    MethodCall(&'hir PathSegment<'hir>, &'hir Expr<'hir>, &'hir [Expr<'hir>], Span),\n     /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(&'hir [Expr<'hir>]),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n@@ -2199,14 +2206,14 @@ pub struct FnSig<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct TraitItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl TraitItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n@@ -2217,7 +2224,7 @@ impl TraitItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n@@ -2228,7 +2235,7 @@ impl TraitItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn trait_item_id(&self) -> TraitItemId {\n@@ -2263,22 +2270,22 @@ pub enum TraitItemKind<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ImplItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl ImplItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n /// Represents anything within an `impl` block.\n #[derive(Debug, HashStable_Generic)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub defaultness: Defaultness,\n@@ -2290,7 +2297,7 @@ impl ImplItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn impl_item_id(&self) -> ImplItemId {\n@@ -2401,6 +2408,14 @@ impl<'hir> Ty<'hir> {\n             _ => None,\n         }\n     }\n+\n+    pub fn peel_refs(&self) -> &Self {\n+        let mut final_ty = self;\n+        while let TyKind::Rptr(_, MutTy { ty, .. }) = &final_ty.kind {\n+            final_ty = &ty;\n+        }\n+        final_ty\n+    }\n }\n \n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n@@ -2505,6 +2520,7 @@ pub struct OpaqueTy<'hir> {\n     pub generics: &'hir Generics<'hir>,\n     pub bounds: GenericBounds<'hir>,\n     pub origin: OpaqueTyOrigin,\n+    pub in_trait: bool,\n }\n \n /// From whence the opaque type came.\n@@ -2528,7 +2544,7 @@ pub enum TyKind<'hir> {\n     /// A raw pointer (i.e., `*const T` or `*mut T`).\n     Ptr(MutTy<'hir>),\n     /// A reference (i.e., `&'a T` or `&'a mut T`).\n-    Rptr(Lifetime, MutTy<'hir>),\n+    Rptr(&'hir Lifetime, MutTy<'hir>),\n     /// A bare function (e.g., `fn(usize) -> bool`).\n     BareFn(&'hir BareFnTy<'hir>),\n     /// The never type (`!`).\n@@ -2544,10 +2560,12 @@ pub enum TyKind<'hir> {\n     ///\n     /// The generic argument list contains the lifetimes (and in the future\n     /// possibly parameters) that are actually bound on the `impl Trait`.\n-    OpaqueDef(ItemId, &'hir [GenericArg<'hir>]),\n+    ///\n+    /// The last parameter specifies whether this opaque appears in a trait definition.\n+    OpaqueDef(ItemId, &'hir [GenericArg<'hir>], bool),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n-    TraitObject(&'hir [PolyTraitRef<'hir>], Lifetime, TraitObjectSyntax),\n+    TraitObject(&'hir [PolyTraitRef<'hir>], &'hir Lifetime, TraitObjectSyntax),\n     /// Unused for now.\n     Typeof(AnonConst),\n     /// `TyKind::Infer` means the type should be inferred instead of it having been\n@@ -2561,23 +2579,23 @@ pub enum TyKind<'hir> {\n pub enum InlineAsmOperand<'hir> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n-        expr: Expr<'hir>,\n+        expr: &'hir Expr<'hir>,\n     },\n     Out {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        expr: Option<Expr<'hir>>,\n+        expr: Option<&'hir Expr<'hir>>,\n     },\n     InOut {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        expr: Expr<'hir>,\n+        expr: &'hir Expr<'hir>,\n     },\n     SplitInOut {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        in_expr: Expr<'hir>,\n-        out_expr: Option<Expr<'hir>>,\n+        in_expr: &'hir Expr<'hir>,\n+        out_expr: Option<&'hir Expr<'hir>>,\n     },\n     Const {\n         anon_const: AnonConst,\n@@ -2642,7 +2660,7 @@ pub struct FnDecl<'hir> {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Copy, Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -2870,14 +2888,14 @@ impl<'hir> VariantData<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, Hash, HashStable_Generic)]\n pub struct ItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl ItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n@@ -2887,7 +2905,7 @@ impl ItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub kind: ItemKind<'hir>,\n     pub span: Span,\n     pub vis_span: Span,\n@@ -2897,7 +2915,7 @@ impl Item<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn item_id(&self) -> ItemId {\n@@ -2991,7 +3009,7 @@ pub enum ItemKind<'hir> {\n     /// A MBE macro definition (`macro_rules!` or `macro`).\n     Macro(ast::MacroDef, MacroKind),\n     /// A module.\n-    Mod(Mod<'hir>),\n+    Mod(&'hir Mod<'hir>),\n     /// An external module, e.g. `extern { .. }`.\n     ForeignMod { abi: Abi, items: &'hir [ForeignItemRef] },\n     /// Module-level inline assembly (from `global_asm!`).\n@@ -3114,14 +3132,14 @@ pub enum AssocItemKind {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ForeignItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl ForeignItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n@@ -3142,7 +3160,7 @@ pub struct ForeignItemRef {\n pub struct ForeignItem<'hir> {\n     pub ident: Ident,\n     pub kind: ForeignItemKind<'hir>,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub span: Span,\n     pub vis_span: Span,\n }\n@@ -3151,7 +3169,7 @@ impl ForeignItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn foreign_item_id(&self) -> ForeignItemId {\n@@ -3245,7 +3263,7 @@ impl<'hir> OwnerNode<'hir> {\n         Node::generics(self.into())\n     }\n \n-    pub fn def_id(self) -> LocalDefId {\n+    pub fn def_id(self) -> OwnerId {\n         match self {\n             OwnerNode::Item(Item { def_id, .. })\n             | OwnerNode::TraitItem(TraitItem { def_id, .. })\n@@ -3495,16 +3513,32 @@ impl<'hir> Node<'hir> {\n mod size_asserts {\n     use super::*;\n     // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(Block<'static>, 48);\n-    static_assert_size!(Expr<'static>, 56);\n-    static_assert_size!(ForeignItem<'static>, 72);\n+    static_assert_size!(Block<'_>, 48);\n+    static_assert_size!(Body<'_>, 32);\n+    static_assert_size!(Expr<'_>, 64);\n+    static_assert_size!(ExprKind<'_>, 48);\n+    static_assert_size!(FnDecl<'_>, 40);\n+    static_assert_size!(ForeignItem<'_>, 72);\n+    static_assert_size!(ForeignItemKind<'_>, 40);\n+    static_assert_size!(GenericArg<'_>, 24);\n     static_assert_size!(GenericBound<'_>, 48);\n-    static_assert_size!(Generics<'static>, 56);\n-    static_assert_size!(ImplItem<'static>, 88);\n-    static_assert_size!(Impl<'static>, 80);\n-    static_assert_size!(Item<'static>, 80);\n-    static_assert_size!(Pat<'static>, 88);\n-    static_assert_size!(QPath<'static>, 24);\n-    static_assert_size!(TraitItem<'static>, 96);\n-    static_assert_size!(Ty<'static>, 72);\n+    static_assert_size!(Generics<'_>, 56);\n+    static_assert_size!(Impl<'_>, 80);\n+    static_assert_size!(ImplItem<'_>, 80);\n+    static_assert_size!(ImplItemKind<'_>, 32);\n+    static_assert_size!(Item<'_>, 80);\n+    static_assert_size!(ItemKind<'_>, 48);\n+    static_assert_size!(Local<'_>, 64);\n+    static_assert_size!(Param<'_>, 32);\n+    static_assert_size!(Pat<'_>, 72);\n+    static_assert_size!(PatKind<'_>, 48);\n+    static_assert_size!(Path<'_>, 48);\n+    static_assert_size!(PathSegment<'_>, 56);\n+    static_assert_size!(QPath<'_>, 24);\n+    static_assert_size!(Stmt<'_>, 32);\n+    static_assert_size!(StmtKind<'_>, 16);\n+    static_assert_size!(TraitItem<'_>, 88);\n+    static_assert_size!(TraitItemKind<'_>, 48);\n+    static_assert_size!(Ty<'_>, 48);\n+    static_assert_size!(TyKind<'_>, 32);\n }"}, {"sha": "752f760ea9719395fcf8982ea0600b8f45aa2fc4", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,6 +1,43 @@\n-use crate::def_id::{LocalDefId, CRATE_DEF_ID};\n+use crate::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n+use rustc_span::{def_id::DefPathHash, HashStableContext};\n use std::fmt;\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Encodable, Decodable)]\n+pub struct OwnerId {\n+    pub def_id: LocalDefId,\n+}\n+\n+impl From<OwnerId> for HirId {\n+    fn from(owner: OwnerId) -> HirId {\n+        HirId { owner, local_id: ItemLocalId::from_u32(0) }\n+    }\n+}\n+\n+impl OwnerId {\n+    #[inline]\n+    pub fn to_def_id(self) -> DefId {\n+        self.def_id.to_def_id()\n+    }\n+}\n+\n+impl<CTX: HashStableContext> HashStable<CTX> for OwnerId {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.to_stable_hash_key(hcx).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<CTX: HashStableContext> ToStableHashKey<CTX> for OwnerId {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &CTX) -> DefPathHash {\n+        hcx.def_path_hash(self.to_def_id())\n+    }\n+}\n+\n /// Uniquely identifies a node in the HIR of the current crate. It is\n /// composed of the `owner`, which is the `LocalDefId` of the directly enclosing\n /// `hir::Item`, `hir::TraitItem`, or `hir::ImplItem` (i.e., the closest \"item-like\"),\n@@ -15,19 +52,23 @@ use std::fmt;\n #[derive(Encodable, Decodable, HashStable_Generic)]\n #[rustc_pass_by_value]\n pub struct HirId {\n-    pub owner: LocalDefId,\n+    pub owner: OwnerId,\n     pub local_id: ItemLocalId,\n }\n \n impl HirId {\n+    /// Signal local id which should never be used.\n+    pub const INVALID: HirId =\n+        HirId { owner: OwnerId { def_id: CRATE_DEF_ID }, local_id: ItemLocalId::INVALID };\n+\n     #[inline]\n-    pub fn expect_owner(self) -> LocalDefId {\n+    pub fn expect_owner(self) -> OwnerId {\n         assert_eq!(self.local_id.index(), 0);\n         self.owner\n     }\n \n     #[inline]\n-    pub fn as_owner(self) -> Option<LocalDefId> {\n+    pub fn as_owner(self) -> Option<OwnerId> {\n         if self.local_id.index() == 0 { Some(self.owner) } else { None }\n     }\n \n@@ -38,11 +79,14 @@ impl HirId {\n \n     #[inline]\n     pub fn make_owner(owner: LocalDefId) -> Self {\n-        Self { owner, local_id: ItemLocalId::from_u32(0) }\n+        Self { owner: OwnerId { def_id: owner }, local_id: ItemLocalId::from_u32(0) }\n     }\n \n     pub fn index(self) -> (usize, usize) {\n-        (rustc_index::vec::Idx::index(self.owner), rustc_index::vec::Idx::index(self.local_id))\n+        (\n+            rustc_index::vec::Idx::index(self.owner.def_id),\n+            rustc_index::vec::Idx::index(self.local_id),\n+        )\n     }\n }\n \n@@ -64,8 +108,13 @@ impl PartialOrd for HirId {\n     }\n }\n \n-rustc_data_structures::define_id_collections!(HirIdMap, HirIdSet, HirId);\n-rustc_data_structures::define_id_collections!(ItemLocalMap, ItemLocalSet, ItemLocalId);\n+rustc_data_structures::define_stable_id_collections!(HirIdMap, HirIdSet, HirIdMapEntry, HirId);\n+rustc_data_structures::define_id_collections!(\n+    ItemLocalMap,\n+    ItemLocalSet,\n+    ItemLocalMapEntry,\n+    ItemLocalId\n+);\n \n rustc_index::newtype_index! {\n     /// An `ItemLocalId` uniquely identifies something within a given \"item-like\";\n@@ -86,4 +135,7 @@ impl ItemLocalId {\n }\n \n /// The `HirId` corresponding to `CRATE_NODE_ID` and `CRATE_DEF_ID`.\n-pub const CRATE_HIR_ID: HirId = HirId { owner: CRATE_DEF_ID, local_id: ItemLocalId::from_u32(0) };\n+pub const CRATE_HIR_ID: HirId =\n+    HirId { owner: OwnerId { def_id: CRATE_DEF_ID }, local_id: ItemLocalId::from_u32(0) };\n+\n+pub const CRATE_OWNER_ID: OwnerId = OwnerId { def_id: CRATE_DEF_ID };"}, {"sha": "8f5f314ecae1d309323611c8f4116494eb20edb3", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 32, "deletions": 48, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -298,7 +298,7 @@ pub trait Visitor<'v>: Sized {\n     fn visit_id(&mut self, _hir_id: HirId) {\n         // Nothing to do.\n     }\n-    fn visit_name(&mut self, _span: Span, _name: Symbol) {\n+    fn visit_name(&mut self, _name: Symbol) {\n         // Nothing to do.\n     }\n     fn visit_ident(&mut self, ident: Ident) {\n@@ -361,8 +361,8 @@ pub trait Visitor<'v>: Sized {\n     fn visit_fn_decl(&mut self, fd: &'v FnDecl<'v>) {\n         walk_fn_decl(self, fd)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl<'v>, b: BodyId, s: Span, id: HirId) {\n-        walk_fn(self, fk, fd, b, s, id)\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl<'v>, b: BodyId, _: Span, id: HirId) {\n+        walk_fn(self, fk, fd, b, id)\n     }\n     fn visit_use(&mut self, path: &'v Path<'v>, hir_id: HirId) {\n         walk_use(self, path, hir_id)\n@@ -388,8 +388,8 @@ pub trait Visitor<'v>: Sized {\n     fn visit_param_bound(&mut self, bounds: &'v GenericBound<'v>) {\n         walk_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef<'v>, m: TraitBoundModifier) {\n-        walk_poly_trait_ref(self, t, m)\n+    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef<'v>) {\n+        walk_poly_trait_ref(self, t)\n     }\n     fn visit_variant_data(&mut self, s: &'v VariantData<'v>) {\n         walk_struct_def(self, s)\n@@ -420,17 +420,18 @@ pub trait Visitor<'v>: Sized {\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_qpath(&mut self, qpath: &'v QPath<'v>, id: HirId, span: Span) {\n-        walk_qpath(self, qpath, id, span)\n+    // The span is that of the surrounding type/pattern/expr/whatever.\n+    fn visit_qpath(&mut self, qpath: &'v QPath<'v>, id: HirId, _span: Span) {\n+        walk_qpath(self, qpath, id)\n     }\n     fn visit_path(&mut self, path: &'v Path<'v>, _id: HirId) {\n         walk_path(self, path)\n     }\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment<'v>) {\n-        walk_path_segment(self, path_span, path_segment)\n+    fn visit_path_segment(&mut self, path_segment: &'v PathSegment<'v>) {\n+        walk_path_segment(self, path_segment)\n     }\n-    fn visit_generic_args(&mut self, path_span: Span, generic_args: &'v GenericArgs<'v>) {\n-        walk_generic_args(self, path_span, generic_args)\n+    fn visit_generic_args(&mut self, generic_args: &'v GenericArgs<'v>) {\n+        walk_generic_args(self, generic_args)\n     }\n     fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding<'v>) {\n         walk_assoc_type_binding(self, type_binding)\n@@ -472,7 +473,7 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n }\n \n pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n-    visitor.visit_name(ident.span, ident.name);\n+    visitor.visit_name(ident.name);\n }\n \n pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n@@ -494,11 +495,7 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n     }\n }\n \n-pub fn walk_poly_trait_ref<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    trait_ref: &'v PolyTraitRef<'v>,\n-    _modifier: TraitBoundModifier,\n-) {\n+pub fn walk_poly_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v PolyTraitRef<'v>) {\n     walk_list!(visitor, visit_generic_param, trait_ref.bound_generic_params);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n@@ -519,7 +516,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n         ItemKind::ExternCrate(orig_name) => {\n             visitor.visit_id(item.hir_id());\n             if let Some(orig_name) = orig_name {\n-                visitor.visit_name(item.span, orig_name);\n+                visitor.visit_name(orig_name);\n             }\n         }\n         ItemKind::Use(ref path, _) => {\n@@ -670,7 +667,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n         TyKind::Path(ref qpath) => {\n             visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n         }\n-        TyKind::OpaqueDef(item_id, lifetimes) => {\n+        TyKind::OpaqueDef(item_id, lifetimes, _in_trait) => {\n             visitor.visit_nested_item(item_id);\n             walk_list!(visitor, visit_generic_arg, lifetimes);\n         }\n@@ -680,7 +677,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n         }\n         TyKind::TraitObject(bounds, ref lifetime, _syntax) => {\n             for bound in bounds {\n-                visitor.visit_poly_trait_ref(bound, TraitBoundModifier::None);\n+                visitor.visit_poly_trait_ref(bound);\n             }\n             visitor.visit_lifetime(lifetime);\n         }\n@@ -693,48 +690,35 @@ pub fn walk_inf<'v, V: Visitor<'v>>(visitor: &mut V, inf: &'v InferArg) {\n     visitor.visit_id(inf.hir_id);\n }\n \n-pub fn walk_qpath<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    qpath: &'v QPath<'v>,\n-    id: HirId,\n-    span: Span,\n-) {\n+pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath<'v>, id: HirId) {\n     match *qpath {\n         QPath::Resolved(ref maybe_qself, ref path) => {\n             walk_list!(visitor, visit_ty, maybe_qself);\n             visitor.visit_path(path, id)\n         }\n         QPath::TypeRelative(ref qself, ref segment) => {\n             visitor.visit_ty(qself);\n-            visitor.visit_path_segment(span, segment);\n+            visitor.visit_path_segment(segment);\n         }\n         QPath::LangItem(..) => {}\n     }\n }\n \n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n     for segment in path.segments {\n-        visitor.visit_path_segment(path.span, segment);\n+        visitor.visit_path_segment(segment);\n     }\n }\n \n-pub fn walk_path_segment<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    path_span: Span,\n-    segment: &'v PathSegment<'v>,\n-) {\n+pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V, segment: &'v PathSegment<'v>) {\n     visitor.visit_ident(segment.ident);\n-    walk_list!(visitor, visit_id, segment.hir_id);\n+    visitor.visit_id(segment.hir_id);\n     if let Some(ref args) = segment.args {\n-        visitor.visit_generic_args(path_span, args);\n+        visitor.visit_generic_args(args);\n     }\n }\n \n-pub fn walk_generic_args<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    _path_span: Span,\n-    generic_args: &'v GenericArgs<'v>,\n-) {\n+pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V, generic_args: &'v GenericArgs<'v>) {\n     walk_list!(visitor, visit_generic_arg, generic_args.args);\n     walk_list!(visitor, visit_assoc_type_binding, generic_args.bindings);\n }\n@@ -745,7 +729,7 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n ) {\n     visitor.visit_id(type_binding.hir_id);\n     visitor.visit_ident(type_binding.ident);\n-    visitor.visit_generic_args(type_binding.span, type_binding.gen_args);\n+    visitor.visit_generic_args(type_binding.gen_args);\n     match type_binding.kind {\n         TypeBindingKind::Equality { ref term } => match term {\n             Term::Ty(ref ty) => visitor.visit_ty(ty),\n@@ -819,12 +803,12 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n \n pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n     match *bound {\n-        GenericBound::Trait(ref typ, modifier) => {\n-            visitor.visit_poly_trait_ref(typ, modifier);\n+        GenericBound::Trait(ref typ, _modifier) => {\n+            visitor.visit_poly_trait_ref(typ);\n         }\n-        GenericBound::LangItemTrait(_, span, hir_id, args) => {\n+        GenericBound::LangItemTrait(_, _span, hir_id, args) => {\n             visitor.visit_id(hir_id);\n-            visitor.visit_generic_args(span, args);\n+            visitor.visit_generic_args(args);\n         }\n         GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n     }\n@@ -910,7 +894,6 @@ pub fn walk_fn<'v, V: Visitor<'v>>(\n     function_kind: FnKind<'v>,\n     function_declaration: &'v FnDecl<'v>,\n     body_id: BodyId,\n-    _span: Span,\n     id: HirId,\n ) {\n     visitor.visit_id(id);\n@@ -1094,8 +1077,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::MethodCall(ref segment, arguments, _) => {\n-            visitor.visit_path_segment(expression.span, segment);\n+        ExprKind::MethodCall(ref segment, receiver, arguments, _) => {\n+            visitor.visit_path_segment(segment);\n+            visitor.visit_expr(receiver);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n         ExprKind::Binary(_, ref left_expression, ref right_expression) => {"}, {"sha": "ca615a4912a193ed362282fa44b3aeb153b00ab6", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -193,7 +193,8 @@ language_item_table! {\n     DispatchFromDyn,         sym::dispatch_from_dyn,   dispatch_from_dyn_trait,    Target::Trait,          GenericRequirement::Minimum(1);\n \n     // language items relating to transmutability\n-    TransmuteTrait,          sym::transmute_trait,     transmute_trait,            Target::Trait,          GenericRequirement::Exact(6);\n+    TransmuteOpts,           sym::transmute_opts,      transmute_opts,             Target::Struct,         GenericRequirement::Exact(0);\n+    TransmuteTrait,          sym::transmute_trait,     transmute_trait,            Target::Trait,          GenericRequirement::Exact(3);\n \n     Add(Op),                 sym::add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n     Sub(Op),                 sym::sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n@@ -237,7 +238,6 @@ language_item_table! {\n     Future,                  sym::future_trait,        future_trait,               Target::Trait,          GenericRequirement::Exact(0);\n     GeneratorState,          sym::generator_state,     gen_state,                  Target::Enum,           GenericRequirement::None;\n     Generator,               sym::generator,           gen_trait,                  Target::Trait,          GenericRequirement::Minimum(1);\n-    GeneratorReturn,         sym::generator_return,    generator_return,           Target::AssocTy,        GenericRequirement::None;\n     Unpin,                   sym::unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n     Pin,                     sym::pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n \n@@ -268,8 +268,6 @@ language_item_table! {\n     DropInPlace,             sym::drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n     Oom,                     sym::oom,                 oom,                        Target::Fn,             GenericRequirement::None;\n     AllocLayout,             sym::alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n-    ConstEvalSelect,         sym::const_eval_select,   const_eval_select,          Target::Fn,             GenericRequirement::Exact(4);\n-    ConstConstEvalSelect,    sym::const_eval_select_ct,const_eval_select_ct,       Target::Fn,             GenericRequirement::Exact(4);\n \n     Start,                   sym::start,               start_fn,                   Target::Fn,             GenericRequirement::Exact(1);\n \n@@ -291,6 +289,8 @@ language_item_table! {\n \n     Try,                     sym::Try,                 try_trait,                  Target::Trait,          GenericRequirement::None;\n \n+    Tuple,                   sym::tuple_trait,         tuple_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+\n     SliceLen,                sym::slice_len_fn,        slice_len_fn,               Target::Method(MethodKind::Inherent), GenericRequirement::None;\n \n     // Language items from AST lowering"}, {"sha": "1c4aa420c9bf9bb59d116b0b8efa10ec484c846e", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -4,8 +4,7 @@\n \n #![feature(associated_type_defaults)]\n #![feature(closure_track_caller)]\n-#![feature(const_btree_new)]\n-#![feature(let_else)]\n+#![feature(const_btree_len)]\n #![feature(once_cell)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n@@ -17,6 +16,9 @@\n #[macro_use]\n extern crate rustc_macros;\n \n+#[macro_use]\n+extern crate tracing;\n+\n #[macro_use]\n extern crate rustc_data_structures;\n "}, {"sha": "0c1819bb0c745ef45190480c5cb3460b5bd757b2", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,6 +1,6 @@\n use crate::def::{CtorOf, DefKind, Res};\n use crate::def_id::DefId;\n-use crate::hir::{self, HirId, PatKind};\n+use crate::hir::{self, BindingAnnotation, ByRef, HirId, PatKind};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::Ident;\n@@ -35,7 +35,7 @@ pub trait EnumerateAndAdjustIterator {\n     fn enumerate_and_adjust(\n         self,\n         expected_len: usize,\n-        gap_pos: Option<usize>,\n+        gap_pos: hir::DotDotPos,\n     ) -> EnumerateAndAdjust<Self>\n     where\n         Self: Sized;\n@@ -45,15 +45,15 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n     fn enumerate_and_adjust(\n         self,\n         expected_len: usize,\n-        gap_pos: Option<usize>,\n+        gap_pos: hir::DotDotPos,\n     ) -> EnumerateAndAdjust<Self>\n     where\n         Self: Sized,\n     {\n         let actual_len = self.len();\n         EnumerateAndAdjust {\n             enumerate: self.enumerate(),\n-            gap_pos: gap_pos.unwrap_or(expected_len),\n+            gap_pos: gap_pos.as_opt_usize().unwrap_or(expected_len),\n             gap_len: expected_len - actual_len,\n         }\n     }\n@@ -93,12 +93,7 @@ impl hir::Pat<'_> {\n \n     pub fn simple_ident(&self) -> Option<Ident> {\n         match self.kind {\n-            PatKind::Binding(\n-                hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable,\n-                _,\n-                ident,\n-                None,\n-            ) => Some(ident),\n+            PatKind::Binding(BindingAnnotation(ByRef::No, _), _, ident, None) => Some(ident),\n             _ => None,\n         }\n     }\n@@ -135,11 +130,11 @@ impl hir::Pat<'_> {\n     pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| match annotation {\n-            hir::BindingAnnotation::Ref => match result {\n+            hir::BindingAnnotation::REF => match result {\n                 None | Some(hir::Mutability::Not) => result = Some(hir::Mutability::Not),\n                 _ => {}\n             },\n-            hir::BindingAnnotation::RefMut => result = Some(hir::Mutability::Mut),\n+            hir::BindingAnnotation::REF_MUT => result = Some(hir::Mutability::Mut),\n             _ => {}\n         });\n         result"}, {"sha": "06b7a65662e7cbe5b3573cf176d8aefbfbe0fcd4", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -20,7 +20,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for HirId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> (DefPathHash, ItemLocalId) {\n-        let def_path_hash = self.owner.to_stable_hash_key(hcx);\n+        let def_path_hash = self.owner.def_id.to_stable_hash_key(hcx);\n         (def_path_hash, self.local_id)\n     }\n }\n@@ -49,7 +49,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -58,7 +58,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for TraitItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -67,7 +67,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ImplItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -76,7 +76,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ForeignItemId\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n "}, {"sha": "5917d5e346e371d2a1da00c227dcf2924f4bf51f", "filename": "compiler/rustc_hir/src/target.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -36,6 +36,7 @@ pub enum Target {\n     GlobalAsm,\n     TyAlias,\n     OpaqueTy,\n+    ImplTraitPlaceholder,\n     Enum,\n     Variant,\n     Struct,\n@@ -79,7 +80,13 @@ impl Target {\n             ItemKind::ForeignMod { .. } => Target::ForeignMod,\n             ItemKind::GlobalAsm(..) => Target::GlobalAsm,\n             ItemKind::TyAlias(..) => Target::TyAlias,\n-            ItemKind::OpaqueTy(..) => Target::OpaqueTy,\n+            ItemKind::OpaqueTy(ref opaque) => {\n+                if opaque.in_trait {\n+                    Target::ImplTraitPlaceholder\n+                } else {\n+                    Target::OpaqueTy\n+                }\n+            }\n             ItemKind::Enum(..) => Target::Enum,\n             ItemKind::Struct(..) => Target::Struct,\n             ItemKind::Union(..) => Target::Union,\n@@ -103,6 +110,7 @@ impl Target {\n             DefKind::GlobalAsm => Target::GlobalAsm,\n             DefKind::TyAlias => Target::TyAlias,\n             DefKind::OpaqueTy => Target::OpaqueTy,\n+            DefKind::ImplTraitPlaceholder => Target::ImplTraitPlaceholder,\n             DefKind::Enum => Target::Enum,\n             DefKind::Struct => Target::Struct,\n             DefKind::Union => Target::Union,\n@@ -157,6 +165,7 @@ impl Target {\n             Target::GlobalAsm => \"global asm\",\n             Target::TyAlias => \"type alias\",\n             Target::OpaqueTy => \"opaque type\",\n+            Target::ImplTraitPlaceholder => \"opaque type in trait\",\n             Target::Enum => \"enum\",\n             Target::Variant => \"enum variant\",\n             Target::Struct => \"struct\","}, {"sha": "da9c9c1216e9d7c574ae8e3d7beb0ea3b18a84ed", "filename": "compiler/rustc_hir/src/weak_lang_items.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -18,6 +18,12 @@ pub static WEAK_ITEMS_REFS: LazyLock<FxIndexMap<Symbol, LangItem>> = LazyLock::n\n     map\n });\n \n+pub static WEAK_ITEMS_SYMBOLS: LazyLock<FxIndexMap<LangItem, Symbol>> = LazyLock::new(|| {\n+    let mut map = FxIndexMap::default();\n+    $(map.insert(LangItem::$item, sym::$sym);)*\n+    map\n+});\n+\n pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol>\n {\n     lang_items::extract(attrs).and_then(|(name, _)| {"}, {"sha": "35a58296e370e4aa0daf15caa39690d9dc7cc46c", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 31, "deletions": 51, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -9,7 +9,9 @@ use rustc_ast_pretty::pp::{self, Breaks};\n use rustc_ast_pretty::pprust::{Comments, PrintState};\n use rustc_hir as hir;\n use rustc_hir::LifetimeParamKind;\n-use rustc_hir::{GenericArg, GenericParam, GenericParamKind, Node, Term};\n+use rustc_hir::{\n+    BindingAnnotation, ByRef, GenericArg, GenericParam, GenericParamKind, Mutability, Node, Term,\n+};\n use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, Ident, IdentPrinter, Symbol};\n@@ -1181,15 +1183,20 @@ impl<'a> State<'a> {\n         self.print_call_post(args)\n     }\n \n-    fn print_expr_method_call(&mut self, segment: &hir::PathSegment<'_>, args: &[hir::Expr<'_>]) {\n-        let base_args = &args[1..];\n-        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n+    fn print_expr_method_call(\n+        &mut self,\n+        segment: &hir::PathSegment<'_>,\n+        receiver: &hir::Expr<'_>,\n+        args: &[hir::Expr<'_>],\n+    ) {\n+        let base_args = args;\n+        self.print_expr_maybe_paren(&receiver, parser::PREC_POSTFIX);\n         self.word(\".\");\n         self.print_ident(segment.ident);\n \n         let generic_args = segment.args();\n         if !generic_args.args.is_empty() || !generic_args.bindings.is_empty() {\n-            self.print_generic_args(generic_args, segment.infer_args, true);\n+            self.print_generic_args(generic_args, true);\n         }\n \n         self.print_call_post(base_args)\n@@ -1394,8 +1401,8 @@ impl<'a> State<'a> {\n             hir::ExprKind::Call(func, args) => {\n                 self.print_expr_call(func, args);\n             }\n-            hir::ExprKind::MethodCall(segment, args, _) => {\n-                self.print_expr_method_call(segment, args);\n+            hir::ExprKind::MethodCall(segment, receiver, args, _) => {\n+                self.print_expr_method_call(segment, receiver, args);\n             }\n             hir::ExprKind::Binary(op, lhs, rhs) => {\n                 self.print_expr_binary(op, lhs, rhs);\n@@ -1592,15 +1599,15 @@ impl<'a> State<'a> {\n             }\n             if segment.ident.name != kw::PathRoot {\n                 self.print_ident(segment.ident);\n-                self.print_generic_args(segment.args(), segment.infer_args, colons_before_params);\n+                self.print_generic_args(segment.args(), colons_before_params);\n             }\n         }\n     }\n \n     pub fn print_path_segment(&mut self, segment: &hir::PathSegment<'_>) {\n         if segment.ident.name != kw::PathRoot {\n             self.print_ident(segment.ident);\n-            self.print_generic_args(segment.args(), segment.infer_args, false);\n+            self.print_generic_args(segment.args(), false);\n         }\n     }\n \n@@ -1619,23 +1626,15 @@ impl<'a> State<'a> {\n                     }\n                     if segment.ident.name != kw::PathRoot {\n                         self.print_ident(segment.ident);\n-                        self.print_generic_args(\n-                            segment.args(),\n-                            segment.infer_args,\n-                            colons_before_params,\n-                        );\n+                        self.print_generic_args(segment.args(), colons_before_params);\n                     }\n                 }\n \n                 self.word(\">\");\n                 self.word(\"::\");\n                 let item_segment = path.segments.last().unwrap();\n                 self.print_ident(item_segment.ident);\n-                self.print_generic_args(\n-                    item_segment.args(),\n-                    item_segment.infer_args,\n-                    colons_before_params,\n-                )\n+                self.print_generic_args(item_segment.args(), colons_before_params)\n             }\n             hir::QPath::TypeRelative(qself, item_segment) => {\n                 // If we've got a compound-qualified-path, let's push an additional pair of angle\n@@ -1651,11 +1650,7 @@ impl<'a> State<'a> {\n \n                 self.word(\"::\");\n                 self.print_ident(item_segment.ident);\n-                self.print_generic_args(\n-                    item_segment.args(),\n-                    item_segment.infer_args,\n-                    colons_before_params,\n-                )\n+                self.print_generic_args(item_segment.args(), colons_before_params)\n             }\n             hir::QPath::LangItem(lang_item, span, _) => {\n                 self.word(\"#[lang = \\\"\");\n@@ -1668,7 +1663,6 @@ impl<'a> State<'a> {\n     fn print_generic_args(\n         &mut self,\n         generic_args: &hir::GenericArgs<'_>,\n-        infer_args: bool,\n         colons_before_params: bool,\n     ) {\n         if generic_args.parenthesized {\n@@ -1715,13 +1709,6 @@ impl<'a> State<'a> {\n                 );\n             }\n \n-            // FIXME(eddyb): this would leak into error messages (e.g.,\n-            // \"non-exhaustive patterns: `Some::<..>(_)` not covered\").\n-            if infer_args && false {\n-                start_or_comma(self);\n-                self.word(\"..\");\n-            }\n-\n             for binding in generic_args.bindings {\n                 start_or_comma(self);\n                 self.print_type_binding(binding);\n@@ -1735,7 +1722,7 @@ impl<'a> State<'a> {\n \n     pub fn print_type_binding(&mut self, binding: &hir::TypeBinding<'_>) {\n         self.print_ident(binding.ident);\n-        self.print_generic_args(binding.gen_args, false, false);\n+        self.print_generic_args(binding.gen_args, false);\n         self.space();\n         match binding.kind {\n             hir::TypeBindingKind::Equality { ref term } => {\n@@ -1758,20 +1745,12 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.kind {\n             PatKind::Wild => self.word(\"_\"),\n-            PatKind::Binding(binding_mode, _, ident, sub) => {\n-                match binding_mode {\n-                    hir::BindingAnnotation::Ref => {\n-                        self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Not, false);\n-                    }\n-                    hir::BindingAnnotation::RefMut => {\n-                        self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Mut, false);\n-                    }\n-                    hir::BindingAnnotation::Unannotated => {}\n-                    hir::BindingAnnotation::Mutable => {\n-                        self.word_nbsp(\"mut\");\n-                    }\n+            PatKind::Binding(BindingAnnotation(by_ref, mutbl), _, ident, sub) => {\n+                if by_ref == ByRef::Yes {\n+                    self.word_nbsp(\"ref\");\n+                }\n+                if mutbl == Mutability::Mut {\n+                    self.word_nbsp(\"mut\");\n                 }\n                 self.print_ident(ident);\n                 if let Some(p) = sub {\n@@ -1782,7 +1761,8 @@ impl<'a> State<'a> {\n             PatKind::TupleStruct(ref qpath, elts, ddpos) => {\n                 self.print_qpath(qpath, true);\n                 self.popen();\n-                if let Some(ddpos) = ddpos {\n+                if let Some(ddpos) = ddpos.as_opt_usize() {\n+                    let ddpos = ddpos as usize;\n                     self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p));\n                     if ddpos != 0 {\n                         self.word_space(\",\");\n@@ -1825,7 +1805,7 @@ impl<'a> State<'a> {\n             }\n             PatKind::Tuple(elts, ddpos) => {\n                 self.popen();\n-                if let Some(ddpos) = ddpos {\n+                if let Some(ddpos) = ddpos.as_opt_usize() {\n                     self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p));\n                     if ddpos != 0 {\n                         self.word_space(\",\");\n@@ -2413,9 +2393,9 @@ fn contains_exterior_struct_lit(value: &hir::Expr<'_>) -> bool {\n             contains_exterior_struct_lit(x)\n         }\n \n-        hir::ExprKind::MethodCall(.., exprs, _) => {\n+        hir::ExprKind::MethodCall(_, receiver, ..) => {\n             // `X { y: 1 }.bar(...)`\n-            contains_exterior_struct_lit(&exprs[0])\n+            contains_exterior_struct_lit(receiver)\n         }\n \n         _ => false,"}, {"sha": "83dd9a67e61bc0f9b22325b38e6314366cb744fa", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -2,7 +2,6 @@\n \n #![deny(missing_docs)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(let_else)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "09163e4f25f3ccb9e5bfd60e439ede025396b1a9", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -149,19 +149,19 @@ pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n         let crate_items = tcx.hir_crate_items(());\n \n         for id in crate_items.items() {\n-            dirty_clean_visitor.check_item(id.def_id);\n+            dirty_clean_visitor.check_item(id.def_id.def_id);\n         }\n \n         for id in crate_items.trait_items() {\n-            dirty_clean_visitor.check_item(id.def_id);\n+            dirty_clean_visitor.check_item(id.def_id.def_id);\n         }\n \n         for id in crate_items.impl_items() {\n-            dirty_clean_visitor.check_item(id.def_id);\n+            dirty_clean_visitor.check_item(id.def_id.def_id);\n         }\n \n         for id in crate_items.foreign_items() {\n-            dirty_clean_visitor.check_item(id.def_id);\n+            dirty_clean_visitor.check_item(id.def_id.def_id);\n         }\n \n         let mut all_attrs = FindAllAttrs { tcx, found_attrs: vec![] };"}, {"sha": "9753fb355308c2a0a829be4ba3224d569a8bfe7e", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -3,7 +3,6 @@\n #![feature(allow_internal_unstable)]\n #![feature(bench_black_box)]\n #![feature(extend_one)]\n-#![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(new_uninit)]\n #![feature(step_trait)]"}, {"sha": "938f8aa77a5b4589f6e5eb2f5ed5956fce22ee8b", "filename": "compiler/rustc_infer/src/errors.rs", "status": "removed", "additions": 0, "deletions": 254, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,254 +0,0 @@\n-use rustc_errors::{fluent, AddSubdiagnostic, DiagnosticMessage, DiagnosticStyledString};\n-use rustc_hir::FnRetTy;\n-use rustc_macros::SessionDiagnostic;\n-use rustc_span::{BytePos, Span};\n-\n-use crate::infer::error_reporting::{\n-    need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n-    ObligationCauseAsDiagArg,\n-};\n-\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::opaque_hidden_type)]\n-pub struct OpaqueHiddenTypeDiag {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    #[note(infer::opaque_type)]\n-    pub opaque_type: Span,\n-    #[note(infer::hidden_type)]\n-    pub hidden_type: Span,\n-}\n-\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0282\")]\n-pub struct AnnotationRequired<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub source_kind: &'static str,\n-    pub source_name: &'a str,\n-    #[label]\n-    pub failure_span: Option<Span>,\n-    #[subdiagnostic]\n-    pub bad_label: Option<InferenceBadError<'a>>,\n-    #[subdiagnostic]\n-    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n-    #[subdiagnostic]\n-    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n-}\n-\n-// Copy of `AnnotationRequired` for E0283\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0283\")]\n-pub struct AmbigousImpl<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub source_kind: &'static str,\n-    pub source_name: &'a str,\n-    #[label]\n-    pub failure_span: Option<Span>,\n-    #[subdiagnostic]\n-    pub bad_label: Option<InferenceBadError<'a>>,\n-    #[subdiagnostic]\n-    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n-    #[subdiagnostic]\n-    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n-}\n-\n-// Copy of `AnnotationRequired` for E0284\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0284\")]\n-pub struct AmbigousReturn<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub source_kind: &'static str,\n-    pub source_name: &'a str,\n-    #[label]\n-    pub failure_span: Option<Span>,\n-    #[subdiagnostic]\n-    pub bad_label: Option<InferenceBadError<'a>>,\n-    #[subdiagnostic]\n-    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n-    #[subdiagnostic]\n-    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n-}\n-\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n-pub struct NeedTypeInfoInGenerator<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub generator_kind: GeneratorKindAsDiagArg,\n-    #[subdiagnostic]\n-    pub bad_label: InferenceBadError<'a>,\n-}\n-\n-// Used when a better one isn't available\n-#[derive(SessionSubdiagnostic)]\n-#[label(infer::label_bad)]\n-pub struct InferenceBadError<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub bad_kind: &'static str,\n-    pub prefix_kind: UnderspecifiedArgKind,\n-    pub has_parent: bool,\n-    pub prefix: &'a str,\n-    pub parent_prefix: &'a str,\n-    pub parent_name: String,\n-    pub name: String,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-pub enum SourceKindSubdiag<'a> {\n-    #[suggestion_verbose(\n-        infer::source_kind_subdiag_let,\n-        code = \": {type_name}\",\n-        applicability = \"has-placeholders\"\n-    )]\n-    LetLike {\n-        #[primary_span]\n-        span: Span,\n-        name: String,\n-        type_name: String,\n-        kind: &'static str,\n-        x_kind: &'static str,\n-        prefix_kind: UnderspecifiedArgKind,\n-        prefix: &'a str,\n-        arg_name: String,\n-    },\n-    #[label(infer::source_kind_subdiag_generic_label)]\n-    GenericLabel {\n-        #[primary_span]\n-        span: Span,\n-        is_type: bool,\n-        param_name: String,\n-        parent_exists: bool,\n-        parent_prefix: String,\n-        parent_name: String,\n-    },\n-    #[suggestion_verbose(\n-        infer::source_kind_subdiag_generic_suggestion,\n-        code = \"::<{args}>\",\n-        applicability = \"has-placeholders\"\n-    )]\n-    GenericSuggestion {\n-        #[primary_span]\n-        span: Span,\n-        arg_count: usize,\n-        args: String,\n-    },\n-}\n-\n-// Has to be implemented manually because multipart suggestions are not supported by the derive macro.\n-// Would be a part of `SourceKindSubdiag` otherwise.\n-pub enum SourceKindMultiSuggestion<'a> {\n-    FullyQualified {\n-        span: Span,\n-        def_path: String,\n-        adjustment: &'a str,\n-        successor: (&'a str, BytePos),\n-    },\n-    ClosureReturn {\n-        ty_info: String,\n-        data: &'a FnRetTy<'a>,\n-        should_wrap_expr: Option<Span>,\n-    },\n-}\n-\n-impl AddSubdiagnostic for SourceKindMultiSuggestion<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n-        match self {\n-            Self::FullyQualified { span, def_path, adjustment, successor } => {\n-                let suggestion = vec![\n-                    (span.shrink_to_lo(), format!(\"{def_path}({adjustment}\")),\n-                    (span.shrink_to_hi().with_hi(successor.1), successor.0.to_string()),\n-                ];\n-                diag.multipart_suggestion_verbose(\n-                    fluent::infer::source_kind_fully_qualified,\n-                    suggestion,\n-                    rustc_errors::Applicability::HasPlaceholders,\n-                );\n-            }\n-            Self::ClosureReturn { ty_info, data, should_wrap_expr } => {\n-                let (arrow, post) = match data {\n-                    FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n-                    _ => (\"\", \"\"),\n-                };\n-                let suggestion = match should_wrap_expr {\n-                    Some(end_span) => vec![\n-                        (data.span(), format!(\"{}{}{}{{ \", arrow, ty_info, post)),\n-                        (end_span, \" }\".to_string()),\n-                    ],\n-                    None => vec![(data.span(), format!(\"{}{}{}\", arrow, ty_info, post))],\n-                };\n-                diag.multipart_suggestion_verbose(\n-                    fluent::infer::source_kind_closure_return,\n-                    suggestion,\n-                    rustc_errors::Applicability::HasPlaceholders,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-pub enum RegionOriginNote<'a> {\n-    Plain {\n-        span: Span,\n-        msg: DiagnosticMessage,\n-    },\n-    WithName {\n-        span: Span,\n-        msg: DiagnosticMessage,\n-        name: &'a str,\n-        continues: bool,\n-    },\n-    WithRequirement {\n-        span: Span,\n-        requirement: ObligationCauseAsDiagArg<'a>,\n-        expected_found: Option<(DiagnosticStyledString, DiagnosticStyledString)>,\n-    },\n-}\n-\n-impl AddSubdiagnostic for RegionOriginNote<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n-        let mut label_or_note = |span, msg: DiagnosticMessage| {\n-            let sub_count = diag.children.iter().filter(|d| d.span.is_dummy()).count();\n-            let expanded_sub_count = diag.children.iter().filter(|d| !d.span.is_dummy()).count();\n-            let span_is_primary = diag.span.primary_spans().iter().all(|&sp| sp == span);\n-            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n-                diag.span_label(span, msg);\n-            } else if span_is_primary && expanded_sub_count == 0 {\n-                diag.note(msg);\n-            } else {\n-                diag.span_note(span, msg);\n-            }\n-        };\n-        match self {\n-            RegionOriginNote::Plain { span, msg } => {\n-                label_or_note(span, msg);\n-            }\n-            RegionOriginNote::WithName { span, msg, name, continues } => {\n-                label_or_note(span, msg);\n-                diag.set_arg(\"name\", name);\n-                diag.set_arg(\"continues\", continues);\n-            }\n-            RegionOriginNote::WithRequirement {\n-                span,\n-                requirement,\n-                expected_found: Some((expected, found)),\n-            } => {\n-                label_or_note(span, fluent::infer::subtype);\n-                diag.set_arg(\"requirement\", requirement);\n-\n-                diag.note_expected_found(&\"\", expected, &\"\", found);\n-            }\n-            RegionOriginNote::WithRequirement { span, requirement, expected_found: None } => {\n-                // FIXME: this really should be handled at some earlier stage. Our\n-                // handling of region checking when type errors are present is\n-                // *terrible*.\n-                label_or_note(span, fluent::infer::subtype_2);\n-                diag.set_arg(\"requirement\", requirement);\n-            }\n-        };\n-    }\n-}"}, {"sha": "85b877652c6aad9fe4e4a91437a6ed463f7d9aae", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "added", "additions": 499, "deletions": 0, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -0,0 +1,499 @@\n+use hir::GenericParamKind;\n+use rustc_errors::{\n+    fluent, AddToDiagnostic, Applicability, DiagnosticMessage, DiagnosticStyledString, MultiSpan,\n+};\n+use rustc_hir as hir;\n+use rustc_hir::{FnRetTy, Ty};\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_middle::ty::{Region, TyCtxt};\n+use rustc_span::symbol::kw;\n+use rustc_span::{symbol::Ident, BytePos, Span};\n+\n+use crate::infer::error_reporting::{\n+    need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n+    ObligationCauseAsDiagArg,\n+};\n+\n+pub mod note_and_explain;\n+\n+#[derive(Diagnostic)]\n+#[diag(infer::opaque_hidden_type)]\n+pub struct OpaqueHiddenTypeDiag {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note(infer::opaque_type)]\n+    pub opaque_type: Span,\n+    #[note(infer::hidden_type)]\n+    pub hidden_type: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0282\")]\n+pub struct AnnotationRequired<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0283\n+#[derive(Diagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0283\")]\n+pub struct AmbigousImpl<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0284\n+#[derive(Diagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0284\")]\n+pub struct AmbigousReturn<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n+pub struct NeedTypeInfoInGenerator<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub generator_kind: GeneratorKindAsDiagArg,\n+    #[subdiagnostic]\n+    pub bad_label: InferenceBadError<'a>,\n+}\n+\n+// Used when a better one isn't available\n+#[derive(Subdiagnostic)]\n+#[label(infer::label_bad)]\n+pub struct InferenceBadError<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub bad_kind: &'static str,\n+    pub prefix_kind: UnderspecifiedArgKind,\n+    pub has_parent: bool,\n+    pub prefix: &'a str,\n+    pub parent_prefix: &'a str,\n+    pub parent_name: String,\n+    pub name: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SourceKindSubdiag<'a> {\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_let,\n+        code = \": {type_name}\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    LetLike {\n+        #[primary_span]\n+        span: Span,\n+        name: String,\n+        type_name: String,\n+        kind: &'static str,\n+        x_kind: &'static str,\n+        prefix_kind: UnderspecifiedArgKind,\n+        prefix: &'a str,\n+        arg_name: String,\n+    },\n+    #[label(infer::source_kind_subdiag_generic_label)]\n+    GenericLabel {\n+        #[primary_span]\n+        span: Span,\n+        is_type: bool,\n+        param_name: String,\n+        parent_exists: bool,\n+        parent_prefix: String,\n+        parent_name: String,\n+    },\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_generic_suggestion,\n+        code = \"::<{args}>\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    GenericSuggestion {\n+        #[primary_span]\n+        span: Span,\n+        arg_count: usize,\n+        args: String,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SourceKindMultiSuggestion<'a> {\n+    #[multipart_suggestion_verbose(\n+        infer::source_kind_fully_qualified,\n+        applicability = \"has-placeholders\"\n+    )]\n+    FullyQualified {\n+        #[suggestion_part(code = \"{def_path}({adjustment}\")]\n+        span_lo: Span,\n+        #[suggestion_part(code = \"{successor_pos}\")]\n+        span_hi: Span,\n+        def_path: String,\n+        adjustment: &'a str,\n+        successor_pos: &'a str,\n+    },\n+    #[multipart_suggestion_verbose(\n+        infer::source_kind_closure_return,\n+        applicability = \"has-placeholders\"\n+    )]\n+    ClosureReturn {\n+        #[suggestion_part(code = \"{start_span_code}\")]\n+        start_span: Span,\n+        start_span_code: String,\n+        #[suggestion_part(code = \" }}\")]\n+        end_span: Option<Span>,\n+    },\n+}\n+\n+impl<'a> SourceKindMultiSuggestion<'a> {\n+    pub fn new_fully_qualified(\n+        span: Span,\n+        def_path: String,\n+        adjustment: &'a str,\n+        successor: (&'a str, BytePos),\n+    ) -> Self {\n+        Self::FullyQualified {\n+            span_lo: span.shrink_to_lo(),\n+            span_hi: span.shrink_to_hi().with_hi(successor.1),\n+            def_path,\n+            adjustment,\n+            successor_pos: successor.0,\n+        }\n+    }\n+\n+    pub fn new_closure_return(\n+        ty_info: String,\n+        data: &'a FnRetTy<'a>,\n+        should_wrap_expr: Option<Span>,\n+    ) -> Self {\n+        let (arrow, post) = match data {\n+            FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+            _ => (\"\", \"\"),\n+        };\n+        let (start_span, start_span_code, end_span) = match should_wrap_expr {\n+            Some(end_span) => {\n+                (data.span(), format!(\"{}{}{}{{ \", arrow, ty_info, post), Some(end_span))\n+            }\n+            None => (data.span(), format!(\"{}{}{}\", arrow, ty_info, post), None),\n+        };\n+        Self::ClosureReturn { start_span, start_span_code, end_span }\n+    }\n+}\n+\n+pub enum RegionOriginNote<'a> {\n+    Plain {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+    },\n+    WithName {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+        name: &'a str,\n+        continues: bool,\n+    },\n+    WithRequirement {\n+        span: Span,\n+        requirement: ObligationCauseAsDiagArg<'a>,\n+        expected_found: Option<(DiagnosticStyledString, DiagnosticStyledString)>,\n+    },\n+}\n+\n+impl AddToDiagnostic for RegionOriginNote<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        let mut label_or_note = |span, msg: DiagnosticMessage| {\n+            let sub_count = diag.children.iter().filter(|d| d.span.is_dummy()).count();\n+            let expanded_sub_count = diag.children.iter().filter(|d| !d.span.is_dummy()).count();\n+            let span_is_primary = diag.span.primary_spans().iter().all(|&sp| sp == span);\n+            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n+                diag.span_label(span, msg);\n+            } else if span_is_primary && expanded_sub_count == 0 {\n+                diag.note(msg);\n+            } else {\n+                diag.span_note(span, msg);\n+            }\n+        };\n+        match self {\n+            RegionOriginNote::Plain { span, msg } => {\n+                label_or_note(span, msg);\n+            }\n+            RegionOriginNote::WithName { span, msg, name, continues } => {\n+                label_or_note(span, msg);\n+                diag.set_arg(\"name\", name);\n+                diag.set_arg(\"continues\", continues);\n+            }\n+            RegionOriginNote::WithRequirement {\n+                span,\n+                requirement,\n+                expected_found: Some((expected, found)),\n+            } => {\n+                label_or_note(span, fluent::infer::subtype);\n+                diag.set_arg(\"requirement\", requirement);\n+\n+                diag.note_expected_found(&\"\", expected, &\"\", found);\n+            }\n+            RegionOriginNote::WithRequirement { span, requirement, expected_found: None } => {\n+                // FIXME: this really should be handled at some earlier stage. Our\n+                // handling of region checking when type errors are present is\n+                // *terrible*.\n+                label_or_note(span, fluent::infer::subtype_2);\n+                diag.set_arg(\"requirement\", requirement);\n+            }\n+        };\n+    }\n+}\n+\n+pub enum LifetimeMismatchLabels {\n+    InRet {\n+        param_span: Span,\n+        ret_span: Span,\n+        span: Span,\n+        label_var1: Option<Ident>,\n+    },\n+    Normal {\n+        hir_equal: bool,\n+        ty_sup: Span,\n+        ty_sub: Span,\n+        span: Span,\n+        sup: Option<Ident>,\n+        sub: Option<Ident>,\n+    },\n+}\n+\n+impl AddToDiagnostic for LifetimeMismatchLabels {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            LifetimeMismatchLabels::InRet { param_span, ret_span, span, label_var1 } => {\n+                diag.span_label(param_span, fluent::infer::declared_different);\n+                diag.span_label(ret_span, fluent::infer::nothing);\n+                diag.span_label(span, fluent::infer::data_returned);\n+                diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n+                diag.set_arg(\"label_var1\", label_var1.map(|x| x.to_string()).unwrap_or_default());\n+            }\n+            LifetimeMismatchLabels::Normal {\n+                hir_equal,\n+                ty_sup,\n+                ty_sub,\n+                span,\n+                sup: label_var1,\n+                sub: label_var2,\n+            } => {\n+                if hir_equal {\n+                    diag.span_label(ty_sup, fluent::infer::declared_multiple);\n+                    diag.span_label(ty_sub, fluent::infer::nothing);\n+                    diag.span_label(span, fluent::infer::data_lifetime_flow);\n+                } else {\n+                    diag.span_label(ty_sup, fluent::infer::types_declared_different);\n+                    diag.span_label(ty_sub, fluent::infer::nothing);\n+                    diag.span_label(span, fluent::infer::data_flows);\n+                    diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n+                    diag.set_arg(\n+                        \"label_var1\",\n+                        label_var1.map(|x| x.to_string()).unwrap_or_default(),\n+                    );\n+                    diag.set_arg(\"label_var2_exists\", label_var2.is_some());\n+                    diag.set_arg(\n+                        \"label_var2\",\n+                        label_var2.map(|x| x.to_string()).unwrap_or_default(),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct AddLifetimeParamsSuggestion<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub sub: Region<'a>,\n+    pub ty_sup: &'a Ty<'a>,\n+    pub ty_sub: &'a Ty<'a>,\n+    pub add_note: bool,\n+}\n+\n+impl AddToDiagnostic for AddLifetimeParamsSuggestion<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        let mut mk_suggestion = || {\n+            let (\n+                hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },\n+                hir::Ty { kind: hir::TyKind::Rptr(lifetime_sup, _), .. },\n+            ) = (self.ty_sub, self.ty_sup) else {\n+                return false;\n+            };\n+\n+            if !lifetime_sub.name.is_anonymous() || !lifetime_sup.name.is_anonymous() {\n+                return false;\n+            };\n+\n+            let Some(anon_reg) = self.tcx.is_suitable_region(self.sub) else {\n+                return false;\n+            };\n+\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n+\n+            let node = self.tcx.hir().get(hir_id);\n+            let is_impl = matches!(&node, hir::Node::ImplItem(_));\n+            let generics = match node {\n+                hir::Node::Item(&hir::Item {\n+                    kind: hir::ItemKind::Fn(_, ref generics, ..),\n+                    ..\n+                })\n+                | hir::Node::TraitItem(&hir::TraitItem { ref generics, .. })\n+                | hir::Node::ImplItem(&hir::ImplItem { ref generics, .. }) => generics,\n+                _ => return false,\n+            };\n+\n+            let suggestion_param_name = generics\n+                .params\n+                .iter()\n+                .filter(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n+                .map(|p| p.name.ident().name)\n+                .find(|i| *i != kw::UnderscoreLifetime);\n+            let introduce_new = suggestion_param_name.is_none();\n+            let suggestion_param_name =\n+                suggestion_param_name.map(|n| n.to_string()).unwrap_or_else(|| \"'a\".to_owned());\n+\n+            debug!(?lifetime_sup.span);\n+            debug!(?lifetime_sub.span);\n+            let make_suggestion = |span: rustc_span::Span| {\n+                if span.is_empty() {\n+                    (span, format!(\"{}, \", suggestion_param_name))\n+                } else if let Ok(\"&\") = self.tcx.sess.source_map().span_to_snippet(span).as_deref()\n+                {\n+                    (span.shrink_to_hi(), format!(\"{} \", suggestion_param_name))\n+                } else {\n+                    (span, suggestion_param_name.clone())\n+                }\n+            };\n+            let mut suggestions =\n+                vec![make_suggestion(lifetime_sub.span), make_suggestion(lifetime_sup.span)];\n+\n+            if introduce_new {\n+                let new_param_suggestion = if let Some(first) =\n+                    generics.params.iter().find(|p| !p.name.ident().span.is_empty())\n+                {\n+                    (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name))\n+                } else {\n+                    (generics.span, format!(\"<{}>\", suggestion_param_name))\n+                };\n+\n+                suggestions.push(new_param_suggestion);\n+            }\n+\n+            diag.multipart_suggestion(\n+                fluent::infer::lifetime_param_suggestion,\n+                suggestions,\n+                Applicability::MaybeIncorrect,\n+            );\n+            diag.set_arg(\"is_impl\", is_impl);\n+            true\n+        };\n+        if mk_suggestion() && self.add_note {\n+            diag.note(fluent::infer::lifetime_param_suggestion_elided);\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer::lifetime_mismatch, code = \"E0623\")]\n+pub struct LifetimeMismatch<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub labels: LifetimeMismatchLabels,\n+    #[subdiagnostic]\n+    pub suggestion: AddLifetimeParamsSuggestion<'a>,\n+}\n+\n+pub struct IntroducesStaticBecauseUnmetLifetimeReq {\n+    pub unmet_requirements: MultiSpan,\n+    pub binding_span: Span,\n+}\n+\n+impl AddToDiagnostic for IntroducesStaticBecauseUnmetLifetimeReq {\n+    fn add_to_diagnostic(mut self, diag: &mut rustc_errors::Diagnostic) {\n+        self.unmet_requirements\n+            .push_span_label(self.binding_span, fluent::infer::msl_introduces_static);\n+        diag.span_note(self.unmet_requirements, fluent::infer::msl_unmet_req);\n+    }\n+}\n+\n+pub struct ImplNote {\n+    pub impl_span: Option<Span>,\n+}\n+\n+impl AddToDiagnostic for ImplNote {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self.impl_span {\n+            Some(span) => diag.span_note(span, fluent::infer::msl_impl_note),\n+            None => diag.note(fluent::infer::msl_impl_note),\n+        };\n+    }\n+}\n+\n+pub enum TraitSubdiag {\n+    Note { span: Span },\n+    Sugg { span: Span },\n+}\n+\n+// FIXME(#100717) used in `Vec<TraitSubdiag>` so requires eager translation/list support\n+impl AddToDiagnostic for TraitSubdiag {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            TraitSubdiag::Note { span } => {\n+                diag.span_note(span, \"this has an implicit `'static` lifetime requirement\");\n+            }\n+            TraitSubdiag::Sugg { span } => {\n+                diag.span_suggestion_verbose(\n+                    span,\n+                    \"consider relaxing the implicit `'static` requirement\",\n+                    \" + '_\".to_owned(),\n+                    rustc_errors::Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer::mismatched_static_lifetime)]\n+pub struct MismatchedStaticLifetime<'a> {\n+    #[primary_span]\n+    pub cause_span: Span,\n+    #[subdiagnostic]\n+    pub unmet_lifetime_reqs: IntroducesStaticBecauseUnmetLifetimeReq,\n+    #[subdiagnostic]\n+    pub expl: Option<note_and_explain::RegionExplanation<'a>>,\n+    #[subdiagnostic]\n+    pub impl_note: ImplNote,\n+    #[subdiagnostic]\n+    pub trait_subdiags: Vec<TraitSubdiag>,\n+}"}, {"sha": "7f54918f73614e2cd94d478d6fa9c1b13c1858e5", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -0,0 +1,172 @@\n+use crate::infer::error_reporting::nice_region_error::find_anon_type;\n+use rustc_errors::{self, fluent, AddToDiagnostic, IntoDiagnosticArg};\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::{symbol::kw, Span};\n+\n+#[derive(Default)]\n+struct DescriptionCtx<'a> {\n+    span: Option<Span>,\n+    kind: &'a str,\n+    arg: String,\n+    num_arg: u32,\n+}\n+\n+impl<'a> DescriptionCtx<'a> {\n+    fn new<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+        alt_span: Option<Span>,\n+    ) -> Option<Self> {\n+        let mut me = DescriptionCtx::default();\n+        me.span = alt_span;\n+        match *region {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n+                return Self::from_early_bound_and_free_regions(tcx, region);\n+            }\n+            ty::ReStatic => {\n+                me.kind = \"restatic\";\n+            }\n+\n+            ty::RePlaceholder(_) => return None,\n+\n+            // FIXME(#13998) RePlaceholder should probably print like\n+            // ReFree rather than dumping Debug output on the user.\n+            //\n+            // We shouldn't really be having unification failures with ReVar\n+            // and ReLateBound though.\n+            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+                me.kind = \"revar\";\n+                me.arg = format!(\"{:?}\", region);\n+            }\n+        };\n+        Some(me)\n+    }\n+\n+    fn from_early_bound_and_free_regions<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) -> Option<Self> {\n+        let mut me = DescriptionCtx::default();\n+        let scope = region.free_region_binding_scope(tcx).expect_local();\n+        match *region {\n+            ty::ReEarlyBound(ref br) => {\n+                let mut sp = tcx.def_span(scope);\n+                if let Some(param) =\n+                    tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n+                {\n+                    sp = param.span;\n+                }\n+                if br.has_name() {\n+                    me.kind = \"as_defined\";\n+                    me.arg = br.name.to_string();\n+                } else {\n+                    me.kind = \"as_defined_anon\";\n+                };\n+                me.span = Some(sp)\n+            }\n+            ty::ReFree(ref fr) => {\n+                if !fr.bound_region.is_named()\n+                    && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n+                {\n+                    me.kind = \"defined_here\";\n+                    me.span = Some(ty.span);\n+                } else {\n+                    match fr.bound_region {\n+                        ty::BoundRegionKind::BrNamed(_, name) => {\n+                            let mut sp = tcx.def_span(scope);\n+                            if let Some(param) =\n+                                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+                            {\n+                                sp = param.span;\n+                            }\n+                            if name == kw::UnderscoreLifetime {\n+                                me.kind = \"as_defined_anon\";\n+                            } else {\n+                                me.kind = \"as_defined\";\n+                                me.arg = name.to_string();\n+                            };\n+                            me.span = Some(sp);\n+                        }\n+                        ty::BrAnon(idx) => {\n+                            me.kind = \"anon_num_here\";\n+                            me.num_arg = idx+1;\n+                            me.span = Some(tcx.def_span(scope));\n+                        },\n+                        _ => {\n+                            me.kind = \"defined_here_reg\";\n+                            me.arg = region.to_string();\n+                            me.span = Some(tcx.def_span(scope));\n+                        },\n+                    }\n+                }\n+            }\n+            _ => bug!(),\n+        }\n+        Some(me)\n+    }\n+\n+    fn add_to(self, diag: &mut rustc_errors::Diagnostic) {\n+        diag.set_arg(\"desc_kind\", self.kind);\n+        diag.set_arg(\"desc_arg\", self.arg);\n+        diag.set_arg(\"desc_num_arg\", self.num_arg);\n+    }\n+}\n+\n+pub enum PrefixKind {\n+    Empty,\n+}\n+\n+pub enum SuffixKind {\n+    Continues,\n+}\n+\n+impl IntoDiagnosticArg for PrefixKind {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        let kind = match self {\n+            Self::Empty => \"empty\",\n+        }\n+        .into();\n+        rustc_errors::DiagnosticArgValue::Str(kind)\n+    }\n+}\n+\n+impl IntoDiagnosticArg for SuffixKind {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        let kind = match self {\n+            Self::Continues => \"continues\",\n+        }\n+        .into();\n+        rustc_errors::DiagnosticArgValue::Str(kind)\n+    }\n+}\n+\n+pub struct RegionExplanation<'a> {\n+    desc: DescriptionCtx<'a>,\n+    prefix: PrefixKind,\n+    suffix: SuffixKind,\n+}\n+\n+impl RegionExplanation<'_> {\n+    pub fn new<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+        alt_span: Option<Span>,\n+        prefix: PrefixKind,\n+        suffix: SuffixKind,\n+    ) -> Option<Self> {\n+        Some(Self { desc: DescriptionCtx::new(tcx, region, alt_span)?, prefix, suffix })\n+    }\n+}\n+\n+impl AddToDiagnostic for RegionExplanation<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        if let Some(span) = self.desc.span {\n+            diag.span_note(span, fluent::infer::region_explanation);\n+        } else {\n+            diag.note(fluent::infer::region_explanation);\n+        }\n+        self.desc.add_to(diag);\n+        diag.set_arg(\"pref_kind\", self.prefix);\n+        diag.set_arg(\"suff_kind\", self.suffix);\n+    }\n+}"}, {"sha": "9488d0a6cbb68c766f5fbf57536263768f53603d", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -180,11 +180,7 @@ impl CanonicalizeMode for CanonicalizeQueryResponse {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReFree(_)\n-            | ty::ReErased\n-            | ty::ReStatic\n-            | ty::ReEmpty(ty::UniverseIndex::ROOT)\n-            | ty::ReEarlyBound(..) => r,\n+            ty::ReFree(_) | ty::ReErased | ty::ReStatic | ty::ReEarlyBound(..) => r,\n \n             ty::RePlaceholder(placeholder) => canonicalizer.canonical_var_for_region(\n                 CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderRegion(placeholder) },\n@@ -199,10 +195,6 @@ impl CanonicalizeMode for CanonicalizeQueryResponse {\n                 )\n             }\n \n-            ty::ReEmpty(ui) => {\n-                bug!(\"canonicalizing 'empty in universe {:?}\", ui) // FIXME\n-            }\n-\n             _ => {\n                 // Other than `'static` or `'empty`, the query\n                 // response should be executing in a fully\n@@ -381,7 +373,6 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n-            | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n             | ty::ReErased => self.canonicalize_mode.canonicalize_free_region(self, r),\n         }"}, {"sha": "56e83489879516f0659329050dfb4848fa218c40", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -22,6 +22,7 @@ use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_middle::arena::ArenaAllocatable;\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n@@ -129,7 +130,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n             make_query_region_constraints(\n                 tcx,\n-                region_obligations.iter().map(|r_o| (r_o.sup_type, r_o.sub_region)),\n+                region_obligations\n+                    .iter()\n+                    .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category())),\n                 region_constraints,\n             )\n         });\n@@ -248,6 +251,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n \n+        let constraint_category = cause.to_constraint_category();\n+\n         for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n             let result_value = query_response.substitute_projected(self.tcx, &result_subst, |v| {\n@@ -263,12 +268,14 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 (GenericArgKind::Lifetime(v_o), GenericArgKind::Lifetime(v_r)) => {\n                     // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n                     if v_o != v_r {\n-                        output_query_region_constraints\n-                            .outlives\n-                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)));\n-                        output_query_region_constraints\n-                            .outlives\n-                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)));\n+                        output_query_region_constraints.outlives.push((\n+                            ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)),\n+                            constraint_category,\n+                        ));\n+                        output_query_region_constraints.outlives.push((\n+                            ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)),\n+                            constraint_category,\n+                        ));\n                     }\n                 }\n \n@@ -314,7 +321,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 // Screen out `'a: 'a` cases -- we skip the binder here but\n                 // only compare the inner values to one another, so they are still at\n                 // consistent binding levels.\n-                let ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n+                let ty::OutlivesPredicate(k1, r2) = r_c.0.skip_binder();\n                 if k1 != r2.into() { Some(r_c) } else { None }\n             }),\n         );\n@@ -559,7 +566,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Obligation<'tcx, ty::Predicate<'tcx>> {\n-        let ty::OutlivesPredicate(k1, r2) = predicate.skip_binder();\n+        let ty::OutlivesPredicate(k1, r2) = predicate.0.skip_binder();\n \n         let atom = match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n@@ -574,7 +581,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 span_bug!(cause.span, \"unexpected const outlives {:?}\", predicate);\n             }\n         };\n-        let predicate = predicate.rebind(atom).to_predicate(self.tcx);\n+        let predicate = predicate.0.rebind(atom).to_predicate(self.tcx);\n \n         Obligation::new(cause, param_env, predicate)\n     }\n@@ -625,7 +632,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n /// creates query region constraints.\n pub fn make_query_region_constraints<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>)>,\n+    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n     let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n@@ -638,26 +645,31 @@ pub fn make_query_region_constraints<'tcx>(\n \n     let outlives: Vec<_> = constraints\n         .iter()\n-        .map(|(k, _)| match *k {\n-            // Swap regions because we are going from sub (<=) to outlives\n-            // (>=).\n-            Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n-                tcx.mk_region(ty::ReVar(v2)).into(),\n-                tcx.mk_region(ty::ReVar(v1)),\n-            ),\n-            Constraint::VarSubReg(v1, r2) => {\n-                ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n-            }\n-            Constraint::RegSubVar(r1, v2) => {\n-                ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n-            }\n-            Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+        .map(|(k, origin)| {\n+            // no bound vars in the code above\n+            let constraint = ty::Binder::dummy(match *k {\n+                // Swap regions because we are going from sub (<=) to outlives\n+                // (>=).\n+                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                    tcx.mk_region(ty::ReVar(v2)).into(),\n+                    tcx.mk_region(ty::ReVar(v1)),\n+                ),\n+                Constraint::VarSubReg(v1, r2) => {\n+                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n+                }\n+                Constraint::RegSubVar(r1, v2) => {\n+                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n+                }\n+                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+            });\n+            (constraint, origin.to_constraint_category())\n         })\n-        .map(ty::Binder::dummy) // no bound vars in the code above\n         .chain(\n             outlives_obligations\n-                .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n-                .map(ty::Binder::dummy), // no bound vars in the code above\n+                // no bound vars in the code above\n+                .map(|(ty, r, constraint_category)| {\n+                    (ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), r)), constraint_category)\n+                }),\n         )\n         .collect();\n "}, {"sha": "389afe22eb7672afe16c801ca97c9b1c940390fe", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -72,15 +72,16 @@ where\n         value\n     } else {\n         let delegate = FnMutDelegate {\n-            regions: |br: ty::BoundRegion| match var_values.var_values[br.var].unpack() {\n+            regions: &mut |br: ty::BoundRegion| match var_values.var_values[br.var].unpack() {\n                 GenericArgKind::Lifetime(l) => l,\n                 r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n             },\n-            types: |bound_ty: ty::BoundTy| match var_values.var_values[bound_ty.var].unpack() {\n+            types: &mut |bound_ty: ty::BoundTy| match var_values.var_values[bound_ty.var].unpack() {\n                 GenericArgKind::Type(ty) => ty,\n                 r => bug!(\"{:?} is a type but value is {:?}\", bound_ty, r),\n             },\n-            consts: |bound_ct: ty::BoundVar, _| match var_values.var_values[bound_ct].unpack() {\n+            consts: &mut |bound_ct: ty::BoundVar, _| match var_values.var_values[bound_ct].unpack()\n+            {\n                 GenericArgKind::Const(ct) => ct,\n                 c => bug!(\"{:?} is a const but value is {:?}\", bound_ct, c),\n             },"}, {"sha": "9488f1f6bfc482f40a79158db27174471a597689", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 28, "deletions": 63, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -147,11 +147,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n                 ty::ConstKind::Infer(InferConst::Var(a_vid)),\n                 ty::ConstKind::Infer(InferConst::Var(b_vid)),\n             ) => {\n-                self.inner\n-                    .borrow_mut()\n-                    .const_unification_table()\n-                    .unify_var_var(a_vid, b_vid)\n-                    .map_err(|e| const_unification_error(a_is_expected, e))?;\n+                self.inner.borrow_mut().const_unification_table().union(a_vid, b_vid);\n                 return Ok(a);\n             }\n \n@@ -246,21 +242,17 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         let value = ConstInferUnifier { infcx: self, span, param_env, for_universe, target_vid }\n             .relate(ct, ct)?;\n \n-        self.inner\n-            .borrow_mut()\n-            .const_unification_table()\n-            .unify_var_value(\n-                target_vid,\n-                ConstVarValue {\n-                    origin: ConstVariableOrigin {\n-                        kind: ConstVariableOriginKind::ConstInference,\n-                        span: DUMMY_SP,\n-                    },\n-                    val: ConstVariableValue::Known { value },\n+        self.inner.borrow_mut().const_unification_table().union_value(\n+            target_vid,\n+            ConstVarValue {\n+                origin: ConstVariableOrigin {\n+                    kind: ConstVariableOriginKind::ConstInference,\n+                    span: DUMMY_SP,\n                 },\n-            )\n-            .map(|()| value)\n-            .map_err(|e| const_unification_error(vid_is_expected, e))\n+                val: ConstVariableValue::Known { value },\n+            },\n+        );\n+        Ok(value)\n     }\n \n     fn unify_integral_variable(\n@@ -391,7 +383,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     /// Preconditions:\n     ///\n     /// - `for_vid` is a \"root vid\"\n-    #[instrument(skip(self), level = \"trace\")]\n+    #[instrument(skip(self), level = \"trace\", ret)]\n     fn generalize(\n         &self,\n         ty: Ty<'tcx>,\n@@ -435,15 +427,8 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             cache: SsoHashMap::new(),\n         };\n \n-        let ty = match generalize.relate(ty, ty) {\n-            Ok(ty) => ty,\n-            Err(e) => {\n-                debug!(?e, \"failure\");\n-                return Err(e);\n-            }\n-        };\n+        let ty = generalize.relate(ty, ty)?;\n         let needs_wf = generalize.needs_wf;\n-        trace!(?ty, ?needs_wf, \"success\");\n         Ok(Generalization { ty, needs_wf })\n     }\n \n@@ -493,12 +478,13 @@ struct Generalizer<'cx, 'tcx> {\n \n     param_env: ty::ParamEnv<'tcx>,\n \n-    cache: SsoHashMap<Ty<'tcx>, RelateResult<'tcx, Ty<'tcx>>>,\n+    cache: SsoHashMap<Ty<'tcx>, Ty<'tcx>>,\n }\n \n /// Result from a generalization operation. This includes\n /// not only the generalized type, but also a bool flag\n /// indicating whether further WF checks are needed.\n+#[derive(Debug)]\n struct Generalization<'tcx> {\n     ty: Ty<'tcx>,\n \n@@ -599,8 +585,8 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         assert_eq!(t, t2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n \n-        if let Some(result) = self.cache.get(&t) {\n-            return result.clone();\n+        if let Some(&result) = self.cache.get(&t) {\n+            return Ok(result);\n         }\n         debug!(\"generalize: t={:?}\", t);\n \n@@ -670,10 +656,10 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 Ok(t)\n             }\n             _ => relate::super_relate_tys(self, t, t),\n-        };\n+        }?;\n \n-        self.cache.insert(t, result.clone());\n-        return result;\n+        self.cache.insert(t, result);\n+        Ok(result)\n     }\n \n     fn regions(\n@@ -694,7 +680,6 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n             ty::RePlaceholder(..)\n             | ty::ReVar(..)\n-            | ty::ReEmpty(_)\n             | ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(..) => {\n@@ -749,10 +734,7 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     }\n                 }\n             }\n-            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n-                if self.tcx().lazy_normalization() =>\n-            {\n-                assert_eq!(promoted, None);\n+            ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }) => {\n                 let substs = self.relate_with_variance(\n                     ty::Variance::Invariant,\n                     ty::VarianceDiagInfo::default(),\n@@ -761,7 +743,7 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 )?;\n                 Ok(self.tcx().mk_const(ty::ConstS {\n                     ty: c.ty(),\n-                    kind: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n+                    kind: ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }),\n                 }))\n             }\n             _ => relate::super_relate_consts(self, c, c),\n@@ -776,13 +758,6 @@ pub trait ConstEquateRelation<'tcx>: TypeRelation<'tcx> {\n     fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>);\n }\n \n-pub fn const_unification_error<'tcx>(\n-    a_is_expected: bool,\n-    (a, b): (ty::Const<'tcx>, ty::Const<'tcx>),\n-) -> TypeError<'tcx> {\n-    TypeError::ConstMismatch(ExpectedFound::new(a_is_expected, a, b))\n-}\n-\n fn int_unification_error<'tcx>(\n     a_is_expected: bool,\n     v: (ty::IntVarValue, ty::IntVarValue),\n@@ -856,10 +831,9 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn tys(&mut self, t: Ty<'tcx>, _t: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         debug_assert_eq!(t, _t);\n-        debug!(\"ConstInferUnifier: t={:?}\", t);\n \n         match t.kind() {\n             &ty::Infer(ty::TyVar(vid)) => {\n@@ -883,12 +857,7 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                             .borrow_mut()\n                             .type_variables()\n                             .new_var(self.for_universe, origin);\n-                        let u = self.tcx().mk_ty_var(new_var_id);\n-                        debug!(\n-                            \"ConstInferUnifier: replacing original vid={:?} with new={:?}\",\n-                            vid, u\n-                        );\n-                        Ok(u)\n+                        Ok(self.tcx().mk_ty_var(new_var_id))\n                     }\n                 }\n             }\n@@ -914,7 +883,6 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n \n             ty::RePlaceholder(..)\n             | ty::ReVar(..)\n-            | ty::ReEmpty(_)\n             | ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(..) => {\n@@ -932,14 +900,13 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         }\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn consts(\n         &mut self,\n         c: ty::Const<'tcx>,\n         _c: ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         debug_assert_eq!(c, _c);\n-        debug!(\"ConstInferUnifier: c={:?}\", c);\n \n         match c.kind() {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n@@ -980,19 +947,17 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                     }\n                 }\n             }\n-            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n-                if self.tcx().lazy_normalization() =>\n-            {\n-                assert_eq!(promoted, None);\n+            ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }) => {\n                 let substs = self.relate_with_variance(\n                     ty::Variance::Invariant,\n                     ty::VarianceDiagInfo::default(),\n                     substs,\n                     substs,\n                 )?;\n+\n                 Ok(self.tcx().mk_const(ty::ConstS {\n                     ty: c.ty(),\n-                    kind: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n+                    kind: ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }),\n                 }))\n             }\n             _ => relate::super_relate_consts(self, c, c),"}, {"sha": "59728148a84c43e8023a2f580d5193849e22fab1", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -110,6 +110,25 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n                         .obligations,\n                 );\n             }\n+            // Optimization of GeneratorWitness relation since we know that all\n+            // free regions are replaced with bound regions during construction.\n+            // This greatly speeds up equating of GeneratorWitness.\n+            (&ty::GeneratorWitness(a_types), &ty::GeneratorWitness(b_types)) => {\n+                let a_types = infcx.tcx.anonymize_bound_vars(a_types);\n+                let b_types = infcx.tcx.anonymize_bound_vars(b_types);\n+                if a_types.bound_vars() == b_types.bound_vars() {\n+                    let (a_types, b_types) = infcx.replace_bound_vars_with_placeholders(\n+                        a_types.map_bound(|a_types| (a_types, b_types.skip_binder())),\n+                    );\n+                    for (a, b) in std::iter::zip(a_types, b_types) {\n+                        self.relate(a, b)?;\n+                    }\n+                } else {\n+                    return Err(ty::error::TypeError::Sorts(ty::relate::expected_found(\n+                        self, a, b,\n+                    )));\n+                }\n+            }\n \n             _ => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;"}, {"sha": "99469d1e1e7db9f189b587c7515be69e6c91130d", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 180, "deletions": 60, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -51,6 +51,7 @@ use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePa\n \n use crate::infer;\n use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n+use crate::infer::ExpectedFound;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n@@ -61,15 +62,16 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, MultiSpan};\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Node;\n use rustc_middle::dep_graph::DepContext;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::{self, RelateResult, TypeRelation};\n use rustc_middle::ty::{\n-    self, error::TypeError, Binder, List, Region, Subst, Ty, TyCtxt, TypeFoldable,\n-    TypeSuperVisitable, TypeVisitable,\n+    self, error::TypeError, Binder, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n+    TypeVisitable,\n };\n use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n@@ -96,11 +98,6 @@ pub(super) fn note_and_explain_region<'tcx>(\n             msg_span_from_free_region(tcx, region, alt_span)\n         }\n \n-        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"the empty lifetime\".to_owned(), alt_span),\n-\n-        // uh oh, hope no user ever sees THIS\n-        ty::ReEmpty(ui) => (format!(\"the empty lifetime in universe {:?}\", ui), alt_span),\n-\n         ty::RePlaceholder(_) => return,\n \n         // FIXME(#13998) RePlaceholder should probably print like\n@@ -139,8 +136,6 @@ fn msg_span_from_free_region<'tcx>(\n             (msg, Some(span))\n         }\n         ty::ReStatic => (\"the static lifetime\".to_owned(), alt_span),\n-        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"an empty lifetime\".to_owned(), alt_span),\n-        ty::ReEmpty(ui) => (format!(\"an empty lifetime in universe {:?}\", ui), alt_span),\n         _ => bug!(\"{:?}\", region),\n     }\n }\n@@ -250,17 +245,7 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n \n     // Explain the region we are capturing.\n     match *hidden_region {\n-        ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n-            // All lifetimes shorter than the function body are `empty` in\n-            // lexical region resolution. The default explanation of \"an empty\n-            // lifetime\" isn't really accurate here.\n-            let message = format!(\n-                \"hidden type `{}` captures lifetime smaller than the function body\",\n-                hidden_ty\n-            );\n-            err.span_note(span, &message);\n-        }\n-        ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) => {\n+        ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n             // Assuming regionck succeeded (*), we ought to always be\n             // capturing *some* region from the fn header, and hence it\n             // ought to be free. So under normal circumstances, we will go\n@@ -386,7 +371,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     RegionResolutionError::UpperBoundUniverseConflict(\n                         _,\n                         _,\n-                        var_universe,\n+                        _,\n                         sup_origin,\n                         sup_r,\n                     ) => {\n@@ -397,7 +382,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // placeholder. In practice, we expect more\n                         // tailored errors that don't really use this\n                         // value.\n-                        let sub_r = self.tcx.mk_region(ty::ReEmpty(var_universe));\n+                        let sub_r = self.tcx.lifetimes.re_erased;\n \n                         self.report_placeholder_failure(sup_origin, sub_r, sup_r).emit();\n                     }\n@@ -1434,7 +1419,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// the message in `secondary_span` as the primary label, and apply the message that would\n     /// otherwise be used for the primary label on the `secondary_span` `Span`. This applies on\n     /// E0271, like `src/test/ui/issues/issue-39970.stderr`.\n-    #[tracing::instrument(\n+    #[instrument(\n         level = \"debug\",\n         skip(self, diag, secondary_span, swap_secondary_and_primary, prefer_label)\n     )]\n@@ -1586,28 +1571,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             Some(values) => {\n                 let values = self.resolve_vars_if_possible(values);\n                 let (is_simple_error, exp_found) = match values {\n-                    ValuePairs::Terms(infer::ExpectedFound {\n-                        expected: ty::Term::Ty(expected),\n-                        found: ty::Term::Ty(found),\n-                    }) => {\n-                        let is_simple_err = expected.is_simple_text() && found.is_simple_text();\n-                        OpaqueTypesVisitor::visit_expected_found(self.tcx, expected, found, span)\n-                            .report(diag);\n-\n-                        (\n-                            is_simple_err,\n-                            Mismatch::Variable(infer::ExpectedFound { expected, found }),\n-                        )\n+                    ValuePairs::Terms(infer::ExpectedFound { expected, found }) => {\n+                        match (expected.unpack(), found.unpack()) {\n+                            (ty::TermKind::Ty(expected), ty::TermKind::Ty(found)) => {\n+                                let is_simple_err =\n+                                    expected.is_simple_text() && found.is_simple_text();\n+                                OpaqueTypesVisitor::visit_expected_found(\n+                                    self.tcx, expected, found, span,\n+                                )\n+                                .report(diag);\n+\n+                                (\n+                                    is_simple_err,\n+                                    Mismatch::Variable(infer::ExpectedFound { expected, found }),\n+                                )\n+                            }\n+                            (ty::TermKind::Const(_), ty::TermKind::Const(_)) => {\n+                                (false, Mismatch::Fixed(\"constant\"))\n+                            }\n+                            _ => (false, Mismatch::Fixed(\"type\")),\n+                        }\n                     }\n-                    ValuePairs::Terms(infer::ExpectedFound {\n-                        expected: ty::Term::Const(_),\n-                        found: ty::Term::Const(_),\n-                    }) => (false, Mismatch::Fixed(\"constant\")),\n                     ValuePairs::TraitRefs(_) | ValuePairs::PolyTraitRefs(_) => {\n                         (false, Mismatch::Fixed(\"trait\"))\n                     }\n                     ValuePairs::Regions(_) => (false, Mismatch::Fixed(\"lifetime\")),\n-                    _ => (false, Mismatch::Fixed(\"type\")),\n                 };\n                 let vals = match self.values_str(values) {\n                     Some((expected, found)) => Some((expected, found)),\n@@ -1666,8 +1654,114 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ),\n                 Mismatch::Fixed(s) => (s.into(), s.into(), None),\n             };\n-            match (&terr, expected == found) {\n-                (TypeError::Sorts(values), extra) => {\n+\n+            enum Similar<'tcx> {\n+                Adts { expected: ty::AdtDef<'tcx>, found: ty::AdtDef<'tcx> },\n+                PrimitiveFound { expected: ty::AdtDef<'tcx>, found: Ty<'tcx> },\n+                PrimitiveExpected { expected: Ty<'tcx>, found: ty::AdtDef<'tcx> },\n+            }\n+\n+            let similarity = |ExpectedFound { expected, found }: ExpectedFound<Ty<'tcx>>| {\n+                if let ty::Adt(expected, _) = expected.kind() && let Some(primitive) = found.primitive_symbol() {\n+                    let path = self.tcx.def_path(expected.did()).data;\n+                    let name = path.last().unwrap().data.get_opt_name();\n+                    if name == Some(primitive) {\n+                        return Some(Similar::PrimitiveFound { expected: *expected, found });\n+                    }\n+                } else if let Some(primitive) = expected.primitive_symbol() && let ty::Adt(found, _) = found.kind() {\n+                    let path = self.tcx.def_path(found.did()).data;\n+                    let name = path.last().unwrap().data.get_opt_name();\n+                    if name == Some(primitive) {\n+                        return Some(Similar::PrimitiveExpected { expected, found: *found });\n+                    }\n+                } else if let ty::Adt(expected, _) = expected.kind() && let ty::Adt(found, _) = found.kind() {\n+                    if !expected.did().is_local() && expected.did().krate == found.did().krate {\n+                        // Most likely types from different versions of the same crate\n+                        // are in play, in which case this message isn't so helpful.\n+                        // A \"perhaps two different versions...\" error is already emitted for that.\n+                        return None;\n+                    }\n+                    let f_path = self.tcx.def_path(found.did()).data;\n+                    let e_path = self.tcx.def_path(expected.did()).data;\n+\n+                    if let (Some(e_last), Some(f_last)) = (e_path.last(), f_path.last()) && e_last ==  f_last {\n+                        return Some(Similar::Adts{expected: *expected, found: *found});\n+                    }\n+                }\n+                None\n+            };\n+\n+            match terr {\n+                // If two types mismatch but have similar names, mention that specifically.\n+                TypeError::Sorts(values) if let Some(s) = similarity(values) => {\n+                    let diagnose_primitive =\n+                        |prim: Ty<'tcx>,\n+                         shadow: Ty<'tcx>,\n+                         defid: DefId,\n+                         diagnostic: &mut Diagnostic| {\n+                            let name = shadow.sort_string(self.tcx);\n+                            diagnostic.note(format!(\n+                            \"{prim} and {name} have similar names, but are actually distinct types\"\n+                        ));\n+                            diagnostic\n+                                .note(format!(\"{prim} is a primitive defined by the language\"));\n+                            let def_span = self.tcx.def_span(defid);\n+                            let msg = if defid.is_local() {\n+                                format!(\"{name} is defined in the current crate\")\n+                            } else {\n+                                let crate_name = self.tcx.crate_name(defid.krate);\n+                                format!(\"{name} is defined in crate `{crate_name}\")\n+                            };\n+                            diagnostic.span_note(def_span, msg);\n+                        };\n+\n+                    let diagnose_adts =\n+                        |expected_adt : ty::AdtDef<'tcx>,\n+                         found_adt: ty::AdtDef<'tcx>,\n+                         diagnostic: &mut Diagnostic| {\n+                            let found_name = values.found.sort_string(self.tcx);\n+                            let expected_name = values.expected.sort_string(self.tcx);\n+\n+                            let found_defid = found_adt.did();\n+                            let expected_defid = expected_adt.did();\n+\n+                            diagnostic.note(format!(\"{found_name} and {expected_name} have similar names, but are actually distinct types\"));\n+                            for (defid, name) in\n+                                [(found_defid, found_name), (expected_defid, expected_name)]\n+                            {\n+                                let def_span = self.tcx.def_span(defid);\n+\n+                                let msg = if found_defid.is_local() && expected_defid.is_local() {\n+                                    let module = self\n+                                        .tcx\n+                                        .parent_module_from_def_id(defid.expect_local())\n+                                        .to_def_id();\n+                                    let module_name = self.tcx.def_path(module).to_string_no_crate_verbose();\n+                                    format!(\"{name} is defined in module `crate{module_name}` of the current crate\")\n+                                } else if defid.is_local() {\n+                                    format!(\"{name} is defined in the current crate\")\n+                                } else {\n+                                    let crate_name = self.tcx.crate_name(defid.krate);\n+                                    format!(\"{name} is defined in crate `{crate_name}`\")\n+                                };\n+                                diagnostic.span_note(def_span, msg);\n+                            }\n+                        };\n+\n+                    match s {\n+                        Similar::Adts{expected, found} => {\n+                            diagnose_adts(expected, found, diag)\n+                        }\n+                        Similar::PrimitiveFound{expected, found: prim} => {\n+                            diagnose_primitive(prim, values.expected, expected.did(), diag)\n+                        }\n+                        Similar::PrimitiveExpected{expected: prim, found} => {\n+                            diagnose_primitive(prim, values.found, found.did(), diag)\n+                        }\n+                    }\n+                }\n+                TypeError::Sorts(values) => {\n+                    let extra = expected == found;\n                     let sort_string = |ty: Ty<'tcx>| match (extra, ty.kind()) {\n                         (true, ty::Opaque(def_id, _)) => {\n                             let sm = self.tcx.sess.source_map();\n@@ -1679,6 +1773,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 pos.col.to_usize() + 1,\n                             )\n                         }\n+                        (true, ty::Projection(proj))\n+                            if self.tcx.def_kind(proj.item_def_id)\n+                                == DefKind::ImplTraitPlaceholder =>\n+                        {\n+                            let sm = self.tcx.sess.source_map();\n+                            let pos = sm.lookup_char_pos(self.tcx.def_span(proj.item_def_id).lo());\n+                            format!(\n+                                \" (trait associated opaque type at <{}:{}:{}>)\",\n+                                sm.filename_for_diagnostics(&pos.file.name),\n+                                pos.line,\n+                                pos.col.to_usize() + 1,\n+                            )\n+                        }\n                         (true, _) => format!(\" ({})\", ty.sort_string(self.tcx)),\n                         (false, _) => \"\".to_string(),\n                     };\n@@ -1707,10 +1814,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         );\n                     }\n                 }\n-                (TypeError::ObjectUnsafeCoercion(_), _) => {\n+                TypeError::ObjectUnsafeCoercion(_) => {\n                     diag.note_unsuccessful_coercion(found, expected);\n                 }\n-                (_, _) => {\n+                _ => {\n                     debug!(\n                         \"note_type_err: exp_found={:?}, expected={:?} found={:?}\",\n                         exp_found, expected, found\n@@ -2273,11 +2380,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        Some(match (exp_found.expected, exp_found.found) {\n-            (ty::Term::Ty(expected), ty::Term::Ty(found)) => self.cmp(expected, found),\n-            (expected, found) => (\n-                DiagnosticStyledString::highlighted(expected.to_string()),\n-                DiagnosticStyledString::highlighted(found.to_string()),\n+        Some(match (exp_found.expected.unpack(), exp_found.found.unpack()) {\n+            (ty::TermKind::Ty(expected), ty::TermKind::Ty(found)) => self.cmp(expected, found),\n+            _ => (\n+                DiagnosticStyledString::highlighted(exp_found.expected.to_string()),\n+                DiagnosticStyledString::highlighted(exp_found.found.to_string()),\n             ),\n         })\n     }\n@@ -2333,7 +2440,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                         // instead we suggest `T: 'a + 'b` in that case.\n                         let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                        let ast_generics = self.tcx.hir().get_generics(hir_id.owner);\n+                        let ast_generics = self.tcx.hir().get_generics(hir_id.owner.def_id);\n                         let bounds =\n                             ast_generics.and_then(|g| g.bounds_span_for_suggestions(def_id));\n                         // `sp` only covers `T`, change it so that it covers\n@@ -2374,6 +2481,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n             GenericKind::Projection(ref p) => format!(\"the associated type `{}`\", p),\n+            GenericKind::Opaque(def_id, substs) => {\n+                format!(\"the opaque type `{}`\", self.tcx.def_path_str_with_substs(def_id, substs))\n+            }\n         };\n \n         if let Some(SubregionOrigin::CompareImplItemObligation {\n@@ -2395,19 +2505,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             type_param_span: Option<(Span, bool)>,\n             bound_kind: GenericKind<'tcx>,\n             sub: S,\n+            add_lt_sugg: Option<(Span, String)>,\n         ) {\n             let msg = \"consider adding an explicit lifetime bound\";\n             if let Some((sp, has_lifetimes)) = type_param_span {\n                 let suggestion =\n                     if has_lifetimes { format!(\" + {}\", sub) } else { format!(\": {}\", sub) };\n-                err.span_suggestion_verbose(\n-                    sp,\n-                    &format!(\"{}...\", msg),\n-                    suggestion,\n+                let mut suggestions = vec![(sp, suggestion)];\n+                if let Some(add_lt_sugg) = add_lt_sugg {\n+                    suggestions.push(add_lt_sugg);\n+                }\n+                err.multipart_suggestion_verbose(\n+                    format!(\"{msg}...\"),\n+                    suggestions,\n                     Applicability::MaybeIncorrect, // Issue #41966\n                 );\n             } else {\n-                let consider = format!(\"{} `{}: {}`...\", msg, bound_kind, sub,);\n+                let consider = format!(\"{} `{}: {}`...\", msg, bound_kind, sub);\n                 err.help(&consider);\n             }\n         }\n@@ -2423,7 +2537,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     };\n                     let mut sugg =\n                         vec![(sp, suggestion), (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n-                    if let Some(lt) = add_lt_sugg {\n+                    if let Some(lt) = add_lt_sugg.clone() {\n                         sugg.push(lt);\n                         sugg.rotate_right(1);\n                     }\n@@ -2529,7 +2643,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // for the bound is not suitable for suggestions when `-Zverbose` is set because it\n                 // uses `Debug` output, so we handle it specially here so that suggestions are\n                 // always correct.\n-                binding_suggestion(&mut err, type_param_span, bound_kind, name);\n+                binding_suggestion(&mut err, type_param_span, bound_kind, name, None);\n                 err\n             }\n \n@@ -2542,7 +2656,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"{} may not live long enough\",\n                     labeled_user_string\n                 );\n-                binding_suggestion(&mut err, type_param_span, bound_kind, \"'static\");\n+                binding_suggestion(&mut err, type_param_span, bound_kind, \"'static\", None);\n                 err\n             }\n \n@@ -2576,7 +2690,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             new_binding_suggestion(&mut err, type_param_span);\n                         }\n                         _ => {\n-                            binding_suggestion(&mut err, type_param_span, bound_kind, new_lt);\n+                            binding_suggestion(\n+                                &mut err,\n+                                type_param_span,\n+                                bound_kind,\n+                                new_lt,\n+                                add_lt_sugg,\n+                            );\n                         }\n                     }\n                 }\n@@ -2755,7 +2875,7 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n     where\n         T: relate::Relate<'tcx>,\n     {\n-        Ok(ty::Binder::dummy(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n     fn consts("}, {"sha": "baa97d72a4baab067f77395502cecac7460541cc", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -4,6 +4,7 @@ use crate::errors::{\n };\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::InferCtxt;\n+use rustc_errors::IntoDiagnostic;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -15,10 +16,9 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, InferConst};\n+use rustc_middle::ty::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{IsSuggestable, Ty, TyCtxt, TypeckResults};\n-use rustc_session::SessionDiagnostic;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{BytePos, Span};\n use std::borrow::Cow;\n@@ -199,7 +199,7 @@ fn ty_to_string<'tcx>(infcx: &InferCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> String {\n }\n \n /// We don't want to directly use `ty_to_string` for closures as their type isn't really\n-/// something users are familar with. Directly printing the `fn_sig` of closures also\n+/// something users are familiar with. Directly printing the `fn_sig` of closures also\n /// doesn't work as they actually use the \"rust-call\" API.\n fn closure_as_fn_str<'tcx>(infcx: &InferCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> String {\n     let ty::Closure(_, substs) = ty.kind() else { unreachable!() };\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n             TypeAnnotationNeeded::E0283 => AmbigousImpl {\n                 span,\n                 source_kind,\n@@ -351,7 +351,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n             TypeAnnotationNeeded::E0284 => AmbigousReturn {\n                 span,\n                 source_kind,\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n         }\n     }\n \n@@ -511,20 +511,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     _ => \"\",\n                 };\n \n-                multi_suggestions.push(SourceKindMultiSuggestion::FullyQualified {\n-                    span: receiver.span,\n+                multi_suggestions.push(SourceKindMultiSuggestion::new_fully_qualified(\n+                    receiver.span,\n                     def_path,\n                     adjustment,\n                     successor,\n-                });\n+                ));\n             }\n             InferSourceKind::ClosureReturn { ty, data, should_wrap_expr } => {\n                 let ty_info = ty_to_string(self, ty);\n-                multi_suggestions.push(SourceKindMultiSuggestion::ClosureReturn {\n+                multi_suggestions.push(SourceKindMultiSuggestion::new_closure_return(\n                     ty_info,\n                     data,\n                     should_wrap_expr,\n-                });\n+                ));\n             }\n         }\n         match error_code {\n@@ -537,7 +537,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label: None,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n             TypeAnnotationNeeded::E0283 => AmbigousImpl {\n                 span,\n                 source_kind,\n@@ -547,7 +547,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label: None,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n             TypeAnnotationNeeded::E0284 => AmbigousReturn {\n                 span,\n                 source_kind,\n@@ -557,7 +557,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label: None,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n         }\n     }\n \n@@ -575,7 +575,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             span,\n             generator_kind: GeneratorKindAsDiagArg(kind),\n         }\n-        .into_diagnostic(&self.tcx.sess.parse_sess)\n+        .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n     }\n }\n \n@@ -901,15 +901,15 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprKind::MethodCall(segment, _, _) => {\n+            hir::ExprKind::MethodCall(segment, ..) => {\n                 if let Some(def_id) = self.typeck_results.type_dependent_def_id(expr.hir_id) {\n                     let generics = tcx.generics_of(def_id);\n                     let insertable: Option<_> = try {\n                         if generics.has_impl_trait() {\n                             None?\n                         }\n                         let substs = self.node_substs_opt(expr.hir_id)?;\n-                        let span = tcx.hir().span(segment.hir_id?);\n+                        let span = tcx.hir().span(segment.hir_id);\n                         let insert_span = segment.ident.span.shrink_to_hi().with_hi(span.hi());\n                         InsertableGenericArgs {\n                             insert_span,\n@@ -957,13 +957,13 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n         path.segments\n             .iter()\n             .filter_map(move |segment| {\n-                let res = segment.res?;\n+                let res = segment.res;\n                 let generics_def_id = tcx.res_generics_def_id(res)?;\n                 let generics = tcx.generics_of(generics_def_id);\n                 if generics.has_impl_trait() {\n                     return None;\n                 }\n-                let span = tcx.hir().span(segment.hir_id?);\n+                let span = tcx.hir().span(segment.hir_id);\n                 let insert_span = segment.ident.span.shrink_to_hi().with_hi(span.hi());\n                 Some(InsertableGenericArgs {\n                     insert_span,\n@@ -996,7 +996,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                     if !segment.infer_args || generics.has_impl_trait() {\n                         None?;\n                     }\n-                    let span = tcx.hir().span(segment.hir_id?);\n+                    let span = tcx.hir().span(segment.hir_id);\n                     let insert_span = segment.ident.span.shrink_to_hi().with_hi(span.hi());\n                     InsertableGenericArgs { insert_span, substs, generics_def_id: def_id, def_id }\n                 };\n@@ -1132,7 +1132,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n                 let generic_args = &generics.own_substs_no_defaults(tcx, substs)\n                     [generics.own_counts().lifetimes..];\n                 let span = match expr.kind {\n-                    ExprKind::MethodCall(path, _, _) => path.ident.span,\n+                    ExprKind::MethodCall(path, ..) => path.ident.span,\n                     _ => expr.span,\n                 };\n \n@@ -1181,20 +1181,20 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n             })\n             .any(|generics| generics.has_impl_trait())\n         };\n-        if let ExprKind::MethodCall(path, args, span) = expr.kind\n+        if let ExprKind::MethodCall(path, receiver, args, span) = expr.kind\n             && let Some(substs) = self.node_substs_opt(expr.hir_id)\n             && substs.iter().any(|arg| self.generic_arg_contains_target(arg))\n             && let Some(def_id) = self.typeck_results.type_dependent_def_id(expr.hir_id)\n             && self.infcx.tcx.trait_of_item(def_id).is_some()\n             && !has_impl_trait(def_id)\n         {\n             let successor =\n-                args.get(1).map_or_else(|| (\")\", span.hi()), |arg| (\", \", arg.span.lo()));\n+                args.get(0).map_or_else(|| (\")\", span.hi()), |arg| (\", \", arg.span.lo()));\n             let substs = self.infcx.resolve_vars_if_possible(substs);\n             self.update_infer_source(InferSource {\n                 span: path.ident.span,\n                 kind: InferSourceKind::FullyQualifiedMethodCall {\n-                    receiver: args.first().unwrap(),\n+                    receiver,\n                     successor,\n                     substs,\n                     def_id,"}, {"sha": "da0271a345e40ed6f1ef80c14e16b3696d0d6e63", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 31, "deletions": 116, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,18 +1,20 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n \n+use crate::errors::AddLifetimeParamsSuggestion;\n+use crate::errors::LifetimeMismatch;\n+use crate::errors::LifetimeMismatchLabels;\n use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::SubregionOrigin;\n use crate::infer::TyCtxt;\n \n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n-use rustc_hir as hir;\n-use rustc_hir::{GenericParamKind, Ty};\n+use rustc_errors::AddToDiagnostic;\n+use rustc_errors::{Diagnostic, ErrorGuaranteed};\n+use rustc_hir::Ty;\n use rustc_middle::ty::Region;\n-use rustc_span::symbol::kw;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n@@ -98,137 +100,50 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = match anon_param_sup.pat.simple_ident() {\n-            Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n-            None => String::new(),\n-        };\n-\n-        let span_label_var2 = match anon_param_sub.pat.simple_ident() {\n-            Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n-            None => String::new(),\n-        };\n-\n         debug!(\n             \"try_report_anon_anon_conflict: sub_is_ret_type={:?} sup_is_ret_type={:?}\",\n             sub_is_ret_type, sup_is_ret_type\n         );\n \n-        let mut err = struct_span_err!(self.tcx().sess, span, E0623, \"lifetime mismatch\");\n-\n-        match (sup_is_ret_type, sub_is_ret_type) {\n+        let labels = match (sup_is_ret_type, sub_is_ret_type) {\n             (ret_capture @ Some(ret_span), _) | (_, ret_capture @ Some(ret_span)) => {\n                 let param_span =\n                     if sup_is_ret_type == ret_capture { ty_sub.span } else { ty_sup.span };\n-\n-                err.span_label(\n+                LifetimeMismatchLabels::InRet {\n                     param_span,\n-                    \"this parameter and the return type are declared with different lifetimes...\",\n-                );\n-                err.span_label(ret_span, \"\");\n-                err.span_label(span, format!(\"...but data{} is returned here\", span_label_var1));\n-            }\n-\n-            (None, None) => {\n-                if ty_sup.hir_id == ty_sub.hir_id {\n-                    err.span_label(ty_sup.span, \"this type is declared with multiple lifetimes...\");\n-                    err.span_label(ty_sub.span, \"\");\n-                    err.span_label(span, \"...but data with one lifetime flows into the other here\");\n-                } else {\n-                    err.span_label(\n-                        ty_sup.span,\n-                        \"these two types are declared with different lifetimes...\",\n-                    );\n-                    err.span_label(ty_sub.span, \"\");\n-                    err.span_label(\n-                        span,\n-                        format!(\"...but data{} flows{} here\", span_label_var1, span_label_var2),\n-                    );\n+                    ret_span,\n+                    span,\n+                    label_var1: anon_param_sup.pat.simple_ident(),\n                 }\n             }\n-        }\n \n-        if suggest_adding_lifetime_params(self.tcx(), sub, ty_sup, ty_sub, &mut err) {\n-            err.note(\"each elided lifetime in input position becomes a distinct lifetime\");\n-        }\n+            (None, None) => LifetimeMismatchLabels::Normal {\n+                hir_equal: ty_sup.hir_id == ty_sub.hir_id,\n+                ty_sup: ty_sup.span,\n+                ty_sub: ty_sub.span,\n+                span,\n+                sup: anon_param_sup.pat.simple_ident(),\n+                sub: anon_param_sub.pat.simple_ident(),\n+            },\n+        };\n \n-        let reported = err.emit();\n+        let suggestion =\n+            AddLifetimeParamsSuggestion { tcx: self.tcx(), sub, ty_sup, ty_sub, add_note: true };\n+        let err = LifetimeMismatch { span, labels, suggestion };\n+        let reported = self.tcx().sess.emit_err(err);\n         Some(reported)\n     }\n }\n \n+/// Currently only used in rustc_borrowck, probably should be\n+/// removed in favour of public_errors::AddLifetimeParamsSuggestion\n pub fn suggest_adding_lifetime_params<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sub: Region<'tcx>,\n-    ty_sup: &Ty<'_>,\n-    ty_sub: &Ty<'_>,\n+    ty_sup: &'tcx Ty<'_>,\n+    ty_sub: &'tcx Ty<'_>,\n     err: &mut Diagnostic,\n-) -> bool {\n-    let (\n-        hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },\n-        hir::Ty { kind: hir::TyKind::Rptr(lifetime_sup, _), .. },\n-    ) = (ty_sub, ty_sup) else {\n-        return false;\n-    };\n-\n-    if !lifetime_sub.name.is_anonymous() || !lifetime_sup.name.is_anonymous() {\n-        return false;\n-    };\n-\n-    let Some(anon_reg) = tcx.is_suitable_region(sub) else {\n-        return false;\n-    };\n-\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n-\n-    let node = tcx.hir().get(hir_id);\n-    let is_impl = matches!(&node, hir::Node::ImplItem(_));\n-    let generics = match node {\n-        hir::Node::Item(&hir::Item { kind: hir::ItemKind::Fn(_, ref generics, ..), .. })\n-        | hir::Node::TraitItem(&hir::TraitItem { ref generics, .. })\n-        | hir::Node::ImplItem(&hir::ImplItem { ref generics, .. }) => generics,\n-        _ => return false,\n-    };\n-\n-    let suggestion_param_name = generics\n-        .params\n-        .iter()\n-        .filter(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n-        .map(|p| p.name.ident().name)\n-        .find(|i| *i != kw::UnderscoreLifetime);\n-    let introduce_new = suggestion_param_name.is_none();\n-    let suggestion_param_name =\n-        suggestion_param_name.map(|n| n.to_string()).unwrap_or_else(|| \"'a\".to_owned());\n-\n-    debug!(?lifetime_sup.span);\n-    debug!(?lifetime_sub.span);\n-    let make_suggestion = |span: rustc_span::Span| {\n-        if span.is_empty() {\n-            (span, format!(\"{}, \", suggestion_param_name))\n-        } else if let Ok(\"&\") = tcx.sess.source_map().span_to_snippet(span).as_deref() {\n-            (span.shrink_to_hi(), format!(\"{} \", suggestion_param_name))\n-        } else {\n-            (span, suggestion_param_name.clone())\n-        }\n-    };\n-    let mut suggestions =\n-        vec![make_suggestion(lifetime_sub.span), make_suggestion(lifetime_sup.span)];\n-\n-    if introduce_new {\n-        let new_param_suggestion =\n-            if let Some(first) = generics.params.iter().find(|p| !p.name.ident().span.is_empty()) {\n-                (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name))\n-            } else {\n-                (generics.span, format!(\"<{}>\", suggestion_param_name))\n-            };\n-\n-        suggestions.push(new_param_suggestion);\n-    }\n-\n-    let mut sugg = String::from(\"consider introducing a named lifetime parameter\");\n-    if is_impl {\n-        sugg.push_str(\" and update trait if needed\");\n-    }\n-    err.multipart_suggestion(sugg, suggestions, Applicability::MaybeIncorrect);\n-\n-    true\n+) {\n+    let suggestion = AddLifetimeParamsSuggestion { tcx, sub, ty_sup, ty_sub, add_note: false };\n+    suggestion.add_to_diagnostic(err);\n }"}, {"sha": "d8f540b74465d46c1ad725a6c18b27c86330d2f0", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -91,7 +91,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n             hir::TyKind::TraitObject(bounds, ..) => {\n                 for bound in bounds {\n                     self.current_index.shift_in(1);\n-                    self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                    self.visit_poly_trait_ref(bound);\n                     self.current_index.shift_out(1);\n                 }\n             }"}, {"sha": "1410e2b63b0b87fbfa433ba727a410780b1354de", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -1,13 +1,14 @@\n //! Error Reporting for when the lifetime for a type doesn't match the `impl` selected for a predicate\n //! to hold.\n \n+use crate::errors::{note_and_explain, IntroducesStaticBecauseUnmetLifetimeReq};\n+use crate::errors::{ImplNote, MismatchedStaticLifetime, TraitSubdiag};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::infer::error_reporting::note_and_explain_region;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::ObligationCauseCode;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::ty::TypeVisitor;\n@@ -39,12 +40,23 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             = *parent.code() else {\n             return None;\n         };\n-        let mut err = self.tcx().sess.struct_span_err(cause.span, \"incompatible lifetime on type\");\n+\n         // FIXME: we should point at the lifetime\n-        let mut multi_span: MultiSpan = vec![binding_span].into();\n-        multi_span.push_span_label(binding_span, \"introduces a `'static` lifetime requirement\");\n-        err.span_note(multi_span, \"because this has an unmet lifetime requirement\");\n-        note_and_explain_region(self.tcx(), &mut err, \"\", sup, \"...\", Some(binding_span));\n+        let multi_span: MultiSpan = vec![binding_span].into();\n+        let multispan_subdiag = IntroducesStaticBecauseUnmetLifetimeReq {\n+            unmet_requirements: multi_span,\n+            binding_span,\n+        };\n+\n+        let expl = note_and_explain::RegionExplanation::new(\n+            self.tcx(),\n+            sup,\n+            Some(binding_span),\n+            note_and_explain::PrefixKind::Empty,\n+            note_and_explain::SuffixKind::Continues,\n+        );\n+        let mut impl_span = None;\n+        let mut trait_subdiags = Vec::new();\n         if let Some(impl_node) = self.tcx().hir().get_if_local(*impl_def_id) {\n             // If an impl is local, then maybe this isn't what they want. Try to\n             // be as helpful as possible with implicit lifetimes.\n@@ -73,31 +85,30 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 // there aren't trait objects or because none are implicit, then just\n                 // write a single note on the impl itself.\n \n-                let impl_span = self.tcx().def_span(*impl_def_id);\n-                err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+                impl_span = Some(self.tcx().def_span(*impl_def_id));\n             } else {\n                 // Otherwise, point at all implicit static lifetimes\n \n-                err.note(\"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n                 for span in &traits {\n-                    err.span_note(*span, \"this has an implicit `'static` lifetime requirement\");\n+                    trait_subdiags.push(TraitSubdiag::Note { span: *span });\n                     // It would be nice to put this immediately under the above note, but they get\n                     // pushed to the end.\n-                    err.span_suggestion_verbose(\n-                        span.shrink_to_hi(),\n-                        \"consider relaxing the implicit `'static` requirement\",\n-                        \" + '_\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    trait_subdiags.push(TraitSubdiag::Sugg { span: span.shrink_to_hi() });\n                 }\n             }\n         } else {\n             // Otherwise just point out the impl.\n \n-            let impl_span = self.tcx().def_span(*impl_def_id);\n-            err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+            impl_span = Some(self.tcx().def_span(*impl_def_id));\n         }\n-        let reported = err.emit();\n+        let err = MismatchedStaticLifetime {\n+            cause_span: cause.span,\n+            unmet_lifetime_reqs: multispan_subdiag,\n+            expl,\n+            impl_note: ImplNote { impl_span },\n+            trait_subdiags,\n+        };\n+        let reported = self.tcx().sess.emit_err(err);\n         Some(reported)\n     }\n }"}, {"sha": "2ccfcd51b1152a20165e76920a40eada4631f93e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -185,8 +185,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             | ObligationCauseCode::BlockTailExpression(hir_id) = cause.code()\n             {\n                 let parent_id = tcx.hir().get_parent_item(*hir_id);\n-                let parent_id = tcx.hir().local_def_id_to_hir_id(parent_id);\n-                if let Some(fn_decl) = tcx.hir().fn_decl_by_hir_id(parent_id) {\n+                if let Some(fn_decl) = tcx.hir().fn_decl_by_hir_id(parent_id.into()) {\n                     let mut span: MultiSpan = fn_decl.output.span().into();\n                     let mut add_label = true;\n                     if let hir::FnRetTy::Return(ty) = fn_decl.output {\n@@ -300,7 +299,7 @@ pub fn suggest_new_region_bound(\n             continue;\n         }\n         match fn_return.kind {\n-            TyKind::OpaqueDef(item_id, _) => {\n+            TyKind::OpaqueDef(item_id, _, _) => {\n                 let item = tcx.hir().item(item_id);\n                 let ItemKind::OpaqueTy(opaque) = &item.kind else {\n                     return;\n@@ -415,7 +414,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let tcx = self.tcx();\n         match tcx.hir().get_if_local(def_id) {\n             Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id())) {\n+                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n+                {\n                     Some(Node::Item(Item {\n                         kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n                         ..\n@@ -425,7 +425,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n             Some(Node::TraitItem(trait_item)) => {\n                 let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did) {\n+                match tcx.hir().find_by_def_id(trait_did.def_id) {\n                     Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n                         // The method being called is defined in the `trait`, but the `'static`\n                         // obligation comes from the `impl`. Find that `impl` so that we can point\n@@ -544,7 +544,7 @@ pub struct TraitObjectVisitor(pub FxHashSet<DefId>);\n impl<'tcx> TypeVisitor<'tcx> for TraitObjectVisitor {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n-            ty::Dynamic(preds, re) if re.is_static() => {\n+            ty::Dynamic(preds, re, _) if re.is_static() => {\n                 if let Some(def_id) = preds.principal_def_id() {\n                     self.0.insert(def_id);\n                 }"}, {"sha": "a6a39d062d51dadc9a0f2e173af676f563e4bdb7", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -154,16 +154,11 @@ impl<'tcx> Visitor<'tcx> for TypeParamSpanVisitor<'tcx> {\n             }\n             hir::TyKind::Path(hir::QPath::Resolved(None, path)) => match &path.segments {\n                 [segment]\n-                    if segment\n-                        .res\n-                        .map(|res| {\n-                            matches!(\n-                                res,\n-                                Res::SelfTy { trait_: _, alias_to: _ }\n-                                    | Res::Def(hir::def::DefKind::TyParam, _)\n-                            )\n-                        })\n-                        .unwrap_or(false) =>\n+                    if matches!(\n+                        segment.res,\n+                        Res::SelfTy { trait_: _, alias_to: _ }\n+                            | Res::Def(hir::def::DefKind::TyParam, _)\n+                    ) =>\n                 {\n                     self.types.push(path.span);\n                 }"}, {"sha": "286cfb64a1ecd2d781e06954324e640f31ffda44", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -2,7 +2,7 @@ use crate::errors::RegionOriginNote;\n use crate::infer::error_reporting::note_and_explain_region;\n use crate::infer::{self, InferCtxt, SubregionOrigin};\n use rustc_errors::{\n-    fluent, struct_span_err, AddSubdiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    fluent, struct_span_err, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n };\n use rustc_middle::traits::ObligationCauseCode;\n use rustc_middle::ty::error::TypeError;\n@@ -77,6 +77,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n                 self.note_region_origin(err, &parent);\n             }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                RegionOriginNote::Plain {\n+                    span,\n+                    msg: fluent::infer::ascribe_user_type_prove_predicate,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n         }\n     }\n \n@@ -356,6 +363,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 err\n             }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"lifetime instantiated with \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but lifetime must outlive \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n         }\n     }\n "}, {"sha": "fee15afc7b3aaa3077643900e3b3577a646e04fd", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -126,7 +126,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::ReFree(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // replace all free regions with 'erased\n                 self.tcx().lifetimes.re_erased"}, {"sha": "0ce271c0e5d6541b5840c2a287b5fb03e9892941", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// For more details visit the relevant sections of the [rustc dev guide].\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub fn replace_bound_vars_with_placeholders<T>(&self, binder: ty::Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx> + Copy,\n@@ -81,19 +81,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let next_universe = self.create_next_universe();\n \n         let delegate = FnMutDelegate {\n-            regions: |br: ty::BoundRegion| {\n+            regions: &mut |br: ty::BoundRegion| {\n                 self.tcx.mk_region(ty::RePlaceholder(ty::PlaceholderRegion {\n                     universe: next_universe,\n                     name: br.kind,\n                 }))\n             },\n-            types: |bound_ty: ty::BoundTy| {\n+            types: &mut |bound_ty: ty::BoundTy| {\n                 self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: next_universe,\n                     name: bound_ty.var,\n                 }))\n             },\n-            consts: |bound_var: ty::BoundVar, ty| {\n+            consts: &mut |bound_var: ty::BoundVar, ty| {\n                 self.tcx.mk_const(ty::ConstS {\n                     kind: ty::ConstKind::Placeholder(ty::PlaceholderConst {\n                         universe: next_universe,\n@@ -104,9 +104,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             },\n         };\n \n-        let result = self.tcx.replace_bound_vars_uncached(binder, delegate);\n-        debug!(?next_universe, ?result);\n-        result\n+        debug!(?next_universe);\n+        self.tcx.replace_bound_vars_uncached(binder, delegate)\n     }\n \n     /// See [RegionConstraintCollector::leak_check][1]."}, {"sha": "5f13b2b3deb1b6e0c7fce6f27bd78280a495238b", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "efc9c1ca46fe49da56b2f5fb1352c7a698643dd9", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "bb6f6ae60e26ac27c05ad3e59c889122e90d6ef3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "9bf92f08aa54b63095ff0efd3fd78879e6275050", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "4d124554afb94d3bb119275e9c415932dbc8131b", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "14ee9f05190102b8f7067bf28a1f56a7b332b9b5", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "113d4f0906673d0ecef6f43f8b37c958dbeb10f4", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "2d19d1823fdfc2b04816cde419dd59aa3361009b", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "229b69b92e68e31f3b48f5190319c16885a6300d", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 116, "deletions": 41, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "a5c21f0fb9b50eadf775aac2a6840500f388a00d", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "f470b2eb8c1939a4acef1abd6f12e7b4c6a35b97", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 42, "deletions": 75, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "67b3da687200e9538aff976cbf4db4af520c482e", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "375dd670fabf4c092bdde2aef7630df64370aa5b", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "7ff086452536bbfafa30d80f7a9050f9540eeed6", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "611961ab1cc94afb98501fb1b205e4502af4199a", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "b91c098ab03db2828718a7294dc0de51d773c5df", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "c8600ded987e5d4d921c32a20a3a507d3781c673", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "1c6ab6a082b99ce7279d425bedb0fc04f984a2c5", "filename": "compiler/rustc_infer/src/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "e12c069dcc1d980de0587cc5368b863574767ca0", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "097640f26c154a2f9216ec1c775a64a95d12f6d6", "filename": "compiler/rustc_interface/src/errors.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "949bd02ad6839a8f1535e453efc2d08d1a704dcf", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "a41a749ee68e5f240c49bbfd129301c49f4d4ab9", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "c41b154c3e066cb936a5b76a3cce35bbaaf823db", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "2b1b931b7326b9e2b15e5a7fff78b12875b96723", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "6c725a01b53151ccfb9325f876442a22920facbf", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "2cd959689e6cf27f0ef24b77be1887c7367ca68d", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "f7e70d355cf86e6ff3ad519311676536ed3a6e24", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "a79c982649afca775168aa27d61a4a875bad075a", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "abe61406c219cb6c020b9f6dbb5c4b055b31973d", "filename": "compiler/rustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2FCargo.toml?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "b97f8acb37f8442d7152d0e12f01fe9fac4db493", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "5fba1d3d3c7acc2ac835b0f4941e0193eae29bb7", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 134, "deletions": 30, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "cbab56f2066f01ad8b23ed774920b6b3f97d3b10", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "96ecd79a69cfb3603cae46f45a7c06064ab331a8", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "880f3fbd00e60791bda61a70989304eeca0d2962", "filename": "compiler/rustc_lint/src/errors.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "d8a03024d132334d424361582457a34816612e6c", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "da6f1c5eeccfd1112d25b7a27c63cecdba145e16", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "7e885e6c51aad42261b5da1eeb11ee618712875c", "filename": "compiler/rustc_lint/src/let_underscore.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "1e16ac51e9e5de807f6178de339e694c8f2b006d", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "4408f68dd63f3d4738363870baa6ec8507db7a70", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "5f7f03480c043b07e58815012b35ff2b8418705c", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "768ad84838b154cb0e8ceebc91d323ab72ca74e5", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "d1449496d331578be434f7053145359d05767316", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "1c6a057d1a85b56e3faf054f711aa52888572623", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "4fb6d65a6e98f4f86db64f3975bc73a5809fe042", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "3d426ecbfcb0538a663491077f40e578a80758ee", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "e5dfda24dc7016be98f192ead19760d6629b9f61", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "11b2d057a07692fd1fbdee07b1b6bc01ac2e03dd", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "09f377d349f45b2a78a7e58c923ec4c22374439f", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 20, "deletions": 247, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "6f36281af23cc7abfff8aa0b78c44ca113c3efe0", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 10, "deletions": 45, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "3b8d9594eb91abad6892b860b5c58d84910eca9e", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "2aa292bbce2b6493b86c23e12d46c0fdecf7696b", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 168, "deletions": 326, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "4166816b5e3c7feb80402134bd8dca76f1bac62d", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "6545ae086b15801e6106258d904c5c85a1a1d719", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 191, "deletions": 345, "changes": 536, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}, {"sha": "a31bda9ca0def7dfab11df273586e4fc4e5156e0", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 266, "deletions": 4, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aab524cbafec7ff8c7cd54ba4f6fb18216c623/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=24aab524cbafec7ff8c7cd54ba4f6fb18216c623"}]}