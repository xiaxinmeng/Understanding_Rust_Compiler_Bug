{"sha": "5dc3fd7c05010654b4d80b87eac8c937e4808607", "node_id": "C_kwDOAAsO6NoAKDVkYzNmZDdjMDUwMTA2NTRiNGQ4MGI4N2VhYzhjOTM3ZTQ4MDg2MDc", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-21T21:50:16Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-23T05:56:27Z"}, "message": "Include relation direction in AliasEq predicate", "tree": {"sha": "5277cbdbb1c42ecfaac6cc1e1a0dd01176f95d30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5277cbdbb1c42ecfaac6cc1e1a0dd01176f95d30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dc3fd7c05010654b4d80b87eac8c937e4808607", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dc3fd7c05010654b4d80b87eac8c937e4808607", "html_url": "https://github.com/rust-lang/rust/commit/5dc3fd7c05010654b4d80b87eac8c937e4808607", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dc3fd7c05010654b4d80b87eac8c937e4808607/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "439292bc7913399e406d9bb7e8da0f70c6317c6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/439292bc7913399e406d9bb7e8da0f70c6317c6e", "html_url": "https://github.com/rust-lang/rust/commit/439292bc7913399e406d9bb7e8da0f70c6317c6e"}], "stats": {"total": 211, "additions": 175, "deletions": 36}, "files": [{"sha": "c82438f05e14096801eea1545c9af81484d4a6b5", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -842,7 +842,7 @@ pub trait ObligationEmittingRelation<'tcx>: TypeRelation<'tcx> {\n         let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n \n         self.register_predicates([ty::Binder::dummy(if self.tcx().trait_solver_next() {\n-            ty::PredicateKind::AliasEq(a.into(), b.into())\n+            ty::PredicateKind::AliasEq(a.into(), b.into(), ty::AliasRelationDirection::Equate)\n         } else {\n             ty::PredicateKind::ConstEquate(a, b)\n         })]);\n@@ -852,13 +852,15 @@ pub trait ObligationEmittingRelation<'tcx>: TypeRelation<'tcx> {\n     ///\n     /// If they aren't equal then the relation doesn't hold.\n     fn register_type_equate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n-        let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n-\n         self.register_predicates([ty::Binder::dummy(ty::PredicateKind::AliasEq(\n             a.into(),\n             b.into(),\n+            self.alias_relate_direction(),\n         ))]);\n     }\n+\n+    /// Relation direction emitted for `AliasEq` predicates\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection;\n }\n \n fn int_unification_error<'tcx>("}, {"sha": "38002357cde35cbe948c221d95792c4935228e56", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -210,4 +210,8 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Equate<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        ty::AliasRelationDirection::Equate\n+    }\n }"}, {"sha": "6395c4d4b20781f86ec5dd01dfe1d3f559a83a74", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -155,4 +155,9 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Glb<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        // FIXME(deferred_projection_equality): This isn't right, I think?\n+        ty::AliasRelationDirection::Equate\n+    }\n }"}, {"sha": "98cbd4c561c52d0b6d6703c170ff2bd7db914ffc", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -155,4 +155,9 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Lub<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations)\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        // FIXME(deferred_projection_equality): This isn't right, I think?\n+        ty::AliasRelationDirection::Equate\n+    }\n }"}, {"sha": "216d2965da7615b0bbabe421122da1c4bbf5eae7", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -777,6 +777,16 @@ where\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.delegate.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        match self.ambient_variance {\n+            ty::Variance::Covariant => ty::AliasRelationDirection::Subtype,\n+            ty::Variance::Contravariant => ty::AliasRelationDirection::Supertype,\n+            ty::Variance::Invariant => ty::AliasRelationDirection::Equate,\n+            // FIXME(deferred_projection_equality): Implement this when we trigger it\n+            ty::Variance::Bivariant => unreachable!(),\n+        }\n+    }\n }\n \n /// When we encounter a binder like `for<..> fn(..)`, we actually have"}, {"sha": "fc73ca7606d238213c3edbc74b7dc4045c4ac9c4", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -236,4 +236,8 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Sub<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        ty::AliasRelationDirection::Subtype\n+    }\n }"}, {"sha": "1ae47fddccc1a23bceec1355a1ea0dc2e30cad7a", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -288,7 +288,7 @@ impl FlagComputation {\n                 self.add_ty(ty);\n             }\n             ty::PredicateKind::Ambiguous => {}\n-            ty::PredicateKind::AliasEq(t1, t2) => {\n+            ty::PredicateKind::AliasEq(t1, t2, _) => {\n                 self.add_term(t1);\n                 self.add_term(t2);\n             }"}, {"sha": "d1e268f49c4b228c41b67ddb0bf50b328e344ec0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -640,7 +640,25 @@ pub enum PredicateKind<'tcx> {\n     /// This predicate requires two terms to be equal to eachother.\n     ///\n     /// Only used for new solver\n-    AliasEq(Term<'tcx>, Term<'tcx>),\n+    AliasEq(Term<'tcx>, Term<'tcx>, AliasRelationDirection),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n+#[derive(HashStable, Debug)]\n+pub enum AliasRelationDirection {\n+    Equate,\n+    Subtype,\n+    Supertype,\n+}\n+\n+impl AliasRelationDirection {\n+    pub fn invert(self) -> Self {\n+        match self {\n+            AliasRelationDirection::Equate => AliasRelationDirection::Equate,\n+            AliasRelationDirection::Subtype => AliasRelationDirection::Supertype,\n+            AliasRelationDirection::Supertype => AliasRelationDirection::Subtype,\n+        }\n+    }\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -976,11 +994,11 @@ impl<'tcx> Term<'tcx> {\n         }\n     }\n \n-    /// This function returns `None` for `AliasKind::Opaque`.\n+    /// This function returns the inner `AliasTy` if this term is a projection.\n     ///\n     /// FIXME: rename `AliasTy` to `AliasTerm` and make sure we correctly\n     /// deal with constants.\n-    pub fn to_alias_term_no_opaque(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n+    pub fn to_projection_term(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n         match self.unpack() {\n             TermKind::Ty(ty) => match ty.kind() {\n                 ty::Alias(kind, alias_ty) => match kind {"}, {"sha": "e96856231cec4b65f2c4a59d17a42270a9ec44a7", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -2847,7 +2847,8 @@ define_print_and_forward_display! {\n                 p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n             ty::PredicateKind::Ambiguous => p!(\"ambiguous\"),\n-            ty::PredicateKind::AliasEq(t1, t2) => p!(print(t1), \" == \", print(t2)),\n+            // TODO\n+            ty::PredicateKind::AliasEq(t1, t2, _) => p!(print(t1), \" == \", print(t2)),\n         }\n     }\n "}, {"sha": "92a2b4b18dd6ae8a0aeb7e459b6ea67d119ae905", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -177,7 +177,8 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n                 write!(f, \"TypeWellFormedFromEnv({:?})\", ty)\n             }\n             ty::PredicateKind::Ambiguous => write!(f, \"Ambiguous\"),\n-            ty::PredicateKind::AliasEq(t1, t2) => write!(f, \"AliasEq({t1:?}, {t2:?})\"),\n+            // TODO\n+            ty::PredicateKind::AliasEq(t1, t2, _) => write!(f, \"AliasEq({t1:?}, {t2:?})\"),\n         }\n     }\n }\n@@ -250,6 +251,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::AssocItem,\n     crate::ty::AssocKind,\n     crate::ty::AliasKind,\n+    crate::ty::AliasRelationDirection,\n     crate::ty::Placeholder<crate::ty::BoundRegionKind>,\n     crate::ty::Placeholder<crate::ty::BoundTyKind>,\n     crate::ty::ClosureKind,"}, {"sha": "fda9ef008d7159cfed0c4913f6b957a6312c258b", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -180,7 +180,7 @@ where\n             | ty::PredicateKind::ConstEquate(_, _)\n             | ty::PredicateKind::TypeWellFormedFromEnv(_)\n             | ty::PredicateKind::Ambiguous\n-            | ty::PredicateKind::AliasEq(_, _) => bug!(\"unexpected predicate: {:?}\", predicate),\n+            | ty::PredicateKind::AliasEq(..) => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }\n "}, {"sha": "106a989b22f617cb5b03593ca54071e31a66731f", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -223,8 +223,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n-                ty::PredicateKind::AliasEq(lhs, rhs) => {\n-                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n+                ty::PredicateKind::AliasEq(lhs, rhs, direction) => {\n+                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs, direction) })\n                 }\n             }\n         } else {"}, {"sha": "a9c9e5761a86d2ff468786c7a458bf42c55f44b2", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                         MismatchedProjectionTypes { err: TypeError::Mismatch },\n                                     )\n                                 }\n-                                ty::PredicateKind::AliasEq(_, _) => {\n+                                ty::PredicateKind::AliasEq(_, _, _) => {\n                                     FulfillmentErrorCode::CodeProjectionError(\n                                         MismatchedProjectionTypes { err: TypeError::Mismatch },\n                                     )"}, {"sha": "48ef089a7b2ec9f893ed748010eccf641a024d78", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 72, "deletions": 23, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -158,13 +158,35 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self), ret)]\n     fn compute_alias_eq_goal(\n         &mut self,\n-        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>)>,\n+        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>, ty::AliasRelationDirection)>,\n     ) -> QueryResult<'tcx> {\n         let tcx = self.tcx();\n \n-        let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other| {\n+        let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other, direction| {\n             debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n-            let r = ecx.probe(|ecx| {\n+            let result = ecx.probe(|ecx| {\n+                let other = match direction {\n+                    // This is purely an optimization.\n+                    ty::AliasRelationDirection::Equate => other,\n+\n+                    ty::AliasRelationDirection::Subtype | ty::AliasRelationDirection::Supertype => {\n+                        let fresh = ecx.next_term_infer_of_kind(other);\n+                        let (sub, sup) = if direction == ty::AliasRelationDirection::Subtype {\n+                            (fresh, other)\n+                        } else {\n+                            (other, fresh)\n+                        };\n+                        ecx.add_goals(\n+                            ecx.infcx\n+                                .at(&ObligationCause::dummy(), goal.param_env)\n+                                .sub(DefineOpaqueTypes::No, sub, sup)?\n+                                .into_obligations()\n+                                .into_iter()\n+                                .map(|o| o.into()),\n+                        );\n+                        fresh\n+                    }\n+                };\n                 ecx.add_goal(goal.with(\n                     tcx,\n                     ty::Binder::dummy(ty::ProjectionPredicate {\n@@ -174,37 +196,64 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ));\n                 ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             });\n-            debug!(\"evaluate_normalizes_to(..) -> {:?}\", r);\n-            r\n+            debug!(\"evaluate_normalizes_to({alias}, {other}, {direction:?}) -> {result:?}\");\n+            result\n         };\n \n-        if goal.predicate.0.is_infer() || goal.predicate.1.is_infer() {\n+        let (lhs, rhs, direction) = goal.predicate;\n+\n+        if lhs.is_infer() || rhs.is_infer() {\n             bug!(\n                 \"`AliasEq` goal with an infer var on lhs or rhs which should have been instantiated\"\n             );\n         }\n \n-        match (\n-            goal.predicate.0.to_alias_term_no_opaque(tcx),\n-            goal.predicate.1.to_alias_term_no_opaque(tcx),\n-        ) {\n+        match (lhs.to_projection_term(tcx), rhs.to_projection_term(tcx)) {\n             (None, None) => bug!(\"`AliasEq` goal without an alias on either lhs or rhs\"),\n-            (Some(alias), None) => evaluate_normalizes_to(self, alias, goal.predicate.1),\n-            (None, Some(alias)) => evaluate_normalizes_to(self, alias, goal.predicate.0),\n-            (Some(alias_lhs), Some(alias_rhs)) => {\n-                debug!(\"compute_alias_eq_goal: both sides are aliases\");\n \n-                let mut candidates = Vec::with_capacity(3);\n+            // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n+            (Some(alias_lhs), None) => evaluate_normalizes_to(self, alias_lhs, rhs, direction),\n \n-                // Evaluate all 3 potential candidates for the alias' being equal\n-                candidates.push(evaluate_normalizes_to(self, alias_lhs, goal.predicate.1));\n-                candidates.push(evaluate_normalizes_to(self, alias_rhs, goal.predicate.0));\n-                candidates.push(self.probe(|ecx| {\n-                    debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n-                    ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                }));\n+            // LHS is not a projection, only way this is true is if RHS normalizes-to LHS\n+            (None, Some(alias_rhs)) => {\n+                evaluate_normalizes_to(self, alias_rhs, lhs, direction.invert())\n+            }\n \n+            (Some(alias_lhs), Some(alias_rhs)) => {\n+                debug!(\"compute_alias_eq_goal: both sides are aliases\");\n+\n+                let candidates = vec![\n+                    // LHS normalizes-to RHS\n+                    evaluate_normalizes_to(self, alias_lhs, rhs, direction),\n+                    // RHS normalizes-to RHS\n+                    evaluate_normalizes_to(self, alias_rhs, lhs, direction.invert()),\n+                    // Relate via substs\n+                    self.probe(|ecx| {\n+                        debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n+\n+                        ecx.add_goals(\n+                            match direction {\n+                                ty::AliasRelationDirection::Equate => ecx\n+                                    .infcx\n+                                    .at(&ObligationCause::dummy(), goal.param_env)\n+                                    .eq(DefineOpaqueTypes::No, alias_lhs, alias_rhs),\n+                                ty::AliasRelationDirection::Subtype => ecx\n+                                    .infcx\n+                                    .at(&ObligationCause::dummy(), goal.param_env)\n+                                    .sub(DefineOpaqueTypes::No, alias_lhs, alias_rhs),\n+                                ty::AliasRelationDirection::Supertype => ecx\n+                                    .infcx\n+                                    .at(&ObligationCause::dummy(), goal.param_env)\n+                                    .sup(DefineOpaqueTypes::No, alias_lhs, alias_rhs),\n+                            }?\n+                            .into_obligations()\n+                            .into_iter()\n+                            .map(|o| o.into()),\n+                        );\n+\n+                        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                    }),\n+                ];\n                 debug!(?candidates);\n \n                 self.try_merge_responses(candidates.into_iter())"}, {"sha": "13607b9079a75d120a712ca7da44a1a40b5158d7", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/method_chain.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -92,6 +92,11 @@ impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n }\n \n impl<'tcx> ObligationEmittingRelation<'tcx> for CollectAllMismatches<'_, 'tcx> {\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        // FIXME(deferred_projection_equality): We really should get rid of this relation.\n+        ty::AliasRelationDirection::Equate\n+    }\n+\n     fn register_obligations(&mut self, _obligations: PredicateObligations<'tcx>) {\n         // FIXME(deferred_projection_equality)\n     }"}, {"sha": "30c1981a92eceed582a7460fb904ec75ad431dbc", "filename": "tests/ui/traits/new-solver/alias-sub.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5dc3fd7c05010654b4d80b87eac8c937e4808607/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc3fd7c05010654b4d80b87eac8c937e4808607/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-sub.rs?ref=5dc3fd7c05010654b4d80b87eac8c937e4808607", "patch": "@@ -0,0 +1,34 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Trait {\n+    type Assoc: Sized;\n+}\n+\n+impl Trait for &'static str {\n+    type Assoc = &'static str;\n+}\n+\n+// Wrapper is just here to get around stupid `Sized` obligations in mir typeck\n+struct Wrapper<T: ?Sized>(std::marker::PhantomData<T>);\n+fn mk<T: Trait>(x: T) -> Wrapper<<T as Trait>::Assoc> { todo!() }\n+\n+\n+trait IsStaticStr {}\n+impl IsStaticStr for (&'static str,) {}\n+fn define<T: IsStaticStr>(_: T) {}\n+\n+fn foo<'a, T: Trait>() {\n+    let y = Default::default();\n+\n+    // `<?0 as Trait>::Assoc <: &'a str`\n+    // In the old solver, this would *equate* the LHS and RHS.\n+    let _: Wrapper<&'a str> = mk(y);\n+\n+    // ... then later on, we constrain `?0 = &'static str`\n+    // but that should not mean that `'a = 'static`, because\n+    // we should use *sub* above.\n+    define((y,));\n+}\n+\n+fn main() {}"}]}