{"sha": "e6d814c423db142575563e2c5126ca9cd0794b14", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZDgxNGM0MjNkYjE0MjU3NTU2M2UyYzUxMjZjYTljZDA3OTRiMTQ=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-08-05T10:34:22Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-08-05T10:55:22Z"}, "message": "Put comment between chain elements on its original position", "tree": {"sha": "39c2d18a22e9f0b38cfaa25221d4fc7c90868506", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39c2d18a22e9f0b38cfaa25221d4fc7c90868506"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6d814c423db142575563e2c5126ca9cd0794b14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d814c423db142575563e2c5126ca9cd0794b14", "html_url": "https://github.com/rust-lang/rust/commit/e6d814c423db142575563e2c5126ca9cd0794b14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6d814c423db142575563e2c5126ca9cd0794b14/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24fccdc45c170a6d64025bbebd44ae30bea52d32", "url": "https://api.github.com/repos/rust-lang/rust/commits/24fccdc45c170a6d64025bbebd44ae30bea52d32", "html_url": "https://github.com/rust-lang/rust/commit/24fccdc45c170a6d64025bbebd44ae30bea52d32"}], "stats": {"total": 144, "additions": 115, "deletions": 29}, "files": [{"sha": "99d943c494ac2541826c0f3359a3ae3fbb3f772e", "filename": "src/chains.rs", "status": "modified", "additions": 115, "deletions": 29, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e6d814c423db142575563e2c5126ca9cd0794b14/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d814c423db142575563e2c5126ca9cd0794b14/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=e6d814c423db142575563e2c5126ca9cd0794b14", "patch": "@@ -69,6 +69,7 @@ use codemap::SpanUtils;\n use comment::rewrite_comment;\n use config::IndentStyle;\n use expr::rewrite_call;\n+use lists::{extract_post_comment, extract_pre_comment, get_comment_end};\n use macros::convert_try_mac;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n@@ -81,7 +82,7 @@ use std::borrow::Cow;\n use std::cmp::min;\n use std::iter;\n \n-use syntax::codemap::Span;\n+use syntax::codemap::{BytePos, Span};\n use syntax::{ast, ptr};\n \n pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n@@ -97,6 +98,12 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     chain.rewrite(context, shape)\n }\n \n+#[derive(Debug)]\n+enum CommentPosition {\n+    Back,\n+    Top,\n+}\n+\n // An expression plus trailing `?`s to be formatted together.\n #[derive(Debug)]\n struct ChainItem {\n@@ -118,7 +125,7 @@ enum ChainItemKind {\n     ),\n     StructField(ast::Ident),\n     TupleField(ast::Ident, bool),\n-    Comment,\n+    Comment(String, CommentPosition),\n }\n \n impl ChainItemKind {\n@@ -128,7 +135,7 @@ impl ChainItemKind {\n             ChainItemKind::MethodCall(..) => reps.contains('\\n'),\n             ChainItemKind::StructField(..)\n             | ChainItemKind::TupleField(..)\n-            | ChainItemKind::Comment => false,\n+            | ChainItemKind::Comment(..) => false,\n         }\n     }\n \n@@ -187,12 +194,9 @@ impl Rewrite for ChainItem {\n             ChainItemKind::TupleField(ident, nested) => {\n                 format!(\"{}.{}\", if nested { \" \" } else { \"\" }, ident.name)\n             }\n-            ChainItemKind::Comment => rewrite_comment(\n-                context.snippet(self.span).trim(),\n-                false,\n-                shape,\n-                context.config,\n-            )?,\n+            ChainItemKind::Comment(ref comment, _) => {\n+                rewrite_comment(comment, false, shape, context.config)?\n+            }\n         };\n         Some(format!(\"{}{}\", rewrite, \"?\".repeat(self.tries)))\n     }\n@@ -204,17 +208,17 @@ impl ChainItem {\n         ChainItem { kind, tries, span }\n     }\n \n-    fn comment(span: Span) -> ChainItem {\n+    fn comment(span: Span, comment: String, pos: CommentPosition) -> ChainItem {\n         ChainItem {\n-            kind: ChainItemKind::Comment,\n+            kind: ChainItemKind::Comment(comment, pos),\n             tries: 0,\n             span,\n         }\n     }\n \n     fn is_comment(&self) -> bool {\n         match self.kind {\n-            ChainItemKind::Comment => true,\n+            ChainItemKind::Comment(..) => true,\n             _ => false,\n         }\n     }\n@@ -269,21 +273,98 @@ impl Chain {\n             s.chars().all(|c| c == '?')\n         }\n \n+        fn handle_post_comment(\n+            post_comment_span: Span,\n+            post_comment_snippet: &str,\n+            prev_span_end: &mut BytePos,\n+            children: &mut Vec<ChainItem>,\n+        ) {\n+            let white_spaces: &[_] = &[' ', '\\t'];\n+            if post_comment_snippet\n+                .trim_matches(white_spaces)\n+                .starts_with('\\n')\n+            {\n+                // No post comment.\n+                return;\n+            }\n+            // HACK: Treat `?`s as separators.\n+            let trimmed_snippet = post_comment_snippet.trim_matches('?');\n+            let comment_end = get_comment_end(trimmed_snippet, \"?\", \"\", false);\n+            let maybe_post_comment = extract_post_comment(trimmed_snippet, comment_end, \"?\")\n+                .and_then(|comment| {\n+                    if comment.is_empty() {\n+                        None\n+                    } else {\n+                        Some((comment, comment_end))\n+                    }\n+                });\n+\n+            if let Some((post_comment, comment_end)) = maybe_post_comment {\n+                children.push(ChainItem::comment(\n+                    post_comment_span,\n+                    post_comment,\n+                    CommentPosition::Back,\n+                ));\n+                *prev_span_end = *prev_span_end + BytePos(comment_end as u32);\n+            }\n+        }\n+\n         let parent = rev_children.pop().unwrap();\n         let mut children = vec![];\n-        let mut prev_hi = parent.span.hi();\n-        for chain_item in rev_children.into_iter().rev() {\n-            let comment_span = mk_sp(prev_hi, chain_item.span.lo());\n+        let mut prev_span_end = parent.span.hi();\n+        let mut iter = rev_children.into_iter().rev().peekable();\n+        if let Some(first_chain_item) = iter.peek() {\n+            let comment_span = mk_sp(prev_span_end, first_chain_item.span.lo());\n             let comment_snippet = context.snippet(comment_span);\n+            if !is_tries(comment_snippet.trim()) {\n+                handle_post_comment(\n+                    comment_span,\n+                    comment_snippet,\n+                    &mut prev_span_end,\n+                    &mut children,\n+                );\n+            }\n+        }\n+        while let Some(chain_item) = iter.next() {\n+            let comment_snippet = context.snippet(chain_item.span);\n             // FIXME: Figure out the way to get a correct span when converting `try!` to `?`.\n-            if !(context.config.use_try_shorthand()\n-                || comment_snippet.trim().is_empty()\n-                || is_tries(comment_snippet.trim()))\n-            {\n-                children.push(ChainItem::comment(comment_span));\n+            let handle_comment =\n+                !(context.config.use_try_shorthand() || is_tries(comment_snippet.trim()));\n+\n+            // Pre-comment\n+            if handle_comment {\n+                let pre_comment_span = mk_sp(prev_span_end, chain_item.span.lo());\n+                let pre_comment_snippet = context.snippet(pre_comment_span);\n+                let (pre_comment, _) = extract_pre_comment(pre_comment_snippet);\n+                match pre_comment {\n+                    Some(ref comment) if !comment.is_empty() => {\n+                        children.push(ChainItem::comment(\n+                            pre_comment_span,\n+                            comment.to_owned(),\n+                            CommentPosition::Top,\n+                        ));\n+                    }\n+                    _ => (),\n+                }\n             }\n-            prev_hi = chain_item.span.hi();\n+\n+            prev_span_end = chain_item.span.hi();\n             children.push(chain_item);\n+\n+            // Post-comment\n+            if !handle_comment || iter.peek().is_none() {\n+                continue;\n+            }\n+\n+            let next_lo = iter.peek().unwrap().span.lo();\n+            let post_comment_span = mk_sp(prev_span_end, next_lo);\n+            let post_comment_snippet = context.snippet(post_comment_span);\n+            handle_post_comment(\n+                post_comment_span,\n+                post_comment_snippet,\n+                &mut prev_span_end,\n+                &mut children,\n+            );\n         }\n \n         Chain { parent, children }\n@@ -552,13 +633,18 @@ impl<'a> ChainFormatterShared<'a> {\n \n         let mut rewrite_iter = self.rewrites.iter();\n         let mut result = rewrite_iter.next().unwrap().clone();\n+        let children_iter = self.children.iter();\n+        let iter = rewrite_iter.zip(block_like_iter).zip(children_iter);\n \n-        for (rewrite, prev_is_block_like) in rewrite_iter.zip(block_like_iter) {\n-            if !prev_is_block_like {\n-                result.push_str(&connector);\n-            } else if rewrite.starts_with('/') {\n-                // This is comment, add a space before it.\n-                result.push(' ');\n+        for ((rewrite, prev_is_block_like), chain_item) in iter {\n+            match chain_item.kind {\n+                ChainItemKind::Comment(_, CommentPosition::Back) => result.push(' '),\n+                ChainItemKind::Comment(_, CommentPosition::Top) => result.push_str(&connector),\n+                _ => {\n+                    if !prev_is_block_like {\n+                        result.push_str(&connector);\n+                    }\n+                }\n             }\n             result.push_str(&rewrite);\n         }\n@@ -597,7 +683,7 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n \n         while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n             let item = &self.shared.children[0];\n-            if let ChainItemKind::Comment = item.kind {\n+            if let ChainItemKind::Comment(..) = item.kind {\n                 break;\n             }\n             let shape = shape.offset_left(root_rewrite.len())?;\n@@ -692,7 +778,7 @@ impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n \n         if !multiline || parent.kind.is_block_like(context, &root_rewrite) {\n             let item = &self.shared.children[0];\n-            if let ChainItemKind::Comment = item.kind {\n+            if let ChainItemKind::Comment(..) = item.kind {\n                 self.shared.rewrites.push(root_rewrite);\n                 return Some(());\n             }"}]}