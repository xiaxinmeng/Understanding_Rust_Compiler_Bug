{"sha": "78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZTk0ZTQ1NzBmMDljOGNiZTFmOGM2ODAyZGY5YjExMmNhMzdmMDg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-25T00:16:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-25T00:16:32Z"}, "message": "Merge #5044\n\n5044: Tweak visibility r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "395a23d51c043660ec50ee289d695694037af158", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/395a23d51c043660ec50ee289d695694037af158"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe8+zgCRBK7hj4Ov3rIwAAdHIIAHHW/RMUWQgw94qiSoNqwRRD\n1sqL8HxKOTgPVeshDe6M0Ov9cdhFNcb3dATD+07yAtFKnnoizeXT3mEFS2NjnFXC\n8J4yKOeCcUOxxmQxs4hX++HudhHsgcFto+Y64j74L3ycShpxj26VvXFSA2s3Yhp+\nu210DfmoBAymOvCal+iCJjiH3Ca0LVxVcn05T5AcT4Hq+U/1ESPfVJ1L3D8PwJkQ\naeLjNA9O4F+O4zavBK+AEH+CDfNI4EEeGfKd6nAjjoJm0QWI5LpHXHi5YUHyDKrG\nCFF4zGusG2fZQY0eG/JUII1DL9zMQfecUqSVJjTvPmgAl1h8daKcniLbvcMy5TE=\n=q/3u\n-----END PGP SIGNATURE-----\n", "payload": "tree 395a23d51c043660ec50ee289d695694037af158\nparent 104fad65daaa6ab103ba8815244afa8243421594\nparent 10ee6eb7333d1978eac4c70039162f61d6275ba3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593044192 +0000\ncommitter GitHub <noreply@github.com> 1593044192 +0000\n\nMerge #5044\n\n5044: Tweak visibility r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "html_url": "https://github.com/rust-lang/rust/commit/78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "104fad65daaa6ab103ba8815244afa8243421594", "url": "https://api.github.com/repos/rust-lang/rust/commits/104fad65daaa6ab103ba8815244afa8243421594", "html_url": "https://github.com/rust-lang/rust/commit/104fad65daaa6ab103ba8815244afa8243421594"}, {"sha": "10ee6eb7333d1978eac4c70039162f61d6275ba3", "url": "https://api.github.com/repos/rust-lang/rust/commits/10ee6eb7333d1978eac4c70039162f61d6275ba3", "html_url": "https://github.com/rust-lang/rust/commit/10ee6eb7333d1978eac4c70039162f61d6275ba3"}], "stats": {"total": 384, "additions": 177, "deletions": 207}, "files": [{"sha": "e4dd5d92d267bad6bd9798234369d718c393402c", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "patch": "@@ -94,7 +94,7 @@ impl CargoTargetSpec {\n         global_state_snapshot: &GlobalStateSnapshot,\n         file_id: FileId,\n     ) -> Result<Option<CargoTargetSpec>> {\n-        let crate_id = match global_state_snapshot.analysis().crate_for(file_id)?.first() {\n+        let crate_id = match global_state_snapshot.analysis.crate_for(file_id)?.first() {\n             Some(crate_id) => *crate_id,\n             None => return Ok(None),\n         };"}, {"sha": "15b2811037280c0a2162083f7689b7d1d917f2a3", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "patch": "@@ -37,7 +37,7 @@ pub(crate) fn file_position(\n     tdpp: lsp_types::TextDocumentPositionParams,\n ) -> Result<FilePosition> {\n     let file_id = file_id(world, &tdpp.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let line_index = world.analysis.file_line_index(file_id)?;\n     let offset = offset(&*line_index, tdpp.position);\n     Ok(FilePosition { file_id, offset })\n }\n@@ -48,7 +48,7 @@ pub(crate) fn file_range(\n     range: lsp_types::Range,\n ) -> Result<FileRange> {\n     let file_id = file_id(world, &text_document_identifier.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let line_index = world.analysis.file_line_index(file_id)?;\n     let range = text_range(&line_index, range);\n     Ok(FileRange { file_id, range })\n }"}, {"sha": "87f3fe4db8d3c57c0552c861b34e5a8e015d8ff8", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "patch": "@@ -20,11 +20,12 @@ use crate::{\n     diagnostics::{CheckFixes, DiagnosticCollection},\n     from_proto,\n     line_endings::LineEndings,\n+    main_loop::ReqQueue,\n     request_metrics::{LatestRequests, RequestMetrics},\n     to_proto::url_from_abs_path,\n     Result,\n };\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n \n fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) -> Option<Flycheck> {\n     // FIXME: Figure out the multi-workspace situation\n@@ -40,41 +41,56 @@ fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) ->\n     })\n }\n \n+#[derive(Eq, PartialEq)]\n+pub(crate) enum Status {\n+    Loading,\n+    Ready,\n+}\n+\n+impl Default for Status {\n+    fn default() -> Self {\n+        Status::Loading\n+    }\n+}\n+\n /// `GlobalState` is the primary mutable state of the language server\n ///\n /// The most interesting components are `vfs`, which stores a consistent\n /// snapshot of the file systems, and `analysis_host`, which stores our\n /// incremental salsa database.\n-#[derive(Debug)]\n pub(crate) struct GlobalState {\n     pub(crate) config: Config,\n-    pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub(crate) analysis_host: AnalysisHost,\n     pub(crate) loader: Box<dyn vfs::loader::Handle>,\n     pub(crate) task_receiver: Receiver<vfs::loader::Message>,\n     pub(crate) flycheck: Option<Flycheck>,\n     pub(crate) diagnostics: DiagnosticCollection,\n-    pub(crate) proc_macro_client: ProcMacroClient,\n+    pub(crate) mem_docs: FxHashSet<VfsPath>,\n     pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n-    pub(crate) latest_requests: Arc<RwLock<LatestRequests>>,\n+    pub(crate) status: Status,\n+    pub(crate) req_queue: ReqQueue,\n+    latest_requests: Arc<RwLock<LatestRequests>>,\n     source_root_config: SourceRootConfig,\n+    _proc_macro_client: ProcMacroClient,\n+    workspaces: Arc<Vec<ProjectWorkspace>>,\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n pub(crate) struct GlobalStateSnapshot {\n     pub(crate) config: Config,\n-    pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub(crate) analysis: Analysis,\n     pub(crate) check_fixes: CheckFixes,\n     pub(crate) latest_requests: Arc<RwLock<LatestRequests>>,\n     vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n+    workspaces: Arc<Vec<ProjectWorkspace>>,\n }\n \n impl GlobalState {\n     pub(crate) fn new(\n         workspaces: Vec<ProjectWorkspace>,\n         lru_capacity: Option<usize>,\n         config: Config,\n+        req_queue: ReqQueue,\n     ) -> GlobalState {\n         let mut change = AnalysisChange::new();\n \n@@ -133,22 +149,25 @@ impl GlobalState {\n         analysis_host.apply_change(change);\n         let mut res = GlobalState {\n             config,\n-            workspaces: Arc::new(workspaces),\n             analysis_host,\n             loader,\n-            vfs: Arc::new(RwLock::new((vfs, FxHashMap::default()))),\n             task_receiver,\n-            latest_requests: Default::default(),\n             flycheck,\n             diagnostics: Default::default(),\n-            proc_macro_client,\n+            mem_docs: FxHashSet::default(),\n+            vfs: Arc::new(RwLock::new((vfs, FxHashMap::default()))),\n+            status: Status::default(),\n+            req_queue,\n+            latest_requests: Default::default(),\n             source_root_config: project_folders.source_root_config,\n+            _proc_macro_client: proc_macro_client,\n+            workspaces: Arc::new(workspaces),\n         };\n         res.process_changes();\n         res\n     }\n \n-    pub fn update_configuration(&mut self, config: Config) {\n+    pub(crate) fn update_configuration(&mut self, config: Config) {\n         self.analysis_host.update_lru_capacity(config.lru_capacity);\n         if config.check != self.config.check {\n             self.flycheck =\n@@ -158,7 +177,7 @@ impl GlobalState {\n         self.config = config;\n     }\n \n-    pub fn process_changes(&mut self) -> bool {\n+    pub(crate) fn process_changes(&mut self) -> bool {\n         let change = {\n             let mut change = AnalysisChange::new();\n             let (vfs, line_endings_map) = &mut *self.vfs.write();\n@@ -196,7 +215,7 @@ impl GlobalState {\n         true\n     }\n \n-    pub fn snapshot(&self) -> GlobalStateSnapshot {\n+    pub(crate) fn snapshot(&self) -> GlobalStateSnapshot {\n         GlobalStateSnapshot {\n             config: self.config.clone(),\n             workspaces: Arc::clone(&self.workspaces),\n@@ -207,11 +226,11 @@ impl GlobalState {\n         }\n     }\n \n-    pub fn maybe_collect_garbage(&mut self) {\n+    pub(crate) fn maybe_collect_garbage(&mut self) {\n         self.analysis_host.maybe_collect_garbage()\n     }\n \n-    pub fn collect_garbage(&mut self) {\n+    pub(crate) fn collect_garbage(&mut self) {\n         self.analysis_host.collect_garbage()\n     }\n \n@@ -221,10 +240,6 @@ impl GlobalState {\n }\n \n impl GlobalStateSnapshot {\n-    pub(crate) fn analysis(&self) -> &Analysis {\n-        &self.analysis\n-    }\n-\n     pub(crate) fn url_to_file_id(&self, url: &Url) -> Result<FileId> {\n         let path = from_proto::abs_path(url)?;\n         let path = path.into();\n@@ -253,7 +268,7 @@ impl GlobalStateSnapshot {\n         &self,\n         crate_id: CrateId,\n     ) -> Option<(&CargoWorkspace, Target)> {\n-        let file_id = self.analysis().crate_root(crate_id).ok()?;\n+        let file_id = self.analysis.crate_root(crate_id).ok()?;\n         let path = self.vfs.read().0.file_path(file_id);\n         let path = path.as_path()?;\n         self.workspaces.iter().find_map(|ws| match ws {"}, {"sha": "b2ff9a157de2986fbd410530cc1e8687b744d112", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "patch": "@@ -56,9 +56,9 @@ pub(crate) fn handle_syntax_tree(\n ) -> Result<String> {\n     let _p = profile(\"handle_syntax_tree\");\n     let id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis().file_line_index(id)?;\n+    let line_index = snap.analysis.file_line_index(id)?;\n     let text_range = params.range.map(|r| from_proto::text_range(&line_index, r));\n-    let res = snap.analysis().syntax_tree(id, text_range)?;\n+    let res = snap.analysis.syntax_tree(id, text_range)?;\n     Ok(res)\n }\n \n@@ -68,10 +68,10 @@ pub(crate) fn handle_expand_macro(\n ) -> Result<Option<lsp_ext::ExpandedMacro>> {\n     let _p = profile(\"handle_expand_macro\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n     let offset = from_proto::offset(&line_index, params.position);\n \n-    let res = snap.analysis().expand_macro(FilePosition { file_id, offset })?;\n+    let res = snap.analysis.expand_macro(FilePosition { file_id, offset })?;\n     Ok(res.map(|it| lsp_ext::ExpandedMacro { name: it.name, expansion: it.expansion }))\n }\n \n@@ -81,7 +81,7 @@ pub(crate) fn handle_selection_range(\n ) -> Result<Option<Vec<lsp_types::SelectionRange>>> {\n     let _p = profile(\"handle_selection_range\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n     let res: Result<Vec<lsp_types::SelectionRange>> = params\n         .positions\n         .into_iter()\n@@ -93,7 +93,7 @@ pub(crate) fn handle_selection_range(\n                 loop {\n                     ranges.push(range);\n                     let frange = FileRange { file_id, range };\n-                    let next = snap.analysis().extend_selection(frange)?;\n+                    let next = snap.analysis.extend_selection(frange)?;\n                     if next == range {\n                         break;\n                     } else {\n@@ -124,13 +124,13 @@ pub(crate) fn handle_matching_brace(\n ) -> Result<Vec<Position>> {\n     let _p = profile(\"handle_matching_brace\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n     let res = params\n         .positions\n         .into_iter()\n         .map(|position| {\n             let offset = from_proto::offset(&line_index, position);\n-            let offset = match snap.analysis().matching_brace(FilePosition { file_id, offset }) {\n+            let offset = match snap.analysis.matching_brace(FilePosition { file_id, offset }) {\n                 Ok(Some(matching_brace_offset)) => matching_brace_offset,\n                 Err(_) | Ok(None) => offset,\n             };\n@@ -146,12 +146,12 @@ pub(crate) fn handle_join_lines(\n ) -> Result<Vec<lsp_types::TextEdit>> {\n     let _p = profile(\"handle_join_lines\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n     let line_endings = snap.file_line_endings(file_id);\n     let mut res = TextEdit::default();\n     for range in params.ranges {\n         let range = from_proto::text_range(&line_index, range);\n-        let edit = snap.analysis().join_lines(FileRange { file_id, range })?;\n+        let edit = snap.analysis.join_lines(FileRange { file_id, range })?;\n         match res.union(edit) {\n             Ok(()) => (),\n             Err(_edit) => {\n@@ -169,11 +169,11 @@ pub(crate) fn handle_on_enter(\n ) -> Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {\n     let _p = profile(\"handle_on_enter\");\n     let position = from_proto::file_position(&snap, params)?;\n-    let edit = match snap.analysis().on_enter(position)? {\n+    let edit = match snap.analysis.on_enter(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let line_endings = snap.file_line_endings(position.file_id);\n     let edit = to_proto::snippet_text_edit_vec(&line_index, line_endings, true, edit);\n     Ok(Some(edit))\n@@ -186,15 +186,15 @@ pub(crate) fn handle_on_type_formatting(\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile(\"handle_on_type_formatting\");\n     let mut position = from_proto::file_position(&snap, params.text_document_position)?;\n-    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let line_endings = snap.file_line_endings(position.file_id);\n \n     // in `ra_ide`, the `on_type` invariant is that\n     // `text.char_at(position) == typed_char`.\n     position.offset -= TextSize::of('.');\n     let char_typed = params.ch.chars().next().unwrap_or('\\0');\n     assert!({\n-        let text = snap.analysis().file_text(position.file_id)?;\n+        let text = snap.analysis.file_text(position.file_id)?;\n         text[usize::from(position.offset)..].starts_with(char_typed)\n     });\n \n@@ -206,7 +206,7 @@ pub(crate) fn handle_on_type_formatting(\n         return Ok(None);\n     }\n \n-    let edit = snap.analysis().on_char_typed(position, char_typed)?;\n+    let edit = snap.analysis.on_char_typed(position, char_typed)?;\n     let mut edit = match edit {\n         Some(it) => it,\n         None => return Ok(None),\n@@ -225,11 +225,11 @@ pub(crate) fn handle_document_symbol(\n ) -> Result<Option<lsp_types::DocumentSymbolResponse>> {\n     let _p = profile(\"handle_document_symbol\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n \n     let mut parents: Vec<(DocumentSymbol, Option<usize>)> = Vec::new();\n \n-    for symbol in snap.analysis().file_structure(file_id)? {\n+    for symbol in snap.analysis.file_structure(file_id)? {\n         let doc_symbol = DocumentSymbol {\n             name: symbol.label,\n             detail: symbol.detail,\n@@ -317,7 +317,7 @@ pub(crate) fn handle_workspace_symbol(\n \n     fn exec_query(snap: &GlobalStateSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n         let mut res = Vec::new();\n-        for nav in snap.analysis().symbol_search(query)? {\n+        for nav in snap.analysis.symbol_search(query)? {\n             let info = SymbolInformation {\n                 name: nav.name().to_string(),\n                 kind: to_proto::symbol_kind(nav.kind()),\n@@ -337,7 +337,7 @@ pub(crate) fn handle_goto_definition(\n ) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_goto_definition\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let nav_info = match snap.analysis().goto_definition(position)? {\n+    let nav_info = match snap.analysis.goto_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -352,7 +352,7 @@ pub(crate) fn handle_goto_implementation(\n ) -> Result<Option<lsp_types::request::GotoImplementationResponse>> {\n     let _p = profile(\"handle_goto_implementation\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let nav_info = match snap.analysis().goto_implementation(position)? {\n+    let nav_info = match snap.analysis.goto_implementation(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -367,7 +367,7 @@ pub(crate) fn handle_goto_type_definition(\n ) -> Result<Option<lsp_types::request::GotoTypeDefinitionResponse>> {\n     let _p = profile(\"handle_goto_type_definition\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let nav_info = match snap.analysis().goto_type_definition(position)? {\n+    let nav_info = match snap.analysis.goto_type_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -382,7 +382,7 @@ pub(crate) fn handle_parent_module(\n ) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_parent_module\");\n     let position = from_proto::file_position(&snap, params)?;\n-    let navs = snap.analysis().parent_module(position)?;\n+    let navs = snap.analysis.parent_module(position)?;\n     let res = to_proto::goto_definition_response(&snap, None, navs)?;\n     Ok(Some(res))\n }\n@@ -393,11 +393,11 @@ pub(crate) fn handle_runnables(\n ) -> Result<Vec<lsp_ext::Runnable>> {\n     let _p = profile(\"handle_runnables\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n     let offset = params.position.map(|it| from_proto::offset(&line_index, it));\n     let mut res = Vec::new();\n     let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n-    for runnable in snap.analysis().runnables(file_id)? {\n+    for runnable in snap.analysis.runnables(file_id)? {\n         if let Some(offset) = offset {\n             if !runnable.nav.full_range().contains_inclusive(offset) {\n                 continue;\n@@ -456,7 +456,7 @@ pub(crate) fn handle_completion(\n         let mut res = false;\n         if let Some(ctx) = params.context {\n             if ctx.trigger_character.unwrap_or_default() == \":\" {\n-                let source_file = snap.analysis().parse(position.file_id)?;\n+                let source_file = snap.analysis.parse(position.file_id)?;\n                 let syntax = source_file.syntax();\n                 let text = syntax.text();\n                 if let Some(next_char) = text.char_at(position.offset) {\n@@ -474,11 +474,11 @@ pub(crate) fn handle_completion(\n         return Ok(None);\n     }\n \n-    let items = match snap.analysis().completions(&snap.config.completion, position)? {\n+    let items = match snap.analysis.completions(&snap.config.completion, position)? {\n         None => return Ok(None),\n         Some(items) => items,\n     };\n-    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let line_endings = snap.file_line_endings(position.file_id);\n     let items: Vec<CompletionItem> = items\n         .into_iter()\n@@ -494,9 +494,9 @@ pub(crate) fn handle_folding_range(\n ) -> Result<Option<Vec<FoldingRange>>> {\n     let _p = profile(\"handle_folding_range\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let folds = snap.analysis().folding_ranges(file_id)?;\n-    let text = snap.analysis().file_text(file_id)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let folds = snap.analysis.folding_ranges(file_id)?;\n+    let text = snap.analysis.file_text(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n     let line_folding_only = snap.config.client_caps.line_folding_only;\n     let res = folds\n         .into_iter()\n@@ -511,7 +511,7 @@ pub(crate) fn handle_signature_help(\n ) -> Result<Option<lsp_types::SignatureHelp>> {\n     let _p = profile(\"handle_signature_help\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let call_info = match snap.analysis().call_info(position)? {\n+    let call_info = match snap.analysis.call_info(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -535,7 +535,7 @@ pub(crate) fn handle_hover(\n ) -> Result<Option<lsp_ext::Hover>> {\n     let _p = profile(\"handle_hover\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let info = match snap.analysis().hover(position)? {\n+    let info = match snap.analysis.hover(position)? {\n         None => return Ok(None),\n         Some(info) => info,\n     };\n@@ -562,13 +562,13 @@ pub(crate) fn handle_prepare_rename(\n     let _p = profile(\"handle_prepare_rename\");\n     let position = from_proto::file_position(&snap, params)?;\n \n-    let optional_change = snap.analysis().rename(position, \"dummy\")?;\n+    let optional_change = snap.analysis.rename(position, \"dummy\")?;\n     let range = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.range,\n     };\n \n-    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, range);\n     Ok(Some(PrepareRenameResponse::Range(range)))\n }\n@@ -588,7 +588,7 @@ pub(crate) fn handle_rename(\n         .into());\n     }\n \n-    let optional_change = snap.analysis().rename(position, &*params.new_name)?;\n+    let optional_change = snap.analysis.rename(position, &*params.new_name)?;\n     let source_change = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.info,\n@@ -604,7 +604,7 @@ pub(crate) fn handle_references(\n     let _p = profile(\"handle_references\");\n     let position = from_proto::file_position(&snap, params.text_document_position)?;\n \n-    let refs = match snap.analysis().find_all_refs(position, None)? {\n+    let refs = match snap.analysis.find_all_refs(position, None)? {\n         None => return Ok(None),\n         Some(refs) => refs,\n     };\n@@ -630,10 +630,10 @@ pub(crate) fn handle_formatting(\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile(\"handle_formatting\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let file = snap.analysis().file_text(file_id)?;\n-    let crate_ids = snap.analysis().crate_for(file_id)?;\n+    let file = snap.analysis.file_text(file_id)?;\n+    let crate_ids = snap.analysis.crate_for(file_id)?;\n \n-    let file_line_index = snap.analysis().file_line_index(file_id)?;\n+    let file_line_index = snap.analysis.file_line_index(file_id)?;\n     let end_position = to_proto::position(&file_line_index, TextSize::of(file.as_str()));\n \n     let mut rustfmt = match &snap.config.rustfmt {\n@@ -642,7 +642,7 @@ pub(crate) fn handle_formatting(\n             cmd.args(extra_args);\n             if let Some(&crate_id) = crate_ids.first() {\n                 // Assume all crates are in the same edition\n-                let edition = snap.analysis().crate_edition(crate_id)?;\n+                let edition = snap.analysis.crate_edition(crate_id)?;\n                 cmd.arg(\"--edition\");\n                 cmd.arg(edition.to_string());\n             }\n@@ -706,9 +706,9 @@ fn handle_fixes(\n     res: &mut Vec<lsp_ext::CodeAction>,\n ) -> Result<()> {\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.range);\n-    let diagnostics = snap.analysis().diagnostics(file_id)?;\n+    let diagnostics = snap.analysis.diagnostics(file_id)?;\n \n     let fixes_from_diagnostics = diagnostics\n         .into_iter()\n@@ -752,7 +752,7 @@ pub(crate) fn handle_code_action(\n     }\n \n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.range);\n     let frange = FileRange { file_id, range };\n     let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n@@ -761,12 +761,12 @@ pub(crate) fn handle_code_action(\n \n     if snap.config.client_caps.resolve_code_action {\n         for (index, assist) in\n-            snap.analysis().unresolved_assists(&snap.config.assist, frange)?.into_iter().enumerate()\n+            snap.analysis.unresolved_assists(&snap.config.assist, frange)?.into_iter().enumerate()\n         {\n             res.push(to_proto::unresolved_code_action(&snap, assist, index)?);\n         }\n     } else {\n-        for assist in snap.analysis().resolved_assists(&snap.config.assist, frange)?.into_iter() {\n+        for assist in snap.analysis.resolved_assists(&snap.config.assist, frange)?.into_iter() {\n             res.push(to_proto::resolved_code_action(&snap, assist)?);\n         }\n     }\n@@ -780,11 +780,11 @@ pub(crate) fn handle_resolve_code_action(\n ) -> Result<Option<lsp_ext::SnippetWorkspaceEdit>> {\n     let _p = profile(\"handle_resolve_code_action\");\n     let file_id = from_proto::file_id(&snap, &params.code_action_params.text_document.uri)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.code_action_params.range);\n     let frange = FileRange { file_id, range };\n \n-    let assists = snap.analysis().resolved_assists(&snap.config.assist, frange)?;\n+    let assists = snap.analysis.resolved_assists(&snap.config.assist, frange)?;\n     let (id_string, index) = split_delim(&params.id, ':').unwrap();\n     let index = index.parse::<usize>().unwrap();\n     let assist = &assists[index];\n@@ -805,12 +805,12 @@ pub(crate) fn handle_code_lens(\n     }\n \n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n     let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n \n     if snap.config.lens.runnable() {\n         // Gather runnables\n-        for runnable in snap.analysis().runnables(file_id)? {\n+        for runnable in snap.analysis.runnables(file_id)? {\n             if should_skip_target(&runnable, cargo_spec.as_ref()) {\n                 continue;\n             }\n@@ -838,7 +838,7 @@ pub(crate) fn handle_code_lens(\n     if snap.config.lens.impementations {\n         // Handle impls\n         lenses.extend(\n-            snap.analysis()\n+            snap.analysis\n                 .file_structure(file_id)?\n                 .into_iter()\n                 .filter(|it| match it.kind {\n@@ -916,10 +916,10 @@ pub(crate) fn handle_document_highlight(\n ) -> Result<Option<Vec<DocumentHighlight>>> {\n     let _p = profile(\"handle_document_highlight\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_index = snap.analysis.file_line_index(position.file_id)?;\n \n     let refs = match snap\n-        .analysis()\n+        .analysis\n         .find_all_refs(position, Some(SearchScope::single_file(position.file_id)))?\n     {\n         None => return Ok(None),\n@@ -943,7 +943,7 @@ pub(crate) fn handle_ssr(\n ) -> Result<lsp_types::WorkspaceEdit> {\n     let _p = profile(\"handle_ssr\");\n     let source_change =\n-        snap.analysis().structural_search_replace(&params.query, params.parse_only)??;\n+        snap.analysis.structural_search_replace(&params.query, params.parse_only)??;\n     to_proto::workspace_edit(&snap, source_change)\n }\n \n@@ -952,9 +952,9 @@ pub(crate) fn publish_diagnostics(\n     file_id: FileId,\n ) -> Result<DiagnosticTask> {\n     let _p = profile(\"publish_diagnostics\");\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n     let diagnostics: Vec<Diagnostic> = snap\n-        .analysis()\n+        .analysis\n         .diagnostics(file_id)?\n         .into_iter()\n         .map(|d| Diagnostic {\n@@ -976,9 +976,9 @@ pub(crate) fn handle_inlay_hints(\n ) -> Result<Vec<InlayHint>> {\n     let _p = profile(\"handle_inlay_hints\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let analysis = snap.analysis();\n-    let line_index = analysis.file_line_index(file_id)?;\n-    Ok(analysis\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n+    Ok(snap\n+        .analysis\n         .inlay_hints(file_id, &snap.config.inlay_hints)?\n         .into_iter()\n         .map(|it| to_proto::inlay_int(&line_index, it))\n@@ -992,7 +992,7 @@ pub(crate) fn handle_call_hierarchy_prepare(\n     let _p = profile(\"handle_call_hierarchy_prepare\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n \n-    let nav_info = match snap.analysis().call_hierarchy(position)? {\n+    let nav_info = match snap.analysis.call_hierarchy(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1018,7 +1018,7 @@ pub(crate) fn handle_call_hierarchy_incoming(\n     let frange = from_proto::file_range(&snap, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n-    let call_items = match snap.analysis().incoming_calls(fpos)? {\n+    let call_items = match snap.analysis.incoming_calls(fpos)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1027,7 +1027,7 @@ pub(crate) fn handle_call_hierarchy_incoming(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n-        let line_index = snap.analysis().file_line_index(file_id)?;\n+        let line_index = snap.analysis.file_line_index(file_id)?;\n         let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyIncomingCall {\n             from: item,\n@@ -1053,7 +1053,7 @@ pub(crate) fn handle_call_hierarchy_outgoing(\n     let frange = from_proto::file_range(&snap, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n-    let call_items = match snap.analysis().outgoing_calls(fpos)? {\n+    let call_items = match snap.analysis.outgoing_calls(fpos)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1062,7 +1062,7 @@ pub(crate) fn handle_call_hierarchy_outgoing(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n-        let line_index = snap.analysis().file_line_index(file_id)?;\n+        let line_index = snap.analysis.file_line_index(file_id)?;\n         let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyOutgoingCall {\n             to: item,\n@@ -1084,10 +1084,10 @@ pub(crate) fn handle_semantic_tokens(\n     let _p = profile(\"handle_semantic_tokens\");\n \n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let text = snap.analysis().file_text(file_id)?;\n-    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let text = snap.analysis.file_text(file_id)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n \n-    let highlights = snap.analysis().highlight(file_id)?;\n+    let highlights = snap.analysis.highlight(file_id)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n@@ -1099,10 +1099,10 @@ pub(crate) fn handle_semantic_tokens_range(\n     let _p = profile(\"handle_semantic_tokens_range\");\n \n     let frange = from_proto::file_range(&snap, params.text_document, params.range)?;\n-    let text = snap.analysis().file_text(frange.file_id)?;\n-    let line_index = snap.analysis().file_line_index(frange.file_id)?;\n+    let text = snap.analysis.file_text(frange.file_id)?;\n+    let line_index = snap.analysis.file_line_index(frange.file_id)?;\n \n-    let highlights = snap.analysis().highlight_range(frange)?;\n+    let highlights = snap.analysis.highlight_range(frange)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n@@ -1178,9 +1178,9 @@ fn show_impl_command_link(\n     position: &FilePosition,\n ) -> Option<lsp_ext::CommandLinkGroup> {\n     if snap.config.hover.implementations {\n-        if let Some(nav_data) = snap.analysis().goto_implementation(*position).unwrap_or(None) {\n+        if let Some(nav_data) = snap.analysis.goto_implementation(*position).unwrap_or(None) {\n             let uri = to_proto::url(snap, position.file_id);\n-            let line_index = snap.analysis().file_line_index(position.file_id).ok()?;\n+            let line_index = snap.analysis.file_line_index(position.file_id).ok()?;\n             let position = to_proto::position(&line_index, position.offset);\n             let locations: Vec<_> = nav_data\n                 .info"}, {"sha": "d6cd043031a1c6516daea94186c20eb28b08617f", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "patch": "@@ -37,12 +37,32 @@ use serde::de::DeserializeOwned;\n pub type Result<T, E = Box<dyn std::error::Error + Send + Sync>> = std::result::Result<T, E>;\n pub use crate::{\n     caps::server_capabilities,\n-    main_loop::LspError,\n     main_loop::{main_loop, show_message},\n };\n+use std::fmt;\n \n pub fn from_json<T: DeserializeOwned>(what: &'static str, json: serde_json::Value) -> Result<T> {\n     let res = T::deserialize(&json)\n         .map_err(|e| format!(\"Failed to deserialize {}: {}; {}\", what, e, json))?;\n     Ok(res)\n }\n+\n+#[derive(Debug)]\n+struct LspError {\n+    code: i32,\n+    message: String,\n+}\n+\n+impl LspError {\n+    fn new(code: i32, message: String) -> LspError {\n+        LspError { code, message }\n+    }\n+}\n+\n+impl fmt::Display for LspError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Language Server request failed with {}. ({})\", self.code, self.message)\n+    }\n+}\n+\n+impl std::error::Error for LspError {}"}, {"sha": "eb9e7f9130daf2809875c9e8891f413579cd4273", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 43, "deletions": 108, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "patch": "@@ -1,61 +1,34 @@\n //! The main loop of `rust-analyzer` responsible for dispatching LSP\n //! requests/replies and notifications back to the client.\n use std::{\n-    env,\n-    error::Error,\n-    fmt,\n+    env, fmt,\n     ops::Range,\n     panic,\n     sync::Arc,\n     time::{Duration, Instant},\n };\n \n use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n-use lsp_server::{\n-    Connection, ErrorCode, Message, Notification, ReqQueue, Request, RequestId, Response,\n-};\n+use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{request::Request as _, NumberOrString, TextDocumentContentChangeEvent};\n use ra_db::VfsPath;\n use ra_flycheck::CheckTask;\n use ra_ide::{Canceled, FileId, LineIndex};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n-use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n use crate::{\n     config::{Config, FilesWatcher, LinkedProject},\n     diagnostics::DiagnosticTask,\n     from_proto,\n-    global_state::{file_id_to_url, GlobalState, GlobalStateSnapshot},\n+    global_state::{file_id_to_url, GlobalState, GlobalStateSnapshot, Status},\n     handlers, lsp_ext,\n     request_metrics::RequestMetrics,\n-    Result,\n+    LspError, Result,\n };\n \n-#[derive(Debug)]\n-pub struct LspError {\n-    pub code: i32,\n-    pub message: String,\n-}\n-\n-impl LspError {\n-    pub const UNKNOWN_FILE: i32 = -32900;\n-\n-    pub fn new(code: i32, message: String) -> LspError {\n-        LspError { code, message }\n-    }\n-}\n-\n-impl fmt::Display for LspError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Language Server request failed with {}. ({})\", self.code, self.message)\n-    }\n-}\n-\n-impl Error for LspError {}\n-\n pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n     log::info!(\"initial config: {:#?}\", config);\n \n@@ -78,7 +51,6 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n         SetThreadPriority(thread, thread_priority_above_normal);\n     }\n \n-    let mut loop_state = LoopState::default();\n     let mut global_state = {\n         let workspaces = {\n             if config.linked_projects.is_empty() && config.notifications.cargo_toml_not_found {\n@@ -116,6 +88,8 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                 .collect::<Vec<_>>()\n         };\n \n+        let mut req_queue = ReqQueue::default();\n+\n         if let FilesWatcher::Client = config.files.watcher {\n             let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n                 watchers: workspaces\n@@ -132,15 +106,15 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                 register_options: Some(serde_json::to_value(registration_options).unwrap()),\n             };\n             let params = lsp_types::RegistrationParams { registrations: vec![registration] };\n-            let request = loop_state.req_queue.outgoing.register(\n+            let request = req_queue.outgoing.register(\n                 lsp_types::request::RegisterCapability::METHOD.to_string(),\n                 params,\n                 DO_NOTHING,\n             );\n             connection.sender.send(request.into()).unwrap();\n         }\n \n-        GlobalState::new(workspaces, config.lru_capacity, config)\n+        GlobalState::new(workspaces, config.lru_capacity, config, req_queue)\n     };\n \n     let pool = ThreadPool::default();\n@@ -172,15 +146,13 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                 };\n             }\n             assert!(!global_state.vfs.read().0.has_changes());\n-            loop_turn(&pool, &task_sender, &connection, &mut global_state, &mut loop_state, event)?;\n+            loop_turn(&pool, &task_sender, &connection, &mut global_state, event)?;\n             assert!(!global_state.vfs.read().0.has_changes());\n         }\n     }\n     global_state.analysis_host.request_cancellation();\n     log::info!(\"waiting for tasks to finish...\");\n-    task_receiver.into_iter().for_each(|task| {\n-        on_task(task, &connection.sender, &mut loop_state.req_queue.incoming, &mut global_state)\n-    });\n+    task_receiver.into_iter().for_each(|task| on_task(task, &connection.sender, &mut global_state));\n     log::info!(\"...tasks have finished\");\n     log::info!(\"joining threadpool...\");\n     pool.join();\n@@ -244,35 +216,15 @@ impl fmt::Debug for Event {\n     }\n }\n \n-type ReqHandler = fn(&mut GlobalState, Response);\n+pub(crate) type ReqHandler = fn(&mut GlobalState, Response);\n+pub(crate) type ReqQueue = lsp_server::ReqQueue<(&'static str, Instant), ReqHandler>;\n const DO_NOTHING: ReqHandler = |_, _| ();\n-type Incoming = lsp_server::Incoming<(&'static str, Instant)>;\n-\n-#[derive(Default)]\n-struct LoopState {\n-    req_queue: ReqQueue<(&'static str, Instant), ReqHandler>,\n-    mem_docs: FxHashSet<VfsPath>,\n-    status: Status,\n-}\n-\n-#[derive(Eq, PartialEq)]\n-enum Status {\n-    Loading,\n-    Ready,\n-}\n-\n-impl Default for Status {\n-    fn default() -> Self {\n-        Status::Loading\n-    }\n-}\n \n fn loop_turn(\n     pool: &ThreadPool,\n     task_sender: &Sender<Task>,\n     connection: &Connection,\n     global_state: &mut GlobalState,\n-    loop_state: &mut LoopState,\n     event: Event,\n ) -> Result<()> {\n     let loop_start = Instant::now();\n@@ -288,43 +240,37 @@ fn loop_turn(\n     let mut became_ready = false;\n     match event {\n         Event::Task(task) => {\n-            on_task(task, &connection.sender, &mut loop_state.req_queue.incoming, global_state);\n+            on_task(task, &connection.sender, global_state);\n             global_state.maybe_collect_garbage();\n         }\n         Event::Vfs(task) => match task {\n             vfs::loader::Message::Loaded { files } => {\n                 let vfs = &mut global_state.vfs.write().0;\n                 for (path, contents) in files {\n                     let path = VfsPath::from(path);\n-                    if !loop_state.mem_docs.contains(&path) {\n+                    if !global_state.mem_docs.contains(&path) {\n                         vfs.set_file_contents(path, contents)\n                     }\n                 }\n             }\n             vfs::loader::Message::Progress { n_total, n_done } => {\n                 if n_done == n_total {\n-                    loop_state.status = Status::Ready;\n+                    global_state.status = Status::Ready;\n                     became_ready = true;\n                 }\n-                report_progress(loop_state, &connection.sender, n_done, n_total, \"roots scanned\")\n+                report_progress(global_state, &connection.sender, n_done, n_total, \"roots scanned\")\n             }\n         },\n         Event::CheckWatcher(task) => on_check_task(task, global_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n-            Message::Request(req) => on_request(\n-                global_state,\n-                &mut loop_state.req_queue.incoming,\n-                pool,\n-                task_sender,\n-                &connection.sender,\n-                loop_start,\n-                req,\n-            )?,\n+            Message::Request(req) => {\n+                on_request(global_state, pool, task_sender, &connection.sender, loop_start, req)?\n+            }\n             Message::Notification(not) => {\n-                on_notification(&connection.sender, global_state, loop_state, not)?;\n+                on_notification(&connection.sender, global_state, not)?;\n             }\n             Message::Response(resp) => {\n-                let handler = loop_state.req_queue.outgoing.complete(resp.id.clone());\n+                let handler = global_state.req_queue.outgoing.complete(resp.id.clone());\n                 handler(global_state, resp)\n             }\n         },\n@@ -338,8 +284,8 @@ fn loop_turn(\n         }\n     }\n \n-    if loop_state.status == Status::Ready && (state_changed || became_ready) {\n-        let subscriptions = loop_state\n+    if global_state.status == Status::Ready && (state_changed || became_ready) {\n+        let subscriptions = global_state\n             .mem_docs\n             .iter()\n             .map(|path| global_state.vfs.read().0.file_id(&path).unwrap())\n@@ -354,7 +300,7 @@ fn loop_turn(\n         pool.execute({\n             let subs = subscriptions;\n             let snap = global_state.snapshot();\n-            move || snap.analysis().prime_caches(subs).unwrap_or_else(|_: Canceled| ())\n+            move || snap.analysis.prime_caches(subs).unwrap_or_else(|_: Canceled| ())\n         });\n     }\n \n@@ -373,18 +319,15 @@ fn loop_turn(\n     Ok(())\n }\n \n-fn on_task(\n-    task: Task,\n-    msg_sender: &Sender<Message>,\n-    incoming_requests: &mut Incoming,\n-    state: &mut GlobalState,\n-) {\n+fn on_task(task: Task, msg_sender: &Sender<Message>, global_state: &mut GlobalState) {\n     match task {\n         Task::Respond(response) => {\n-            if let Some((method, start)) = incoming_requests.complete(response.id.clone()) {\n+            if let Some((method, start)) =\n+                global_state.req_queue.incoming.complete(response.id.clone())\n+            {\n                 let duration = start.elapsed();\n                 log::info!(\"handled req#{} in {:?}\", response.id, duration);\n-                state.complete_request(RequestMetrics {\n+                global_state.complete_request(RequestMetrics {\n                     id: response.id.clone(),\n                     method: method.to_string(),\n                     duration,\n@@ -395,13 +338,12 @@ fn on_task(\n         Task::Notify(n) => {\n             msg_sender.send(n.into()).unwrap();\n         }\n-        Task::Diagnostic(task) => on_diagnostic_task(task, msg_sender, state),\n+        Task::Diagnostic(task) => on_diagnostic_task(task, msg_sender, global_state),\n     }\n }\n \n fn on_request(\n     global_state: &mut GlobalState,\n-    incoming_requests: &mut Incoming,\n     pool: &ThreadPool,\n     task_sender: &Sender<Task>,\n     msg_sender: &Sender<Message>,\n@@ -414,7 +356,6 @@ fn on_request(\n         global_state,\n         task_sender,\n         msg_sender,\n-        incoming_requests,\n         request_received,\n     };\n     pool_dispatcher\n@@ -469,7 +410,6 @@ fn on_request(\n fn on_notification(\n     msg_sender: &Sender<Message>,\n     global_state: &mut GlobalState,\n-    loop_state: &mut LoopState,\n     not: Notification,\n ) -> Result<()> {\n     let not = match notification_cast::<lsp_types::notification::Cancel>(not) {\n@@ -478,7 +418,7 @@ fn on_notification(\n                 NumberOrString::Number(id) => id.into(),\n                 NumberOrString::String(id) => id.into(),\n             };\n-            if let Some(response) = loop_state.req_queue.incoming.cancel(id) {\n+            if let Some(response) = global_state.req_queue.incoming.cancel(id) {\n                 msg_sender.send(response.into()).unwrap()\n             }\n             return Ok(());\n@@ -488,7 +428,7 @@ fn on_notification(\n     let not = match notification_cast::<lsp_types::notification::DidOpenTextDocument>(not) {\n         Ok(params) => {\n             if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                if !loop_state.mem_docs.insert(path.clone()) {\n+                if !global_state.mem_docs.insert(path.clone()) {\n                     log::error!(\"duplicate DidOpenTextDocument: {}\", path)\n                 }\n                 global_state\n@@ -504,7 +444,7 @@ fn on_notification(\n     let not = match notification_cast::<lsp_types::notification::DidChangeTextDocument>(not) {\n         Ok(params) => {\n             if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                assert!(loop_state.mem_docs.contains(&path));\n+                assert!(global_state.mem_docs.contains(&path));\n                 let vfs = &mut global_state.vfs.write().0;\n                 let file_id = vfs.file_id(&path).unwrap();\n                 let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n@@ -518,7 +458,7 @@ fn on_notification(\n     let not = match notification_cast::<lsp_types::notification::DidCloseTextDocument>(not) {\n         Ok(params) => {\n             if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                if !loop_state.mem_docs.remove(&path) {\n+                if !global_state.mem_docs.remove(&path) {\n                     log::error!(\"orphan DidCloseTextDocument: {}\", path)\n                 }\n                 if let Some(path) = path.as_path() {\n@@ -549,7 +489,7 @@ fn on_notification(\n         Ok(_) => {\n             // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n             // this notification's parameters should be ignored and the actual config queried separately.\n-            let request = loop_state.req_queue.outgoing.register(\n+            let request = global_state.req_queue.outgoing.register(\n                 lsp_types::request::WorkspaceConfiguration::METHOD.to_string(),\n                 lsp_types::ConfigurationParams {\n                     items: vec![lsp_types::ConfigurationItem {\n@@ -732,7 +672,7 @@ fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state:\n }\n \n fn report_progress(\n-    loop_state: &mut LoopState,\n+    global_state: &mut GlobalState,\n     sender: &Sender<Message>,\n     done: usize,\n     total: usize,\n@@ -742,7 +682,7 @@ fn report_progress(\n     let message = Some(format!(\"{}/{} {}\", done, total, message));\n     let percentage = Some(100.0 * done as f64 / total.max(1) as f64);\n     let work_done_progress = if done == 0 {\n-        let work_done_progress_create = loop_state.req_queue.outgoing.register(\n+        let work_done_progress_create = global_state.req_queue.outgoing.register(\n             lsp_types::request::WorkDoneProgressCreate::METHOD.to_string(),\n             lsp_types::WorkDoneProgressCreateParams { token: token.clone() },\n             DO_NOTHING,\n@@ -777,7 +717,6 @@ struct PoolDispatcher<'a> {\n     req: Option<Request>,\n     pool: &'a ThreadPool,\n     global_state: &'a mut GlobalState,\n-    incoming_requests: &'a mut Incoming,\n     msg_sender: &'a Sender<Message>,\n     task_sender: &'a Sender<Task>,\n     request_received: Instant,\n@@ -806,7 +745,7 @@ impl<'a> PoolDispatcher<'a> {\n             result_to_task::<R>(id, result)\n         })\n         .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n-        on_task(task, self.msg_sender, self.incoming_requests, self.global_state);\n+        on_task(task, self.msg_sender, self.global_state);\n         Ok(self)\n     }\n \n@@ -853,7 +792,10 @@ impl<'a> PoolDispatcher<'a> {\n                 return None;\n             }\n         };\n-        self.incoming_requests.register(id.clone(), (R::METHOD, self.request_received));\n+        self.global_state\n+            .req_queue\n+            .incoming\n+            .register(id.clone(), (R::METHOD, self.request_received));\n         Some((id, params))\n     }\n \n@@ -882,14 +824,7 @@ where\n     let response = match result {\n         Ok(resp) => Response::new_ok(id, &resp),\n         Err(e) => match e.downcast::<LspError>() {\n-            Ok(lsp_error) => {\n-                if lsp_error.code == LspError::UNKNOWN_FILE {\n-                    // Work-around for https://github.com/rust-analyzer/rust-analyzer/issues/1521\n-                    Response::new_ok(id, ())\n-                } else {\n-                    Response::new_err(id, lsp_error.code, lsp_error.message)\n-                }\n-            }\n+            Ok(lsp_error) => Response::new_err(id, lsp_error.code, lsp_error.message),\n             Err(e) => {\n                 if is_canceled(&e) {\n                     Response::new_err("}, {"sha": "f6cb8e4bb44bbb1ce6e7cb298ccad85de604e900", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "patch": "@@ -440,7 +440,7 @@ pub(crate) fn location(\n     frange: FileRange,\n ) -> Result<lsp_types::Location> {\n     let url = url(snap, frange.file_id);\n-    let line_index = snap.analysis().file_line_index(frange.file_id)?;\n+    let line_index = snap.analysis.file_line_index(frange.file_id)?;\n     let range = range(&line_index, frange.range);\n     let loc = lsp_types::Location::new(url, range);\n     Ok(loc)\n@@ -453,7 +453,7 @@ pub(crate) fn location_link(\n ) -> Result<lsp_types::LocationLink> {\n     let origin_selection_range = match src {\n         Some(src) => {\n-            let line_index = snap.analysis().file_line_index(src.file_id)?;\n+            let line_index = snap.analysis.file_line_index(src.file_id)?;\n             let range = range(&line_index, src.range);\n             Some(range)\n         }\n@@ -473,7 +473,7 @@ fn location_info(\n     snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n ) -> Result<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n-    let line_index = snap.analysis().file_line_index(target.file_id())?;\n+    let line_index = snap.analysis.file_line_index(target.file_id())?;\n \n     let target_uri = url(snap, target.file_id());\n     let target_range = range(&line_index, target.full_range());\n@@ -516,7 +516,7 @@ pub(crate) fn snippet_text_document_edit(\n     source_file_edit: SourceFileEdit,\n ) -> Result<lsp_ext::SnippetTextDocumentEdit> {\n     let text_document = versioned_text_document_identifier(snap, source_file_edit.file_id, None);\n-    let line_index = snap.analysis().file_line_index(source_file_edit.file_id)?;\n+    let line_index = snap.analysis.file_line_index(source_file_edit.file_id)?;\n     let line_endings = snap.file_line_endings(source_file_edit.file_id);\n     let edits = source_file_edit\n         .edit"}]}