{"sha": "34d7f05292911d5582ede20fd871f600447ad59d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZDdmMDUyOTI5MTFkNTU4MmVkZTIwZmQ4NzFmNjAwNDQ3YWQ1OWQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-11T14:15:54Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-11T20:00:11Z"}, "message": "Major clean-up of std::io\n\nUse ifaces instead of objs, stop wrapping everything in two (or three)\nlayers of no-value-added indirection, and remove some of the more\npointless/outdated idioms from the code.", "tree": {"sha": "f066647b8b427ba8789eeed70867013040227830", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f066647b8b427ba8789eeed70867013040227830"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34d7f05292911d5582ede20fd871f600447ad59d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34d7f05292911d5582ede20fd871f600447ad59d", "html_url": "https://github.com/rust-lang/rust/commit/34d7f05292911d5582ede20fd871f600447ad59d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34d7f05292911d5582ede20fd871f600447ad59d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "807592e99f6da30b44d75db459f5e4ab6a8958e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/807592e99f6da30b44d75db459f5e4ab6a8958e5", "html_url": "https://github.com/rust-lang/rust/commit/807592e99f6da30b44d75db459f5e4ab6a8958e5"}], "stats": {"total": 727, "additions": 310, "deletions": 417}, "files": [{"sha": "c33aaa000cf8c2b06190ed12aa6eca48609afbd8", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -10,6 +10,7 @@ import rustc::util::filesearch::get_cargo_root;\n import std::fs;\n import std::generic_os;\n import std::io;\n+import io::writer_util;\n import std::json;\n import option;\n import option::{none, some};"}, {"sha": "f462002adb6171cc70ca36fdc8ecd272f8315bd2", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,5 +1,4 @@\n \n-\n // -*- rust -*-\n import metadata::{creader, cstore};\n import syntax::parse::{parser};\n@@ -13,6 +12,7 @@ import back::link;\n import core::{option, str, int, result};\n import result::{ok, err};\n import std::{fs, io, getopts};\n+import io::reader_util;\n import option::{some, none};\n import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n import back::{x86, x86_64};\n@@ -84,7 +84,7 @@ fn parse_input(sess: session::session, cfg: ast::crate_cfg, input: str) ->\n \n fn parse_input_src(sess: session::session, cfg: ast::crate_cfg, infile: str)\n    -> {crate: @ast::crate, src: str} {\n-    let srcbytes = if infile != \"-\" {\n+    let src_stream = if infile != \"-\" {\n         alt io::file_reader(infile) {\n           result::ok(reader) { reader }\n           result::err(e) {\n@@ -93,7 +93,8 @@ fn parse_input_src(sess: session::session, cfg: ast::crate_cfg, infile: str)\n         }\n     } else {\n         io::stdin()\n-    }.read_whole_stream();\n+    };\n+    let srcbytes = src_stream.read_whole_stream();\n     let src = str::unsafe_from_bytes(srcbytes);\n     let crate =\n         parser::parse_crate_from_source_str(infile, src, cfg,"}, {"sha": "8bfe9dfca89a5b96267fce671d117e6e799b79fd", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -5,6 +5,7 @@ use rustc;\n import core::{option, str, vec, result};\n import result::{ok, err};\n import std::{io, getopts};\n+import io::writer_util;\n import option::{some, none};\n import getopts::{opt_present};\n import rustc::driver::driver::*;"}, {"sha": "8c6204d11051f7f75a2a83e71858a71673cc1deb", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -7,8 +7,8 @@ import front::attr;\n import syntax::visit;\n import syntax::codemap::span;\n import util::{filesearch};\n-import core::{either, vec, str, option};\n import std::{io, fs};\n+import io::writer_util;\n import option::{none, some};\n import std::map::{hashmap, new_int_hash};\n import syntax::print::pprust;"}, {"sha": "b1da9f840a893bf3162503cda74585b69862d1aa", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,6 +1,7 @@\n // Decoding metadata from a single crate's metadata\n \n import std::{ebml, io};\n+import io::writer_util;\n import syntax::{ast, ast_util};\n import front::attr;\n import middle::ty;"}, {"sha": "e7d5c47643f460ea579c7666c6f87444b68622e6", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,7 +1,7 @@\n // Metadata encoding\n \n-import core::{vec, str, uint};\n import std::{io, ebml, map};\n+import io::writer_util;\n import syntax::ast::*;\n import syntax::ast_util;\n import syntax::ast_util::local_def;\n@@ -191,7 +191,7 @@ fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n     for param in params {\n         ebml::start_tag(ebml_w, tag_items_data_item_ty_param_bounds);\n         let bs = ecx.ccx.tcx.ty_param_bounds.get(param.id);\n-        tyencode::enc_bounds(io::new_writer(ebml_w.writer), ty_str_ctxt, bs);\n+        tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, bs);\n         ebml::end_tag(ebml_w);\n     }\n }\n@@ -207,7 +207,7 @@ fn write_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n         @{ds: def_to_str,\n           tcx: ecx.ccx.tcx,\n           abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n-    tyencode::enc_ty(io::new_writer(ebml_w.writer), ty_str_ctxt, typ);\n+    tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n@@ -522,7 +522,7 @@ fn create_index<T: copy>(index: [entry<T>], hash_fn: fn(T) -> uint) ->\n \n fn encode_index<T>(ebml_w: ebml::writer, buckets: [@[entry<T>]],\n                    write_fn: fn(io::writer, T)) {\n-    let writer = io::new_writer(ebml_w.writer);\n+    let writer = ebml_w.writer;\n     ebml::start_tag(ebml_w, tag_index);\n     let bucket_locs: [uint] = [];\n     ebml::start_tag(ebml_w, tag_index_buckets);\n@@ -702,8 +702,8 @@ fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> str {\n     let abbrevs = ty::new_ty_hash();\n     let ecx = @{ccx: cx, type_abbrevs: abbrevs};\n \n-    let string_w = io::string_writer();\n-    let buf_w = string_w.get_writer().get_buf_writer();\n+    let buf = io::mk_mem_buffer();\n+    let buf_w = io::mem_buffer_writer(buf);\n     let ebml_w = ebml::create_writer(buf_w);\n \n     encode_hash(ebml_w, cx.link_meta.extras_hash);\n@@ -714,32 +714,31 @@ fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> str {\n     encode_crate_deps(ebml_w, cx.sess.get_cstore());\n \n     // Encode and index the paths.\n-\n     ebml::start_tag(ebml_w, tag_paths);\n     let paths_index = encode_item_paths(ebml_w, ecx, crate);\n     let paths_buckets = create_index(paths_index, hash_path);\n     encode_index(ebml_w, paths_buckets, write_str);\n     ebml::end_tag(ebml_w);\n-    // Encode and index the items.\n \n+    // Encode and index the items.\n     ebml::start_tag(ebml_w, tag_items);\n     let items_index = encode_info_for_items(ecx, ebml_w, crate.node.module);\n     let items_buckets = create_index(items_index, hash_node_id);\n     encode_index(ebml_w, items_buckets, write_int);\n     ebml::end_tag(ebml_w);\n+\n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n-\n     buf_w.write([0u8, 0u8, 0u8, 0u8]);\n-    ret string_w.get_str();\n+    io::mem_buffer_str(buf)\n }\n \n // Get the encoded string for a type\n fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> str {\n     let cx = @{ds: def_to_str, tcx: tcx, abbrevs: tyencode::ac_no_abbrevs};\n-    let sw = io::string_writer();\n-    tyencode::enc_ty(sw.get_writer(), cx, t);\n-    ret sw.get_str();\n+    let buf = io::mk_mem_buffer();\n+    tyencode::enc_ty(io::mem_buffer_writer(buf), cx, t);\n+    ret io::mem_buffer_str(buf);\n }\n \n "}, {"sha": "83b69f0cad1a32303aa7deb2a50ac70bf7fef055", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,7 +1,7 @@\n // Type encoding\n \n-import core::{int, uint};\n import std::io;\n+import io::writer_util;\n import std::map::hashmap;\n import option::{some, none};\n import syntax::ast::*;\n@@ -37,25 +37,24 @@ fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n     alt cx.abbrevs {\n       ac_no_abbrevs. {\n-        let result_str: @str;\n-        alt cx.tcx.short_names_cache.find(t) {\n-          some(s) { result_str = s; }\n+        let result_str = alt cx.tcx.short_names_cache.find(t) {\n+          some(s) { *s }\n           none. {\n-            let sw = io::string_writer();\n-            enc_sty(sw.get_writer(), cx, ty::struct(cx.tcx, t));\n-            result_str = @sw.get_str();\n-            cx.tcx.short_names_cache.insert(t, result_str);\n+            let buf = io::mk_mem_buffer();\n+            enc_sty(io::mem_buffer_writer(buf), cx, ty::struct(cx.tcx, t));\n+            cx.tcx.short_names_cache.insert(t, @io::mem_buffer_str(buf));\n+            io::mem_buffer_str(buf)\n           }\n-        }\n-        w.write_str(*result_str);\n+        };\n+        w.write_str(result_str);\n       }\n       ac_use_abbrevs(abbrevs) {\n         alt abbrevs.find(t) {\n           some(a) { w.write_str(*a.s); ret; }\n           none. {\n-            let pos = w.get_buf_writer().tell();\n+            let pos = w.tell();\n             enc_sty(w, cx, ty::struct(cx.tcx, t));\n-            let end = w.get_buf_writer().tell();\n+            let end = w.tell();\n             let len = end - pos;\n             fn estimate_sz(u: uint) -> uint {\n                 let n = u;"}, {"sha": "7d7df57863c7ac08e2ad3fcddfb73b2fd94cc074", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,5 +1,6 @@\n import core::{vec, uint, str, option, result};\n import std::{term, io};\n+import io::writer_util;\n import option::{some, none};\n \n type filename = str;\n@@ -126,11 +127,11 @@ fn print_diagnostic(topic: str, t: diagnostictype, msg: str) {\n         io::stdout().write_str(#fmt[\"%s \", topic]);\n     }\n     if term::color_supported() {\n-        term::fg(io::stdout().get_buf_writer(), diagnosticcolor(t));\n+        term::fg(io::stdout(), diagnosticcolor(t));\n     }\n     io::stdout().write_str(#fmt[\"%s:\", diagnosticstr(t)]);\n     if term::color_supported() {\n-        term::reset(io::stdout().get_buf_writer());\n+        term::reset(io::stdout());\n     }\n     io::stdout().write_str(#fmt[\" %s\\n\", msg]);\n }"}, {"sha": "47a639b7ed0b88c35fd7bbec317baeca8636895a", "filename": "src/comp/syntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,6 +1,6 @@\n-import option;\n import base::*;\n import syntax::ast;\n+import std::io::writer_util;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: @ast::expr,\n                      _body: option::t<str>) -> @ast::expr {"}, {"sha": "2fe28f793bfd4dc265ed8d791967ac3ca81dcaf3", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,6 +1,7 @@\n \n import core::{vec, str, option, either};\n import std::io;\n+import io::reader_util;\n import option::{some, none};\n import util::interner;\n import util::interner::intern;"}, {"sha": "ac4d92c47b243168d6ca672bbe1ca2a12d9776aa", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,6 +1,7 @@\n \n import core::{vec, str};\n import std::io;\n+import io::writer_util;\n \n /*\n  * This pretty-printer is a direct reimplementation of Philip Karlton's"}, {"sha": "3e0f3503ef1fdbf53c2db764d27c4cc3ebce1676", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -93,25 +93,23 @@ fn path_to_str(&&p: @ast::path) -> str {\n \n fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n               params: [ast::ty_param]) -> str {\n-    let writer = io::string_writer();\n-    let s = rust_printer(writer.get_writer());\n+    let buffer = io::mk_mem_buffer();\n+    let s = rust_printer(io::mem_buffer_writer(buffer));\n     print_fn(s, decl, name, params);\n     eof(s.s);\n-    ret writer.get_str();\n+    io::mem_buffer_str(buffer)\n }\n \n fn block_to_str(blk: ast::blk) -> str {\n-    let writer = io::string_writer();\n-    let s = rust_printer(writer.get_writer());\n+    let buffer = io::mk_mem_buffer();\n+    let s = rust_printer(io::mem_buffer_writer(buffer));\n     // containing cbox, will be closed by print-block at }\n-\n     cbox(s, indent_unit);\n     // head-ibox, will be closed by print-block after {\n-\n     ibox(s, 0u);\n     print_block(s, blk);\n     eof(s.s);\n-    ret writer.get_str();\n+    io::mem_buffer_str(buffer)\n }\n \n fn meta_item_to_str(mi: ast::meta_item) -> str {\n@@ -1597,11 +1595,11 @@ fn escape_str(st: str, to_escape: char) -> str {\n }\n \n fn to_str<T>(t: T, f: fn@(ps, T)) -> str {\n-    let writer = io::string_writer();\n-    let s = rust_printer(writer.get_writer());\n+    let buffer = io::mk_mem_buffer();\n+    let s = rust_printer(io::mem_buffer_writer(buffer));\n     f(s, t);\n     eof(s.s);\n-    ret writer.get_str();\n+    io::mem_buffer_str(buffer)\n }\n \n fn next_comment(s: ps) -> option::t<lexer::cmnt> {"}, {"sha": "e0c4bf6b654c7fb26952cb95990bdf88962bdc5e", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,6 +1,5 @@\n-import option;\n-import str;\n import std::io;\n+import io::reader_util;\n import std::fs;\n \n import common::config;"}, {"sha": "b7ff47c89e7eeb1e44efd62168d81150d2a79cbf", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,6 +1,7 @@\n import option;\n import str;\n import std::io;\n+import io::reader_util;\n import std::fs;\n \n import common::config;"}, {"sha": "14604fbd1d41555b8312453e770cab38edafeb34", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -4,16 +4,12 @@\n // child process. Because of that we have to use a complicated scheme with a\n // dedicated server for spawning processes.\n \n-import core::comm;\n-import core::option;\n-import task;\n import std::generic_os::setenv;\n import std::generic_os::getenv;\n-import vec;\n import std::os;\n import std::run;\n import std::io;\n-import str;\n+import io::writer_util;\n import comm::chan;\n import comm::port;\n import comm::send;\n@@ -75,7 +71,7 @@ fn run(handle: handle, lib_path: str, prog: str, args: [str],\n \n fn writeclose(fd: fd_t, s: option::t<str>) {\n     if option::is_some(s) {\n-        let writer = io::new_writer(io::fd_buf_writer(fd, option::none));\n+        let writer = io::fd_writer(fd, false);\n         writer.write_str(option::get(s));\n     }\n \n@@ -85,7 +81,7 @@ fn writeclose(fd: fd_t, s: option::t<str>) {\n fn readclose(fd: fd_t) -> str {\n     // Copied from run::program_output\n     let file = os::fd_FILE(fd);\n-    let reader = io::new_reader(io::FILE_buf_reader(file, option::none));\n+    let reader = io::FILE_reader(file, false);\n     let buf = \"\";\n     while !reader.eof() {\n         let bytes = reader.read_bytes(4096u);"}, {"sha": "44679602683f3d779a0f357bb64819f5106ed233", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,10 +1,7 @@\n import std::io;\n-import str;\n-import option;\n+import io::writer_util;\n import std::fs;\n import std::os;\n-import vec;\n-import result;\n \n import common::mode_run_pass;\n import common::mode_run_fail;"}, {"sha": "e2943f35fc42baa9a5004483191c8537da98f91f", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -36,5 +36,5 @@ fn path_div() -> str { \";\" }\n \n fn logv(config: config, s: str) {\n     log(debug, s);\n-    if config.verbose { io::stdout().write_line(s); }\n+    if config.verbose { io::println(s); }\n }"}, {"sha": "676f2635093fbee7f90680e58bbaddc93df4ae81", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,4 +1,5 @@\n import std::{fs, io};\n+import io::writer_util;\n \n import rustc::syntax::{ast, ast_util, fold, visit, codemap};\n import rustc::syntax::parse::parser;\n@@ -212,12 +213,12 @@ fn under(n: uint, it: block(uint)) {\n     while i < n { it(i); i += 1u; }\n }\n \n-fn devnull() -> io::writer { std::io::string_writer().get_writer() }\n+fn devnull() -> io::writer { io::mem_buffer_writer(io::mk_mem_buffer()) }\n \n fn as_str(f: fn@(io::writer)) -> str {\n-    let w = std::io::string_writer();\n-    f(w.get_writer());\n-    ret w.get_str();\n+    let buf = io::mk_mem_buffer();\n+    f(io::mem_buffer_writer(buf));\n+    io::mem_buffer_str(buf)\n }\n \n fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,"}, {"sha": "e7b0a2b9ae2d4c13a485e943203bed488e0c5220", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -153,22 +153,21 @@ Function: to_mut\n \n Produces a mutable vector from an immutable vector.\n */\n-fn to_mut<T: copy>(v: [T]) -> [mutable T] {\n-    let vres = [mutable];\n-    for t: T in v { vres += [mutable t]; }\n-    ret vres;\n+fn to_mut<T>(+v: [T]) -> [mutable T] unsafe {\n+    let r = ::unsafe::reinterpret_cast(v);\n+    ::unsafe::leak(v);\n+    r\n }\n \n-// Same comment as from_mut\n /*\n Function: from_mut\n \n Produces an immutable vector from a mutable vector.\n */\n-fn from_mut<T: copy>(v: [mutable T]) -> [T] {\n-    let vres = [];\n-    for t: T in v { vres += [t]; }\n-    ret vres;\n+fn from_mut<T>(+v: [mutable T]) -> [T] unsafe {\n+    let r = ::unsafe::reinterpret_cast(v);\n+    ::unsafe::leak(v);\n+    r\n }\n \n // Accessors"}, {"sha": "88de3ebb7254b29143925ae19afbcd968c1e5a28", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -116,9 +116,9 @@ fn doc_as_uint(d: doc) -> uint {\n \n \n // ebml writing\n-type writer = {writer: io::buf_writer, mutable size_positions: [uint]};\n+type writer = {writer: io::writer, mutable size_positions: [uint]};\n \n-fn write_sized_vint(w: io::buf_writer, n: uint, size: uint) {\n+fn write_sized_vint(w: io::writer, n: uint, size: uint) {\n     let buf: [u8];\n     alt size {\n       1u { buf = [0x80u8 | (n as u8)]; }\n@@ -138,7 +138,7 @@ fn write_sized_vint(w: io::buf_writer, n: uint, size: uint) {\n     w.write(buf);\n }\n \n-fn write_vint(w: io::buf_writer, n: uint) {\n+fn write_vint(w: io::writer, n: uint) {\n     if n < 0x7fu { write_sized_vint(w, n, 1u); ret; }\n     if n < 0x4000u { write_sized_vint(w, n, 2u); ret; }\n     if n < 0x200000u { write_sized_vint(w, n, 3u); ret; }\n@@ -147,7 +147,7 @@ fn write_vint(w: io::buf_writer, n: uint) {\n     fail;\n }\n \n-fn create_writer(w: io::buf_writer) -> writer {\n+fn create_writer(w: io::writer) -> writer {\n     let size_positions: [uint] = [];\n     ret {writer: w, mutable size_positions: size_positions};\n }"}, {"sha": "39247ef6380818479556d96e8415985a1407730b", "filename": "src/libstd/io.rs", "status": "modified", "additions": 204, "deletions": 283, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -4,8 +4,6 @@ Module: io\n Basic input/output\n */\n \n-import core::option;\n-import core::result;\n import core::ctypes::fd_t;\n import core::ctypes::c_int;\n \n@@ -22,86 +20,20 @@ native mod rustrt {\n tag seek_style { seek_set; seek_end; seek_cur; }\n \n \n-// The raw underlying reader class. All readers must implement this.\n-type buf_reader =\n-    // FIXME: Seekable really should be orthogonal. We will need\n-    // inheritance.\n-    obj {\n-        fn read(uint) -> [u8];\n-        fn read_byte() -> int;\n-        fn unread_byte(int);\n-        fn eof() -> bool;\n-        fn seek(int, seek_style);\n-        fn tell() -> uint;\n-        // Needed on readers in case one needs to flush metadata\n-        // changes (atime)\n-        fn fsync(level: fsync::level) -> int;\n-    };\n-\n-\n-// Convenience methods for reading.\n-type reader =\n-    // FIXME: This should inherit from buf_reader.\n-    // FIXME: eventually u64\n-\n-    obj {\n-        fn get_buf_reader() -> buf_reader;\n-        fn read_byte() -> int;\n-        fn unread_byte(int);\n-        fn read_bytes(uint) -> [u8];\n-        fn read_char() -> char;\n-        fn read_chars(uint) -> [char];\n-        fn eof() -> bool;\n-        fn read_line() -> str;\n-        fn read_c_str() -> str;\n-        fn read_le_uint(uint) -> uint;\n-        fn read_le_int(uint) -> int;\n-        fn read_be_uint(uint) -> uint;\n-        fn read_whole_stream() -> [u8];\n-        fn seek(int, seek_style);\n-        fn tell() -> uint;\n-    };\n-\n-fn convert_whence(whence: seek_style) -> i32 {\n-    ret alt whence {\n-      seek_set. { 0i32 }\n-      seek_cur. { 1i32 }\n-      seek_end. { 2i32 }\n-    };\n+// The raw underlying reader iface. All readers must implement this.\n+iface reader {\n+    // FIXME: Seekable really should be orthogonal.\n+    fn read_bytes(uint) -> [u8];\n+    fn read_byte() -> int;\n+    fn unread_byte(int);\n+    fn eof() -> bool;\n+    fn seek(int, seek_style);\n+    fn tell() -> uint;\n }\n \n-resource FILE_res(f: os::libc::FILE) {\n-    os::libc::fclose(f);\n-}\n+// Generic utility functions defined on readers\n \n-obj FILE_buf_reader(f: os::libc::FILE, res: option::t<@FILE_res>) {\n-    fn read(len: uint) -> [u8] unsafe {\n-        let buf = [];\n-        vec::reserve::<u8>(buf, len);\n-        let read =\n-            os::libc::fread(vec::unsafe::to_ptr::<u8>(buf), 1u, len, f);\n-        vec::unsafe::set_len::<u8>(buf, read);\n-        ret buf;\n-    }\n-    fn read_byte() -> int { ret os::libc::fgetc(f) as int; }\n-    fn unread_byte(byte: int) { os::libc::ungetc(byte as i32, f); }\n-    fn eof() -> bool { ret os::libc::feof(f) != 0i32; }\n-    fn seek(offset: int, whence: seek_style) {\n-        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0i32);\n-    }\n-    fn tell() -> uint { ret os::libc::ftell(f) as uint; }\n-    fn fsync(level: fsync::level) -> int {\n-        ret os::fsync_fd(os::libc::fileno(f), level) as int;\n-    }\n-}\n-\n-\n-// FIXME: Convert this into pseudomethods on buf_reader.\n-obj new_reader(rdr: buf_reader) {\n-    fn get_buf_reader() -> buf_reader { ret rdr; }\n-    fn read_byte() -> int { ret rdr.read_byte(); }\n-    fn unread_byte(byte: int) { ret rdr.unread_byte(byte); }\n-    fn read_bytes(len: uint) -> [u8] { ret rdr.read(len); }\n+impl reader_util for reader {\n     fn read_chars(n: uint) -> [char] {\n         // returns the (consumed offset, n_req), appends characters to &chars\n         fn chars_from_buf(buf: [u8], &chars: [char]) -> (uint, uint) {\n@@ -158,8 +90,9 @@ obj new_reader(rdr: buf_reader) {\n                 buf = vec::slice(buf, offset, vec::len(buf));\n             }\n         }\n-        ret chars;\n+        chars\n     }\n+\n     fn read_char() -> char {\n         let c = self.read_chars(1u);\n         if vec::len(c) == 0u {\n@@ -168,75 +101,116 @@ obj new_reader(rdr: buf_reader) {\n         assert(vec::len(c) == 1u);\n         ret c[0];\n     }\n-    fn eof() -> bool { ret rdr.eof(); }\n+\n     fn read_line() -> str {\n         let buf: [u8] = [];\n-        // No break yet in rustc\n-\n-        let go_on = true;\n-        while go_on {\n-            let ch = rdr.read_byte();\n-            if ch == -1 || ch == 10 {\n-                go_on = false;\n-            } else { buf += [ch as u8]; }\n+        while true {\n+            let ch = self.read_byte();\n+            if ch == -1 || ch == 10 { break; }\n+            buf += [ch as u8];\n         }\n-        ret str::unsafe_from_bytes(buf);\n+        str::unsafe_from_bytes(buf)\n     }\n+\n     fn read_c_str() -> str {\n         let buf: [u8] = [];\n-        let go_on = true;\n-        while go_on {\n-            let ch = rdr.read_byte();\n-            if ch < 1 { go_on = false; } else { buf += [ch as u8]; }\n+        while true {\n+            let ch = self.read_byte();\n+            if ch < 1 { break; } else { buf += [ch as u8]; }\n         }\n-        ret str::unsafe_from_bytes(buf);\n+        str::unsafe_from_bytes(buf)\n     }\n \n     // FIXME deal with eof?\n     fn read_le_uint(size: uint) -> uint {\n-        let val = 0u;\n-        let pos = 0u;\n-        let i = size;\n+        let val = 0u, pos = 0u, i = size;\n         while i > 0u {\n-            val += (rdr.read_byte() as uint) << pos;\n+            val += (self.read_byte() as uint) << pos;\n             pos += 8u;\n             i -= 1u;\n         }\n-        ret val;\n+        val\n     }\n     fn read_le_int(size: uint) -> int {\n         let val = 0u, pos = 0u, i = size;\n         while i > 0u {\n-            val += (rdr.read_byte() as uint) << pos;\n+            val += (self.read_byte() as uint) << pos;\n             pos += 8u;\n             i -= 1u;\n         }\n-        ret val as int;\n+        val as int\n     }\n-\n-    // FIXME deal with eof?\n-    fn read_be_uint(sz: uint) -> uint {\n-        let val = 0u, i = sz;\n-\n+    fn read_be_uint(size: uint) -> uint {\n+        let val = 0u, i = size;\n         while i > 0u {\n             i -= 1u;\n-            val += (rdr.read_byte() as uint) << i * 8u;\n+            val += (self.read_byte() as uint) << i * 8u;\n         }\n-        ret val;\n+        val\n     }\n+\n     fn read_whole_stream() -> [u8] {\n         let buf: [u8] = [];\n-        while !rdr.eof() { buf += rdr.read(2048u); }\n+        while !self.eof() { buf += self.read_bytes(2048u); }\n+        buf\n+    }\n+}\n+\n+// Reader implementations\n+\n+fn convert_whence(whence: seek_style) -> i32 {\n+    ret alt whence {\n+      seek_set. { 0i32 }\n+      seek_cur. { 1i32 }\n+      seek_end. { 2i32 }\n+    };\n+}\n+\n+impl of reader for os::libc::FILE {\n+    fn read_bytes(len: uint) -> [u8] unsafe {\n+        let buf = [];\n+        vec::reserve(buf, len);\n+        let read = os::libc::fread(vec::unsafe::to_ptr(buf), 1u, len, self);\n+        vec::unsafe::set_len(buf, read);\n         ret buf;\n     }\n-    fn seek(offset: int, whence: seek_style) { ret rdr.seek(offset, whence); }\n-    fn tell() -> uint { ret rdr.tell(); }\n+    fn read_byte() -> int { ret os::libc::fgetc(self) as int; }\n+    fn unread_byte(byte: int) { os::libc::ungetc(byte as i32, self); }\n+    fn eof() -> bool { ret os::libc::feof(self) != 0i32; }\n+    fn seek(offset: int, whence: seek_style) {\n+        assert os::libc::fseek(self, offset, convert_whence(whence)) == 0i32;\n+    }\n+    fn tell() -> uint { ret os::libc::ftell(self) as uint; }\n }\n \n-fn stdin() -> reader {\n-    ret new_reader(FILE_buf_reader(rustrt::rust_get_stdin(), option::none));\n+// A forwarding impl of reader that also holds on to a resource for the\n+// duration of its lifetime.\n+// FIXME there really should be a better way to do this\n+impl <T: reader, C> of reader for {base: T, cleanup: C} {\n+    fn read_bytes(len: uint) -> [u8] { self.base.read_bytes(len) }\n+    fn read_byte() -> int { self.base.read_byte() }\n+    fn unread_byte(byte: int) { self.base.unread_byte(byte); }\n+    fn eof() -> bool { self.base.eof() }\n+    fn seek(off: int, whence: seek_style) { self.base.seek(off, whence) }\n+    fn tell() -> uint { self.base.tell() }\n }\n \n+resource FILE_res(f: os::libc::FILE) { os::libc::fclose(f); }\n+\n+fn FILE_reader(f: os::libc::FILE, cleanup: bool) -> reader {\n+    if cleanup {\n+        {base: f, cleanup: FILE_res(f)} as reader\n+    } else {\n+        f as reader\n+    }\n+}\n+\n+// FIXME: this should either be an iface-less impl, a set of top-level\n+// functions that take a reader, or a set of default methods on reader\n+// (which can then be called reader)\n+\n+fn stdin() -> reader { rustrt::rust_get_stdin() as reader }\n+\n fn file_reader(path: str) -> result::t<reader, str> {\n     let f = str::as_buf(path, {|pathbuf|\n         str::as_buf(\"r\", {|modebuf|\n@@ -245,98 +219,99 @@ fn file_reader(path: str) -> result::t<reader, str> {\n     });\n     ret if f as uint == 0u { result::err(\"error opening \" + path) }\n     else {\n-        result::ok(new_reader(FILE_buf_reader(f, option::some(@FILE_res(f)))))\n+        result::ok(FILE_reader(f, true))\n     }\n }\n \n \n // Byte buffer readers\n \n // TODO: const u8, but this fails with rustboot.\n-type byte_buf = @{buf: [u8], mutable pos: uint};\n+type byte_buf = {buf: [u8], mutable pos: uint};\n \n-obj byte_buf_reader(bbuf: byte_buf) {\n-    fn read(len: uint) -> [u8] {\n-        let rest = vec::len::<u8>(bbuf.buf) - bbuf.pos;\n+impl of reader for byte_buf {\n+    fn read_bytes(len: uint) -> [u8] {\n+        let rest = vec::len(self.buf) - self.pos;\n         let to_read = len;\n         if rest < to_read { to_read = rest; }\n-        let range = vec::slice::<u8>(bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n-        bbuf.pos += to_read;\n+        let range = vec::slice(self.buf, self.pos, self.pos + to_read);\n+        self.pos += to_read;\n         ret range;\n     }\n     fn read_byte() -> int {\n-        if bbuf.pos == vec::len::<u8>(bbuf.buf) { ret -1; }\n-        let b = bbuf.buf[bbuf.pos];\n-        bbuf.pos += 1u;\n+        if self.pos == vec::len(self.buf) { ret -1; }\n+        let b = self.buf[self.pos];\n+        self.pos += 1u;\n         ret b as int;\n     }\n     fn unread_byte(_byte: int) { #error(\"TODO: unread_byte\"); fail; }\n-    fn eof() -> bool { ret bbuf.pos == vec::len::<u8>(bbuf.buf); }\n+    fn eof() -> bool { self.pos == vec::len(self.buf) }\n     fn seek(offset: int, whence: seek_style) {\n-        let pos = bbuf.pos;\n-        let len = vec::len::<u8>(bbuf.buf);\n-        bbuf.pos = seek_in_buf(offset, pos, len, whence);\n+        let pos = self.pos;\n+        let len = vec::len(self.buf);\n+        self.pos = seek_in_buf(offset, pos, len, whence);\n     }\n-    fn tell() -> uint { ret bbuf.pos; }\n-    fn fsync(_level: fsync::level) -> int { ret 0; }\n-}\n-\n-fn new_byte_buf_reader(buf: [u8]) -> buf_reader {\n-    ret byte_buf_reader(@{buf: buf, mutable pos: 0u});\n+    fn tell() -> uint { self.pos }\n }\n \n fn bytes_reader(bytes: [u8]) -> reader {\n-    ret new_reader(new_byte_buf_reader(bytes));\n+    {buf: bytes, mutable pos: 0u} as reader\n }\n \n fn string_reader(s: str) -> reader {\n-    ret new_reader(new_byte_buf_reader(str::bytes(s)));\n+    bytes_reader(str::bytes(s))\n }\n \n \n // Writing\n tag fileflag { append; create; truncate; none; }\n \n-type buf_writer =\n-    // FIXME: Seekable really should be orthogonal. We will need\n-    // inheritance.\n-    // FIXME: eventually u64\n-\n-    obj {\n-        fn write([const u8]);\n-        fn seek(int, seek_style);\n-        fn tell() -> uint;\n-        fn flush() -> int;\n-        fn fsync(level: fsync::level) -> int;\n-    };\n+// FIXME: Seekable really should be orthogonal.\n+// FIXME: eventually u64\n+iface writer {\n+    fn write([const u8]);\n+    fn seek(int, seek_style);\n+    fn tell() -> uint;\n+    fn flush() -> int;\n+}\n+\n+impl <T: writer, C> of writer for {base: T, cleanup: C} {\n+    fn write(bs: [const u8]) { self.base.write(bs); }\n+    fn seek(off: int, style: seek_style) { self.base.seek(off, style); }\n+    fn tell() -> uint { self.base.tell() }\n+    fn flush() -> int { self.base.flush() }\n+}\n \n-obj FILE_writer(f: os::libc::FILE, res: option::t<@FILE_res>) {\n+impl of writer for os::libc::FILE {\n     fn write(v: [const u8]) unsafe {\n-        let len = vec::len::<u8>(v);\n-        let vbuf = vec::unsafe::to_ptr::<u8>(v);\n-        let nout = os::libc::fwrite(vbuf, len, 1u, f);\n+        let len = vec::len(v);\n+        let vbuf = vec::unsafe::to_ptr(v);\n+        let nout = os::libc::fwrite(vbuf, len, 1u, self);\n         if nout < 1u { #error(\"error dumping buffer\"); }\n     }\n     fn seek(offset: int, whence: seek_style) {\n-        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0i32);\n-    }\n-    fn tell() -> uint { ret os::libc::ftell(f) as uint; }\n-    fn flush() -> int { ret os::libc::fflush(f) as int; }\n-    fn fsync(level: fsync::level) -> int {\n-        ret os::fsync_fd(os::libc::fileno(f), level) as int;\n+        assert os::libc::fseek(self, offset, convert_whence(whence)) == 0i32;\n     }\n+    fn tell() -> uint { os::libc::ftell(self) as uint }\n+    fn flush() -> int { os::libc::fflush(self) as int }\n }\n \n-resource fd_res(fd: fd_t) { os::libc::close(fd); }\n+fn FILE_writer(f: os::libc::FILE, cleanup: bool) -> writer {\n+    if cleanup {\n+        {base: f, cleanup: FILE_res(f)} as writer\n+    } else {\n+        f as writer\n+    }\n+}\n \n-obj fd_buf_writer(fd: fd_t, res: option::t<@fd_res>) {\n+impl of writer for fd_t {\n     fn write(v: [const u8]) unsafe {\n-        let len = vec::len::<u8>(v);\n+        let len = vec::len(v);\n         let count = 0u;\n         let vbuf;\n         while count < len {\n-            vbuf = ptr::offset(vec::unsafe::to_ptr::<u8>(v), count);\n-            let nout = os::libc::write(fd, vbuf, len);\n+            vbuf = ptr::offset(vec::unsafe::to_ptr(v), count);\n+            let nout = os::libc::write(self, vbuf, len);\n             if nout < 0 {\n                 #error(\"error dumping buffer\");\n                 log(error, sys::last_os_error());\n@@ -353,16 +328,21 @@ obj fd_buf_writer(fd: fd_t, res: option::t<@fd_res>) {\n         #error(\"need 64-bit native calls for tell, sorry\");\n         fail;\n     }\n+    fn flush() -> int { 0 }\n+}\n \n-    fn flush() -> int { ret 0; }\n+resource fd_res(fd: fd_t) { os::libc::close(fd); }\n \n-    fn fsync(level: fsync::level) -> int {\n-        ret os::fsync_fd(fd, level) as int;\n+fn fd_writer(fd: fd_t, cleanup: bool) -> writer {\n+    if cleanup {\n+        {base: fd, cleanup: fd_res(fd)} as writer\n+    } else {\n+        fd as writer\n     }\n }\n \n-fn file_buf_writer(path: str,\n-                   flags: [fileflag]) -> result::t<buf_writer, str> {\n+fn mk_file_writer(path: str, flags: [fileflag])\n+    -> result::t<writer, str> {\n     let fflags: i32 =\n         os::libc_constants::O_WRONLY | os::libc_constants::O_BINARY;\n     for f: fileflag in flags {\n@@ -373,37 +353,19 @@ fn file_buf_writer(path: str,\n           none. { }\n         }\n     }\n-    let fd =\n-        str::as_buf(path,\n-                    {|pathbuf|\n-                        os::libc::open(pathbuf, fflags,\n-                                       os::libc_constants::S_IRUSR |\n-                                           os::libc_constants::S_IWUSR)\n-                    });\n-    ret if fd < 0i32 {\n+    let fd = str::as_buf(path, {|pathbuf|\n+        os::libc::open(pathbuf, fflags, os::libc_constants::S_IRUSR |\n+                       os::libc_constants::S_IWUSR)\n+    });\n+    if fd < 0i32 {\n+        // FIXME don't log this! put it in the returned error string\n         log(error, sys::last_os_error());\n         result::err(\"error opening \" + path)\n     } else {\n-        result::ok(fd_buf_writer(fd, option::some(@fd_res(fd))))\n+        result::ok(fd_writer(fd, true))\n     }\n }\n \n-type writer =\n-    // write_str will continue to do utf-8 output only. an alternative\n-    // function will be provided for general encoded string output\n-    obj {\n-        fn get_buf_writer() -> buf_writer;\n-        fn write_str(str);\n-        fn write_line(str);\n-        fn write_char(char);\n-        fn write_int(int);\n-        fn write_uint(uint);\n-        fn write_bytes([const u8]);\n-        fn write_le_uint(uint, uint);\n-        fn write_le_int(int, uint);\n-        fn write_be_uint(uint, uint);\n-    };\n-\n fn uint_to_le_bytes(n: uint, size: uint) -> [u8] {\n     let bytes: [u8] = [], i = size, n = n;\n     while i > 0u { bytes += [n & 255u as u8]; n >>= 8u; i -= 1u; }\n@@ -417,130 +379,89 @@ fn uint_to_be_bytes(n: uint, size: uint) -> [u8] {\n     ret bytes;\n }\n \n-obj new_writer(out: buf_writer) {\n-    fn get_buf_writer() -> buf_writer { ret out; }\n-    fn write_str(s: str) { out.write(str::bytes(s)); }\n-    fn write_line(s: str) {\n-        out.write(str::bytes(s));\n-        out.write(str::bytes(\"\\n\"));\n-    }\n+impl writer_util for writer {\n     fn write_char(ch: char) {\n-        // FIXME needlessly consy\n-\n-        out.write(str::bytes(str::from_char(ch)));\n+        if ch as uint < 128u {\n+            self.write([ch as u8]);\n+        } else {\n+            self.write(str::bytes(str::from_char(ch)));\n+        }\n     }\n-    fn write_int(n: int) { out.write(str::bytes(int::to_str(n, 10u))); }\n-    fn write_uint(n: uint) { out.write(str::bytes(uint::to_str(n, 10u))); }\n-    fn write_bytes(bytes: [const u8]) { out.write(bytes); }\n+    fn write_str(s: str) { self.write(str::bytes(s)); }\n+    fn write_line(s: str) { self.write(str::bytes(s + \"\\n\")); }\n+    fn write_int(n: int) { self.write(str::bytes(int::to_str(n, 10u))); }\n+    fn write_uint(n: uint) { self.write(str::bytes(uint::to_str(n, 10u))); }\n+\n     fn write_le_uint(n: uint, size: uint) {\n-        out.write(uint_to_le_bytes(n, size));\n+        self.write(uint_to_le_bytes(n, size));\n     }\n     fn write_le_int(n: int, size: uint) {\n-        out.write(uint_to_le_bytes(n as uint, size));\n+        self.write(uint_to_le_bytes(n as uint, size));\n     }\n     fn write_be_uint(n: uint, size: uint) {\n-        out.write(uint_to_be_bytes(n, size));\n+        self.write(uint_to_be_bytes(n, size));\n     }\n }\n \n fn file_writer(path: str, flags: [fileflag]) -> result::t<writer, str> {\n-    result::chain(file_buf_writer(path, flags), { |w|\n-        result::ok(new_writer(w))\n-    })\n+    result::chain(mk_file_writer(path, flags), { |w| result::ok(w)})\n }\n \n \n // FIXME: fileflags\n-fn buffered_file_buf_writer(path: str) -> result::t<buf_writer, str> {\n-    let f =\n-        str::as_buf(path,\n-                    {|pathbuf|\n-                        str::as_buf(\"w\",\n-                                    {|modebuf|\n-                                        os::libc::fopen(pathbuf, modebuf)\n-                                    })\n-                    });\n+fn buffered_file_writer(path: str) -> result::t<writer, str> {\n+    let f = str::as_buf(path, {|pathbuf|\n+        str::as_buf(\"w\", {|modebuf| os::libc::fopen(pathbuf, modebuf) })\n+    });\n     ret if f as uint == 0u { result::err(\"error opening \" + path) }\n-    else { result::ok(FILE_writer(f, option::some(@FILE_res(f)))) }\n+    else { result::ok(FILE_writer(f, true)) }\n }\n \n-\n // FIXME it would be great if this could be a const\n-// Problem seems to be that new_writer is not pure\n-fn stdout() -> writer { ret new_writer(fd_buf_writer(1i32, option::none)); }\n-fn stderr() -> writer { ret new_writer(fd_buf_writer(2i32, option::none)); }\n+fn stdout() -> writer { fd_writer(1i32, false) }\n+fn stderr() -> writer { fd_writer(2i32, false) }\n \n fn print(s: str) { stdout().write_str(s); }\n-fn println(s: str) { stdout().write_str(s + \"\\n\"); }\n-\n-type bytes_writer =\n-    obj {\n-        fn get_writer() -> writer;\n-        fn get_bytes() -> [mutable u8];\n-    };\n+fn println(s: str) { stdout().write_line(s); }\n \n-type str_writer =\n-    obj {\n-        fn get_writer() -> writer;\n-        fn get_str() -> str;\n-    };\n-\n-type mutable_byte_buf = @{mutable buf: [mutable u8], mutable pos: uint};\n+type mem_buffer = @{mutable buf: [mutable u8],\n+                    mutable pos: uint};\n \n-obj byte_buf_writer(buf: mutable_byte_buf) {\n+impl of writer for mem_buffer {\n     fn write(v: [const u8]) {\n         // Fast path.\n-\n-        if buf.pos == vec::len(buf.buf) {\n-            for b: u8 in v { buf.buf += [mutable b]; }\n-            buf.pos += vec::len::<u8>(v);\n+        if self.pos == vec::len(self.buf) {\n+            for b: u8 in v { self.buf += [mutable b]; }\n+            self.pos += vec::len(v);\n             ret;\n         }\n         // FIXME: Optimize: These should be unique pointers.\n-\n-        let vlen = vec::len::<u8>(v);\n+        let vlen = vec::len(v);\n         let vpos = 0u;\n         while vpos < vlen {\n             let b = v[vpos];\n-            if buf.pos == vec::len(buf.buf) {\n-                buf.buf += [mutable b];\n-            } else { buf.buf[buf.pos] = b; }\n-            buf.pos += 1u;\n+            if self.pos == vec::len(self.buf) {\n+                self.buf += [mutable b];\n+            } else { self.buf[self.pos] = b; }\n+            self.pos += 1u;\n             vpos += 1u;\n         }\n     }\n     fn seek(offset: int, whence: seek_style) {\n-        let pos = buf.pos;\n-        let len = vec::len(buf.buf);\n-        buf.pos = seek_in_buf(offset, pos, len, whence);\n+        let pos = self.pos;\n+        let len = vec::len(self.buf);\n+        self.pos = seek_in_buf(offset, pos, len, whence);\n     }\n-    fn tell() -> uint { ret buf.pos; }\n-    fn flush() -> int { ret 0; }\n-    fn fsync(_level: fsync::level) -> int { ret 0; }\n+    fn tell() -> uint { self.pos }\n+    fn flush() -> int { 0 }\n }\n \n-fn bytes_writer() -> bytes_writer {\n-    // FIXME: yikes, this is bad. Needs fixing of mutable syntax.\n-\n-    let b: [mutable u8] = [mutable 0u8];\n-    vec::pop(b);\n-    let buf = @{mutable buf: b, mutable pos: 0u};\n-    obj byte_buf_writer_wrap(wr: writer, buf: mutable_byte_buf) {\n-        fn get_writer() -> writer { ret wr; }\n-        fn get_bytes() -> [mutable u8] { ret buf.buf; }\n-    }\n-    ret byte_buf_writer_wrap(new_writer(byte_buf_writer(buf)), buf);\n+fn mk_mem_buffer() -> mem_buffer {\n+    @{mutable buf: [mutable], mutable pos: 0u}\n }\n-\n-fn string_writer() -> str_writer {\n-    let writer = bytes_writer();\n-    obj str_writer_wrap(wr: bytes_writer) {\n-        fn get_writer() -> writer { wr.get_writer() }\n-        fn get_str() -> str { str::unsafe_from_bytes(wr.get_bytes()) }\n-    }\n-    str_writer_wrap(writer)\n-}\n-\n+fn mem_buffer_writer(b: mem_buffer) -> writer { b as writer }\n+fn mem_buffer_buf(b: mem_buffer) -> [u8] { vec::from_mut(b.buf) }\n+fn mem_buffer_str(b: mem_buffer) -> str { str::unsafe_from_bytes(b.buf) }\n \n // Utility functions\n fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n@@ -562,9 +483,9 @@ fn read_whole_file_str(file: str) -> result::t<str, str> {\n     })\n }\n \n+// FIXME implement this in a low-level way. Going through the abstractions is\n+// pointless.\n fn read_whole_file(file: str) -> result::t<[u8], str> {\n-\n-    // FIXME: There's a lot of copying here\n     result::chain(file_reader(file), { |rdr|\n         result::ok(rdr.read_whole_stream())\n     })\n@@ -591,8 +512,8 @@ mod fsync {\n     // Resource of artifacts that need to fsync on destruction\n     resource res<t>(arg: arg<t>) {\n         alt arg.opt_level {\n-          option::none::<level>. { }\n-          option::some::<level>(level) {\n+          option::none. { }\n+          option::some(level) {\n             // fail hard if not succesful\n             assert(arg.fsync_fn(arg.val, level) != -1);\n           }\n@@ -629,7 +550,7 @@ mod fsync {\n     }\n \n     // Type of objects that may want to fsync\n-    type t = obj { fn fsync(l: level) -> int; };\n+    iface t { fn fsync(l: level) -> int; }\n \n     // Call o.fsync after executing blk\n     fn obj_sync(&&o: t, opt_level: option::t<level>, blk: block(&&res<t>)) {"}, {"sha": "cc1e7c96046dd29f948487a426ddb03a0e2ef01d", "filename": "src/libstd/run_program.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibstd%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibstd%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun_program.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -197,15 +197,9 @@ fn start_program(prog: str, args: [str]) -> program {\n \n     impl of program for prog_res {\n         fn get_id() -> pid_t { ret self.pid; }\n-        fn input() -> io::writer {\n-            ret io::new_writer(io::fd_buf_writer(self.in_fd, none));\n-        }\n-        fn output() -> io::reader {\n-            ret io::new_reader(io::FILE_buf_reader(self.out_file, none));\n-        }\n-        fn err() -> io::reader {\n-            ret io::new_reader(io::FILE_buf_reader(self.err_file, none));\n-        }\n+        fn input() -> io::writer { io::fd_writer(self.in_fd, false) }\n+        fn output() -> io::reader { io::FILE_reader(self.out_file, false) }\n+        fn err() -> io::reader { io::FILE_reader(self.err_file, false) }\n         fn close_input() { close_repr_input(*self); }\n         fn finish() -> int { finish_repr(*self) }\n         fn destroy() { destroy_repr(*self); }"}, {"sha": "c1076978cf987f2e79caa5f47c6d6590f341b84d", "filename": "src/libstd/term.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -45,14 +45,14 @@ const color_bright_cyan: u8 = 14u8;\n /* Const: color_bright_white */\n const color_bright_white: u8 = 15u8;\n \n-fn esc(writer: io::buf_writer) { writer.write([0x1bu8, '[' as u8]); }\n+fn esc(writer: io::writer) { writer.write([0x1bu8, '[' as u8]); }\n \n /*\n Function: reset\n \n Reset the foreground and background colors to default\n */\n-fn reset(writer: io::buf_writer) {\n+fn reset(writer: io::writer) {\n     esc(writer);\n     writer.write(['0' as u8, 'm' as u8]);\n }\n@@ -76,7 +76,7 @@ fn color_supported() -> bool {\n         };\n }\n \n-fn set_color(writer: io::buf_writer, first_char: u8, color: u8) {\n+fn set_color(writer: io::writer, first_char: u8, color: u8) {\n     assert (color < 16u8);\n     esc(writer);\n     let color = color;\n@@ -89,7 +89,7 @@ Function: fg\n \n Set the foreground color\n */\n-fn fg(writer: io::buf_writer, color: u8) {\n+fn fg(writer: io::writer, color: u8) {\n     ret set_color(writer, '3' as u8, color);\n }\n \n@@ -98,7 +98,7 @@ Function: fg\n \n Set the background color\n */\n-fn bg(writer: io::buf_writer, color: u8) {\n+fn bg(writer: io::writer, color: u8) {\n     ret set_color(writer, '4' as u8, color);\n }\n "}, {"sha": "af2910536b24f2bd131093c0ec2b4f4d7ef5c4eb", "filename": "src/libstd/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -3,13 +3,7 @@\n // simplest interface possible for representing and running tests\n // while providing a base that other test frameworks may build off of.\n \n-import core::comm;\n-import core::task;\n-import task::task;\n-import core::option;\n-import core::either;\n-import core::vec;\n-import core::result::{ok, err};\n+import result::{ok, err};\n \n export test_name;\n export test_fn;\n@@ -36,6 +30,12 @@ native mod rustrt {\n     fn sched_threads() -> uint;\n }\n \n+// FIXME Kludge to work around issue #1494 . Simply import io::writer_util\n+// when that is fixed.\n+impl writer_util for io::writer {\n+    fn write_str(s: str) { self.write(str::bytes(s)); }\n+    fn write_line(s: str) { self.write(str::bytes(s + \"\\n\")); }\n+}\n \n // The name of a test. By convention this follows the rules for rust\n // paths; i.e. it should be a series of identifiers seperated by double\n@@ -101,7 +101,7 @@ fn parse_opts(args: [str]) : vec::is_not_empty(args) -> opt_res {\n \n tag test_result { tr_ok; tr_failed; tr_ignored; }\n \n-type joinable = (task, comm::port<task::task_notification>);\n+type joinable = (task::task, comm::port<task::task_notification>);\n \n // To get isolation and concurrency tests have to be run in their own tasks.\n // In cases where test functions are closures it is not ok to just dump them\n@@ -203,11 +203,11 @@ fn run_tests_console_<T: copy>(opts: test_opts, tests: [test_desc<T>],\n \n     fn write_pretty(out: io::writer, word: str, color: u8, use_color: bool) {\n         if use_color && term::color_supported() {\n-            term::fg(out.get_buf_writer(), color);\n+            term::fg(out, color);\n         }\n         out.write_str(word);\n         if use_color && term::color_supported() {\n-            term::reset(out.get_buf_writer());\n+            term::reset(out);\n         }\n     }\n }"}, {"sha": "2afd944ad3ec24fffce14605945f2ad206e8450f", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -13,6 +13,7 @@ import rustc::syntax::parse::parser;\n import rustc::syntax::print::pprust;\n import rustc::syntax::visit;\n import std::io;\n+import io::writer_util;\n import std::map;\n \n type rustdoc = {"}, {"sha": "04f55d4d0b71eda92a5c401d8b500840d86f2589", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -12,16 +12,9 @@\n \n use std;\n \n-import vec;\n-import uint;\n-import std::time;\n-import str;\n+import std::{time, io, getopts};\n+import io::writer_util;\n import int::range;\n-import std::io;\n-import std::getopts;\n-import task;\n-import u64;\n-import comm;\n import comm::port;\n import comm::chan;\n import comm::send;"}, {"sha": "01dcc5ed12593ee724de00a659e3577e0273d9b9", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -1,11 +1,7 @@\n use std;\n \n-import std::io;\n-import str;\n-import uint;\n-import u8;\n-import vec;\n-import std::bitv;\n+import std::{io, bitv};\n+import io::{writer_util, reader_util};\n \n // Computes a single solution to a given 9x9 sudoku\n //"}, {"sha": "a920f73e05223859abd2eed20f0739b083b44cbc", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -11,20 +11,11 @@\n use std;\n \n import option = option::t;\n-import option::some;\n-import option::none;\n-import str;\n-import std::map;\n-import vec;\n-import std::io;\n-\n-import std::time;\n-import u64;\n-import result;\n-\n-import task;\n+import option::{some, none};\n+import std::{map, io, time};\n+import io::reader_util;\n+\n import task::joinable_task;\n-import comm;\n import comm::chan;\n import comm::port;\n import comm::recv;\n@@ -210,7 +201,6 @@ fn read_word(r: io::reader) -> option<str> {\n     while !r.eof() {\n         let c = r.read_char();\n \n-\n         if is_word_char(c) {\n             w += str::from_char(c);\n         } else { if w != \"\" { ret some(w); } }"}, {"sha": "817beee22b3a846cc0ffae01ed9b5d03bcca977f", "filename": "src/test/stdtest/io.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fstdtest%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fstdtest%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fio.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -3,6 +3,7 @@ import core::*;\n // -*- rust -*-\n use std;\n import std::io;\n+import io::{writer_util, reader_util};\n import str;\n import result;\n \n@@ -82,8 +83,8 @@ fn file_reader_not_exist() {\n }\n \n #[test]\n-fn file_buf_writer_bad_name() {\n-    alt io::file_buf_writer(\"?/?\", []) {\n+fn file_writer_bad_name() {\n+    alt io::file_writer(\"?/?\", []) {\n       result::err(e) {\n         assert e == \"error opening ?/?\";\n       }\n@@ -92,8 +93,8 @@ fn file_buf_writer_bad_name() {\n }\n \n #[test]\n-fn buffered_file_buf_writer_bad_name() {\n-    alt io::buffered_file_buf_writer(\"?/?\") {\n+fn buffered_file_writer_bad_name() {\n+    alt io::buffered_file_writer(\"?/?\") {\n       result::err(e) {\n         assert e == \"error opening ?/?\";\n       }"}, {"sha": "65291026bd596ebf2f8a3c0acf41835614c615fa", "filename": "src/test/stdtest/qsort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fstdtest%2Fqsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fstdtest%2Fqsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -44,7 +44,7 @@ fn test() {\n     }\n }\n \n-// Regression test for #705\n+// Regression test for #750\n #[test]\n fn test_simple() {\n     let names = [mutable 2, 1, 3];"}, {"sha": "c1e194a35905a6c547c92ff413ed78ffa8a81beb", "filename": "src/test/stdtest/run.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fstdtest%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d7f05292911d5582ede20fd871f600447ad59d/src%2Ftest%2Fstdtest%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frun.rs?ref=34d7f05292911d5582ede20fd871f600447ad59d", "patch": "@@ -4,6 +4,7 @@ use std;\n import std::run;\n import std::os;\n import std::io;\n+import io::writer_util;\n import option;\n import str;\n import ctypes::fd_t;\n@@ -41,7 +42,7 @@ fn test_pipes() {\n \n     fn writeclose(fd: fd_t, s: str) {\n         #error(\"writeclose %d, %s\", fd as int, s);\n-        let writer = io::new_writer(io::fd_buf_writer(fd, option::none));\n+        let writer = io::fd_writer(fd, false);\n         writer.write_str(s);\n \n         os::close(fd);\n@@ -50,7 +51,7 @@ fn test_pipes() {\n     fn readclose(fd: fd_t) -> str {\n         // Copied from run::program_output\n         let file = os::fd_FILE(fd);\n-        let reader = io::new_reader(io::FILE_buf_reader(file, option::none));\n+        let reader = io::FILE_reader(file, false);\n         let buf = \"\";\n         while !reader.eof() {\n             let bytes = reader.read_bytes(4096u);"}]}