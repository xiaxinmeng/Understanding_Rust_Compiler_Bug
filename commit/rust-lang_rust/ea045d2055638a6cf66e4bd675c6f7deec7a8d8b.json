{"sha": "ea045d2055638a6cf66e4bd675c6f7deec7a8d8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMDQ1ZDIwNTU2MzhhNmNmNjZlNGJkNjc1YzZmN2RlZWM3YThkOGI=", "commit": {"author": {"name": "Valerii Hiora", "email": "valerii.hiora@gmail.com", "date": "2015-01-09T16:18:23Z"}, "committer": {"name": "Valerii Hiora", "email": "valerii.hiora@gmail.com", "date": "2015-01-09T16:38:30Z"}, "message": "iOS: cabi fixes\n\nChanged alignment according to official Apple docs", "tree": {"sha": "eff1efb141d2598c80c4b4e7612685575226ce45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eff1efb141d2598c80c4b4e7612685575226ce45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea045d2055638a6cf66e4bd675c6f7deec7a8d8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea045d2055638a6cf66e4bd675c6f7deec7a8d8b", "html_url": "https://github.com/rust-lang/rust/commit/ea045d2055638a6cf66e4bd675c6f7deec7a8d8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea045d2055638a6cf66e4bd675c6f7deec7a8d8b/comments", "author": {"login": "vhbit", "id": 140199, "node_id": "MDQ6VXNlcjE0MDE5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/140199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vhbit", "html_url": "https://github.com/vhbit", "followers_url": "https://api.github.com/users/vhbit/followers", "following_url": "https://api.github.com/users/vhbit/following{/other_user}", "gists_url": "https://api.github.com/users/vhbit/gists{/gist_id}", "starred_url": "https://api.github.com/users/vhbit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vhbit/subscriptions", "organizations_url": "https://api.github.com/users/vhbit/orgs", "repos_url": "https://api.github.com/users/vhbit/repos", "events_url": "https://api.github.com/users/vhbit/events{/privacy}", "received_events_url": "https://api.github.com/users/vhbit/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vhbit", "id": 140199, "node_id": "MDQ6VXNlcjE0MDE5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/140199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vhbit", "html_url": "https://github.com/vhbit", "followers_url": "https://api.github.com/users/vhbit/followers", "following_url": "https://api.github.com/users/vhbit/following{/other_user}", "gists_url": "https://api.github.com/users/vhbit/gists{/gist_id}", "starred_url": "https://api.github.com/users/vhbit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vhbit/subscriptions", "organizations_url": "https://api.github.com/users/vhbit/orgs", "repos_url": "https://api.github.com/users/vhbit/repos", "events_url": "https://api.github.com/users/vhbit/events{/privacy}", "received_events_url": "https://api.github.com/users/vhbit/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac0607acb27ed8ad3852a6e099ff0766b002f40e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac0607acb27ed8ad3852a6e099ff0766b002f40e", "html_url": "https://github.com/rust-lang/rust/commit/ac0607acb27ed8ad3852a6e099ff0766b002f40e"}], "stats": {"total": 94, "additions": 75, "deletions": 19}, "files": [{"sha": "f7ffbb95feb3b43699a5002d526f6e1546a45d87", "filename": "src/librustc_trans/trans/cabi.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea045d2055638a6cf66e4bd675c6f7deec7a8d8b/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea045d2055638a6cf66e4bd675c6f7deec7a8d8b/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=ea045d2055638a6cf66e4bd675c6f7deec7a8d8b", "patch": "@@ -115,8 +115,15 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         } else {\n             cabi_x86_64::compute_abi_info(ccx, atys, rty, ret_def)\n         },\n-        \"arm\" => cabi_arm::compute_abi_info(ccx, atys, rty, ret_def),\n         \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, atys, rty, ret_def),\n+        \"arm\" => {\n+            let flavor = if ccx.sess().target.target.target_os == \"ios\" {\n+                cabi_arm::Flavor::Ios\n+            } else {\n+                cabi_arm::Flavor::General\n+            };\n+            cabi_arm::compute_abi_info(ccx, atys, rty, ret_def, flavor)\n+        },\n         \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n         a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)\n                               []),"}, {"sha": "830771d7397e2d3c7c3a16a40f4c4814df7f4d91", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 67, "deletions": 18, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ea045d2055638a6cf66e4bd675c6f7deec7a8d8b/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea045d2055638a6cf66e4bd675c6f7deec7a8d8b/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=ea045d2055638a6cf66e4bd675c6f7deec7a8d8b", "patch": "@@ -19,16 +19,23 @@ use trans::type_::Type;\n \n use std::cmp;\n \n+pub enum Flavor {\n+    General,\n+    Ios\n+}\n+\n+type TyAlignFn = fn(ty: Type) -> uint;\n+\n fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n }\n \n-fn align(off: uint, ty: Type) -> uint {\n-    let a = ty_align(ty);\n+fn align(off: uint, ty: Type, align_fn: TyAlignFn) -> uint {\n+    let a = align_fn(ty);\n     return align_up_to(off, a);\n }\n \n-fn ty_align(ty: Type) -> uint {\n+fn general_ty_align(ty: Type) -> uint {\n     match ty.kind() {\n         Integer => {\n             unsafe {\n@@ -43,18 +50,51 @@ fn ty_align(ty: Type) -> uint {\n                 1\n             } else {\n                 let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n+                str_tys.iter().fold(1, |a, t| cmp::max(a, general_ty_align(*t)))\n+            }\n+        }\n+        Array => {\n+            let elt = ty.element_type();\n+            general_ty_align(elt)\n+        }\n+        _ => panic!(\"ty_align: unhandled type\")\n+    }\n+}\n+\n+// For more information see:\n+// ARMv7\n+// https://developer.apple.com/library/ios/documentation/Xcode/Conceptual\n+//    /iPhoneOSABIReference/Articles/ARMv7FunctionCallingConventions.html\n+// ARMv6\n+// https://developer.apple.com/library/ios/documentation/Xcode/Conceptual\n+//    /iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html\n+fn ios_ty_align(ty: Type) -> uint {\n+    match ty.kind() {\n+        Integer => {\n+            unsafe {\n+                cmp::min(4, ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8)\n+            }\n+        }\n+        Pointer => 4,\n+        Float => 4,\n+        Double => 4,\n+        Struct => {\n+            if ty.is_packed() {\n+                1\n+            } else {\n+                let str_tys = ty.field_types();\n+                str_tys.iter().fold(1, |a, t| cmp::max(a, ios_ty_align(*t)))\n             }\n         }\n         Array => {\n             let elt = ty.element_type();\n-            ty_align(elt)\n+            ios_ty_align(elt)\n         }\n         _ => panic!(\"ty_align: unhandled type\")\n     }\n }\n \n-fn ty_size(ty: Type) -> uint {\n+fn ty_size(ty: Type, align_fn: TyAlignFn) -> uint {\n     match ty.kind() {\n         Integer => {\n             unsafe {\n@@ -67,29 +107,32 @@ fn ty_size(ty: Type) -> uint {\n         Struct => {\n             if ty.is_packed() {\n                 let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n+                str_tys.iter().fold(0, |s, t| s + ty_size(*t, align_fn))\n             } else {\n                 let str_tys = ty.field_types();\n-                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                align(size, ty)\n+                let size = str_tys.iter()\n+                                  .fold(0, |s, t| {\n+                                      align(s, *t, align_fn) + ty_size(*t, align_fn)\n+                                  });\n+                align(size, ty, align_fn)\n             }\n         }\n         Array => {\n             let len = ty.array_length();\n             let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n+            let eltsz = ty_size(elt, align_fn);\n             len * eltsz\n         }\n         _ => panic!(\"ty_size: unhandled type\")\n     }\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n+fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n         let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n-    let size = ty_size(ty);\n+    let size = ty_size(ty, align_fn);\n     if size <= 4 {\n         let llty = if size <= 1 {\n             Type::i8(ccx)\n@@ -103,13 +146,13 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     ArgType::indirect(ty, Some(StructRetAttribute))\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n         let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n-    let align = ty_align(ty);\n-    let size = ty_size(ty);\n+    let align = align_fn(ty);\n+    let size = ty_size(ty, align_fn);\n     let llty = if align <= 4 {\n         Type::array(&Type::i32(ccx), ((size + 3) / 4) as u64)\n     } else {\n@@ -131,15 +174,21 @@ fn is_reg_ty(ty: Type) -> bool {\n pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n-                        ret_def: bool) -> FnType {\n+                        ret_def: bool,\n+                        flavor: Flavor) -> FnType {\n+    let align_fn = match flavor {\n+        Flavor::General => general_ty_align as TyAlignFn,\n+        Flavor::Ios => ios_ty_align as TyAlignFn,\n+    };\n+\n     let mut arg_tys = Vec::new();\n     for &aty in atys.iter() {\n-        let ty = classify_arg_ty(ccx, aty);\n+        let ty = classify_arg_ty(ccx, aty, align_fn);\n         arg_tys.push(ty);\n     }\n \n     let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty)\n+        classify_ret_ty(ccx, rty, align_fn)\n     } else {\n         ArgType::direct(Type::void(ccx), None, None, None)\n     };"}]}