{"sha": "6277b1fef617610c32b36dba1b06f937488ca5a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNzdiMWZlZjYxNzYxMGMzMmIzNmRiYTFiMDZmOTM3NDg4Y2E1YTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-12T18:18:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T14:25:01Z"}, "message": "separate main items from addl items in metadata", "tree": {"sha": "a21a2fdfcd7b0a435ba5bad672f1a622c43e2b45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a21a2fdfcd7b0a435ba5bad672f1a622c43e2b45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6277b1fef617610c32b36dba1b06f937488ca5a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6277b1fef617610c32b36dba1b06f937488ca5a9", "html_url": "https://github.com/rust-lang/rust/commit/6277b1fef617610c32b36dba1b06f937488ca5a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6277b1fef617610c32b36dba1b06f937488ca5a9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d49e1a91912788b874bfb5cfc610bc8e3a845d7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d49e1a91912788b874bfb5cfc610bc8e3a845d7f", "html_url": "https://github.com/rust-lang/rust/commit/d49e1a91912788b874bfb5cfc610bc8e3a845d7f"}], "stats": {"total": 374, "additions": 220, "deletions": 154}, "files": [{"sha": "8611e744bc468caf64a64253ef20c4f11dbfe65f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 220, "deletions": 154, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/6277b1fef617610c32b36dba1b06f937488ca5a9/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6277b1fef617610c32b36dba1b06f937488ca5a9/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6277b1fef617610c32b36dba1b06f937488ca5a9", "patch": "@@ -443,18 +443,18 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_struct_ctor(&mut self,\n                                    name: Name,\n-                                   struct_def: &hir::VariantData,\n+                                   ctor_id: ast::NodeId,\n+                                   variant: ty::VariantDef<'tcx>,\n                                    struct_id: NodeId) {\n         let ecx = self.ecx();\n-        let ctor_id = struct_def.id();\n         let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n \n         self.record(ctor_def_id, |this| {\n             encode_def_id_and_key(ecx, this.rbml_w, ctor_def_id);\n-            encode_family(this.rbml_w, match *struct_def {\n-                hir::VariantData::Struct(..) => 'S',\n-                hir::VariantData::Tuple(..) => 's',\n-                hir::VariantData::Unit(..) => 'u',\n+            encode_family(this.rbml_w, match variant.kind {\n+                ty::VariantKind::Struct => 'S',\n+                ty::VariantKind::Tuple => 's',\n+                ty::VariantKind::Unit => 'u',\n             });\n             this.encode_bounds_and_type_for_item(ctor_id);\n             encode_name(this.rbml_w, name);\n@@ -874,15 +874,13 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                     encode_stability(this.rbml_w, stab);\n                     encode_deprecation(this.rbml_w, depr);\n                 });\n-\n-                self.encode_enum_variant_info(def_id, vis);\n             }\n             hir::ItemStruct(ref struct_def, _) => {\n                 /* Index the class*/\n-                let def = ecx.tcx.lookup_adt_def(def_id);\n-                let variant = def.struct_variant();\n-\n                 self.record(def_id, |this| {\n+                    let def = ecx.tcx.lookup_adt_def(def_id);\n+                    let variant = def.struct_variant();\n+\n                     /* Now, make an item for the class itself */\n                     encode_def_id_and_key(ecx, this.rbml_w, def_id);\n                     encode_family(this.rbml_w, match *struct_def {\n@@ -917,15 +915,6 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                                              def_to_u64(ctor_did));\n                     }\n                 });\n-\n-                for field in &variant.fields {\n-                    self.encode_field(field);\n-                }\n-\n-                // If this is a tuple-like struct, encode the type of the constructor.\n-                if !struct_def.is_struct() {\n-                    self.encode_info_for_struct_ctor(item.name, struct_def, item.id);\n-                }\n             }\n             hir::ItemDefaultImpl(unsafety, _) => {\n                 self.record(def_id, |this| {\n@@ -938,13 +927,13 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                     encode_trait_ref(this.rbml_w, ecx, trait_ref, tag_item_trait_ref);\n                 });\n             }\n-            hir::ItemImpl(unsafety, polarity, _, _, _, ref ast_items) => {\n-                // We need to encode information about the default methods we\n-                // have inherited, so we drive this based on the impl structure.\n-                let impl_items = tcx.impl_items.borrow();\n-                let items = &impl_items[&def_id];\n-\n+            hir::ItemImpl(unsafety, polarity, _, _, _, _) => {\n                 self.record(def_id, |this| {\n+                    // We need to encode information about the default methods we\n+                    // have inherited, so we drive this based on the impl structure.\n+                    let impl_items = tcx.impl_items.borrow();\n+                    let items = &impl_items[&def_id];\n+\n                     encode_def_id_and_key(ecx, this.rbml_w, def_id);\n                     encode_family(this.rbml_w, 'i');\n                     this.encode_bounds_and_type_for_item(item.id);\n@@ -1003,40 +992,8 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                     encode_stability(this.rbml_w, stab);\n                     encode_deprecation(this.rbml_w, depr);\n                 });\n-\n-                // Iterate down the trait items, emitting them. We rely on the\n-                // assumption that all of the actually implemented trait items\n-                // appear first in the impl structure, in the same order they do\n-                // in the ast. This is a little sketchy.\n-                let num_implemented_methods = ast_items.len();\n-                for (i, &trait_item_def_id) in items.iter().enumerate() {\n-                    let ast_item = if i < num_implemented_methods {\n-                        Some(&ast_items[i])\n-                    } else {\n-                        None\n-                    };\n-\n-                    match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n-                        ty::ConstTraitItem(ref associated_const) => {\n-                            self.encode_info_for_associated_const(&associated_const,\n-                                                                  item.id,\n-                                                                  ast_item)\n-                        }\n-                        ty::MethodTraitItem(ref method_type) => {\n-                            self.encode_info_for_method(&method_type,\n-                                                        false,\n-                                                        item.id,\n-                                                        ast_item)\n-                        }\n-                        ty::TypeTraitItem(ref associated_type) => {\n-                            self.encode_info_for_associated_type(&associated_type,\n-                                                                 item.id,\n-                                                                 ast_item)\n-                        }\n-                    }\n-                }\n             }\n-            hir::ItemTrait(_, _, _, ref ms) => {\n+            hir::ItemTrait(_, _, _, _) => {\n                 self.record(def_id, |this| {\n                     encode_def_id_and_key(ecx, this.rbml_w, def_id);\n                     encode_family(this.rbml_w, 'I');\n@@ -1081,114 +1038,222 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                     // Encode inherent implementations for this trait.\n                     encode_inherent_implementations(ecx, this.rbml_w, def_id);\n                 });\n+            }\n+            hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n+                // these are encoded separately\n+            }\n+        }\n+    }\n \n-                // Now output the trait item info for each trait item.\n-                let r = tcx.trait_item_def_ids(def_id);\n-                for (i, &item_def_id) in r.iter().enumerate() {\n-                    assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n+    /// In some cases, along with the item itself, we also\n+    /// encode some sub-items. Usually we want some info from the item\n+    /// so it's easier to do that here then to wait until we would encounter\n+    /// normally in the visitor walk.\n+    fn encode_addl_info_for_item(&mut self,\n+                                 item: &hir::Item) {\n+        let def_id = self.ecx.tcx.map.local_def_id(item.id);\n+        match item.node {\n+            hir::ItemStatic(..) |\n+            hir::ItemConst(..) |\n+            hir::ItemFn(..) |\n+            hir::ItemMod(..) |\n+            hir::ItemForeignMod(..) |\n+            hir::ItemExternCrate(..) |\n+            hir::ItemUse(..) |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemTy(..) => {\n+                // no sub-item recording needed in these cases\n+            }\n+            hir::ItemEnum(..) => {\n+                self.encode_enum_variant_info(def_id, &item.vis);\n+            }\n+            hir::ItemStruct(ref struct_def, _) => {\n+                self.encode_addl_struct_info(def_id, struct_def.id(), item);\n+            }\n+            hir::ItemImpl(_, _, _, _, _, ref ast_items) => {\n+                self.encode_addl_impl_info(def_id, item.id, ast_items);\n+            }\n+            hir::ItemTrait(_, _, _, ref trait_items) => {\n+                self.encode_addl_trait_info(def_id, trait_items);\n+            }\n+        }\n+    }\n \n-                    self.record(item_def_id.def_id(), |this| {\n-                        this.encode_parent_item(def_id);\n+    fn encode_addl_struct_info(&mut self,\n+                               def_id: DefId,\n+                               struct_def_id: ast::NodeId,\n+                               item: &hir::Item) {\n+        let ecx = self.ecx;\n+        let def = ecx.tcx.lookup_adt_def(def_id);\n+        let variant = def.struct_variant();\n \n-                        let stab = tcx.lookup_stability(item_def_id.def_id());\n-                        let depr = tcx.lookup_deprecation(item_def_id.def_id());\n-                        encode_stability(this.rbml_w, stab);\n-                        encode_deprecation(this.rbml_w, depr);\n+        for field in &variant.fields {\n+            self.encode_field(field);\n+        }\n \n-                        let trait_item_type =\n-                            tcx.impl_or_trait_item(item_def_id.def_id());\n-                        let is_nonstatic_method;\n-                        match trait_item_type {\n-                            ty::ConstTraitItem(associated_const) => {\n-                                encode_name(this.rbml_w, associated_const.name);\n-                                encode_def_id_and_key(ecx, this.rbml_w, associated_const.def_id);\n-                                this.encode_visibility(associated_const.vis);\n+        // If this is a tuple-like struct, encode the type of the constructor.\n+        match variant.kind {\n+            ty::VariantKind::Struct => {\n+                // no value for structs like struct Foo { ... }\n+            }\n+            ty::VariantKind::Tuple | ty::VariantKind::Unit => {\n+                // there is a value for structs like `struct\n+                // Foo()` and `struct Foo`\n+                self.encode_info_for_struct_ctor(item.name,\n+                                                       struct_def_id,\n+                                                       variant,\n+                                                       item.id);\n+            }\n+        }\n+    }\n \n-                                encode_family(this.rbml_w, 'C');\n+    fn encode_addl_impl_info(&mut self,\n+                             def_id: DefId,\n+                             impl_id: ast::NodeId,\n+                             ast_items: &[hir::ImplItem]) {\n+        let ecx = self.ecx;\n+        let impl_items = ecx.tcx.impl_items.borrow();\n+        let items = &impl_items[&def_id];\n+\n+        // Iterate down the trait items, emitting them. We rely on the\n+        // assumption that all of the actually implemented trait items\n+        // appear first in the impl structure, in the same order they do\n+        // in the ast. This is a little sketchy.\n+        let num_implemented_methods = ast_items.len();\n+        for (i, &trait_item_def_id) in items.iter().enumerate() {\n+            let ast_item = if i < num_implemented_methods {\n+                Some(&ast_items[i])\n+            } else {\n+                None\n+            };\n+\n+            match self.ecx.tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n+                ty::ConstTraitItem(ref associated_const) => {\n+                    self.encode_info_for_associated_const(&associated_const,\n+                                                          impl_id,\n+                                                          ast_item)\n+                }\n+                ty::MethodTraitItem(ref method_type) => {\n+                    self.encode_info_for_method(&method_type,\n+                                                false,\n+                                                impl_id,\n+                                                ast_item)\n+                }\n+                ty::TypeTraitItem(ref associated_type) => {\n+                    self.encode_info_for_associated_type(&associated_type,\n+                                                         impl_id,\n+                                                         ast_item)\n+                }\n+            }\n+        }\n+    }\n \n-                                this.encode_bounds_and_type_for_item(\n-                                    ecx.local_id(associated_const.def_id));\n+    fn encode_addl_trait_info(&mut self,\n+                              def_id: DefId,\n+                              trait_items: &[hir::TraitItem]) {\n+        // Now output the trait item info for each trait item.\n+        let ecx = self.ecx;\n+        let tcx = self.ecx.tcx;\n+        let r = tcx.trait_item_def_ids(def_id);\n+        for (&item_def_id, trait_item) in r.iter().zip(trait_items) {\n+            assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n-                                is_nonstatic_method = false;\n+            self.record(item_def_id.def_id(), |this| {\n+                this.encode_parent_item(def_id);\n+\n+                let stab = tcx.lookup_stability(item_def_id.def_id());\n+                let depr = tcx.lookup_deprecation(item_def_id.def_id());\n+                encode_stability(this.rbml_w, stab);\n+                encode_deprecation(this.rbml_w, depr);\n+\n+                let trait_item_type =\n+                    tcx.impl_or_trait_item(item_def_id.def_id());\n+                let is_nonstatic_method;\n+                match trait_item_type {\n+                    ty::ConstTraitItem(associated_const) => {\n+                        encode_name(this.rbml_w, associated_const.name);\n+                        encode_def_id_and_key(ecx, this.rbml_w, associated_const.def_id);\n+                        this.encode_visibility(associated_const.vis);\n+\n+                        encode_family(this.rbml_w, 'C');\n+\n+                        this.encode_bounds_and_type_for_item(\n+                            ecx.local_id(associated_const.def_id));\n+\n+                        is_nonstatic_method = false;\n+                    }\n+                    ty::MethodTraitItem(method_ty) => {\n+                        let method_def_id = item_def_id.def_id();\n+\n+                        this.encode_method_ty_fields(&method_ty);\n+\n+                        match method_ty.explicit_self {\n+                            ty::ExplicitSelfCategory::Static => {\n+                                encode_family(this.rbml_w,\n+                                              STATIC_METHOD_FAMILY);\n                             }\n-                            ty::MethodTraitItem(method_ty) => {\n-                                let method_def_id = item_def_id.def_id();\n-\n-                                this.encode_method_ty_fields(&method_ty);\n-\n-                                match method_ty.explicit_self {\n-                                    ty::ExplicitSelfCategory::Static => {\n-                                        encode_family(this.rbml_w,\n-                                                      STATIC_METHOD_FAMILY);\n-                                    }\n-                                    _ => {\n-                                        encode_family(this.rbml_w,\n-                                                      METHOD_FAMILY);\n-                                    }\n-                                }\n-                                this.encode_bounds_and_type_for_item(ecx.local_id(method_def_id));\n-\n-                                is_nonstatic_method = method_ty.explicit_self !=\n-                                    ty::ExplicitSelfCategory::Static;\n+                            _ => {\n+                                encode_family(this.rbml_w,\n+                                              METHOD_FAMILY);\n                             }\n-                            ty::TypeTraitItem(associated_type) => {\n-                                encode_name(this.rbml_w, associated_type.name);\n-                                encode_def_id_and_key(ecx, this.rbml_w, associated_type.def_id);\n-                                encode_item_sort(this.rbml_w, 't');\n-                                encode_family(this.rbml_w, 'y');\n+                        }\n+                        this.encode_bounds_and_type_for_item(ecx.local_id(method_def_id));\n \n-                                if let Some(ty) = associated_type.ty {\n-                                    this.encode_type(ty);\n-                                }\n+                        is_nonstatic_method = method_ty.explicit_self !=\n+                            ty::ExplicitSelfCategory::Static;\n+                    }\n+                    ty::TypeTraitItem(associated_type) => {\n+                        encode_name(this.rbml_w, associated_type.name);\n+                        encode_def_id_and_key(ecx, this.rbml_w, associated_type.def_id);\n+                        encode_item_sort(this.rbml_w, 't');\n+                        encode_family(this.rbml_w, 'y');\n+\n+                        if let Some(ty) = associated_type.ty {\n+                            this.encode_type(ty);\n+                        }\n \n-                                is_nonstatic_method = false;\n-                            }\n+                        is_nonstatic_method = false;\n+                    }\n+                }\n+\n+                encode_attributes(this.rbml_w, &trait_item.attrs);\n+                match trait_item.node {\n+                    hir::ConstTraitItem(_, ref default) => {\n+                        if default.is_some() {\n+                            encode_item_sort(this.rbml_w, 'C');\n+                        } else {\n+                            encode_item_sort(this.rbml_w, 'c');\n                         }\n \n-                        let trait_item = &ms[i];\n-                        encode_attributes(this.rbml_w, &trait_item.attrs);\n-                        match trait_item.node {\n-                            hir::ConstTraitItem(_, ref default) => {\n-                                if default.is_some() {\n-                                    encode_item_sort(this.rbml_w, 'C');\n-                                } else {\n-                                    encode_item_sort(this.rbml_w, 'c');\n-                                }\n-\n-                                encode_inlined_item(ecx, this.rbml_w,\n-                                                    InlinedItemRef::TraitItem(def_id, trait_item));\n-                                this.encode_mir(trait_item.id);\n-                            }\n-                            hir::MethodTraitItem(ref sig, ref body) => {\n-                                // If this is a static method, we've already\n-                                // encoded this.\n-                                if is_nonstatic_method {\n-                                    this.encode_bounds_and_type_for_item(\n-                                        ecx.local_id(item_def_id.def_id()));\n-                                }\n-\n-                                if body.is_some() {\n-                                    encode_item_sort(this.rbml_w, 'p');\n-                                    encode_inlined_item(ecx,\n-                                                        this.rbml_w,\n-                                                        InlinedItemRef::TraitItem(\n-                                                            def_id,\n-                                                            trait_item));\n-                                    this.encode_mir(trait_item.id);\n-                                } else {\n-                                    encode_item_sort(this.rbml_w, 'r');\n-                                }\n-                                this.encode_method_argument_names(&sig.decl);\n-                            }\n+                        encode_inlined_item(ecx, this.rbml_w,\n+                                            InlinedItemRef::TraitItem(def_id, trait_item));\n+                        this.encode_mir(trait_item.id);\n+                    }\n+                    hir::MethodTraitItem(ref sig, ref body) => {\n+                        // If this is a static method, we've already\n+                        // encoded this.\n+                        if is_nonstatic_method {\n+                            this.encode_bounds_and_type_for_item(\n+                                ecx.local_id(item_def_id.def_id()));\n+                        }\n \n-                            hir::TypeTraitItem(..) => {}\n+                        if body.is_some() {\n+                            encode_item_sort(this.rbml_w, 'p');\n+                            encode_inlined_item(ecx,\n+                                                this.rbml_w,\n+                                                InlinedItemRef::TraitItem(\n+                                                    def_id,\n+                                                    trait_item));\n+                            this.encode_mir(trait_item.id);\n+                        } else {\n+                            encode_item_sort(this.rbml_w, 'r');\n                         }\n-                    });\n+                        this.encode_method_argument_names(&sig.decl);\n+                    }\n+\n+                    hir::TypeTraitItem(..) => {}\n                 }\n-            }\n-            hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n-                // these are encoded separately\n-            }\n+            });\n         }\n     }\n \n@@ -1251,9 +1316,10 @@ impl<'a, 'ecx, 'tcx, 'encoder> Visitor<'tcx> for EncodeVisitor<'a, 'ecx, 'tcx, '\n         intravisit::walk_expr(self, ex);\n         self.index.encode_info_for_expr(ex);\n     }\n-    fn visit_item(&mut self, i: &'tcx hir::Item) {\n-        intravisit::walk_item(self, i);\n-        self.index.encode_info_for_item(i);\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        intravisit::walk_item(self, item);\n+        self.index.encode_info_for_item(item);\n+        self.index.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);"}]}