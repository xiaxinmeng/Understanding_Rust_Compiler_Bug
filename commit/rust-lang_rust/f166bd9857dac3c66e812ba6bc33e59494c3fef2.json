{"sha": "f166bd9857dac3c66e812ba6bc33e59494c3fef2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNjZiZDk4NTdkYWMzYzY2ZTgxMmJhNmJjMzNlNTk0OTRjM2ZlZjI=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2017-04-24T04:14:32Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2017-05-21T08:48:03Z"}, "message": "Make RangeInclusive just a two-field struct\n\nNot being an enum improves ergonomics, especially since NonEmpty could be Empty.  It can still be iterable without an extra \"done\" bit by making the range have !(start <= end), which is even possible without changing the Step trait.\n\nImplements RFC 1980", "tree": {"sha": "d29f84b35bd2428ade46b8282c69f593a9f8645b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d29f84b35bd2428ade46b8282c69f593a9f8645b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f166bd9857dac3c66e812ba6bc33e59494c3fef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f166bd9857dac3c66e812ba6bc33e59494c3fef2", "html_url": "https://github.com/rust-lang/rust/commit/f166bd9857dac3c66e812ba6bc33e59494c3fef2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f166bd9857dac3c66e812ba6bc33e59494c3fef2/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bd9e1f5e6e9832691d033f1cc32409f5e2a9145", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bd9e1f5e6e9832691d033f1cc32409f5e2a9145", "html_url": "https://github.com/rust-lang/rust/commit/0bd9e1f5e6e9832691d033f1cc32409f5e2a9145"}], "stats": {"total": 383, "additions": 134, "deletions": 249}, "files": [{"sha": "bc8566e8cbeb375b6b066b0ddd368eb7ee883dfb", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=f166bd9857dac3c66e812ba6bc33e59494c3fef2", "patch": "@@ -106,16 +106,10 @@ impl<T> RangeArgument<T> for Range<T> {\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<T> RangeArgument<T> for RangeInclusive<T> {\n     fn start(&self) -> Bound<&T> {\n-        match *self {\n-            RangeInclusive::Empty{ ref at }            => Included(at),\n-            RangeInclusive::NonEmpty { ref start, .. } => Included(start),\n-        }\n+        Included(&self.start)\n     }\n     fn end(&self) -> Bound<&T> {\n-        match *self {\n-            RangeInclusive::Empty{ ref at }            => Excluded(at),\n-            RangeInclusive::NonEmpty { ref end, .. }   => Included(end),\n-        }\n+        Included(&self.end)\n     }\n }\n "}, {"sha": "a6fde7e5d6dee2b9734cd233d5fd5622ceecfc71", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 52, "deletions": 120, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=f166bd9857dac3c66e812ba6bc33e59494c3fef2", "patch": "@@ -403,61 +403,35 @@ impl<A: Step + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        use ops::RangeInclusive::*;\n-\n-        // this function has a sort of odd structure due to borrowck issues\n-        // we may need to replace self.range, so borrows of start and end need to end early\n-\n-        let (finishing, n) = match self.range {\n-            Empty { .. } => return None, // empty iterators yield no values\n-\n-            NonEmpty { ref mut start, ref mut end } => {\n-                let rev = self.step_by.is_negative();\n-\n-                // march start towards (maybe past!) end and yield the old value\n-                if (rev && start >= end) ||\n-                   (!rev && start <= end)\n-                {\n-                    match start.step(&self.step_by) {\n-                        Some(mut n) => {\n-                            mem::swap(start, &mut n);\n-                            (None, Some(n)) // yield old value, remain non-empty\n-                        },\n-                        None => {\n-                            let mut n = end.clone();\n-                            mem::swap(start, &mut n);\n-                            (None, Some(n)) // yield old value, remain non-empty\n-                        }\n-                    }\n-                } else {\n-                    // found range in inconsistent state (start at or past end), so become empty\n-                    (Some(end.replace_zero()), None)\n-                }\n-            }\n-        };\n+        let rev = self.step_by.is_negative();\n \n-        // turn into an empty iterator if we've reached the end\n-        if let Some(end) = finishing {\n-            self.range = Empty { at: end };\n+        if (rev && self.range.start >= self.range.end) ||\n+           (!rev && self.range.start <= self.range.end)\n+        {\n+            match self.range.start.step(&self.step_by) {\n+                Some(n) => {\n+                    Some(mem::replace(&mut self.range.start, n))\n+                },\n+                None => {\n+                    let last = self.range.start.replace_one();\n+                    self.range.end.replace_zero();\n+                    self.step_by.replace_one();\n+                    Some(last)\n+                },\n+            }\n+        }\n+        else {\n+            None\n         }\n-\n-        n\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        use ops::RangeInclusive::*;\n-\n-        match self.range {\n-            Empty { .. } => (0, Some(0)),\n-\n-            NonEmpty { ref start, ref end } =>\n-                match Step::steps_between(start,\n-                                          end,\n-                                          &self.step_by) {\n-                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n-                    None       => (0, None)\n-                }\n+        match Step::steps_between(&self.range.start,\n+                                  &self.range.end,\n+                                  &self.step_by) {\n+            Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+            None       => (0, None)\n         }\n     }\n }\n@@ -583,56 +557,27 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> where\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        use ops::RangeInclusive::*;\n-\n-        // this function has a sort of odd structure due to borrowck issues\n-        // we may need to replace self, so borrows of self.start and self.end need to end early\n-\n-        let (finishing, n) = match *self {\n-            Empty { .. } => (None, None), // empty iterators yield no values\n-\n-            NonEmpty { ref mut start, ref mut end } => {\n-                if start == end {\n-                    (Some(end.replace_one()), Some(start.replace_one()))\n-                } else if start < end {\n-                    let mut n = start.add_one();\n-                    mem::swap(&mut n, start);\n-\n-                    // if the iterator is done iterating, it will change from\n-                    // NonEmpty to Empty to avoid unnecessary drops or clones,\n-                    // we'll reuse either start or end (they are equal now, so\n-                    // it doesn't matter which) to pull out end, we need to swap\n-                    // something back in\n-\n-                    (if n == *end { Some(end.replace_one()) } else { None },\n-                    // ^ are we done yet?\n-                    Some(n)) // < the value to output\n-                } else {\n-                    (Some(start.replace_one()), None)\n-                }\n-            }\n-        };\n-\n-        // turn into an empty iterator if this is the last value\n-        if let Some(end) = finishing {\n-            *self = Empty { at: end };\n+        use cmp::Ordering::*;\n+\n+        match self.start.partial_cmp(&self.end) {\n+            Some(Less) => {\n+                let n = self.start.add_one();\n+                Some(mem::replace(&mut self.start, n))\n+            },\n+            Some(Equal) => {\n+                let last = self.start.replace_one();\n+                self.end.replace_zero();\n+                Some(last)\n+            },\n+            _ => None,\n         }\n-\n-        n\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        use ops::RangeInclusive::*;\n-\n-        match *self {\n-            Empty { .. } => (0, Some(0)),\n-\n-            NonEmpty { ref start, ref end } =>\n-                match Step::steps_between_by_one(start, end) {\n-                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n-                    None => (0, None),\n-                }\n+        match Step::steps_between_by_one(&self.start, &self.end) {\n+            Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+            None => (0, None),\n         }\n     }\n }\n@@ -644,33 +589,20 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        use ops::RangeInclusive::*;\n-\n-        // see Iterator::next for comments\n-\n-        let (finishing, n) = match *self {\n-            Empty { .. } => return None,\n-\n-            NonEmpty { ref mut start, ref mut end } => {\n-                if start == end {\n-                    (Some(start.replace_one()), Some(end.replace_one()))\n-                } else if start < end {\n-                    let mut n = end.sub_one();\n-                    mem::swap(&mut n, end);\n-\n-                    (if n == *start { Some(start.replace_one()) } else { None },\n-                     Some(n))\n-                } else {\n-                    (Some(end.replace_one()), None)\n-                }\n-            }\n-        };\n-\n-        if let Some(start) = finishing {\n-            *self = Empty { at: start };\n+        use cmp::Ordering::*;\n+\n+        match self.start.partial_cmp(&self.end) {\n+            Some(Less) => {\n+                let n = self.end.sub_one();\n+                Some(mem::replace(&mut self.end, n))\n+            },\n+            Some(Equal) => {\n+                let last = self.end.replace_zero();\n+                self.start.replace_one();\n+                Some(last)\n+            },\n+            _ => None,\n         }\n-\n-        n\n     }\n }\n "}, {"sha": "59c3a9a8afa02ed2a0c6623a1aafb1a3078211b8", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=f166bd9857dac3c66e812ba6bc33e59494c3fef2", "patch": "@@ -2271,7 +2271,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n /// fn main() {\n-///     assert_eq!((3...5), std::ops::RangeInclusive::NonEmpty{ start: 3, end: 5 });\n+///     assert_eq!((3...5), std::ops::RangeInclusive{ start: 3, end: 5 });\n ///     assert_eq!(3+4+5, (3...5).sum());\n ///\n ///     let arr = [0, 1, 2, 3];\n@@ -2281,45 +2281,23 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-pub enum RangeInclusive<Idx> {\n-    /// Empty range (iteration has finished)\n+pub struct RangeInclusive<Idx> {\n+    /// The lower bound of the range (inclusive).\n     #[unstable(feature = \"inclusive_range\",\n                reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n-    Empty {\n-        /// The point at which iteration finished\n-        #[unstable(feature = \"inclusive_range\",\n-                   reason = \"recently added, follows RFC\",\n-                   issue = \"28237\")]\n-        at: Idx\n-    },\n-    /// Non-empty range (iteration will yield value(s))\n+    pub start: Idx,\n+    /// The upper bound of the range (inclusive).\n     #[unstable(feature = \"inclusive_range\",\n                reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n-    NonEmpty {\n-        /// The lower bound of the range (inclusive).\n-        #[unstable(feature = \"inclusive_range\",\n-                   reason = \"recently added, follows RFC\",\n-                   issue = \"28237\")]\n-        start: Idx,\n-        /// The upper bound of the range (inclusive).\n-        #[unstable(feature = \"inclusive_range\",\n-                   reason = \"recently added, follows RFC\",\n-                   issue = \"28237\")]\n-        end: Idx,\n-    },\n+    pub end: Idx,\n }\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        use self::RangeInclusive::*;\n-\n-        match *self {\n-            Empty { ref at } => write!(fmt, \"[empty range @ {:?}]\", at),\n-            NonEmpty { ref start, ref end } => write!(fmt, \"{:?}...{:?}\", start, end),\n-        }\n+        write!(fmt, \"{:?}...{:?}\", self.start, self.end)\n     }\n }\n \n@@ -2341,9 +2319,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n-        if let &RangeInclusive::NonEmpty{ref start, ref end} = self {\n-            (*start <= item) && (item <= *end)\n-        } else { false }\n+        self.start <= item && item <= self.end\n     }\n }\n "}, {"sha": "69b9e2a6288f9b765fe11f7bc5ebefe64c4fe7a7", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 27, "deletions": 40, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=f166bd9857dac3c66e812ba6bc33e59494c3fef2", "patch": "@@ -981,95 +981,82 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => Some(&[]),\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => None,\n-            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get(slice),\n-        }\n+        if self.end == usize::max_value() { None }\n+        else { (self.start..self.end + 1).get(slice) }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => Some(&mut []),\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => None,\n-            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get_mut(slice),\n-        }\n+        if self.end == usize::max_value() { None }\n+        else { (self.start..self.end + 1).get_mut(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => &[],\n-            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get_unchecked(slice),\n-        }\n+        (self.start..self.end + 1).get_unchecked(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => &mut [],\n-            ops::RangeInclusive::NonEmpty { start, end } => {\n-                (start..end + 1).get_unchecked_mut(slice)\n-            }\n-        }\n+        (self.start..self.end + 1).get_unchecked_mut(slice)\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => &[],\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => {\n-                panic!(\"attempted to index slice up to maximum usize\");\n-            },\n-            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).index(slice),\n-        }\n+        assert!(self.end != usize::max_value(),\n+            \"attempted to index slice up to maximum usize\");\n+        (self.start..self.end + 1).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => &mut [],\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => {\n-                panic!(\"attempted to index slice up to maximum usize\");\n-            },\n-            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).index_mut(slice),\n-        }\n+        assert!(self.end != usize::max_value(),\n+            \"attempted to index slice up to maximum usize\");\n+        (self.start..self.end + 1).index_mut(slice)\n     }\n }\n \n+#[cfg(stage0)] // The bootstrap compiler has a different `...` desugar\n+fn inclusive(start: usize, end: usize) -> ops::RangeInclusive<usize> {\n+    ops::RangeInclusive { start, end }\n+}\n+#[cfg(not(stage0))]\n+fn inclusive(start: usize, end: usize) -> ops::RangeInclusive<usize> {\n+    start...end\n+}\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        (0...self.end).get(slice)\n+        inclusive(0, self.end).get(slice)\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        (0...self.end).get_mut(slice)\n+        inclusive(0, self.end).get_mut(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (0...self.end).get_unchecked(slice)\n+        inclusive(0, self.end).get_unchecked(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0...self.end).get_unchecked_mut(slice)\n+        inclusive(0, self.end).get_unchecked_mut(slice)\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        (0...self.end).index(slice)\n+        inclusive(0, self.end).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0...self.end).index_mut(slice)\n+        inclusive(0, self.end).index_mut(slice)\n     }\n }\n "}, {"sha": "ccd8ef8ae56e39bae3a9e640d8b8811c25571f3b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 19, "deletions": 40, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=f166bd9857dac3c66e812ba6bc33e59494c3fef2", "patch": "@@ -1724,15 +1724,12 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n-            match index {\n-                ops::RangeInclusive::Empty { .. } => \"\",\n-                ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n-                    panic!(\"attempted to index slice up to maximum usize\"),\n-                ops::RangeInclusive::NonEmpty { start, end } =>\n-                    self.index(start .. end+1)\n-            }\n+            assert!(index.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n+            self.index(index.start .. index.end+1)\n         }\n     }\n+\n     #[unstable(feature = \"inclusive_range\",\n                reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n@@ -1741,7 +1738,9 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n-            self.index(0...index.end)\n+            assert!(index.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n+            self.index(.. index.end+1)\n         }\n     }\n \n@@ -1751,13 +1750,9 @@ mod traits {\n     impl ops::IndexMut<ops::RangeInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n-            match index {\n-                ops::RangeInclusive::Empty { .. } => &mut self[0..0], // `&mut \"\"` doesn't work\n-                ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n-                    panic!(\"attempted to index str up to maximum usize\"),\n-                    ops::RangeInclusive::NonEmpty { start, end } =>\n-                        self.index_mut(start .. end+1)\n-            }\n+            assert!(index.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n+            self.index_mut(index.start .. index.end+1)\n         }\n     }\n     #[unstable(feature = \"inclusive_range\",\n@@ -1766,7 +1761,9 @@ mod traits {\n     impl ops::IndexMut<ops::RangeToInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n-            self.index_mut(0...index.end)\n+            assert!(index.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n+            self.index_mut(.. index.end+1)\n         }\n     }\n \n@@ -1948,45 +1945,27 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.get(slice)\n+            (self.start..self.end+1).get(slice)\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.get_mut(slice)\n+            (self.start..self.end+1).get_mut(slice)\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.get_unchecked(slice)\n+            (self.start..self.end+1).get_unchecked(slice)\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.get_unchecked_mut(slice)\n+            (self.start..self.end+1).get_unchecked_mut(slice)\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.index(slice)\n+            (self.start..self.end+1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.index_mut(slice)\n+            (self.start..self.end+1).index_mut(slice)\n         }\n     }\n "}, {"sha": "8c4cd1d0c84583b20e961f9151c0e363686dbcac", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=f166bd9857dac3c66e812ba6bc33e59494c3fef2", "patch": "@@ -22,6 +22,7 @@\n #![feature(fmt_internals)]\n #![feature(iterator_step_by)]\n #![feature(i128_type)]\n+#![feature(inclusive_range)]\n #![feature(iter_rfind)]\n #![feature(libc)]\n #![feature(nonzero)]"}, {"sha": "50aed15896c752d9cda4df08e96cb06a05f9b1ec", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=f166bd9857dac3c66e812ba6bc33e59494c3fef2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::ops::{Range, RangeFull, RangeFrom, RangeTo};\n+use core::ops::{Range, RangeFull, RangeFrom, RangeTo, RangeInclusive};\n \n // Test the Range structs without the syntactic sugar.\n \n@@ -47,3 +47,19 @@ fn test_full_range() {\n     // Not much to test.\n     let _ = RangeFull;\n }\n+\n+#[test]\n+fn test_range_inclusive() {\n+    let mut r = RangeInclusive { start: 1i8, end: 2 };\n+    assert_eq!(r.next(), Some(1));\n+    assert_eq!(r.next(), Some(2));\n+    assert_eq!(r.next(), None);\n+\n+    r = RangeInclusive { start: 127i8, end: 127 };\n+    assert_eq!(r.next(), Some(127));\n+    assert_eq!(r.next(), None);\n+\n+    r = RangeInclusive { start: -128i8, end: -128 };\n+    assert_eq!(r.next_back(), Some(-128));\n+    assert_eq!(r.next_back(), None);\n+}\n\\ No newline at end of file"}, {"sha": "d359c69d3a092842e8868c63b03d9c3fa43b9d9d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f166bd9857dac3c66e812ba6bc33e59494c3fef2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f166bd9857dac3c66e812ba6bc33e59494c3fef2", "patch": "@@ -1934,13 +1934,13 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Range(ref e1, ref e2, lims) => {\n                 use syntax::ast::RangeLimits::*;\n \n-                let (path, variant) = match (e1, e2, lims) {\n-                    (&None, &None, HalfOpen) => (\"RangeFull\", None),\n-                    (&Some(..), &None, HalfOpen) => (\"RangeFrom\", None),\n-                    (&None, &Some(..), HalfOpen) => (\"RangeTo\", None),\n-                    (&Some(..), &Some(..), HalfOpen) => (\"Range\", None),\n-                    (&None, &Some(..), Closed) => (\"RangeToInclusive\", None),\n-                    (&Some(..), &Some(..), Closed) => (\"RangeInclusive\", Some(\"NonEmpty\")),\n+                let path = match (e1, e2, lims) {\n+                    (&None, &None, HalfOpen) => \"RangeFull\",\n+                    (&Some(..), &None, HalfOpen) => \"RangeFrom\",\n+                    (&None, &Some(..), HalfOpen) => \"RangeTo\",\n+                    (&Some(..), &Some(..), HalfOpen) => \"Range\",\n+                    (&None, &Some(..), Closed) => \"RangeToInclusive\",\n+                    (&Some(..), &Some(..), Closed) => \"RangeInclusive\",\n                     (_, &None, Closed) =>\n                         panic!(self.diagnostic().span_fatal(\n                             e.span, \"inclusive range with no end\")),\n@@ -1957,7 +1957,7 @@ impl<'a> LoweringContext<'a> {\n                 let is_unit = fields.is_empty();\n                 let unstable_span = self.allow_internal_unstable(\"...\", e.span);\n                 let struct_path =\n-                    iter::once(\"ops\").chain(iter::once(path)).chain(variant)\n+                    iter::once(\"ops\").chain(iter::once(path))\n                     .collect::<Vec<_>>();\n                 let struct_path = self.std_path(unstable_span, &struct_path, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));"}]}