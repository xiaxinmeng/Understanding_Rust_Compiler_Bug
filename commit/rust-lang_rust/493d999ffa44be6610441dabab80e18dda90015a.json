{"sha": "493d999ffa44be6610441dabab80e18dda90015a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5M2Q5OTlmZmE0NGJlNjYxMDQ0MWRhYmFiODBlMThkZGE5MDAxNWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-03T17:41:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-03T17:41:13Z"}, "message": "Auto merge of #32007 - nikomatsakis:compiletest-incremental, r=alexcrichton\n\nThis PR extends compiletest to support **test revisions** and with a preliminary **incremental testing harness**. run-pass, compile-fail, and run-fail tests may be tagged with\n\n```\n// revisions: a b c d\n```\n\nThis will cause the test to be re-run four times with `--cfg {a,b,c,d}` in turn. This means you can write very closely related things using `cfg`. You can also configure the headers/expected-errors by writing `//[foo] header: value` or `//[foo]~ ERROR bar`, where `foo` is the name of your revision. See the changes to `coherence-cow.rs` as a proof of concept.\n\nThe main point of this work is to support the incremental testing harness. This PR contains an initial, unused version. The code that uses it will land later. The incremental testing harness compiles each revision in turn, and requires that the revisions have particular names (e.g., `rpass2`, `cfail3`), which tell it whether a particular revision is expected to compile or not.\n\nTwo questions:\n\n- Is there compiletest documentation anywhere I can update?\n- Should I hold off on landing the incremental testing harness until I have the code to exercise it? (That will come in a separate PR, still fixing a few details)\n\nr? @alexcrichton\ncc @rust-lang/compiler <-- new testing capabilities", "tree": {"sha": "1e8cb7a3a287236d5a56363f4f62d2f9bf0c7f94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e8cb7a3a287236d5a56363f4f62d2f9bf0c7f94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/493d999ffa44be6610441dabab80e18dda90015a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/493d999ffa44be6610441dabab80e18dda90015a", "html_url": "https://github.com/rust-lang/rust/commit/493d999ffa44be6610441dabab80e18dda90015a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/493d999ffa44be6610441dabab80e18dda90015a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e125f04a54ec65eac0ecd3cb68e180210a06fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e125f04a54ec65eac0ecd3cb68e180210a06fa", "html_url": "https://github.com/rust-lang/rust/commit/f6e125f04a54ec65eac0ecd3cb68e180210a06fa"}, {"sha": "fc4d0ecf20103e6f394e8771d11373e15ce70501", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc4d0ecf20103e6f394e8771d11373e15ce70501", "html_url": "https://github.com/rust-lang/rust/commit/fc4d0ecf20103e6f394e8771d11373e15ce70501"}], "stats": {"total": 726, "additions": 498, "deletions": 228}, "files": [{"sha": "1cae4ef090fe0b6fa6d9a69bfbaa5c5533eadfe4", "filename": "COMPILER_TESTS.md", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/493d999ffa44be6610441dabab80e18dda90015a/COMPILER_TESTS.md", "raw_url": "https://github.com/rust-lang/rust/raw/493d999ffa44be6610441dabab80e18dda90015a/COMPILER_TESTS.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COMPILER_TESTS.md?ref=493d999ffa44be6610441dabab80e18dda90015a", "patch": "@@ -42,3 +42,43 @@ whole, instead of just a few lines inside the test.\n * `ignore-test` always ignores the test\n * `ignore-lldb` and `ignore-gdb` will skip the debuginfo tests\n * `min-{gdb,lldb}-version`\n+* `should-fail` indicates that the test should fail; used for \"meta testing\",\n+  where we test the compiletest program itself to check that it will generate\n+  errors in appropriate scenarios. This header is ignored for pretty-printer tests.\n+\n+## Revisions\n+\n+Certain classes of tests support \"revisions\" (as of the time of this\n+writing, this includes run-pass, compile-fail, run-fail, and\n+incremental, though incremental tests are somewhat\n+different). Revisions allow a single test file to be used for multiple\n+tests. This is done by adding a special header at the top of the file:\n+\n+```\n+// revisions: foo bar baz\n+```\n+\n+This will result in the test being compiled (and tested) three times,\n+once with `--cfg foo`, once with `--cfg bar`, and once with `--cfg\n+baz`. You can therefore use `#[cfg(foo)]` etc within the test to tweak\n+each of these results.\n+\n+You can also customize headers and expected error messages to a particular\n+revision. To do this, add `[foo]` (or `bar`, `baz`, etc) after the `//`\n+comment, like so:\n+\n+```\n+// A flag to pass in only for cfg `foo`:\n+//[foo]compile-flags: -Z verbose\n+\n+#[cfg(foo)]\n+fn test_foo() {\n+    let x: usize = 32_u32; //[foo]~ ERROR mismatched types\n+}\n+```\n+\n+Note that not all headers have meaning when customized too a revision.\n+For example, the `ignore-test` header (and all \"ignore\" headers)\n+currently only apply to the test as a whole, not to particular\n+revisions. The only headers that are intended to really work when\n+customized to a revision are error patterns and compiler flags."}, {"sha": "99745d840f767f1c4a5b3bf972bf82e771dcbac6", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/493d999ffa44be6610441dabab80e18dda90015a/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493d999ffa44be6610441dabab80e18dda90015a/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=493d999ffa44be6610441dabab80e18dda90015a", "patch": "@@ -354,11 +354,25 @@ pub fn is_test(config: &Config, testfile: &Path) -> bool {\n }\n \n pub fn make_test(config: &Config, testpaths: &TestPaths) -> test::TestDescAndFn {\n+    let early_props = header::early_props(config, &testpaths.file);\n+\n+    // The `should-fail` annotation doesn't apply to pretty tests,\n+    // since we run the pretty printer across all tests by default.\n+    // If desired, we could add a `should-fail-pretty` annotation.\n+    let should_panic = match config.mode {\n+        Pretty => test::ShouldPanic::No,\n+        _ => if early_props.should_fail {\n+            test::ShouldPanic::Yes\n+        } else {\n+            test::ShouldPanic::No\n+        }\n+    };\n+\n     test::TestDescAndFn {\n         desc: test::TestDesc {\n             name: make_test_name(config, testpaths),\n-            ignore: header::is_test_ignored(config, &testpaths.file),\n-            should_panic: test::ShouldPanic::No,\n+            ignore: early_props.ignore,\n+            should_panic: should_panic,\n         },\n         testfn: make_test_closure(config, testpaths),\n     }"}, {"sha": "44634e4d565ff0f68158a8932f5e154eb45f596f", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/493d999ffa44be6610441dabab80e18dda90015a/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493d999ffa44be6610441dabab80e18dda90015a/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=493d999ffa44be6610441dabab80e18dda90015a", "patch": "@@ -30,8 +30,10 @@ enum WhichLine { ThisLine, FollowPrevious(usize), AdjustBackward(usize) }\n /// Goal is to enable tests both like: //~^^^ ERROR go up three\n /// and also //~^ ERROR message one for the preceding line, and\n ///          //~| ERROR message two for that same line.\n-// Load any test directives embedded in the file\n-pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n+///\n+/// If cfg is not None (i.e., in an incremental test), then we look\n+/// for `//[X]~` instead, where `X` is the current `cfg`.\n+pub fn load_errors(testfile: &Path, cfg: Option<&str>) -> Vec<ExpectedError> {\n     let rdr = BufReader::new(File::open(testfile).unwrap());\n \n     // `last_nonfollow_error` tracks the most recently seen\n@@ -44,30 +46,41 @@ pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n     // updating it in the map callback below.)\n     let mut last_nonfollow_error = None;\n \n-    rdr.lines().enumerate().filter_map(|(line_no, ln)| {\n-        parse_expected(last_nonfollow_error,\n-                       line_no + 1,\n-                       &ln.unwrap())\n-            .map(|(which, error)| {\n-                match which {\n-                    FollowPrevious(_) => {}\n-                    _ => last_nonfollow_error = Some(error.line),\n-                }\n-                error\n-            })\n-    }).collect()\n+    let tag = match cfg {\n+        Some(rev) => format!(\"//[{}]~\", rev),\n+        None => format!(\"//~\")\n+    };\n+\n+    rdr.lines()\n+       .enumerate()\n+       .filter_map(|(line_no, ln)| {\n+           parse_expected(last_nonfollow_error,\n+                          line_no + 1,\n+                          &ln.unwrap(),\n+                          &tag)\n+               .map(|(which, error)| {\n+                   match which {\n+                       FollowPrevious(_) => {}\n+                       _ => last_nonfollow_error = Some(error.line),\n+                   }\n+                   error\n+               })\n+       })\n+       .collect()\n }\n \n fn parse_expected(last_nonfollow_error: Option<usize>,\n                   line_num: usize,\n-                  line: &str) -> Option<(WhichLine, ExpectedError)> {\n-    let start = match line.find(\"//~\") { Some(i) => i, None => return None };\n-    let (follow, adjusts) = if line.char_at(start + 3) == '|' {\n+                  line: &str,\n+                  tag: &str)\n+                  -> Option<(WhichLine, ExpectedError)> {\n+    let start = match line.find(tag) { Some(i) => i, None => return None };\n+    let (follow, adjusts) = if line.char_at(start + tag.len()) == '|' {\n         (true, 0)\n     } else {\n-        (false, line[start + 3..].chars().take_while(|c| *c == '^').count())\n+        (false, line[start + tag.len()..].chars().take_while(|c| *c == '^').count())\n     };\n-    let kind_start = start + 3 + adjusts + (follow as usize);\n+    let kind_start = start + tag.len() + adjusts + (follow as usize);\n     let letters = line[kind_start..].chars();\n     let kind = letters.skip_while(|c| c.is_whitespace())\n                       .take_while(|c| !c.is_whitespace())\n@@ -91,7 +104,9 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n         (which, line)\n     };\n \n-    debug!(\"line={} which={:?} kind={:?} msg={:?}\", line_num, which, kind, msg);\n+    debug!(\"line={} tag={:?} which={:?} kind={:?} msg={:?}\",\n+           line_num, tag, which, kind, msg);\n+\n     Some((which, ExpectedError { line: line,\n                                  kind: kind,\n                                  msg: msg, }))"}, {"sha": "cf4d545a827c168972311ebaf3ec1e65bc1e7159", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 142, "deletions": 86, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/493d999ffa44be6610441dabab80e18dda90015a/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493d999ffa44be6610441dabab80e18dda90015a/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=493d999ffa44be6610441dabab80e18dda90015a", "patch": "@@ -18,11 +18,12 @@ use common::Config;\n use common;\n use util;\n \n+#[derive(Clone, Debug)]\n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n     pub error_patterns: Vec<String> ,\n     // Extra flags to pass to the compiler\n-    pub compile_flags: Option<String>,\n+    pub compile_flags: Vec<String>,\n     // Extra flags to pass when the compiled code is run (such as --bench)\n     pub run_flags: Option<String>,\n     // If present, the name of a file that this test should match when\n@@ -50,119 +51,168 @@ pub struct TestProps {\n     pub pretty_compare_only: bool,\n     // Patterns which must not appear in the output of a cfail test.\n     pub forbid_output: Vec<String>,\n+    // Revisions to test for incremental compilation.\n+    pub revisions: Vec<String>,\n }\n \n // Load any test directives embedded in the file\n pub fn load_props(testfile: &Path) -> TestProps {\n-    let mut error_patterns = Vec::new();\n-    let mut aux_builds = Vec::new();\n-    let mut exec_env = Vec::new();\n-    let mut compile_flags = None;\n-    let mut run_flags = None;\n-    let mut pp_exact = None;\n-    let mut check_lines = Vec::new();\n-    let mut build_aux_docs = false;\n-    let mut force_host = false;\n-    let mut check_stdout = false;\n-    let mut no_prefer_dynamic = false;\n-    let mut pretty_expanded = false;\n-    let mut pretty_mode = None;\n-    let mut pretty_compare_only = false;\n-    let mut forbid_output = Vec::new();\n-    iter_header(testfile, &mut |ln| {\n+    let error_patterns = Vec::new();\n+    let aux_builds = Vec::new();\n+    let exec_env = Vec::new();\n+    let run_flags = None;\n+    let pp_exact = None;\n+    let check_lines = Vec::new();\n+    let build_aux_docs = false;\n+    let force_host = false;\n+    let check_stdout = false;\n+    let no_prefer_dynamic = false;\n+    let pretty_expanded = false;\n+    let pretty_compare_only = false;\n+    let forbid_output = Vec::new();\n+    let mut props = TestProps {\n+        error_patterns: error_patterns,\n+        compile_flags: vec![],\n+        run_flags: run_flags,\n+        pp_exact: pp_exact,\n+        aux_builds: aux_builds,\n+        revisions: vec![],\n+        exec_env: exec_env,\n+        check_lines: check_lines,\n+        build_aux_docs: build_aux_docs,\n+        force_host: force_host,\n+        check_stdout: check_stdout,\n+        no_prefer_dynamic: no_prefer_dynamic,\n+        pretty_expanded: pretty_expanded,\n+        pretty_mode: format!(\"normal\"),\n+        pretty_compare_only: pretty_compare_only,\n+        forbid_output: forbid_output,\n+    };\n+    load_props_into(&mut props, testfile, None);\n+    props\n+}\n+\n+/// Load properties from `testfile` into `props`. If a property is\n+/// tied to a particular revision `foo` (indicated by writing\n+/// `//[foo]`), then the property is ignored unless `cfg` is\n+/// `Some(\"foo\")`.\n+pub fn load_props_into(props: &mut TestProps, testfile: &Path, cfg: Option<&str>)  {\n+    iter_header(testfile, cfg, &mut |ln| {\n         if let Some(ep) = parse_error_pattern(ln) {\n-           error_patterns.push(ep);\n+            props.error_patterns.push(ep);\n+        }\n+\n+        if let Some(flags) = parse_compile_flags(ln) {\n+            props.compile_flags.extend(\n+                flags\n+                    .split_whitespace()\n+                    .map(|s| s.to_owned()));\n         }\n \n-        if compile_flags.is_none() {\n-            compile_flags = parse_compile_flags(ln);\n+        if let Some(r) = parse_revisions(ln) {\n+            props.revisions.extend(r);\n         }\n \n-        if run_flags.is_none() {\n-            run_flags = parse_run_flags(ln);\n+        if props.run_flags.is_none() {\n+            props.run_flags = parse_run_flags(ln);\n         }\n \n-        if pp_exact.is_none() {\n-            pp_exact = parse_pp_exact(ln, testfile);\n+        if props.pp_exact.is_none() {\n+            props.pp_exact = parse_pp_exact(ln, testfile);\n         }\n \n-        if !build_aux_docs {\n-            build_aux_docs = parse_build_aux_docs(ln);\n+        if !props.build_aux_docs {\n+            props.build_aux_docs = parse_build_aux_docs(ln);\n         }\n \n-        if !force_host {\n-            force_host = parse_force_host(ln);\n+        if !props.force_host {\n+            props.force_host = parse_force_host(ln);\n         }\n \n-        if !check_stdout {\n-            check_stdout = parse_check_stdout(ln);\n+        if !props.check_stdout {\n+            props.check_stdout = parse_check_stdout(ln);\n         }\n \n-        if !no_prefer_dynamic {\n-            no_prefer_dynamic = parse_no_prefer_dynamic(ln);\n+        if !props.no_prefer_dynamic {\n+            props.no_prefer_dynamic = parse_no_prefer_dynamic(ln);\n         }\n \n-        if !pretty_expanded {\n-            pretty_expanded = parse_pretty_expanded(ln);\n+        if !props.pretty_expanded {\n+            props.pretty_expanded = parse_pretty_expanded(ln);\n         }\n \n-        if pretty_mode.is_none() {\n-            pretty_mode = parse_pretty_mode(ln);\n+        if let Some(m) = parse_pretty_mode(ln) {\n+            props.pretty_mode = m;\n         }\n \n-        if !pretty_compare_only {\n-            pretty_compare_only = parse_pretty_compare_only(ln);\n+        if !props.pretty_compare_only {\n+            props.pretty_compare_only = parse_pretty_compare_only(ln);\n         }\n \n         if let  Some(ab) = parse_aux_build(ln) {\n-            aux_builds.push(ab);\n+            props.aux_builds.push(ab);\n         }\n \n         if let Some(ee) = parse_exec_env(ln) {\n-            exec_env.push(ee);\n+            props.exec_env.push(ee);\n         }\n \n         if let Some(cl) =  parse_check_line(ln) {\n-            check_lines.push(cl);\n+            props.check_lines.push(cl);\n         }\n \n         if let Some(of) = parse_forbid_output(ln) {\n-            forbid_output.push(of);\n+            props.forbid_output.push(of);\n         }\n-\n-        true\n     });\n \n     for key in vec![\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n         match env::var(key) {\n             Ok(val) =>\n-                if exec_env.iter().find(|&&(ref x, _)| *x == key).is_none() {\n-                    exec_env.push((key.to_owned(), val))\n+                if props.exec_env.iter().find(|&&(ref x, _)| *x == key).is_none() {\n+                    props.exec_env.push((key.to_owned(), val))\n                 },\n             Err(..) => {}\n         }\n     }\n+}\n \n-    TestProps {\n-        error_patterns: error_patterns,\n-        compile_flags: compile_flags,\n-        run_flags: run_flags,\n-        pp_exact: pp_exact,\n-        aux_builds: aux_builds,\n-        exec_env: exec_env,\n-        check_lines: check_lines,\n-        build_aux_docs: build_aux_docs,\n-        force_host: force_host,\n-        check_stdout: check_stdout,\n-        no_prefer_dynamic: no_prefer_dynamic,\n-        pretty_expanded: pretty_expanded,\n-        pretty_mode: pretty_mode.unwrap_or(\"normal\".to_owned()),\n-        pretty_compare_only: pretty_compare_only,\n-        forbid_output: forbid_output,\n-    }\n+pub struct EarlyProps {\n+    pub ignore: bool,\n+    pub should_fail: bool,\n }\n \n-pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n+// scan the file to detect whether the test should be ignored and\n+// whether it should panic; these are two things the test runner needs\n+// to know early, before actually running the test\n+pub fn early_props(config: &Config, testfile: &Path) -> EarlyProps {\n+    let mut props = EarlyProps {\n+        ignore: false,\n+        should_fail: false,\n+    };\n+\n+    iter_header(testfile, None, &mut |ln| {\n+        props.ignore =\n+            props.ignore ||\n+            parse_name_directive(ln, \"ignore-test\") ||\n+            parse_name_directive(ln, &ignore_target(config)) ||\n+            parse_name_directive(ln, &ignore_architecture(config)) ||\n+            parse_name_directive(ln, &ignore_stage(config)) ||\n+            parse_name_directive(ln, &ignore_env(config)) ||\n+            (config.mode == common::Pretty &&\n+             parse_name_directive(ln, \"ignore-pretty\")) ||\n+            (config.target != config.host &&\n+             parse_name_directive(ln, \"ignore-cross-compile\")) ||\n+            ignore_gdb(config, ln) ||\n+            ignore_lldb(config, ln);\n+\n+        props.should_fail =\n+            props.should_fail ||\n+            parse_name_directive(ln, \"should-fail\");\n+    });\n+\n+    return props;\n+\n     fn ignore_target(config: &Config) -> String {\n         format!(\"ignore-{}\", util::get_os(&config.target))\n     }\n@@ -229,39 +279,40 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n             false\n         }\n     }\n-\n-    let val = iter_header(testfile, &mut |ln| {\n-        !parse_name_directive(ln, \"ignore-test\") &&\n-        !parse_name_directive(ln, &ignore_target(config)) &&\n-        !parse_name_directive(ln, &ignore_architecture(config)) &&\n-        !parse_name_directive(ln, &ignore_stage(config)) &&\n-        !parse_name_directive(ln, &ignore_env(config)) &&\n-        !(config.mode == common::Pretty && parse_name_directive(ln, \"ignore-pretty\")) &&\n-        !(config.target != config.host && parse_name_directive(ln, \"ignore-cross-compile\")) &&\n-        !ignore_gdb(config, ln) &&\n-        !ignore_lldb(config, ln)\n-    });\n-\n-    !val\n }\n \n-fn iter_header(testfile: &Path, it: &mut FnMut(&str) -> bool) -> bool {\n+fn iter_header(testfile: &Path,\n+               cfg: Option<&str>,\n+               it: &mut FnMut(&str)) {\n     let rdr = BufReader::new(File::open(testfile).unwrap());\n     for ln in rdr.lines() {\n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n         let ln = ln.unwrap();\n-        if ln.starts_with(\"fn\") ||\n-                ln.starts_with(\"mod\") {\n-            return true;\n-        } else {\n-            if !(it(ln.trim())) {\n-                return false;\n+        let ln = ln.trim();\n+        if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n+            return;\n+        } else if ln.starts_with(\"//[\") {\n+            // A comment like `//[foo]` is specific to revision `foo`\n+            if let Some(close_brace) = ln.find(\"]\") {\n+                let lncfg = &ln[3..close_brace];\n+                let matches = match cfg {\n+                    Some(s) => s == &lncfg[..],\n+                    None => false,\n+                };\n+                if matches {\n+                    it(&ln[close_brace+1..]);\n+                }\n+            } else {\n+                panic!(\"malformed condition directive: expected `//[foo]`, found `{}`\",\n+                       ln)\n             }\n+        } else if ln.starts_with(\"//\") {\n+            it(&ln[2..]);\n         }\n     }\n-    return true;\n+    return;\n }\n \n fn parse_error_pattern(line: &str) -> Option<String> {\n@@ -280,6 +331,11 @@ fn parse_compile_flags(line: &str) -> Option<String> {\n     parse_name_value_directive(line, \"compile-flags\")\n }\n \n+fn parse_revisions(line: &str) -> Option<Vec<String>> {\n+    parse_name_value_directive(line, \"revisions\")\n+        .map(|r| r.split_whitespace().map(|t| t.to_string()).collect())\n+}\n+\n fn parse_run_flags(line: &str) -> Option<String> {\n     parse_name_value_directive(line, \"run-flags\")\n }"}, {"sha": "1d2f560f5f65b2be2b39ecb229dc3cd50228ed54", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 194, "deletions": 97, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/493d999ffa44be6610441dabab80e18dda90015a/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493d999ffa44be6610441dabab80e18dda90015a/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=493d999ffa44be6610441dabab80e18dda90015a", "patch": "@@ -70,80 +70,128 @@ fn get_output(props: &TestProps, proc_res: &ProcRes) -> String {\n     }\n }\n \n+\n+fn for_each_revision<OP>(config: &Config, props: &TestProps, testpaths: &TestPaths,\n+                         mut op: OP)\n+    where OP: FnMut(&Config, &TestProps, &TestPaths, Option<&str>)\n+{\n+    if props.revisions.is_empty() {\n+        op(config, props, testpaths, None)\n+    } else {\n+        for revision in &props.revisions {\n+            let mut revision_props = props.clone();\n+            header::load_props_into(&mut revision_props,\n+                                    &testpaths.file,\n+                                    Some(&revision));\n+            revision_props.compile_flags.extend(vec![\n+                format!(\"--cfg\"),\n+                format!(\"{}\", revision),\n+            ]);\n+            op(config, &revision_props, testpaths, Some(revision));\n+        }\n+    }\n+}\n+\n fn run_cfail_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    for_each_revision(config, props, testpaths, run_cfail_test_revision);\n+}\n+\n+fn run_cfail_test_revision(config: &Config,\n+                           props: &TestProps,\n+                           testpaths: &TestPaths,\n+                           revision: Option<&str>) {\n     let proc_res = compile_test(config, props, testpaths);\n \n     if proc_res.status.success() {\n-        fatal_proc_rec(&format!(\"{} test compiled successfully!\", config.mode)[..],\n-                      &proc_res);\n+        fatal_proc_rec(\n+            revision,\n+            &format!(\"{} test compiled successfully!\", config.mode)[..],\n+            &proc_res);\n     }\n \n-    check_correct_failure_status(&proc_res);\n+    check_correct_failure_status(revision, &proc_res);\n \n     if proc_res.status.success() {\n-        fatal(\"process did not return an error status\");\n+        fatal(revision, \"process did not return an error status\");\n     }\n \n     let output_to_check = get_output(props, &proc_res);\n-    let expected_errors = errors::load_errors(&testpaths.file);\n+    let expected_errors = errors::load_errors(&testpaths.file, revision);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n-            fatal(\"both error pattern and expected errors specified\");\n+            fatal(revision, \"both error pattern and expected errors specified\");\n         }\n-        check_expected_errors(expected_errors, testpaths, &proc_res);\n+        check_expected_errors(revision, expected_errors, testpaths, &proc_res);\n     } else {\n-        check_error_patterns(props, testpaths, &output_to_check, &proc_res);\n+        check_error_patterns(revision, props, testpaths, &output_to_check, &proc_res);\n     }\n-    check_no_compiler_crash(&proc_res);\n-    check_forbid_output(props, &output_to_check, &proc_res);\n+    check_no_compiler_crash(revision, &proc_res);\n+    check_forbid_output(revision, props, &output_to_check, &proc_res);\n }\n \n fn run_rfail_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    for_each_revision(config, props, testpaths, run_rfail_test_revision);\n+}\n+\n+fn run_rfail_test_revision(config: &Config,\n+                           props: &TestProps,\n+                           testpaths: &TestPaths,\n+                           revision: Option<&str>) {\n     let proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        fatal_proc_rec(revision, \"compilation failed!\", &proc_res);\n     }\n \n     let proc_res = exec_compiled_test(config, props, testpaths);\n \n     // The value our Makefile configures valgrind to return on failure\n     const VALGRIND_ERR: i32 = 100;\n     if proc_res.status.code() == Some(VALGRIND_ERR) {\n-        fatal_proc_rec(\"run-fail test isn't valgrind-clean!\", &proc_res);\n+        fatal_proc_rec(revision, \"run-fail test isn't valgrind-clean!\", &proc_res);\n     }\n \n     let output_to_check = get_output(props, &proc_res);\n-    check_correct_failure_status(&proc_res);\n-    check_error_patterns(props, testpaths, &output_to_check, &proc_res);\n+    check_correct_failure_status(revision, &proc_res);\n+    check_error_patterns(revision, props, testpaths, &output_to_check, &proc_res);\n }\n \n-fn check_correct_failure_status(proc_res: &ProcRes) {\n+fn check_correct_failure_status(revision: Option<&str>, proc_res: &ProcRes) {\n     // The value the rust runtime returns on failure\n     const RUST_ERR: i32 = 101;\n     if proc_res.status.code() != Some(RUST_ERR) {\n         fatal_proc_rec(\n+            revision,\n             &format!(\"failure produced the wrong error: {}\",\n                      proc_res.status),\n             proc_res);\n     }\n }\n \n fn run_rpass_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    for_each_revision(config, props, testpaths, run_rpass_test_revision);\n+}\n+\n+fn run_rpass_test_revision(config: &Config,\n+                           props: &TestProps,\n+                           testpaths: &TestPaths,\n+                           revision: Option<&str>) {\n     let proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        fatal_proc_rec(revision, \"compilation failed!\", &proc_res);\n     }\n \n     let proc_res = exec_compiled_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"test run failed!\", &proc_res);\n+        fatal_proc_rec(revision, \"test run failed!\", &proc_res);\n     }\n }\n \n fn run_valgrind_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n+\n     if config.valgrind_path.is_none() {\n         assert!(!config.force_valgrind);\n         return run_rpass_test(config, props, testpaths);\n@@ -152,19 +200,26 @@ fn run_valgrind_test(config: &Config, props: &TestProps, testpaths: &TestPaths)\n     let mut proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        fatal_proc_rec(None, \"compilation failed!\", &proc_res);\n     }\n \n     let mut new_config = config.clone();\n     new_config.runtool = new_config.valgrind_path.clone();\n     proc_res = exec_compiled_test(&new_config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"test run failed!\", &proc_res);\n+        fatal_proc_rec(None, \"test run failed!\", &proc_res);\n     }\n }\n \n fn run_pretty_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    for_each_revision(config, props, testpaths, run_pretty_test_revision);\n+}\n+\n+fn run_pretty_test_revision(config: &Config,\n+                            props: &TestProps,\n+                            testpaths: &TestPaths,\n+                            revision: Option<&str>) {\n     if props.pp_exact.is_some() {\n         logv(config, \"testing for exact pretty-printing\".to_owned());\n     } else {\n@@ -180,16 +235,19 @@ fn run_pretty_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n \n     let mut round = 0;\n     while round < rounds {\n-        logv(config, format!(\"pretty-printing round {}\", round));\n+        logv(config, format!(\"pretty-printing round {} revision {:?}\",\n+                             round, revision));\n         let proc_res = print_source(config,\n                                     props,\n                                     testpaths,\n                                     srcs[round].to_owned(),\n                                     &props.pretty_mode);\n \n         if !proc_res.status.success() {\n-            fatal_proc_rec(&format!(\"pretty-printing failed in round {}\", round),\n-                          &proc_res);\n+            fatal_proc_rec(revision,\n+                           &format!(\"pretty-printing failed in round {} revision {:?}\",\n+                                    round, revision),\n+                           &proc_res);\n         }\n \n         let ProcRes{ stdout, .. } = proc_res;\n@@ -215,30 +273,32 @@ fn run_pretty_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n         expected = expected.replace(&cr, \"\").to_owned();\n     }\n \n-    compare_source(&expected, &actual);\n+    compare_source(revision, &expected, &actual);\n \n     // If we're only making sure that the output matches then just stop here\n     if props.pretty_compare_only { return; }\n \n     // Finally, let's make sure it actually appears to remain valid code\n     let proc_res = typecheck_source(config, props, testpaths, actual);\n-\n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"pretty-printed source does not typecheck\", &proc_res);\n+        fatal_proc_rec(revision, \"pretty-printed source does not typecheck\", &proc_res);\n     }\n+\n     if !props.pretty_expanded { return }\n \n     // additionally, run `--pretty expanded` and try to build it.\n     let proc_res = print_source(config, props, testpaths, srcs[round].clone(), \"expanded\");\n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"pretty-printing (expanded) failed\", &proc_res);\n+        fatal_proc_rec(revision, \"pretty-printing (expanded) failed\", &proc_res);\n     }\n \n     let ProcRes{ stdout: expanded_src, .. } = proc_res;\n     let proc_res = typecheck_source(config, props, testpaths, expanded_src);\n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"pretty-printed source (expanded) does not typecheck\",\n-                      &proc_res);\n+        fatal_proc_rec(\n+            revision,\n+            \"pretty-printed source (expanded) does not typecheck\",\n+            &proc_res);\n     }\n \n     return;\n@@ -275,16 +335,16 @@ fn run_pretty_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n                             \"-L\".to_owned(),\n                             aux_dir.to_str().unwrap().to_owned());\n         args.extend(split_maybe_args(&config.target_rustcflags));\n-        args.extend(split_maybe_args(&props.compile_flags));\n+        args.extend(props.compile_flags.iter().cloned());\n         return ProcArgs {\n             prog: config.rustc_path.to_str().unwrap().to_owned(),\n             args: args,\n         };\n     }\n \n-    fn compare_source(expected: &str, actual: &str) {\n+    fn compare_source(revision: Option<&str>, expected: &str, actual: &str) {\n         if expected != actual {\n-            error(\"pretty-printed source does not match expected source\");\n+            error(revision, \"pretty-printed source does not match expected source\");\n             println!(\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n@@ -322,7 +382,7 @@ actual:\\n\\\n                             \"-L\".to_owned(),\n                             aux_dir.to_str().unwrap().to_owned());\n         args.extend(split_maybe_args(&config.target_rustcflags));\n-        args.extend(split_maybe_args(&props.compile_flags));\n+        args.extend(props.compile_flags.iter().cloned());\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         return ProcArgs {\n             prog: config.rustc_path.to_str().unwrap().to_owned(),\n@@ -332,6 +392,8 @@ actual:\\n\\\n }\n \n fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n+\n     let mut config = Config {\n         target_rustcflags: cleanup_debug_info_options(&config.target_rustcflags),\n         host_rustcflags: cleanup_debug_info_options(&config.host_rustcflags),\n@@ -349,7 +411,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testpaths: &TestPa\n     // compile test file (it should have 'compile-flags:-g' in the header)\n     let compiler_run_result = compile_test(config, props, testpaths);\n     if !compiler_run_result.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &compiler_run_result);\n+        fatal_proc_rec(None, \"compilation failed!\", &compiler_run_result);\n     }\n \n     let exe_file = make_exe_name(config, testpaths);\n@@ -441,7 +503,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testpaths: &TestPa\n \n             let tool_path = match config.android_cross_path.to_str() {\n                 Some(x) => x.to_owned(),\n-                None => fatal(\"cannot find android cross path\")\n+                None => fatal(None, \"cannot find android cross path\")\n             };\n \n             let debugger_script = make_out_name(config, testpaths, \"debugger.script\");\n@@ -580,7 +642,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testpaths: &TestPa\n     }\n \n     if !debugger_run_result.status.success() {\n-        fatal(\"gdb failed to execute\");\n+        fatal(None, \"gdb failed to execute\");\n     }\n \n     check_debugger_output(&debugger_run_result, &check_lines);\n@@ -600,8 +662,10 @@ fn find_rust_src_root(config: &Config) -> Option<PathBuf> {\n }\n \n fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n+\n     if config.lldb_python_dir.is_none() {\n-        fatal(\"Can't run LLDB test because LLDB's python path is not set.\");\n+        fatal(None, \"Can't run LLDB test because LLDB's python path is not set.\");\n     }\n \n     let mut config = Config {\n@@ -615,7 +679,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testpaths: &TestP\n     // compile test file (it should have 'compile-flags:-g' in the header)\n     let compile_result = compile_test(config, props, testpaths);\n     if !compile_result.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &compile_result);\n+        fatal_proc_rec(None, \"compilation failed!\", &compile_result);\n     }\n \n     let exe_file = make_exe_name(config, testpaths);\n@@ -692,7 +756,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testpaths: &TestP\n                                        &rust_src_root);\n \n     if !debugger_run_result.status.success() {\n-        fatal_proc_rec(\"Error while running LLDB\", &debugger_run_result);\n+        fatal_proc_rec(None, \"Error while running LLDB\", &debugger_run_result);\n     }\n \n     check_debugger_output(&debugger_run_result, &check_lines);\n@@ -725,7 +789,7 @@ fn cmd2procres(config: &Config, testpaths: &TestPaths, cmd: &mut Command)\n              String::from_utf8(stderr).unwrap())\n         },\n         Err(e) => {\n-            fatal(&format!(\"Failed to setup Python process for \\\n+            fatal(None, &format!(\"Failed to setup Python process for \\\n                             LLDB script: {}\", e))\n         }\n     };\n@@ -775,7 +839,7 @@ fn parse_debugger_commands(testpaths: &TestPaths, debugger_prefix: &str)\n                 });\n             }\n             Err(e) => {\n-                fatal(&format!(\"Error while parsing debugger commands: {}\", e))\n+                fatal(None, &format!(\"Error while parsing debugger commands: {}\", e))\n             }\n         }\n         counter += 1;\n@@ -857,19 +921,21 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n             }\n         }\n         if i != num_check_lines {\n-            fatal_proc_rec(&format!(\"line not found in debugger output: {}\",\n+            fatal_proc_rec(None, &format!(\"line not found in debugger output: {}\",\n                                     check_lines.get(i).unwrap()),\n                           debugger_run_result);\n         }\n     }\n }\n \n-fn check_error_patterns(props: &TestProps,\n+fn check_error_patterns(revision: Option<&str>,\n+                        props: &TestProps,\n                         testpaths: &TestPaths,\n                         output_to_check: &str,\n                         proc_res: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        fatal(&format!(\"no error pattern specified in {:?}\",\n+        fatal(revision,\n+              &format!(\"no error pattern specified in {:?}\",\n                        testpaths.file.display()));\n     }\n     let mut next_err_idx = 0;\n@@ -891,44 +957,50 @@ fn check_error_patterns(props: &TestProps,\n \n     let missing_patterns = &props.error_patterns[next_err_idx..];\n     if missing_patterns.len() == 1 {\n-        fatal_proc_rec(&format!(\"error pattern '{}' not found!\", missing_patterns[0]),\n-                      proc_res);\n+        fatal_proc_rec(\n+            revision,\n+            &format!(\"error pattern '{}' not found!\", missing_patterns[0]),\n+            proc_res);\n     } else {\n         for pattern in missing_patterns {\n-            error(&format!(\"error pattern '{}' not found!\", *pattern));\n+            error(revision, &format!(\"error pattern '{}' not found!\", *pattern));\n         }\n-        fatal_proc_rec(\"multiple error patterns not found\", proc_res);\n+        fatal_proc_rec(revision, \"multiple error patterns not found\", proc_res);\n     }\n }\n \n-fn check_no_compiler_crash(proc_res: &ProcRes) {\n+fn check_no_compiler_crash(revision: Option<&str>, proc_res: &ProcRes) {\n     for line in proc_res.stderr.lines() {\n         if line.starts_with(\"error: internal compiler error:\") {\n-            fatal_proc_rec(\"compiler encountered internal error\",\n-                          proc_res);\n+            fatal_proc_rec(revision,\n+                           \"compiler encountered internal error\",\n+                           proc_res);\n         }\n     }\n }\n \n-fn check_forbid_output(props: &TestProps,\n+fn check_forbid_output(revision: Option<&str>,\n+                       props: &TestProps,\n                        output_to_check: &str,\n                        proc_res: &ProcRes) {\n     for pat in &props.forbid_output {\n         if output_to_check.contains(pat) {\n-            fatal_proc_rec(\"forbidden pattern found in compiler output\", proc_res);\n+            fatal_proc_rec(revision,\n+                           \"forbidden pattern found in compiler output\",\n+                           proc_res);\n         }\n     }\n }\n \n-fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n+fn check_expected_errors(revision: Option<&str>,\n+                         expected_errors: Vec<errors::ExpectedError>,\n                          testpaths: &TestPaths,\n                          proc_res: &ProcRes) {\n-\n     // true if we found the error in question\n     let mut found_flags = vec![false; expected_errors.len()];\n \n     if proc_res.status.success() {\n-        fatal(\"process did not return an error status\");\n+        fatal_proc_rec(revision, \"process did not return an error status\", proc_res);\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n@@ -944,23 +1016,6 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n                                   (acc_help || ee.kind == \"help:\", acc_note ||\n                                    ee.kind == \"note:\"));\n \n-    fn prefix_matches(line: &str, prefix: &str) -> bool {\n-        use std::ascii::AsciiExt;\n-        // On windows just translate all '\\' path separators to '/'\n-        let line = line.replace(r\"\\\", \"/\");\n-        if cfg!(windows) {\n-            line.to_ascii_lowercase().starts_with(&prefix.to_ascii_lowercase())\n-        } else {\n-            line.starts_with(prefix)\n-        }\n-    }\n-\n-    // A multi-line error will have followup lines which start with a space\n-    // or open paren.\n-    fn continuation( line: &str) -> bool {\n-        line.starts_with(\" \") || line.starts_with(\"(\")\n-    }\n-\n     // Scan and extract our error/warning messages,\n     // which look like:\n     //    filename:line1:col1: line2:col2: *error:* msg\n@@ -970,6 +1025,8 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n     //\n     // This pattern is ambiguous on windows, because filename may contain\n     // a colon, so any path prefix must be detected and removed first.\n+    let mut unexpected = 0;\n+    let mut not_found = 0;\n     for line in proc_res.stderr.lines() {\n         let mut was_expected = false;\n         let mut prev = 0;\n@@ -991,9 +1048,11 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n                         break;\n                     }\n                 }\n-                if (prefix_matches(line, &prefixes[i]) || continuation(line)) &&\n+                if\n+                    (prefix_matches(line, &prefixes[i]) || continuation(line)) &&\n                     line.contains(&ee.kind) &&\n-                    line.contains(&ee.msg) {\n+                    line.contains(&ee.msg)\n+                {\n                     found_flags[i] = true;\n                     was_expected = true;\n                     break;\n@@ -1008,20 +1067,44 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n         }\n \n         if !was_expected && is_unexpected_compiler_message(line, expect_help, expect_note) {\n-            fatal_proc_rec(&format!(\"unexpected compiler message: '{}'\",\n-                                    line),\n-                          proc_res);\n+            error(revision, &format!(\"unexpected compiler message: '{}'\", line));\n+            unexpected += 1;\n         }\n     }\n \n     for (i, &flag) in found_flags.iter().enumerate() {\n         if !flag {\n             let ee = &expected_errors[i];\n-            fatal_proc_rec(&format!(\"expected {} on line {} not found: {}\",\n-                                    ee.kind, ee.line, ee.msg),\n-                          proc_res);\n+            error(revision, &format!(\"expected {} on line {} not found: {}\",\n+                                     ee.kind, ee.line, ee.msg));\n+            not_found += 1;\n         }\n     }\n+\n+    if unexpected > 0 || not_found > 0 {\n+        fatal_proc_rec(\n+            revision,\n+            &format!(\"{} unexpected errors found, {} expected errors not found\",\n+                     unexpected, not_found),\n+            proc_res);\n+    }\n+\n+    fn prefix_matches(line: &str, prefix: &str) -> bool {\n+        use std::ascii::AsciiExt;\n+        // On windows just translate all '\\' path separators to '/'\n+        let line = line.replace(r\"\\\", \"/\");\n+        if cfg!(windows) {\n+            line.to_ascii_lowercase().starts_with(&prefix.to_ascii_lowercase())\n+        } else {\n+            line.starts_with(prefix)\n+        }\n+    }\n+\n+    // A multi-line error will have followup lines which start with a space\n+    // or open paren.\n+    fn continuation( line: &str) -> bool {\n+        line.starts_with(\" \") || line.starts_with(\"(\")\n+    }\n }\n \n fn is_unexpected_compiler_message(line: &str, expect_help: bool, expect_note: bool) -> bool {\n@@ -1184,7 +1267,7 @@ fn document(config: &Config,\n                         \"-o\".to_owned(),\n                         out_dir.to_str().unwrap().to_owned(),\n                         testpaths.file.to_str().unwrap().to_owned()];\n-    args.extend(split_maybe_args(&props.compile_flags));\n+    args.extend(props.compile_flags.iter().cloned());\n     let args = ProcArgs {\n         prog: config.rustdoc_path.to_str().unwrap().to_owned(),\n         args: args,\n@@ -1286,6 +1369,7 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n                                      None);\n         if !auxres.status.success() {\n             fatal_proc_rec(\n+                None,\n                 &format!(\"auxiliary build of {:?} failed to compile: \",\n                         aux_testpaths.file.display()),\n                 &auxres);\n@@ -1369,7 +1453,7 @@ fn make_compile_args<F>(config: &Config,\n     } else {\n         args.extend(split_maybe_args(&config.target_rustcflags));\n     }\n-    args.extend(split_maybe_args(&props.compile_flags));\n+    args.extend(props.compile_flags.iter().cloned());\n     return ProcArgs {\n         prog: config.rustc_path.to_str().unwrap().to_owned(),\n         args: args,\n@@ -1537,13 +1621,20 @@ fn maybe_dump_to_stdout(config: &Config, out: &str, err: &str) {\n     }\n }\n \n-fn error(err: &str) { println!(\"\\nerror: {}\", err); }\n+fn error(revision: Option<&str>, err: &str) {\n+    match revision {\n+        Some(rev) => println!(\"\\nerror in revision `{}`: {}\", rev, err),\n+        None => println!(\"\\nerror: {}\", err)\n+    }\n+}\n \n-fn fatal(err: &str) -> ! { error(err); panic!(); }\n+fn fatal(revision: Option<&str>, err: &str) -> ! {\n+    error(revision, err); panic!();\n+}\n \n-fn fatal_proc_rec(err: &str, proc_res: &ProcRes) -> ! {\n-    print!(\"\\n\\\n-error: {}\\n\\\n+fn fatal_proc_rec(revision: Option<&str>, err: &str, proc_res: &ProcRes) -> ! {\n+    error(revision, err);\n+    print!(\"\\\n status: {}\\n\\\n command: {}\\n\\\n stdout:\\n\\\n@@ -1555,7 +1646,7 @@ stderr:\\n\\\n {}\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-             err, proc_res.status, proc_res.cmdline, proc_res.stdout,\n+             proc_res.status, proc_res.cmdline, proc_res.stdout,\n              proc_res.stderr);\n     panic!();\n }\n@@ -1753,20 +1844,22 @@ fn check_ir_with_filecheck(config: &Config, testpaths: &TestPaths) -> ProcRes {\n }\n \n fn run_codegen_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n \n     if config.llvm_bin_path.is_none() {\n-        fatal(\"missing --llvm-bin-path\");\n+        fatal(None, \"missing --llvm-bin-path\");\n     }\n \n     let mut proc_res = compile_test_and_save_ir(config, props, testpaths);\n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        fatal_proc_rec(None, \"compilation failed!\", &proc_res);\n     }\n \n     proc_res = check_ir_with_filecheck(config, testpaths);\n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"verification with 'FileCheck' failed\",\n-                      &proc_res);\n+        fatal_proc_rec(None,\n+                       \"verification with 'FileCheck' failed\",\n+                       &proc_res);\n     }\n }\n \n@@ -1782,13 +1875,15 @@ fn charset() -> &'static str {\n }\n \n fn run_rustdoc_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n+\n     let out_dir = output_base_name(config, testpaths);\n     let _ = fs::remove_dir_all(&out_dir);\n     ensure_dir(&out_dir);\n \n     let proc_res = document(config, props, testpaths, &out_dir);\n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"rustdoc failed!\", &proc_res);\n+        fatal_proc_rec(None, \"rustdoc failed!\", &proc_res);\n     }\n     let root = find_rust_src_root(config).unwrap();\n \n@@ -1799,18 +1894,20 @@ fn run_rustdoc_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n                                   .arg(out_dir)\n                                   .arg(&testpaths.file));\n     if !res.status.success() {\n-        fatal_proc_rec(\"htmldocck failed!\", &res);\n+        fatal_proc_rec(None, \"htmldocck failed!\", &res);\n     }\n }\n \n fn run_codegen_units_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n+\n     let proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n-        fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        fatal_proc_rec(None, \"compilation failed!\", &proc_res);\n     }\n \n-    check_no_compiler_crash(&proc_res);\n+    check_no_compiler_crash(None, &proc_res);\n \n     let prefix = \"TRANS_ITEM \";\n \n@@ -1821,7 +1918,7 @@ fn run_codegen_units_test(config: &Config, props: &TestProps, testpaths: &TestPa\n         .map(|s| (&s[prefix.len()..]).to_string())\n         .collect();\n \n-    let expected: HashSet<String> = errors::load_errors(&testpaths.file)\n+    let expected: HashSet<String> = errors::load_errors(&testpaths.file, None)\n         .iter()\n         .map(|e| e.msg.trim().to_string())\n         .collect();"}, {"sha": "6a2d1bac49381f825be56c04635a8d0367726a6f", "filename": "src/test/compile-fail/coherence-cow.rs", "status": "renamed", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/493d999ffa44be6610441dabab80e18dda90015a/src%2Ftest%2Fcompile-fail%2Fcoherence-cow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493d999ffa44be6610441dabab80e18dda90015a/src%2Ftest%2Fcompile-fail%2Fcoherence-cow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cow.rs?ref=493d999ffa44be6610441dabab80e18dda90015a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: a b c\n+\n // aux-build:coherence_lib.rs\n \n // pretty-expanded FIXME #23616\n@@ -22,7 +24,14 @@ use lib::{Remote,Pair};\n \n pub struct Cover<T>(T);\n \n-impl<T> Remote for Pair<T,Cover<T>> { }\n-//~^ ERROR E0210\n+#[cfg(a)]\n+impl<T> Remote for Pair<T,Cover<T>> { } //[a]~ ERROR E0210\n+\n+#[cfg(b)]\n+impl<T> Remote for Pair<Cover<T>,T> { } //[b]~ ERROR E0210\n+\n+#[cfg(c)]\n+impl<T,U> Remote for Pair<Cover<T>,U> { }\n+//[c]~^ ERROR type parameter `T` must be used as the type parameter for some local type\n \n fn main() { }", "previous_filename": "src/test/compile-fail/coherence-cow-1.rs"}, {"sha": "95b4e1a33cccd0c25705218e15bbdb6dbd6b5088", "filename": "src/test/compile-fail/meta-expected-error-correct-rev.rs", "status": "renamed", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/493d999ffa44be6610441dabab80e18dda90015a/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-correct-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493d999ffa44be6610441dabab80e18dda90015a/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-correct-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-correct-rev.rs?ref=493d999ffa44be6610441dabab80e18dda90015a", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:coherence_lib.rs\n+// revisions: a\n+// pretty-expanded FIXME #23616\n \n-// Test that it's not ok for T to appear uncovered\n+// Counterpart to `meta-expected-error-wrong-rev.rs`\n \n-extern crate coherence_lib as lib;\n-use lib::{Remote,Pair};\n-\n-pub struct Cover<T>(T);\n-\n-impl<T,U> Remote for Pair<Cover<T>,U> { }\n-//~^ ERROR type parameter `T` must be used as the type parameter for some local type\n+#[cfg(a)]\n+fn foo() {\n+    let x: u32 = 22_usize; //[a]~ ERROR mismatched types\n+}\n \n fn main() { }", "previous_filename": "src/test/compile-fail/coherence-cow-no-cover.rs"}, {"sha": "084c6ed4f4b4113bd006ff6572ae181758fda620", "filename": "src/test/compile-fail/meta-expected-error-wrong-rev.rs", "status": "renamed", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/493d999ffa44be6610441dabab80e18dda90015a/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-wrong-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493d999ffa44be6610441dabab80e18dda90015a/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-wrong-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-wrong-rev.rs?ref=493d999ffa44be6610441dabab80e18dda90015a", "patch": "@@ -8,20 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:coherence_lib.rs\n-\n-// Test that the `Pair` type reports an error if it contains type\n-// parameters, even when they are covered by local types. This test\n-// was originally intended to test the opposite, but the rules changed\n-// with RFC 1023 and this became illegal.\n-\n+// revisions: a\n+// should-fail\n // pretty-expanded FIXME #23616\n \n-extern crate coherence_lib as lib;\n-use lib::{Remote,Pair};\n-\n-pub struct Cover<T>(T);\n+// This is a \"meta-test\" of the compilertest framework itself.  In\n+// particular, it includes the right error message, but the message\n+// targets the wrong revision, so we expect the execution to fail.\n+// See also `meta-expected-error-correct-rev.rs`.\n \n-impl<T> Remote for Pair<Cover<T>,T> { } //~ ERROR E0210\n+#[cfg(a)]\n+fn foo() {\n+    let x: u32 = 22_usize; //[b]~ ERROR mismatched types\n+}\n \n fn main() { }", "previous_filename": "src/test/compile-fail/coherence-cow-2.rs"}, {"sha": "bf521d4b4e5e4eb638634be687fea8785bf2da3e", "filename": "src/test/run-fail/meta-revision-bad.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/493d999ffa44be6610441dabab80e18dda90015a/src%2Ftest%2Frun-fail%2Fmeta-revision-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493d999ffa44be6610441dabab80e18dda90015a/src%2Ftest%2Frun-fail%2Fmeta-revision-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmeta-revision-bad.rs?ref=493d999ffa44be6610441dabab80e18dda90015a", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Meta test for compiletest: check that when we give the wrong error\n+// patterns, the test fails.\n+\n+// revisions: foo bar\n+// should-fail\n+//[foo] error-pattern:bar\n+//[bar] error-pattern:foo\n+\n+#[cfg(foo)] fn die() {panic!(\"foo\");}\n+#[cfg(bar)] fn die() {panic!(\"bar\");}\n+\n+fn main() { die(); }"}, {"sha": "f74ec39fdf27a031234680707277e75e410d01e6", "filename": "src/test/run-fail/meta-revision-ok.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/493d999ffa44be6610441dabab80e18dda90015a/src%2Ftest%2Frun-fail%2Fmeta-revision-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493d999ffa44be6610441dabab80e18dda90015a/src%2Ftest%2Frun-fail%2Fmeta-revision-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmeta-revision-ok.rs?ref=493d999ffa44be6610441dabab80e18dda90015a", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Meta test for compiletest: check that when we give the right error\n+// patterns, the test passes. See all `meta-revision-bad.rs`.\n+\n+// revisions: foo bar\n+//[foo] error-pattern:foo\n+//[bar] error-pattern:bar\n+\n+#[cfg(foo)] fn die() {panic!(\"foo\");}\n+#[cfg(bar)] fn die() {panic!(\"bar\");}\n+\n+fn main() { die(); }"}]}