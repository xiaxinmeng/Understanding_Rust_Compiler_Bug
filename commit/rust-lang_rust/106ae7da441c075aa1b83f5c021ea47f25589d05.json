{"sha": "106ae7da441c075aa1b83f5c021ea47f25589d05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNmFlN2RhNDQxYzA3NWFhMWI4M2Y1YzAyMWVhNDdmMjU1ODlkMDU=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@cs.washington.edu", "date": "2016-03-26T05:57:03Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-02T13:32:57Z"}, "message": "Invalid upcast comparison cleanup", "tree": {"sha": "aebdb2dedbc7826e92f5502024ee6ed65875892d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aebdb2dedbc7826e92f5502024ee6ed65875892d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/106ae7da441c075aa1b83f5c021ea47f25589d05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/106ae7da441c075aa1b83f5c021ea47f25589d05", "html_url": "https://github.com/rust-lang/rust/commit/106ae7da441c075aa1b83f5c021ea47f25589d05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/106ae7da441c075aa1b83f5c021ea47f25589d05/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8687949a29aaf8e33718a33154f9d9b65d39a6be", "url": "https://api.github.com/repos/rust-lang/rust/commits/8687949a29aaf8e33718a33154f9d9b65d39a6be", "html_url": "https://github.com/rust-lang/rust/commit/8687949a29aaf8e33718a33154f9d9b65d39a6be"}], "stats": {"total": 189, "additions": 93, "deletions": 96}, "files": [{"sha": "fee6d066e7c26669bbf824f88f58f62a1e13a1e3", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/106ae7da441c075aa1b83f5c021ea47f25589d05/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/106ae7da441c075aa1b83f5c021ea47f25589d05/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=106ae7da441c075aa1b83f5c021ea47f25589d05", "patch": "@@ -68,7 +68,7 @@ name\n [ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)                         | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n [inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                                       | warn    | `#[inline(always)]` is a bad idea in most cases\n [invalid_regex](https://github.com/Manishearth/rust-clippy/wiki#invalid_regex)                                       | deny    | finds invalid regular expressions in `Regex::new(_)` invocations\n-[invalid_upcast_comparisons](https://github.com/Manishearth/rust-clippy/wiki#invalid_upcast_comparisons)             | warn    | a comparison involving an term's upcasting to be within the range of the other side of the term is always true or false\n+[invalid_upcast_comparisons](https://github.com/Manishearth/rust-clippy/wiki#invalid_upcast_comparisons)             | warn    | a comparison involving an upcast which is always true or false\n [items_after_statements](https://github.com/Manishearth/rust-clippy/wiki#items_after_statements)                     | warn    | finds blocks where an item comes after a statement\n [iter_next_loop](https://github.com/Manishearth/rust-clippy/wiki#iter_next_loop)                                     | warn    | for-looping over `_.next()` which is probably not intended\n [len_without_is_empty](https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty)                         | warn    | traits and impls that have `.len()` but not `.is_empty()`"}, {"sha": "5e4b3e673cd0d562473d9c22f631602b53e40628", "filename": "src/types.rs", "status": "modified", "additions": 68, "deletions": 91, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/106ae7da441c075aa1b83f5c021ea47f25589d05/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106ae7da441c075aa1b83f5c021ea47f25589d05/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=106ae7da441c075aa1b83f5c021ea47f25589d05", "patch": "@@ -643,32 +643,21 @@ enum AbsurdComparisonResult {\n     InequalityImpossible,\n }\n \n-enum Rel {\n-    Lt,\n-    Le,\n-}\n \n-// Put the expression in the form lhs < rhs or lhs <= rhs.\n-fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n-                                -> Option<(Rel, &'a Expr, &'a Expr)> {\n-    match op {\n-        BiLt => Some((Rel::Lt, lhs, rhs)),\n-        BiLe => Some((Rel::Le, lhs, rhs)),\n-        BiGt => Some((Rel::Lt, rhs, lhs)),\n-        BiGe => Some((Rel::Le, rhs, lhs)),\n-        _ => None,\n-    }\n-}\n \n fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n                                 -> Option<(ExtremeExpr<'a>, AbsurdComparisonResult)> {\n     use types::ExtremeType::*;\n     use types::AbsurdComparisonResult::*;\n+    use utils::comparisons::*;\n     type Extr<'a> = ExtremeExpr<'a>;\n \n     let normalized = normalize_comparison(op, lhs, rhs);\n-    if normalized.is_none() { return None; } // Could be an if let, but this prevents rightward drift\n-    let (rel, normalized_lhs, normalized_rhs) = normalized.expect(\"Unreachable-- is none check above\");\n+    let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n+        val\n+    } else {\n+        return None;\n+    };\n \n     let lx = detect_extreme_expr(cx, normalized_lhs);\n     let rx = detect_extreme_expr(cx, normalized_rhs);\n@@ -799,8 +788,7 @@ impl LateLintPass for AbsurdExtremeComparisons {\n /// **Example:** `let x : u8 = ...; (x as u32) > 300`\n declare_lint! {\n     pub INVALID_UPCAST_COMPARISONS, Warn,\n-    \"a comparison involving an term's upcasting to be within the range of the other side of the \\\n-    term is always true or false\"\n+    \"a comparison involving an upcast which is always true or false\"\n }\n \n pub struct InvalidUpcastComparisons;\n@@ -811,46 +799,39 @@ impl LintPass for InvalidUpcastComparisons {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n enum FullInt {\n     S(i64),\n     U(u64),\n }\n \n-use std;\n use std::cmp::Ordering;\n \n impl FullInt {\n     #[allow(cast_sign_loss)]\n-    fn cmp_s_u(s: &i64, u: &u64) -> std::cmp::Ordering {\n-        if *s < 0 {\n+    fn cmp_s_u(s: i64, u: u64) -> Ordering {\n+        if s < 0 {\n             Ordering::Less\n-        } else if *u > (i64::max_value() as u64) {\n+        } else if u > (i64::max_value() as u64) {\n             Ordering::Greater\n         } else {\n-            (*s as u64).cmp(u)\n+            (s as u64).cmp(&u)\n         }\n     }\n }\n \n-impl PartialEq for FullInt {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.cmp(other) == Ordering::Equal\n-    }\n-}\n-impl Eq for FullInt {}\n-\n impl PartialOrd for FullInt {\n-    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         Some(match (self, other) {\n-            (&FullInt::S(ref s), &FullInt::S(ref o)) => s.cmp(o),\n-            (&FullInt::U(ref s), &FullInt::U(ref o)) => s.cmp(o),\n-            (&FullInt::S(ref s), &FullInt::U(ref o)) => Self::cmp_s_u(s, o),\n-            (&FullInt::U(ref s), &FullInt::S(ref o)) => Self::cmp_s_u(o, s).reverse(),\n+            (&FullInt::S(s), &FullInt::S(o)) => s.cmp(&o),\n+            (&FullInt::U(s), &FullInt::U(o)) => s.cmp(&o),\n+            (&FullInt::S(s), &FullInt::U(o)) => Self::cmp_s_u(s, o),\n+            (&FullInt::U(s), &FullInt::S(o)) => Self::cmp_s_u(o, s).reverse(),\n         })\n     }\n }\n impl Ord for FullInt {\n-    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+    fn cmp(&self, other: &Self) -> Ordering {\n         self.partial_cmp(other).expect(\"partial_cmp for FullInt can never return None\")\n     }\n }\n@@ -896,19 +877,15 @@ fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n                     I8(x) => FullInt::S(x as i64),\n                     I16(x) => FullInt::S(x as i64),\n                     I32(x) => FullInt::S(x as i64),\n-                    Isize(x) => FullInt::S(match x {\n-                        Is32(x_) => x_ as i64,\n-                        Is64(x_) => x_\n-                    }),\n+                    Isize(Is32(x)) => FullInt::S(x as i64),\n+                    Isize(Is64(x)) |\n                     I64(x) => FullInt::S(x),\n                     InferSigned(x) => FullInt::S(x as i64),\n                     U8(x) => FullInt::U(x as u64),\n                     U16(x) => FullInt::U(x as u64),\n                     U32(x) => FullInt::U(x as u64),\n-                    Usize(x) => FullInt::U(match x {\n-                        Us32(x_) => x_ as u64,\n-                        Us64(x_) => x_,\n-                    }),\n+                    Usize(Us32(x)) => FullInt::U(x as u64),\n+                    Usize(Us64(x)) |\n                     U64(x) => FullInt::U(x),\n                     Infer(x) => FullInt::U(x as u64),\n                 })\n@@ -920,59 +897,59 @@ fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n     }\n }\n \n+fn err_upcast_comparison(cx: &LateContext, span: &Span, expr: &Expr, always: bool) {\n+    if let ExprCast(ref cast_val, _) = expr.node {\n+        span_lint(\n+            cx,\n+            INVALID_UPCAST_COMPARISONS,\n+            *span,\n+            &format!(\n+                \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n+                snippet(cx, cast_val.span, \"the expression\"),\n+                if always { \"true\" } else { \"false\" },\n+            )\n+        );\n+    }\n+}\n+\n+fn upcast_comparison_bounds_err(\n+        cx: &LateContext, span: &Span, rel: comparisons::Rel,\n+        lhs_bounds: Option<(FullInt, FullInt)>, lhs: &Expr, rhs: &Expr, invert: bool) {\n+    use utils::comparisons::*;\n+\n+    if let Some(nlb) = lhs_bounds {\n+        if let Some(norm_rhs_val) = node_as_const_fullint(cx, rhs) {\n+            if match rel {\n+                Rel::Lt => if invert { norm_rhs_val < nlb.0 } else { nlb.1 < norm_rhs_val },\n+                Rel::Le => if invert { norm_rhs_val <= nlb.0  } else { nlb.1 <= norm_rhs_val },\n+            } {\n+                err_upcast_comparison(cx, &span, lhs, true)\n+            } else if match rel {\n+                Rel::Lt => if invert { norm_rhs_val >= nlb.1 } else { nlb.0 >= norm_rhs_val },\n+                Rel::Le => if invert { norm_rhs_val > nlb.1 } else { nlb.0 > norm_rhs_val },\n+            } {\n+                err_upcast_comparison(cx, &span, lhs, false)\n+            }\n+        }\n+    }\n+}\n+\n impl LateLintPass for InvalidUpcastComparisons {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n-            let normalized = normalize_comparison(cmp.node, lhs, rhs);\n-            if normalized.is_none() { return; }\n-            let (rel, normalized_lhs, normalized_rhs) = normalized.expect(\"Unreachable-- is none check above\");\n+\n+            let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n+            let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n+                val\n+            } else {\n+                return;\n+            };\n \n             let lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n             let rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n \n-            let msg = \"Because of the numeric bounds prior to casting, this expression is always \";\n-\n-            if let Some(nlb) = lhs_bounds {\n-                if let Some(norm_rhs_val) = node_as_const_fullint(cx, normalized_rhs) {\n-                    if match rel {\n-                        Rel::Lt => nlb.1 < norm_rhs_val,\n-                        Rel::Le => nlb.1 <= norm_rhs_val,\n-                    } {\n-                        // Expression is always true\n-                        cx.span_lint(INVALID_UPCAST_COMPARISONS,\n-                                     expr.span,\n-                                     &format!(\"{}{}.\", msg, \"true\"));\n-                    } else if match rel {\n-                        Rel::Lt => nlb.0 >= norm_rhs_val,\n-                        Rel::Le => nlb.0 > norm_rhs_val,\n-                    } {\n-                        // Expression is always false\n-                        cx.span_lint(INVALID_UPCAST_COMPARISONS,\n-                                     expr.span,\n-                                     &format!(\"{}{}.\", msg, \"false\"));\n-                    }\n-                }\n-            } else if let Some(nrb) = rhs_bounds {\n-                if let Some(norm_lhs_val) = node_as_const_fullint(cx, normalized_lhs) {\n-                    if match rel {\n-                        Rel::Lt => norm_lhs_val < nrb.0,\n-                        Rel::Le => norm_lhs_val <= nrb.0,\n-                    } {\n-                        // Expression is always true\n-                        cx.span_lint(INVALID_UPCAST_COMPARISONS,\n-                                     expr.span,\n-                                     &format!(\"{}{}.\", msg, \"true\"));\n-                    } else if match rel {\n-                        Rel::Lt => norm_lhs_val >= nrb.1,\n-                        Rel::Le => norm_lhs_val > nrb.1,\n-                    } {\n-                        // Expression is always false\n-                        cx.span_lint(INVALID_UPCAST_COMPARISONS,\n-                                     expr.span,\n-                                     &format!(\"{}{}.\", msg, \"false\"));\n-                    }\n-                }\n-            }\n+            upcast_comparison_bounds_err(cx, &expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n+            upcast_comparison_bounds_err(cx, &expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n         }\n     }\n }"}, {"sha": "2222c31a4f93aeeec65c179911a70ed22f00fb2c", "filename": "src/utils/comparisons.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/106ae7da441c075aa1b83f5c021ea47f25589d05/src%2Futils%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106ae7da441c075aa1b83f5c021ea47f25589d05/src%2Futils%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fcomparisons.rs?ref=106ae7da441c075aa1b83f5c021ea47f25589d05", "patch": "@@ -0,0 +1,19 @@\n+use rustc_front::hir::{BinOp_, Expr};\n+\n+#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n+pub enum Rel {\n+    Lt,\n+    Le,\n+}\n+\n+/// Put the expression in the form  `lhs < rhs` or `lhs <= rhs`.\n+pub fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n+                                -> Option<(Rel, &'a Expr, &'a Expr)> {\n+    match op {\n+        BinOp_::BiLt => Some((Rel::Lt, lhs, rhs)),\n+        BinOp_::BiLe => Some((Rel::Le, lhs, rhs)),\n+        BinOp_::BiGt => Some((Rel::Lt, rhs, lhs)),\n+        BinOp_::BiGe => Some((Rel::Le, rhs, lhs)),\n+        _ => None,\n+    }\n+}"}, {"sha": "7607ef31486b18ccd28e679a2b27ed66e733d938", "filename": "src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/106ae7da441c075aa1b83f5c021ea47f25589d05/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106ae7da441c075aa1b83f5c021ea47f25589d05/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=106ae7da441c075aa1b83f5c021ea47f25589d05", "patch": "@@ -19,6 +19,7 @@ use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n \n+pub mod comparisons;\n pub mod conf;\n mod hir;\n pub use self::hir::{SpanlessEq, SpanlessHash};"}, {"sha": "f94b4959287c3d6426632e3d379d69075619b3eb", "filename": "tests/compile-fail/invalid_upcast_comparisons.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/106ae7da441c075aa1b83f5c021ea47f25589d05/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106ae7da441c075aa1b83f5c021ea47f25589d05/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs?ref=106ae7da441c075aa1b83f5c021ea47f25589d05", "patch": "@@ -7,13 +7,13 @@ fn main() {\n     let zero: u32 = 0;\n     let u8_max: u8 = 255;\n \n-    (u8_max as u32) > 300; //~ERROR Because of the numeric bounds prior to casting, this expression is always false.\n+    (u8_max as u32) > 300; //~ERROR because of the numeric bounds on `u8_max` prior to casting, this expression is always false\n     (u8_max as u32) > 20;\n \n-    (zero as i32) < -5; //~ERROR Because of the numeric bounds prior to casting, this expression is always false.\n+    (zero as i32) < -5; //~ERROR because of the numeric bounds on `zero` prior to casting, this expression is always false\n     (zero as i32) < 10;\n \n-    -5 < (zero as i32); //~ERROR Because of the numeric bounds prior to casting, this expression is always true.\n-    0 <= (zero as i32); //~ERROR Because of the numeric bounds prior to casting, this expression is always true.\n+    -5 < (zero as i32); //~ERROR because of the numeric bounds on `zero` prior to casting, this expression is always true\n+    0 <= (zero as i32); //~ERROR because of the numeric bounds on `zero` prior to casting, this expression is always true\n     0 < (zero as i32);\n }"}]}