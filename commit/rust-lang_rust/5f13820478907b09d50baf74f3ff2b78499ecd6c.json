{"sha": "5f13820478907b09d50baf74f3ff2b78499ecd6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMTM4MjA0Nzg5MDdiMDlkNTBiYWY3NGYzZmYyYjc4NDk5ZWNkNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-21T04:34:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-21T04:34:04Z"}, "message": "Auto merge of #70205 - Centril:rollup-0jq9k4s, r=Centril\n\nRollup of 16 pull requests\n\nSuccessful merges:\n\n - #65097 (Make std::sync::Arc compatible with ThreadSanitizer)\n - #69033 (Use generator resume arguments in the async/await lowering)\n - #69997 (add `Option::{zip,zip_with}` methods under \"option_zip\" gate)\n - #70038 (Remove the call that makes miri fail)\n - #70058 (can_begin_literal_maybe_minus: `true` on `\"-\"? lit` NTs.)\n - #70111 (BTreeMap: remove shared root)\n - #70139 (add delay_span_bug to TransmuteSizeDiff, just to be sure)\n - #70165 (Remove the erase regions MIR transform)\n - #70166 (Derive PartialEq, Eq and Hash for RangeInclusive)\n - #70176 (Add tests for #58319 and #65131)\n - #70177 (Fix oudated comment for NamedRegionMap)\n - #70184 (expand_include: set `.directory` to dir of included file.)\n - #70187 (more clippy fixes)\n - #70188 (Clean up E0439 explanation)\n - #70189 (Abi::is_signed: assert that we are a Scalar)\n - #70194 (#[must_use] on split_off())\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "f8a09a299d9c7e09f562913e7aadefd3c4f12f0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8a09a299d9c7e09f562913e7aadefd3c4f12f0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f13820478907b09d50baf74f3ff2b78499ecd6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f13820478907b09d50baf74f3ff2b78499ecd6c", "html_url": "https://github.com/rust-lang/rust/commit/5f13820478907b09d50baf74f3ff2b78499ecd6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f13820478907b09d50baf74f3ff2b78499ecd6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1057dc97afce39ff6a224966ece3ed438af4c1f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1057dc97afce39ff6a224966ece3ed438af4c1f5", "html_url": "https://github.com/rust-lang/rust/commit/1057dc97afce39ff6a224966ece3ed438af4c1f5"}, {"sha": "54285db640453d2beec91423cb8cc792f52797f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/54285db640453d2beec91423cb8cc792f52797f2", "html_url": "https://github.com/rust-lang/rust/commit/54285db640453d2beec91423cb8cc792f52797f2"}], "stats": {"total": 2121, "additions": 1478, "deletions": 643}, "files": [{"sha": "cae64ef6665bb0b64fc5c827cca265f97c7104dd", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -370,12 +370,17 @@ def to_string(self):\n                 (\"(len: %i)\" % self.__val.get_wrapped_value()['map']['length']))\n \n     def children(self):\n-        root = self.__val.get_wrapped_value()['map']['root']\n-        node_ptr = root['node']\n-        i = 0\n-        for child in children_of_node(node_ptr, root['height'], False):\n-            yield (str(i), child)\n-            i = i + 1\n+        prev_idx = None\n+        innermap = GdbValue(self.__val.get_wrapped_value()['map'])\n+        if innermap.get_wrapped_value()['length'] > 0:\n+            root = GdbValue(innermap.get_wrapped_value()['root'])\n+            type_name = str(root.type.ty.name).replace('core::option::Option<', '')[:-1]\n+            root = root.get_wrapped_value().cast(gdb.lookup_type(type_name))\n+            node_ptr = root['node']\n+            i = 0\n+            for child in children_of_node(node_ptr, root['height'], False):\n+                yield (str(i), child)\n+                i = i + 1\n \n \n class RustStdBTreeMapPrinter(object):\n@@ -391,13 +396,16 @@ def to_string(self):\n                 (\"(len: %i)\" % self.__val.get_wrapped_value()['length']))\n \n     def children(self):\n-        root = self.__val.get_wrapped_value()['root']\n-        node_ptr = root['node']\n-        i = 0\n-        for child in children_of_node(node_ptr, root['height'], True):\n-            yield (str(i), child[0])\n-            yield (str(i), child[1])\n-            i = i + 1\n+        if self.__val.get_wrapped_value()['length'] > 0:\n+            root = GdbValue(self.__val.get_wrapped_value()['root'])\n+            type_name = str(root.type.ty.name).replace('core::option::Option<', '')[:-1]\n+            root = root.get_wrapped_value().cast(gdb.lookup_type(type_name))\n+            node_ptr = root['node']\n+            i = 0\n+            for child in children_of_node(node_ptr, root['height'], True):\n+                yield (str(i), child[0])\n+                yield (str(i), child[1])\n+                i = i + 1\n \n \n class RustStdStringPrinter(object):"}, {"sha": "3ba7befc0460924215d4890e5df2fa494ac5f5f0", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 116, "deletions": 83, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -122,7 +122,7 @@ use UnderflowResult::*;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n-    root: node::Root<K, V>,\n+    root: Option<node::Root<K, V>>,\n     length: usize,\n }\n \n@@ -147,10 +147,11 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n         {\n             match node.force() {\n                 Leaf(leaf) => {\n-                    let mut out_tree = BTreeMap { root: node::Root::new_leaf(), length: 0 };\n+                    let mut out_tree = BTreeMap { root: Some(node::Root::new_leaf()), length: 0 };\n \n                     {\n-                        let mut out_node = match out_tree.root.as_mut().force() {\n+                        let root = out_tree.root.as_mut().unwrap();\n+                        let mut out_node = match root.as_mut().force() {\n                             Leaf(leaf) => leaf,\n                             Internal(_) => unreachable!(),\n                         };\n@@ -169,9 +170,14 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                 }\n                 Internal(internal) => {\n                     let mut out_tree = clone_subtree(internal.first_edge().descend());\n+                    out_tree.ensure_root_is_owned();\n \n                     {\n-                        let mut out_node = out_tree.root.push_level();\n+                        // Ideally we'd use the return of ensure_root_is_owned\n+                        // instead of re-unwrapping here but unfortunately that\n+                        // borrows all of out_tree and we need access to the\n+                        // length below.\n+                        let mut out_node = out_tree.root.as_mut().unwrap().push_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n@@ -190,7 +196,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                                 (root, length)\n                             };\n \n-                            out_node.push(k, v, subroot);\n+                            out_node.push(k, v, subroot.unwrap_or_else(|| node::Root::new_leaf()));\n                             out_tree.length += 1 + sublength;\n                         }\n                     }\n@@ -203,9 +209,9 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n         if self.is_empty() {\n             // Ideally we'd call `BTreeMap::new` here, but that has the `K:\n             // Ord` constraint, which this method lacks.\n-            BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n+            BTreeMap { root: None, length: 0 }\n         } else {\n-            clone_subtree(self.root.as_ref())\n+            clone_subtree(self.root.as_ref().unwrap().as_ref())\n         }\n     }\n \n@@ -271,14 +277,14 @@ where\n     type Key = K;\n \n     fn get(&self, key: &Q) -> Option<&K> {\n-        match search::search_tree(self.root.as_ref(), key) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().0),\n             GoDown(_) => None,\n         }\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_kv()\n@@ -290,7 +296,7 @@ where\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         self.ensure_root_is_owned();\n-        match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut(), &key) {\n+        match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut()?.as_mut(), &key) {\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n                 VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData }\n@@ -344,15 +350,18 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    front: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n     length: usize,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let range = Range { front: self.front.reborrow(), back: self.back.reborrow() };\n+        let range = Range {\n+            front: self.front.as_ref().map(|f| f.reborrow()),\n+            back: self.back.as_ref().map(|b| b.reborrow()),\n+        };\n         f.debug_list().entries(range).finish()\n     }\n }\n@@ -417,8 +426,8 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, K: 'a, V: 'a> {\n-    front: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -437,8 +446,8 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Range<'_, K, V> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n-    front: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n \n     // Be invariant in `K` and `V`\n     _marker: PhantomData<&'a mut (K, V)>,\n@@ -447,7 +456,10 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let range = Range { front: self.front.reborrow(), back: self.back.reborrow() };\n+        let range = Range {\n+            front: self.front.as_ref().map(|f| f.reborrow()),\n+            back: self.back.as_ref().map(|b| b.reborrow()),\n+        };\n         f.debug_list().entries(range).finish()\n     }\n }\n@@ -544,7 +556,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeMap<K, V> {\n-        BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n+        BTreeMap { root: None, length: 0 }\n     }\n \n     /// Clears the map, removing all elements.\n@@ -589,7 +601,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref(), key) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().1),\n             GoDown(_) => None,\n         }\n@@ -616,7 +628,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref(), k) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), k) {\n             Found(handle) => Some(handle.into_kv()),\n             GoDown(_) => None,\n         }\n@@ -645,7 +657,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let front = self.root.as_ref().first_leaf_edge();\n+        let front = self.root.as_ref()?.as_ref().first_leaf_edge();\n         front.right_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -674,7 +686,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let front = self.root.as_mut().first_leaf_edge();\n+        let front = self.root.as_mut()?.as_mut().first_leaf_edge();\n         if let Ok(kv) = front.right_kv() {\n             Some(OccupiedEntry {\n                 handle: kv.forget_node_type(),\n@@ -708,7 +720,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let back = self.root.as_ref().last_leaf_edge();\n+        let back = self.root.as_ref()?.as_ref().last_leaf_edge();\n         back.left_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -737,7 +749,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let back = self.root.as_mut().last_leaf_edge();\n+        let back = self.root.as_mut()?.as_mut().last_leaf_edge();\n         if let Ok(kv) = back.left_kv() {\n             Some(OccupiedEntry {\n                 handle: kv.forget_node_type(),\n@@ -801,7 +813,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(handle.into_kv_mut().1),\n             GoDown(_) => None,\n         }\n@@ -896,7 +908,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_entry(),\n@@ -992,11 +1004,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<T>,\n         R: RangeBounds<T>,\n     {\n-        let root1 = self.root.as_ref();\n-        let root2 = self.root.as_ref();\n-        let (f, b) = range_search(root1, root2, range);\n+        if let Some(root) = &self.root {\n+            let root1 = root.as_ref();\n+            let root2 = root.as_ref();\n+            let (f, b) = range_search(root1, root2, range);\n \n-        Range { front: f, back: b }\n+            Range { front: Some(f), back: Some(b) }\n+        } else {\n+            Range { front: None, back: None }\n+        }\n     }\n \n     /// Constructs a mutable double-ended iterator over a sub-range of elements in the map.\n@@ -1036,11 +1052,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<T>,\n         R: RangeBounds<T>,\n     {\n-        let root1 = self.root.as_mut();\n-        let root2 = unsafe { ptr::read(&root1) };\n-        let (f, b) = range_search(root1, root2, range);\n+        if let Some(root) = &mut self.root {\n+            let root1 = root.as_mut();\n+            let root2 = unsafe { ptr::read(&root1) };\n+            let (f, b) = range_search(root1, root2, range);\n \n-        RangeMut { front: f, back: b, _marker: PhantomData }\n+            RangeMut { front: Some(f), back: Some(b), _marker: PhantomData }\n+        } else {\n+            RangeMut { front: None, back: None, _marker: PhantomData }\n+        }\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n@@ -1065,7 +1085,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         self.ensure_root_is_owned();\n-        match search::search_tree(self.root.as_mut(), &key) {\n+        match search::search_tree(self.root.as_mut().unwrap().as_mut(), &key) {\n             Found(handle) => {\n                 Occupied(OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData })\n             }\n@@ -1077,7 +1097,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n         self.ensure_root_is_owned();\n-        let mut cur_node = self.root.as_mut().last_leaf_edge().into_node();\n+        let mut cur_node = self.root.as_mut().unwrap().as_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -1126,7 +1146,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn fix_right_edge(&mut self) {\n         // Handle underfull nodes, start from the top.\n-        let mut cur_node = self.root.as_mut();\n+        let mut cur_node = self.root.as_mut().unwrap().as_mut();\n         while let Internal(internal) = cur_node.force() {\n             // Check if right-most child is underfull.\n             let mut last_edge = internal.last_edge();\n@@ -1187,14 +1207,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let total_num = self.len();\n \n         let mut right = Self::new();\n-        right.root = node::Root::new_leaf();\n-        for _ in 0..(self.root.as_ref().height()) {\n-            right.root.push_level();\n+        let right_root = right.ensure_root_is_owned();\n+        for _ in 0..(self.root.as_ref().unwrap().as_ref().height()) {\n+            right_root.push_level();\n         }\n \n         {\n-            let mut left_node = self.root.as_mut();\n-            let mut right_node = right.root.as_mut();\n+            let mut left_node = self.root.as_mut().unwrap().as_mut();\n+            let mut right_node = right.root.as_mut().unwrap().as_mut();\n \n             loop {\n                 let mut split_edge = match search::search_node(left_node, key) {\n@@ -1223,7 +1243,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.fix_right_border();\n         right.fix_left_border();\n \n-        if self.root.as_ref().height() < right.root.as_ref().height() {\n+        if self.root.as_ref().unwrap().as_ref().height()\n+            < right.root.as_ref().unwrap().as_ref().height()\n+        {\n             self.recalc_length();\n             right.length = total_num - self.len();\n         } else {\n@@ -1261,27 +1283,27 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             res\n         }\n \n-        self.length = dfs(self.root.as_ref());\n+        self.length = dfs(self.root.as_ref().unwrap().as_ref());\n     }\n \n     /// Removes empty levels on the top.\n     fn fix_top(&mut self) {\n         loop {\n             {\n-                let node = self.root.as_ref();\n+                let node = self.root.as_ref().unwrap().as_ref();\n                 if node.height() == 0 || node.len() > 0 {\n                     break;\n                 }\n             }\n-            self.root.pop_level();\n+            self.root.as_mut().unwrap().pop_level();\n         }\n     }\n \n     fn fix_right_border(&mut self) {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.root.as_mut();\n+            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut last_kv = node.last_kv();\n@@ -1307,7 +1329,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.root.as_mut();\n+            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut first_kv = node.first_kv();\n@@ -1326,13 +1348,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         self.fix_top();\n     }\n-\n-    /// If the root node is the shared root node, allocate our own node.\n-    fn ensure_root_is_owned(&mut self) {\n-        if self.root.is_shared_root() {\n-            self.root = node::Root::new_leaf();\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1458,12 +1473,21 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     type IntoIter = IntoIter<K, V>;\n \n     fn into_iter(self) -> IntoIter<K, V> {\n-        let root1 = unsafe { ptr::read(&self.root).into_ref() };\n-        let root2 = unsafe { ptr::read(&self.root).into_ref() };\n+        if self.root.is_none() {\n+            mem::forget(self);\n+            return IntoIter { front: None, back: None, length: 0 };\n+        }\n+\n+        let root1 = unsafe { unwrap_unchecked(ptr::read(&self.root)).into_ref() };\n+        let root2 = unsafe { unwrap_unchecked(ptr::read(&self.root)).into_ref() };\n         let len = self.length;\n         mem::forget(self);\n \n-        IntoIter { front: root1.first_leaf_edge(), back: root2.last_leaf_edge(), length: len }\n+        IntoIter {\n+            front: Some(root1.first_leaf_edge()),\n+            back: Some(root2.last_leaf_edge()),\n+            length: len,\n+        }\n     }\n }\n \n@@ -1478,9 +1502,9 @@ impl<K, V> Drop for IntoIter<K, V> {\n                 // don't have to care about panics this time (they'll abort).\n                 while let Some(_) = self.0.next() {}\n \n-                // No need to avoid the shared root, because the tree was definitely not empty.\n                 unsafe {\n-                    let mut node = ptr::read(&self.0.front).into_node().forget_type();\n+                    let mut node =\n+                        unwrap_unchecked(ptr::read(&self.0.front)).into_node().forget_type();\n                     while let Some(parent) = node.deallocate_and_ascend() {\n                         node = parent.into_node().forget_type();\n                     }\n@@ -1495,14 +1519,13 @@ impl<K, V> Drop for IntoIter<K, V> {\n         }\n \n         unsafe {\n-            let mut node = ptr::read(&self.front).into_node().forget_type();\n-            if node.is_shared_root() {\n-                return;\n-            }\n-            // Most of the nodes have been deallocated while traversing\n-            // but one pile from a leaf up to the root is left standing.\n-            while let Some(parent) = node.deallocate_and_ascend() {\n-                node = parent.into_node().forget_type();\n+            if let Some(front) = ptr::read(&self.front) {\n+                let mut node = front.into_node().forget_type();\n+                // Most of the nodes have been deallocated while traversing\n+                // but one pile from a leaf up to the root is left standing.\n+                while let Some(parent) = node.deallocate_and_ascend() {\n+                    node = parent.into_node().forget_type();\n+                }\n             }\n         }\n     }\n@@ -1517,7 +1540,7 @@ impl<K, V> Iterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.front.next_unchecked() })\n+            Some(unsafe { self.front.as_mut().unwrap().next_unchecked() })\n         }\n     }\n \n@@ -1533,7 +1556,7 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.back.next_back_unchecked() })\n+            Some(unsafe { self.back.as_mut().unwrap().next_back_unchecked() })\n         }\n     }\n }\n@@ -1683,7 +1706,7 @@ impl<'a, K, V> Range<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        self.front.next_unchecked()\n+        unwrap_unchecked(self.front.as_mut()).next_unchecked()\n     }\n }\n \n@@ -1696,7 +1719,7 @@ impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n \n impl<'a, K, V> Range<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        self.back.next_back_unchecked()\n+        unwrap_unchecked(self.back.as_mut()).next_back_unchecked()\n     }\n }\n \n@@ -1734,7 +1757,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        self.front.next_unchecked()\n+        unwrap_unchecked(self.front.as_mut()).next_unchecked()\n     }\n }\n \n@@ -1755,7 +1778,7 @@ impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        self.back.next_back_unchecked()\n+        unwrap_unchecked(self.back.as_mut()).next_back_unchecked()\n     }\n }\n \n@@ -1969,8 +1992,8 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn iter(&self) -> Iter<'_, K, V> {\n         Iter {\n             range: Range {\n-                front: self.root.as_ref().first_leaf_edge(),\n-                back: self.root.as_ref().last_leaf_edge(),\n+                front: self.root.as_ref().map(|r| r.as_ref().first_leaf_edge()),\n+                back: self.root.as_ref().map(|r| r.as_ref().last_leaf_edge()),\n             },\n             length: self.length,\n         }\n@@ -1999,13 +2022,17 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n-        let root1 = self.root.as_mut();\n-        let root2 = unsafe { ptr::read(&root1) };\n         IterMut {\n-            range: RangeMut {\n-                front: root1.first_leaf_edge(),\n-                back: root2.last_leaf_edge(),\n-                _marker: PhantomData,\n+            range: if let Some(root) = &mut self.root {\n+                let root1 = root.as_mut();\n+                let root2 = unsafe { ptr::read(&root1) };\n+                RangeMut {\n+                    front: Some(root1.first_leaf_edge()),\n+                    back: Some(root2.last_leaf_edge()),\n+                    _marker: PhantomData,\n+                }\n+            } else {\n+                RangeMut { front: None, back: None, _marker: PhantomData }\n             },\n             length: self.length,\n         }\n@@ -2116,6 +2143,12 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n+\n+    /// If the root node is the empty (non-allocated) root node, allocate our\n+    /// own node.\n+    fn ensure_root_is_owned(&mut self) -> &mut node::Root<K, V> {\n+        self.root.get_or_insert_with(|| node::Root::new_leaf())\n+    }\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {"}, {"sha": "6ebb98c42cd4f8ecef6fee0628ed665325a0003e", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 60, "deletions": 144, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -44,34 +44,7 @@ const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;\n pub const CAPACITY: usize = 2 * B - 1;\n \n-/// The underlying representation of leaf nodes. Note that it is often unsafe to actually store\n-/// these, since only the first `len` keys and values are assumed to be initialized. As such,\n-/// these should always be put behind pointers, and specifically behind `BoxedNode` in the owned\n-/// case.\n-///\n-/// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n-/// order to statically allocate a single dummy node to avoid allocations. This struct is\n-/// `repr(C)` to prevent them from being reordered. `LeafNode` does not just contain a\n-/// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n-/// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n-/// by `as_header`.)\n-#[repr(C)]\n-struct NodeHeader<K, V> {\n-    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n-    /// This either points to an actual node or is null.\n-    parent: *const InternalNode<K, V>,\n-\n-    /// This node's index into the parent node's `edges` array.\n-    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n-    /// This is only guaranteed to be initialized when `parent` is non-null.\n-    parent_idx: MaybeUninit<u16>,\n-\n-    /// The number of keys and values this node stores.\n-    ///\n-    /// This next to `parent_idx` to encourage the compiler to join `len` and\n-    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n-    len: u16,\n-}\n+/// The underlying representation of leaf nodes.\n #[repr(C)]\n struct LeafNode<K, V> {\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n@@ -111,21 +84,6 @@ impl<K, V> LeafNode<K, V> {\n     }\n }\n \n-impl<K, V> NodeHeader<K, V> {\n-    fn is_shared_root(&self) -> bool {\n-        ptr::eq(self, &EMPTY_ROOT_NODE as *const _ as *const _)\n-    }\n-}\n-\n-// We need to implement Sync here in order to make a static instance.\n-unsafe impl Sync for NodeHeader<(), ()> {}\n-\n-// An empty node used as a placeholder for the root node, to avoid allocations.\n-// We use just a header in order to save space, since no operation on an empty tree will\n-// ever take a pointer past the first key.\n-static EMPTY_ROOT_NODE: NodeHeader<(), ()> =\n-    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0 };\n-\n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n /// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n /// `InternalNode` can be directly casted to a pointer to the underlying `LeafNode` portion of the\n@@ -154,12 +112,9 @@ impl<K, V> InternalNode<K, V> {\n }\n \n /// A managed, non-null pointer to a node. This is either an owned pointer to\n-/// `LeafNode<K, V>`, an owned pointer to `InternalNode<K, V>`, or a (not owned)\n-/// pointer to `NodeHeader<(), ()` (more specifically, the pointer to EMPTY_ROOT_NODE).\n-/// All of these types have a `NodeHeader<K, V>` prefix, meaning that they have at\n-/// least the same size as `NodeHeader<K, V>` and store the same kinds of data at the same\n-/// offsets; and they have a pointer alignment at least as large as `NodeHeader<K, V>`'s.\n-/// However, `BoxedNode` contains no information as to which of the three types\n+/// `LeafNode<K, V>` or an owned pointer to `InternalNode<K, V>`.\n+///\n+/// However, `BoxedNode` contains no information as to which of the two types\n /// of nodes it actually contains, and, partially due to this lack of information,\n /// has no destructor.\n struct BoxedNode<K, V> {\n@@ -184,8 +139,9 @@ impl<K, V> BoxedNode<K, V> {\n     }\n }\n \n-/// Either an owned tree or a shared, empty tree.  Note that this does not have a destructor,\n-/// and must be cleaned up manually if it is an owned tree.\n+/// An owned tree.\n+///\n+/// Note that this does not have a destructor, and must be cleaned up manually.\n pub struct Root<K, V> {\n     node: BoxedNode<K, V>,\n     /// The number of levels below the root node.\n@@ -196,20 +152,6 @@ unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> {}\n unsafe impl<K: Send, V: Send> Send for Root<K, V> {}\n \n impl<K, V> Root<K, V> {\n-    /// Whether the instance of `Root` wraps a shared, empty root node. If not,\n-    /// the entire tree is uniquely owned by the owner of the `Root` instance.\n-    pub fn is_shared_root(&self) -> bool {\n-        self.as_ref().is_shared_root()\n-    }\n-\n-    /// Returns a shared tree, wrapping a shared root node that is eternally empty.\n-    pub fn shared_empty_root() -> Self {\n-        Root {\n-            node: unsafe { BoxedNode::from_ptr(NonNull::from(&EMPTY_ROOT_NODE).cast()) },\n-            height: 0,\n-        }\n-    }\n-\n     /// Returns a new owned tree, with its own root node that is initially empty.\n     pub fn new_leaf() -> Self {\n         Root { node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })), height: 0 }\n@@ -245,7 +187,6 @@ impl<K, V> Root<K, V> {\n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n     /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n     pub fn push_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n-        debug_assert!(!self.is_shared_root());\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n@@ -308,11 +249,6 @@ impl<K, V> Root<K, V> {\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n-///   Note that in case of a leaf node, this might still be the shared root!\n-///   Only turn this into a `LeafNode` reference if you know it is not the shared root!\n-///   Shared references must be dereferenceable *for the entire size of their pointee*,\n-///   so '&LeafNode` or `&InternalNode` pointing to the shared root is undefined behavior.\n-///   Turning this into a `NodeHeader` reference is always safe.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     /// The number of levels below the node.\n     height: usize,\n@@ -354,7 +290,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Note that, despite being safe, calling this function can have the side effect\n     /// of invalidating mutable references that unsafe code has created.\n     pub fn len(&self) -> usize {\n-        self.as_header().len as usize\n+        self.as_leaf().len as usize\n     }\n \n     /// Returns the height of this node in the whole tree. Zero height denotes the\n@@ -374,35 +310,24 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf \"portion\" of any leaf or internal node that is not the shared root.\n+    /// Exposes the leaf \"portion\" of any leaf or internal node.\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n-    /// Unsafe because the node must not be the shared root. For more information,\n-    /// see the `NodeRef` comments.\n-    unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n-        debug_assert!(!self.is_shared_root());\n-        self.node.as_ref()\n-    }\n-\n-    fn as_header(&self) -> &NodeHeader<K, V> {\n-        unsafe { &*(self.node.as_ptr() as *const NodeHeader<K, V>) }\n-    }\n-\n-    /// Returns whether the node is the shared, empty root.\n-    pub fn is_shared_root(&self) -> bool {\n-        self.as_header().is_shared_root()\n+    fn as_leaf(&self) -> &LeafNode<K, V> {\n+        // The node must be valid for at least the LeafNode portion.\n+        // This is not a reference in the NodeRef type because we don't know if\n+        // it should be unique or shared.\n+        unsafe { self.node.as_ref() }\n     }\n \n     /// Borrows a view into the keys stored in the node.\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    pub unsafe fn keys(&self) -> &[K] {\n+    pub fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n     /// Borrows a view into the values stored in the node.\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn vals(&self) -> &[V] {\n+    fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n \n@@ -416,7 +341,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     pub fn ascend(\n         self,\n     ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {\n-        let parent_as_leaf = self.as_header().parent as *const LeafNode<K, V>;\n+        let parent_as_leaf = self.as_leaf().parent as *const LeafNode<K, V>;\n         if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n@@ -425,7 +350,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData,\n                 },\n-                idx: unsafe { usize::from(*self.as_header().parent_idx.as_ptr()) },\n+                idx: unsafe { usize::from(*self.as_leaf().parent_idx.as_ptr()) },\n                 _marker: PhantomData,\n             })\n         } else {\n@@ -464,7 +389,6 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     pub unsafe fn deallocate_and_ascend(\n         self,\n     ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n-        assert!(!self.is_shared_root());\n         let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n@@ -507,41 +431,37 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// (header, keys and values), and this function exposes that.\n     ///\n     /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n-    /// This also implies you can invoke this member on the shared root, but the resulting pointer\n-    /// might not be properly aligned and definitely would not allow accessing keys and values.\n     fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n         self.node.as_ptr()\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn keys_mut(&mut self) -> &mut [K] {\n-        self.reborrow_mut().into_key_slice_mut()\n+    fn keys_mut(&mut self) -> &mut [K] {\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the key slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn vals_mut(&mut self) -> &mut [V] {\n-        self.reborrow_mut().into_val_slice_mut()\n+    fn vals_mut(&mut self) -> &mut [V] {\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the value slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { self.reborrow_mut().into_val_slice_mut() }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_key_slice(self) -> &'a [K] {\n-        debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf` is okay.\n-        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len())\n+    fn into_key_slice(self) -> &'a [K] {\n+        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len()) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_val_slice(self) -> &'a [V] {\n-        debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf` is okay.\n-        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len())\n+    fn into_val_slice(self) -> &'a [V] {\n+        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        let k = ptr::read(&self);\n+    fn into_slices(self) -> (&'a [K], &'a [V]) {\n+        // SAFETY: equivalent to reborrow() except not requiring Type: 'a\n+        let k = unsafe { ptr::read(&self) };\n         (k.into_key_slice(), self.into_val_slice())\n     }\n }\n@@ -553,37 +473,41 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe { &mut *(self.root as *mut Root<K, V>) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_key_slice_mut(mut self) -> &'a mut [K] {\n-        debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf_mut` is okay.\n-        slice::from_raw_parts_mut(\n-            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n-            self.len(),\n-        )\n+    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n+        // SAFETY: The keys of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n+                self.len(),\n+            )\n+        }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_val_slice_mut(mut self) -> &'a mut [V] {\n-        debug_assert!(!self.is_shared_root());\n-        slice::from_raw_parts_mut(\n-            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n-            self.len(),\n-        )\n+    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n+        // SAFETY: The values of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n+                self.len(),\n+            )\n+        }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n-        debug_assert!(!self.is_shared_root());\n+    fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n         // We cannot use the getters here, because calling the second one\n         // invalidates the reference returned by the first.\n         // More precisely, it is the call to `len` that is the culprit,\n         // because that creates a shared reference to the header, which *can*\n         // overlap with the keys (and even the values, for ZST keys).\n         let len = self.len();\n         let leaf = self.as_leaf_mut();\n-        let keys = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len);\n-        let vals = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len);\n+        // SAFETY: The keys and values of a node must always be initialized up to length.\n+        let keys = unsafe {\n+            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len)\n+        };\n+        let vals = unsafe {\n+            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len)\n+        };\n         (keys, vals)\n     }\n }\n@@ -592,7 +516,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -607,7 +530,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -624,7 +546,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -658,7 +579,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -744,8 +664,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n+    fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n         (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n     }\n }\n@@ -904,7 +823,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n-        debug_assert!(!self.node.is_shared_root());\n \n         unsafe {\n             slice_insert(self.node.keys_mut(), self.idx, key);\n@@ -1081,7 +999,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// - All the key/value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n-        assert!(!self.node.is_shared_root());\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n@@ -1113,7 +1030,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     pub fn remove(\n         mut self,\n     ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n-        assert!(!self.node.is_shared_root());\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);"}, {"sha": "4e80f7f21ebff5c6817a82f9e9436acf3ea5d9d2", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -67,19 +67,16 @@ where\n     Q: Ord,\n     K: Borrow<Q>,\n {\n-    // This function is defined over all borrow types (immutable, mutable, owned),\n-    // and may be called on the shared root in each case.\n+    // This function is defined over all borrow types (immutable, mutable, owned).\n     // Using `keys()` is fine here even if BorrowType is mutable, as all we return\n     // is an index -- not a reference.\n     let len = node.len();\n-    if len > 0 {\n-        let keys = unsafe { node.keys() }; // safe because a non-empty node cannot be the shared root\n-        for (i, k) in keys.iter().enumerate() {\n-            match key.cmp(k.borrow()) {\n-                Ordering::Greater => {}\n-                Ordering::Equal => return (i, true),\n-                Ordering::Less => return (i, false),\n-            }\n+    let keys = node.keys();\n+    for (i, k) in keys.iter().enumerate() {\n+        match key.cmp(k.borrow()) {\n+            Ordering::Greater => {}\n+            Ordering::Equal => return (i, true),\n+            Ordering::Less => return (i, false),\n         }\n     }\n     (len, false)"}, {"sha": "d877ac6ac5c7944558007b37c3fe317af5999f2d", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -80,6 +80,7 @@\n #![feature(box_into_raw_non_null)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(cfg_sanitize)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n #![feature(const_generic_impls_guard)]"}, {"sha": "d9b54fb0b177ad05a81cc06c52fec3186fc06303", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -40,6 +40,23 @@ mod tests;\n /// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n+#[cfg(not(sanitize = \"thread\"))]\n+macro_rules! acquire {\n+    ($x:expr) => {\n+        atomic::fence(Acquire)\n+    };\n+}\n+\n+// ThreadSanitizer does not support memory fences. To avoid false positive\n+// reports in Arc / Weak implementation use atomic loads for synchronization\n+// instead.\n+#[cfg(sanitize = \"thread\")]\n+macro_rules! acquire {\n+    ($x:expr) => {\n+        $x.load(Acquire)\n+    };\n+}\n+\n /// A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically\n /// Reference Counted'.\n ///\n@@ -402,7 +419,7 @@ impl<T> Arc<T> {\n             return Err(this);\n         }\n \n-        atomic::fence(Acquire);\n+        acquire!(this.inner().strong);\n \n         unsafe {\n             let elem = ptr::read(&this.ptr.as_ref().data);\n@@ -739,7 +756,7 @@ impl<T: ?Sized> Arc<T> {\n         ptr::drop_in_place(&mut self.ptr.as_mut().data);\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n-            atomic::fence(Acquire);\n+            acquire!(self.inner().weak);\n             Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n         }\n     }\n@@ -1243,7 +1260,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n         // [2]: (https://github.com/rust-lang/rust/pull/41714)\n-        atomic::fence(Acquire);\n+        acquire!(self.inner().strong);\n \n         unsafe {\n             self.drop_slow();\n@@ -1701,7 +1718,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         let inner = if let Some(inner) = self.inner() { inner } else { return };\n \n         if inner.weak.fetch_sub(1, Release) == 1 {\n-            atomic::fence(Acquire);\n+            acquire!(inner.weak);\n             unsafe { Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref())) }\n         }\n     }"}, {"sha": "3a3462d546f7a9b363178d2b0c07c98cdccc95bf", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -67,7 +67,7 @@ fn test_basic_large() {\n #[test]\n fn test_basic_small() {\n     let mut map = BTreeMap::new();\n-    // Empty, shared root:\n+    // Empty, root is absent (None):\n     assert_eq!(map.remove(&1), None);\n     assert_eq!(map.len(), 0);\n     assert_eq!(map.get(&1), None);\n@@ -123,7 +123,7 @@ fn test_basic_small() {\n     assert_eq!(map.values().collect::<Vec<_>>(), vec![&4]);\n     assert_eq!(map.remove(&2), Some(4));\n \n-    // Empty but private root:\n+    // Empty but root is owned (Some(...)):\n     assert_eq!(map.len(), 0);\n     assert_eq!(map.get(&1), None);\n     assert_eq!(map.get_mut(&1), None);\n@@ -263,13 +263,6 @@ fn test_iter_mut_mutation() {\n     do_test_iter_mut_mutation::<Align32>(144);\n }\n \n-#[test]\n-fn test_into_key_slice_with_shared_root_past_bounds() {\n-    let mut map: BTreeMap<Align32, ()> = BTreeMap::new();\n-    assert_eq!(map.get(&Align32(1)), None);\n-    assert_eq!(map.get_mut(&Align32(1)), None);\n-}\n-\n #[test]\n fn test_values_mut() {\n     let mut a = BTreeMap::new();"}, {"sha": "4769091183a370cb0ff6909052797410c94a4d94", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -1377,6 +1377,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec2, [2, 3]);\n     /// ```\n     #[inline]\n+    #[must_use = \"use `.truncate()` if you don't need the other half\"]\n     #[stable(feature = \"split_off\", since = \"1.4.0\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         assert!(at <= self.len(), \"`at` out of bounds\");"}, {"sha": "8dfda7a4a32366447668ff4b6ed79662457be66e", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -2,6 +2,84 @@\n \n //! Asynchronous values.\n \n+#[cfg(not(bootstrap))]\n+use crate::{\n+    ops::{Generator, GeneratorState},\n+    pin::Pin,\n+    ptr::NonNull,\n+    task::{Context, Poll},\n+};\n+\n mod future;\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::future::Future;\n+\n+/// This type is needed because:\n+///\n+/// a) Generators cannot implement `for<'a, 'b> Generator<&'a mut Context<'b>>`, so we need to pass\n+///    a raw pointer (see https://github.com/rust-lang/rust/issues/68923).\n+/// b) Raw pointers and `NonNull` aren't `Send` or `Sync`, so that would make every single future\n+///    non-Send/Sync as well, and we don't want that.\n+///\n+/// It also simplifies the HIR lowering of `.await`.\n+#[doc(hidden)]\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[cfg(not(bootstrap))]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ResumeTy(NonNull<Context<'static>>);\n+\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[cfg(not(bootstrap))]\n+unsafe impl Send for ResumeTy {}\n+\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[cfg(not(bootstrap))]\n+unsafe impl Sync for ResumeTy {}\n+\n+/// Wrap a generator in a future.\n+///\n+/// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n+/// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n+// This is `const` to avoid extra errors after we recover from `const async fn`\n+#[doc(hidden)]\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[cfg(not(bootstrap))]\n+#[inline]\n+pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n+where\n+    T: Generator<ResumeTy, Yield = ()>,\n+{\n+    struct GenFuture<T: Generator<ResumeTy, Yield = ()>>(T);\n+\n+    // We rely on the fact that async/await futures are immovable in order to create\n+    // self-referential borrows in the underlying generator.\n+    impl<T: Generator<ResumeTy, Yield = ()>> !Unpin for GenFuture<T> {}\n+\n+    impl<T: Generator<ResumeTy, Yield = ()>> Future for GenFuture<T> {\n+        type Output = T::Return;\n+        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+            // Safety: Safe because we're !Unpin + !Drop, and this is just a field projection.\n+            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n+\n+            // Resume the generator, turning the `&mut Context` into a `NonNull` raw pointer. The\n+            // `.await` lowering will safely cast that back to a `&mut Context`.\n+            match gen.resume(ResumeTy(NonNull::from(cx).cast::<Context<'static>>())) {\n+                GeneratorState::Yielded(()) => Poll::Pending,\n+                GeneratorState::Complete(x) => Poll::Ready(x),\n+            }\n+        }\n+    }\n+\n+    GenFuture(gen)\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[cfg(not(bootstrap))]\n+#[inline]\n+pub unsafe fn poll_with_context<F>(f: Pin<&mut F>, mut cx: ResumeTy) -> Poll<F::Output>\n+where\n+    F: Future,\n+{\n+    F::poll(f, cx.0.as_mut())\n+}"}, {"sha": "6cbd26a78de726bed1d5ac403f56397f8f1ddd06", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -114,6 +114,6 @@ pub fn black_box<T>(dummy: T) -> T {\n     // more than we want, but it's so far good enough.\n     unsafe {\n         asm!(\"\" : : \"r\"(&dummy));\n-        return dummy;\n+        dummy\n     }\n }"}, {"sha": "94fc2fd357a06d424679e424d9264ca421752fde", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -140,6 +140,7 @@\n #![feature(associated_type_bounds)]\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n+#![feature(option_zip)]\n #![feature(no_niche)] // rust-lang/rust#68303\n \n #[prelude_import]"}, {"sha": "adee8cea442b439a6c97eb0f03cdd54f07457425", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -1,5 +1,5 @@\n use crate::fmt;\n-use crate::hash::{Hash, Hasher};\n+use crate::hash::Hash;\n \n /// An unbounded range (`..`).\n ///\n@@ -330,7 +330,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);  // RangeInclusive\n /// ```\n #[doc(alias = \"..=\")]\n-#[derive(Clone)] // not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeInclusive<Idx> {\n     // Note that the fields here are not public to allow changing the\n@@ -350,26 +350,6 @@ pub struct RangeInclusive<Idx> {\n     pub(crate) exhausted: bool,\n }\n \n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.start == other.start && self.end == other.end && self.exhausted == other.exhausted\n-    }\n-}\n-\n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<Idx: Eq> Eq for RangeInclusive<Idx> {}\n-\n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<Idx: Hash> Hash for RangeInclusive<Idx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.start.hash(state);\n-        self.end.hash(state);\n-        self.exhausted.hash(state);\n-    }\n-}\n-\n impl<Idx> RangeInclusive<Idx> {\n     /// Creates a new inclusive range. Equivalent to writing `start..=end`.\n     ///"}, {"sha": "3aab8b1b3337cc4ff39619782564eb328f9616ea", "filename": "src/libcore/option.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -913,6 +913,63 @@ impl<T> Option<T> {\n     pub fn replace(&mut self, value: T) -> Option<T> {\n         mem::replace(self, Some(value))\n     }\n+\n+    /// Zips `self` with another `Option`.\n+    ///\n+    /// If `self` is `Some(s)` and `other` is `Some(o)`, this method returns `Some((s, o))`.\n+    /// Otherwise, `None` is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(option_zip)]\n+    /// let x = Some(1);\n+    /// let y = Some(\"hi\");\n+    /// let z = None::<u8>;\n+    ///\n+    /// assert_eq!(x.zip(y), Some((1, \"hi\")));\n+    /// assert_eq!(x.zip(z), None);\n+    /// ```\n+    #[unstable(feature = \"option_zip\", issue = \"70086\")]\n+    pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)> {\n+        self.zip_with(other, |a, b| (a, b))\n+    }\n+\n+    /// Zips `self` and another `Option` with function `f`.\n+    ///\n+    /// If `self` is `Some(s)` and `other` is `Some(o)`, this method returns `Some(f(s, o))`.\n+    /// Otherwise, `None` is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(option_zip)]\n+    ///\n+    /// #[derive(Debug, PartialEq)]\n+    /// struct Point {\n+    ///     x: f64,\n+    ///     y: f64,\n+    /// }\n+    ///\n+    /// impl Point {\n+    ///     fn new(x: f64, y: f64) -> Self {\n+    ///         Self { x, y }\n+    ///     }\n+    /// }\n+    ///\n+    /// let x = Some(17.5);\n+    /// let y = Some(42.7);\n+    ///\n+    /// assert_eq!(x.zip_with(y, Point::new), Some(Point { x: 17.5, y: 42.7 }));\n+    /// assert_eq!(x.zip_with(None, Point::new), None);\n+    /// ```\n+    #[unstable(feature = \"option_zip\", issue = \"70086\")]\n+    pub fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R>\n+    where\n+        F: FnOnce(T, U) -> R,\n+    {\n+        Some(f(self?, other?))\n+    }\n }\n \n impl<T: Copy> Option<&T> {"}, {"sha": "59588d97787b7adc19a93b15b83868fe8f980614", "filename": "src/libcore/tests/mem.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fmem.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -129,21 +129,3 @@ fn test_discriminant_send_sync() {\n     is_send_sync::<Discriminant<Regular>>();\n     is_send_sync::<Discriminant<NotSendSync>>();\n }\n-\n-#[test]\n-fn test_const_forget() {\n-    const _: () = forget(0i32);\n-    const _: () = forget(Vec::<Vec<Box<i32>>>::new());\n-\n-    // Writing this function signature without const-forget\n-    // triggers compiler errors:\n-    // 1) That we use a non-const fn inside a const fn\n-    // 2) without the forget, it complains about the destructor of Box\n-    const fn const_forget_box<T>(x: Box<T>) {\n-        forget(x);\n-    }\n-\n-    // Call the forget_box at runtime,\n-    // as we can't const-construct a box yet.\n-    const_forget_box(Box::new(0i32));\n-}"}, {"sha": "4dd276d2e032c9df90c1ad45864ee192349eb67b", "filename": "src/librustc/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -85,7 +85,7 @@ impl LintLevelSets {\n             level = cmp::min(*driver_level, level);\n         }\n \n-        return (level, src);\n+        (level, src)\n     }\n \n     pub fn get_lint_id_level("}, {"sha": "1a63dc9dcf977f0b63efae6c968827e3de52574d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -467,7 +467,7 @@ impl<'tcx> ScopeTree {\n         }\n \n         debug!(\"temporary_scope({:?}) = None\", expr_id);\n-        return None;\n+        None\n     }\n \n     /// Returns the lifetime of the variable `id`.\n@@ -498,7 +498,7 @@ impl<'tcx> ScopeTree {\n \n         debug!(\"is_subscope_of({:?}, {:?})=true\", subscope, superscope);\n \n-        return true;\n+        true\n     }\n \n     /// Returns the ID of the innermost containing body."}, {"sha": "0e3776f32e0e8b7a9071afc484a09adbc6f37bf8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -1447,11 +1447,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => return None,\n         };\n \n-        return Some(FreeRegionInfo {\n+        Some(FreeRegionInfo {\n             def_id: suitable_region_binding_scope,\n             boundregion: bound_region,\n             is_impl_item,\n-        });\n+        })\n     }\n \n     pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {"}, {"sha": "872e06e1176dc06ba88c81bded574e186c247273", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -440,7 +440,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n                         (Some(sz_a_val), Some(sz_b_val)) => Err(TypeError::FixedArraySize(\n                             expected_found(relation, &sz_a_val, &sz_b_val),\n                         )),\n-                        _ => return Err(err),\n+                        _ => Err(err),\n                     }\n                 }\n             }"}, {"sha": "42cd2f52cb3ad1d1e52d1335b81338135446257f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -1612,7 +1612,7 @@ impl<'tcx> PolyExistentialProjection<'tcx> {\n     }\n \n     pub fn item_def_id(&self) -> DefId {\n-        return self.skip_binder().item_def_id;\n+        self.skip_binder().item_def_id\n     }\n }\n \n@@ -2000,8 +2000,8 @@ impl<'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_unsafe_ptr(&self) -> bool {\n         match self.kind {\n-            RawPtr(_) => return true,\n-            _ => return false,\n+            RawPtr(_) => true,\n+            _ => false,\n         }\n     }\n "}, {"sha": "a3acc14856e1febbb4b168dfe7e0877d9d4690dc", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -524,7 +524,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n             self.root_ty = None;\n         }\n \n-        return t1;\n+        t1\n     }\n \n     fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {"}, {"sha": "be5d322ba1677dd4d984367ff430601babe40ec5", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -424,7 +424,7 @@ impl Token {\n                 NtExpr(..) | NtBlock(..) | NtLiteral(..) => true,\n                 _ => false,\n             },\n-            _ => self.can_begin_literal_or_bool(),\n+            _ => self.can_begin_literal_maybe_minus(),\n         }\n     }\n \n@@ -448,13 +448,22 @@ impl Token {\n     /// Returns `true` if the token is any literal, a minus (which can prefix a literal,\n     /// for example a '-42', or one of the boolean idents).\n     ///\n-    /// Keep this in sync with `Lit::from_token`.\n-    pub fn can_begin_literal_or_bool(&self) -> bool {\n+    /// In other words, would this token be a valid start of `parse_literal_maybe_minus`?\n+    ///\n+    /// Keep this in sync with and `Lit::from_token`, excluding unary negation.\n+    pub fn can_begin_literal_maybe_minus(&self) -> bool {\n         match self.uninterpolate().kind {\n             Literal(..) | BinOp(Minus) => true,\n             Ident(name, false) if name.is_bool_lit() => true,\n             Interpolated(ref nt) => match &**nt {\n-                NtExpr(e) | NtLiteral(e) => matches!(e.kind, ast::ExprKind::Lit(_)),\n+                NtLiteral(_) => true,\n+                NtExpr(e) => match &e.kind {\n+                    ast::ExprKind::Lit(_) => true,\n+                    ast::ExprKind::Unary(ast::UnOp::Neg, e) => {\n+                        matches!(&e.kind, ast::ExprKind::Lit(_))\n+                    }\n+                    _ => false,\n+                },\n                 _ => false,\n             },\n             _ => false,"}, {"sha": "1b17f343a6d67deb74f0e7027199c9985d65438f", "filename": "src/librustc_ast/util/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fliteral.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -189,7 +189,7 @@ impl Lit {\n \n     /// Converts arbitrary token into an AST literal.\n     ///\n-    /// Keep this in sync with `Token::can_begin_literal_or_bool`.\n+    /// Keep this in sync with `Token::can_begin_literal_or_bool` excluding unary negation.\n     pub fn from_token(token: &Token) -> Result<Lit, LitError> {\n         let lit = match token.uninterpolate().kind {\n             token::Ident(name, false) if name.is_bool_lit() => {"}, {"sha": "a212f0a71077b32618db04b0f5ca676de90b4089", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 79, "deletions": 22, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -470,6 +470,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n+    /// Lower an `async` construct to a generator that is then wrapped so it implements `Future`.\n+    ///\n+    /// This results in:\n+    ///\n+    /// ```text\n+    /// std::future::from_generator(static move? |_task_context| -> <ret_ty> {\n+    ///     <body>\n+    /// })\n+    /// ```\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n@@ -480,17 +489,42 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n     ) -> hir::ExprKind<'hir> {\n         let output = match ret_ty {\n-            Some(ty) => FnRetTy::Ty(ty),\n-            None => FnRetTy::Default(span),\n+            Some(ty) => hir::FnRetTy::Return(self.lower_ty(&ty, ImplTraitContext::disallowed())),\n+            None => hir::FnRetTy::DefaultReturn(span),\n         };\n-        let ast_decl = FnDecl { inputs: vec![], output };\n-        let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n-        let body_id = self.lower_fn_body(&ast_decl, |this| {\n+\n+        // Resume argument type. We let the compiler infer this to simplify the lowering. It is\n+        // fully constrained by `future::from_generator`.\n+        let input_ty = hir::Ty { hir_id: self.next_id(), kind: hir::TyKind::Infer, span };\n+\n+        // The closure/generator `FnDecl` takes a single (resume) argument of type `input_ty`.\n+        let decl = self.arena.alloc(hir::FnDecl {\n+            inputs: arena_vec![self; input_ty],\n+            output,\n+            c_variadic: false,\n+            implicit_self: hir::ImplicitSelfKind::None,\n+        });\n+\n+        // Lower the argument pattern/ident. The ident is used again in the `.await` lowering.\n+        let (pat, task_context_hid) = self.pat_ident_binding_mode(\n+            span,\n+            Ident::with_dummy_span(sym::_task_context),\n+            hir::BindingAnnotation::Mutable,\n+        );\n+        let param = hir::Param { attrs: &[], hir_id: self.next_id(), pat, span };\n+        let params = arena_vec![self; param];\n+\n+        let body_id = self.lower_body(move |this| {\n             this.generator_kind = Some(hir::GeneratorKind::Async(async_gen_kind));\n-            body(this)\n+\n+            let old_ctx = this.task_context;\n+            this.task_context = Some(task_context_hid);\n+            let res = body(this);\n+            this.task_context = old_ctx;\n+            (params, res)\n         });\n \n-        // `static || -> <ret_ty> { body }`:\n+        // `static |_task_context| -> <ret_ty> { body }`:\n         let generator_kind = hir::ExprKind::Closure(\n             capture_clause,\n             decl,\n@@ -523,13 +557,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// ```rust\n     /// match <expr> {\n     ///     mut pinned => loop {\n-    ///         match ::std::future::poll_with_tls_context(unsafe {\n-    ///             <::std::pin::Pin>::new_unchecked(&mut pinned)\n-    ///         }) {\n+    ///         match unsafe { ::std::future::poll_with_context(\n+    ///             <::std::pin::Pin>::new_unchecked(&mut pinned),\n+    ///             task_context,\n+    ///         ) } {\n     ///             ::std::task::Poll::Ready(result) => break result,\n     ///             ::std::task::Poll::Pending => {}\n     ///         }\n-    ///         yield ();\n+    ///         task_context = yield ();\n     ///     }\n     /// }\n     /// ```\n@@ -561,12 +596,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let (pinned_pat, pinned_pat_hid) =\n             self.pat_ident_binding_mode(span, pinned_ident, hir::BindingAnnotation::Mutable);\n \n-        // ::std::future::poll_with_tls_context(unsafe {\n-        //     ::std::pin::Pin::new_unchecked(&mut pinned)\n-        // })`\n+        let task_context_ident = Ident::with_dummy_span(sym::_task_context);\n+\n+        // unsafe {\n+        //     ::std::future::poll_with_context(\n+        //         ::std::pin::Pin::new_unchecked(&mut pinned),\n+        //         task_context,\n+        //     )\n+        // }\n         let poll_expr = {\n             let pinned = self.expr_ident(span, pinned_ident, pinned_pat_hid);\n             let ref_mut_pinned = self.expr_mut_addr_of(span, pinned);\n+            let task_context = if let Some(task_context_hid) = self.task_context {\n+                self.expr_ident_mut(span, task_context_ident, task_context_hid)\n+            } else {\n+                // Use of `await` outside of an async context, we cannot use `task_context` here.\n+                self.expr_err(span)\n+            };\n             let pin_ty_id = self.next_id();\n             let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n                 pin_ty_id,\n@@ -575,14 +621,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 \"new_unchecked\",\n                 arena_vec![self; ref_mut_pinned],\n             );\n-            let new_unchecked =\n-                self.arena.alloc(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n-            let unsafe_expr = self.expr_unsafe(new_unchecked);\n-            self.expr_call_std_path(\n+            let new_unchecked = self.expr(span, new_unchecked_expr_kind, ThinVec::new());\n+            let call = self.expr_call_std_path(\n                 gen_future_span,\n-                &[sym::future, sym::poll_with_tls_context],\n-                arena_vec![self; unsafe_expr],\n-            )\n+                &[sym::future, sym::poll_with_context],\n+                arena_vec![self; new_unchecked, task_context],\n+            );\n+            self.arena.alloc(self.expr_unsafe(call))\n         };\n \n         // `::std::task::Poll::Ready(result) => break result`\n@@ -622,14 +667,26 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             self.stmt_expr(span, match_expr)\n         };\n \n+        // task_context = yield ();\n         let yield_stmt = {\n             let unit = self.expr_unit(span);\n             let yield_expr = self.expr(\n                 span,\n                 hir::ExprKind::Yield(unit, hir::YieldSource::Await),\n                 ThinVec::new(),\n             );\n-            self.stmt_expr(span, yield_expr)\n+            let yield_expr = self.arena.alloc(yield_expr);\n+\n+            if let Some(task_context_hid) = self.task_context {\n+                let lhs = self.expr_ident(span, task_context_ident, task_context_hid);\n+                let assign =\n+                    self.expr(span, hir::ExprKind::Assign(lhs, yield_expr, span), AttrVec::new());\n+                self.stmt_expr(span, assign)\n+            } else {\n+                // Use of `await` outside of an async context. Return `yield_expr` so that we can\n+                // proceed with type checking.\n+                self.stmt(span, hir::StmtKind::Semi(yield_expr))\n+            }\n         };\n \n         let loop_block = self.block_all(span, arena_vec![self; inner_match_stmt, yield_stmt], None);"}, {"sha": "c22b2812a9e3c43af282e70656bbd213f201c2b6", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -814,7 +814,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Construct `ExprKind::Err` for the given `span`.\n-    fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n+    crate fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::Err, AttrVec::new())\n     }\n \n@@ -960,7 +960,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id\n     }\n \n-    fn lower_body(\n+    pub(super) fn lower_body(\n         &mut self,\n         f: impl FnOnce(&mut Self) -> (&'hir [hir::Param<'hir>], hir::Expr<'hir>),\n     ) -> hir::BodyId {"}, {"sha": "24fe51fc4d0d1290bcc8d57de4d043d09ac807f0", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -116,6 +116,10 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n+    /// When inside an `async` context, this is the `HirId` of the\n+    /// `task_context` local bound to the resume argument of the generator.\n+    task_context: Option<hir::HirId>,\n+\n     /// Used to get the current `fn`'s def span to point to when using `await`\n     /// outside of an `async fn`.\n     current_item: Option<Span>,\n@@ -294,6 +298,7 @@ pub fn lower_crate<'a, 'hir>(\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n         generator_kind: None,\n+        task_context: None,\n         current_item: None,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,"}, {"sha": "64a810bdcf687a1fe7caf09ebb6970f1c885ac01", "filename": "src/librustc_builtin_macros/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -87,7 +87,7 @@ fn decodable_substructure(\n     let blkarg = cx.ident_of(\"_d\", trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n-    return match *substr.fields {\n+    match *substr.fields {\n         StaticStruct(_, ref summary) => {\n             let nfields = match *summary {\n                 Unnamed(ref fields, _) => fields.len(),\n@@ -178,7 +178,7 @@ fn decodable_substructure(\n             )\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in derive(Decodable)\"),\n-    };\n+    }\n }\n \n /// Creates a decoder for a single enum variant/struct:"}, {"sha": "27d5263320041221b3ac3d18c340db64b0849eac", "filename": "src/librustc_builtin_macros/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -53,7 +53,7 @@ fn default_substructure(\n     let default_ident = cx.std_path(&[kw::Default, sym::Default, kw::Default]);\n     let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n-    return match *substr.fields {\n+    match *substr.fields {\n         StaticStruct(_, ref summary) => match *summary {\n             Unnamed(ref fields, is_tuple) => {\n                 if !is_tuple {\n@@ -83,5 +83,5 @@ fn default_substructure(\n             DummyResult::raw_expr(trait_span, true)\n         }\n         _ => cx.span_bug(trait_span, \"method in `derive(Default)`\"),\n-    };\n+    }\n }"}, {"sha": "54926ec3fd502aeb44cf1ebbeb2c697e5073e4aa", "filename": "src/librustc_builtin_macros/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -173,7 +173,7 @@ fn encodable_substructure(\n         ],\n     ));\n \n-    return match *substr.fields {\n+    match *substr.fields {\n         Struct(_, ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\", trait_span);\n             let mut stmts = Vec::new();\n@@ -283,5 +283,5 @@ fn encodable_substructure(\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in derive(Encodable)\"),\n-    };\n+    }\n }"}, {"sha": "ee32e914acba4e3493579f08242d1d3e5e796752", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -489,7 +489,6 @@ impl<'a> TraitDef<'a> {\n                 // set earlier; see\n                 // librustc_expand/expand.rs:MacroExpander::fully_expand_fragment()\n                 // librustc_expand/base.rs:Annotatable::derive_allowed()\n-                return;\n             }\n         }\n     }"}, {"sha": "e6a87e4d82586771c2afa796e622bec3554636a9", "filename": "src/librustc_builtin_macros/format_foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat_foreign.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -359,7 +359,7 @@ pub mod printf {\n         //\n         // Note: `move` used to capture copies of the cursors as they are *now*.\n         let fallback = move || {\n-            return Some((\n+            Some((\n                 Substitution::Format(Format {\n                     span: start.slice_between(next).unwrap(),\n                     parameter: None,\n@@ -371,7 +371,7 @@ pub mod printf {\n                     position: InnerSpan::new(start.at, next.at),\n                 }),\n                 next.slice_after(),\n-            ));\n+            ))\n         };\n \n         // Next parsing state."}, {"sha": "718498f04b94ed56fbc63665559eb8cddb3a0367", "filename": "src/librustc_builtin_macros/source_util.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fsource_util.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -4,13 +4,15 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{self, *};\n+use rustc_expand::module::DirectoryOwnership;\n use rustc_expand::panictry;\n use rustc_parse::{self, new_sub_parser_from_file, parser::Parser};\n use rustc_session::lint::builtin::INCOMPLETE_INCLUDE;\n use rustc_span::symbol::Symbol;\n use rustc_span::{self, Pos, Span};\n \n use smallvec::SmallVec;\n+use std::rc::Rc;\n \n use rustc_data_structures::sync::Lrc;\n \n@@ -101,7 +103,7 @@ pub fn expand_include<'cx>(\n         None => return DummyResult::any(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let file = match cx.resolve_path(file, sp) {\n+    let mut file = match cx.resolve_path(file, sp) {\n         Ok(f) => f,\n         Err(mut err) => {\n             err.emit();\n@@ -110,6 +112,15 @@ pub fn expand_include<'cx>(\n     };\n     let p = new_sub_parser_from_file(cx.parse_sess(), &file, None, sp);\n \n+    // If in the included file we have e.g., `mod bar;`,\n+    // then the path of `bar.rs` should be relative to the directory of `file`.\n+    // See https://github.com/rust-lang/rust/pull/69838/files#r395217057 for a discussion.\n+    // `MacroExpander::fully_expand_fragment` later restores, so \"stack discipline\" is maintained.\n+    file.pop();\n+    cx.current_expansion.directory_ownership = DirectoryOwnership::Owned { relative: None };\n+    let mod_path = cx.current_expansion.module.mod_path.clone();\n+    cx.current_expansion.module = Rc::new(ModuleData { mod_path, directory: file });\n+\n     struct ExpandResult<'a> {\n         p: Parser<'a>,\n     }"}, {"sha": "f1fe40d919eebb36e3055657295b1512b11294f9", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -146,7 +146,7 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n             }\n \n             // ok, don't skip this\n-            return false;\n+            false\n         })\n     }\n "}, {"sha": "0c8ce39132abb51283b205432a01ee711b7863e5", "filename": "src/librustc_codegen_llvm/back/bytecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -83,7 +83,7 @@ pub fn encode(identifier: &str, bytecode: &[u8]) -> Vec<u8> {\n         encoded.push(0);\n     }\n \n-    return encoded;\n+    encoded\n }\n \n pub struct DecodedBytecode<'a> {\n@@ -132,7 +132,7 @@ impl<'a> DecodedBytecode<'a> {\n     pub fn bytecode(&self) -> Vec<u8> {\n         let mut data = Vec::new();\n         DeflateDecoder::new(self.encoded_bytecode).read_to_end(&mut data).unwrap();\n-        return data;\n+        data\n     }\n \n     pub fn identifier(&self) -> &'a str {"}, {"sha": "f72060868128c3624b4eb402162c110fbd1e1202", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -96,15 +96,11 @@ impl BackendTypes for CodegenCx<'ll, 'tcx> {\n \n impl CodegenCx<'ll, 'tcx> {\n     pub fn const_array(&self, ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n-        unsafe {\n-            return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n-        }\n+        unsafe { llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint) }\n     }\n \n     pub fn const_vector(&self, elts: &[&'ll Value]) -> &'ll Value {\n-        unsafe {\n-            return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n-        }\n+        unsafe { llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint) }\n     }\n \n     pub fn const_bytes(&self, bytes: &[u8]) -> &'ll Value {\n@@ -330,7 +326,7 @@ pub fn val_ty(v: &Value) -> &Type {\n pub fn bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n     unsafe {\n         let ptr = bytes.as_ptr() as *const c_char;\n-        return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n+        llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True)\n     }\n }\n "}, {"sha": "4427997c2732d4c77064d82a1f6460e9b954e7b0", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -800,7 +800,7 @@ impl CodegenCx<'b, 'tcx> {\n             ifn!(\"llvm.dbg.declare\", fn(self.type_metadata(), self.type_metadata()) -> void);\n             ifn!(\"llvm.dbg.value\", fn(self.type_metadata(), t_i64, self.type_metadata()) -> void);\n         }\n-        return None;\n+        None\n     }\n }\n "}, {"sha": "f35220cc6666ad059c4bb47d980f6918e5b6749f", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -203,7 +203,7 @@ impl TypeMap<'ll, 'tcx> {\n         let key = self.unique_id_interner.intern(&unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n-        return UniqueTypeId(key);\n+        UniqueTypeId(key)\n     }\n \n     /// Gets the `UniqueTypeId` for an enum variant. Enum variants are not really\n@@ -314,7 +314,7 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n                     member_holding_stub,\n                     member_descriptions,\n                 );\n-                return MetadataCreationResult::new(metadata_stub, true);\n+                MetadataCreationResult::new(metadata_stub, true)\n             }\n         }\n     }\n@@ -364,7 +364,7 @@ fn fixed_vec_metadata(\n         )\n     };\n \n-    return MetadataCreationResult::new(metadata, false);\n+    MetadataCreationResult::new(metadata, false)\n }\n \n fn vec_slice_metadata(\n@@ -445,7 +445,7 @@ fn subroutine_type_metadata(\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n-    return MetadataCreationResult::new(\n+    MetadataCreationResult::new(\n         unsafe {\n             llvm::LLVMRustDIBuilderCreateSubroutineType(\n                 DIB(cx),\n@@ -454,7 +454,7 @@ fn subroutine_type_metadata(\n             )\n         },\n         false,\n-    );\n+    )\n }\n \n // FIXME(1563): This is all a bit of a hack because 'trait pointer' is an ill-\n@@ -781,7 +781,7 @@ fn file_metadata_raw(\n     let key = (file_name, directory);\n \n     match debug_context(cx).created_files.borrow_mut().entry(key) {\n-        Entry::Occupied(o) => return o.get(),\n+        Entry::Occupied(o) => o.get(),\n         Entry::Vacant(v) => {\n             let (file_name, directory) = v.key();\n             debug!(\"file_metadata: file_name: {:?}, directory: {:?}\", file_name, directory);\n@@ -831,7 +831,7 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n         )\n     };\n \n-    return ty_metadata;\n+    ty_metadata\n }\n \n fn foreign_type_metadata(\n@@ -1273,11 +1273,11 @@ fn prepare_union_metadata(\n fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n     // On MSVC we have to use the fallback mode, because LLVM doesn't\n     // lower variant parts to PDB.\n-    return cx.sess().target.target.options.is_like_msvc\n+    cx.sess().target.target.options.is_like_msvc\n         // LLVM version 7 did not release with an important bug fix;\n         // but the required patch is in the LLVM 8.  Rust LLVM reports\n         // 8 as well.\n-        || llvm_util::get_major_version() < 8;\n+        || llvm_util::get_major_version() < 8\n }\n \n // FIXME(eddyb) maybe precompute this? Right now it's computed once\n@@ -2075,7 +2075,7 @@ fn prepare_enum_metadata(\n         }\n     };\n \n-    return create_and_register_recursive_type_forward_declaration(\n+    create_and_register_recursive_type_forward_declaration(\n         cx,\n         enum_type,\n         unique_type_id,\n@@ -2088,7 +2088,7 @@ fn prepare_enum_metadata(\n             containing_scope,\n             span,\n         }),\n-    );\n+    )\n }\n \n /// Creates debug information for a composite type, that is, anything that"}, {"sha": "41829d4ee42562842e4ef82eca57c7cbda23797f", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -444,7 +444,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 vec![]\n             };\n \n-            return create_DIArray(DIB(cx), &template_params[..]);\n+            create_DIArray(DIB(cx), &template_params[..])\n         }\n \n         fn get_parameter_names(cx: &CodegenCx<'_, '_>, generics: &ty::Generics) -> Vec<Symbol> {"}, {"sha": "b42d760a773450d38c2fdef52221da624fa2144b", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -24,9 +24,7 @@ pub fn is_node_local_to_unit(cx: &CodegenCx<'_, '_>, def_id: DefId) -> bool {\n \n #[allow(non_snake_case)]\n pub fn create_DIArray(builder: &DIBuilder<'ll>, arr: &[Option<&'ll DIDescriptor>]) -> &'ll DIArray {\n-    return unsafe {\n-        llvm::LLVMRustDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n-    };\n+    unsafe { llvm::LLVMRustDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32) }\n }\n \n #[inline]"}, {"sha": "64db4f7462df81d860c559c94550bcbaa012a688", "filename": "src/librustc_codegen_llvm/llvm/archive_ro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -27,13 +27,13 @@ impl ArchiveRO {\n     /// If this archive is used with a mutable method, then an error will be\n     /// raised.\n     pub fn open(dst: &Path) -> Result<ArchiveRO, String> {\n-        return unsafe {\n+        unsafe {\n             let s = path_to_c_string(dst);\n             let ar = super::LLVMRustOpenArchive(s.as_ptr()).ok_or_else(|| {\n                 super::last_error().unwrap_or_else(|| \"failed to open archive\".to_owned())\n             })?;\n             Ok(ArchiveRO { raw: ar })\n-        };\n+        }\n     }\n \n     pub fn iter(&self) -> Iter<'_> {"}, {"sha": "0208bb73abdbe1e5d3c07e0c53ec190e73b8366e", "filename": "src/librustc_codegen_ssa/back/command.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -119,7 +119,7 @@ impl Command {\n         for k in &self.env_remove {\n             ret.env_remove(k);\n         }\n-        return ret;\n+        ret\n     }\n \n     // extensions"}, {"sha": "5fd16cb121fdafbea5166729b7fc9d662c0ca728", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -852,7 +852,7 @@ impl CrateInfo {\n             info.missing_lang_items.insert(cnum, missing);\n         }\n \n-        return info;\n+        info\n     }\n }\n \n@@ -887,7 +887,7 @@ pub fn provide_both(providers: &mut Providers<'_>) {\n                 }\n             }\n         }\n-        return tcx.sess.opts.optimize;\n+        tcx.sess.opts.optimize\n     };\n \n     providers.dllimport_foreign_items = |tcx, krate| {"}, {"sha": "a7f9340dead88589dee03485f49faf96fc3fb458", "filename": "src/librustc_data_structures/graph/dominators/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -125,9 +125,9 @@ impl<'dom, Node: Idx> Iterator for Iter<'dom, Node> {\n             } else {\n                 self.node = Some(dom);\n             }\n-            return Some(node);\n+            Some(node)\n         } else {\n-            return None;\n+            None\n         }\n     }\n }"}, {"sha": "e3e076e769f5d14c91c39d98a059fa3b86ddcb9e", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -752,7 +752,7 @@ impl RustcDefaultCalls {\n                 PrintRequest::NativeStaticLibs => {}\n             }\n         }\n-        return Compilation::Stop;\n+        Compilation::Stop\n     }\n }\n "}, {"sha": "3e663df866caaac49ba8e63468672409c5430359", "filename": "src/librustc_error_codes/error_codes/E0439.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0439.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0439.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0439.md?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -1,5 +1,6 @@\n-The length of the platform-intrinsic function `simd_shuffle`\n-wasn't specified. Erroneous code example:\n+The length of the platform-intrinsic function `simd_shuffle` wasn't specified.\n+\n+Erroneous code example:\n \n ```compile_fail,E0439\n #![feature(platform_intrinsics)]"}, {"sha": "0d777d88cad3a6b1e7ca080ae5260005b355686d", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -778,7 +778,7 @@ fn may_begin_with(token: &Token, name: Name) -> bool {\n         }\n         sym::ty => token.can_begin_type(),\n         sym::ident => get_macro_ident(token).is_some(),\n-        sym::literal => token.can_begin_literal_or_bool(),\n+        sym::literal => token.can_begin_literal_maybe_minus(),\n         sym::vis => match token.kind {\n             // The follow-set of :vis + \"priv\" keyword + interpolated\n             token::Comma | token::Ident(..) | token::Interpolated(_) => true,"}, {"sha": "c5446116f4c5093076e0938d577ec6cf74a3efec", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -175,6 +175,6 @@ impl AssertModuleSource<'tcx> {\n             return true;\n         }\n         debug!(\"check_config: no match found\");\n-        return false;\n+        false\n     }\n }"}, {"sha": "ba586d0cfba04d5d6305a19205e3a691f24da727", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -132,7 +132,6 @@ where\n         }\n         Err(err) => {\n             sess.err(&format!(\"failed to write dep-graph to `{}`: {}\", path_buf.display(), err));\n-            return;\n         }\n     }\n }"}, {"sha": "8f8fc4f137b7355ac22fb7206aacadfc5db601b7", "filename": "src/librustc_infer/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fequate.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -136,7 +136,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n         } else {\n             // Fast path for the common case.\n             self.relate(a.skip_binder(), b.skip_binder())?;\n-            return Ok(a.clone());\n+            Ok(a.clone())\n         }\n     }\n }"}, {"sha": "689323ce4834658aa334f5a306cb66044ec557be", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -142,6 +142,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             .span_label(span_2, String::new())\n             .span_label(span, span_label)\n             .emit();\n-        return Some(ErrorReported);\n+        Some(ErrorReported)\n     }\n }"}, {"sha": "6a5a1c46d4caf38c8f5be2d2c030a678bbfaea8e", "filename": "src/librustc_infer/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -30,7 +30,7 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n \n         let span = self.trace.cause.span;\n \n-        return self.infcx.commit_if_ok(|snapshot| {\n+        self.infcx.commit_if_ok(|snapshot| {\n             // First, we instantiate each bound region in the supertype with a\n             // fresh placeholder region.\n             let (b_prime, placeholder_map) = self.infcx.replace_bound_vars_with_placeholders(b);\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n             Ok(ty::Binder::bind(result))\n-        });\n+        })\n     }\n }\n "}, {"sha": "821b9f72c0b20e6c04fe584c552a21aefce0703e", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -452,12 +452,10 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 debug!(\"Expanding value of {:?} from {:?} to {:?}\", b_vid, cur_region, lub);\n \n                 *b_data = VarValue::Value(lub);\n-                return true;\n+                true\n             }\n \n-            VarValue::ErrorValue => {\n-                return false;\n-            }\n+            VarValue::ErrorValue => false,\n         }\n     }\n \n@@ -804,7 +802,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n         }\n \n-        return graph;\n+        graph\n     }\n \n     fn collect_error_for_expanding_node("}, {"sha": "c194e968013eb0ecfeebeec4161f2e675ef0cee8", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -877,7 +877,7 @@ where\n                     // If sub-roots are equal, then `for_vid` and\n                     // `vid` are related via subtyping.\n                     debug!(\"TypeGeneralizer::tys: occurs check failed\");\n-                    return Err(TypeError::Mismatch);\n+                    Err(TypeError::Mismatch)\n                 } else {\n                     match variables.probe(vid) {\n                         TypeVariableValue::Known { value: u } => {\n@@ -898,7 +898,7 @@ where\n \n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n-                            return Ok(u);\n+                            Ok(u)\n                         }\n                     }\n                 }"}, {"sha": "38475b02e5db84073e407333bc996bc0c9c9c26c", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -505,7 +505,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             self.undo_log.push(AddVar(vid));\n         }\n         debug!(\"created new region variable {:?} in {:?} with origin {:?}\", vid, universe, origin);\n-        return vid;\n+        vid\n     }\n \n     /// Returns the universe for the given variable."}, {"sha": "d3ac58a49c8d5faa595f826e3e8fc27902cf9a98", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -527,10 +527,10 @@ impl Cursor<'_> {\n         if self.first() == '\\'' {\n             self.bump();\n             let kind = Char { terminated: true };\n-            return Literal { kind, suffix_start: self.len_consumed() };\n+            Literal { kind, suffix_start: self.len_consumed() }\n+        } else {\n+            Lifetime { starts_with_number }\n         }\n-\n-        return Lifetime { starts_with_number };\n     }\n \n     fn single_quoted_string(&mut self) -> bool {"}, {"sha": "88f2284cd6154ac4eefce533feb3f0405519adba", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -269,7 +269,7 @@ impl EarlyLintPass for UnsafeCode {\n                 })\n             }\n \n-            _ => return,\n+            _ => {}\n         }\n     }\n "}, {"sha": "fcd50001cb3a9473e180184988c1ffca4cff68cc", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -273,7 +273,6 @@ fn lint_int_literal<'a, 'tcx>(\n                     cx.sess()\n                         .source_map()\n                         .span_to_snippet(lit.span)\n-                        .ok()\n                         .expect(\"must get snippet from literal\"),\n                     t.name_str(),\n                     min,\n@@ -338,7 +337,6 @@ fn lint_uint_literal<'a, 'tcx>(\n                     cx.sess()\n                         .source_map()\n                         .span_to_snippet(lit.span)\n-                        .ok()\n                         .expect(\"must get snippet from literal\"),\n                     t.name_str(),\n                     min,"}, {"sha": "b5826d6a5efa655035f1ab196fac88b5b0a8214f", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -543,7 +543,7 @@ impl EarlyLintPass for UnusedParens {\n             // Do not lint on `(..)` as that will result in the other arms being useless.\n             Paren(_)\n             // The other cases do not contain sub-patterns.\n-            | Wild | Rest | Lit(..) | MacCall(..) | Range(..) | Ident(.., None) | Path(..) => return,\n+            | Wild | Rest | Lit(..) | MacCall(..) | Range(..) | Ident(.., None) | Path(..) => {},\n             // These are list-like patterns; parens can always be removed.\n             TupleStruct(_, ps) | Tuple(ps) | Slice(ps) | Or(ps) => for p in ps {\n                 self.check_unused_parens_pat(cx, p, false, false);"}, {"sha": "9b6e427abc1fd96abe04a3fa0ff91a790604c8d2", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -264,7 +264,7 @@ impl<'a> CrateLoader<'a> {\n                 ret = Some(cnum);\n             }\n         });\n-        return ret;\n+        ret\n     }\n \n     fn verify_no_symbol_conflicts(&self, span: Span, root: &CrateRoot<'_>) {"}, {"sha": "60b8239a82155d87d8126c16710709035d6f0d50", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::itemlikevisit::ItemLikeVisitor;\n crate fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n     let mut collector = Collector { tcx, modules: Vec::new() };\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n-    return collector.modules;\n+    collector.modules\n }\n \n struct Collector<'tcx> {"}, {"sha": "56b26efe5bf1e6c89949bcc37084fbc44f4d1781", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -16,7 +16,7 @@ crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n         }\n     }\n \n-    return collector.args;\n+    collector.args\n }\n \n struct Collector {"}, {"sha": "2f9be599ba94b9ffc1a8c3035b638755120dd8c7", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -949,7 +949,7 @@ fn get_metadata_section(\n     let start = Instant::now();\n     let ret = get_metadata_section_imp(target, flavor, filename, loader);\n     info!(\"reading {:?} => {:?}\", filename.file_name().unwrap(), start.elapsed());\n-    return ret;\n+    ret\n }\n \n /// A trivial wrapper for `Mmap` that implements `StableDeref`."}, {"sha": "19d2d620f58a7b90ccd8da678480cf0ad45ef52b", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -15,7 +15,7 @@ crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n     let mut collector = Collector { tcx, libs: Vec::new() };\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n     collector.process_command_line();\n-    return collector.libs;\n+    collector.libs\n }\n \n crate fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {"}, {"sha": "ca75daf1aa9b222f72bdd3a1b4a43ca05747fe2d", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -170,7 +170,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n             .iter()\n             .filter_map(|&(exported_symbol, export_level)| {\n                 if let ExportedSymbol::NonGeneric(def_id) = exported_symbol {\n-                    return Some((def_id, export_level))\n+                    Some((def_id, export_level))\n                 } else {\n                     None\n                 }"}, {"sha": "9f4f0ce5620b52d8149443c7368380cc10f884ec", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -273,7 +273,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n             assert_eq!(borrow_data.borrowed_place, *place);\n         }\n \n-        return self.super_rvalue(rvalue, location);\n+        self.super_rvalue(rvalue, location)\n     }\n }\n "}, {"sha": "d1d0ba215e08e26eea9fee38a149f78ca055591d", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -500,7 +500,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             }\n         }\n \n-        return None;\n+        None\n     }\n \n     /// We've found an enum/struct/union type with the substitutions"}, {"sha": "f2194c77c8991aee23f6bf65bb12bd101bc741aa", "filename": "src/librustc_mir/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -64,13 +64,16 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n         };\n \n+        debug!(\n+            \"equate_inputs_and_outputs: normalized_input_tys = {:?}, local_decls = {:?}\",\n+            normalized_input_tys, body.local_decls\n+        );\n+\n         // Equate expected input tys with those in the MIR.\n         for (&normalized_input_ty, argument_index) in normalized_input_tys.iter().zip(0..) {\n             // In MIR, argument N is stored in local N+1.\n             let local = Local::new(argument_index + 1);\n \n-            debug!(\"equate_inputs_and_outputs: normalized_input_ty = {:?}\", normalized_input_ty);\n-\n             let mir_input_ty = body.local_decls[local].ty;\n             let mir_input_span = body.local_decls[local].source_info.span;\n             self.equate_normalized_input_or_output("}, {"sha": "d81aae6523a45addab79a39c408720556dac7a1c", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -56,7 +56,7 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n \n         self.return_to_block(ret.map(|r| r.1))?;\n         self.dump_place(*dest);\n-        return Ok(true);\n+        Ok(true)\n     }\n \n     /// \"Intercept\" a function call to a panic-related function"}, {"sha": "c98a5e84729ab949d8b188b77d3ff9317ad3a928", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -122,7 +122,7 @@ pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Opti\n             }\n         }\n     }\n-    return None;\n+    None\n }\n \n pub struct MoveDataParamEnv<'tcx> {\n@@ -171,7 +171,7 @@ where\n                     return None;\n                 }\n             }\n-            return None;\n+            None\n         };\n \n         let print_preflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_preflow);"}, {"sha": "dc2b0e1b983dc452f20defc3983065829dc2b404", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -39,7 +39,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let loc_ty = self\n             .tcx\n             .type_of(self.tcx.require_lang_item(PanicLocationLangItem, None))\n-            .subst(*self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_static.into()].iter()));\n+            .subst(*self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_erased.into()].iter()));\n         let loc_layout = self.layout_of(loc_ty).unwrap();\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation);\n "}, {"sha": "4c82172ae4517cb1958bdd4254c978f0e2c7381e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -604,7 +604,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     .not_undef()\n                     .and_then(|raw_discr| self.force_bits(raw_discr, discr_val.layout.size))\n                     .map_err(|_| err_ub!(InvalidDiscriminant(raw_discr.erase_tag())))?;\n-                let real_discr = if discr_val.layout.ty.is_signed() {\n+                let real_discr = if discr_val.layout.abi.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n                     // requires first sign extending with the discriminant layout\n                     let sexted = sign_extend(bits_discr, discr_val.layout.size) as i128;"}, {"sha": "76a5aecb9db62e3bee38ed0b40533f3f2e1786ad", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -64,7 +64,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Ge => l >= r,\n             _ => bug!(\"Invalid operation on char: {:?}\", bin_op),\n         };\n-        return (Scalar::from_bool(res), false, self.tcx.types.bool);\n+        (Scalar::from_bool(res), false, self.tcx.types.bool)\n     }\n \n     fn binary_bool_op(\n@@ -87,7 +87,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             BitXor => l ^ r,\n             _ => bug!(\"Invalid operation on bool: {:?}\", bin_op),\n         };\n-        return (Scalar::from_bool(res), false, self.tcx.types.bool);\n+        (Scalar::from_bool(res), false, self.tcx.types.bool)\n     }\n \n     fn binary_float_op<F: Float + Into<Scalar<M::PointerTag>>>(\n@@ -113,7 +113,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Rem => ((l % r).value.into(), ty),\n             _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n         };\n-        return (val, false, ty);\n+        (val, false, ty)\n     }\n \n     fn binary_int_op("}, {"sha": "027e33abc7bb193b19909b964eb9dea33da2c695", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -212,9 +212,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind {\n-                ty::Slice(..) | ty::Str => {\n-                    return self.mplace.meta.unwrap_meta().to_machine_usize(cx);\n-                }\n+                ty::Slice(..) | ty::Str => self.mplace.meta.unwrap_meta().to_machine_usize(cx),\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n@@ -920,6 +918,10 @@ where\n             // most likey we *are* running `typeck` right now. Investigate whether we can bail out\n             // on `typeck_tables().has_errors` at all const eval entry points.\n             debug!(\"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n+            self.tcx.sess.delay_span_bug(\n+                self.tcx.span,\n+                \"size-changing transmute, should have been caught by transmute checking\",\n+            );\n             throw_inval!(TransmuteSizeDiff(src.layout.ty, dest.layout.ty));\n         }\n         // Unsized copies rely on interpreting `src.meta` with `dest.layout`, we want"}, {"sha": "a9e45a032a6bee9b4b2bc2a1c4654a14cefbeefc", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -240,7 +240,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 assert!(caller_abi == Abi::RustIntrinsic || caller_abi == Abi::PlatformIntrinsic);\n-                return M::call_intrinsic(self, span, instance, args, ret, unwind);\n+                M::call_intrinsic(self, span, instance, args, ret, unwind)\n             }\n             ty::InstanceDef::VtableShim(..)\n             | ty::InstanceDef::ReifyShim(..)"}, {"sha": "a592e8d9c05fe6863d89ca6659eaa66aa331c67d", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -751,7 +751,7 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx\n         bug!(\"cannot create local mono-item for {:?}\", def_id)\n     }\n \n-    return true;\n+    true\n }\n \n /// For a given pair of source and target type that occur in an unsizing coercion,"}, {"sha": "3d219ac2c01ec940ce659d408ef78ea1ffe8a69f", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -32,6 +32,7 @@ impl<'tcx> MirPass<'tcx> for CleanupNonCodegenStatements {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n         let mut delete = DeleteNonCodegenStatements { tcx };\n         delete.visit_body(body);\n+        body.user_type_annotations.raw.clear();\n     }\n }\n "}, {"sha": "43876380c840e0f1785b8e1df8607d2086c763a3", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -483,7 +483,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             err.span_label(source_info.span, format!(\"{:?}\", panic));\n             err.emit()\n         });\n-        return None;\n+        None\n     }\n \n     fn check_unary_op("}, {"sha": "996b97c03b14e773538d692807f0f781c0665e41", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1057dc97afce39ff6a224966ece3ed438af4c1f5/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1057dc97afce39ff6a224966ece3ed438af4c1f5/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=1057dc97afce39ff6a224966ece3ed438af4c1f5", "patch": "@@ -1,63 +0,0 @@\n-//! This pass erases all early-bound regions from the types occurring in the MIR.\n-//! We want to do this once just before codegen, so codegen does not have to take\n-//! care erasing regions all over the place.\n-//! N.B., we do _not_ erase regions of statements that are relevant for\n-//! \"types-as-contracts\"-validation, namely, `AcquireValid` and `ReleaseValid`.\n-\n-use crate::transform::{MirPass, MirSource};\n-use rustc::mir::visit::{MutVisitor, TyContext};\n-use rustc::mir::*;\n-use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, Ty, TyCtxt};\n-\n-struct EraseRegionsVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl EraseRegionsVisitor<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        EraseRegionsVisitor { tcx }\n-    }\n-}\n-\n-impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n-        *ty = self.tcx.erase_regions(ty);\n-    }\n-\n-    fn visit_region(&mut self, region: &mut ty::Region<'tcx>, _: Location) {\n-        *region = self.tcx.lifetimes.re_erased;\n-    }\n-\n-    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _: Location) {\n-        *constant = self.tcx.erase_regions(constant);\n-    }\n-\n-    fn visit_substs(&mut self, substs: &mut SubstsRef<'tcx>, _: Location) {\n-        *substs = self.tcx.erase_regions(substs);\n-    }\n-\n-    fn process_projection_elem(&mut self, elem: &PlaceElem<'tcx>) -> Option<PlaceElem<'tcx>> {\n-        if let PlaceElem::Field(field, ty) = elem {\n-            let new_ty = self.tcx.erase_regions(ty);\n-\n-            if new_ty != *ty {\n-                return Some(PlaceElem::Field(*field, new_ty));\n-            }\n-        }\n-\n-        None\n-    }\n-}\n-\n-pub struct EraseRegions;\n-\n-impl<'tcx> MirPass<'tcx> for EraseRegions {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n-        EraseRegionsVisitor::new(tcx).visit_body(body);\n-    }\n-}"}, {"sha": "82c5ac689b56838eb22bd839b264d2894c7e2660", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -357,18 +357,11 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n     }\n }\n \n-fn make_generator_state_argument_indirect<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    body: &mut BodyAndCache<'tcx>,\n-) {\n+fn make_generator_state_argument_indirect<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyAndCache<'tcx>) {\n     let gen_ty = body.local_decls.raw[1].ty;\n \n-    let region = ty::ReFree(ty::FreeRegion { scope: def_id, bound_region: ty::BoundRegion::BrEnv });\n-\n-    let region = tcx.mk_region(region);\n-\n-    let ref_gen_ty = tcx.mk_ref(region, ty::TypeAndMut { ty: gen_ty, mutbl: hir::Mutability::Mut });\n+    let ref_gen_ty =\n+        tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut { ty: gen_ty, mutbl: Mutability::Mut });\n \n     // Replace the by value generator argument\n     body.local_decls.raw[1].ty = ref_gen_ty;\n@@ -874,7 +867,6 @@ fn elaborate_generator_drops<'tcx>(\n fn create_generator_drop_shim<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     transform: &TransformVisitor<'tcx>,\n-    def_id: DefId,\n     source: MirSource<'tcx>,\n     gen_ty: Ty<'tcx>,\n     body: &mut BodyAndCache<'tcx>,\n@@ -912,7 +904,7 @@ fn create_generator_drop_shim<'tcx>(\n         local_info: LocalInfo::Other,\n     };\n \n-    make_generator_state_argument_indirect(tcx, def_id, &mut body);\n+    make_generator_state_argument_indirect(tcx, &mut body);\n \n     // Change the generator argument from &mut to *mut\n     body.local_decls[SELF_ARG] = LocalDecl {\n@@ -1047,7 +1039,6 @@ fn can_unwind<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) -> bool {\n fn create_generator_resume_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     transform: TransformVisitor<'tcx>,\n-    def_id: DefId,\n     source: MirSource<'tcx>,\n     body: &mut BodyAndCache<'tcx>,\n     can_return: bool,\n@@ -1112,7 +1103,7 @@ fn create_generator_resume_function<'tcx>(\n \n     insert_switch(body, cases, &transform, TerminatorKind::Unreachable);\n \n-    make_generator_state_argument_indirect(tcx, def_id, body);\n+    make_generator_state_argument_indirect(tcx, body);\n     make_generator_state_argument_pinned(tcx, body);\n \n     no_landing_pads(tcx, body);\n@@ -1332,11 +1323,11 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         // Create a copy of our MIR and use it to create the drop shim for the generator\n         let drop_shim =\n-            create_generator_drop_shim(tcx, &transform, def_id, source, gen_ty, body, drop_clean);\n+            create_generator_drop_shim(tcx, &transform, source, gen_ty, body, drop_clean);\n \n         body.generator_drop = Some(box drop_shim);\n \n         // Create the Generator::resume function\n-        create_generator_resume_function(tcx, transform, def_id, source, body, can_return);\n+        create_generator_resume_function(tcx, transform, source, body, can_return);\n     }\n }"}, {"sha": "50868434baa32779344da04d08abb826bf2e890e", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -22,7 +22,6 @@ pub mod copy_prop;\n pub mod deaggregator;\n pub mod dump_mir;\n pub mod elaborate_drops;\n-pub mod erase_regions;\n pub mod generator;\n pub mod inline;\n pub mod instcombine;\n@@ -296,8 +295,6 @@ fn run_optimization_passes<'tcx>(\n             &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n             // No lifetime analysis based on borrowing can be done from here on out.\n \n-            // From here on out, regions are gone.\n-            &erase_regions::EraseRegions,\n             // Optimizations begin.\n             &unreachable_prop::UnreachablePropagation,\n             &uninhabited_enum_branching::UninhabitedEnumBranching,\n@@ -341,6 +338,9 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &BodyAndCache<'_> {\n     let mut body = body.steal();\n     run_optimization_passes(tcx, &mut body, def_id, None);\n     body.ensure_predecessors();\n+\n+    debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");\n+\n     tcx.arena.alloc(body)\n }\n \n@@ -358,5 +358,7 @@ fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &IndexVec<Promoted, BodyAndCa\n         body.ensure_predecessors();\n     }\n \n+    debug_assert!(!promoted.has_free_regions(), \"Free regions in promoted MIR\");\n+\n     tcx.intern_promoted(promoted)\n }"}, {"sha": "a27c80d91cfd0c39cc0b2e331c9964e97299052a", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -913,7 +913,13 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         ty,\n                         val: ty::ConstKind::Unevaluated(\n                             def_id,\n-                            InternalSubsts::identity_for_item(tcx, def_id),\n+                            InternalSubsts::for_item(tcx, def_id, |param, _| {\n+                                if let ty::GenericParamDefKind::Lifetime = param.kind {\n+                                    tcx.lifetimes.re_erased.into()\n+                                } else {\n+                                    tcx.mk_param_from_def(param)\n+                                }\n+                            }),\n                             Some(promoted_id),\n                         ),\n                     }),"}, {"sha": "c21834bfde84b744bf674f3ede722cc84c259ff0", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -6,7 +6,7 @@ use rustc::middle::lang_items;\n use rustc::middle::region;\n use rustc::mir::*;\n use rustc::ty::subst::Subst;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_attr::{self as attr, UnwindAttr};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -43,8 +43,7 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n             ..\n         })\n         | Node::TraitItem(hir::TraitItem {\n-            kind:\n-                hir::TraitItemKind::Fn(hir::FnSig { decl, .. }, hir::TraitFn::Provided(body_id)),\n+            kind: hir::TraitItemKind::Fn(hir::FnSig { decl, .. }, hir::TraitFn::Provided(body_id)),\n             ..\n         }) => (*body_id, decl.output.span()),\n         Node::Item(hir::Item { kind: hir::ItemKind::Static(ty, _, body_id), .. })\n@@ -128,12 +127,8 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n                 let ty = if fn_sig.c_variadic && index == fn_sig.inputs().len() {\n                     let va_list_did =\n                         tcx.require_lang_item(lang_items::VaListTypeLangItem, Some(arg.span));\n-                    let region = tcx.mk_region(ty::ReScope(region::Scope {\n-                        id: body.value.hir_id.local_id,\n-                        data: region::ScopeData::CallSite,\n-                    }));\n \n-                    tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n+                    tcx.type_of(va_list_did).subst(tcx, &[tcx.lifetimes.re_erased.into()])\n                 } else {\n                     fn_sig.inputs()[index]\n                 };\n@@ -189,6 +184,20 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n \n         let mut body = BodyAndCache::new(body);\n         body.ensure_predecessors();\n+\n+        // The borrow checker will replace all the regions here with its own\n+        // inference variables. There's no point having non-erased regions here.\n+        // The exception is `body.user_type_annotations`, which is used unmodified\n+        // by borrow checking.\n+        debug_assert!(\n+            !(body.local_decls.has_free_regions()\n+                || body.basic_blocks().has_free_regions()\n+                || body.var_debug_info.has_free_regions()\n+                || body.yield_ty.has_free_regions()),\n+            \"Unexpected free regions in MIR: {:?}\",\n+            body,\n+        );\n+\n         body\n     })\n }\n@@ -209,7 +218,7 @@ fn liberated_closure_env_ty(\n     };\n \n     let closure_env_ty = tcx.closure_env_ty(closure_def_id, closure_substs).unwrap();\n-    tcx.liberate_late_bound_regions(closure_def_id, &closure_env_ty)\n+    tcx.erase_late_bound_regions(&closure_env_ty)\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -368,7 +377,7 @@ impl BlockContext {\n             }\n         }\n \n-        return None;\n+        None\n     }\n \n     /// Looks at the topmost frame on the BlockContext and reports"}, {"sha": "07a9d91cd746d344a2bd5e6dbfb7db3c1d7191b6", "filename": "src/librustc_mir_build/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -98,7 +98,7 @@ fn mirror_stmts<'a, 'tcx>(\n             }\n         }\n     }\n-    return result;\n+    result\n }\n \n crate fn to_expr_ref<'a, 'tcx>("}, {"sha": "58db7d286e7e65b003d71817fed6f7080d7ce677", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -320,7 +320,7 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n                 going with stringified version\"\n         );\n     }\n-    return tokens_for_real;\n+    tokens_for_real\n }\n \n fn prepend_attrs("}, {"sha": "b993857681a301e1456896ababc6ec03df0c17ed", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -996,7 +996,7 @@ impl<'a> Parser<'a> {\n                 let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(literal), attrs);\n                 self.maybe_recover_from_bad_qpath(expr, true)\n             }\n-            None => return Err(self.expected_expression_found()),\n+            None => Err(self.expected_expression_found()),\n         }\n     }\n \n@@ -1374,6 +1374,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n+    /// Keep this in sync with `Token::can_begin_literal_maybe_minus`.\n     pub fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);\n \n@@ -1713,7 +1714,7 @@ impl<'a> Parser<'a> {\n         }\n         let hi = self.token.span;\n         self.bump();\n-        return Ok(self.mk_expr(lo.to(hi), ExprKind::Match(scrutinee, arms), attrs));\n+        Ok(self.mk_expr(lo.to(hi), ExprKind::Match(scrutinee, arms), attrs))\n     }\n \n     pub(super) fn parse_arm(&mut self) -> PResult<'a, Arm> {"}, {"sha": "5f37069afbe4c9a2fcd660f621f2e99a95c03306", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -314,7 +314,7 @@ impl<'a> Parser<'a> {\n                 \" struct \".into(),\n                 Applicability::MaybeIncorrect, // speculative\n             );\n-            return Err(err);\n+            Err(err)\n         } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n             let ident = self.parse_ident().unwrap();\n             self.bump(); // `(`\n@@ -362,7 +362,7 @@ impl<'a> Parser<'a> {\n                     );\n                 }\n             }\n-            return Err(err);\n+            Err(err)\n         } else if self.look_ahead(1, |t| *t == token::Lt) {\n             let ident = self.parse_ident().unwrap();\n             self.eat_to_tokens(&[&token::Gt]);\n@@ -384,7 +384,7 @@ impl<'a> Parser<'a> {\n                     Applicability::MachineApplicable,\n                 );\n             }\n-            return Err(err);\n+            Err(err)\n         } else {\n             Ok(())\n         }\n@@ -910,7 +910,7 @@ impl<'a> Parser<'a> {\n         let span = self.sess.source_map().def_span(span);\n         let msg = format!(\"{} is not supported in {}\", kind.descr(), ctx);\n         self.struct_span_err(span, &msg).emit();\n-        return None;\n+        None\n     }\n \n     fn error_on_foreign_const(&self, span: Span, ident: Ident) {\n@@ -1509,7 +1509,7 @@ impl<'a> Parser<'a> {\n                 })\n             // `extern ABI fn`\n             || self.check_keyword(kw::Extern)\n-                && self.look_ahead(1, |t| t.can_begin_literal_or_bool())\n+                && self.look_ahead(1, |t| t.can_begin_literal_maybe_minus())\n                 && self.look_ahead(2, |t| t.is_keyword(kw::Fn))\n     }\n "}, {"sha": "f7f7ac89a1864f1db190443dc063676450eb6f14", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -696,7 +696,7 @@ impl<'a> Parser<'a> {\n         self.look_ahead(dist, |t| {\n             t.is_path_start() // e.g. `MY_CONST`;\n                 || t.kind == token::Dot // e.g. `.5` for recovery;\n-                || t.can_begin_literal_or_bool() // e.g. `42`.\n+                || t.can_begin_literal_maybe_minus() // e.g. `42`.\n                 || t.is_whole_expr()\n         })\n     }\n@@ -918,7 +918,7 @@ impl<'a> Parser<'a> {\n             }\n             err.emit();\n         }\n-        return Ok((fields, etc));\n+        Ok((fields, etc))\n     }\n \n     /// Recover on `...` as if it were `..` to avoid further errors."}, {"sha": "d43f5d67113a1e348055e6dabda92ef4757bf5a5", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -278,7 +278,7 @@ impl<'a> Parser<'a> {\n             _ => {}\n         }\n         e.span_label(sp, \"expected `{`\");\n-        return Err(e);\n+        Err(e)\n     }\n \n     /// Parses a block. Inner attributes are allowed."}, {"sha": "bf577d26b0fed870dcdad0bab25f400ba63c98e6", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -864,7 +864,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             first_merge,\n             any_changed\n         );\n-        return any_changed;\n+        any_changed\n     }\n \n     // Indicates that a local variable was *defined*; we know that no"}, {"sha": "fa2afae469c045a1beb0c1f4c862bfe74891b0d9", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n                 return true;\n             }\n         }\n-        return false;\n+        false\n     }\n     fn emit_unlabled_cf_in_while_condition(&mut self, span: Span, cf_type: &str) {\n         struct_span_err!("}, {"sha": "1e9c6c91d385f3ea432860ff12d9785930bf8e43", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -30,9 +30,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>, attrs: Codegen\n     }\n \n     match item.kind {\n-        hir::ItemKind::Fn(ref sig, ..) if sig.header.is_const() => {\n-            return true;\n-        }\n+        hir::ItemKind::Fn(ref sig, ..) if sig.header.is_const() => true,\n         hir::ItemKind::Impl { .. } | hir::ItemKind::Fn(..) => {\n             let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n             generics.requires_monomorphization(tcx)"}, {"sha": "8fa5a4fbc61f46920b0ad4ee617a12da6d5bc31d", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -465,7 +465,7 @@ fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n             |v| intravisit::walk_crate(v, krate),\n         );\n     }\n-    return index;\n+    index\n }\n \n /// Cross-references the feature names of unstable APIs with enabled"}, {"sha": "a3510737b7edc7be1088514185f8efaa0f31129f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -1423,7 +1423,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 Some(_) | None => false,\n             }\n         } else {\n-            return false;\n+            false\n         }\n     }\n \n@@ -1837,7 +1837,7 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n             && self.tcx.is_private_dep(item_id.krate);\n \n         log::debug!(\"leaks_private_dep(item_id={:?})={}\", item_id, ret);\n-        return ret;\n+        ret\n     }\n }\n "}, {"sha": "0dee997f2ed962071d52a2e6a12409423adca400", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -200,7 +200,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_pat(&mut self, pat: &'a Pat) {\n         match pat.kind {\n-            PatKind::MacCall(..) => return self.visit_macro_invoc(pat.id),\n+            PatKind::MacCall(..) => self.visit_macro_invoc(pat.id),\n             _ => visit::walk_pat(self, pat),\n         }\n     }"}, {"sha": "95597e8ebf1e9247ced9b18f9b81b2b61b66c66c", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -1108,7 +1108,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                     match binding.kind {\n                                         // Never suggest the name that has binding error\n                                         // i.e., the name that cannot be previously resolved\n-                                        NameBindingKind::Res(Res::Err, _) => return None,\n+                                        NameBindingKind::Res(Res::Err, _) => None,\n                                         _ => Some(&i.name),\n                                     }\n                                 }"}, {"sha": "e1256551e24da2fd62c1e9bc9f21c1fc9a5ebd57", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -380,7 +380,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 _ => (),\n             }\n         };\n-        return has_self_arg;\n+        has_self_arg\n     }\n \n     fn followed_by_brace(&self, span: Span) -> (bool, Option<(Span, String)>) {\n@@ -430,7 +430,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 break;\n             }\n         }\n-        return (followed_by_brace, closing_brace);\n+        (followed_by_brace, closing_brace)\n     }\n \n     /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`"}, {"sha": "bc843fccc4c71369b9b043e57a0f3fd8d06e651e", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -133,7 +133,7 @@ impl RegionExt for Region {\n /// that it corresponds to.\n ///\n /// FIXME. This struct gets converted to a `ResolveLifetimes` for\n-/// actual use. It has the same data, but indexed by `DefIndex`.  This\n+/// actual use. It has the same data, but indexed by `LocalDefId`.  This\n /// is silly.\n #[derive(Default)]\n struct NamedRegionMap {"}, {"sha": "166fc48b44c4c87533a98d70638923557c56a937", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -83,7 +83,7 @@ fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKi\n // line-breaks and is slow.\n fn fast_print_path(path: &ast::Path) -> Symbol {\n     if path.segments.len() == 1 {\n-        return path.segments[0].ident.name;\n+        path.segments[0].ident.name\n     } else {\n         let mut path_str = String::with_capacity(64);\n         for (i, segment) in path.segments.iter().enumerate() {"}, {"sha": "59084f19045454c1a3608d16a5860b483c842b23", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -534,15 +534,15 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                         let variant = &def.non_enum_variant();\n                         filter!(self.span_utils, ident.span);\n                         let span = self.span_from_span(ident.span);\n-                        return Some(Data::RefData(Ref {\n+                        Some(Data::RefData(Ref {\n                             kind: RefKind::Variable,\n                             span,\n                             ref_id: self\n                                 .tcx\n                                 .find_field_index(ident, variant)\n                                 .map(|index| id_from_def_id(variant.fields[index].did))\n                                 .unwrap_or_else(|| null_id()),\n-                        }));\n+                        }))\n                     }\n                     ty::Tuple(..) => None,\n                     _ => {"}, {"sha": "f16e4ca93d80a5ca0d6a2e3b2569bf063feff42c", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -1140,7 +1140,7 @@ pub fn parse_error_format(\n         _ => {}\n     }\n \n-    return error_format;\n+    error_format\n }\n \n fn parse_crate_edition(matches: &getopts::Matches) -> Edition {"}, {"sha": "68b0bd1a574187d3eb0982e8a7f6985737ee60e4", "filename": "src/librustc_span/caching_source_map_view.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_span%2Fcaching_source_map_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_span%2Fcaching_source_map_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fcaching_source_map_view.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -99,10 +99,6 @@ impl<'sm> CachingSourceMapView<'sm> {\n         cache_entry.line_end = line_bounds.1;\n         cache_entry.time_stamp = self.time_stamp;\n \n-        return Some((\n-            cache_entry.file.clone(),\n-            cache_entry.line_number,\n-            pos - cache_entry.line_start,\n-        ));\n+        Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line_start))\n     }\n }"}, {"sha": "39eb318a785e7c69c514946ae95f6b59dd1192e7", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -368,7 +368,7 @@ impl SourceMap {\n \n     // If there is a doctest offset, applies it to the line.\n     pub fn doctest_offset_line(&self, file: &FileName, orig: usize) -> usize {\n-        return match file {\n+        match file {\n             FileName::DocTest(_, offset) => {\n                 return if *offset >= 0 {\n                     orig + *offset as usize\n@@ -377,7 +377,7 @@ impl SourceMap {\n                 };\n             }\n             _ => orig,\n-        };\n+        }\n     }\n \n     /// Looks up source information about a `BytePos`.\n@@ -569,10 +569,10 @@ impl SourceMap {\n         let local_end = self.lookup_byte_offset(sp.hi());\n \n         if local_begin.sf.start_pos != local_end.sf.start_pos {\n-            return Err(SpanSnippetError::DistinctSources(DistinctSources {\n+            Err(SpanSnippetError::DistinctSources(DistinctSources {\n                 begin: (local_begin.sf.name.clone(), local_begin.sf.start_pos),\n                 end: (local_end.sf.name.clone(), local_end.sf.start_pos),\n-            }));\n+            }))\n         } else {\n             self.ensure_source_file_source_present(local_begin.sf.clone());\n \n@@ -590,13 +590,11 @@ impl SourceMap {\n             }\n \n             if let Some(ref src) = local_begin.sf.src {\n-                return extract_source(src, start_index, end_index);\n+                extract_source(src, start_index, end_index)\n             } else if let Some(src) = local_begin.sf.external_src.borrow().get_source() {\n-                return extract_source(src, start_index, end_index);\n+                extract_source(src, start_index, end_index)\n             } else {\n-                return Err(SpanSnippetError::SourceNotAvailable {\n-                    filename: local_begin.sf.name.clone(),\n-                });\n+                Err(SpanSnippetError::SourceNotAvailable { filename: local_begin.sf.name.clone() })\n             }\n         }\n     }"}, {"sha": "35a97cfd3c3c21f98b7e8438f90acf43d550dffb", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -544,7 +544,7 @@ symbols! {\n         plugin_registrar,\n         plugins,\n         Poll,\n-        poll_with_tls_context,\n+        poll_with_context,\n         powerpc_target_feature,\n         precise_pointer_size_matching,\n         pref_align_of,\n@@ -720,6 +720,7 @@ symbols! {\n         target_has_atomic_load_store,\n         target_thread_local,\n         task,\n+        _task_context,\n         tbm_target_feature,\n         termination_trait,\n         termination_trait_test,"}, {"sha": "635fb80b659801f503e9b0808912342dc67a365c", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -751,7 +751,7 @@ impl Abi {\n                 Primitive::Int(_, signed) => signed,\n                 _ => false,\n             },\n-            _ => false,\n+            _ => panic!(\"`is_signed` on non-scalar ABI {:?}\", self),\n         }\n     }\n "}, {"sha": "bd980e6eb8b8a51327ab363578ac14e42a7463f7", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -113,7 +113,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             return AutoTraitResult::ExplicitImpl;\n         }\n \n-        return tcx.infer_ctxt().enter(|infcx| {\n+        tcx.infer_ctxt().enter(|infcx| {\n             let mut fresh_preds = FxHashSet::default();\n \n             // Due to the way projections are handled by SelectionContext, we need to run\n@@ -219,8 +219,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n             let info = AutoTraitInfo { full_user_env, region_data, vid_to_region };\n \n-            return AutoTraitResult::PositiveImpl(auto_trait_callback(&infcx, info));\n-        });\n+            AutoTraitResult::PositiveImpl(auto_trait_callback(&infcx, info))\n+        })\n     }\n }\n \n@@ -384,7 +384,7 @@ impl AutoTraitFinder<'tcx> {\n             ty, trait_did, new_env, final_user_env\n         );\n \n-        return Some((new_env, final_user_env));\n+        Some((new_env, final_user_env))\n     }\n \n     /// This method is designed to work around the following issue:\n@@ -492,7 +492,7 @@ impl AutoTraitFinder<'tcx> {\n                 }\n                 _ => {}\n             }\n-            return true;\n+            true\n         });\n \n         if should_add_new {\n@@ -591,15 +591,15 @@ impl AutoTraitFinder<'tcx> {\n     }\n \n     fn is_param_no_infer(&self, substs: SubstsRef<'_>) -> bool {\n-        return self.is_of_param(substs.type_at(0)) && !substs.types().any(|t| t.has_infer_types());\n+        self.is_of_param(substs.type_at(0)) && !substs.types().any(|t| t.has_infer_types())\n     }\n \n     pub fn is_of_param(&self, ty: Ty<'_>) -> bool {\n-        return match ty.kind {\n+        match ty.kind {\n             ty::Param(_) => true,\n             ty::Projection(p) => self.is_of_param(p.self_ty()),\n             _ => false,\n-        };\n+        }\n     }\n \n     fn is_self_referential_projection(&self, p: ty::PolyProjectionPredicate<'_>) -> bool {\n@@ -804,7 +804,7 @@ impl AutoTraitFinder<'tcx> {\n                 _ => panic!(\"Unexpected predicate {:?} {:?}\", ty, predicate),\n             };\n         }\n-        return true;\n+        true\n     }\n \n     pub fn clean_pred("}, {"sha": "dc13af99fec6c7d0b5aaac1759a1826400a110d8", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -221,10 +221,10 @@ pub fn trait_ref_is_knowable<'tcx>(\n     // we are an owner.\n     if orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok() {\n         debug!(\"trait_ref_is_knowable: orphan check passed\");\n-        return None;\n+        None\n     } else {\n         debug!(\"trait_ref_is_knowable: nonlocal, nonfundamental, unowned\");\n-        return Some(Conflict::Upstream);\n+        Some(Conflict::Upstream)\n     }\n }\n "}, {"sha": "18b2ca89837208d585c7135af5dc11fa1be6dafd", "filename": "src/librustc_trait_selection/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -111,11 +111,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }),\n             hir::Node::Expr(hir::Expr { .. }) => {\n                 let parent_hid = hir.get_parent_node(hir_id);\n-                if parent_hid != hir_id {\n-                    return self.describe_enclosure(parent_hid);\n-                } else {\n-                    None\n-                }\n+                if parent_hid != hir_id { self.describe_enclosure(parent_hid) } else { None }\n             }\n             _ => None,\n         }"}, {"sha": "522a8084cdc0d5555f4a84b496e4fe73103917b9", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // Different to previous arm because one is `&hir::Local` and the other\n             // is `P<hir::Local>`.\n             Some(hir::Node::Local(local)) => get_name(err, &local.pat.kind),\n-            _ => return None,\n+            _ => None,\n         }\n     }\n "}, {"sha": "99412fafcfa8d854c2b265e1c68c04e17011e9b7", "filename": "src/librustc_trait_selection/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -169,12 +169,12 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                                 debug!(\"QueryNormalizer: result = {:#?}\", result);\n                                 debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n                                 self.obligations.extend(obligations);\n-                                return result.normalized_ty;\n+                                result.normalized_ty\n                             }\n \n                             Err(_) => {\n                                 self.error = true;\n-                                return ty;\n+                                ty\n                             }\n                         }\n                     }"}, {"sha": "5f40c1cefca45e88d60fc2ef48fd15c18ea84430", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -595,7 +595,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         }\n \n         // if we made it through that loop above, we made progress!\n-        return true;\n+        true\n     }\n \n     fn nominal_obligations("}, {"sha": "ed6259d4573610142f57c9b9712246d0ca7db546", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -146,7 +146,7 @@ crate fn program_clauses_for_env<'tcx>(\n \n     debug!(\"program_clauses_for_env: closure = {:#?}\", closure);\n \n-    return tcx.mk_clauses(closure.into_iter());\n+    tcx.mk_clauses(closure.into_iter())\n }\n \n crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {"}, {"sha": "3b72da23bafae80f8314526f801544ab6d43313a", "filename": "src/librustc_ty/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ty%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_ty%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fneeds_drop.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -132,7 +132,7 @@ where\n             }\n         }\n \n-        return None;\n+        None\n     }\n }\n "}, {"sha": "3ee6d5df7356b385887ad9d24bf1fcd9e642bee0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -2128,7 +2128,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 return Err(ErrorReported);\n             }\n         }\n-        return Ok(bound);\n+        Ok(bound)\n     }\n \n     fn complain_about_assoc_type_not_found<I>(\n@@ -2709,7 +2709,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::Err => {\n                 self.set_tainted_by_errors();\n-                return self.tcx().types.err;\n+                self.tcx().types.err\n             }\n             _ => span_bug!(span, \"unexpected resolution: {:?}\", path.res),\n         }\n@@ -3047,7 +3047,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             )\n             .emit();\n         }\n-        return Some(r);\n+        Some(r)\n     }\n }\n "}, {"sha": "d19422311719590b8c26cb678222f041136ec2d6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -1580,7 +1580,7 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: DefId) -> bool {\n     } else {\n         span_bug!(span, \"unions must be ty::Adt, but got {:?}\", item_type.kind);\n     }\n-    return true;\n+    true\n }\n \n /// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n@@ -2313,7 +2313,7 @@ fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: DefId) -> bool {\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),\n     }\n-    return true;\n+    true\n }\n \n pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {"}, {"sha": "c6ee9ab60abf3b3764e619e9233f78597700027b", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -272,9 +272,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     item.span,\n                 );\n             }\n-            ty::Error => {\n-                return;\n-            }\n+            ty::Error => {}\n             _ => {\n                 struct_span_err!(\n                     self.tcx.sess,\n@@ -288,7 +286,6 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                        to wrap it instead\",\n                 )\n                 .emit();\n-                return;\n             }\n         }\n     }"}, {"sha": "44ef4ebd463d7448671438ccd5cd87d9d940ac0c", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -290,7 +290,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                             DUMMY_SP,\n                             &format!(\"unexpected const parent path {:?}\", parent_node,),\n                         );\n-                        return tcx.types.err;\n+                        tcx.types.err\n                     }\n                 }\n "}, {"sha": "ef94500f5c44436c7eafb3384ca66e5fd0361f05", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -270,7 +270,7 @@ fn check_static_lifetimes<'tcx>(\n     span: Span,\n ) {\n     if tcx.any_free_region_meets(parent_substs, |r| *r == ty::ReStatic) {\n-        tcx.sess.struct_span_err(span, &format!(\"cannot specialize on `'static` lifetime\")).emit();\n+        tcx.sess.struct_span_err(span, \"cannot specialize on `'static` lifetime\").emit();\n     }\n }\n "}, {"sha": "98300385c8fb8876fec63de84292ef5a02dc9f47", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -8,7 +8,6 @@ use rustc_ast::attr;\n use rustc_span::symbol::sym;\n use rustc_span::FileName;\n use serde::Serialize;\n-use serde_json;\n \n use std::collections::BTreeMap;\n use std::ops;"}, {"sha": "e10d466030f0b1abc135e1418373c8d08fc0ea40", "filename": "src/libstd/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibstd%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibstd%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbacktrace.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -250,7 +250,7 @@ impl Backtrace {\n             },\n         };\n         ENABLED.store(enabled as usize + 1, SeqCst);\n-        return enabled;\n+        enabled\n     }\n \n     /// Capture a stack backtrace of the current thread."}, {"sha": "c0675eeba98da602fba6d31893d89578bb86d3e5", "filename": "src/libstd/future.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -1,12 +1,14 @@\n //! Asynchronous values.\n \n-use core::cell::Cell;\n-use core::marker::Unpin;\n-use core::ops::{Drop, Generator, GeneratorState};\n-use core::option::Option;\n-use core::pin::Pin;\n-use core::ptr::NonNull;\n-use core::task::{Context, Poll};\n+#[cfg(bootstrap)]\n+use core::{\n+    cell::Cell,\n+    marker::Unpin,\n+    ops::{Drop, Generator, GeneratorState},\n+    pin::Pin,\n+    ptr::NonNull,\n+    task::{Context, Poll},\n+};\n \n #[doc(inline)]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n@@ -17,22 +19,26 @@ pub use core::future::*;\n /// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n /// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n // This is `const` to avoid extra errors after we recover from `const async fn`\n+#[cfg(bootstrap)]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n pub const fn from_generator<T: Generator<Yield = ()>>(x: T) -> impl Future<Output = T::Return> {\n     GenFuture(x)\n }\n \n /// A wrapper around generators used to implement `Future` for `async`/`await` code.\n+#[cfg(bootstrap)]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n struct GenFuture<T: Generator<Yield = ()>>(T);\n \n // We rely on the fact that async/await futures are immovable in order to create\n // self-referential borrows in the underlying generator.\n+#[cfg(bootstrap)]\n impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n \n+#[cfg(bootstrap)]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n@@ -48,12 +54,15 @@ impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n     }\n }\n \n+#[cfg(bootstrap)]\n thread_local! {\n     static TLS_CX: Cell<Option<NonNull<Context<'static>>>> = Cell::new(None);\n }\n \n+#[cfg(bootstrap)]\n struct SetOnDrop(Option<NonNull<Context<'static>>>);\n \n+#[cfg(bootstrap)]\n impl Drop for SetOnDrop {\n     fn drop(&mut self) {\n         TLS_CX.with(|tls_cx| {\n@@ -64,13 +73,15 @@ impl Drop for SetOnDrop {\n \n // Safety: the returned guard must drop before `cx` is dropped and before\n // any previous guard is dropped.\n+#[cfg(bootstrap)]\n unsafe fn set_task_context(cx: &mut Context<'_>) -> SetOnDrop {\n     // transmute the context's lifetime to 'static so we can store it.\n     let cx = core::mem::transmute::<&mut Context<'_>, &mut Context<'static>>(cx);\n     let old_cx = TLS_CX.with(|tls_cx| tls_cx.replace(Some(NonNull::from(cx))));\n     SetOnDrop(old_cx)\n }\n \n+#[cfg(bootstrap)]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Polls a future in the current thread-local task waker."}, {"sha": "e9b1e86d7ae49ed8e66a6f5a995be65ceb8ef4d5", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -28,7 +28,7 @@ pub fn lock() -> impl Drop {\n \n     unsafe {\n         LOCK.lock();\n-        return Guard;\n+        Guard\n     }\n }\n "}, {"sha": "3d2d88a676d0d911d196da7695d57fcef72097d8", "filename": "src/test/debuginfo/pretty-std-collections.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -17,35 +17,43 @@\n // gdb-command: print btree_set\n // gdb-check:$1 = BTreeSet<i32>(len: 15) = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}\n \n+// gdb-command: print empty_btree_set\n+// gdb-check:$2 = BTreeSet<i32>(len: 0)\n+\n // gdb-command: print btree_map\n-// gdb-check:$2 = BTreeMap<i32, i32>(len: 15) = {[0] = 0, [1] = 1, [2] = 2, [3] = 3, [4] = 4, [5] = 5, [6] = 6, [7] = 7, [8] = 8, [9] = 9, [10] = 10, [11] = 11, [12] = 12, [13] = 13, [14] = 14}\n+// gdb-check:$3 = BTreeMap<i32, i32>(len: 15) = {[0] = 0, [1] = 1, [2] = 2, [3] = 3, [4] = 4, [5] = 5, [6] = 6, [7] = 7, [8] = 8, [9] = 9, [10] = 10, [11] = 11, [12] = 12, [13] = 13, [14] = 14}\n+\n+// gdb-command: print empty_btree_map\n+// gdb-check:$4 = BTreeMap<i32, u32>(len: 0)\n \n // gdb-command: print vec_deque\n-// gdb-check:$3 = VecDeque<i32>(len: 3, cap: 8) = {5, 3, 7}\n+// gdb-check:$5 = VecDeque<i32>(len: 3, cap: 8) = {5, 3, 7}\n \n // gdb-command: print vec_deque2\n-// gdb-check:$4 = VecDeque<i32>(len: 7, cap: 8) = {2, 3, 4, 5, 6, 7, 8}\n+// gdb-check:$6 = VecDeque<i32>(len: 7, cap: 8) = {2, 3, 4, 5, 6, 7, 8}\n \n #![allow(unused_variables)]\n-use std::collections::BTreeSet;\n use std::collections::BTreeMap;\n+use std::collections::BTreeSet;\n use std::collections::VecDeque;\n \n-\n fn main() {\n-\n     // BTreeSet\n     let mut btree_set = BTreeSet::new();\n     for i in 0..15 {\n         btree_set.insert(i);\n     }\n \n+    let mut empty_btree_set: BTreeSet<i32> = BTreeSet::new();\n+\n     // BTreeMap\n     let mut btree_map = BTreeMap::new();\n     for i in 0..15 {\n         btree_map.insert(i, i);\n     }\n \n+    let mut empty_btree_map: BTreeMap<i32, u32> = BTreeMap::new();\n+\n     // VecDeque\n     let mut vec_deque = VecDeque::new();\n     vec_deque.push_back(5);\n@@ -63,4 +71,6 @@ fn main() {\n     zzz(); // #break\n }\n \n-fn zzz() { () }\n+fn zzz() {\n+    ()\n+}"}, {"sha": "57f30acb3a643bc35ab4934e638e20e7a35510fa", "filename": "src/test/mir-opt/array-index-is-temporary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fmir-opt%2Farray-index-is-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fmir-opt%2Farray-index-is-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Farray-index-is-temporary.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -15,7 +15,7 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.main.EraseRegions.after.mir\n+// START rustc.main.SimplifyCfg-elaborate-drops.after.mir\n //     bb0: {\n //         ...\n //         _4 = &mut _2;\n@@ -38,4 +38,4 @@ fn main() {\n //         ...\n //         return;\n //     }\n-// END rustc.main.EraseRegions.after.mir\n+// END rustc.main.SimplifyCfg-elaborate-drops.after.mir"}, {"sha": "0fb685c3c4e6d2bff2b9fa8c02c4903d1999008c", "filename": "src/test/mir-opt/byte_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fmir-opt%2Fbyte_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fmir-opt%2Fbyte_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbyte_slice.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -6,10 +6,10 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.main.EraseRegions.after.mir\n+// START rustc.main.SimplifyCfg-elaborate-drops.after.mir\n // ...\n // _1 = const b\"foo\";\n // ...\n // _2 = [const 5u8, const 120u8];\n // ...\n-// END rustc.main.EraseRegions.after.mir\n+// END rustc.main.SimplifyCfg-elaborate-drops.after.mir"}, {"sha": "39b9006017958c5d59c301a14fcf50c261737c3a", "filename": "src/test/mir-opt/packed-struct-drop-aligned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -15,7 +15,7 @@ impl Drop for Droppy {\n }\n \n // END RUST SOURCE\n-// START rustc.main.EraseRegions.before.mir\n+// START rustc.main.SimplifyCfg-elaborate-drops.after.mir\n // fn main() -> () {\n //     let mut _0: ();\n //     let mut _1: Packed;\n@@ -56,4 +56,4 @@ impl Drop for Droppy {\n //         drop(_1) -> [return: bb2, unwind: bb1];\n //     }\n // }\n-// END rustc.main.EraseRegions.before.mir\n+// END rustc.main.SimplifyCfg-elaborate-drops.after.mir"}, {"sha": "e917441200b8a3d103b77cabc949dd9659885175", "filename": "src/test/mir-opt/retag.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fmir-opt%2Fretag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fmir-opt%2Fretag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -8,8 +8,12 @@ struct Test(i32);\n \n impl Test {\n     // Make sure we run the pass on a method, not just on bare functions.\n-    fn foo<'x>(&self, x: &'x mut i32) -> &'x mut i32 { x }\n-    fn foo_shr<'x>(&self, x: &'x i32) -> &'x i32 { x }\n+    fn foo<'x>(&self, x: &'x mut i32) -> &'x mut i32 {\n+        x\n+    }\n+    fn foo_shr<'x>(&self, x: &'x i32) -> &'x i32 {\n+        x\n+    }\n }\n \n impl Drop for Test {\n@@ -27,7 +31,10 @@ fn main() {\n     }\n \n     // Also test closures\n-    let c: fn(&i32) -> &i32 = |x: &i32| -> &i32 { let _y = x; x };\n+    let c: fn(&i32) -> &i32 = |x: &i32| -> &i32 {\n+        let _y = x;\n+        x\n+    };\n     let _w = c(&x);\n \n     // need to call `foo_shr` or it doesn't even get generated\n@@ -38,7 +45,7 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.{{impl}}-foo.EraseRegions.after.mir\n+// START rustc.{{impl}}-foo.SimplifyCfg-elaborate-drops.after.mir\n //     bb0: {\n //         Retag([fn entry] _1);\n //         Retag([fn entry] _2);\n@@ -48,8 +55,8 @@ fn main() {\n //         ...\n //         return;\n //     }\n-// END rustc.{{impl}}-foo.EraseRegions.after.mir\n-// START rustc.{{impl}}-foo_shr.EraseRegions.after.mir\n+// END rustc.{{impl}}-foo.SimplifyCfg-elaborate-drops.after.mir\n+// START rustc.{{impl}}-foo_shr.SimplifyCfg-elaborate-drops.after.mir\n //     bb0: {\n //         Retag([fn entry] _1);\n //         Retag([fn entry] _2);\n@@ -59,8 +66,8 @@ fn main() {\n //         ...\n //         return;\n //     }\n-// END rustc.{{impl}}-foo_shr.EraseRegions.after.mir\n-// START rustc.main.EraseRegions.after.mir\n+// END rustc.{{impl}}-foo_shr.SimplifyCfg-elaborate-drops.after.mir\n+// START rustc.main.SimplifyCfg-elaborate-drops.after.mir\n // fn main() -> () {\n //     ...\n //     bb0: {\n@@ -96,8 +103,8 @@ fn main() {\n //\n //     ...\n // }\n-// END rustc.main.EraseRegions.after.mir\n-// START rustc.main-{{closure}}.EraseRegions.after.mir\n+// END rustc.main.SimplifyCfg-elaborate-drops.after.mir\n+// START rustc.main-{{closure}}.SimplifyCfg-elaborate-drops.after.mir\n // fn main::{{closure}}#0(_1: &[closure@main::{{closure}}#0], _2: &i32) -> &i32 {\n //     ...\n //     bb0: {\n@@ -112,7 +119,7 @@ fn main() {\n //         return;\n //     }\n // }\n-// END rustc.main-{{closure}}.EraseRegions.after.mir\n+// END rustc.main-{{closure}}.SimplifyCfg-elaborate-drops.after.mir\n // START rustc.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir\n // fn  std::intrinsics::drop_in_place(_1: *mut Test) -> () {\n //     ..."}, {"sha": "0624c049048c70896535f2db2a5e58214aeb8719", "filename": "src/test/ui/async-await/issues/issue-62009-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -33,10 +33,10 @@ error[E0277]: the trait bound `[closure@$DIR/issue-62009-1.rs:16:5: 16:15]: std:\n LL |     (|_| 2333).await;\n    |     ^^^^^^^^^^^^^^^^ the trait `std::future::Future` is not implemented for `[closure@$DIR/issue-62009-1.rs:16:5: 16:15]`\n    | \n-  ::: $SRC_DIR/libstd/future.rs:LL:COL\n+  ::: $SRC_DIR/libcore/future/mod.rs:LL:COL\n    |\n LL |     F: Future,\n-   |        ------ required by this bound in `std::future::poll_with_tls_context`\n+   |        ------ required by this bound in `std::future::poll_with_context`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "63e93cdff7e7729465df974e48e7a99cdebb994d", "filename": "src/test/ui/async-await/no-std.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fasync-await%2Fno-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fasync-await%2Fno-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-std.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -0,0 +1,13 @@\n+// edition:2018\n+// check-pass\n+\n+#![no_std]\n+#![crate_type = \"rlib\"]\n+\n+use core::future::Future;\n+\n+async fn a(f: impl Future) {\n+    f.await;\n+}\n+\n+fn main() {}"}, {"sha": "2dcb72a5a09cb1f747e9aad77e93862f4a026318", "filename": "src/test/ui/consts/const_forget.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fconsts%2Fconst_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fconsts%2Fconst_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_forget.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+#![feature(const_forget)]\n+\n+use std::mem::forget;\n+\n+const _: () = forget(0i32);\n+const _: () = forget(Vec::<Vec<Box<i32>>>::new());\n+\n+// Writing this function signature without const-forget\n+// triggers compiler errors:\n+// 1) That we use a non-const fn inside a const fn\n+// 2) without the forget, it complains about the destructor of Box\n+//\n+// FIXME: this method cannot be called in const-eval yet, as Box isn't\n+// const constructable\n+#[allow(unused)]\n+const fn const_forget_box<T: ?Sized>(b: Box<T>) {\n+    forget(b);\n+}\n+\n+fn main() {}"}, {"sha": "757307d944f1806d629cb9fc869ec1bf658d6cd0", "filename": "src/test/ui/issues/issue-58319.rs", "status": "added", "additions": 621, "deletions": 0, "changes": 621, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fissues%2Fissue-58319.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fissues%2Fissue-58319.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58319.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -0,0 +1,621 @@\n+// run-pass\n+fn main() {}\n+#[derive(Clone)]\n+pub struct Little;\n+#[derive(Clone)]\n+pub struct Big(\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+    Little,\n+);"}, {"sha": "8b5345da900aa20196770817950cf595bf65ed8d", "filename": "src/test/ui/issues/issue-65131.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fissues%2Fissue-65131.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fissues%2Fissue-65131.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65131.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -0,0 +1,18 @@\n+fn get_pair(_a: &mut u32, _b: &mut u32) {}\n+\n+macro_rules! x10 {\n+    ($($t:tt)*) => {\n+        $($t)* $($t)* $($t)* $($t)* $($t)*\n+        $($t)* $($t)* $($t)* $($t)* $($t)*\n+    }\n+}\n+\n+#[allow(unused_assignments)]\n+fn main() {\n+    let mut x = 1;\n+\n+    get_pair(&mut x, &mut x);\n+    //~^ ERROR: cannot borrow `x` as mutable more than once at a time\n+\n+    x10! { x10!{ x10!{ if x > 0 { x += 2 } else { x += 1 } } } }\n+}"}, {"sha": "e234e6da552a8460cc27a5a8abccf237fe43b7aa", "filename": "src/test/ui/issues/issue-65131.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fissues%2Fissue-65131.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fissues%2Fissue-65131.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65131.stderr?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -0,0 +1,12 @@\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+  --> $DIR/issue-65131.rs:14:22\n+   |\n+LL |     get_pair(&mut x, &mut x);\n+   |     -------- ------  ^^^^^^ second mutable borrow occurs here\n+   |     |        |\n+   |     |        first mutable borrow occurs here\n+   |     first borrow later used by call\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "ec12f8c5cb442ee72def5fa4e2e4a593d5f2795a", "filename": "src/test/ui/macros/issue-69838-dir/bar.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fmacros%2Fissue-69838-dir%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fmacros%2Fissue-69838-dir%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-69838-dir%2Fbar.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -0,0 +1,3 @@\n+// ignore-test -- this is an auxiliary file as part of another test.\n+\n+pub fn i_am_in_bar() {}"}, {"sha": "9900b8fd5092cfdd36ccc3cf931e5ea520d3eec7", "filename": "src/test/ui/macros/issue-69838-dir/included.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fmacros%2Fissue-69838-dir%2Fincluded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fmacros%2Fissue-69838-dir%2Fincluded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-69838-dir%2Fincluded.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -0,0 +1,3 @@\n+// ignore-test -- this is an auxiliary file as part of another test.\n+\n+pub mod bar;"}, {"sha": "2a4e97f0ef5f18c084e55e69468bd4cb845025bd", "filename": "src/test/ui/macros/issue-69838-mods-relative-to-included-path.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fmacros%2Fissue-69838-mods-relative-to-included-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fmacros%2Fissue-69838-mods-relative-to-included-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-69838-mods-relative-to-included-path.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+\n+include!(\"issue-69838-dir/included.rs\");\n+\n+fn main() {\n+    bar::i_am_in_bar();\n+}"}, {"sha": "4ecb21d26ab9b7fe6f99cec1d1122b8acec0b45b", "filename": "src/test/ui/parser/extern-abi-from-mac-literal-frag.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -1,7 +1,7 @@\n // check-pass\n \n // In this test we check that the parser accepts an ABI string when it\n-// comes from a macro `literal` fragment as opposed to a hardcoded string.\n+// comes from a macro `literal` or `expr` fragment as opposed to a hardcoded string.\n \n fn main() {}\n \n@@ -17,10 +17,30 @@ macro_rules! abi_from_lit_frag {\n     }\n }\n \n+macro_rules! abi_from_expr_frag {\n+    ($abi:expr) => {\n+        extern $abi {\n+            fn _import();\n+        }\n+\n+        extern $abi fn _export() {}\n+\n+        type _PTR = extern $abi fn();\n+    };\n+}\n+\n mod rust {\n     abi_from_lit_frag!(\"Rust\");\n }\n \n mod c {\n     abi_from_lit_frag!(\"C\");\n }\n+\n+mod rust_expr {\n+    abi_from_expr_frag!(\"Rust\");\n+}\n+\n+mod c_expr {\n+    abi_from_expr_frag!(\"C\");\n+}"}, {"sha": "aca9d9eb0a5b4c3e837897a45100b238bf8334f1", "filename": "src/test/ui/parser/issue-70050-ntliteral-accepts-negated-lit.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fparser%2Fissue-70050-ntliteral-accepts-negated-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13820478907b09d50baf74f3ff2b78499ecd6c/src%2Ftest%2Fui%2Fparser%2Fissue-70050-ntliteral-accepts-negated-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-70050-ntliteral-accepts-negated-lit.rs?ref=5f13820478907b09d50baf74f3ff2b78499ecd6c", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+macro_rules! foo {\n+    ($a:literal) => {\n+        bar!($a)\n+    };\n+}\n+\n+macro_rules! bar {\n+    ($b:literal) => {};\n+}\n+\n+fn main() {\n+    foo!(-2);\n+    bar!(-2);\n+}"}]}