{"sha": "d2d8ae6575281e92a58899fb8f8c51fc8f84de04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZDhhZTY1NzUyODFlOTJhNTg4OTlmYjhmOGM1MWZjOGY4NGRlMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-24T11:51:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-24T11:51:34Z"}, "message": "Auto merge of #39214 - estebank:fix-labels-without-msg, r=nikomatsakis\n\nFix multiple labels when some don't have message\n\nThe diagnostic emitter now accounts for labels with no text message, presenting the underline on its own, without drawing the line for the non existing message below it. Go from\n\n```\nerror: foo\n --> test.rs:3:6\n  |\n3 |   a { b { c } d }\n  |   ----^^^^^^^----\n  |   |   |\n  |   |   `b` is a good letter\n  |\n```\n\nto\n\n```\nerror: foo\n --> test.rs:3:6\n  |\n3 |   a { b { c } d }\n  |   ----^^^^^^^----\n  |       |\n  |       `b` is a good letter\n```\n\nfrom\n\n```\nerror: foo\n --> test.rs:3:6\n  |\n3 |   a { b { c } d }\n  |   ^^^^-------^^^^\n  |   |   |\n  |   |\n  |   `a` is a good letter\n```\n\nto\n\n```\nerror: foo\n --> test.rs:3:6\n  |\n3 |   a { b { c } d }\n  |   ^^^^-------^^^^ `a` is a good letter\n```\n\nand from\n\n```\nerror: foo\n --> test.rs:3:6\n  |\n3 |   a { b { c } d }\n  |   ^^^^-------^^^^\n  |   |   |\n  |   |\n  |\n```\n\nto\n\n```\nerror: foo\n --> test.rs:3:6\n  |\n3 |   a { b { c } d }\n  |   ^^^^-------^^^^\n```\nr? @nikomatsakis\ncc @jonathandturner, @GuillaumeGomez, @nrc", "tree": {"sha": "b57fd6179467be20a977c2c77e24011525c0a305", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b57fd6179467be20a977c2c77e24011525c0a305"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2d8ae6575281e92a58899fb8f8c51fc8f84de04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2d8ae6575281e92a58899fb8f8c51fc8f84de04", "html_url": "https://github.com/rust-lang/rust/commit/d2d8ae6575281e92a58899fb8f8c51fc8f84de04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2d8ae6575281e92a58899fb8f8c51fc8f84de04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65b17f53ef19439d6f14adadc706c745a92956a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/65b17f53ef19439d6f14adadc706c745a92956a2", "html_url": "https://github.com/rust-lang/rust/commit/65b17f53ef19439d6f14adadc706c745a92956a2"}, {"sha": "469ecef422aab0364f87205f39f2830cbdfe6ab1", "url": "https://api.github.com/repos/rust-lang/rust/commits/469ecef422aab0364f87205f39f2830cbdfe6ab1", "html_url": "https://github.com/rust-lang/rust/commit/469ecef422aab0364f87205f39f2830cbdfe6ab1"}], "stats": {"total": 500, "additions": 470, "deletions": 30}, "files": [{"sha": "0b0a9e51cacb0f27901c66d4c99178ab51031bbb", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 47, "deletions": 30, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d2d8ae6575281e92a58899fb8f8c51fc8f84de04/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d8ae6575281e92a58899fb8f8c51fc8f84de04/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=d2d8ae6575281e92a58899fb8f8c51fc8f84de04", "patch": "@@ -339,43 +339,56 @@ impl EmitterWriter {\n         // which is...less weird, at least. In fact, in general, if\n         // the rightmost span overlaps with any other span, we should\n         // use the \"hang below\" version, so we can at least make it\n-        // clear where the span *starts*.\n+        // clear where the span *starts*. There's an exception for this\n+        // logic, when the labels do not have a message:\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //             |\n+        //             x_span\n+        //\n+        // instead of:\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //      |      |\n+        //      |      x_span\n+        //      <EMPTY LINE>\n+        //\n         let mut annotations_position = vec![];\n         let mut line_len = 0;\n         let mut p = 0;\n         let mut ann_iter = annotations.iter().peekable();\n         while let Some(annotation) = ann_iter.next() {\n-            let is_line = if let AnnotationType::MultilineLine(_) = annotation.annotation_type {\n-                true\n-            } else {\n-                false\n-            };\n             let peek = ann_iter.peek();\n             if let Some(next) = peek {\n-                let next_is_line = if let AnnotationType::MultilineLine(_) = next.annotation_type {\n-                    true\n-                } else {\n-                    false\n-                };\n-\n-                if overlaps(next, annotation) && !is_line && !next_is_line {\n+                if overlaps(next, annotation) && !annotation.is_line() && !next.is_line()\n+                    && annotation.has_label()\n+                {\n+                    // This annotation needs a new line in the output.\n                     p += 1;\n                 }\n             }\n             annotations_position.push((p, annotation));\n             if let Some(next) = peek {\n-                let next_is_line = if let AnnotationType::MultilineLine(_) = next.annotation_type {\n-                    true\n-                } else {\n-                    false\n-                };\n                 let l = if let Some(ref label) = next.label {\n                     label.len() + 2\n                 } else {\n                     0\n                 };\n-                if (overlaps(next, annotation) || next.end_col + l > annotation.start_col)\n-                    && !is_line && !next_is_line\n+                if (overlaps(next, annotation)  // Do not allow two labels to be in the same line\n+                    || next.end_col + l > annotation.start_col)  // if they overlap including\n+                                                // padding, to avoid situations like:\n+                                                //\n+                                                //      fn foo(x: u32) {\n+                                                //      -------^------\n+                                                //      |      |\n+                                                //      fn_spanx_span\n+                                                //\n+                    && !annotation.is_line()    // Do not add a new line if this annotation or the\n+                    && !next.is_line()          // next are vertical line placeholders.\n+                    && annotation.has_label()   // Both labels must have some text, otherwise\n+                    && next.has_label()         // they are not overlapping.\n                 {\n                     p += 1;\n                 }\n@@ -412,6 +425,17 @@ impl EmitterWriter {\n             return;\n         }\n \n+        // Write the colunmn separator.\n+        //\n+        // After this we will have:\n+        //\n+        // 2 |   fn foo() {\n+        //   |\n+        //   |\n+        //   |\n+        // 3 |\n+        // 4 |   }\n+        //   |\n         for pos in 0..line_len + 1 {\n             draw_col_separator(buffer, line_offset + pos + 1, width_offset - 2);\n             buffer.putc(line_offset + pos + 1,\n@@ -472,7 +496,8 @@ impl EmitterWriter {\n                 Style::UnderlineSecondary\n             };\n             let pos = pos + 1;\n-            if pos > 1 {\n+\n+            if pos > 1 && annotation.has_label() {\n                 for p in line_offset + 1..line_offset + pos + 1 {\n                     buffer.putc(p,\n                                 code_offset + annotation.start_col,\n@@ -550,16 +575,8 @@ impl EmitterWriter {\n         //   | |  something about `foo`\n         //   | something about `fn foo()`\n         annotations_position.sort_by(|a, b| {\n-            fn len(a: &Annotation) -> usize {\n-                // Account for usize underflows\n-                if a.end_col > a.start_col {\n-                    a.end_col - a.start_col\n-                } else {\n-                    a.start_col - a.end_col\n-                }\n-            }\n             // Decreasing order\n-            len(a.1).cmp(&len(b.1)).reverse()\n+            a.1.len().cmp(&b.1.len()).reverse()\n         });\n \n         // Write the underlines."}, {"sha": "95b03677b72857b9ee6df5ddbe7a0736a83d1333", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d2d8ae6575281e92a58899fb8f8c51fc8f84de04/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d8ae6575281e92a58899fb8f8c51fc8f84de04/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=d2d8ae6575281e92a58899fb8f8c51fc8f84de04", "patch": "@@ -151,6 +151,15 @@ impl Annotation {\n         }\n     }\n \n+    /// Wether this annotation is a vertical line placeholder.\n+    pub fn is_line(&self) -> bool {\n+        if let AnnotationType::MultilineLine(_) = self.annotation_type {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     pub fn is_multiline(&self) -> bool {\n         match self.annotation_type {\n             AnnotationType::Multiline(_) |\n@@ -161,6 +170,32 @@ impl Annotation {\n         }\n     }\n \n+    pub fn len(&self) -> usize {\n+        // Account for usize underflows\n+        if self.end_col > self.start_col {\n+            self.end_col - self.start_col\n+        } else {\n+            self.start_col - self.end_col\n+        }\n+    }\n+\n+    pub fn has_label(&self) -> bool {\n+        if let Some(ref label) = self.label {\n+            // Consider labels with no text as effectively not being there\n+            // to avoid weird output with unnecessary vertical lines, like:\n+            //\n+            //     X | fn foo(x: u32) {\n+            //       | -------^------\n+            //       | |      |\n+            //       | |\n+            //       |\n+            //\n+            // Note that this would be the complete output users would see.\n+            label.len() > 0\n+        } else {\n+            false\n+        }\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "c6d6e6237f2edfd71f904dc993c935f65f08373d", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/d2d8ae6575281e92a58899fb8f8c51fc8f84de04/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d8ae6575281e92a58899fb8f8c51fc8f84de04/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=d2d8ae6575281e92a58899fb8f8c51fc8f84de04", "patch": "@@ -494,6 +494,7 @@ error: foo\n \n \"#);\n }\n+\n #[test]\n fn overlaping_start_and_end() {\n     test_harness(r#\"\n@@ -544,3 +545,390 @@ error: foo\n \n \"#);\n }\n+\n+#[test]\n+fn multiple_labels_primary_without_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"`a` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:7\n+  |\n+3 |   a { b { c } d }\n+  |   ----^^^^-^^-- `a` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_secondary_without_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"`a` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^-------^^ `a` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_primary_without_message_2() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"`b` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:7\n+  |\n+3 |   a { b { c } d }\n+  |   ----^^^^-^^--\n+  |       |\n+  |       `b` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_secondary_without_message_2() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"`b` is a good letter\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^-------^^\n+  |       |\n+  |       `b` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_without_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^-------^^\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_without_message_2() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:7\n+  |\n+3 |   a { b { c } d }\n+  |   ----^^^^-^^--\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_with_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"`a` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"`b` is a good letter\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^-------^^\n+  |   |   |\n+  |   |   `b` is a good letter\n+  |   `a` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn single_label_with_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"`a` is a good letter\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^^^^^^^^^^ `a` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn single_label_without_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^^^^^^^^^^\n+\n+\"#);\n+}"}]}