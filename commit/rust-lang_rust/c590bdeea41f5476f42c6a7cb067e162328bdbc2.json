{"sha": "c590bdeea41f5476f42c6a7cb067e162328bdbc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1OTBiZGVlYTQxZjU0NzZmNDJjNmE3Y2IwNjdlMTYyMzI4YmRiYzI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-26T16:33:12Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-26T17:58:35Z"}, "message": "Make re-exporting of impls work\n\nCloses #1438", "tree": {"sha": "c728974e1ceab0b3598b47e97811cf6201840322", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c728974e1ceab0b3598b47e97811cf6201840322"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c590bdeea41f5476f42c6a7cb067e162328bdbc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c590bdeea41f5476f42c6a7cb067e162328bdbc2", "html_url": "https://github.com/rust-lang/rust/commit/c590bdeea41f5476f42c6a7cb067e162328bdbc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c590bdeea41f5476f42c6a7cb067e162328bdbc2/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bead0e4ccfa65a89bee8db6d4587e297fba1a57", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bead0e4ccfa65a89bee8db6d4587e297fba1a57", "html_url": "https://github.com/rust-lang/rust/commit/6bead0e4ccfa65a89bee8db6d4587e297fba1a57"}], "stats": {"total": 246, "additions": 135, "deletions": 111}, "files": [{"sha": "87b00a9e25bde66fdce49b25ec1749e4f5dad7ec", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=c590bdeea41f5476f42c6a7cb067e162328bdbc2", "patch": "@@ -199,7 +199,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n         time(time_passes, \"translation\",\n              bind trans::trans_crate(sess, crate, ty_cx,\n                                      outputs.obj_filename, exp_map, ast_map,\n-                                     mut_map, copy_map, last_uses,\n+                                     mut_map, copy_map, last_uses, impl_map,\n                                      method_map, dict_map));\n     time(time_passes, \"LLVM passes\",\n          bind link::write::run_passes(sess, llmod, outputs.obj_filename));"}, {"sha": "a3bc668ad9d1f6cf6a4bb0977643525d3f69fcbc", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=c590bdeea41f5476f42c6a7cb067e162328bdbc2", "patch": "@@ -1,6 +1,6 @@\n // Metadata encoding\n \n-import std::{io, ebml, map};\n+import std::{io, ebml, map, list};\n import io::writer_util;\n import syntax::ast::*;\n import syntax::ast_util;\n@@ -151,13 +151,14 @@ fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n \n fn encode_reexport_paths(ebml_w: ebml::writer,\n                          ecx: @encode_ctxt, &index: [entry<str>]) {\n-    ecx.ccx.exp_map.items {|key, def|\n-        let path = key.path;\n-        index += [{val: path, pos: ebml_w.writer.tell()}];\n-        ebml::start_tag(ebml_w, tag_paths_data_item);\n-        encode_name(ebml_w, path);\n-        encode_def_id(ebml_w, ast_util::def_id_of_def(def));\n-        ebml::end_tag(ebml_w);\n+    ecx.ccx.exp_map.items {|path, defs|\n+        for def in *defs {\n+            index += [{val: path, pos: ebml_w.writer.tell()}];\n+            ebml::start_tag(ebml_w, tag_paths_data_item);\n+            encode_name(ebml_w, path);\n+            encode_def_id(ebml_w, ast_util::def_id_of_def(def));\n+            ebml::end_tag(ebml_w);\n+        }\n     }\n }\n \n@@ -258,23 +259,22 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     }\n }\n \n-fn encode_info_for_mod(ebml_w: ebml::writer, md: _mod,\n+fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n                        id: node_id, name: ident) {\n     ebml::start_tag(ebml_w, tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm' as u8);\n     encode_name(ebml_w, name);\n-    for i in md.items {\n-        alt i.node {\n-          item_impl(_, _, _, _) {\n+    alt ecx.ccx.impl_map.get(id) {\n+      list::cons(impls, @list::nil) {\n+        for i in *impls {\n             if ast_util::is_exported(i.ident, md) {\n                 ebml::start_tag(ebml_w, tag_mod_impl);\n-                ebml_w.writer.write(str::bytes(def_to_str(local_def(i.id))));\n+                ebml_w.writer.write(str::bytes(def_to_str(i.did)));\n                 ebml::end_tag(ebml_w);\n             }\n-          }\n-          _ {}\n         }\n+      }\n     }\n     ebml::end_tag(ebml_w);\n }\n@@ -306,7 +306,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::end_tag(ebml_w);\n       }\n       item_mod(m) {\n-        encode_info_for_mod(ebml_w, m, item.id, item.ident);\n+        encode_info_for_mod(ecx, ebml_w, m, item.id, item.ident);\n       }\n       item_native_mod(_) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n@@ -447,7 +447,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     let index: [entry<int>] = [];\n     ebml::start_tag(ebml_w, tag_items_data);\n     index += [{val: crate_node_id, pos: ebml_w.writer.tell()}];\n-    encode_info_for_mod(ebml_w, crate_mod, crate_node_id, \"\");\n+    encode_info_for_mod(ecx, ebml_w, crate_mod, crate_node_id, \"\");\n     ecx.ccx.ast_map.items {|key, val|\n         alt val {\n           middle::ast_map::node_item(i) {"}, {"sha": "f6fe2a79e4be02bcdcfd85a64794c78fcd0adf2d", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 101, "deletions": 80, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=c590bdeea41f5476f42c6a7cb067e162328bdbc2", "patch": "@@ -82,22 +82,6 @@ fn new_ext_hash() -> ext_hash {\n     ret std::map::mk_hashmap::<key, def>(hash, eq);\n }\n \n-fn new_exp_hash() -> exp_map {\n-    type key = {path: str, ns: namespace};\n-    fn hash(v: key) -> uint {\n-        ret str::hash(v.path) +\n-                alt v.ns {\n-                  ns_val(_) { 1u }\n-                  ns_type { 2u }\n-                  ns_module { 3u }\n-                };\n-    }\n-    fn eq(v1: key, v2: key) -> bool {\n-        ret str::eq(v1.path, v2.path) && v1.ns == v2.ns;\n-    }\n-    ret std::map::mk_hashmap::<key, def>(hash, eq);\n-}\n-\n enum mod_index_entry {\n     mie_view_item(@ast::view_item),\n     mie_import_ident(node_id, codemap::span),\n@@ -125,9 +109,9 @@ type indexed_mod = {\n \n type def_map = hashmap<node_id, def>;\n type ext_map = hashmap<def_id, [ident]>;\n-type exp_map = hashmap<{path: str, ns: namespace}, def>;\n+type exp_map = hashmap<str, @mutable [def]>;\n type impl_map = hashmap<node_id, iscopes>;\n-type impl_cache = hashmap<def_id, @[@_impl]>;\n+type impl_cache = hashmap<def_id, option::t<@[@_impl]>>;\n \n type env =\n     {cstore: cstore::cstore,\n@@ -168,7 +152,7 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n           def_map: new_int_hash(),\n           ast_map: amap,\n           imports: new_int_hash(),\n-          exp_map: new_exp_hash(),\n+          exp_map: new_str_hash(),\n           mod_map: new_int_hash(),\n           block_map: new_int_hash(),\n           ext_map: new_def_hash(),\n@@ -1725,41 +1709,50 @@ fn check_exports(e: @env) {\n         let (m, v, t) = (lookup(ns_module),\n                          lookup(ns_val(ns_any_value)),\n                          lookup(ns_type));\n-        maybe_add_reexport(e, path + ident, ns_module, m);\n-        maybe_add_reexport(e, path + ident, ns_val(ns_any_value), v);\n-        maybe_add_reexport(e, path + ident, ns_type, t);\n-        ret is_some(m) || is_some(v) || is_some(t);\n-    }\n-\n-    fn maybe_add_reexport(e: @env, path: str, ns: namespace,\n-                          def: option::t<def>) {\n-        if option::is_some(def) {\n-            e.exp_map.insert({path: path, ns: ns}, option::get(def));\n+        let full_path = path + ident;\n+        maybe_add_reexport(e, full_path, m);\n+        maybe_add_reexport(e, full_path, v);\n+        maybe_add_reexport(e, full_path, t);\n+        is_some(m) || is_some(v) || is_some(t)\n+    }\n+\n+    fn maybe_add_reexport(e: @env, path: str, def: option::t<def>) {\n+        alt def {\n+          some(def) {\n+            alt e.exp_map.find(path) {\n+              some(v) { *v += [def]; }\n+              none { e.exp_map.insert(path, @mutable [def]); }\n+            }\n+          }\n+          _ {}\n         }\n     }\n \n-    fn check_export(e: @env, ident: str, val: @indexed_mod, vi: @view_item) {\n+    fn check_export(e: @env, ident: str, val: @indexed_mod,\n+                    vi: @view_item) {\n+        let found_something = false;\n+        let full_path = val.path + ident;\n         if val.index.contains_key(ident) {\n+            found_something = true;\n             let xs = val.index.get(ident);\n             list::iter(xs) {|x|\n                 alt x {\n                   mie_import_ident(id, _) {\n                     alt e.imports.get(id) {\n                       resolved(v, t, m, _, rid, _) {\n-                        maybe_add_reexport(e, val.path + rid,\n-                                           ns_val(ns_any_value), v);\n-                        maybe_add_reexport(e, val.path + rid, ns_type, t);\n-                        maybe_add_reexport(e, val.path + rid, ns_module, m);\n+                        maybe_add_reexport(e, full_path, v);\n+                        maybe_add_reexport(e, full_path, t);\n+                        maybe_add_reexport(e, full_path, m);\n                       }\n                       _ { }\n                     }\n                   }\n                   _ { }\n                 }\n             }\n-        } else if lookup_glob_any(e, val, vi.span, val.path, ident) {\n-            // do nothing\n-        } else {\n+        }\n+        found_something |= lookup_glob_any(e, val, vi.span, val.path, ident);\n+        if !found_something {\n             e.sess.span_warn(vi.span,\n                              #fmt(\"exported item %s is not defined\", ident));\n         }\n@@ -1849,40 +1842,52 @@ type iscopes = list<@[@_impl]>;\n fn resolve_impls(e: @env, c: @ast::crate) {\n     visit::visit_crate(*c, nil, visit::mk_vt(@{\n         visit_block: bind visit_block_with_impl_scope(e, _, _, _),\n-        visit_mod: bind visit_mod_with_impl_scope(e, _, _, _, _),\n+        visit_mod: bind visit_mod_with_impl_scope(e, _, _, _, _, _),\n         visit_expr: bind resolve_impl_in_expr(e, _, _, _)\n         with *visit::default_visitor()\n     }));\n }\n \n fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n-                           &impls: [@_impl], sc: iscopes) {\n+                           &impls: [@_impl], sc: option::t<iscopes>) {\n+    fn lookup_imported_impls(e: env, id: ast::node_id,\n+                             act: fn(@[@_impl])) {\n+        alt e.imports.get(id) {\n+          resolved(_, _, _, is, _, _) { act(is); }\n+          todo(node_id, name, path, span, scopes) {\n+            resolve_import(e, local_def(node_id), name, *path, span,\n+                           scopes);\n+            alt e.imports.get(id) {\n+              resolved(_, _, _, is, _, _) { act(is); }\n+            }\n+          }\n+          _ {}\n+        }\n+    }\n     alt vi.node {\n       ast::view_item_import(name, pt, id) {\n         let found = [];\n         if vec::len(*pt) == 1u {\n-            list::iter(sc) {|level|\n-                if vec::len(found) > 0u { ret; }\n-                for imp in *level {\n-                    if imp.ident == pt[0] {\n-                        found += [@{ident: name with *imp}];\n+            option::may(sc) {|sc|\n+                list::iter(sc) {|level|\n+                    if vec::len(found) > 0u { ret; }\n+                    for imp in *level {\n+                        if imp.ident == pt[0] {\n+                            found += [@{ident: name with *imp}];\n+                        }\n                     }\n+                    if vec::len(found) > 0u { impls += found; }\n                 }\n-                if vec::len(found) > 0u { impls += found; }\n             }\n         } else {\n-            alt e.imports.get(id) {\n-              resolved(_, _, _, is, _, _) {\n+            lookup_imported_impls(e, id) {|is|\n                 for i in *is { impls += [@{ident: name with *i}]; }\n-              }\n             }\n         }\n       }\n       ast::view_item_import_from(base, names, _) {\n         for nm in names {\n-            alt e.imports.get(nm.node.id) {\n-              resolved(_, _, _, is, _, _) { impls += *is; }\n-            }\n+            lookup_imported_impls(e, nm.node.id) {|is| impls += *is; }\n         }\n       }\n       ast::view_item_import_glob(ids, id) {\n@@ -1922,34 +1927,45 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n     }\n }\n \n+fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl],\n+                           name: option::t<ident>) {\n+    let cached;\n+    alt e.impl_cache.find(defid) {\n+      some(some(v)) { cached = v; }\n+      some(none) { ret; }\n+      none {\n+        e.impl_cache.insert(defid, none);\n+        cached = if defid.crate == ast::local_crate {\n+            let tmp = [];\n+            let md = option::get(e.mod_map.get(defid.node).m);\n+            for vi in md.view_items {\n+                find_impls_in_view_item(e, vi, tmp, none);\n+            }\n+            for i in md.items {\n+                find_impls_in_item(e, i, tmp, none, none);\n+            }\n+            @vec::filter(tmp) {|i| is_exported(e, i.ident, md)}\n+        } else {\n+            csearch::get_impls_for_mod(e.sess.cstore, defid, none)\n+        };\n+        e.impl_cache.insert(defid, some(cached));\n+      }\n+    }\n+    alt name {\n+      some(n) {\n+        for im in *cached {\n+            if n == im.ident { impls += [im]; }\n+        }\n+      }\n+      _ { impls += *cached; }\n+    }\n+}\n+\n fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n                      name: option::t<ident>) {\n     alt m {\n       ast::def_mod(defid) {\n-        let cached;\n-        alt e.impl_cache.find(defid) {\n-          some(v) { cached = v; }\n-          none {\n-            cached = if defid.crate == ast::local_crate {\n-                let tmp = [];\n-                for i in option::get(e.mod_map.get(defid.node).m).items {\n-                    find_impls_in_item(e, i, tmp, none, none);\n-                }\n-                @tmp\n-            } else {\n-                csearch::get_impls_for_mod(e.sess.cstore, defid, none)\n-            };\n-            e.impl_cache.insert(defid, cached);\n-          }\n-        }\n-        alt name {\n-          some(n) {\n-            for im in *cached {\n-                if n == im.ident { impls += [im]; }\n-            }\n-          }\n-          _ { impls += *cached; }\n-        }\n+        find_impls_in_mod_by_id(e, defid, impls, name);\n       }\n       _ {}\n     }\n@@ -1959,7 +1975,7 @@ fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n                                v: vt<iscopes>) {\n     let impls = [];\n     for vi in b.node.view_items {\n-        find_impls_in_view_item(*e, vi, impls, sc);\n+        find_impls_in_view_item(*e, vi, impls, some(sc));\n     }\n     for st in b.node.stmts {\n         alt st.node {\n@@ -1973,12 +1989,17 @@ fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n     visit::visit_block(b, sc, v);\n }\n \n-fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, sc: iscopes,\n-                             v: vt<iscopes>) {\n+fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, id: node_id,\n+                             sc: iscopes, v: vt<iscopes>) {\n     let impls = [];\n-    for vi in m.view_items { find_impls_in_view_item(*e, vi, impls, sc); }\n+    for vi in m.view_items {\n+        find_impls_in_view_item(*e, vi, impls, some(sc));\n+    }\n     for i in m.items { find_impls_in_item(*e, i, impls, none, none); }\n-    visit::visit_mod(m, s, vec::len(impls) > 0u ? cons(@impls, @sc) : sc, v);\n+    let impls = @impls;\n+    visit::visit_mod(m, s, id,\n+                     vec::len(*impls) > 0u ? cons(impls, @sc) : sc, v);\n+    e.impl_map.insert(id, cons(impls, @nil));\n }\n \n fn resolve_impl_in_expr(e: @env, x: @ast::expr, sc: iscopes, v: vt<iscopes>) {"}, {"sha": "9e978b3572a33bc70adf406fa59a69e7976c0030", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c590bdeea41f5476f42c6a7cb067e162328bdbc2", "patch": "@@ -5498,8 +5498,8 @@ fn write_abi_version(ccx: @crate_ctxt) {\n fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n                output: str, emap: resolve::exp_map, amap: ast_map::map,\n                mut_map: mut::mut_map, copy_map: alias::copy_map,\n-               last_uses: last_use::last_uses, method_map: typeck::method_map,\n-               dict_map: typeck::dict_map)\n+               last_uses: last_use::last_uses, impl_map: resolve::impl_map,\n+               method_map: typeck::method_map, dict_map: typeck::dict_map)\n     -> (ModuleRef, link::link_meta) {\n     let sha = std::sha1::mk_sha1();\n     let link_meta = link::build_link_meta(sess, *crate, output, sha);\n@@ -5576,6 +5576,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           mut_map: mut_map,\n           copy_map: copy_map,\n           last_uses: last_uses,\n+          impl_map: impl_map,\n           method_map: method_map,\n           dict_map: dict_map,\n           stats:"}, {"sha": "790f78aed587098a085b078dd857ed7fc1d8c615", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=c590bdeea41f5476f42c6a7cb067e162328bdbc2", "patch": "@@ -108,6 +108,7 @@ type crate_ctxt =\n      mut_map: mut::mut_map,\n      copy_map: alias::copy_map,\n      last_uses: last_use::last_uses,\n+     impl_map: resolve::impl_map,\n      method_map: typeck::method_map,\n      dict_map: typeck::dict_map,\n      stats: stats,"}, {"sha": "ba99519285954c5ea1d1f24d77f982a1ee5ae3f3", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c590bdeea41f5476f42c6a7cb067e162328bdbc2/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=c590bdeea41f5476f42c6a7cb067e162328bdbc2", "patch": "@@ -40,7 +40,7 @@ fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n type visitor<E> =\n     // takes the components so that one function can be\n     // generic over constr and ty_constr\n-    @{visit_mod: fn@(_mod, span, E, vt<E>),\n+    @{visit_mod: fn@(_mod, span, node_id, E, vt<E>),\n       visit_view_item: fn@(@view_item, E, vt<E>),\n       visit_native_item: fn@(@native_item, E, vt<E>),\n       visit_item: fn@(@item, E, vt<E>),\n@@ -57,7 +57,7 @@ type visitor<E> =\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n-    ret @{visit_mod: bind visit_mod::<E>(_, _, _, _),\n+    ret @{visit_mod: bind visit_mod::<E>(_, _, _, _, _),\n           visit_view_item: bind visit_view_item::<E>(_, _, _),\n           visit_native_item: bind visit_native_item::<E>(_, _, _),\n           visit_item: bind visit_item::<E>(_, _, _),\n@@ -75,7 +75,7 @@ fn default_visitor<E>() -> visitor<E> {\n }\n \n fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n-    v.visit_mod(c.node.module, c.span, e, v);\n+    v.visit_mod(c.node.module, c.span, crate_node_id, e, v);\n }\n \n fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n@@ -91,7 +91,7 @@ fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_mod<E>(m: _mod, _sp: span, e: E, v: vt<E>) {\n+fn visit_mod<E>(m: _mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n     for vi: @view_item in m.view_items { v.visit_view_item(vi, e, v); }\n     for i: @item in m.items { v.visit_item(i, e, v); }\n }\n@@ -110,7 +110,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       item_fn(decl, tp, body) {\n         v.visit_fn(fk_item_fn(i.ident, tp), decl, body, i.span, i.id, e, v);\n       }\n-      item_mod(m) { v.visit_mod(m, i.span, e, v); }\n+      item_mod(m) { v.visit_mod(m, i.span, i.id, e, v); }\n       item_native_mod(nm) {\n         for vi: @view_item in nm.view_items { v.visit_view_item(vi, e, v); }\n         for ni: @native_item in nm.items { v.visit_native_item(ni, e, v); }\n@@ -376,7 +376,7 @@ fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n type simple_visitor =\n     // takes the components so that one function can be\n     // generic over constr and ty_constr\n-    @{visit_mod: fn@(_mod, span),\n+    @{visit_mod: fn@(_mod, span, node_id),\n       visit_view_item: fn@(@view_item),\n       visit_native_item: fn@(@native_item),\n       visit_item: fn@(@item),\n@@ -395,7 +395,7 @@ type simple_visitor =\n fn simple_ignore_ty(_t: @ty) {}\n \n fn default_simple_visitor() -> simple_visitor {\n-    ret @{visit_mod: fn@(_m: _mod, _sp: span) { },\n+    ret @{visit_mod: fn@(_m: _mod, _sp: span, _id: node_id) { },\n           visit_view_item: fn@(_vi: @view_item) { },\n           visit_native_item: fn@(_ni: @native_item) { },\n           visit_item: fn@(_i: @item) { },\n@@ -415,9 +415,10 @@ fn default_simple_visitor() -> simple_visitor {\n }\n \n fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n-    fn v_mod(f: fn@(_mod, span), m: _mod, sp: span, &&e: (), v: vt<()>) {\n-        f(m, sp);\n-        visit_mod(m, sp, e, v);\n+    fn v_mod(f: fn@(_mod, span, node_id), m: _mod, sp: span, id: node_id,\n+             &&e: (), v: vt<()>) {\n+        f(m, sp, id);\n+        visit_mod(m, sp, id, e, v);\n     }\n     fn v_view_item(f: fn@(@view_item), vi: @view_item, &&e: (), v: vt<()>) {\n         f(vi);\n@@ -484,7 +485,7 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     } else {\n         bind v_ty(v.visit_ty, _, _, _)\n     };\n-    ret mk_vt(@{visit_mod: bind v_mod(v.visit_mod, _, _, _, _),\n+    ret mk_vt(@{visit_mod: bind v_mod(v.visit_mod, _, _, _, _, _),\n                 visit_view_item: bind v_view_item(v.visit_view_item, _, _, _),\n                 visit_native_item:\n                     bind v_native_item(v.visit_native_item, _, _, _),"}]}