{"sha": "399314d802366023fc3d2b7ac7b7decfcc3397ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5OTMxNGQ4MDIzNjYwMjNmYzNkMmI3YWM3YjdkZWNmY2MzMzk3ZWE=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-19T03:03:34Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-19T08:47:51Z"}, "message": "Rollup merge of #55169 - raphlinus:copysign, r=joshtriplett\n\nAdd a `copysign` function to f32 and f64\n\nThis patch adds a `copysign` function to the float primitive types. It is an exceptionally useful function for writing efficient numeric code, as it often avoids branches, is auto-vectorizable, and there are efficient intrinsics for most platforms.\n\nI think this might work as-is, as the relevant `copysign` intrinsic is already used internally for the implementation of `signum`. It's possible that an implementation might be needed in japaric/libm for portability across all platforms, in which case I'll do that also.\n\nPart of the work towards #55107", "tree": {"sha": "d148fea6c7c51fd2fdb1e6a18c140712d837e5f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d148fea6c7c51fd2fdb1e6a18c140712d837e5f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/399314d802366023fc3d2b7ac7b7decfcc3397ea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlvJmjcACgkQ/vbIBR0O\nATwueQ//a5HboxUY6oAPLlULoNmm0jnJzd187CBKchToCpl8DiBSrwDolfTEjBRZ\nl5cWrjvbalM6fC90OTvZcmJghRg4gcBB2Vexm5SLLWuvlzjafDShOULoLrf421DC\nfnRpYVkFG40/G3roWangcPm5XQohgFMZ93Paj/Ls5bA0Glt+R4WrtLFVNl2SaJEU\nEWxGmczf8gI8RSy3ugbvqVvi9YICh05R+u3kbJumnD9RfonBWRywCt5eUkIklMVC\nPmYN/DweWL6BRqSjRCt3ER5ZOVbIXibPjmdP3MliVnswIHWOFbItzC1C47K423sn\nzsGbGaK7mjUsCeOLkqJ/4C0kdI0rwkBy+YEh+ITcCWvBVFq3vfH8s6Br8fvb9dNr\nuPHPmlHMQZCEkibIF3EkHzBBRlqnQS+SiVVXD5d0D5JxL41VwtwV+d5upUMpQhVT\niiMba4t/i0X+dbS24lx0MYaOLVUacyvDMt91lzwfmTR4pcJlANdmfgXYLoDc7SHA\nedbOsJlDrHKvOgJrLrNrF6bBljb/aYXxNYcgi6UuHSub27e2O/wAEIDKMFvjtBRq\nkRQsAdtJT8ZqwPVFCwnjZV5t8d+/w9TcltEhBQgGiC4NsqwhTT5kycqSDkfhuzdq\ny3VXcLXVEp7GEsBHo7uKOmxtu65FBQufTlS2L0/mAPmmXAB21sI=\n=LTgs\n-----END PGP SIGNATURE-----", "payload": "tree d148fea6c7c51fd2fdb1e6a18c140712d837e5f2\nparent 9d2eb9b7529321a6c60bf299b48440e259a7d9d9\nparent f08db6bf1ee44dd1bc8c4d3ddcea1425fcd8d118\nauthor kennytm <kennytm@gmail.com> 1539918214 +0800\ncommitter kennytm <kennytm@gmail.com> 1539938871 +0800\n\nRollup merge of #55169 - raphlinus:copysign, r=joshtriplett\n\nAdd a `copysign` function to f32 and f64\n\nThis patch adds a `copysign` function to the float primitive types. It is an exceptionally useful function for writing efficient numeric code, as it often avoids branches, is auto-vectorizable, and there are efficient intrinsics for most platforms.\n\nI think this might work as-is, as the relevant `copysign` intrinsic is already used internally for the implementation of `signum`. It's possible that an implementation might be needed in japaric/libm for portability across all platforms, in which case I'll do that also.\n\nPart of the work towards #55107\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/399314d802366023fc3d2b7ac7b7decfcc3397ea", "html_url": "https://github.com/rust-lang/rust/commit/399314d802366023fc3d2b7ac7b7decfcc3397ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/399314d802366023fc3d2b7ac7b7decfcc3397ea/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d2eb9b7529321a6c60bf299b48440e259a7d9d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d2eb9b7529321a6c60bf299b48440e259a7d9d9", "html_url": "https://github.com/rust-lang/rust/commit/9d2eb9b7529321a6c60bf299b48440e259a7d9d9"}, {"sha": "f08db6bf1ee44dd1bc8c4d3ddcea1425fcd8d118", "url": "https://api.github.com/repos/rust-lang/rust/commits/f08db6bf1ee44dd1bc8c4d3ddcea1425fcd8d118", "html_url": "https://github.com/rust-lang/rust/commit/f08db6bf1ee44dd1bc8c4d3ddcea1425fcd8d118"}], "stats": {"total": 58, "additions": 58, "deletions": 0}, "files": [{"sha": "c3f225d1eb0136e72070a1f1555082b7da6b941d", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/399314d802366023fc3d2b7ac7b7decfcc3397ea/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399314d802366023fc3d2b7ac7b7decfcc3397ea/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=399314d802366023fc3d2b7ac7b7decfcc3397ea", "patch": "@@ -198,6 +198,35 @@ impl f32 {\n         }\n     }\n \n+    /// Returns a number composed of the magnitude of one number and the sign of\n+    /// another.\n+    ///\n+    /// Equal to `self` if the sign of `self` and `y` are the same, otherwise\n+    /// equal to `-y`. If `self` is a `NAN`, then a `NAN` with the sign of `y`\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(copysign)]\n+    /// use std::f32;\n+    ///\n+    /// let f = 3.5_f32;\n+    ///\n+    /// assert_eq!(f.copysign(0.42), 3.5_f32);\n+    /// assert_eq!(f.copysign(-0.42), -3.5_f32);\n+    /// assert_eq!((-f).copysign(0.42), 3.5_f32);\n+    /// assert_eq!((-f).copysign(-0.42), -3.5_f32);\n+    ///\n+    /// assert!(f32::NAN.copysign(1.0).is_nan());\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[unstable(feature=\"copysign\", issue=\"55169\")]\n+    pub fn copysign(self, y: f32) -> f32 {\n+        unsafe { intrinsics::copysignf32(self, y) }\n+    }\n+\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error, yielding a more accurate result than an unfused multiply-add.\n     ///"}, {"sha": "da062dda77a47a5496e76e671875545653f3d91a", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/399314d802366023fc3d2b7ac7b7decfcc3397ea/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399314d802366023fc3d2b7ac7b7decfcc3397ea/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=399314d802366023fc3d2b7ac7b7decfcc3397ea", "patch": "@@ -176,6 +176,35 @@ impl f64 {\n         }\n     }\n \n+    /// Returns a number composed of the magnitude of one number and the sign of\n+    /// another.\n+    ///\n+    /// Equal to `self` if the sign of `self` and `y` are the same, otherwise\n+    /// equal to `-y`. If `self` is a `NAN`, then a `NAN` with the sign of `y`\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(copysign)]\n+    /// use std::f64;\n+    ///\n+    /// let f = 3.5_f64;\n+    ///\n+    /// assert_eq!(f.copysign(0.42), 3.5_f64);\n+    /// assert_eq!(f.copysign(-0.42), -3.5_f64);\n+    /// assert_eq!((-f).copysign(0.42), 3.5_f64);\n+    /// assert_eq!((-f).copysign(-0.42), -3.5_f64);\n+    ///\n+    /// assert!(f64::NAN.copysign(1.0).is_nan());\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[unstable(feature=\"copysign\", issue=\"55169\")]\n+    pub fn copysign(self, y: f64) -> f64 {\n+        unsafe { intrinsics::copysignf64(self, y) }\n+    }\n+\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error, yielding a more accurate result than an unfused multiply-add.\n     ///"}]}