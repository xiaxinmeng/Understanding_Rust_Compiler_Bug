{"sha": "b1962a2b2e52f16ad817339e798f90fac973c2b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxOTYyYTJiMmU1MmYxNmFkODE3MzM5ZTc5OGY5MGZhYzk3M2MyYjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-07T19:37:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-11T21:55:24Z"}, "message": "add upvar_borrow_map to tcx and fcx in typeck", "tree": {"sha": "6c2b0db4a33ba6e052988b4400713ee72bb3e7b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c2b0db4a33ba6e052988b4400713ee72bb3e7b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1962a2b2e52f16ad817339e798f90fac973c2b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1962a2b2e52f16ad817339e798f90fac973c2b1", "html_url": "https://github.com/rust-lang/rust/commit/b1962a2b2e52f16ad817339e798f90fac973c2b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1962a2b2e52f16ad817339e798f90fac973c2b1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "807def022a6540dde6727b9a438ea3b0eaafd9b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/807def022a6540dde6727b9a438ea3b0eaafd9b5", "html_url": "https://github.com/rust-lang/rust/commit/807def022a6540dde6727b9a438ea3b0eaafd9b5"}], "stats": {"total": 182, "additions": 181, "deletions": 1}, "files": [{"sha": "7c4cb396b3e26176598173393a7bf274170af766", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 143, "deletions": 1, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/b1962a2b2e52f16ad817339e798f90fac973c2b1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1962a2b2e52f16ad817339e798f90fac973c2b1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b1962a2b2e52f16ad817339e798f90fac973c2b1", "patch": "@@ -351,6 +351,9 @@ pub struct ctxt_ {\n     // is used for lazy resolution of traits.\n     populated_external_traits: RefCell<HashSet<ast::DefId>>,\n \n+    // Borrows\n+    upvar_borrow_map: RefCell<UpvarBorrowMap>,\n+\n     // These two caches are used by const_eval when decoding external statics\n     // and variants that are found.\n     extern_const_statics: RefCell<HashMap<ast::DefId, Option<@ast::Expr>>>,\n@@ -494,6 +497,120 @@ pub enum Region {\n     ReEmpty,\n }\n \n+/**\n+ * Upvars do not get their own node-id. Instead, we use the pair of\n+ * the original var id (that is, the root variable that is referenced\n+ * by the upvar) and the id of the closure expression.\n+ */\n+#[deriving(Clone, Eq, IterBytes)]\n+pub struct UpvarId {\n+    var_id: ast::NodeId,\n+    closure_expr_id: ast::NodeId,\n+}\n+\n+#[deriving(Clone, Eq, IterBytes)]\n+pub enum BorrowKind {\n+    /// Data must be immutable and is aliasable.\n+    ImmBorrow,\n+\n+    /// Data must be immutable but not aliasable.  This kind of borrow\n+    /// cannot currently be expressed by the user and is used only in\n+    /// implicit closure bindings. It is needed when you the closure\n+    /// is borrowing or mutating a mutable referent, e.g.:\n+    ///\n+    ///    let x: &mut int = ...;\n+    ///    let y = || *x += 5;\n+    ///\n+    /// If we were to try to translate this closure into a more explicit\n+    /// form, we'd encounter an error with the code as written:\n+    ///\n+    ///    struct Env { x: & &mut int }\n+    ///    let x: &mut int = ...;\n+    ///    let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n+    ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    ///\n+    /// This is then illegal because you cannot mutate a `&mut` found\n+    /// in an aliasable location. To solve, you'd have to translate with\n+    /// an `&mut` borrow:\n+    ///\n+    ///    struct Env { x: & &mut int }\n+    ///    let x: &mut int = ...;\n+    ///    let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n+    ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    ///\n+    /// Now the assignment to `**env.x` is legal, but creating a\n+    /// mutable pointer to `x` is not because `x` is not mutable. We\n+    /// could fix this by declaring `x` as `let mut x`. This is ok in\n+    /// user code, if awkward, but extra weird for closures, since the\n+    /// borrow is hidden.\n+    ///\n+    /// So we introduce a \"unique imm\" borrow -- the referent is\n+    /// immutable, but not aliasable. This solves the problem. For\n+    /// simplicity, we don't give users the way to express this\n+    /// borrow, it's just used when translating closures.\n+    UniqueImmBorrow,\n+\n+    /// Data is mutable and not aliasable.\n+    MutBorrow\n+}\n+\n+/**\n+ * Information describing the borrowing of an upvar. This is computed\n+ * during `typeck`, specifically by `regionck`. The general idea is\n+ * that the compiler analyses treat closures like:\n+ *\n+ *     let closure: &'e fn() = || {\n+ *        x = 1;   // upvar x is assigned to\n+ *        use(y);  // upvar y is read\n+ *        foo(&z); // upvar z is borrowed immutably\n+ *     };\n+ *\n+ * as if they were \"desugared\" to something loosely like:\n+ *\n+ *     struct Vars<'x,'y,'z> { x: &'x mut int,\n+ *                             y: &'y const int,\n+ *                             z: &'z int }\n+ *     let closure: &'e fn() = {\n+ *         fn f(env: &Vars) {\n+ *             *env.x = 1;\n+ *             use(*env.y);\n+ *             foo(env.z);\n+ *         }\n+ *         let env: &'e mut Vars<'x,'y,'z> = &mut Vars { x: &'x mut x,\n+ *                                                       y: &'y const y,\n+ *                                                       z: &'z z };\n+ *         (env, f)\n+ *     };\n+ *\n+ * This is basically what happens at runtime. The closure is basically\n+ * an existentially quantified version of the `(env, f)` pair.\n+ *\n+ * This data structure indicates the region and mutability of a single\n+ * one of the `x...z` borrows.\n+ *\n+ * It may not be obvious why each borrowed variable gets its own\n+ * lifetime (in the desugared version of the example, these are indicated\n+ * by the lifetime parameters `'x`, `'y`, and `'z` in the `Vars` definition).\n+ * Each such lifetime must encompass the lifetime `'e` of the closure itself,\n+ * but need not be identical to it. The reason that this makes sense:\n+ *\n+ * - Callers are only permitted to invoke the closure, and hence to\n+ *   use the pointers, within the lifetime `'e`, so clearly `'e` must\n+ *   be a sublifetime of `'x...'z`.\n+ * - The closure creator knows which upvars were borrowed by the closure\n+ *   and thus `x...z` will be reserved for `'x...'z` respectively.\n+ * - Through mutation, the borrowed upvars can actually escape the\n+ *   the closure, so sometimes it is necessary for them to be larger\n+ *   than the closure lifetime itself.\n+ */\n+#[deriving(Eq, Clone)]\n+pub struct UpvarBorrow {\n+    kind: BorrowKind,\n+    region: ty::Region,\n+}\n+\n+pub type UpvarBorrowMap = HashMap<UpvarId, UpvarBorrow>;\n+\n impl Region {\n     pub fn is_bound(&self) -> bool {\n         match self {\n@@ -999,7 +1116,7 @@ pub fn mk_ctxt(s: session::Session,\n         impl_vtables: RefCell::new(HashMap::new()),\n         populated_external_types: RefCell::new(HashSet::new()),\n         populated_external_traits: RefCell::new(HashSet::new()),\n-\n+        upvar_borrow_map: RefCell::new(HashMap::new()),\n         extern_const_statics: RefCell::new(HashMap::new()),\n         extern_const_variants: RefCell::new(HashMap::new()),\n      }\n@@ -5100,3 +5217,28 @@ impl substs {\n         }\n     }\n }\n+\n+impl BorrowKind {\n+    pub fn from_mutbl(m: ast::Mutability) -> BorrowKind {\n+        match m {\n+            ast::MutMutable => MutBorrow,\n+            ast::MutImmutable => ImmBorrow,\n+        }\n+    }\n+\n+    pub fn to_user_str(&self) -> &'static str {\n+        match *self {\n+            MutBorrow => \"mutable\",\n+            ImmBorrow => \"immutable\",\n+            UniqueImmBorrow => \"uniquely immutable\",\n+        }\n+    }\n+\n+    pub fn to_short_str(&self) -> &'static str {\n+        match *self {\n+            MutBorrow => \"mut\",\n+            ImmBorrow => \"imm\",\n+            UniqueImmBorrow => \"own\",\n+        }\n+    }\n+}"}, {"sha": "9eec804dd2e11932e2a2b37d1d95a8823cf97f8b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1962a2b2e52f16ad817339e798f90fac973c2b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1962a2b2e52f16ad817339e798f90fac973c2b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b1962a2b2e52f16ad817339e798f90fac973c2b1", "patch": "@@ -164,6 +164,7 @@ pub struct Inherited {\n     adjustments: RefCell<HashMap<ast::NodeId, @ty::AutoAdjustment>>,\n     method_map: method_map,\n     vtable_map: vtable_map,\n+    upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n }\n \n #[deriving(Clone)]\n@@ -266,6 +267,7 @@ impl Inherited {\n             adjustments: RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(HashMap::new()),\n             vtable_map: @RefCell::new(HashMap::new()),\n+            upvar_borrow_map: RefCell::new(HashMap::new()),\n         }\n     }\n }"}, {"sha": "8480135599052bf1820bdcbb39017ac5243cce59", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b1962a2b2e52f16ad817339e798f90fac973c2b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1962a2b2e52f16ad817339e798f90fac973c2b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=b1962a2b2e52f16ad817339e798f90fac973c2b1", "patch": "@@ -378,10 +378,45 @@ impl Visitor<()> for WbCtxt {\n     fn visit_ty(&mut self, _t: &ast::Ty, _: ()) {}\n }\n \n+fn resolve_upvar_borrow_map(wbcx: &mut WbCtxt) {\n+    if !wbcx.success {\n+        return;\n+    }\n+\n+    let fcx = wbcx.fcx;\n+    let tcx = fcx.tcx();\n+    let upvar_borrow_map = fcx.inh.upvar_borrow_map.borrow();\n+    for (upvar_id, upvar_borrow) in upvar_borrow_map.get().iter() {\n+        let r = upvar_borrow.region;\n+        match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n+            Ok(r) => {\n+                let new_upvar_borrow = ty::UpvarBorrow {\n+                    kind: upvar_borrow.kind,\n+                    region: r\n+                };\n+                debug!(\"Upvar borrow for {} resolved to {}\",\n+                       upvar_id.repr(tcx), new_upvar_borrow.repr(tcx));\n+                let mut tcx_upvar_borrow_map = tcx.upvar_borrow_map.borrow_mut();\n+                tcx_upvar_borrow_map.get().insert(*upvar_id, new_upvar_borrow);\n+            }\n+            Err(e) => {\n+                let span = ty::expr_span(tcx, upvar_id.closure_expr_id);\n+                fcx.ccx.tcx.sess.span_err(\n+                    span, format!(\"cannot resolve lifetime for \\\n+                                  captured variable `{}`: {}\",\n+                                  ty::local_var_name_str(tcx, upvar_id.var_id).get().to_str(),\n+                                  infer::fixup_err_to_str(e)));\n+                wbcx.success = false;\n+            }\n+        };\n+    }\n+}\n+\n pub fn resolve_type_vars_in_expr(fcx: @FnCtxt, e: &ast::Expr) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;\n     wbcx.visit_expr(e, ());\n+    resolve_upvar_borrow_map(wbcx);\n     return wbcx.success;\n }\n \n@@ -397,5 +432,6 @@ pub fn resolve_type_vars_in_fn(fcx: @FnCtxt, decl: &ast::FnDecl,\n             resolve_type_vars_for_node(wbcx, arg.pat.span, arg.pat.id);\n         }\n     }\n+    resolve_upvar_borrow_map(wbcx);\n     return wbcx.success;\n }"}]}