{"sha": "ca52c56e346a2a2bb042bec441b5058df3e3e289", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNTJjNTZlMzQ2YTJhMmJiMDQyYmVjNDQxYjUwNThkZjNlM2UyODk=", "commit": {"author": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2015-12-12T22:38:03Z"}, "committer": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2015-12-18T12:32:14Z"}, "message": "Add memchr implemenation based on rust-memchr to libstd", "tree": {"sha": "a7717cc94aaae682b5c9c5dba8c6bd42c0cb7cc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7717cc94aaae682b5c9c5dba8c6bd42c0cb7cc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca52c56e346a2a2bb042bec441b5058df3e3e289", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca52c56e346a2a2bb042bec441b5058df3e3e289", "html_url": "https://github.com/rust-lang/rust/commit/ca52c56e346a2a2bb042bec441b5058df3e3e289", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca52c56e346a2a2bb042bec441b5058df3e3e289/comments", "author": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27d551142f9e3cd2fc402555a8f6287dd0fc01ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/27d551142f9e3cd2fc402555a8f6287dd0fc01ac", "html_url": "https://github.com/rust-lang/rust/commit/27d551142f9e3cd2fc402555a8f6287dd0fc01ac"}], "stats": {"total": 402, "additions": 402, "deletions": 0}, "files": [{"sha": "eba0c799cd2c1c08208c102ce08924bb4dde3795", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca52c56e346a2a2bb042bec441b5058df3e3e289/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca52c56e346a2a2bb042bec441b5058df3e3e289/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ca52c56e346a2a2bb042bec441b5058df3e3e289", "patch": "@@ -248,6 +248,7 @@\n #![feature(link_args)]\n #![feature(linkage)]\n #![feature(macro_reexport)]\n+#![feature(num_bits_bytes)]\n #![feature(on_unimplemented)]\n #![feature(oom)]\n #![feature(optin_builtin_traits)]\n@@ -429,6 +430,7 @@ pub mod path;\n pub mod process;\n pub mod sync;\n pub mod time;\n+mod memchr;\n \n #[macro_use]\n #[path = \"sys/common/mod.rs\"] mod sys_common;"}, {"sha": "8a2fc575759708052eed60aa44cd7518d75e4f65", "filename": "src/libstd/memchr.rs", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/ca52c56e346a2a2bb042bec441b5058df3e3e289/src%2Flibstd%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca52c56e346a2a2bb042bec441b5058df3e3e289/src%2Flibstd%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmemchr.rs?ref=ca52c56e346a2a2bb042bec441b5058df3e3e289", "patch": "@@ -0,0 +1,400 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+use libc::{c_void, c_int, size_t};\n+\n+\n+/// A safe interface to `memchr`.\n+///\n+/// Returns the index corresponding to the first occurrence of `needle` in\n+/// `haystack`, or `None` if one is not found.\n+///\n+/// memchr reduces to super-optimized machine code at around an order of\n+/// magnitude faster than `haystack.iter().position(|&b| b == needle)`.\n+/// (See benchmarks.)\n+///\n+/// # Example\n+///\n+/// This shows how to find the first position of a byte in a byte string.\n+///\n+/// ```rust\n+/// use memchr::memchr;\n+///\n+/// let haystack = b\"the quick brown fox\";\n+/// assert_eq!(memchr(b'k', haystack), Some(8));\n+/// ```\n+pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+    // libc memchr\n+    #[cfg(any(not(target_os = \"windows\"),\n+              not(any(target_pointer_width = \"32\",\n+                      target_pointer_width = \"64\"))))]\n+    fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        use libc::memchr as libc_memchr;\n+\n+        let p = unsafe {\n+            libc_memchr(\n+                haystack.as_ptr() as *const c_void,\n+                needle as c_int,\n+                haystack.len() as size_t)\n+        };\n+        if p.is_null() {\n+            None\n+        } else {\n+            Some(p as usize - (haystack.as_ptr() as usize))\n+        }\n+    }\n+\n+    // use fallback on windows, since it's faster\n+    #[cfg(all(target_os = \"windows\",\n+              any(target_pointer_width = \"32\",\n+                  target_pointer_width = \"64\")))]\n+    fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        fallback::memchr(needle, haystack)\n+    }\n+\n+    memchr_specific(needle, haystack)\n+}\n+\n+/// A safe interface to `memrchr`.\n+///\n+/// Returns the index corresponding to the last occurrence of `needle` in\n+/// `haystack`, or `None` if one is not found.\n+///\n+/// # Example\n+///\n+/// This shows how to find the last position of a byte in a byte string.\n+///\n+/// ```rust\n+/// use memchr::memrchr;\n+///\n+/// let haystack = b\"the quick brown fox\";\n+/// assert_eq!(memrchr(b'o', haystack), Some(17));\n+/// ```\n+pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        use libc::memrchr as libc_memrchr;\n+\n+        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n+        if haystack.is_empty() {return None}\n+        let p = unsafe {\n+            libc_memrchr(\n+                haystack.as_ptr() as *const c_void,\n+                needle as c_int,\n+                haystack.len() as size_t)\n+        };\n+        if p.is_null() {\n+            None\n+        } else {\n+            Some(p as usize - (haystack.as_ptr() as usize))\n+        }\n+    }\n+\n+    #[cfg(all(not(target_os = \"linux\"),\n+              any(target_pointer_width = \"32\", target_pointer_width = \"64\")))]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        fallback::memrchr(needle, haystack)\n+    }\n+\n+    // For the rare case of neither 32 bit nor 64-bit platform.\n+    #[cfg(all(not(target_os = \"linux\"),\n+              not(target_pointer_width = \"32\"),\n+              not(target_pointer_width = \"64\")))]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        haystack.iter().rposition(|&b| b == needle)\n+    }\n+\n+    memrchr_specific(needle, haystack)\n+}\n+\n+#[allow(dead_code)]\n+mod fallback {\n+    use cmp;\n+    use usize;\n+\n+    const LO_U64: u64 = 0x0101010101010101;\n+    const HI_U64: u64 = 0x8080808080808080;\n+\n+    // use truncation\n+    const LO_USIZE: usize = LO_U64 as usize;\n+    const HI_USIZE: usize = HI_U64 as usize;\n+\n+    /// Return `true` if `x` contains any zero byte.\n+    ///\n+    /// From *Matters Computational*, J. Arndt\n+    ///\n+    /// \"The idea is to subtract one from each of the bytes and then look for\n+    /// bytes where the borrow propagated all the way to the most significant\n+    /// bit.\"\n+    #[inline]\n+    fn contains_zero_byte(x: usize) -> bool {\n+        x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[inline]\n+    fn repeat_byte(b: u8) -> usize {\n+        let mut rep = (b as usize) << 8 | b as usize;\n+        rep = rep << 16 | rep;\n+        rep\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[inline]\n+    fn repeat_byte(b: u8) -> usize {\n+        let mut rep = (b as usize) << 8 | b as usize;\n+        rep = rep << 16 | rep;\n+        rep = rep << 32 | rep;\n+        rep\n+    }\n+\n+    /// Return the first index matching the byte `a` in `text`.\n+    pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n+        // Scan for a single byte value by reading two `usize` words at a time.\n+        //\n+        // Split `text` in three parts\n+        // - unaligned inital part, before the first word aligned address in text\n+        // - body, scan by 2 words at a time\n+        // - the last remaining part, < 2 word size\n+        let len = text.len();\n+        let ptr = text.as_ptr();\n+\n+        // search up to an aligned boundary\n+        let align = (ptr as usize) & (usize::BYTES- 1);\n+        let mut offset;\n+        if align > 0 {\n+            offset = cmp::min(usize::BYTES - align, len);\n+            if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n+                return Some(index);\n+            }\n+        } else {\n+            offset = 0;\n+        }\n+\n+        // search the body of the text\n+        let repeated_x = repeat_byte(x);\n+\n+        if len >= 2 * usize::BYTES {\n+            while offset <= len - 2 * usize::BYTES {\n+                unsafe {\n+                    let u = *(ptr.offset(offset as isize) as *const usize);\n+                    let v = *(ptr.offset((offset + usize::BYTES) as isize) as *const usize);\n+\n+                    // break if there is a matching byte\n+                    let zu = contains_zero_byte(u ^ repeated_x);\n+                    let zv = contains_zero_byte(v ^ repeated_x);\n+                    if zu || zv {\n+                        break;\n+                    }\n+                }\n+                offset += usize::BYTES * 2;\n+            }\n+        }\n+\n+        // find the byte after the point the body loop stopped\n+        text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n+    }\n+\n+    /// Return the last index matching the byte `a` in `text`.\n+    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n+        // Scan for a single byte value by reading two `usize` words at a time.\n+        //\n+        // Split `text` in three parts\n+        // - unaligned tail, after the last word aligned address in text\n+        // - body, scan by 2 words at a time\n+        // - the first remaining bytes, < 2 word size\n+        let len = text.len();\n+        let ptr = text.as_ptr();\n+\n+        // search to an aligned boundary\n+        let end_align = (ptr as usize + len) & (usize::BYTES - 1);\n+        let mut offset;\n+        if end_align > 0 {\n+            offset = len - cmp::min(usize::BYTES - end_align, len);\n+            if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n+                return Some(offset + index);\n+            }\n+        } else {\n+            offset = len;\n+        }\n+\n+        // search the body of the text\n+        let repeated_x = repeat_byte(x);\n+\n+        while offset >= 2 * usize::BYTES {\n+            unsafe {\n+                let u = *(ptr.offset(offset as isize - 2 * usize::BYTES as isize) as *const usize);\n+                let v = *(ptr.offset(offset as isize - usize::BYTES as isize) as *const usize);\n+\n+                // break if there is a matching byte\n+                let zu = contains_zero_byte(u ^ repeated_x);\n+                let zv = contains_zero_byte(v ^ repeated_x);\n+                if zu || zv {\n+                    break;\n+                }\n+            }\n+            offset -= 2 * usize::BYTES;\n+        }\n+\n+        // find the byte before the point the body loop stopped\n+        text[..offset].iter().rposition(|elt| *elt == x)\n+    }\n+\n+    // test fallback implementations on all plattforms\n+    #[test]\n+    fn matches_one() {\n+        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin() {\n+        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end() {\n+        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul() {\n+        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul() {\n+        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty() {\n+        assert_eq!(None, memchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match() {\n+        assert_eq!(None, memchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn matches_one_reversed() {\n+        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin_reversed() {\n+        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul_reversed() {\n+        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    // test the implementations for the current plattform\n+    use super::{memchr, memrchr};\n+\n+    #[test]\n+    fn matches_one() {\n+        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin() {\n+        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end() {\n+        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul() {\n+        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul() {\n+        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty() {\n+        assert_eq!(None, memchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match() {\n+        assert_eq!(None, memchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn matches_one_reversed() {\n+        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin_reversed() {\n+        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul_reversed() {\n+        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n+    }\n+}"}]}