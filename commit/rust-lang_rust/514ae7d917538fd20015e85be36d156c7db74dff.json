{"sha": "514ae7d917538fd20015e85be36d156c7db74dff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNGFlN2Q5MTc1MzhmZDIwMDE1ZTg1YmUzNmQxNTZjN2RiNzRkZmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-01-29T22:40:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-01-30T19:00:24Z"}, "message": "change `overlapping_impls` to take a tcx and create the infcx", "tree": {"sha": "fbc3c003b026e6ea05e35c9ee071d6ce4b110f02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbc3c003b026e6ea05e35c9ee071d6ce4b110f02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/514ae7d917538fd20015e85be36d156c7db74dff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/514ae7d917538fd20015e85be36d156c7db74dff", "html_url": "https://github.com/rust-lang/rust/commit/514ae7d917538fd20015e85be36d156c7db74dff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/514ae7d917538fd20015e85be36d156c7db74dff/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c210afb19cd8b3a71a18f85dce80d3429f72667", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c210afb19cd8b3a71a18f85dce80d3429f72667", "html_url": "https://github.com/rust-lang/rust/commit/4c210afb19cd8b3a71a18f85dce80d3429f72667"}], "stats": {"total": 138, "additions": 66, "deletions": 72}, "files": [{"sha": "41c824a5e0e7f8cb119d52b9d6a65dbcec807839", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/514ae7d917538fd20015e85be36d156c7db74dff/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/514ae7d917538fd20015e85be36d156c7db74dff/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=514ae7d917538fd20015e85be36d156c7db74dff", "patch": "@@ -19,7 +19,7 @@ use ty::{self, Ty, TyCtxt};\n use ty::fold::TypeFoldable;\n use ty::subst::Subst;\n \n-use infer::{InferCtxt, InferOk};\n+use infer::{InferOk};\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -43,8 +43,8 @@ pub struct OverlapResult<'tcx> {\n /// If there are types that satisfy both impls, invokes `on_overlap`\n /// with a suitably-freshened `ImplHeader` with those types\n /// substituted. Otherwise, invokes `no_overlap`.\n-pub fn overlapping_impls<F1, F2, R>(\n-    infcx: &InferCtxt<'_, '_, '_>,\n+pub fn overlapping_impls<'gcx, F1, F2, R>(\n+    tcx: TyCtxt<'_, 'gcx, 'gcx>,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     intercrate_mode: IntercrateMode,\n@@ -63,12 +63,14 @@ where\n            impl2_def_id,\n            intercrate_mode);\n \n-    let selcx = &mut SelectionContext::intercrate(infcx, intercrate_mode);\n-    if let Some(r) = overlap(selcx, impl1_def_id, impl2_def_id) {\n-        on_overlap(r)\n-    } else {\n-        no_overlap()\n-    }\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n+        if let Some(r) = overlap(selcx, impl1_def_id, impl2_def_id) {\n+            on_overlap(r)\n+        } else {\n+            no_overlap()\n+        }\n+    })\n }\n \n fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,"}, {"sha": "a10169e13e60a705e4bc9e0bc3d6cf75cf5a4a75", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/514ae7d917538fd20015e85be36d156c7db74dff/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/514ae7d917538fd20015e85be36d156c7db74dff/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=514ae7d917538fd20015e85be36d156c7db74dff", "patch": "@@ -133,29 +133,27 @@ impl<'a, 'gcx, 'tcx> Children {\n             };\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = tcx.infer_ctxt().enter(|infcx| {\n-                traits::overlapping_impls(\n-                    &infcx,\n-                    possible_sibling,\n-                    impl_def_id,\n-                    traits::IntercrateMode::Issue43355,\n-                    |overlap| {\n-                        if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n-                            return Ok((false, false));\n-                        }\n-\n-                        let le = tcx.specializes((impl_def_id, possible_sibling));\n-                        let ge = tcx.specializes((possible_sibling, impl_def_id));\n-\n-                        if le == ge {\n-                            Err(overlap_error(overlap))\n-                        } else {\n-                            Ok((le, ge))\n-                        }\n-                    },\n-                    || Ok((false, false)),\n-                )\n-            })?;\n+            let (le, ge) = traits::overlapping_impls(\n+                tcx,\n+                possible_sibling,\n+                impl_def_id,\n+                traits::IntercrateMode::Issue43355,\n+                |overlap| {\n+                    if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n+                        return Ok((false, false));\n+                    }\n+\n+                    let le = tcx.specializes((impl_def_id, possible_sibling));\n+                    let ge = tcx.specializes((possible_sibling, impl_def_id));\n+\n+                    if le == ge {\n+                        Err(overlap_error(overlap))\n+                    } else {\n+                        Ok((le, ge))\n+                    }\n+                },\n+                || Ok((false, false)),\n+            )?;\n \n             if le && !ge {\n                 debug!(\"descending as child of TraitRef {:?}\",\n@@ -172,16 +170,14 @@ impl<'a, 'gcx, 'tcx> Children {\n                 return Ok(Inserted::Replaced(possible_sibling));\n             } else {\n                 if !tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n-                    tcx.infer_ctxt().enter(|infcx| {\n-                        traits::overlapping_impls(\n-                            &infcx,\n-                            possible_sibling,\n-                            impl_def_id,\n-                            traits::IntercrateMode::Fixed,\n-                            |overlap| last_lint = Some(overlap_error(overlap)),\n-                            || (),\n-                        )\n-                    });\n+                    traits::overlapping_impls(\n+                        tcx,\n+                        possible_sibling,\n+                        impl_def_id,\n+                        traits::IntercrateMode::Fixed,\n+                        |overlap| last_lint = Some(overlap_error(overlap)),\n+                        || (),\n+                    );\n                 }\n \n                 // no overlap (error bailed already via ?)"}, {"sha": "88a2dc817ae63f139f1ad1a38bee016c777fa732", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/514ae7d917538fd20015e85be36d156c7db74dff/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/514ae7d917538fd20015e85be36d156c7db74dff/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=514ae7d917538fd20015e85be36d156c7db74dff", "patch": "@@ -82,41 +82,37 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                let used_to_be_allowed = self.tcx.infer_ctxt().enter(|infcx| {\n+                let used_to_be_allowed = traits::overlapping_impls(\n+                    self.tcx,\n+                    impl1_def_id,\n+                    impl2_def_id,\n+                    IntercrateMode::Issue43355,\n+                    |overlap| {\n+                        self.check_for_common_items_in_impls(\n+                            impl1_def_id,\n+                            impl2_def_id,\n+                            overlap,\n+                            false,\n+                        );\n+                        false\n+                    },\n+                    || true,\n+                );\n+\n+                if used_to_be_allowed {\n                     traits::overlapping_impls(\n-                        &infcx,\n+                        self.tcx,\n                         impl1_def_id,\n                         impl2_def_id,\n-                        IntercrateMode::Issue43355,\n-                        |overlap| {\n-                            self.check_for_common_items_in_impls(\n-                                impl1_def_id,\n-                                impl2_def_id,\n-                                overlap,\n-                                false,\n-                            );\n-                            false\n-                        },\n-                        || true,\n-                    )\n-                });\n-\n-                if used_to_be_allowed {\n-                    self.tcx.infer_ctxt().enter(|infcx| {\n-                        traits::overlapping_impls(\n-                            &infcx,\n+                        IntercrateMode::Fixed,\n+                        |overlap| self.check_for_common_items_in_impls(\n                             impl1_def_id,\n                             impl2_def_id,\n-                            IntercrateMode::Fixed,\n-                            |overlap| self.check_for_common_items_in_impls(\n-                                impl1_def_id,\n-                                impl2_def_id,\n-                                overlap,\n-                                true,\n-                            ),\n-                            || (),\n-                        );\n-                    });\n+                            overlap,\n+                            true,\n+                        ),\n+                        || (),\n+                    );\n                 }\n             }\n         }"}]}