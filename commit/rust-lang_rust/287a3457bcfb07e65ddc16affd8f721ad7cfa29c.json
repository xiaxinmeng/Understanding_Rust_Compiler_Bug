{"sha": "287a3457bcfb07e65ddc16affd8f721ad7cfa29c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4N2EzNDU3YmNmYjA3ZTY1ZGRjMTZhZmZkOGY3MjFhZDdjZmEyOWM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-02-15T22:55:02Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-02-21T19:01:23Z"}, "message": "clean up some things\n\nI double checked that everything is here and in the correct order; this fixes things up", "tree": {"sha": "073e4521cb331988f6261e62525cf3f0723c4455", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/073e4521cb331988f6261e62525cf3f0723c4455"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/287a3457bcfb07e65ddc16affd8f721ad7cfa29c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/287a3457bcfb07e65ddc16affd8f721ad7cfa29c", "html_url": "https://github.com/rust-lang/rust/commit/287a3457bcfb07e65ddc16affd8f721ad7cfa29c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/287a3457bcfb07e65ddc16affd8f721ad7cfa29c/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c937254357c0991e3eacad3822b1b7f80d7f145c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c937254357c0991e3eacad3822b1b7f80d7f145c", "html_url": "https://github.com/rust-lang/rust/commit/c937254357c0991e3eacad3822b1b7f80d7f145c"}], "stats": {"total": 425, "additions": 381, "deletions": 44}, "files": [{"sha": "9f667e7a3c46d1e4824e4a83e6fd1956f9325755", "filename": "src/doc/reference/src/items.md", "status": "modified", "additions": 370, "deletions": 1, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/287a3457bcfb07e65ddc16affd8f721ad7cfa29c/src%2Fdoc%2Freference%2Fsrc%2Fitems.md", "raw_url": "https://github.com/rust-lang/rust/raw/287a3457bcfb07e65ddc16affd8f721ad7cfa29c/src%2Fdoc%2Freference%2Fsrc%2Fitems.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fitems.md?ref=287a3457bcfb07e65ddc16affd8f721ad7cfa29c", "patch": "@@ -630,7 +630,7 @@ unsafe fn bump_levels_unsafe2() -> u32 {\n Mutable statics have the same restrictions as normal statics, except that the\n type of the value is not required to ascribe to `Sync`.\n \n-### `'static` lifetime elision\n+#### `'static` lifetime elision\n \n [Unstable] Both constant and static declarations of reference types have\n *implicit* `'static` lifetimes unless an explicit lifetime is specified. As\n@@ -676,3 +676,372 @@ const RESOLVED_MULTIPLE: Fn(&Foo, &Bar, &Baz) -> usize = ..\n // `Fn(&'static Foo, &'static Bar) -> &'static Baz`.\n const RESOLVED_STATIC: Fn(&Foo, &Bar) -> &Baz = ..\n ```\n+\n+### Traits\n+\n+A _trait_ describes an abstract interface that types can\n+implement. This interface consists of associated items, which come in\n+three varieties:\n+\n+- functions\n+- constants\n+- types\n+\n+Associated functions whose first parameter is named `self` are called\n+methods and may be invoked using `.` notation (e.g., `x.foo()`).\n+\n+All traits define an implicit type parameter `Self` that refers to\n+\"the type that is implementing this interface\". Traits may also\n+contain additional type parameters. These type parameters (including\n+`Self`) may be constrained by other traits and so forth as usual.\n+\n+Trait bounds on `Self` are considered \"supertraits\". These are\n+required to be acyclic.  Supertraits are somewhat different from other\n+constraints in that they affect what methods are available in the\n+vtable when the trait is used as a [trait object](#trait-objects).\n+\n+Traits are implemented for specific types through separate\n+[implementations](#implementations).\n+\n+Consider the following trait:\n+\n+```\n+# type Surface = i32;\n+# type BoundingBox = i32;\n+trait Shape {\n+    fn draw(&self, Surface);\n+    fn bounding_box(&self) -> BoundingBox;\n+}\n+```\n+\n+This defines a trait with two methods. All values that have\n+[implementations](#implementations) of this trait in scope can have their\n+`draw` and `bounding_box` methods called, using `value.bounding_box()`\n+[syntax](#method-call-expressions).\n+\n+Traits can include default implementations of methods, as in:\n+\n+```\n+trait Foo {\n+    fn bar(&self);\n+    fn baz(&self) { println!(\"We called baz.\"); }\n+}\n+```\n+\n+Here the `baz` method has a default implementation, so types that implement\n+`Foo` need only implement `bar`. It is also possible for implementing types\n+to override a method that has a default implementation.\n+\n+Type parameters can be specified for a trait to make it generic. These appear\n+after the trait name, using the same syntax used in [generic\n+functions](#generic-functions).\n+\n+```\n+trait Seq<T> {\n+    fn len(&self) -> u32;\n+    fn elt_at(&self, n: u32) -> T;\n+    fn iter<F>(&self, F) where F: Fn(T);\n+}\n+```\n+\n+It is also possible to define associated types for a trait. Consider the\n+following example of a `Container` trait. Notice how the type is available\n+for use in the method signatures:\n+\n+```\n+trait Container {\n+    type E;\n+    fn empty() -> Self;\n+    fn insert(&mut self, Self::E);\n+}\n+```\n+\n+In order for a type to implement this trait, it must not only provide\n+implementations for every method, but it must specify the type `E`. Here's\n+an implementation of `Container` for the standard library type `Vec`:\n+\n+```\n+# trait Container {\n+#     type E;\n+#     fn empty() -> Self;\n+#     fn insert(&mut self, Self::E);\n+# }\n+impl<T> Container for Vec<T> {\n+    type E = T;\n+    fn empty() -> Vec<T> { Vec::new() }\n+    fn insert(&mut self, x: T) { self.push(x); }\n+}\n+```\n+\n+Generic functions may use traits as _bounds_ on their type parameters. This\n+will have two effects:\n+\n+- Only types that have the trait may instantiate the parameter.\n+- Within the generic function, the methods of the trait can be\n+  called on values that have the parameter's type.\n+\n+For example:\n+\n+```\n+# type Surface = i32;\n+# trait Shape { fn draw(&self, Surface); }\n+fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n+    sh.draw(surface);\n+    sh.draw(surface);\n+}\n+```\n+\n+Traits also define a [trait object](#trait-objects) with the same\n+name as the trait. Values of this type are created by coercing from a\n+pointer of some specific type to a pointer of trait type. For example,\n+`&T` could be coerced to `&Shape` if `T: Shape` holds (and similarly\n+for `Box<T>`). This coercion can either be implicit or\n+[explicit](#type-cast-expressions). Here is an example of an explicit\n+coercion:\n+\n+```\n+trait Shape { }\n+impl Shape for i32 { }\n+let mycircle = 0i32;\n+let myshape: Box<Shape> = Box::new(mycircle) as Box<Shape>;\n+```\n+\n+The resulting value is a box containing the value that was cast, along with\n+information that identifies the methods of the implementation that was used.\n+Values with a trait type can have [methods called](#method-call-expressions) on\n+them, for any method in the trait, and can be used to instantiate type\n+parameters that are bounded by the trait.\n+\n+Trait methods may be static, which means that they lack a `self` argument.\n+This means that they can only be called with function call syntax (`f(x)`) and\n+not method call syntax (`obj.f()`). The way to refer to the name of a static\n+method is to qualify it with the trait name, treating the trait name like a\n+module. For example:\n+\n+```\n+trait Num {\n+    fn from_i32(n: i32) -> Self;\n+}\n+impl Num for f64 {\n+    fn from_i32(n: i32) -> f64 { n as f64 }\n+}\n+let x: f64 = Num::from_i32(42);\n+```\n+\n+Traits may inherit from other traits. Consider the following example:\n+\n+```\n+trait Shape { fn area(&self) -> f64; }\n+trait Circle : Shape { fn radius(&self) -> f64; }\n+```\n+\n+The syntax `Circle : Shape` means that types that implement `Circle` must also\n+have an implementation for `Shape`. Multiple supertraits are separated by `+`,\n+`trait Circle : Shape + PartialEq { }`. In an implementation of `Circle` for a\n+given type `T`, methods can refer to `Shape` methods, since the typechecker\n+checks that any type with an implementation of `Circle` also has an\n+implementation of `Shape`:\n+\n+```rust\n+struct Foo;\n+\n+trait Shape { fn area(&self) -> f64; }\n+trait Circle : Shape { fn radius(&self) -> f64; }\n+impl Shape for Foo {\n+    fn area(&self) -> f64 {\n+        0.0\n+    }\n+}\n+impl Circle for Foo {\n+    fn radius(&self) -> f64 {\n+        println!(\"calling area: {}\", self.area());\n+\n+        0.0\n+    }\n+}\n+\n+let c = Foo;\n+c.radius();\n+```\n+\n+In type-parameterized functions, methods of the supertrait may be called on\n+values of subtrait-bound type parameters. Referring to the previous example of\n+`trait Circle : Shape`:\n+\n+```\n+# trait Shape { fn area(&self) -> f64; }\n+# trait Circle : Shape { fn radius(&self) -> f64; }\n+fn radius_times_area<T: Circle>(c: T) -> f64 {\n+    // `c` is both a Circle and a Shape\n+    c.radius() * c.area()\n+}\n+```\n+\n+Likewise, supertrait methods may also be called on trait objects.\n+\n+```{.ignore}\n+# trait Shape { fn area(&self) -> f64; }\n+# trait Circle : Shape { fn radius(&self) -> f64; }\n+# impl Shape for i32 { fn area(&self) -> f64 { 0.0 } }\n+# impl Circle for i32 { fn radius(&self) -> f64 { 0.0 } }\n+# let mycircle = 0i32;\n+let mycircle = Box::new(mycircle) as Box<Circle>;\n+let nonsense = mycircle.radius() * mycircle.area();\n+```\n+\n+### Implementations\n+\n+An _implementation_ is an item that implements a [trait](#traits) for a\n+specific type.\n+\n+Implementations are defined with the keyword `impl`.\n+\n+```\n+# #[derive(Copy, Clone)]\n+# struct Point {x: f64, y: f64};\n+# type Surface = i32;\n+# struct BoundingBox {x: f64, y: f64, width: f64, height: f64};\n+# trait Shape { fn draw(&self, Surface); fn bounding_box(&self) -> BoundingBox; }\n+# fn do_draw_circle(s: Surface, c: Circle) { }\n+struct Circle {\n+    radius: f64,\n+    center: Point,\n+}\n+\n+impl Copy for Circle {}\n+\n+impl Clone for Circle {\n+    fn clone(&self) -> Circle { *self }\n+}\n+\n+impl Shape for Circle {\n+    fn draw(&self, s: Surface) { do_draw_circle(s, *self); }\n+    fn bounding_box(&self) -> BoundingBox {\n+        let r = self.radius;\n+        BoundingBox {\n+            x: self.center.x - r,\n+            y: self.center.y - r,\n+            width: 2.0 * r,\n+            height: 2.0 * r,\n+        }\n+    }\n+}\n+```\n+\n+It is possible to define an implementation without referring to a trait. The\n+methods in such an implementation can only be used as direct calls on the values\n+of the type that the implementation targets. In such an implementation, the\n+trait type and `for` after `impl` are omitted. Such implementations are limited\n+to nominal types (enums, structs, trait objects), and the implementation must\n+appear in the same crate as the `self` type:\n+\n+```\n+struct Point {x: i32, y: i32}\n+\n+impl Point {\n+    fn log(&self) {\n+        println!(\"Point is at ({}, {})\", self.x, self.y);\n+    }\n+}\n+\n+let my_point = Point {x: 10, y:11};\n+my_point.log();\n+```\n+\n+When a trait _is_ specified in an `impl`, all methods declared as part of the\n+trait must be implemented, with matching types and type parameter counts.\n+\n+An implementation can take type parameters, which can be different from the\n+type parameters taken by the trait it implements. Implementation parameters\n+are written after the `impl` keyword.\n+\n+```\n+# trait Seq<T> { fn dummy(&self, _: T) { } }\n+impl<T> Seq<T> for Vec<T> {\n+    /* ... */\n+}\n+impl Seq<bool> for u32 {\n+    /* Treat the integer as a sequence of bits */\n+}\n+```\n+\n+### External blocks\n+\n+External blocks form the basis for Rust's foreign function interface.\n+Declarations in an external block describe symbols in external, non-Rust\n+libraries.\n+\n+Functions within external blocks are declared in the same way as other Rust\n+functions, with the exception that they may not have a body and are instead\n+terminated by a semicolon.\n+\n+Functions within external blocks may be called by Rust code, just like\n+functions defined in Rust. The Rust compiler automatically translates between\n+the Rust ABI and the foreign ABI.\n+\n+Functions within external blocks may be variadic by specifying `...` after one\n+or more named arguments in the argument list:\n+\n+```ignore\n+extern {\n+    fn foo(x: i32, ...);\n+}\n+```\n+\n+A number of [attributes](#ffi-attributes) control the behavior of external blocks.\n+\n+By default external blocks assume that the library they are calling uses the\n+standard C ABI on the specific platform. Other ABIs may be specified using an\n+`abi` string, as shown here:\n+\n+```ignore\n+// Interface to the Windows API\n+extern \"stdcall\" { }\n+```\n+\n+There are three ABI strings which are cross-platform, and which all compilers\n+are guaranteed to support:\n+\n+* `extern \"Rust\"` -- The default ABI when you write a normal `fn foo()` in any\n+  Rust code.\n+* `extern \"C\"` -- This is the same as `extern fn foo()`; whatever the default\n+  your C compiler supports.\n+* `extern \"system\"` -- Usually the same as `extern \"C\"`, except on Win32, in\n+  which case it's `\"stdcall\"`, or what you should use to link to the Windows API\n+  itself\n+\n+There are also some platform-specific ABI strings:\n+\n+* `extern \"cdecl\"` -- The default for x86\\_32 C code.\n+* `extern \"stdcall\"` -- The default for the Win32 API on x86\\_32.\n+* `extern \"win64\"` -- The default for C code on x86\\_64 Windows.\n+* `extern \"sysv64\"` -- The default for C code on non-Windows x86\\_64.\n+* `extern \"aapcs\"` -- The default for ARM.\n+* `extern \"fastcall\"` -- The `fastcall` ABI -- corresponds to MSVC's\n+  `__fastcall` and GCC and clang's `__attribute__((fastcall))`\n+* `extern \"vectorcall\"` -- The `vectorcall` ABI -- corresponds to MSVC's\n+  `__vectorcall` and clang's `__attribute__((vectorcall))`\n+\n+Finally, there are some rustc-specific ABI strings:\n+\n+* `extern \"rust-intrinsic\"` -- The ABI of rustc intrinsics.\n+* `extern \"rust-call\"` -- The ABI of the Fn::call trait functions.\n+* `extern \"platform-intrinsic\"` -- Specific platform intrinsics -- like, for\n+  example, `sqrt` -- have this ABI. You should never have to deal with it.\n+\n+The `link` attribute allows the name of the library to be specified. When\n+specified the compiler will attempt to link against the native library of the\n+specified name.\n+\n+```{.ignore}\n+#[link(name = \"crypto\")]\n+extern { }\n+```\n+\n+The type of a function declared in an extern block is `extern \"abi\" fn(A1, ...,\n+An) -> R`, where `A1...An` are the declared types of its arguments and `R` is\n+the declared return type.\n+\n+It is valid to add the `link` attribute on an empty extern block. You can use\n+this to satisfy the linking requirements of extern blocks elsewhere in your code\n+(including upstream crates) instead of adding the attribute to each extern block."}, {"sha": "aa57ae6ae9bead48da8e96697c73058d78958387", "filename": "src/doc/reference/src/memory-model.md", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/287a3457bcfb07e65ddc16affd8f721ad7cfa29c/src%2Fdoc%2Freference%2Fsrc%2Fmemory-model.md", "raw_url": "https://github.com/rust-lang/rust/raw/287a3457bcfb07e65ddc16affd8f721ad7cfa29c/src%2Fdoc%2Freference%2Fsrc%2Fmemory-model.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fmemory-model.md?ref=287a3457bcfb07e65ddc16affd8f721ad7cfa29c", "patch": "@@ -8,17 +8,3 @@ discipline, exist in the standard library.\n \n Allocations in the stack consist of *variables*, and allocations in the heap\n consist of *boxes*.\n-\n-## Memory allocation and lifetime\n-\n-The _items_ of a program are those functions, modules and types that have their\n-value calculated at compile-time and stored uniquely in the memory image of the\n-rust process. Items are neither dynamically allocated nor freed.\n-\n-The _heap_ is a general term that describes boxes.  The lifetime of an\n-allocation in the heap depends on the lifetime of the box values pointing to\n-it. Since box values may themselves be passed in and out of frames, or stored\n-in the heap, heap allocations may outlive the frame they are allocated within.\n-An allocation in the heap is guaranteed to reside at a single location in the\n-heap for the whole lifetime of the allocation - it will never be relocated as\n-a result of moving a box value."}, {"sha": "5a45a2a150b8feaa390d0af6630bb35d62be0d4d", "filename": "src/doc/reference/src/tokens.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/287a3457bcfb07e65ddc16affd8f721ad7cfa29c/src%2Fdoc%2Freference%2Fsrc%2Ftokens.md", "raw_url": "https://github.com/rust-lang/rust/raw/287a3457bcfb07e65ddc16affd8f721ad7cfa29c/src%2Fdoc%2Freference%2Fsrc%2Ftokens.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Ftokens.md?ref=287a3457bcfb07e65ddc16affd8f721ad7cfa29c", "patch": "@@ -303,3 +303,14 @@ The representation semantics of floating-point numbers are described in\n ### Boolean literals\n \n The two values of the boolean type are written `true` and `false`.\n+\n+## Symbols\n+\n+Symbols are a general class of printable [tokens](#tokens) that play structural\n+roles in a variety of grammar productions. They are a\n+set of remaining miscellaneous printable tokens that do not\n+otherwise appear as [unary operators](#unary-operator-expressions), [binary\n+operators](#binary-operator-expressions), or [keywords][keywords].\n+They are catalogued in [the Symbols section][symbols] of the Grammar document.\n+\n+[symbols]: grammar.html#symbols"}, {"sha": "72ae1c725edf3ee71047cf640aaf2a41ed92d449", "filename": "src/doc/reference/src/unsafety.md", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/287a3457bcfb07e65ddc16affd8f721ad7cfa29c/src%2Fdoc%2Freference%2Fsrc%2Funsafety.md", "raw_url": "https://github.com/rust-lang/rust/raw/287a3457bcfb07e65ddc16affd8f721ad7cfa29c/src%2Fdoc%2Freference%2Fsrc%2Funsafety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Funsafety.md?ref=287a3457bcfb07e65ddc16affd8f721ad7cfa29c", "patch": "@@ -9,32 +9,3 @@ Rust:\n - Dereferencing a [raw pointer](#pointer-types).\n - Reading or writing a [mutable static variable](#mutable-statics).\n - Calling an unsafe function (including an intrinsic or foreign function).\n-\n-## Unsafe functions\n-\n-Unsafe functions are functions that are not safe in all contexts and/or for all\n-possible inputs. Such a function must be prefixed with the keyword `unsafe` and\n-can only be called from an `unsafe` block or another `unsafe` function.\n-\n-## Unsafe blocks\n-\n-A block of code can be prefixed with the `unsafe` keyword, to permit calling\n-`unsafe` functions or dereferencing raw pointers within a safe function.\n-\n-When a programmer has sufficient conviction that a sequence of potentially\n-unsafe operations is actually safe, they can encapsulate that sequence (taken\n-as a whole) within an `unsafe` block. The compiler will consider uses of such\n-code safe, in the surrounding context.\n-\n-Unsafe blocks are used to wrap foreign libraries, make direct use of hardware\n-or implement features not directly present in the language. For example, Rust\n-provides the language features necessary to implement memory-safe concurrency\n-in the language but the implementation of threads and message passing is in the\n-standard library.\n-\n-Rust's type system is a conservative approximation of the dynamic safety\n-requirements, so in some cases there is a performance cost to using safe code.\n-For example, a doubly-linked list is not a tree structure and can only be\n-represented with reference-counted pointers in safe code. By using `unsafe`\n-blocks to represent the reverse links as raw pointers, it can be implemented\n-with only boxes."}]}