{"sha": "b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MmRmOTE4NzczMGFiYmNkOWNiYjEzMmY3ZDE4NGM3NGI5YTNiN2Y=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-25T23:01:58Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-25T23:01:58Z"}, "message": "Stop expanding UseTrees during ItemTree lowering", "tree": {"sha": "06cf9ab8dcd938db5390b7da40f7e9a6db262d0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06cf9ab8dcd938db5390b7da40f7e9a6db262d0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "html_url": "https://github.com/rust-lang/rust/commit/b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5587d0a3e3599063a8993e9a44a7628abbabae8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5587d0a3e3599063a8993e9a44a7628abbabae8b", "html_url": "https://github.com/rust-lang/rust/commit/5587d0a3e3599063a8993e9a44a7628abbabae8b"}], "stats": {"total": 508, "additions": 320, "deletions": 188}, "files": [{"sha": "01b2de515ad9b13819433932fac18ac7958f9f25", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -472,27 +472,13 @@ impl Module {\n                     });\n                 }\n \n-                DefDiagnosticKind::UnresolvedImport { ast, index } => {\n-                    let use_item = ast.to_node(db.upcast());\n-                    let hygiene = Hygiene::new(db.upcast(), ast.file_id);\n-                    let mut cur = 0;\n-                    let mut tree = None;\n-                    ModPath::expand_use_item(\n-                        db.upcast(),\n-                        InFile::new(ast.file_id, use_item),\n-                        &hygiene,\n-                        |_mod_path, use_tree, _is_glob, _alias| {\n-                            if cur == *index {\n-                                tree = Some(use_tree.clone());\n-                            }\n-\n-                            cur += 1;\n-                        },\n-                    );\n+                DefDiagnosticKind::UnresolvedImport { id, index } => {\n+                    let file_id = id.file_id();\n+                    let item_tree = id.item_tree(db.upcast());\n+                    let import = &item_tree[id.value];\n \n-                    if let Some(tree) = tree {\n-                        sink.push(UnresolvedImport { file: ast.file_id, node: AstPtr::new(&tree) });\n-                    }\n+                    let use_tree = import.use_tree_to_ast(db.upcast(), file_id, *index);\n+                    sink.push(UnresolvedImport { file: file_id, node: AstPtr::new(&use_tree) });\n                 }\n \n                 DefDiagnosticKind::UnconfiguredCode { ast, cfg, opts } => {"}, {"sha": "508736885b9c49e7d8dc1a900b48a54e32ce64bd", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 119, "deletions": 11, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -523,21 +523,38 @@ impl<N: ItemTreeNode> Index<FileItemTreeId<N>> for ItemTree {\n     }\n }\n \n-/// A desugared `use` import.\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Import {\n-    pub path: Interned<ModPath>,\n-    pub alias: Option<ImportAlias>,\n     pub visibility: RawVisibilityId,\n-    pub is_glob: bool,\n-    /// AST ID of the `use` item this import was derived from. Note that many `Import`s can map to\n-    /// the same `use` item.\n     pub ast_id: FileAstId<ast::Use>,\n-    /// Index of this `Import` when the containing `Use` is visited via `ModPath::expand_use_item`.\n-    ///\n-    /// This can be used to get the `UseTree` this `Import` corresponds to and allows emitting\n-    /// precise diagnostics.\n-    pub index: usize,\n+    pub use_tree: UseTree,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct UseTree {\n+    pub index: Idx<ast::UseTree>,\n+    kind: UseTreeKind,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum UseTreeKind {\n+    /// ```ignore\n+    /// use path::to::Item;\n+    /// use path::to::Item as Renamed;\n+    /// use path::to::Trait as _;\n+    /// ```\n+    Single { path: ModPath, alias: Option<ImportAlias> },\n+\n+    /// ```ignore\n+    /// use *;  // (invalid, but can occur in nested tree)\n+    /// use path::*;\n+    /// ```\n+    Glob { path: Option<ModPath> },\n+\n+    /// ```ignore\n+    /// use prefix::{self, Item, ...};\n+    /// ```\n+    Prefixed { prefix: Option<ModPath>, list: Vec<UseTree> },\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -711,6 +728,97 @@ pub struct MacroDef {\n     pub ast_id: FileAstId<ast::MacroDef>,\n }\n \n+impl Import {\n+    /// Maps a `UseTree` contained in this import back to its AST node.\n+    pub fn use_tree_to_ast(\n+        &self,\n+        db: &dyn DefDatabase,\n+        file_id: HirFileId,\n+        index: Idx<ast::UseTree>,\n+    ) -> ast::UseTree {\n+        // Re-lower the AST item and get the source map.\n+        // Note: The AST unwraps are fine, since if they fail we should have never obtained `index`.\n+        let ast = InFile::new(file_id, self.ast_id).to_node(db.upcast());\n+        let ast_use_tree = ast.use_tree().expect(\"missing `use_tree`\");\n+        let hygiene = Hygiene::new(db.upcast(), file_id);\n+        let (_, source_map) =\n+            lower::lower_use_tree(db, &hygiene, ast_use_tree).expect(\"failed to lower use tree\");\n+        source_map[index].clone()\n+    }\n+}\n+\n+impl UseTree {\n+    /// Expands the `UseTree` into individually imported `ModPath`s.\n+    pub fn expand(\n+        &self,\n+        mut cb: impl FnMut(Idx<ast::UseTree>, ModPath, /* is_glob */ bool, Option<ImportAlias>),\n+    ) {\n+        self.expand_impl(None, &mut cb)\n+    }\n+\n+    fn expand_impl(\n+        &self,\n+        prefix: Option<ModPath>,\n+        cb: &mut dyn FnMut(\n+            Idx<ast::UseTree>,\n+            ModPath,\n+            /* is_glob */ bool,\n+            Option<ImportAlias>,\n+        ),\n+    ) {\n+        fn concat_mod_paths(prefix: Option<ModPath>, path: &ModPath) -> Option<ModPath> {\n+            match (prefix, &path.kind) {\n+                (None, _) => Some(path.clone()),\n+                (Some(mut prefix), PathKind::Plain) => {\n+                    for segment in path.segments() {\n+                        prefix.push_segment(segment.clone());\n+                    }\n+                    Some(prefix)\n+                }\n+                (Some(prefix), PathKind::Super(0)) => {\n+                    // `some::path::self` == `some::path`\n+                    if path.segments().is_empty() {\n+                        Some(prefix)\n+                    } else {\n+                        None\n+                    }\n+                }\n+                (Some(_), _) => None,\n+            }\n+        }\n+\n+        match &self.kind {\n+            UseTreeKind::Single { path, alias } => {\n+                if let Some(path) = concat_mod_paths(prefix, path) {\n+                    cb(self.index, path, false, alias.clone());\n+                }\n+            }\n+            UseTreeKind::Glob { path: Some(path) } => {\n+                if let Some(path) = concat_mod_paths(prefix, path) {\n+                    cb(self.index, path, true, None);\n+                }\n+            }\n+            UseTreeKind::Glob { path: None } => {\n+                if let Some(prefix) = prefix {\n+                    cb(self.index, prefix, true, None);\n+                }\n+            }\n+            UseTreeKind::Prefixed { prefix: additional_prefix, list } => {\n+                let prefix = match additional_prefix {\n+                    Some(path) => match concat_mod_paths(prefix, path) {\n+                        Some(path) => Some(path),\n+                        None => return,\n+                    },\n+                    None => prefix,\n+                };\n+                for tree in list {\n+                    tree.expand_impl(prefix.clone(), cb);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n macro_rules! impl_froms {\n     ($e:ident { $($v:ident ($t:ty)),* $(,)? }) => {\n         $("}, {"sha": "a59a3dc37e334d82e5636f5929eaa91b9bdaadee", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 77, "deletions": 23, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -35,7 +35,6 @@ pub(super) struct Ctx<'a> {\n     db: &'a dyn DefDatabase,\n     tree: ItemTree,\n     hygiene: Hygiene,\n-    file: HirFileId,\n     source_ast_id_map: Arc<AstIdMap>,\n     body_ctx: crate::body::LowerCtx<'a>,\n     forced_visibility: Option<RawVisibilityId>,\n@@ -47,7 +46,6 @@ impl<'a> Ctx<'a> {\n             db,\n             tree: ItemTree::default(),\n             hygiene,\n-            file,\n             source_ast_id_map: db.ast_id_map(file),\n             body_ctx: crate::body::LowerCtx::new(db, file),\n             forced_visibility: None,\n@@ -561,30 +559,13 @@ impl<'a> Ctx<'a> {\n         Some(id(self.data().impls.alloc(res)))\n     }\n \n-    fn lower_use(&mut self, use_item: &ast::Use) -> Vec<FileItemTreeId<Import>> {\n+    fn lower_use(&mut self, use_item: &ast::Use) -> Option<FileItemTreeId<Import>> {\n         let visibility = self.lower_visibility(use_item);\n         let ast_id = self.source_ast_id_map.ast_id(use_item);\n+        let (use_tree, _) = lower_use_tree(self.db, &self.hygiene, use_item.use_tree()?)?;\n \n-        // Every use item can expand to many `Import`s.\n-        let mut imports = Vec::new();\n-        let tree = self.tree.data_mut();\n-        ModPath::expand_use_item(\n-            self.db,\n-            InFile::new(self.file, use_item.clone()),\n-            &self.hygiene,\n-            |path, _use_tree, is_glob, alias| {\n-                imports.push(id(tree.imports.alloc(Import {\n-                    path: Interned::new(path),\n-                    alias,\n-                    visibility,\n-                    is_glob,\n-                    ast_id,\n-                    index: imports.len(),\n-                })));\n-            },\n-        );\n-\n-        imports\n+        let res = Import { visibility, ast_id, use_tree };\n+        Some(id(self.data().imports.alloc(res)))\n     }\n \n     fn lower_extern_crate(\n@@ -884,3 +865,76 @@ fn lower_abi(abi: ast::Abi) -> Interned<str> {\n         }\n     }\n }\n+\n+struct UseTreeLowering<'a> {\n+    db: &'a dyn DefDatabase,\n+    hygiene: &'a Hygiene,\n+    mapping: Arena<ast::UseTree>,\n+}\n+\n+impl UseTreeLowering<'_> {\n+    fn lower_use_tree(&mut self, tree: ast::UseTree) -> Option<UseTree> {\n+        if let Some(use_tree_list) = tree.use_tree_list() {\n+            let prefix = match tree.path() {\n+                // E.g. use something::{{{inner}}};\n+                None => None,\n+                // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n+                // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n+                Some(path) => {\n+                    match ModPath::from_src(self.db, path, &self.hygiene) {\n+                        Some(it) => Some(it),\n+                        None => return None, // FIXME: report errors somewhere\n+                    }\n+                }\n+            };\n+\n+            let list =\n+                use_tree_list.use_trees().filter_map(|tree| self.lower_use_tree(tree)).collect();\n+\n+            Some(self.use_tree(UseTreeKind::Prefixed { prefix, list }, tree))\n+        } else {\n+            let is_glob = tree.star_token().is_some();\n+            let path = match tree.path() {\n+                Some(path) => Some(ModPath::from_src(self.db, path, &self.hygiene)?),\n+                None => None,\n+            };\n+            let alias = tree.rename().map(|a| {\n+                a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n+            });\n+            if alias.is_some() && is_glob {\n+                return None;\n+            }\n+\n+            match (path, alias, is_glob) {\n+                (path, None, true) => {\n+                    if path.is_none() {\n+                        cov_mark::hit!(glob_enum_group);\n+                    }\n+                    Some(self.use_tree(UseTreeKind::Glob { path }, tree))\n+                }\n+                // Globs can't be renamed\n+                (_, Some(_), true) | (None, None, false) => None,\n+                // `bla::{ as Name}` is invalid\n+                (None, Some(_), false) => None,\n+                (Some(path), alias, false) => {\n+                    Some(self.use_tree(UseTreeKind::Single { path, alias }, tree))\n+                }\n+            }\n+        }\n+    }\n+\n+    fn use_tree(&mut self, kind: UseTreeKind, ast: ast::UseTree) -> UseTree {\n+        let index = self.mapping.alloc(ast);\n+        UseTree { index, kind }\n+    }\n+}\n+\n+pub(super) fn lower_use_tree(\n+    db: &dyn DefDatabase,\n+    hygiene: &Hygiene,\n+    tree: ast::UseTree,\n+) -> Option<(UseTree, Arena<ast::UseTree>)> {\n+    let mut lowering = UseTreeLowering { db, hygiene, mapping: Arena::new() };\n+    let tree = lowering.lower_use_tree(tree)?;\n+    Some((tree, lowering.mapping))\n+}"}, {"sha": "53631ab192b43b0b33a07a3258ca9fd0f435cad5", "filename": "crates/hir_def/src/item_tree/pretty.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -163,21 +163,46 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n+    fn print_use_tree(&mut self, use_tree: &UseTree) {\n+        match &use_tree.kind {\n+            UseTreeKind::Single { path, alias } => {\n+                w!(self, \"{}\", path);\n+                if let Some(alias) = alias {\n+                    w!(self, \" as {}\", alias);\n+                }\n+            }\n+            UseTreeKind::Glob { path } => {\n+                if let Some(path) = path {\n+                    w!(self, \"{}::\", path);\n+                }\n+                w!(self, \"*\");\n+            }\n+            UseTreeKind::Prefixed { prefix, list } => {\n+                if let Some(prefix) = prefix {\n+                    w!(self, \"{}::\", prefix);\n+                }\n+                w!(self, \"{{\");\n+                for (i, tree) in list.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    self.print_use_tree(tree);\n+                }\n+                w!(self, \"}}\");\n+            }\n+        }\n+    }\n+\n     fn print_mod_item(&mut self, item: ModItem) {\n         self.print_attrs_of(item);\n \n         match item {\n             ModItem::Import(it) => {\n-                let Import { visibility, path, is_glob, alias, ast_id: _, index } = &self.tree[it];\n+                let Import { visibility, use_tree, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"use {}\", path);\n-                if *is_glob {\n-                    w!(self, \"::*\");\n-                }\n-                if let Some(alias) = alias {\n-                    w!(self, \" as {}\", alias);\n-                }\n-                wln!(self, \";  // {}\", index);\n+                w!(self, \"use \");\n+                self.print_use_tree(use_tree);\n+                wln!(self, \";\");\n             }\n             ModItem::ExternCrate(it) => {\n                 let ExternCrate { name, alias, visibility, ast_id: _ } = &self.tree[it];"}, {"sha": "20773aa699494c36d04ce9ed222116979b73e545", "filename": "crates/hir_def/src/item_tree/tests.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -26,6 +26,8 @@ use globs::*;\n \n /// docs on import\n use crate::{A, B};\n+\n+use a::{c, d::{e}};\n         \"#,\n         expect![[r##\"\n             #![doc = \" file comment\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n@@ -36,19 +38,14 @@ use crate::{A, B};\n \n             pub(super) extern crate bli;\n \n-            pub use crate::path::nested;  // 0\n-\n-            pub use crate::path::items as renamed;  // 1\n+            pub use crate::path::{nested, items as renamed, Trait as _};\n \n-            pub use crate::path::Trait as _;  // 2\n-\n-            pub(self) use globs::*;  // 0\n+            pub(self) use globs::*;\n \n             #[doc = \" docs on import\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n-            pub(self) use crate::A;  // 0\n+            pub(self) use crate::{A, B};\n \n-            #[doc = \" docs on import\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n-            pub(self) use crate::B;  // 1\n+            pub(self) use a::{c, d::{e}};\n         \"##]],\n     );\n }\n@@ -218,7 +215,7 @@ mod outline;\n             #[doc = \" outer\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n             #[doc = \" inner\"]  // AttrId { is_doc_comment: true, ast_index: 1 }\n             pub(self) mod inline {\n-                pub(self) use super::*;  // 0\n+                pub(self) use super::*;\n \n                 // flags = 0x2\n                 pub(self) fn fn_in_module() -> ();"}, {"sha": "4296c630452f1bc6021cb0649d3c55f59688e6b6", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -17,6 +17,7 @@ use hir_expand::{\n };\n use hir_expand::{InFile, MacroCallLoc};\n use itertools::Itertools;\n+use la_arena::Idx;\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n \n@@ -143,7 +144,7 @@ impl PartialResolvedImport {\n \n #[derive(Clone, Debug, Eq, PartialEq)]\n enum ImportSource {\n-    Import(ItemTreeId<item_tree::Import>),\n+    Import { id: ItemTreeId<item_tree::Import>, use_tree: Idx<ast::UseTree> },\n     ExternCrate(ItemTreeId<item_tree::ExternCrate>),\n }\n \n@@ -165,20 +166,26 @@ impl Import {\n         krate: CrateId,\n         tree: &ItemTree,\n         id: ItemTreeId<item_tree::Import>,\n-    ) -> Self {\n+    ) -> Vec<Self> {\n         let it = &tree[id.value];\n         let attrs = &tree.attrs(db, krate, ModItem::from(id.value).into());\n         let visibility = &tree[it.visibility];\n-        Self {\n-            path: it.path.clone(),\n-            alias: it.alias.clone(),\n-            visibility: visibility.clone(),\n-            is_glob: it.is_glob,\n-            is_prelude: attrs.by_key(\"prelude_import\").exists(),\n-            is_extern_crate: false,\n-            is_macro_use: false,\n-            source: ImportSource::Import(id),\n-        }\n+        let is_prelude = attrs.by_key(\"prelude_import\").exists();\n+\n+        let mut res = Vec::new();\n+        it.use_tree.expand(|idx, path, is_glob, alias| {\n+            res.push(Self {\n+                path: Interned::new(path), // FIXME this makes little sense\n+                alias,\n+                visibility: visibility.clone(),\n+                is_glob,\n+                is_prelude,\n+                is_extern_crate: false,\n+                is_macro_use: false,\n+                source: ImportSource::Import { id, use_tree: idx },\n+            });\n+        });\n+        res\n     }\n \n     fn from_extern_crate(\n@@ -1130,11 +1137,8 @@ impl DefCollector<'_> {\n         }\n \n         for directive in &self.unresolved_imports {\n-            if let ImportSource::Import(import) = &directive.import.source {\n-                let item_tree = import.item_tree(self.db);\n-                let import_data = &item_tree[import.value];\n-\n-                match (import_data.path.segments().first(), &import_data.path.kind) {\n+            if let ImportSource::Import { id: import, use_tree } = &directive.import.source {\n+                match (directive.import.path.segments().first(), &directive.import.path.kind) {\n                     (Some(krate), PathKind::Plain) | (Some(krate), PathKind::Abs) => {\n                         if diagnosed_extern_crates.contains(krate) {\n                             continue;\n@@ -1145,8 +1149,8 @@ impl DefCollector<'_> {\n \n                 self.def_map.diagnostics.push(DefDiagnostic::unresolved_import(\n                     directive.module_id,\n-                    InFile::new(import.file_id(), import_data.ast_id),\n-                    import_data.index,\n+                    *import,\n+                    *use_tree,\n                 ));\n             }\n         }\n@@ -1222,16 +1226,20 @@ impl ModCollector<'_, '_> {\n             match item {\n                 ModItem::Mod(m) => self.collect_module(&self.item_tree[m], &attrs),\n                 ModItem::Import(import_id) => {\n-                    self.def_collector.unresolved_imports.push(ImportDirective {\n-                        module_id: self.module_id,\n-                        import: Import::from_use(\n-                            self.def_collector.db,\n-                            krate,\n-                            &self.item_tree,\n-                            ItemTreeId::new(self.file_id, import_id),\n-                        ),\n-                        status: PartialResolvedImport::Unresolved,\n-                    })\n+                    let module_id = self.module_id;\n+                    let imports = Import::from_use(\n+                        self.def_collector.db,\n+                        krate,\n+                        &self.item_tree,\n+                        ItemTreeId::new(self.file_id, import_id),\n+                    );\n+                    self.def_collector.unresolved_imports.extend(imports.into_iter().map(\n+                        |import| ImportDirective {\n+                            module_id,\n+                            import,\n+                            status: PartialResolvedImport::Unresolved,\n+                        },\n+                    ));\n                 }\n                 ModItem::ExternCrate(import_id) => {\n                     self.def_collector.unresolved_imports.push(ImportDirective {"}, {"sha": "57c36c3c6cbe53b5d2817ebe837cb2e95d84f2bb", "filename": "crates/hir_def/src/nameres/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -2,17 +2,23 @@\n \n use cfg::{CfgExpr, CfgOptions};\n use hir_expand::MacroCallKind;\n+use la_arena::Idx;\n use syntax::ast;\n \n-use crate::{nameres::LocalModuleId, path::ModPath, AstId};\n+use crate::{\n+    item_tree::{self, ItemTreeId},\n+    nameres::LocalModuleId,\n+    path::ModPath,\n+    AstId,\n+};\n \n #[derive(Debug, PartialEq, Eq)]\n pub enum DefDiagnosticKind {\n     UnresolvedModule { ast: AstId<ast::Module>, candidate: String },\n \n     UnresolvedExternCrate { ast: AstId<ast::ExternCrate> },\n \n-    UnresolvedImport { ast: AstId<ast::Use>, index: usize },\n+    UnresolvedImport { id: ItemTreeId<item_tree::Import>, index: Idx<ast::UseTree> },\n \n     UnconfiguredCode { ast: AstId<ast::Item>, cfg: CfgExpr, opts: CfgOptions },\n \n@@ -53,10 +59,10 @@ impl DefDiagnostic {\n \n     pub(super) fn unresolved_import(\n         container: LocalModuleId,\n-        ast: AstId<ast::Use>,\n-        index: usize,\n+        id: ItemTreeId<item_tree::Import>,\n+        index: Idx<ast::UseTree>,\n     ) -> Self {\n-        Self { in_module: container, kind: DefDiagnosticKind::UnresolvedImport { ast, index } }\n+        Self { in_module: container, kind: DefDiagnosticKind::UnresolvedImport { id, index } }\n     }\n \n     pub(super) fn unconfigured_code("}, {"sha": "16440041dcb5bbd1495cccba71f9f7c43d2fe824", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -14,10 +14,7 @@ use hir_expand::{\n };\n use syntax::ast;\n \n-use crate::{\n-    type_ref::{TypeBound, TypeRef},\n-    InFile,\n-};\n+use crate::type_ref::{TypeBound, TypeRef};\n \n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ModPath {\n@@ -56,8 +53,7 @@ impl Display for ImportAlias {\n \n impl ModPath {\n     pub fn from_src(db: &dyn DefDatabase, path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n-        let ctx = LowerCtx::with_hygiene(db, hygiene);\n-        lower::lower_path(path, &ctx).map(|it| (*it.mod_path).clone())\n+        lower::convert_path(db, None, path, hygiene)\n     }\n \n     pub fn from_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> ModPath {\n@@ -70,18 +66,6 @@ impl ModPath {\n         ModPath { kind, segments: Vec::new() }\n     }\n \n-    /// Calls `cb` with all paths, represented by this use item.\n-    pub fn expand_use_item(\n-        db: &dyn DefDatabase,\n-        item_src: InFile<ast::Use>,\n-        hygiene: &Hygiene,\n-        mut cb: impl FnMut(ModPath, &ast::UseTree, /* is_glob */ bool, Option<ImportAlias>),\n-    ) {\n-        if let Some(tree) = item_src.value.use_tree() {\n-            lower::lower_use_tree(db, None, tree, hygiene, &mut cb);\n-        }\n-    }\n-\n     pub fn segments(&self) -> &[Name] {\n         &self.segments\n     }"}, {"sha": "f6220aa9280652608ba68824a2cf5d163f4b6a97", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     type_ref::{LifetimeRef, TypeBound, TypeRef},\n };\n \n-pub(super) use lower_use::lower_use_tree;\n+pub(super) use lower_use::convert_path;\n \n /// Converts an `ast::Path` to `Path`. Works with use trees.\n /// It correctly handles `$crate` based path from macro call."}, {"sha": "0ee406f63a64dad31e60fab7aa88f79c20d1ffc1", "filename": "crates/hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 19, "deletions": 59, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -4,68 +4,15 @@\n use std::iter;\n \n use either::Either;\n-use hir_expand::{hygiene::Hygiene, name::AsName};\n-use syntax::ast::{self, NameOwner};\n+use hir_expand::hygiene::Hygiene;\n+use syntax::{ast, AstNode};\n \n use crate::{\n     db::DefDatabase,\n-    path::{ImportAlias, ModPath, PathKind},\n+    path::{ModPath, PathKind},\n };\n \n-pub(crate) fn lower_use_tree(\n-    db: &dyn DefDatabase,\n-    prefix: Option<ModPath>,\n-    tree: ast::UseTree,\n-    hygiene: &Hygiene,\n-    cb: &mut dyn FnMut(ModPath, &ast::UseTree, bool, Option<ImportAlias>),\n-) {\n-    if let Some(use_tree_list) = tree.use_tree_list() {\n-        let prefix = match tree.path() {\n-            // E.g. use something::{{{inner}}};\n-            None => prefix,\n-            // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n-            // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n-            Some(path) => match convert_path(db, prefix, path, hygiene) {\n-                Some(it) => Some(it),\n-                None => return, // FIXME: report errors somewhere\n-            },\n-        };\n-        for child_tree in use_tree_list.use_trees() {\n-            lower_use_tree(db, prefix.clone(), child_tree, hygiene, cb);\n-        }\n-    } else {\n-        let alias = tree.rename().map(|a| {\n-            a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n-        });\n-        let is_glob = tree.star_token().is_some();\n-        if let Some(ast_path) = tree.path() {\n-            // Handle self in a path.\n-            // E.g. `use something::{self, <...>}`\n-            if ast_path.qualifier().is_none() {\n-                if let Some(segment) = ast_path.segment() {\n-                    if segment.kind() == Some(ast::PathSegmentKind::SelfKw) {\n-                        if let Some(prefix) = prefix {\n-                            cb(prefix, &tree, false, alias);\n-                            return;\n-                        }\n-                    }\n-                }\n-            }\n-            if let Some(path) = convert_path(db, prefix, ast_path, hygiene) {\n-                cb(path, &tree, is_glob, alias)\n-            }\n-        // FIXME: report errors somewhere\n-        // We get here if we do\n-        } else if is_glob {\n-            cov_mark::hit!(glob_enum_group);\n-            if let Some(prefix) = prefix {\n-                cb(prefix, &tree, is_glob, None)\n-            }\n-        }\n-    }\n-}\n-\n-fn convert_path(\n+pub(crate) fn convert_path(\n     db: &dyn DefDatabase,\n     prefix: Option<ModPath>,\n     path: ast::Path,\n@@ -78,7 +25,7 @@ fn convert_path(\n     };\n \n     let segment = path.segment()?;\n-    let res = match segment.kind()? {\n+    let mut mod_path = match segment.kind()? {\n         ast::PathSegmentKind::Name(name_ref) => {\n             match hygiene.name_ref_to_name(db.upcast(), name_ref) {\n                 Either::Left(name) => {\n@@ -125,5 +72,18 @@ fn convert_path(\n             return None;\n         }\n     };\n-    Some(res)\n+\n+    // handle local_inner_macros :\n+    // Basically, even in rustc it is quite hacky:\n+    // https://github.com/rust-lang/rust/blob/614f273e9388ddd7804d5cbc80b8865068a3744e/src/librustc_resolve/macros.rs#L456\n+    // We follow what it did anyway :)\n+    if mod_path.segments.len() == 1 && mod_path.kind == PathKind::Plain {\n+        if let Some(_macro_call) = path.syntax().parent().and_then(ast::MacroCall::cast) {\n+            if let Some(crate_id) = hygiene.local_inner_macros(db.upcast(), path) {\n+                mod_path.kind = PathKind::DollarCrate(crate_id);\n+            }\n+        }\n+    }\n+\n+    Some(mod_path)\n }"}, {"sha": "a9c1e13e2f180e3e46bdcfe6ca059f38fa8d4a21", "filename": "crates/hir_def/src/test_db.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftest_db.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -278,9 +278,11 @@ impl TestDB {\n                         let node = ast.to_node(self.upcast());\n                         (InFile::new(ast.file_id, node.syntax().clone()), \"UnresolvedExternCrate\")\n                     }\n-                    DefDiagnosticKind::UnresolvedImport { ast, .. } => {\n-                        let node = ast.to_node(self.upcast());\n-                        (InFile::new(ast.file_id, node.syntax().clone()), \"UnresolvedImport\")\n+                    DefDiagnosticKind::UnresolvedImport { id, .. } => {\n+                        let item_tree = id.item_tree(self.upcast());\n+                        let import = &item_tree[id.value];\n+                        let node = InFile::new(id.file_id(), import.ast_id).to_node(self.upcast());\n+                        (InFile::new(id.file_id(), node.syntax().clone()), \"UnresolvedImport\")\n                     }\n                     DefDiagnosticKind::UnconfiguredCode { ast, .. } => {\n                         let node = ast.to_node(self.upcast());"}, {"sha": "6cf5810fa4d205ad7ca4b567b5896c05624f02c0", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52df9187730abbcd9cbb132f7d184c74b9a3b7f/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=b52df9187730abbcd9cbb132f7d184c74b9a3b7f", "patch": "@@ -311,6 +311,7 @@ mod tests {\n     ///  * a diagnostic is produced\n     ///  * the first diagnostic fix trigger range touches the input cursor position\n     ///  * that the contents of the file containing the cursor match `after` after the diagnostic fix is applied\n+    #[track_caller]\n     pub(crate) fn check_fix(ra_fixture_before: &str, ra_fixture_after: &str) {\n         check_nth_fix(0, ra_fixture_before, ra_fixture_after);\n     }\n@@ -325,6 +326,7 @@ mod tests {\n         }\n     }\n \n+    #[track_caller]\n     fn check_nth_fix(nth: usize, ra_fixture_before: &str, ra_fixture_after: &str) {\n         let after = trim_indent(ra_fixture_after);\n "}]}