{"sha": "b16fbe79ac29fc5ce604c89736352ca2765c7d78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNmZiZTc5YWMyOWZjNWNlNjA0Yzg5NzM2MzUyY2EyNzY1YzdkNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-30T10:16:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-30T10:16:55Z"}, "message": "Auto merge of #30843 - jseyfried:no_per_ns, r=nikomatsakis\n\nThis commit refactors the field `Module::children` from mapping `Name` -> `NameBindings` to mapping `(Name, Namespace)` -> `NameBinding` and refactors the field `Module::import_resolutions` from mapping `Name` -> `ImportResolutionPerNamespace` to mapping `(Name, Namespace)` -> `ImportResolution`.\n\nThis allows the duplicate checking code to be refactored so that `NameBinding` no longer needs ref-counting or a RefCell (removing the need for `NsDef`).\n\nr? @nikomatsakis", "tree": {"sha": "8e6c4556c72cc75c8cdff93856e992f02ed8c308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e6c4556c72cc75c8cdff93856e992f02ed8c308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b16fbe79ac29fc5ce604c89736352ca2765c7d78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b16fbe79ac29fc5ce604c89736352ca2765c7d78", "html_url": "https://github.com/rust-lang/rust/commit/b16fbe79ac29fc5ce604c89736352ca2765c7d78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b16fbe79ac29fc5ce604c89736352ca2765c7d78/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef1a13b6371bcebc15c850ab82f14688d994fd25", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef1a13b6371bcebc15c850ab82f14688d994fd25", "html_url": "https://github.com/rust-lang/rust/commit/ef1a13b6371bcebc15c850ab82f14688d994fd25"}, {"sha": "afd42d21442db92492799f65e22e024e1e2b1011", "url": "https://api.github.com/repos/rust-lang/rust/commits/afd42d21442db92492799f65e22e024e1e2b1011", "html_url": "https://github.com/rust-lang/rust/commit/afd42d21442db92492799f65e22e024e1e2b1011"}], "stats": {"total": 1355, "additions": 451, "deletions": 904}, "files": [{"sha": "a1d866fc48be4552a7a3d0d148231af29d0a1fe9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 110, "deletions": 244, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/b16fbe79ac29fc5ce604c89736352ca2765c7d78/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16fbe79ac29fc5ce604c89736352ca2765c7d78/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b16fbe79ac29fc5ce604c89736352ca2765c7d78", "patch": "@@ -16,18 +16,16 @@\n use DefModifiers;\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n-use resolve_imports::{ImportResolution, ImportResolutionPerNamespace};\n+use resolve_imports::ImportResolution;\n use Module;\n-use Namespace::{TypeNS, ValueNS};\n-use NameBindings;\n+use Namespace::{self, TypeNS, ValueNS};\n+use {NameBinding, DefOrModule};\n use {names_to_string, module_to_string};\n use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n use resolve_imports::Shadowable;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use self::DuplicateCheckingMode::*;\n-\n use rustc::middle::cstore::{CrateStore, ChildItem, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n@@ -54,16 +52,6 @@ use rustc_front::intravisit::{self, Visitor};\n use std::mem::replace;\n use std::ops::{Deref, DerefMut};\n \n-// Specifies how duplicates should be handled when adding a child item if\n-// another item exists with the same name in some namespace.\n-#[derive(Copy, Clone, PartialEq)]\n-enum DuplicateCheckingMode {\n-    ForbidDuplicateTypes,\n-    ForbidDuplicateValues,\n-    ForbidDuplicateTypesAndValues,\n-    OverwriteDuplicates,\n-}\n-\n struct GraphBuilder<'a, 'b: 'a, 'tcx: 'b> {\n     resolver: &'a mut Resolver<'b, 'tcx>,\n }\n@@ -82,6 +70,23 @@ impl<'a, 'b:'a, 'tcx:'b> DerefMut for GraphBuilder<'a, 'b, 'tcx> {\n     }\n }\n \n+trait ToNameBinding<'a> {\n+    fn to_name_binding(self) -> NameBinding<'a>;\n+}\n+\n+impl<'a> ToNameBinding<'a> for (Module<'a>, Span) {\n+    fn to_name_binding(self) -> NameBinding<'a> {\n+        NameBinding::create_from_module(self.0, Some(self.1))\n+    }\n+}\n+\n+impl<'a> ToNameBinding<'a> for (Def, Span, DefModifiers) {\n+    fn to_name_binding(self) -> NameBinding<'a> {\n+        let def = DefOrModule::Def(self.0);\n+        NameBinding { modifiers: self.2, def_or_module: def, span: Some(self.1) }\n+    }\n+}\n+\n impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Constructs the reduced graph for the entire crate.\n     fn build_reduced_graph(self, krate: &hir::Crate) {\n@@ -92,63 +97,30 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         intravisit::walk_crate(&mut visitor, krate);\n     }\n \n-    /// Adds a new child item to the module definition of the parent node,\n-    /// or if there is already a child, does duplicate checking on the child.\n-    /// Returns the child's corresponding name bindings.\n-    fn add_child(&self,\n-                 name: Name,\n-                 parent: Module<'b>,\n-                 duplicate_checking_mode: DuplicateCheckingMode,\n-                 // For printing errors\n-                 sp: Span)\n-                 -> NameBindings<'b> {\n-        self.check_for_conflicts_between_external_crates_and_items(parent, name, sp);\n-\n-        // Add or reuse the child.\n-        let child = parent.children.borrow().get(&name).cloned();\n-        match child {\n-            None => {\n-                let child = NameBindings::new();\n-                parent.children.borrow_mut().insert(name, child.clone());\n-                child\n-            }\n-            Some(child) => {\n-                // Enforce the duplicate checking mode:\n-                //\n-                // * If we're requesting duplicate type checking, check that\n-                //   the name isn't defined in the type namespace.\n-                //\n-                // * If we're requesting duplicate value checking, check that\n-                //   the name isn't defined in the value namespace.\n-                //\n-                // * If we're requesting duplicate type and value checking,\n-                //   check that the name isn't defined in either namespace.\n-                //\n-                // * If no duplicate checking was requested at all, do\n-                //   nothing.\n-\n-                let ns = match duplicate_checking_mode {\n-                    ForbidDuplicateTypes if child.type_ns.defined() => TypeNS,\n-                    ForbidDuplicateValues if child.value_ns.defined() => ValueNS,\n-                    ForbidDuplicateTypesAndValues if child.type_ns.defined() => TypeNS,\n-                    ForbidDuplicateTypesAndValues if child.value_ns.defined() => ValueNS,\n-                    _ => return child,\n-                };\n-\n-                // Record an error here by looking up the namespace that had the duplicate\n-                let ns_str = match ns { TypeNS => \"type or module\", ValueNS => \"value\" };\n-                let mut err = resolve_struct_error(self,\n-                                                   sp,\n-                                                   ResolutionError::DuplicateDefinition(ns_str,\n-                                                                                        name));\n+    /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined.\n+    fn try_define<T>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n+        where T: ToNameBinding<'b>\n+    {\n+        parent.try_define_child(name, ns, def.to_name_binding());\n+    }\n \n-                if let Some(sp) = child[ns].span() {\n-                    let note = format!(\"first definition of {} `{}` here\", ns_str, name);\n-                    err.span_note(sp, &note);\n-                }\n-                err.emit();\n-                child\n+    /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n+    /// otherwise, reports an error.\n+    fn define<T: ToNameBinding<'b>>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T) {\n+        let name_binding = def.to_name_binding();\n+        let span = name_binding.span.unwrap_or(DUMMY_SP);\n+        self.check_for_conflicts_between_external_crates_and_items(&parent, name, span);\n+        if !parent.try_define_child(name, ns, name_binding) {\n+            // Record an error here by looking up the namespace that had the duplicate\n+            let ns_str = match ns { TypeNS => \"type or module\", ValueNS => \"value\" };\n+            let resolution_error = ResolutionError::DuplicateDefinition(ns_str, name);\n+            let mut err = resolve_struct_error(self, span, resolution_error);\n+\n+            if let Some(sp) = parent.children.borrow().get(&(name, ns)).unwrap().span {\n+                let note = format!(\"first definition of {} `{}` here\", ns_str, name);\n+                err.span_note(sp, &note);\n             }\n+            err.emit();\n         }\n     }\n \n@@ -331,64 +303,47 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n \n             ItemMod(..) => {\n-                let name_bindings = self.add_child(name, parent, ForbidDuplicateTypes, sp);\n-\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Mod(self.ast_map.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false, is_public);\n-                name_bindings.define_module(module.clone(), sp);\n+                self.define(parent, name, TypeNS, (module, sp));\n                 module\n             }\n \n             ItemForeignMod(..) => parent,\n \n             // These items live in the value namespace.\n             ItemStatic(_, m, _) => {\n-                let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n                 let mutbl = m == hir::MutMutable;\n-\n-                name_bindings.define_value(Def::Static(self.ast_map.local_def_id(item.id), mutbl),\n-                                           sp,\n-                                           modifiers);\n+                let def = Def::Static(self.ast_map.local_def_id(item.id), mutbl);\n+                self.define(parent, name, ValueNS, (def, sp, modifiers));\n                 parent\n             }\n             ItemConst(_, _) => {\n-                self.add_child(name, parent, ForbidDuplicateValues, sp)\n-                    .define_value(Def::Const(self.ast_map.local_def_id(item.id)), sp, modifiers);\n+                let def = Def::Const(self.ast_map.local_def_id(item.id));\n+                self.define(parent, name, ValueNS, (def, sp, modifiers));\n                 parent\n             }\n             ItemFn(_, _, _, _, _, _) => {\n-                let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n-\n                 let def = Def::Fn(self.ast_map.local_def_id(item.id));\n-                name_bindings.define_value(def, sp, modifiers);\n+                self.define(parent, name, ValueNS, (def, sp, modifiers));\n                 parent\n             }\n \n             // These items live in the type namespace.\n             ItemTy(..) => {\n-                let name_bindings = self.add_child(name,\n-                                                   parent,\n-                                                   ForbidDuplicateTypes,\n-                                                   sp);\n-\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::TyAlias(self.ast_map.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false, is_public);\n-                name_bindings.define_module(module, sp);\n+                self.define(parent, name, TypeNS, (module, sp));\n                 parent\n             }\n \n             ItemEnum(ref enum_definition, _) => {\n-                let name_bindings = self.add_child(name,\n-                                                   parent,\n-                                                   ForbidDuplicateTypes,\n-                                                   sp);\n-\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Enum(self.ast_map.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false, is_public);\n-                name_bindings.define_module(module.clone(), sp);\n+                self.define(parent, name, TypeNS, (module, sp));\n \n                 let variant_modifiers = if is_public {\n                     DefModifiers::empty()\n@@ -405,26 +360,15 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n             // These items live in both the type and value namespaces.\n             ItemStruct(ref struct_def, _) => {\n-                // Adding to both Type and Value namespaces or just Type?\n-                let (forbid, ctor_id) = if struct_def.is_struct() {\n-                    (ForbidDuplicateTypes, None)\n-                } else {\n-                    (ForbidDuplicateTypesAndValues, Some(struct_def.id()))\n-                };\n-\n-                let name_bindings = self.add_child(name, parent, forbid, sp);\n-\n                 // Define a name in the type namespace.\n-                name_bindings.define_type(Def::Struct(self.ast_map.local_def_id(item.id)),\n-                                          sp,\n-                                          modifiers);\n+                let def = Def::Struct(self.ast_map.local_def_id(item.id));\n+                self.define(parent, name, TypeNS, (def, sp, modifiers));\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n-                if let Some(cid) = ctor_id {\n-                    name_bindings.define_value(Def::Struct(self.ast_map.local_def_id(cid)),\n-                                               sp,\n-                                               modifiers);\n+                if !struct_def.is_struct() {\n+                    let def = Def::Struct(self.ast_map.local_def_id(struct_def.id()));\n+                    self.define(parent, name, ValueNS, (def, sp, modifiers));\n                 }\n \n                 // Record the def ID and fields of this struct.\n@@ -447,48 +391,27 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemImpl(..) => parent,\n \n             ItemTrait(_, _, _, ref items) => {\n-                let name_bindings = self.add_child(name,\n-                                                   parent,\n-                                                   ForbidDuplicateTypes,\n-                                                   sp);\n-\n                 let def_id = self.ast_map.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Trait(def_id);\n                 let module_parent = self.new_module(parent_link, Some(def), false, is_public);\n-                name_bindings.define_module(module_parent.clone(), sp);\n+                self.define(parent, name, TypeNS, (module_parent, sp));\n \n                 // Add the names of all the items to the trait info.\n-                for trait_item in items {\n-                    let name_bindings = self.add_child(trait_item.name,\n-                                                       &module_parent,\n-                                                       ForbidDuplicateTypesAndValues,\n-                                                       trait_item.span);\n-\n-                    match trait_item.node {\n-                        hir::ConstTraitItem(..) => {\n-                            let def = Def::AssociatedConst(self.ast_map.\n-                                                                local_def_id(trait_item.id));\n-                            // NB: not DefModifiers::IMPORTABLE\n-                            name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n-                        }\n-                        hir::MethodTraitItem(..) => {\n-                            let def = Def::Method(self.ast_map.local_def_id(trait_item.id));\n-                            // NB: not DefModifiers::IMPORTABLE\n-                            name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n-                        }\n-                        hir::TypeTraitItem(..) => {\n-                            let def = Def::AssociatedTy(self.ast_map.local_def_id(item.id),\n-                                                      self.ast_map.local_def_id(trait_item.id));\n-                            // NB: not DefModifiers::IMPORTABLE\n-                            name_bindings.define_type(def, trait_item.span, DefModifiers::PUBLIC);\n-                        }\n-                    }\n+                for item in items {\n+                    let item_def_id = self.ast_map.local_def_id(item.id);\n+                    let (def, ns) = match item.node {\n+                        hir::ConstTraitItem(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n+                        hir::MethodTraitItem(..) => (Def::Method(item_def_id), ValueNS),\n+                        hir::TypeTraitItem(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n+                    };\n \n-                    let trait_item_def_id = self.ast_map.local_def_id(trait_item.id);\n-                    self.trait_item_map.insert((trait_item.name, def_id), trait_item_def_id);\n+                    let modifiers = DefModifiers::PUBLIC; // NB: not DefModifiers::IMPORTABLE\n+                    self.define(&module_parent, item.name, ns, (def, item.span, modifiers));\n+\n+                    self.trait_item_map.insert((item.name, def_id), item_def_id);\n                 }\n \n                 parent\n@@ -512,13 +435,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         // Variants are always treated as importable to allow them to be glob used.\n         // All variants are defined in both type and value namespaces as future-proofing.\n-        let child = self.add_child(name, parent, ForbidDuplicateTypesAndValues, variant.span);\n-        child.define_value(Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id())),\n-                           variant.span,\n-                           DefModifiers::PUBLIC | DefModifiers::IMPORTABLE | variant_modifiers);\n-        child.define_type(Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id())),\n-                          variant.span,\n-                          DefModifiers::PUBLIC | DefModifiers::IMPORTABLE | variant_modifiers);\n+        let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE | variant_modifiers;\n+        let def = Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id()));\n+\n+        self.define(parent, name, ValueNS, (def, variant.span, modifiers));\n+        self.define(parent, name, TypeNS, (def, variant.span, modifiers));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n@@ -532,7 +453,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         } else {\n             DefModifiers::empty()\n         } | DefModifiers::IMPORTABLE;\n-        let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, foreign_item.span);\n \n         let def = match foreign_item.node {\n             ForeignItemFn(..) => {\n@@ -542,7 +462,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 Def::Static(self.ast_map.local_def_id(foreign_item.id), m)\n             }\n         };\n-        name_bindings.define_value(def, foreign_item.span, modifiers);\n+        self.define(parent, name, ValueNS, (def, foreign_item.span, modifiers));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block, parent: Module<'b>) -> Module<'b> {\n@@ -565,19 +485,22 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     fn handle_external_def(&mut self,\n                            def: Def,\n                            vis: Visibility,\n-                           child_name_bindings: &NameBindings<'b>,\n                            final_ident: &str,\n                            name: Name,\n                            new_parent: Module<'b>) {\n         debug!(\"(building reduced graph for external crate) building external def {}, priv {:?}\",\n                final_ident,\n                vis);\n         let is_public = vis == hir::Public;\n-        let modifiers = if is_public {\n-            DefModifiers::PUBLIC\n-        } else {\n-            DefModifiers::empty()\n-        } | DefModifiers::IMPORTABLE;\n+\n+        let mut modifiers = DefModifiers::empty();\n+        if is_public {\n+            modifiers = modifiers | DefModifiers::PUBLIC;\n+        }\n+        if new_parent.is_normal() {\n+            modifiers = modifiers | DefModifiers::IMPORTABLE;\n+        }\n+\n         let is_exported = is_public &&\n                           match new_parent.def_id() {\n             None => true,\n@@ -586,43 +509,24 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         if is_exported {\n             self.external_exports.insert(def.def_id());\n         }\n-        let is_struct_ctor = if let Def::Struct(def_id) = def {\n-            self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_some()\n-        } else {\n-            false\n-        };\n \n         match def {\n-            Def::Mod(_) |\n-            Def::ForeignMod(_) |\n-            Def::Struct(..) |\n-            Def::Enum(..) |\n-            Def::TyAlias(..) if !is_struct_ctor => {\n-                if let Some(module_def) = child_name_bindings.type_ns.module() {\n-                    debug!(\"(building reduced graph for external crate) already created module\");\n-                    module_def.def.set(Some(def));\n-                } else {\n-                    debug!(\"(building reduced graph for external crate) building module {} {}\",\n-                           final_ident,\n-                           is_public);\n-                    let parent_link = ModuleParentLink(new_parent, name);\n-                    let module = self.new_module(parent_link, Some(def), true, is_public);\n-                    child_name_bindings.define_module(module, DUMMY_SP);\n-                }\n+            Def::Mod(_) | Def::ForeignMod(_) | Def::Enum(..) | Def::TyAlias(..) => {\n+                debug!(\"(building reduced graph for external crate) building module {} {}\",\n+                       final_ident,\n+                       is_public);\n+                let parent_link = ModuleParentLink(new_parent, name);\n+                let module = self.new_module(parent_link, Some(def), true, is_public);\n+                self.try_define(new_parent, name, TypeNS, (module, DUMMY_SP));\n             }\n-            _ => {}\n-        }\n-\n-        match def {\n-            Def::Mod(_) | Def::ForeignMod(_) => {}\n             Def::Variant(_, variant_id) => {\n                 debug!(\"(building reduced graph for external crate) building variant {}\",\n                        final_ident);\n                 // Variants are always treated as importable to allow them to be glob used.\n                 // All variants are defined in both type and value namespaces as future-proofing.\n                 let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE;\n-                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-                child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n+                self.try_define(new_parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n+                self.try_define(new_parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n                 if self.session.cstore.variant_kind(variant_id) == Some(VariantKind::Struct) {\n                     // Not adding fields for variants as they are not accessed with a self receiver\n                     self.structs.insert(variant_id, Vec::new());\n@@ -635,17 +539,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             Def::Method(..) => {\n                 debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n                        final_ident);\n-                // impl methods have already been defined with the correct importability\n-                // modifier\n-                let mut modifiers = match *child_name_bindings.value_ns.borrow() {\n-                    Some(ref def) => (modifiers & !DefModifiers::IMPORTABLE) |\n-                                     (def.modifiers & DefModifiers::IMPORTABLE),\n-                    None => modifiers,\n-                };\n-                if !new_parent.is_normal() {\n-                    modifiers = modifiers & !DefModifiers::IMPORTABLE;\n-                }\n-                child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n+                self.try_define(new_parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n             }\n             Def::Trait(def_id) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\",\n@@ -670,45 +564,31 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     }\n                 }\n \n-                // Define a module if necessary.\n                 let parent_link = ModuleParentLink(new_parent, name);\n                 let module = self.new_module(parent_link, Some(def), true, is_public);\n-                child_name_bindings.define_module(module, DUMMY_SP);\n+                self.try_define(new_parent, name, TypeNS, (module, DUMMY_SP));\n             }\n-            Def::Enum(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => {\n+            Def::AssociatedTy(..) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\",\n                        final_ident);\n-\n-                let modifiers = match new_parent.is_normal() {\n-                    true => modifiers,\n-                    _ => modifiers & !DefModifiers::IMPORTABLE,\n-                };\n-\n-                if let Def::Enum(..) = def {\n-                    child_name_bindings.type_ns.set_modifiers(modifiers);\n-                } else if let Def::TyAlias(..) = def {\n-                    child_name_bindings.type_ns.set_modifiers(modifiers);\n-                } else {\n-                    child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-                }\n+                self.try_define(new_parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n             }\n-            Def::Struct(..) if is_struct_ctor => {\n-                // Do nothing\n-            }\n-            Def::Struct(def_id) => {\n+            Def::Struct(def_id)\n+                if self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_none() => {\n                 debug!(\"(building reduced graph for external crate) building type and value for \\\n                         {}\",\n                        final_ident);\n-\n-                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+                self.try_define(new_parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n                 if let Some(ctor_def_id) = self.session.cstore.struct_ctor_def_id(def_id) {\n-                    child_name_bindings.define_value(Def::Struct(ctor_def_id), DUMMY_SP, modifiers);\n+                    let def = Def::Struct(ctor_def_id);\n+                    self.try_define(new_parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n                 }\n \n                 // Record the def ID and fields of this struct.\n                 let fields = self.session.cstore.struct_field_names(def_id);\n                 self.structs.insert(def_id, fields);\n             }\n+            Def::Struct(..) => {}\n             Def::Local(..) |\n             Def::PrimTy(..) |\n             Def::TyParam(..) |\n@@ -737,14 +617,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         }\n                     }\n                     _ => {\n-                        let child_name_bindings = self.add_child(xcdef.name,\n-                                                                 root,\n-                                                                 OverwriteDuplicates,\n-                                                                 DUMMY_SP);\n-\n                         self.handle_external_def(def,\n                                                  xcdef.vis,\n-                                                 &child_name_bindings,\n                                                  &xcdef.name.as_str(),\n                                                  xcdef.name,\n                                                  root);\n@@ -827,24 +701,16 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                        target);\n \n                 let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-                match import_resolutions.get_mut(&target) {\n-                    Some(resolution_per_ns) => {\n-                        debug!(\"(building import directive) bumping reference\");\n-                        resolution_per_ns.outstanding_references += 1;\n-\n-                        // the source of this name is different now\n-                        let resolution =\n-                            ImportResolution { id: id, is_public: is_public, target: None };\n-                        resolution_per_ns[TypeNS] = resolution.clone();\n-                        resolution_per_ns[ValueNS] = resolution;\n-                        return;\n-                    }\n-                    None => {}\n+                for &ns in [TypeNS, ValueNS].iter() {\n+                    let mut resolution = import_resolutions.entry((target, ns)).or_insert(\n+                        ImportResolution::new(id, is_public)\n+                    );\n+\n+                    resolution.outstanding_references += 1;\n+                    // the source of this name is different now\n+                    resolution.id = id;\n+                    resolution.is_public = is_public;\n                 }\n-                debug!(\"(building import directive) creating new\");\n-                let mut import_resolution_per_ns = ImportResolutionPerNamespace::new(id, is_public);\n-                import_resolution_per_ns.outstanding_references = 1;\n-                import_resolutions.insert(target, import_resolution_per_ns);\n             }\n             GlobImport => {\n                 // Set the glob flag. This tells us that we don't know the"}, {"sha": "6c78f98c0cb0d6500290a5d64246cbbf4cc83894", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 69, "deletions": 258, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/b16fbe79ac29fc5ce604c89736352ca2765c7d78/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16fbe79ac29fc5ce604c89736352ca2765c7d78/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b16fbe79ac29fc5ce604c89736352ca2765c7d78", "patch": "@@ -36,7 +36,6 @@ extern crate rustc;\n \n use self::PatternBindingMode::*;\n use self::Namespace::*;\n-use self::NamespaceResult::*;\n use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n@@ -87,13 +86,12 @@ use rustc_front::hir::{TraitRef, Ty, TyBool, TyChar, TyFloat, TyInt};\n use rustc_front::hir::{TyRptr, TyStr, TyUint, TyPath, TyPtr};\n use rustc_front::util::walk_pat;\n \n-use std::collections::{HashMap, HashSet};\n+use std::collections::{hash_map, HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n-use std::rc::Rc;\n \n-use resolve_imports::{Target, ImportDirective, ImportResolutionPerNamespace};\n+use resolve_imports::{Target, ImportDirective, ImportResolution};\n use resolve_imports::Shadowable;\n \n // NB: This module needs to be declared first so diagnostics are\n@@ -357,8 +355,8 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n             if let Some(directive) = resolver.current_module\n                                              .import_resolutions\n                                              .borrow()\n-                                             .get(&name) {\n-                let item = resolver.ast_map.expect_item(directive.value_ns.id);\n+                                             .get(&(name, ValueNS)) {\n+                let item = resolver.ast_map.expect_item(directive.id);\n                 err.span_note(item.span, \"constant imported here\");\n             }\n             err\n@@ -572,38 +570,6 @@ pub enum Namespace {\n     ValueNS,\n }\n \n-/// A NamespaceResult represents the result of resolving an import in\n-/// a particular namespace. The result is either definitely-resolved,\n-/// definitely- unresolved, or unknown.\n-#[derive(Clone)]\n-enum NamespaceResult<'a> {\n-    /// Means that resolve hasn't gathered enough information yet to determine\n-    /// whether the name is bound in this namespace. (That is, it hasn't\n-    /// resolved all `use` directives yet.)\n-    UnknownResult,\n-    /// Means that resolve has determined that the name is definitely\n-    /// not bound in the namespace.\n-    UnboundResult,\n-    /// Means that resolve has determined that the name is bound in the Module\n-    /// argument, and specified by the NameBinding argument.\n-    BoundResult(Module<'a>, NameBinding<'a>),\n-}\n-\n-impl<'a> NamespaceResult<'a> {\n-    fn is_unknown(&self) -> bool {\n-        match *self {\n-            UnknownResult => true,\n-            _ => false,\n-        }\n-    }\n-    fn is_unbound(&self) -> bool {\n-        match *self {\n-            UnboundResult => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n         self.visit_item(self.ast_map.expect_item(item.id))\n@@ -698,6 +664,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n \n type ErrorMessage = Option<(Span, String)>;\n \n+#[derive(Clone, PartialEq, Eq)]\n enum ResolveResult<T> {\n     Failed(ErrorMessage), // Failed to resolve the name, optional helpful error message.\n     Indeterminate, // Couldn't determine due to unresolved globs.\n@@ -835,7 +802,7 @@ pub struct ModuleS<'a> {\n     def: Cell<Option<Def>>,\n     is_public: bool,\n \n-    children: RefCell<HashMap<Name, NameBindings<'a>>>,\n+    children: RefCell<HashMap<(Name, Namespace), NameBinding<'a>>>,\n     imports: RefCell<Vec<ImportDirective>>,\n \n     // The external module children of this node that were declared with\n@@ -859,7 +826,7 @@ pub struct ModuleS<'a> {\n     anonymous_children: RefCell<NodeMap<Module<'a>>>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: RefCell<HashMap<Name, ImportResolutionPerNamespace<'a>>>,\n+    import_resolutions: RefCell<HashMap<(Name, Namespace), ImportResolution<'a>>>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: Cell<usize>,\n@@ -900,6 +867,17 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n+    fn get_child(&self, name: Name, ns: Namespace) -> Option<NameBinding<'a>> {\n+        self.children.borrow().get(&(name, ns)).cloned()\n+    }\n+\n+    fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>) -> bool {\n+        match self.children.borrow_mut().entry((name, ns)) {\n+            hash_map::Entry::Vacant(entry) => { entry.insert(binding); true }\n+            hash_map::Entry::Occupied(_) => false,\n+        }\n+    }\n+\n     fn def_id(&self) -> Option<DefId> {\n         self.def.get().as_ref().map(Def::def_id)\n     }\n@@ -977,32 +955,28 @@ bitflags! {\n }\n \n // Records a possibly-private value, type, or module definition.\n-#[derive(Debug)]\n-struct NsDef<'a> {\n-    modifiers: DefModifiers, // see note in ImportResolutionPerNamespace about how to use this\n+#[derive(Clone, Debug)]\n+pub struct NameBinding<'a> {\n+    modifiers: DefModifiers, // see note in ImportResolution about how to use this\n     def_or_module: DefOrModule<'a>,\n     span: Option<Span>,\n }\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n enum DefOrModule<'a> {\n     Def(Def),\n     Module(Module<'a>),\n }\n \n-impl<'a> NsDef<'a> {\n+impl<'a> NameBinding<'a> {\n     fn create_from_module(module: Module<'a>, span: Option<Span>) -> Self {\n         let modifiers = if module.is_public {\n             DefModifiers::PUBLIC\n         } else {\n             DefModifiers::empty()\n         } | DefModifiers::IMPORTABLE;\n \n-        NsDef { modifiers: modifiers, def_or_module: DefOrModule::Module(module), span: span }\n-    }\n-\n-    fn create_from_def(def: Def, modifiers: DefModifiers, span: Option<Span>) -> Self {\n-        NsDef { modifiers: modifiers, def_or_module: DefOrModule::Def(def), span: span }\n+        NameBinding { modifiers: modifiers, def_or_module: DefOrModule::Module(module), span: span }\n     }\n \n     fn module(&self) -> Option<Module<'a>> {\n@@ -1018,55 +992,9 @@ impl<'a> NsDef<'a> {\n             DefOrModule::Module(ref module) => module.def.get(),\n         }\n     }\n-}\n-\n-// Records at most one definition that a name in a namespace is bound to\n-#[derive(Clone,Debug)]\n-pub struct NameBinding<'a>(Rc<RefCell<Option<NsDef<'a>>>>);\n-\n-impl<'a> NameBinding<'a> {\n-    fn new() -> Self {\n-        NameBinding(Rc::new(RefCell::new(None)))\n-    }\n-\n-    fn create_from_module(module: Module<'a>) -> Self {\n-        NameBinding(Rc::new(RefCell::new(Some(NsDef::create_from_module(module, None)))))\n-    }\n-\n-    fn set(&self, ns_def: NsDef<'a>) {\n-        *self.0.borrow_mut() = Some(ns_def);\n-    }\n-\n-    fn set_modifiers(&self, modifiers: DefModifiers) {\n-        if let Some(ref mut ns_def) = *self.0.borrow_mut() {\n-            ns_def.modifiers = modifiers\n-        }\n-    }\n-\n-    fn borrow(&self) -> ::std::cell::Ref<Option<NsDef<'a>>> {\n-        self.0.borrow()\n-    }\n-\n-    // Lifted versions of the NsDef methods and fields\n-    fn def(&self) -> Option<Def> {\n-        self.borrow().as_ref().and_then(NsDef::def)\n-    }\n-    fn module(&self) -> Option<Module<'a>> {\n-        self.borrow().as_ref().and_then(NsDef::module)\n-    }\n-    fn span(&self) -> Option<Span> {\n-        self.borrow().as_ref().and_then(|def| def.span)\n-    }\n-    fn modifiers(&self) -> Option<DefModifiers> {\n-        self.borrow().as_ref().and_then(|def| Some(def.modifiers))\n-    }\n-\n-    fn defined(&self) -> bool {\n-        self.borrow().is_some()\n-    }\n \n     fn defined_with(&self, modifiers: DefModifiers) -> bool {\n-        self.modifiers().map(|m| m.contains(modifiers)).unwrap_or(false)\n+        self.modifiers.contains(modifiers)\n     }\n \n     fn is_public(&self) -> bool {\n@@ -1079,47 +1007,6 @@ impl<'a> NameBinding<'a> {\n     }\n }\n \n-// Records the definitions (at most one for each namespace) that a name is\n-// bound to.\n-#[derive(Clone,Debug)]\n-pub struct NameBindings<'a> {\n-    type_ns: NameBinding<'a>, // < Meaning in type namespace.\n-    value_ns: NameBinding<'a>, // < Meaning in value namespace.\n-}\n-\n-impl<'a> ::std::ops::Index<Namespace> for NameBindings<'a> {\n-    type Output = NameBinding<'a>;\n-    fn index(&self, namespace: Namespace) -> &NameBinding<'a> {\n-        match namespace { TypeNS => &self.type_ns, ValueNS => &self.value_ns }\n-    }\n-}\n-\n-impl<'a> NameBindings<'a> {\n-    fn new() -> Self {\n-        NameBindings {\n-            type_ns: NameBinding::new(),\n-            value_ns: NameBinding::new(),\n-        }\n-    }\n-\n-    /// Creates a new module in this set of name bindings.\n-    fn define_module(&self, module: Module<'a>, sp: Span) {\n-        self.type_ns.set(NsDef::create_from_module(module, Some(sp)));\n-    }\n-\n-    /// Records a type definition.\n-    fn define_type(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining type for def {:?} with modifiers {:?}\", def, modifiers);\n-        self.type_ns.set(NsDef::create_from_def(def, modifiers, Some(sp)));\n-    }\n-\n-    /// Records a value definition.\n-    fn define_value(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining value for def {:?} with modifiers {:?}\", def, modifiers);\n-        self.value_ns.set(NsDef::create_from_def(def, modifiers, Some(sp)));\n-    }\n-}\n-\n /// Interns the names of the primitive types.\n struct PrimitiveTypeTable {\n     primitive_types: HashMap<Name, PrimTy>,\n@@ -1333,13 +1220,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                       \"an external crate named `{}` has already been imported into this module\",\n                       name);\n         }\n-        match module.children.borrow().get(&name) {\n-            Some(name_bindings) if name_bindings.type_ns.defined() => {\n-                resolve_error(self,\n-                              name_bindings.type_ns.span().unwrap_or(codemap::DUMMY_SP),\n-                              ResolutionError::NameConflictsWithExternCrate(name));\n-            }\n-            _ => {},\n+        if let Some(name_binding) = module.get_child(name, TypeNS) {\n+            resolve_error(self,\n+                          name_binding.span.unwrap_or(codemap::DUMMY_SP),\n+                          ResolutionError::NameConflictsWithExternCrate(name));\n         }\n     }\n \n@@ -1562,25 +1446,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // its immediate children.\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n-        match module_.children.borrow().get(&name) {\n-            Some(name_bindings) if name_bindings[namespace].defined() => {\n-                debug!(\"top name bindings succeeded\");\n-                return Success((Target::new(module_,\n-                                            name_bindings[namespace].clone(),\n-                                            Shadowable::Never),\n-                                false));\n-            }\n-            Some(_) | None => {\n-                // Not found; continue.\n-            }\n+        if let Some(binding) = module_.get_child(name, namespace) {\n+            debug!(\"top name bindings succeeded\");\n+            return Success((Target::new(module_, binding, Shadowable::Never), false));\n         }\n \n         // Now check for its import directives. We don't have to have resolved\n         // all its imports in the usual way; this is because chains of\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n-        if let Some(import_resolution) = module_.import_resolutions.borrow().get(&name) {\n-            match import_resolution[namespace].target.clone() {\n+        if let Some(import_resolution) =\n+            module_.import_resolutions.borrow().get(&(name, namespace)) {\n+            match import_resolution.target.clone() {\n                 None => {\n                     // Not found; continue.\n                     debug!(\"(resolving item in lexical scope) found import resolution, but not \\\n@@ -1590,7 +1467,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Some(target) => {\n                     debug!(\"(resolving item in lexical scope) using import resolution\");\n                     // track used imports and extern crates as well\n-                    let id = import_resolution[namespace].id;\n+                    let id = import_resolution.id;\n                     if record_used {\n                         self.used_imports.insert((id, namespace));\n                         self.record_import_use(id, name);\n@@ -1607,7 +1484,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if namespace == TypeNS {\n             let children = module_.external_module_children.borrow();\n             if let Some(module) = children.get(&name) {\n-                let name_binding = NameBinding::create_from_module(module);\n+                let name_binding = NameBinding::create_from_module(module, None);\n                 debug!(\"lower name bindings succeeded\");\n                 return Success((Target::new(module_, name_binding, Shadowable::Never),\n                                 false));\n@@ -1774,40 +1651,27 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // First, check the direct children of the module.\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n-        let children = module_.children.borrow();\n-        match children.get(&name) {\n-            Some(name_bindings) if name_bindings[namespace].defined() => {\n-                debug!(\"(resolving name in module) found node as child\");\n-                return Success((Target::new(module_,\n-                                            name_bindings[namespace].clone(),\n-                                            Shadowable::Never),\n-                                false));\n-            }\n-            Some(_) | None => {\n-                // Continue.\n-            }\n+        if let Some(binding) = module_.get_child(name, namespace) {\n+            debug!(\"(resolving name in module) found node as child\");\n+            return Success((Target::new(module_, binding, Shadowable::Never), false));\n         }\n \n         // Check the list of resolved imports.\n-        let children = module_.import_resolutions.borrow();\n-        match children.get(&name) {\n-            Some(import_resolution) if allow_private_imports ||\n-                                       import_resolution[namespace].is_public => {\n-\n-                if import_resolution[namespace].is_public &&\n-                   import_resolution.outstanding_references != 0 {\n+        match module_.import_resolutions.borrow().get(&(name, namespace)) {\n+            Some(import_resolution) if allow_private_imports || import_resolution.is_public => {\n+                if import_resolution.is_public && import_resolution.outstanding_references != 0 {\n                     debug!(\"(resolving name in module) import unresolved; bailing out\");\n                     return Indeterminate;\n                 }\n-                match import_resolution[namespace].target.clone() {\n+                match import_resolution.target.clone() {\n                     None => {\n                         debug!(\"(resolving name in module) name found, but not in namespace {:?}\",\n                                namespace);\n                     }\n                     Some(target) => {\n                         debug!(\"(resolving name in module) resolved to import\");\n                         // track used imports and extern crates as well\n-                        let id = import_resolution[namespace].id;\n+                        let id = import_resolution.id;\n                         self.used_imports.insert((id, namespace));\n                         self.record_import_use(id, name);\n                         if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n@@ -1824,7 +1688,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if namespace == TypeNS {\n             let children = module_.external_module_children.borrow();\n             if let Some(module) = children.get(&name) {\n-                let name_binding = NameBinding::create_from_module(module);\n+                let name_binding = NameBinding::create_from_module(module, None);\n                 return Success((Target::new(module_, name_binding, Shadowable::Never),\n                                 false));\n             }\n@@ -1849,7 +1713,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         for (_, child_node) in module_.children.borrow().iter() {\n-            match child_node.type_ns.module() {\n+            match child_node.module() {\n                 None => {\n                     // Continue.\n                 }\n@@ -1895,14 +1759,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some(name) => {\n                 build_reduced_graph::populate_module_if_necessary(self, &orig_module);\n \n-                match orig_module.children.borrow().get(&name) {\n+                match orig_module.get_child(name, TypeNS) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n                                name,\n                                module_to_string(&*orig_module));\n                     }\n-                    Some(name_bindings) => {\n-                        match name_bindings.type_ns.module() {\n+                    Some(name_binding) => {\n+                        match name_binding.module() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module for `{}` in `{}`\",\n                                        name,\n@@ -2858,7 +2722,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n                        name,\n-                       target.binding.borrow());\n+                       &target.binding);\n                 match target.binding.def() {\n                     None => {\n                         panic!(\"resolved name in the value namespace to a set of name bindings \\\n@@ -3331,12 +3195,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if name_path.len() == 1 {\n                 match this.primitive_type_table.primitive_types.get(last_name) {\n                     Some(_) => None,\n-                    None => {\n-                        match this.current_module.children.borrow().get(last_name) {\n-                            Some(child) => child.type_ns.module(),\n-                            None => None,\n-                        }\n-                    }\n+                    None => this.current_module.get_child(*last_name, TypeNS)\n+                                               .as_ref()\n+                                               .and_then(NameBinding::module)\n                 }\n             } else {\n                 match this.resolve_module_path(root, &name_path, UseLexicalScope, span) {\n@@ -3395,8 +3256,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Look for a method in the current self type's impl module.\n         if let Some(module) = get_module(self, path.span, &name_path) {\n-            if let Some(binding) = module.children.borrow().get(&name) {\n-                if let Some(Def::Method(did)) = binding.value_ns.def() {\n+            if let Some(binding) = module.get_child(name, ValueNS) {\n+                if let Some(Def::Method(did)) = binding.def() {\n                     if is_static_method(self, did) {\n                         return StaticMethod(path_names_to_string(&path, 0));\n                     }\n@@ -3718,35 +3579,31 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // Look for trait children.\n             build_reduced_graph::populate_module_if_necessary(self, &search_module);\n \n-            {\n-                for (_, child_names) in search_module.children.borrow().iter() {\n-                    let def = match child_names.type_ns.def() {\n-                        Some(def) => def,\n-                        None => continue,\n-                    };\n-                    let trait_def_id = match def {\n-                        Def::Trait(trait_def_id) => trait_def_id,\n-                        _ => continue,\n-                    };\n-                    if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n-                        add_trait_info(&mut found_traits, trait_def_id, name);\n-                    }\n+            for (&(_, ns), name_binding) in search_module.children.borrow().iter() {\n+                if ns != TypeNS { continue }\n+                let trait_def_id = match name_binding.def() {\n+                    Some(Def::Trait(trait_def_id)) => trait_def_id,\n+                    Some(..) | None => continue,\n+                };\n+                if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n+                    add_trait_info(&mut found_traits, trait_def_id, name);\n                 }\n             }\n \n             // Look for imports.\n-            for (_, import) in search_module.import_resolutions.borrow().iter() {\n-                let target = match import.type_ns.target {\n-                    None => continue,\n+            for (&(_, ns), import) in search_module.import_resolutions.borrow().iter() {\n+                if ns != TypeNS { continue }\n+                let target = match import.target {\n                     Some(ref target) => target,\n+                    None => continue,\n                 };\n                 let did = match target.binding.def() {\n                     Some(Def::Trait(trait_def_id)) => trait_def_id,\n                     Some(..) | None => continue,\n                 };\n                 if self.trait_item_map.contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n-                    let id = import.type_ns.id;\n+                    let id = import.id;\n                     self.used_imports.insert((id, TypeNS));\n                     let trait_name = self.get_trait_name(did);\n                     self.record_import_use(id, trait_name);\n@@ -3797,52 +3654,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    //\n-    // Diagnostics\n-    //\n-    // Diagnostics are not particularly efficient, because they're rarely\n-    // hit.\n-    //\n-\n-    #[allow(dead_code)]   // useful for debugging\n-    fn dump_module(&mut self, module_: Module<'a>) {\n-        debug!(\"Dump of module `{}`:\", module_to_string(&*module_));\n-\n-        debug!(\"Children:\");\n-        build_reduced_graph::populate_module_if_necessary(self, &module_);\n-        for (&name, _) in module_.children.borrow().iter() {\n-            debug!(\"* {}\", name);\n-        }\n-\n-        debug!(\"Import resolutions:\");\n-        let import_resolutions = module_.import_resolutions.borrow();\n-        for (&name, import_resolution) in import_resolutions.iter() {\n-            let value_repr;\n-            match import_resolution.value_ns.target {\n-                None => {\n-                    value_repr = \"\".to_string();\n-                }\n-                Some(_) => {\n-                    value_repr = \" value:?\".to_string();\n-                    // FIXME #4954\n-                }\n-            }\n-\n-            let type_repr;\n-            match import_resolution.type_ns.target {\n-                None => {\n-                    type_repr = \"\".to_string();\n-                }\n-                Some(_) => {\n-                    type_repr = \" type:?\".to_string();\n-                    // FIXME #4954\n-                }\n-            }\n-\n-            debug!(\"* {}:{}{}\", name, value_repr, type_repr);\n-        }\n-    }\n }\n \n "}, {"sha": "07f6a0f9549906fd84eedf9aa0096f9619643103", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 272, "deletions": 402, "changes": 674, "blob_url": "https://github.com/rust-lang/rust/blob/b16fbe79ac29fc5ce604c89736352ca2765c7d78/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16fbe79ac29fc5ce604c89736352ca2765c7d78/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b16fbe79ac29fc5ce604c89736352ca2765c7d78", "patch": "@@ -13,10 +13,9 @@ use self::ImportDirectiveSubclass::*;\n use DefModifiers;\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n-use {NameBindings, NameBinding};\n-use NamespaceResult::{BoundResult, UnboundResult, UnknownResult};\n-use NamespaceResult;\n+use NameBinding;\n use ResolveResult;\n+use ResolveResult::*;\n use Resolver;\n use UseLexicalScopeFlag;\n use {names_to_string, module_to_string};\n@@ -100,26 +99,20 @@ impl<'a> Target<'a> {\n }\n \n #[derive(Debug)]\n-/// An ImportResolutionPerNamespace records what we know about an imported name.\n+/// An ImportResolution records what we know about an imported name in a given namespace.\n /// More specifically, it records the number of unresolved `use` directives that import the name,\n-/// and for each namespace, it records the `use` directive importing the name in the namespace\n-/// and the `Target` to which the name in the namespace resolves (if applicable).\n+/// the `use` directive importing the name in the namespace, and the `NameBinding` to which the\n+/// name in the namespace resolves (if applicable).\n /// Different `use` directives may import the same name in different namespaces.\n-pub struct ImportResolutionPerNamespace<'a> {\n+pub struct ImportResolution<'a> {\n     // When outstanding_references reaches zero, outside modules can count on the targets being\n     // correct. Before then, all bets are off; future `use` directives could override the name.\n     // Since shadowing is forbidden, the only way outstanding_references > 1 in a legal program\n     // is if the name is imported by exactly two `use` directives, one of which resolves to a\n     // value and the other of which resolves to a type.\n     pub outstanding_references: usize,\n-    pub type_ns: ImportResolution<'a>,\n-    pub value_ns: ImportResolution<'a>,\n-}\n \n-/// Records what we know about an imported name in a namespace (see `ImportResolutionPerNamespace`).\n-#[derive(Clone,Debug)]\n-pub struct ImportResolution<'a> {\n-    /// Whether the name in the namespace was imported with a `use` or a `pub use`.\n+    /// Whether this resolution came from a `use` or a `pub use`.\n     pub is_public: bool,\n \n     /// Resolution of the name in the namespace\n@@ -129,29 +122,18 @@ pub struct ImportResolution<'a> {\n     pub id: NodeId,\n }\n \n-impl<'a> ::std::ops::Index<Namespace> for ImportResolutionPerNamespace<'a> {\n-    type Output = ImportResolution<'a>;\n-    fn index(&self, ns: Namespace) -> &ImportResolution<'a> {\n-        match ns { TypeNS => &self.type_ns, ValueNS => &self.value_ns }\n-    }\n-}\n-\n-impl<'a> ::std::ops::IndexMut<Namespace> for ImportResolutionPerNamespace<'a> {\n-    fn index_mut(&mut self, ns: Namespace) -> &mut ImportResolution<'a> {\n-        match ns { TypeNS => &mut self.type_ns, ValueNS => &mut self.value_ns }\n-    }\n-}\n-\n-impl<'a> ImportResolutionPerNamespace<'a> {\n+impl<'a> ImportResolution<'a> {\n     pub fn new(id: NodeId, is_public: bool) -> Self {\n-        let resolution = ImportResolution { id: id, is_public: is_public, target: None };\n-        ImportResolutionPerNamespace {\n-            outstanding_references: 0, type_ns: resolution.clone(), value_ns: resolution,\n+        ImportResolution {\n+            outstanding_references: 0,\n+            id: id,\n+            target: None,\n+            is_public: is_public,\n         }\n     }\n \n-    pub fn shadowable(&self, namespace: Namespace) -> Shadowable {\n-        match self[namespace].target {\n+    pub fn shadowable(&self) -> Shadowable {\n+        match self.target {\n             Some(ref target) => target.shadowable,\n             None => Shadowable::Always,\n         }\n@@ -232,7 +214,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n         for (_, child_node) in module_.children.borrow().iter() {\n-            match child_node.type_ns.module() {\n+            match child_node.module() {\n                 None => {\n                     // Nothing to do.\n                 }\n@@ -393,6 +375,80 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         return resolution_result;\n     }\n \n+    /// Resolves the name in the namespace of the module because it is being imported by\n+    /// importing_module. Returns the module in which the name was defined (as opposed to imported),\n+    /// the name bindings defining the name, and whether or not the name was imported into `module`.\n+    fn resolve_name_in_module(&mut self,\n+                              module: Module<'b>, // Module containing the name\n+                              name: Name,\n+                              ns: Namespace,\n+                              importing_module: Module<'b>) // Module importing the name\n+                              -> (ResolveResult<(Module<'b>, NameBinding<'b>)>, bool) {\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, module);\n+        if let Some(name_binding) = module.get_child(name, ns) {\n+            return (Success((module, name_binding)), false);\n+        }\n+\n+        if ns == TypeNS {\n+            if let Some(extern_crate) = module.external_module_children.borrow().get(&name) {\n+                // track the extern crate as used.\n+                if let Some(DefId{ krate: kid, .. }) = extern_crate.def_id() {\n+                    self.resolver.used_crates.insert(kid);\n+                }\n+                let name_binding = NameBinding::create_from_module(extern_crate, None);\n+                return (Success((module, name_binding)), false);\n+            }\n+        }\n+\n+        // If there is an unresolved glob at this point in the containing module, bail out.\n+        // We don't know enough to be able to resolve the name.\n+        if module.pub_glob_count.get() > 0 {\n+            return (Indeterminate, false);\n+        }\n+\n+        match module.import_resolutions.borrow().get(&(name, ns)) {\n+            // The containing module definitely doesn't have an exported import with the\n+            // name in question. We can therefore accurately report that names are unbound.\n+            None => (Failed(None), false),\n+\n+            // The name is an import which has been fully resolved, so we just follow it.\n+            Some(resolution) if resolution.outstanding_references == 0 => {\n+                // Import resolutions must be declared with \"pub\" in order to be exported.\n+                if !resolution.is_public {\n+                    return (Failed(None), false);\n+                }\n+\n+                let target = resolution.target.clone();\n+                if let Some(Target { target_module, binding, shadowable: _ }) = target {\n+                    // track used imports and extern crates as well\n+                    self.resolver.used_imports.insert((resolution.id, ns));\n+                    self.resolver.record_import_use(resolution.id, name);\n+                    if let Some(DefId { krate, .. }) = target_module.def_id() {\n+                        self.resolver.used_crates.insert(krate);\n+                    }\n+                    (Success((target_module, binding)), true)\n+                } else {\n+                    (Failed(None), false)\n+                }\n+            }\n+\n+            // If module is the same module whose import we are resolving and\n+            // it has an unresolved import with the same name as `name`, then the user\n+            // is actually trying to import an item that is declared in the same scope\n+            //\n+            // e.g\n+            // use self::submodule;\n+            // pub mod submodule;\n+            //\n+            // In this case we continue as if we resolved the import and let\n+            // check_for_conflicts_between_imports_and_items handle the conflict\n+            Some(_) => match (importing_module.def_id(), module.def_id()) {\n+                (Some(id1), Some(id2)) if id1 == id2 => (Failed(None), false),\n+                _ => (Indeterminate, false)\n+            },\n+        }\n+    }\n+\n     fn resolve_single_import(&mut self,\n                              module_: Module<'b>,\n                              target_module: Module<'b>,\n@@ -420,253 +476,86 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n-\n-        let mut value_result = UnknownResult;\n-        let mut type_result = UnknownResult;\n-        let mut lev_suggestion = \"\".to_owned();\n-\n-        // Search for direct children of the containing module.\n-        build_reduced_graph::populate_module_if_necessary(self.resolver, &target_module);\n-\n-        match target_module.children.borrow().get(&source) {\n-            None => {\n-                let names = target_module.children.borrow();\n-                if let Some(name) = find_best_match_for_name(names.keys(),\n-                                                             &source.as_str(),\n-                                                             None) {\n-                    lev_suggestion = format!(\". Did you mean to use `{}`?\", name);\n-                }\n+        let (value_result, value_used_reexport) =\n+            self.resolve_name_in_module(&target_module, source, ValueNS, module_);\n+        let (type_result, type_used_reexport) =\n+            self.resolve_name_in_module(&target_module, source, TypeNS, module_);\n+\n+        match (&value_result, &type_result) {\n+            (&Success((_, ref name_binding)), _) if !value_used_reexport &&\n+                                                    directive.is_public &&\n+                                                    !name_binding.is_public() => {\n+                let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n+                let note_msg = format!(\"Consider marking `{}` as `pub` in the imported module\",\n+                                        source);\n+                struct_span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg)\n+                    .span_note(directive.span, &note_msg)\n+                    .emit();\n             }\n-            Some(ref child_name_bindings) => {\n-                // pub_err makes sure we don't give the same error twice.\n-                let mut pub_err = false;\n-                if child_name_bindings.value_ns.defined() {\n-                    debug!(\"(resolving single import) found value binding\");\n-                    value_result = BoundResult(target_module,\n-                                               child_name_bindings.value_ns.clone());\n-                    if directive.is_public && !child_name_bindings.value_ns.is_public() {\n-                        let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n-                        let note_msg = format!(\"Consider marking `{}` as `pub` in the imported \\\n-                                                module\",\n-                                               source);\n-                        struct_span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg)\n-                            .span_note(directive.span, &note_msg)\n-                            .emit();\n-                        pub_err = true;\n-                    }\n-                    if directive.is_public && child_name_bindings.value_ns.\n-                                              defined_with(DefModifiers::PRIVATE_VARIANT) {\n-                        let msg = format!(\"variant `{}` is private, and cannot be reexported ( \\\n-                                           error E0364), consider declaring its enum as `pub`\",\n-                                           source);\n-                        self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                                       directive.id,\n-                                                       directive.span,\n-                                                       msg);\n-                        pub_err = true;\n-                    }\n-                }\n-                if child_name_bindings.type_ns.defined() {\n-                    debug!(\"(resolving single import) found type binding\");\n-                    type_result = BoundResult(target_module,\n-                                              child_name_bindings.type_ns.clone());\n-                    if !pub_err && directive.is_public &&\n-                       !child_name_bindings.type_ns.is_public() {\n-                        let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n-                        let note_msg = format!(\"Consider declaring module `{}` as a `pub mod`\",\n-                                               source);\n-                        struct_span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg)\n-                            .span_note(directive.span, &note_msg)\n-                            .emit();\n-                    }\n-                    if !pub_err && directive.is_public && child_name_bindings.type_ns.\n-                                                    defined_with(DefModifiers::PRIVATE_VARIANT) {\n-                        let msg = format!(\"variant `{}` is private, and cannot be reexported ( \\\n-                                           error E0365), consider declaring its enum as `pub`\",\n-                                           source);\n-                        self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                                       directive.id,\n-                                                       directive.span,\n-                                                       msg);\n-                    }\n-                }\n-            }\n-        }\n \n-        // Unless we managed to find a result in both namespaces (unlikely),\n-        // search imports as well.\n-        let mut value_used_reexport = false;\n-        let mut type_used_reexport = false;\n-        match (value_result.clone(), type_result.clone()) {\n-            (BoundResult(..), BoundResult(..)) => {} // Continue.\n-            _ => {\n-                // If there is an unresolved glob at this point in the\n-                // containing module, bail out. We don't know enough to be\n-                // able to resolve this import.\n-\n-                if target_module.pub_glob_count.get() > 0 {\n-                    debug!(\"(resolving single import) unresolved pub glob; bailing out\");\n-                    return ResolveResult::Indeterminate;\n+            (_, &Success((_, ref name_binding))) if !type_used_reexport &&\n+                                                    directive.is_public => {\n+                if !name_binding.is_public() {\n+                    let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n+                    let note_msg =\n+                        format!(\"Consider declaring type or module `{}` with `pub`\", source);\n+                    struct_span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg)\n+                        .span_note(directive.span, &note_msg)\n+                        .emit();\n+                } else if name_binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n+                    let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n+                                       (error E0364), consider declaring its enum as `pub`\",\n+                                       source);\n+                    self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                                   directive.id,\n+                                                   directive.span,\n+                                                   msg);\n                 }\n+            }\n \n-                // Now search the exported imports within the containing module.\n-                match target_module.import_resolutions.borrow().get(&source) {\n-                    None => {\n-                        debug!(\"(resolving single import) no import\");\n-                        // The containing module definitely doesn't have an\n-                        // exported import with the name in question. We can\n-                        // therefore accurately report that the names are\n-                        // unbound.\n-\n-                        if lev_suggestion.is_empty() {  // skip if we already have a suggestion\n-                            let names = target_module.import_resolutions.borrow();\n-                            if let Some(name) = find_best_match_for_name(names.keys(),\n-                                                                         &source.as_str(),\n-                                                                         None) {\n-                                lev_suggestion =\n-                                    format!(\". Did you mean to use the re-exported import `{}`?\",\n-                                            name);\n-                            }\n-                        }\n-\n-                        if value_result.is_unknown() {\n-                            value_result = UnboundResult;\n-                        }\n-                        if type_result.is_unknown() {\n-                            type_result = UnboundResult;\n-                        }\n-                    }\n-                    Some(import_resolution) if import_resolution.outstanding_references == 0 => {\n-\n-                        fn get_binding<'a>(this: &mut Resolver,\n-                                           import_resolution: &ImportResolutionPerNamespace<'a>,\n-                                           namespace: Namespace,\n-                                           source: Name)\n-                                           -> NamespaceResult<'a> {\n-\n-                            // Import resolutions must be declared with \"pub\"\n-                            // in order to be exported.\n-                            if !import_resolution[namespace].is_public {\n-                                return UnboundResult;\n-                            }\n-\n-                            match import_resolution[namespace].target.clone() {\n-                                None => {\n-                                    return UnboundResult;\n-                                }\n-                                Some(Target {\n-                                    target_module,\n-                                    binding,\n-                                    shadowable: _\n-                                }) => {\n-                                    debug!(\"(resolving single import) found import in ns {:?}\",\n-                                           namespace);\n-                                    let id = import_resolution[namespace].id;\n-                                    // track used imports and extern crates as well\n-                                    this.used_imports.insert((id, namespace));\n-                                    this.record_import_use(id, source);\n-                                    match target_module.def_id() {\n-                                        Some(DefId{krate: kid, ..}) => {\n-                                            this.used_crates.insert(kid);\n-                                        }\n-                                        _ => {}\n-                                    }\n-                                    return BoundResult(target_module, binding);\n-                                }\n-                            }\n-                        }\n-\n-                        // The name is an import which has been fully\n-                        // resolved. We can, therefore, just follow it.\n-                        if value_result.is_unknown() {\n-                            value_result = get_binding(self.resolver,\n-                                                       import_resolution,\n-                                                       ValueNS,\n-                                                       source);\n-                            value_used_reexport = import_resolution.value_ns.is_public;\n-                        }\n-                        if type_result.is_unknown() {\n-                            type_result = get_binding(self.resolver,\n-                                                      import_resolution,\n-                                                      TypeNS,\n-                                                      source);\n-                            type_used_reexport = import_resolution.type_ns.is_public;\n-                        }\n+            _ => {}\n+        }\n \n-                    }\n-                    Some(_) => {\n-                        // If target_module is the same module whose import we are resolving\n-                        // and there it has an unresolved import with the same name as `source`,\n-                        // then the user is actually trying to import an item that is declared\n-                        // in the same scope\n-                        //\n-                        // e.g\n-                        // use self::submodule;\n-                        // pub mod submodule;\n-                        //\n-                        // In this case we continue as if we resolved the import and let the\n-                        // check_for_conflicts_between_imports_and_items call below handle\n-                        // the conflict\n-                        match (module_.def_id(), target_module.def_id()) {\n-                            (Some(id1), Some(id2)) if id1 == id2 => {\n-                                if value_result.is_unknown() {\n-                                    value_result = UnboundResult;\n-                                }\n-                                if type_result.is_unknown() {\n-                                    type_result = UnboundResult;\n-                                }\n-                            }\n-                            _ => {\n-                                // The import is unresolved. Bail out.\n-                                debug!(\"(resolving single import) unresolved import; bailing out\");\n-                                return ResolveResult::Indeterminate;\n-                            }\n-                        }\n+        let mut lev_suggestion = \"\".to_owned();\n+        match (&value_result, &type_result) {\n+            (&Indeterminate, _) | (_, &Indeterminate) => return Indeterminate,\n+            (&Failed(_), &Failed(_)) => {\n+                let children = target_module.children.borrow();\n+                let names = children.keys().map(|&(ref name, _)| name);\n+                if let Some(name) = find_best_match_for_name(names, &source.as_str(), None) {\n+                    lev_suggestion = format!(\". Did you mean to use `{}`?\", name);\n+                } else {\n+                    let resolutions = target_module.import_resolutions.borrow();\n+                    let names = resolutions.keys().map(|&(ref name, _)| name);\n+                    if let Some(name) = find_best_match_for_name(names,\n+                                                                 &source.as_str(),\n+                                                                 None) {\n+                        lev_suggestion =\n+                            format!(\". Did you mean to use the re-exported import `{}`?\", name);\n                     }\n                 }\n             }\n+            _ => (),\n         }\n \n         let mut value_used_public = false;\n         let mut type_used_public = false;\n \n-        // If we didn't find a result in the type namespace, search the\n-        // external modules.\n-        match type_result {\n-            BoundResult(..) => {}\n-            _ => {\n-                match target_module.external_module_children.borrow_mut().get(&source) {\n-                    None => {} // Continue.\n-                    Some(module) => {\n-                        debug!(\"(resolving single import) found external module\");\n-                        // track the module as used.\n-                        match module.def_id() {\n-                            Some(DefId{krate: kid, ..}) => {\n-                                self.resolver.used_crates.insert(kid);\n-                            }\n-                            _ => {}\n-                        }\n-                        let name_binding = NameBinding::create_from_module(module);\n-                        type_result = BoundResult(target_module, name_binding);\n-                        type_used_public = true;\n-                    }\n-                }\n-            }\n-        }\n-\n         // We've successfully resolved the import. Write the results in.\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let import_resolution = import_resolutions.get_mut(&target).unwrap();\n \n         {\n-            let mut check_and_write_import = |namespace, result: &_, used_public: &mut bool| {\n+            let mut check_and_write_import = |namespace, result, used_public: &mut bool| {\n+                let result: &ResolveResult<(Module<'b>, NameBinding)> = result;\n+\n+                let import_resolution = import_resolutions.get_mut(&(target, namespace)).unwrap();\n                 let namespace_name = match namespace {\n                     TypeNS => \"type\",\n                     ValueNS => \"value\",\n                 };\n \n                 match *result {\n-                    BoundResult(ref target_module, ref name_binding) => {\n+                    Success((ref target_module, ref name_binding)) => {\n                         debug!(\"(resolving single import) found {:?} target: {:?}\",\n                                namespace_name,\n                                name_binding.def());\n@@ -679,67 +568,68 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                              directive.span,\n                                                              target);\n \n-                        import_resolution[namespace] = ImportResolution {\n-                            target: Some(Target::new(target_module,\n-                                                     name_binding.clone(),\n-                                                     directive.shadowable)),\n-                            id: directive.id,\n-                            is_public: directive.is_public\n-                        };\n+                        import_resolution.target = Some(Target::new(target_module,\n+                                                                    name_binding.clone(),\n+                                                                    directive.shadowable));\n+                        import_resolution.id = directive.id;\n+                        import_resolution.is_public = directive.is_public;\n \n-                        self.add_export(module_, target, &import_resolution[namespace]);\n+                        self.add_export(module_, target, &import_resolution);\n                         *used_public = name_binding.is_public();\n                     }\n-                    UnboundResult => {\n+                    Failed(_) => {\n                         // Continue.\n                     }\n-                    UnknownResult => {\n+                    Indeterminate => {\n                         panic!(\"{:?} result should be known at this point\", namespace_name);\n                     }\n                 }\n+\n+                self.check_for_conflicts_between_imports_and_items(module_,\n+                                                                   import_resolution,\n+                                                                   directive.span,\n+                                                                   (target, namespace));\n             };\n             check_and_write_import(ValueNS, &value_result, &mut value_used_public);\n             check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n         }\n \n-        self.check_for_conflicts_between_imports_and_items(module_,\n-                                                           import_resolution,\n-                                                           directive.span,\n-                                                           target);\n-\n-        if value_result.is_unbound() && type_result.is_unbound() {\n+        if let (&Failed(_), &Failed(_)) = (&value_result, &type_result) {\n             let msg = format!(\"There is no `{}` in `{}`{}\",\n                               source,\n                               module_to_string(&target_module), lev_suggestion);\n-            return ResolveResult::Failed(Some((directive.span, msg)));\n+            return Failed(Some((directive.span, msg)));\n         }\n+\n         let value_used_public = value_used_reexport || value_used_public;\n         let type_used_public = type_used_reexport || type_used_public;\n \n-        assert!(import_resolution.outstanding_references >= 1);\n-        import_resolution.outstanding_references -= 1;\n-\n-        // Record what this import resolves to for later uses in documentation,\n-        // this may resolve to either a value or a type, but for documentation\n-        // purposes it's good enough to just favor one over the other.\n-        let value_def_and_priv = import_resolution.value_ns.target.as_ref().map(|target| {\n-            let def = target.binding.def().unwrap();\n-            (def,\n-             if value_used_public {\n-                lp\n-            } else {\n-                DependsOn(def.def_id())\n+        let value_def_and_priv = {\n+            let import_resolution_value = import_resolutions.get_mut(&(target, ValueNS)).unwrap();\n+            assert!(import_resolution_value.outstanding_references >= 1);\n+            import_resolution_value.outstanding_references -= 1;\n+\n+            // Record what this import resolves to for later uses in documentation,\n+            // this may resolve to either a value or a type, but for documentation\n+            // purposes it's good enough to just favor one over the other.\n+            import_resolution_value.target.as_ref().map(|target| {\n+                let def = target.binding.def().unwrap();\n+                let last_private = if value_used_public { lp } else { DependsOn(def.def_id()) };\n+                (def, last_private)\n             })\n-        });\n-        let type_def_and_priv = import_resolution.type_ns.target.as_ref().map(|target| {\n-            let def = target.binding.def().unwrap();\n-            (def,\n-             if type_used_public {\n-                lp\n-            } else {\n-                DependsOn(def.def_id())\n+        };\n+\n+        let type_def_and_priv = {\n+            let import_resolution_type = import_resolutions.get_mut(&(target, TypeNS)).unwrap();\n+            assert!(import_resolution_type.outstanding_references >= 1);\n+            import_resolution_type.outstanding_references -= 1;\n+\n+            import_resolution_type.target.as_ref().map(|target| {\n+                let def = target.binding.def().unwrap();\n+                let last_private = if type_used_public { lp } else { DependsOn(def.def_id()) };\n+                (def, last_private)\n             })\n-        });\n+        };\n \n         let import_lp = LastImport {\n             value_priv: value_def_and_priv.map(|(_, p)| p),\n@@ -766,7 +656,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         debug!(\"(resolving single import) successfully resolved import\");\n-        return ResolveResult::Success(());\n+        return Success(());\n     }\n \n     // Resolves a glob import. Note that this function cannot fail; it either\n@@ -806,44 +696,41 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                \"Cannot glob-import a module into itself.\".into())));\n         }\n \n-        for (name, target_import_resolution) in import_resolutions.iter() {\n+        for (&(name, ns), target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution {} into `{}`\",\n-                   *name,\n+                   name,\n                    module_to_string(module_));\n \n             // Here we merge two import resolutions.\n             let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-            let mut dest_import_resolution = import_resolutions.entry(*name).or_insert_with(|| {\n-                ImportResolutionPerNamespace::new(id, is_public)\n-            });\n-\n-            for &ns in [TypeNS, ValueNS].iter() {\n-                match target_import_resolution[ns].target {\n-                    Some(ref target) if target_import_resolution[ns].is_public => {\n-                        self.check_for_conflicting_import(&dest_import_resolution,\n-                                                          import_directive.span,\n-                                                          *name,\n-                                                          ns);\n-                        dest_import_resolution[ns] = ImportResolution {\n-                            id: id, is_public: is_public, target: Some(target.clone())\n-                        };\n-                        self.add_export(module_, *name, &dest_import_resolution[ns]);\n-                    }\n-                    _ => {}\n+            let mut dest_import_resolution =\n+                import_resolutions.entry((name, ns))\n+                                  .or_insert_with(|| ImportResolution::new(id, is_public));\n+\n+            match target_import_resolution.target {\n+                Some(ref target) if target_import_resolution.is_public => {\n+                    self.check_for_conflicting_import(&dest_import_resolution,\n+                                                      import_directive.span,\n+                                                      name,\n+                                                      ns);\n+                    dest_import_resolution.id = id;\n+                    dest_import_resolution.is_public = is_public;\n+                    dest_import_resolution.target = Some(target.clone());\n+                    self.add_export(module_, name, &dest_import_resolution);\n                 }\n+                _ => {}\n             }\n         }\n \n         // Add all children from the containing module.\n         build_reduced_graph::populate_module_if_necessary(self.resolver, &target_module);\n \n-        for (&name, name_bindings) in target_module.children.borrow().iter() {\n+        for (&name, name_binding) in target_module.children.borrow().iter() {\n             self.merge_import_resolution(module_,\n                                          target_module,\n                                          import_directive,\n                                          name,\n-                                         name_bindings.clone());\n-\n+                                         name_binding.clone());\n         }\n \n         // Record the destination of this import\n@@ -864,14 +751,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                module_: Module<'b>,\n                                containing_module: Module<'b>,\n                                import_directive: &ImportDirective,\n-                               name: Name,\n-                               name_bindings: NameBindings<'b>) {\n+                               (name, ns): (Name, Namespace),\n+                               name_binding: NameBinding<'b>) {\n         let id = import_directive.id;\n         let is_public = import_directive.is_public;\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = import_resolutions.entry(name).or_insert_with(|| {\n-            ImportResolutionPerNamespace::new(id, is_public)\n+        let dest_import_resolution = import_resolutions.entry((name, ns)).or_insert_with(|| {\n+            ImportResolution::new(id, is_public)\n         });\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` to `{}`\",\n@@ -880,61 +767,46 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                module_to_string(module_));\n \n         // Merge the child item into the import resolution.\n-        // pub_err makes sure we don't give the same error twice.\n-        let mut pub_err = false;\n-        {\n-            let mut merge_child_item = |namespace| {\n-                if !pub_err && is_public &&\n-                        name_bindings[namespace].defined_with(DefModifiers::PRIVATE_VARIANT) {\n-                    let msg = format!(\"variant `{}` is private, and cannot be reexported (error \\\n-                                       E0364), consider declaring its enum as `pub`\", name);\n-                    self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                                   import_directive.id,\n-                                                   import_directive.span,\n-                                                   msg);\n-                    pub_err = true;\n-                }\n+        let modifier = DefModifiers::IMPORTABLE | DefModifiers::PUBLIC;\n+\n+        if ns == TypeNS && is_public && name_binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n+            let msg = format!(\"variant `{}` is private, and cannot be reexported (error \\\n+                               E0364), consider declaring its enum as `pub`\", name);\n+            self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                           import_directive.id,\n+                                           import_directive.span,\n+                                           msg);\n+        }\n \n-                let modifier = DefModifiers::IMPORTABLE | DefModifiers::PUBLIC;\n-                if name_bindings[namespace].defined_with(modifier) {\n-                    let namespace_name = match namespace {\n-                        TypeNS => \"type\",\n-                        ValueNS => \"value\",\n-                    };\n-                    debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n-                    if dest_import_resolution.shadowable(namespace) == Shadowable::Never {\n-                        let msg = format!(\"a {} named `{}` has already been imported in this \\\n-                                           module\",\n-                                          namespace_name,\n-                                          name);\n-                        span_err!(self.resolver.session,\n-                                  import_directive.span,\n-                                  E0251,\n-                                  \"{}\",\n-                                  msg);\n-                    } else {\n-                        dest_import_resolution[namespace] = ImportResolution {\n-                            target: Some(Target::new(containing_module,\n-                                                     name_bindings[namespace].clone(),\n-                                                     import_directive.shadowable)),\n-                            id: id,\n-                            is_public: is_public\n-                        };\n-                        self.add_export(module_, name, &dest_import_resolution[namespace]);\n-                    }\n-                } else {\n-                    // FIXME #30159: This is required for backwards compatability.\n-                    dest_import_resolution[namespace].is_public |= is_public;\n-                }\n+        if name_binding.defined_with(modifier) {\n+            let namespace_name = match ns {\n+                TypeNS => \"type\",\n+                ValueNS => \"value\",\n             };\n-            merge_child_item(ValueNS);\n-            merge_child_item(TypeNS);\n+            debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n+            if dest_import_resolution.shadowable() == Shadowable::Never {\n+                let msg = format!(\"a {} named `{}` has already been imported in this module\",\n+                                 namespace_name,\n+                                 name);\n+                span_err!(self.resolver.session, import_directive.span, E0251, \"{}\", msg);\n+           } else {\n+                let target = Target::new(containing_module,\n+                                         name_binding.clone(),\n+                                         import_directive.shadowable);\n+                dest_import_resolution.target = Some(target);\n+                dest_import_resolution.id = id;\n+                dest_import_resolution.is_public = is_public;\n+                self.add_export(module_, name, &dest_import_resolution);\n+            }\n+        } else {\n+            // FIXME #30159: This is required for backwards compatability.\n+            dest_import_resolution.is_public |= is_public;\n         }\n \n         self.check_for_conflicts_between_imports_and_items(module_,\n                                                            dest_import_resolution,\n                                                            import_directive.span,\n-                                                           name);\n+                                                           (name, ns));\n     }\n \n     fn add_export(&mut self, module: Module<'b>, name: Name, resolution: &ImportResolution<'b>) {\n@@ -952,11 +824,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicting_import(&mut self,\n-                                    import_resolution: &ImportResolutionPerNamespace,\n+                                    import_resolution: &ImportResolution,\n                                     import_span: Span,\n                                     name: Name,\n                                     namespace: Namespace) {\n-        let target = &import_resolution[namespace].target;\n+        let target = &import_resolution.target;\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n                name,\n                target.is_some());\n@@ -973,7 +845,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     }\n                     ValueNS => \"value\",\n                 };\n-                let use_id = import_resolution[namespace].id;\n+                let use_id = import_resolution.id;\n                 let item = self.resolver.ast_map.expect_item(use_id);\n                 let mut err = struct_span_err!(self.resolver.session,\n                                                import_span,\n@@ -1006,55 +878,53 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicts_between_imports_and_items(&mut self,\n                                                      module: Module<'b>,\n-                                                     import: &ImportResolutionPerNamespace<'b>,\n+                                                     import: &ImportResolution<'b>,\n                                                      import_span: Span,\n-                                                     name: Name) {\n+                                                     (name, ns): (Name, Namespace)) {\n         // First, check for conflicts between imports and `extern crate`s.\n-        if module.external_module_children\n-                 .borrow()\n-                 .contains_key(&name) {\n-            match import.type_ns.target {\n-                Some(ref target) if target.shadowable != Shadowable::Always => {\n-                    let msg = format!(\"import `{0}` conflicts with imported crate in this module \\\n-                                       (maybe you meant `use {0}::*`?)\",\n-                                      name);\n-                    span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n+        if ns == TypeNS {\n+            if module.external_module_children.borrow().contains_key(&name) {\n+                match import.target {\n+                    Some(ref target) if target.shadowable != Shadowable::Always => {\n+                        let msg = format!(\"import `{0}` conflicts with imported crate \\\n+                                           in this module (maybe you meant `use {0}::*`?)\",\n+                                          name);\n+                        span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n+                    }\n+                    Some(_) | None => {}\n                 }\n-                Some(_) | None => {}\n             }\n         }\n \n         // Check for item conflicts.\n-        let name_bindings = match module.children.borrow().get(&name) {\n+        let name_binding = match module.get_child(name, ns) {\n             None => {\n                 // There can't be any conflicts.\n                 return;\n             }\n-            Some(ref name_bindings) => (*name_bindings).clone(),\n+            Some(name_binding) => name_binding,\n         };\n \n-        match import.value_ns.target {\n-            Some(ref target) if target.shadowable != Shadowable::Always => {\n-                if let Some(ref value) = *name_bindings.value_ns.borrow() {\n+        if ns == ValueNS {\n+            match import.target {\n+                Some(ref target) if target.shadowable != Shadowable::Always => {\n                     let mut err = struct_span_err!(self.resolver.session,\n                                                    import_span,\n                                                    E0255,\n                                                    \"import `{}` conflicts with \\\n                                                     value in this module\",\n                                                    name);\n-                    if let Some(span) = value.span {\n+                    if let Some(span) = name_binding.span {\n                         err.span_note(span, \"conflicting value here\");\n                     }\n                     err.emit();\n                 }\n+                Some(_) | None => {}\n             }\n-            Some(_) | None => {}\n-        }\n-\n-        match import.type_ns.target {\n-            Some(ref target) if target.shadowable != Shadowable::Always => {\n-                if let Some(ref ty) = *name_bindings.type_ns.borrow() {\n-                    let (what, note) = match ty.module() {\n+        } else {\n+            match import.target {\n+                Some(ref target) if target.shadowable != Shadowable::Always => {\n+                    let (what, note) = match name_binding.module() {\n                         Some(ref module) if module.is_normal() =>\n                             (\"existing submodule\", \"note conflicting module here\"),\n                         Some(ref module) if module.is_trait() =>\n@@ -1067,13 +937,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                    \"import `{}` conflicts with {}\",\n                                                    name,\n                                                    what);\n-                    if let Some(span) = ty.span {\n+                    if let Some(span) = name_binding.span {\n                         err.span_note(span, note);\n                     }\n                     err.emit();\n                 }\n+                Some(_) | None => {}\n             }\n-            Some(_) | None => {}\n         }\n     }\n }"}]}