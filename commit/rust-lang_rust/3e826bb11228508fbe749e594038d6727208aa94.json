{"sha": "3e826bb11228508fbe749e594038d6727208aa94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlODI2YmIxMTIyODUwOGZiZTc0OWU1OTQwMzhkNjcyNzIwOGFhOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-21T12:23:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-21T12:23:45Z"}, "message": "Auto merge of #82359 - JohnTitor:rollup-6puemik, r=JohnTitor\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #81300 (BTree: share panicky test code & test panic during clear, clone)\n - #81706 (Document BinaryHeap unsafe functions)\n - #81833 (parallelize x.py test tidy)\n - #81966 (Add new `rustc` target for Arm64 machines that can target the iphonesimulator)\n - #82154 (Update RELEASES.md 1.50 to include methods stabilized in #79342)\n - #82177 (Do not delete bootstrap.exe on Windows during clean)\n - #82181 (Add check for ES5 in CI)\n - #82229 (Add [A-diagnostics] bug report template)\n - #82233 (try-back-block-type test: Use TryFromSliceError for From test)\n - #82302 (Remove unsafe impl Send for CompletedTest & TestResult)\n - #82349 (test: Print test name only once on timeout)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "75c613b7c3dce3cbe517151112d5787e0146d7a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75c613b7c3dce3cbe517151112d5787e0146d7a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e826bb11228508fbe749e594038d6727208aa94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e826bb11228508fbe749e594038d6727208aa94", "html_url": "https://github.com/rust-lang/rust/commit/3e826bb11228508fbe749e594038d6727208aa94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e826bb11228508fbe749e594038d6727208aa94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef1468822146032d53bc3970ef8382b72923e51f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef1468822146032d53bc3970ef8382b72923e51f", "html_url": "https://github.com/rust-lang/rust/commit/ef1468822146032d53bc3970ef8382b72923e51f"}, {"sha": "d7fb4de79172910bba6ea632196170647dcf11cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7fb4de79172910bba6ea632196170647dcf11cb", "html_url": "https://github.com/rust-lang/rust/commit/d7fb4de79172910bba6ea632196170647dcf11cb"}], "stats": {"total": 1019, "additions": 708, "deletions": 311}, "files": [{"sha": "044979f3baec3b3f9eb8fb6bb5043ad7868643b3", "filename": ".github/ISSUE_TEMPLATE/diagnostics.md", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -0,0 +1,46 @@\n+---\n+name: Diagnostic issue\n+about: Create a bug report or feature request for a change to `rustc`'s error output\n+labels: A-diagnostics, T-compiler\n+---\n+<!--\n+Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n+along with any information you feel relevant to replicating the bug.\n+\n+If you cannot produce a minimal reproduction case (something that would work in\n+isolation), please provide the steps or even link to a repository that causes\n+the problematic output to occur. \n+-->\n+\n+Given the following code: <!-- Please provide a link to play.rust-lang.org -->\n+\n+```rust\n+<code>\n+```\n+\n+The current output is:\n+\n+```\n+<rustc output>\n+```\n+\n+<!-- The following is not always necessary. -->\n+Ideally the output should look like:\n+\n+```\n+<proposed output>\n+```\n+\n+<!--\n+If the problem is not self-explanatory, please provide a rationale for the\n+change.\n+-->\n+\n+<!--\n+If dramatically different output is caused by small changes, consider also\n+adding them here.\n+\n+If you're using the stable version of the compiler, you should also check if the\n+bug also exists in the beta or nightly versions. The output might also be\n+different depending on the Edition.\n+-->"}, {"sha": "25f9c802982c30fab3646d14bcb35d46e4388811", "filename": "RELEASES.md", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -43,6 +43,23 @@ The following previously stable methods are now `const`.\n \n - [`IpAddr::is_ipv4`]\n - [`IpAddr::is_ipv6`]\n+- [`IpAddr::is_unspecified`]\n+- [`IpAddr::is_loopback`]\n+- [`IpAddr::is_multicast`]\n+- [`Ipv4Addr::octets`]\n+- [`Ipv4Addr::is_loopback`]\n+- [`Ipv4Addr::is_private`]\n+- [`Ipv4Addr::is_link_local`]\n+- [`Ipv4Addr::is_multicast`]\n+- [`Ipv4Addr::is_broadcast`]\n+- [`Ipv4Addr::is_documentation`]\n+- [`Ipv4Addr::to_ipv6_compatible`]\n+- [`Ipv4Addr::to_ipv6_mapped`]\n+- [`Ipv6Addr::segments`]\n+- [`Ipv6Addr::is_unspecified`]\n+- [`Ipv6Addr::is_loopback`]\n+- [`Ipv6Addr::is_multicast`]\n+- [`Ipv6Addr::to_ipv4`]\n - [`Layout::size`]\n - [`Layout::align`]\n - [`Layout::from_size_align`]\n@@ -104,6 +121,23 @@ Compatibility Notes\n [cargo/8725]: https://github.com/rust-lang/cargo/pull/8725\n [`IpAddr::is_ipv4`]: https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_ipv4\n [`IpAddr::is_ipv6`]: https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_ipv6\n+[`IpAddr::is_unspecified`]: https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_unspecified\n+[`IpAddr::is_loopback`]: https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_loopback\n+[`IpAddr::is_multicast`]: https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_multicast\n+[`Ipv4Addr::octets`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.octets\n+[`Ipv4Addr::is_loopback`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_loopback\n+[`Ipv4Addr::is_private`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_private\n+[`Ipv4Addr::is_link_local`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_link_local\n+[`Ipv4Addr::is_multicast`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_multicast\n+[`Ipv4Addr::is_broadcast`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_broadcast\n+[`Ipv4Addr::is_documentation`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_documentation\n+[`Ipv4Addr::to_ipv6_compatible`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.to_ipv6_compatible\n+[`Ipv4Addr::to_ipv6_mapped`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.to_ipv6_mapped\n+[`Ipv6Addr::segments`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.segments\n+[`Ipv6Addr::is_unspecified`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.is_unspecified\n+[`Ipv6Addr::is_loopback`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.is_loopback\n+[`Ipv6Addr::is_multicast`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.is_multicast\n+[`Ipv6Addr::to_ipv4`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.to_ipv4\n [`Layout::align`]: https://doc.rust-lang.org/stable/std/alloc/struct.Layout.html#method.align\n [`Layout::from_size_align`]: https://doc.rust-lang.org/stable/std/alloc/struct.Layout.html#method.from_size_align\n [`Layout::size`]: https://doc.rust-lang.org/stable/std/alloc/struct.Layout.html#method.size"}, {"sha": "b93a579df15269b5081b8f4dc004893f829aaafb", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -2193,6 +2193,7 @@ fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n         (\"x86_64\", \"tvos\") => \"appletvsimulator\",\n         (\"arm\", \"ios\") => \"iphoneos\",\n         (\"aarch64\", \"ios\") if llvm_target.contains(\"macabi\") => \"macosx\",\n+        (\"aarch64\", \"ios\") if llvm_target.contains(\"sim\") => \"iphonesimulator\",\n         (\"aarch64\", \"ios\") => \"iphoneos\",\n         (\"x86\", \"ios\") => \"iphonesimulator\",\n         (\"x86_64\", \"ios\") if llvm_target.contains(\"macabi\") => \"macosx\","}, {"sha": "e594ceec1b78c532ba880e2c8740ec0e2bc01a41", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios_sim.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -0,0 +1,39 @@\n+use super::apple_sdk_base::{opts, Arch};\n+use crate::spec::{Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    let base = opts(\"ios\", Arch::Arm64_sim);\n+\n+    // Clang automatically chooses a more specific target based on\n+    // IPHONEOS_DEPLOYMENT_TARGET.\n+    // This is required for the simulator target to pick the right\n+    // MACH-O commands, so we do too.\n+    let arch = \"arm64\";\n+    let llvm_target = super::apple_base::ios_sim_llvm_target(arch);\n+\n+    Target {\n+        llvm_target: llvm_target,\n+        pointer_width: 64,\n+        data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        options: TargetOptions {\n+            features: \"+neon,+fp-armv8,+apple-a7\".to_string(),\n+            eliminate_frame_pointer: false,\n+            max_atomic_width: Some(128),\n+            unsupported_abis: super::arm_base::unsupported_abis(),\n+            forces_embed_bitcode: true,\n+            // Taken from a clang build on Xcode 11.4.1.\n+            // These arguments are not actually invoked - they just have\n+            // to look right to pass App Store validation.\n+            bitcode_llvm_cmdline: \"-triple\\0\\\n+                arm64-apple-ios14.0-simulator\\0\\\n+                -emit-obj\\0\\\n+                -disable-llvm-passes\\0\\\n+                -target-abi\\0\\\n+                darwinpcs\\0\\\n+                -Os\\0\"\n+                .to_string(),\n+            ..base\n+        },\n+    }\n+}"}, {"sha": "23f1357af163f22590e07fb7fed02736ab4bb552", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -54,14 +54,16 @@ pub fn opts(os: &str) -> TargetOptions {\n     }\n }\n \n-fn macos_deployment_target() -> (u32, u32) {\n-    let deployment_target = env::var(\"MACOSX_DEPLOYMENT_TARGET\").ok();\n-    let version = deployment_target\n+fn deployment_target(var_name: &str) -> Option<(u32, u32)> {\n+    let deployment_target = env::var(var_name).ok();\n+    deployment_target\n         .as_ref()\n         .and_then(|s| s.split_once('.'))\n-        .and_then(|(a, b)| a.parse::<u32>().and_then(|a| b.parse::<u32>().map(|b| (a, b))).ok());\n+        .and_then(|(a, b)| a.parse::<u32>().and_then(|a| b.parse::<u32>().map(|b| (a, b))).ok())\n+}\n \n-    version.unwrap_or((10, 7))\n+fn macos_deployment_target() -> (u32, u32) {\n+    deployment_target(\"MACOSX_DEPLOYMENT_TARGET\").unwrap_or((10, 7))\n }\n \n pub fn macos_llvm_target(arch: &str) -> String {\n@@ -84,3 +86,12 @@ pub fn macos_link_env_remove() -> Vec<String> {\n     env_remove.push(\"IPHONEOS_DEPLOYMENT_TARGET\".to_string());\n     env_remove\n }\n+\n+fn ios_deployment_target() -> (u32, u32) {\n+    deployment_target(\"IPHONEOS_DEPLOYMENT_TARGET\").unwrap_or((7, 0))\n+}\n+\n+pub fn ios_sim_llvm_target(arch: &str) -> String {\n+    let (major, minor) = ios_deployment_target();\n+    format!(\"{}-apple-ios{}.{}.0-simulator\", arch, major, minor)\n+}"}, {"sha": "538c4ca86974f9e8c71835eaed9e3c74e98fbc60", "filename": "compiler/rustc_target/src/spec/apple_sdk_base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -11,6 +11,7 @@ pub enum Arch {\n     X86_64,\n     X86_64_macabi,\n     Arm64_macabi,\n+    Arm64_sim,\n }\n \n fn target_cpu(arch: Arch) -> String {\n@@ -22,13 +23,16 @@ fn target_cpu(arch: Arch) -> String {\n         X86_64 => \"core2\",\n         X86_64_macabi => \"core2\",\n         Arm64_macabi => \"apple-a12\",\n+        Arm64_sim => \"apple-a12\",\n     }\n     .to_string()\n }\n \n fn link_env_remove(arch: Arch) -> Vec<String> {\n     match arch {\n-        Armv7 | Armv7s | Arm64 | I386 | X86_64 => vec![\"MACOSX_DEPLOYMENT_TARGET\".to_string()],\n+        Armv7 | Armv7s | Arm64 | I386 | X86_64 | Arm64_sim => {\n+            vec![\"MACOSX_DEPLOYMENT_TARGET\".to_string()]\n+        }\n         X86_64_macabi | Arm64_macabi => vec![\"IPHONEOS_DEPLOYMENT_TARGET\".to_string()],\n     }\n }"}, {"sha": "ae803dbdb3117265b7b33e078040c10df1378394", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -727,6 +727,7 @@ supported_targets! {\n     (\"armv7s-apple-ios\", armv7s_apple_ios),\n     (\"x86_64-apple-ios-macabi\", x86_64_apple_ios_macabi),\n     (\"aarch64-apple-ios-macabi\", aarch64_apple_ios_macabi),\n+    (\"aarch64-apple-ios-sim\", aarch64_apple_ios_sim),\n     (\"aarch64-apple-tvos\", aarch64_apple_tvos),\n     (\"x86_64-apple-tvos\", x86_64_apple_tvos),\n "}, {"sha": "33bd98d467ceca291326b69526b9a766853333d0", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 117, "deletions": 49, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -275,7 +275,8 @@ impl<T: Ord + fmt::Debug> fmt::Debug for PeekMut<'_, T> {\n impl<T: Ord> Drop for PeekMut<'_, T> {\n     fn drop(&mut self) {\n         if self.sift {\n-            self.heap.sift_down(0);\n+            // SAFETY: PeekMut is only instantiated for non-empty heaps.\n+            unsafe { self.heap.sift_down(0) };\n         }\n     }\n }\n@@ -431,7 +432,8 @@ impl<T: Ord> BinaryHeap<T> {\n         self.data.pop().map(|mut item| {\n             if !self.is_empty() {\n                 swap(&mut item, &mut self.data[0]);\n-                self.sift_down_to_bottom(0);\n+                // SAFETY: !self.is_empty() means that self.len() > 0\n+                unsafe { self.sift_down_to_bottom(0) };\n             }\n             item\n         })\n@@ -473,7 +475,9 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n         self.data.push(item);\n-        self.sift_up(0, old_len);\n+        // SAFETY: Since we pushed a new item it means that\n+        //  old_len = self.len() - 1 < self.len()\n+        unsafe { self.sift_up(0, old_len) };\n     }\n \n     /// Consumes the `BinaryHeap` and returns a vector in sorted\n@@ -506,7 +510,10 @@ impl<T: Ord> BinaryHeap<T> {\n                 let ptr = self.data.as_mut_ptr();\n                 ptr::swap(ptr, ptr.add(end));\n             }\n-            self.sift_down_range(0, end);\n+            // SAFETY: `end` goes from `self.len() - 1` to 1 (both included) so:\n+            //  0 < 1 <= end <= self.len() - 1 < self.len()\n+            //  Which means 0 < end and end < self.len().\n+            unsafe { self.sift_down_range(0, end) };\n         }\n         self.into_vec()\n     }\n@@ -519,78 +526,139 @@ impl<T: Ord> BinaryHeap<T> {\n     // the hole is filled back at the end of its scope, even on panic.\n     // Using a hole reduces the constant factor compared to using swaps,\n     // which involves twice as many moves.\n-    fn sift_up(&mut self, start: usize, pos: usize) -> usize {\n-        unsafe {\n-            // Take out the value at `pos` and create a hole.\n-            let mut hole = Hole::new(&mut self.data, pos);\n-\n-            while hole.pos() > start {\n-                let parent = (hole.pos() - 1) / 2;\n-                if hole.element() <= hole.get(parent) {\n-                    break;\n-                }\n-                hole.move_to(parent);\n+\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < self.len()`.\n+    unsafe fn sift_up(&mut self, start: usize, pos: usize) -> usize {\n+        // Take out the value at `pos` and create a hole.\n+        // SAFETY: The caller guarantees that pos < self.len()\n+        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n+\n+        while hole.pos() > start {\n+            let parent = (hole.pos() - 1) / 2;\n+\n+            // SAFETY: hole.pos() > start >= 0, which means hole.pos() > 0\n+            //  and so hole.pos() - 1 can't underflow.\n+            //  This guarantees that parent < hole.pos() so\n+            //  it's a valid index and also != hole.pos().\n+            if hole.element() <= unsafe { hole.get(parent) } {\n+                break;\n             }\n-            hole.pos()\n+\n+            // SAFETY: Same as above\n+            unsafe { hole.move_to(parent) };\n         }\n+\n+        hole.pos()\n     }\n \n     /// Take an element at `pos` and move it down the heap,\n     /// while its children are larger.\n-    fn sift_down_range(&mut self, pos: usize, end: usize) {\n-        unsafe {\n-            let mut hole = Hole::new(&mut self.data, pos);\n-            let mut child = 2 * pos + 1;\n-            while child < end - 1 {\n-                // compare with the greater of the two children\n-                child += (hole.get(child) <= hole.get(child + 1)) as usize;\n-                // if we are already in order, stop.\n-                if hole.element() >= hole.get(child) {\n-                    return;\n-                }\n-                hole.move_to(child);\n-                child = 2 * hole.pos() + 1;\n-            }\n-            if child == end - 1 && hole.element() < hole.get(child) {\n-                hole.move_to(child);\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < end <= self.len()`.\n+    unsafe fn sift_down_range(&mut self, pos: usize, end: usize) {\n+        // SAFETY: The caller guarantees that pos < end <= self.len().\n+        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n+        let mut child = 2 * hole.pos() + 1;\n+\n+        // Loop invariant: child == 2 * hole.pos() + 1.\n+        while child < end - 1 {\n+            // compare with the greater of the two children\n+            // SAFETY: child < end - 1 < self.len() and\n+            //  child + 1 < end <= self.len(), so they're valid indexes.\n+            //  child == 2 * hole.pos() + 1 != hole.pos() and\n+            //  child + 1 == 2 * hole.pos() + 2 != hole.pos().\n+            // FIXME: 2 * hole.pos() + 1 or 2 * hole.pos() + 2 could overflow\n+            //  if T is a ZST\n+            child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;\n+\n+            // if we are already in order, stop.\n+            // SAFETY: child is now either the old child or the old child+1\n+            //  We already proven that both are < self.len() and != hole.pos()\n+            if hole.element() >= unsafe { hole.get(child) } {\n+                return;\n             }\n+\n+            // SAFETY: same as above.\n+            unsafe { hole.move_to(child) };\n+            child = 2 * hole.pos() + 1;\n+        }\n+\n+        // SAFETY: && short circuit, which means that in the\n+        //  second condition it's already true that child == end - 1 < self.len().\n+        if child == end - 1 && hole.element() < unsafe { hole.get(child) } {\n+            // SAFETY: child is already proven to be a valid index and\n+            //  child == 2 * hole.pos() + 1 != hole.pos().\n+            unsafe { hole.move_to(child) };\n         }\n     }\n \n-    fn sift_down(&mut self, pos: usize) {\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < self.len()`.\n+    unsafe fn sift_down(&mut self, pos: usize) {\n         let len = self.len();\n-        self.sift_down_range(pos, len);\n+        // SAFETY: pos < len is guaranteed by the caller and\n+        //  obviously len = self.len() <= self.len().\n+        unsafe { self.sift_down_range(pos, len) };\n     }\n \n     /// Take an element at `pos` and move it all the way down the heap,\n     /// then sift it up to its position.\n     ///\n     /// Note: This is faster when the element is known to be large / should\n     /// be closer to the bottom.\n-    fn sift_down_to_bottom(&mut self, mut pos: usize) {\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < self.len()`.\n+    unsafe fn sift_down_to_bottom(&mut self, mut pos: usize) {\n         let end = self.len();\n         let start = pos;\n-        unsafe {\n-            let mut hole = Hole::new(&mut self.data, pos);\n-            let mut child = 2 * pos + 1;\n-            while child < end - 1 {\n-                child += (hole.get(child) <= hole.get(child + 1)) as usize;\n-                hole.move_to(child);\n-                child = 2 * hole.pos() + 1;\n-            }\n-            if child == end - 1 {\n-                hole.move_to(child);\n-            }\n-            pos = hole.pos;\n+\n+        // SAFETY: The caller guarantees that pos < self.len().\n+        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n+        let mut child = 2 * hole.pos() + 1;\n+\n+        // Loop invariant: child == 2 * hole.pos() + 1.\n+        while child < end - 1 {\n+            // SAFETY: child < end - 1 < self.len() and\n+            //  child + 1 < end <= self.len(), so they're valid indexes.\n+            //  child == 2 * hole.pos() + 1 != hole.pos() and\n+            //  child + 1 == 2 * hole.pos() + 2 != hole.pos().\n+            // FIXME: 2 * hole.pos() + 1 or 2 * hole.pos() + 2 could overflow\n+            //  if T is a ZST\n+            child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;\n+\n+            // SAFETY: Same as above\n+            unsafe { hole.move_to(child) };\n+            child = 2 * hole.pos() + 1;\n         }\n-        self.sift_up(start, pos);\n+\n+        if child == end - 1 {\n+            // SAFETY: child == end - 1 < self.len(), so it's a valid index\n+            //  and child == 2 * hole.pos() + 1 != hole.pos().\n+            unsafe { hole.move_to(child) };\n+        }\n+        pos = hole.pos();\n+        drop(hole);\n+\n+        // SAFETY: pos is the position in the hole and was already proven\n+        //  to be a valid index.\n+        unsafe { self.sift_up(start, pos) };\n     }\n \n     fn rebuild(&mut self) {\n         let mut n = self.len() / 2;\n         while n > 0 {\n             n -= 1;\n-            self.sift_down(n);\n+            // SAFETY: n starts from self.len() / 2 and goes down to 0.\n+            //  The only case when !(n < self.len()) is if\n+            //  self.len() == 0, but it's ruled out by the loop condition.\n+            unsafe { self.sift_down(n) };\n         }\n     }\n "}, {"sha": "56d6ae57e04a57ab3b0c2b9bcf4af20d0f6327fe", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 154, "deletions": 131, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -1,4 +1,6 @@\n-use super::super::{node, DeterministicRng};\n+use super::super::testing::crash_test::{CrashTestDummy, Panic};\n+use super::super::testing::ord_chaos::{Cyclic3, Governed, Governor};\n+use super::super::testing::rng::DeterministicRng;\n use super::Entry::{Occupied, Vacant};\n use super::*;\n use crate::boxed::Box;\n@@ -15,9 +17,6 @@ use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n \n-mod ord_chaos;\n-use ord_chaos::{Cyclic3, Governed, Governor};\n-\n // Capacity of a tree with a single level,\n // i.e., a tree who's root is a leaf node at height 0.\n const NODE_CAPACITY: usize = node::CAPACITY;\n@@ -1136,103 +1135,78 @@ mod test_drain_filter {\n \n     #[test]\n     fn drop_panic_leak() {\n-        static PREDS: AtomicUsize = AtomicUsize::new(0);\n-        static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct D;\n-        impl Drop for D {\n-            fn drop(&mut self) {\n-                if DROPS.fetch_add(1, SeqCst) == 1 {\n-                    panic!(\"panic in `drop`\");\n-                }\n-            }\n-        }\n-\n-        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n-        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n+        let a = CrashTestDummy::new(0);\n+        let b = CrashTestDummy::new(1);\n+        let c = CrashTestDummy::new(2);\n+        let mut map = BTreeMap::new();\n+        map.insert(a.spawn(Panic::Never), ());\n+        map.insert(b.spawn(Panic::InDrop), ());\n+        map.insert(c.spawn(Panic::Never), ());\n \n-        catch_unwind(move || {\n-            drop(map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, SeqCst);\n-                true\n-            }))\n-        })\n-        .unwrap_err();\n+        catch_unwind(move || drop(map.drain_filter(|dummy, _| dummy.query(true)))).unwrap_err();\n \n-        assert_eq!(PREDS.load(SeqCst), 0x011);\n-        assert_eq!(DROPS.load(SeqCst), 3);\n+        assert_eq!(a.queried(), 1);\n+        assert_eq!(b.queried(), 1);\n+        assert_eq!(c.queried(), 0);\n+        assert_eq!(a.dropped(), 1);\n+        assert_eq!(b.dropped(), 1);\n+        assert_eq!(c.dropped(), 1);\n     }\n \n     #[test]\n     fn pred_panic_leak() {\n-        static PREDS: AtomicUsize = AtomicUsize::new(0);\n-        static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct D;\n-        impl Drop for D {\n-            fn drop(&mut self) {\n-                DROPS.fetch_add(1, SeqCst);\n-            }\n-        }\n-\n-        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n-        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n-\n-        catch_unwind(AssertUnwindSafe(|| {\n-            drop(map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, SeqCst);\n-                match i {\n-                    0 => true,\n-                    _ => panic!(),\n-                }\n-            }))\n-        }))\n-        .unwrap_err();\n-\n-        assert_eq!(PREDS.load(SeqCst), 0x011);\n-        assert_eq!(DROPS.load(SeqCst), 1);\n+        let a = CrashTestDummy::new(0);\n+        let b = CrashTestDummy::new(1);\n+        let c = CrashTestDummy::new(2);\n+        let mut map = BTreeMap::new();\n+        map.insert(a.spawn(Panic::Never), ());\n+        map.insert(b.spawn(Panic::InQuery), ());\n+        map.insert(c.spawn(Panic::InQuery), ());\n+\n+        catch_unwind(AssertUnwindSafe(|| drop(map.drain_filter(|dummy, _| dummy.query(true)))))\n+            .unwrap_err();\n+\n+        assert_eq!(a.queried(), 1);\n+        assert_eq!(b.queried(), 1);\n+        assert_eq!(c.queried(), 0);\n+        assert_eq!(a.dropped(), 1);\n+        assert_eq!(b.dropped(), 0);\n+        assert_eq!(c.dropped(), 0);\n         assert_eq!(map.len(), 2);\n-        assert_eq!(map.first_entry().unwrap().key(), &4);\n-        assert_eq!(map.last_entry().unwrap().key(), &8);\n+        assert_eq!(map.first_entry().unwrap().key().id(), 1);\n+        assert_eq!(map.last_entry().unwrap().key().id(), 2);\n         map.check();\n     }\n \n     // Same as above, but attempt to use the iterator again after the panic in the predicate\n     #[test]\n     fn pred_panic_reuse() {\n-        static PREDS: AtomicUsize = AtomicUsize::new(0);\n-        static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct D;\n-        impl Drop for D {\n-            fn drop(&mut self) {\n-                DROPS.fetch_add(1, SeqCst);\n-            }\n-        }\n-\n-        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n-        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n+        let a = CrashTestDummy::new(0);\n+        let b = CrashTestDummy::new(1);\n+        let c = CrashTestDummy::new(2);\n+        let mut map = BTreeMap::new();\n+        map.insert(a.spawn(Panic::Never), ());\n+        map.insert(b.spawn(Panic::InQuery), ());\n+        map.insert(c.spawn(Panic::InQuery), ());\n \n         {\n-            let mut it = map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, SeqCst);\n-                match i {\n-                    0 => true,\n-                    _ => panic!(),\n-                }\n-            });\n+            let mut it = map.drain_filter(|dummy, _| dummy.query(true));\n             catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n             // Iterator behaviour after a panic is explicitly unspecified,\n             // so this is just the current implementation:\n             let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n             assert!(matches!(result, Ok(None)));\n         }\n \n-        assert_eq!(PREDS.load(SeqCst), 0x011);\n-        assert_eq!(DROPS.load(SeqCst), 1);\n+        assert_eq!(a.queried(), 1);\n+        assert_eq!(b.queried(), 1);\n+        assert_eq!(c.queried(), 0);\n+        assert_eq!(a.dropped(), 1);\n+        assert_eq!(b.dropped(), 0);\n+        assert_eq!(c.dropped(), 0);\n         assert_eq!(map.len(), 2);\n-        assert_eq!(map.first_entry().unwrap().key(), &4);\n-        assert_eq!(map.last_entry().unwrap().key(), &8);\n+        assert_eq!(map.first_entry().unwrap().key().id(), 1);\n+        assert_eq!(map.last_entry().unwrap().key().id(), 2);\n         map.check();\n     }\n }\n@@ -1439,6 +1413,43 @@ fn test_bad_zst() {\n     m.check();\n }\n \n+#[test]\n+fn test_clear() {\n+    let mut map = BTreeMap::new();\n+    for &len in &[MIN_INSERTS_HEIGHT_1, MIN_INSERTS_HEIGHT_2, 0, NODE_CAPACITY] {\n+        for i in 0..len {\n+            map.insert(i, ());\n+        }\n+        assert_eq!(map.len(), len);\n+        map.clear();\n+        map.check();\n+        assert!(map.is_empty());\n+    }\n+}\n+\n+#[test]\n+fn test_clear_drop_panic_leak() {\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+\n+    let mut map = BTreeMap::new();\n+    map.insert(a.spawn(Panic::Never), ());\n+    map.insert(b.spawn(Panic::InDrop), ());\n+    map.insert(c.spawn(Panic::Never), ());\n+\n+    catch_unwind(AssertUnwindSafe(|| map.clear())).unwrap_err();\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+    assert_eq!(map.len(), 0);\n+\n+    drop(map);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+}\n+\n #[test]\n fn test_clone() {\n     let mut map = BTreeMap::new();\n@@ -1484,6 +1495,35 @@ fn test_clone() {\n     map.check();\n }\n \n+#[test]\n+fn test_clone_panic_leak() {\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+\n+    let mut map = BTreeMap::new();\n+    map.insert(a.spawn(Panic::Never), ());\n+    map.insert(b.spawn(Panic::InClone), ());\n+    map.insert(c.spawn(Panic::Never), ());\n+\n+    catch_unwind(|| map.clone()).unwrap_err();\n+    assert_eq!(a.cloned(), 1);\n+    assert_eq!(b.cloned(), 1);\n+    assert_eq!(c.cloned(), 0);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 0);\n+    assert_eq!(map.len(), 3);\n+\n+    drop(map);\n+    assert_eq!(a.cloned(), 1);\n+    assert_eq!(b.cloned(), 1);\n+    assert_eq!(c.cloned(), 0);\n+    assert_eq!(a.dropped(), 2);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+}\n+\n #[test]\n fn test_clone_from() {\n     let mut map1 = BTreeMap::new();\n@@ -1901,29 +1941,21 @@ create_append_test!(test_append_1700, 1700);\n \n #[test]\n fn test_append_drop_leak() {\n-    static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-    struct D;\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == 0 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n     let mut left = BTreeMap::new();\n     let mut right = BTreeMap::new();\n-    left.insert(0, D);\n-    left.insert(1, D); // first to be dropped during append\n-    left.insert(2, D);\n-    right.insert(1, D);\n-    right.insert(2, D);\n+    left.insert(a.spawn(Panic::Never), ());\n+    left.insert(b.spawn(Panic::InDrop), ()); // first duplicate key, dropped during append\n+    left.insert(c.spawn(Panic::Never), ());\n+    right.insert(b.spawn(Panic::Never), ());\n+    right.insert(c.spawn(Panic::Never), ());\n \n     catch_unwind(move || left.append(&mut right)).unwrap_err();\n-\n-    assert_eq!(DROPS.load(SeqCst), 4); // Rust issue #47949 ate one little piggy\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1); // should be 2 were it not for Rust issue #47949\n+    assert_eq!(c.dropped(), 2);\n }\n \n #[test]\n@@ -2050,51 +2082,42 @@ fn test_split_off_large_random_sorted() {\n \n #[test]\n fn test_into_iter_drop_leak_height_0() {\n-    static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-    struct D;\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == 3 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+    let d = CrashTestDummy::new(3);\n+    let e = CrashTestDummy::new(4);\n     let mut map = BTreeMap::new();\n-    map.insert(\"a\", D);\n-    map.insert(\"b\", D);\n-    map.insert(\"c\", D);\n-    map.insert(\"d\", D);\n-    map.insert(\"e\", D);\n+    map.insert(\"a\", a.spawn(Panic::Never));\n+    map.insert(\"b\", b.spawn(Panic::Never));\n+    map.insert(\"c\", c.spawn(Panic::Never));\n+    map.insert(\"d\", d.spawn(Panic::InDrop));\n+    map.insert(\"e\", e.spawn(Panic::Never));\n \n     catch_unwind(move || drop(map.into_iter())).unwrap_err();\n \n-    assert_eq!(DROPS.load(SeqCst), 5);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+    assert_eq!(d.dropped(), 1);\n+    assert_eq!(e.dropped(), 1);\n }\n \n #[test]\n fn test_into_iter_drop_leak_height_1() {\n     let size = MIN_INSERTS_HEIGHT_1;\n-    static DROPS: AtomicUsize = AtomicUsize::new(0);\n-    static PANIC_POINT: AtomicUsize = AtomicUsize::new(0);\n-\n-    struct D;\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == PANIC_POINT.load(SeqCst) {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n     for panic_point in vec![0, 1, size - 2, size - 1] {\n-        DROPS.store(0, SeqCst);\n-        PANIC_POINT.store(panic_point, SeqCst);\n-        let map: BTreeMap<_, _> = (0..size).map(|i| (i, D)).collect();\n+        let dummies: Vec<_> = (0..size).map(|i| CrashTestDummy::new(i)).collect();\n+        let map: BTreeMap<_, _> = (0..size)\n+            .map(|i| {\n+                let panic = if i == panic_point { Panic::InDrop } else { Panic::Never };\n+                (dummies[i].spawn(Panic::Never), dummies[i].spawn(panic))\n+            })\n+            .collect();\n         catch_unwind(move || drop(map.into_iter())).unwrap_err();\n-        assert_eq!(DROPS.load(SeqCst), size);\n+        for i in 0..size {\n+            assert_eq!(dummies[i].dropped(), 2);\n+        }\n     }\n }\n "}, {"sha": "421f842dab0acab48510fba28497f55482eb9899", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -20,32 +20,4 @@ trait Recover<Q: ?Sized> {\n }\n \n #[cfg(test)]\n-/// XorShiftRng\n-struct DeterministicRng {\n-    count: usize,\n-    x: u32,\n-    y: u32,\n-    z: u32,\n-    w: u32,\n-}\n-\n-#[cfg(test)]\n-impl DeterministicRng {\n-    fn new() -> Self {\n-        DeterministicRng { count: 0, x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n-    }\n-\n-    /// Guarantees that each returned number is unique.\n-    fn next(&mut self) -> u32 {\n-        self.count += 1;\n-        assert!(self.count <= 70029);\n-        let x = self.x;\n-        let t = x ^ (x << 11);\n-        self.x = self.y;\n-        self.y = self.z;\n-        self.z = self.w;\n-        let w_ = self.w;\n-        self.w = w_ ^ (w_ >> 19) ^ (t ^ (t >> 8));\n-        self.w\n-    }\n-}\n+mod testing;"}, {"sha": "4cb6e3d6619dcb05ac25c1154f3151ee0b1a6343", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 32, "deletions": 57, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -1,10 +1,10 @@\n-use super::super::DeterministicRng;\n+use super::super::testing::crash_test::{CrashTestDummy, Panic};\n+use super::super::testing::rng::DeterministicRng;\n use super::*;\n use crate::vec::Vec;\n use std::cmp::Ordering;\n use std::iter::FromIterator;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::sync::atomic::{AtomicU32, Ordering::SeqCst};\n \n #[test]\n fn test_clone_eq() {\n@@ -349,70 +349,45 @@ fn test_drain_filter() {\n \n #[test]\n fn test_drain_filter_drop_panic_leak() {\n-    static PREDS: AtomicU32 = AtomicU32::new(0);\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    struct D(i32);\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == 1 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n     let mut set = BTreeSet::new();\n-    set.insert(D(0));\n-    set.insert(D(4));\n-    set.insert(D(8));\n+    set.insert(a.spawn(Panic::Never));\n+    set.insert(b.spawn(Panic::InDrop));\n+    set.insert(c.spawn(Panic::Never));\n \n-    catch_unwind(move || {\n-        drop(set.drain_filter(|d| {\n-            PREDS.fetch_add(1u32 << d.0, SeqCst);\n-            true\n-        }))\n-    })\n-    .ok();\n+    catch_unwind(move || drop(set.drain_filter(|dummy| dummy.query(true)))).ok();\n \n-    assert_eq!(PREDS.load(SeqCst), 0x011);\n-    assert_eq!(DROPS.load(SeqCst), 3);\n+    assert_eq!(a.queried(), 1);\n+    assert_eq!(b.queried(), 1);\n+    assert_eq!(c.queried(), 0);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n }\n \n #[test]\n fn test_drain_filter_pred_panic_leak() {\n-    static PREDS: AtomicU32 = AtomicU32::new(0);\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    struct D(i32);\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            DROPS.fetch_add(1, SeqCst);\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n     let mut set = BTreeSet::new();\n-    set.insert(D(0));\n-    set.insert(D(4));\n-    set.insert(D(8));\n-\n-    catch_unwind(AssertUnwindSafe(|| {\n-        drop(set.drain_filter(|d| {\n-            PREDS.fetch_add(1u32 << d.0, SeqCst);\n-            match d.0 {\n-                0 => true,\n-                _ => panic!(),\n-            }\n-        }))\n-    }))\n-    .ok();\n-\n-    assert_eq!(PREDS.load(SeqCst), 0x011);\n-    assert_eq!(DROPS.load(SeqCst), 1);\n+    set.insert(a.spawn(Panic::Never));\n+    set.insert(b.spawn(Panic::InQuery));\n+    set.insert(c.spawn(Panic::InQuery));\n+\n+    catch_unwind(AssertUnwindSafe(|| drop(set.drain_filter(|dummy| dummy.query(true))))).ok();\n+\n+    assert_eq!(a.queried(), 1);\n+    assert_eq!(b.queried(), 1);\n+    assert_eq!(c.queried(), 0);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 0);\n     assert_eq!(set.len(), 2);\n-    assert_eq!(set.first().unwrap().0, 4);\n-    assert_eq!(set.last().unwrap().0, 8);\n+    assert_eq!(set.first().unwrap().id(), 1);\n+    assert_eq!(set.last().unwrap().id(), 2);\n }\n \n #[test]"}, {"sha": "b2527b95f5bba874009a7c5fdc8f82011c8805de", "filename": "library/alloc/src/collections/btree/testing/crash_test.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fcrash_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fcrash_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fcrash_test.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -0,0 +1,119 @@\n+use crate::fmt::Debug;\n+use std::cmp::Ordering;\n+use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+\n+/// A blueprint for crash test dummy instances that monitor particular events.\n+/// Some instances may be configured to panic at some point.\n+/// Events are `clone`, `drop` or some anonymous `query`.\n+///\n+/// Crash test dummies are identified and ordered by an id, so they can be used\n+/// as keys in a BTreeMap. The implementation intentionally uses does not rely\n+/// on anything defined in the crate, apart from the `Debug` trait.\n+#[derive(Debug)]\n+pub struct CrashTestDummy {\n+    id: usize,\n+    cloned: AtomicUsize,\n+    dropped: AtomicUsize,\n+    queried: AtomicUsize,\n+}\n+\n+impl CrashTestDummy {\n+    /// Creates a crash test dummy design. The `id` determines order and equality of instances.\n+    pub fn new(id: usize) -> CrashTestDummy {\n+        CrashTestDummy {\n+            id,\n+            cloned: AtomicUsize::new(0),\n+            dropped: AtomicUsize::new(0),\n+            queried: AtomicUsize::new(0),\n+        }\n+    }\n+\n+    /// Creates an instance of a crash test dummy that records what events it experiences\n+    /// and optionally panics.\n+    pub fn spawn(&self, panic: Panic) -> Instance<'_> {\n+        Instance { origin: self, panic }\n+    }\n+\n+    /// Returns how many times instances of the dummy have been cloned.\n+    pub fn cloned(&self) -> usize {\n+        self.cloned.load(SeqCst)\n+    }\n+\n+    /// Returns how many times instances of the dummy have been dropped.\n+    pub fn dropped(&self) -> usize {\n+        self.dropped.load(SeqCst)\n+    }\n+\n+    /// Returns how many times instances of the dummy have had their `query` member invoked.\n+    pub fn queried(&self) -> usize {\n+        self.queried.load(SeqCst)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Instance<'a> {\n+    origin: &'a CrashTestDummy,\n+    panic: Panic,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Panic {\n+    Never,\n+    InClone,\n+    InDrop,\n+    InQuery,\n+}\n+\n+impl Instance<'_> {\n+    pub fn id(&self) -> usize {\n+        self.origin.id\n+    }\n+\n+    /// Some anonymous query, the result of which is already given.\n+    pub fn query<R>(&self, result: R) -> R {\n+        self.origin.queried.fetch_add(1, SeqCst);\n+        if self.panic == Panic::InQuery {\n+            panic!(\"panic in `query`\");\n+        }\n+        result\n+    }\n+}\n+\n+impl Clone for Instance<'_> {\n+    fn clone(&self) -> Self {\n+        self.origin.cloned.fetch_add(1, SeqCst);\n+        if self.panic == Panic::InClone {\n+            panic!(\"panic in `clone`\");\n+        }\n+        Self { origin: self.origin, panic: Panic::Never }\n+    }\n+}\n+\n+impl Drop for Instance<'_> {\n+    fn drop(&mut self) {\n+        self.origin.dropped.fetch_add(1, SeqCst);\n+        if self.panic == Panic::InDrop {\n+            panic!(\"panic in `drop`\");\n+        }\n+    }\n+}\n+\n+impl PartialOrd for Instance<'_> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.id().partial_cmp(&other.id())\n+    }\n+}\n+\n+impl Ord for Instance<'_> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.id().cmp(&other.id())\n+    }\n+}\n+\n+impl PartialEq for Instance<'_> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.id().eq(&other.id())\n+    }\n+}\n+\n+impl Eq for Instance<'_> {}"}, {"sha": "7a094f8a59522216ad1891e2beac432695737300", "filename": "library/alloc/src/collections/btree/testing/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fmod.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -0,0 +1,3 @@\n+pub mod crash_test;\n+pub mod ord_chaos;\n+pub mod rng;"}, {"sha": "96ce7c15790463b3770285f6395859d64ea9afdc", "filename": "library/alloc/src/collections/btree/testing/ord_chaos.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Ford_chaos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Ford_chaos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Ford_chaos.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "previous_filename": "library/alloc/src/collections/btree/map/tests/ord_chaos.rs"}, {"sha": "ecf543bee035a38a9adc7f08360c5c57876290c7", "filename": "library/alloc/src/collections/btree/testing/rng.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Frng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Frng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Frng.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -0,0 +1,28 @@\n+/// XorShiftRng\n+pub struct DeterministicRng {\n+    count: usize,\n+    x: u32,\n+    y: u32,\n+    z: u32,\n+    w: u32,\n+}\n+\n+impl DeterministicRng {\n+    pub fn new() -> Self {\n+        DeterministicRng { count: 0, x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n+    }\n+\n+    /// Guarantees that each returned number is unique.\n+    pub fn next(&mut self) -> u32 {\n+        self.count += 1;\n+        assert!(self.count <= 70029);\n+        let x = self.x;\n+        let t = x ^ (x << 11);\n+        self.x = self.y;\n+        self.y = self.z;\n+        self.z = self.w;\n+        let w_ = self.w;\n+        self.w = w_ ^ (w_ >> 19) ^ (t ^ (t >> 8));\n+        self.w\n+    }\n+}"}, {"sha": "2103a0d10f4c6cc16be51058fd933f77206e5b8a", "filename": "library/test/src/event.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/library%2Ftest%2Fsrc%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/library%2Ftest%2Fsrc%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fevent.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -24,8 +24,6 @@ impl CompletedTest {\n     }\n }\n \n-unsafe impl Send for CompletedTest {}\n-\n #[derive(Debug, Clone)]\n pub enum TestEvent {\n     TeFiltered(Vec<TestDesc>),"}, {"sha": "5e41d6d9692342067cf405fe971615f28b0bd734", "filename": "library/test/src/formatters/pretty.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -222,10 +222,6 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n     }\n \n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        if self.is_multithreaded {\n-            self.write_test_name(desc)?;\n-        }\n-\n         self.write_plain(&format!(\n             \"test {} has been running for over {} seconds\\n\",\n             desc.name,"}, {"sha": "c5c56ca9c7ff9c57305d49946bdf6fec0b3aaa12", "filename": "library/test/src/test_result.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/library%2Ftest%2Fsrc%2Ftest_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/library%2Ftest%2Fsrc%2Ftest_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftest_result.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -24,8 +24,6 @@ pub enum TestResult {\n     TrTimedFail,\n }\n \n-unsafe impl Send for TestResult {}\n-\n /// Creates a `TestResult` depending on the raw result of test execution\n /// and associated data.\n pub fn calc_result<'a>("}, {"sha": "3216c1af267306cadb87043f9a9cfa9c5ed9f236", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -51,14 +51,40 @@ fn rm_rf(path: &Path) {\n         }\n         Ok(metadata) => {\n             if metadata.file_type().is_file() || metadata.file_type().is_symlink() {\n-                do_op(path, \"remove file\", |p| fs::remove_file(p));\n+                do_op(path, \"remove file\", |p| {\n+                    fs::remove_file(p).or_else(|e| {\n+                        // Work around the fact that we cannot\n+                        // delete an executable while it runs on Windows.\n+                        #[cfg(windows)]\n+                        if e.kind() == std::io::ErrorKind::PermissionDenied\n+                            && p.file_name().and_then(std::ffi::OsStr::to_str)\n+                                == Some(\"bootstrap.exe\")\n+                        {\n+                            eprintln!(\"warning: failed to delete '{}'.\", p.display());\n+                            return Ok(());\n+                        }\n+                        Err(e)\n+                    })\n+                });\n                 return;\n             }\n \n             for file in t!(fs::read_dir(path)) {\n                 rm_rf(&t!(file).path());\n             }\n-            do_op(path, \"remove dir\", |p| fs::remove_dir(p));\n+            do_op(path, \"remove dir\", |p| {\n+                fs::remove_dir(p).or_else(|e| {\n+                    // Check for dir not empty on Windows\n+                    #[cfg(windows)]\n+                    if matches!(e.kind(), std::io::ErrorKind::Other)\n+                        && e.raw_os_error() == Some(145)\n+                    {\n+                        return Ok(());\n+                    }\n+\n+                    Err(e)\n+                })\n+            });\n         }\n     };\n }\n@@ -73,12 +99,18 @@ where\n         // As a result, we have some special logic to remove readonly files on windows.\n         // This is also the reason that we can't use things like fs::remove_dir_all().\n         Err(ref e) if cfg!(windows) && e.kind() == ErrorKind::PermissionDenied => {\n-            let mut p = t!(path.symlink_metadata()).permissions();\n+            let m = t!(path.symlink_metadata());\n+            let mut p = m.permissions();\n             p.set_readonly(false);\n             t!(fs::set_permissions(path, p));\n             f(path).unwrap_or_else(|e| {\n+                // Delete symlinked directories on Windows\n+                #[cfg(windows)]\n+                if m.file_type().is_symlink() && path.is_dir() && fs::remove_dir(path).is_ok() {\n+                    return;\n+                }\n                 panic!(\"failed to {} {}: {}\", desc, path.display(), e);\n-            })\n+            });\n         }\n         Err(e) => {\n             panic!(\"failed to {} {}: {}\", desc, path.display(), e);"}, {"sha": "d21e3408144fea607c598ea6695d479c58e28539", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 63, "deletions": 18, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -3,10 +3,12 @@\n use crate::Build;\n use build_helper::{output, t};\n use ignore::WalkBuilder;\n-use std::path::Path;\n+use std::collections::VecDeque;\n+use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n+use std::sync::mpsc::SyncSender;\n \n-fn rustfmt(src: &Path, rustfmt: &Path, path: &Path, check: bool) {\n+fn rustfmt(src: &Path, rustfmt: &Path, paths: &[PathBuf], check: bool) -> impl FnMut() {\n     let mut cmd = Command::new(&rustfmt);\n     // avoid the submodule config paths from coming into play,\n     // we only allow a single global config for the workspace for now\n@@ -17,17 +19,21 @@ fn rustfmt(src: &Path, rustfmt: &Path, path: &Path, check: bool) {\n     if check {\n         cmd.arg(\"--check\");\n     }\n-    cmd.arg(&path);\n+    cmd.args(paths);\n     let cmd_debug = format!(\"{:?}\", cmd);\n-    let status = cmd.status().expect(\"executing rustfmt\");\n-    if !status.success() {\n-        eprintln!(\n-            \"Running `{}` failed.\\nIf you're running `tidy`, \\\n-            try again with `--bless`. Or, if you just want to format \\\n-            code, run `./x.py fmt` instead.\",\n-            cmd_debug,\n-        );\n-        std::process::exit(1);\n+    let mut cmd = cmd.spawn().expect(\"running rustfmt\");\n+    // poor man's async: return a closure that'll wait for rustfmt's completion\n+    move || {\n+        let status = cmd.wait().unwrap();\n+        if !status.success() {\n+            eprintln!(\n+                \"Running `{}` failed.\\nIf you're running `tidy`, \\\n+                        try again with `--bless`. Or, if you just want to format \\\n+                        code, run `./x.py fmt` instead.\",\n+                cmd_debug,\n+            );\n+            std::process::exit(1);\n+        }\n     }\n }\n \n@@ -101,19 +107,58 @@ pub fn format(build: &Build, check: bool) {\n     }\n     let ignore_fmt = ignore_fmt.build().unwrap();\n \n-    let rustfmt_path = build.config.initial_rustfmt.as_ref().unwrap_or_else(|| {\n-        eprintln!(\"./x.py fmt is not supported on this channel\");\n-        std::process::exit(1);\n+    let rustfmt_path = build\n+        .config\n+        .initial_rustfmt\n+        .as_ref()\n+        .unwrap_or_else(|| {\n+            eprintln!(\"./x.py fmt is not supported on this channel\");\n+            std::process::exit(1);\n+        })\n+        .to_path_buf();\n+    let src = build.src.clone();\n+    let (tx, rx): (SyncSender<PathBuf>, _) = std::sync::mpsc::sync_channel(128);\n+    let walker =\n+        WalkBuilder::new(src.clone()).types(matcher).overrides(ignore_fmt).build_parallel();\n+\n+    // there is a lot of blocking involved in spawning a child process and reading files to format.\n+    // spawn more processes than available concurrency to keep the CPU busy\n+    let max_processes = build.jobs() as usize * 2;\n+\n+    // spawn child processes on a separate thread so we can batch entries we have received from ignore\n+    let thread = std::thread::spawn(move || {\n+        let mut children = VecDeque::new();\n+        while let Ok(path) = rx.recv() {\n+            // try getting a few more paths from the channel to amortize the overhead of spawning processes\n+            let paths: Vec<_> = rx.try_iter().take(7).chain(std::iter::once(path)).collect();\n+\n+            let child = rustfmt(&src, &rustfmt_path, paths.as_slice(), check);\n+            children.push_back(child);\n+\n+            if children.len() >= max_processes {\n+                // await oldest child\n+                children.pop_front().unwrap()();\n+            }\n+        }\n+\n+        // await remaining children\n+        for mut child in children {\n+            child();\n+        }\n     });\n-    let src = &build.src;\n-    let walker = WalkBuilder::new(src).types(matcher).overrides(ignore_fmt).build_parallel();\n+\n     walker.run(|| {\n+        let tx = tx.clone();\n         Box::new(move |entry| {\n             let entry = t!(entry);\n             if entry.file_type().map_or(false, |t| t.is_file()) {\n-                rustfmt(src, &rustfmt_path, &entry.path(), check);\n+                t!(tx.send(entry.into_path()));\n             }\n             ignore::WalkState::Continue\n         })\n     });\n+\n+    drop(tx);\n+\n+    thread.join().unwrap();\n }"}, {"sha": "cb50e0c8f7438776b794cdd6290083781b3aae05", "filename": "src/ci/docker/host-x86_64/mingw-check/Dockerfile", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -17,6 +17,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config \\\n   mingw-w64\n \n+RUN curl -sL https://nodejs.org/dist/v14.4.0/node-v14.4.0-linux-x64.tar.xz | tar -xJ\n+ENV PATH=\"/node-v14.4.0-linux-x64/bin:${PATH}\"\n+# Install es-check\n+RUN npm install es-check -g\n+\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n@@ -29,4 +34,6 @@ ENV SCRIPT python3 ../x.py --stage 2 test src/tools/expand-yaml-anchors && \\\n            python3 ../x.py test --stage 0 src/tools/compiletest && \\\n            python3 ../x.py test --stage 2 src/tools/tidy && \\\n            python3 ../x.py doc --stage 0 library/std && \\\n-           /scripts/validate-toolstate.sh\n+           /scripts/validate-toolstate.sh && \\\n+           # Runs checks to ensure that there are no ES5 issues in our JS code.\n+           es-check es5 ../src/librustdoc/html/static/*.js"}, {"sha": "d21cf334442c84090f2eec83fb9df1a5414b6967", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -153,6 +153,7 @@ not available.\n target | std | host | notes\n -------|-----|------|-------\n `aarch64-apple-ios-macabi` | ? |  | Apple Catalyst on ARM64\n+`aarch64-apple-ios-sim` | ? |  | Apple iOS Simulator on ARM64\n `aarch64-apple-tvos` | * |  | ARM64 tvOS\n `aarch64-unknown-freebsd` | \u2713 | \u2713 | ARM64 FreeBSD\n `aarch64-unknown-hermit` | ? |  |"}, {"sha": "ef6e690e1bd0e03edc6ffbeb3bc76af3bc4dd3c7", "filename": "src/test/ui/try-block/try-block-bad-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.rs?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -3,7 +3,7 @@\n #![feature(try_blocks)]\n \n pub fn main() {\n-    let res: Result<u32, i32> = try {\n+    let res: Result<u32, std::array::TryFromSliceError> = try {\n         Err(\"\")?; //~ ERROR `?` couldn't convert the error\n         5\n     };"}, {"sha": "75a42c0d6b71b9f08103de11072e2aa50054ceb7", "filename": "src/test/ui/try-block/try-block-bad-type.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e826bb11228508fbe749e594038d6727208aa94/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e826bb11228508fbe749e594038d6727208aa94/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr?ref=3e826bb11228508fbe749e594038d6727208aa94", "patch": "@@ -1,16 +1,12 @@\n-error[E0277]: `?` couldn't convert the error to `i32`\n+error[E0277]: `?` couldn't convert the error to `TryFromSliceError`\n   --> $DIR/try-block-bad-type.rs:7:16\n    |\n LL |         Err(\"\")?;\n-   |                ^ the trait `From<&str>` is not implemented for `i32`\n+   |                ^ the trait `From<&str>` is not implemented for `TryFromSliceError`\n    |\n    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\n    = help: the following implementations were found:\n-             <i32 as From<NonZeroI32>>\n-             <i32 as From<bool>>\n-             <i32 as From<i16>>\n-             <i32 as From<i8>>\n-           and 2 others\n+             <TryFromSliceError as From<Infallible>>\n    = note: required by `from`\n \n error[E0271]: type mismatch resolving `<Result<i32, i32> as Try>::Ok == &str`"}]}