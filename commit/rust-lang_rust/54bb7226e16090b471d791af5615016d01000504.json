{"sha": "54bb7226e16090b471d791af5615016d01000504", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YmI3MjI2ZTE2MDkwYjQ3MWQ3OTFhZjU2MTUwMTZkMDEwMDA1MDQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-13T03:04:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-18T23:59:37Z"}, "message": "core: Simplify uvll bindings and strip out currently-unused bits\n\nNo more mapping uv structs to Rust structs", "tree": {"sha": "00de9ddf0a60a6ef906bbd3a15045f239b918f96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00de9ddf0a60a6ef906bbd3a15045f239b918f96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54bb7226e16090b471d791af5615016d01000504", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54bb7226e16090b471d791af5615016d01000504", "html_url": "https://github.com/rust-lang/rust/commit/54bb7226e16090b471d791af5615016d01000504", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54bb7226e16090b471d791af5615016d01000504/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "723d2247c1e310a49dd49afc80e7c8a153bd1432", "url": "https://api.github.com/repos/rust-lang/rust/commits/723d2247c1e310a49dd49afc80e7c8a153bd1432", "html_url": "https://github.com/rust-lang/rust/commit/723d2247c1e310a49dd49afc80e7c8a153bd1432"}], "stats": {"total": 2160, "additions": 372, "deletions": 1788}, "files": [{"sha": "8280359eb2bfc1a12a93fb7489f94e46e69a0da5", "filename": "src/libcore/rt/uv.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/54bb7226e16090b471d791af5615016d01000504/src%2Flibcore%2Frt%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54bb7226e16090b471d791af5615016d01000504/src%2Flibcore%2Frt%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv.rs?ref=54bb7226e16090b471d791af5615016d01000504", "patch": "@@ -44,21 +44,28 @@ use cast::{transmute, transmute_mut_region};\n use ptr::null;\n use sys::size_of;\n use super::uvll;\n+use super::uvll::*;\n use super::io::{IpAddr, Ipv4, Ipv6};\n+use unstable::finally::Finally;\n \n #[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use super::thread::Thread;\n #[cfg(test)] use cell::Cell;\n \n-fn ip4_to_uv_ip4(addr: IpAddr) -> uvll::sockaddr_in {\n+fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n     match addr {\n         Ipv4(a, b, c, d, p) => {\n             unsafe {\n-                uvll::ip4_addr(fmt!(\"%u.%u.%u.%u\",\n-                                    a as uint,\n-                                    b as uint,\n-                                    c as uint,\n-                                    d as uint), p as int)\n+                let addr = malloc_ip4_addr(fmt!(\"%u.%u.%u.%u\",\n+                                                a as uint,\n+                                                b as uint,\n+                                                c as uint,\n+                                                d as uint), p as int);\n+                do (|| {\n+                    f(addr);\n+                }).finally {\n+                    free_ip4_addr(addr);\n+                }\n             }\n         }\n         Ipv6 => fail!()\n@@ -301,7 +308,7 @@ pub impl StreamWatcher {\n                 data.close_cb.swap_unwrap()();\n             }\n             drop_watcher_data(&mut stream_watcher);\n-            unsafe { free(handle as *c_void) }\n+            unsafe { free_handle(handle as *c_void) }\n         }\n     }\n }\n@@ -330,8 +337,7 @@ impl Callback for ConnectionCallback { }\n pub impl TcpWatcher {\n     static fn new(loop_: &mut Loop) -> TcpWatcher {\n         unsafe {\n-            let size = size_of::<uvll::uv_tcp_t>() as size_t;\n-            let handle = malloc(size) as *uvll::uv_tcp_t;\n+            let handle = malloc_handle(UV_TCP);\n             fail_unless!(handle.is_not_null());\n             fail_unless!(0 == uvll::tcp_init(loop_.native_handle(), handle));\n             let mut watcher = NativeHandle::from_native_handle(handle);\n@@ -343,12 +349,13 @@ pub impl TcpWatcher {\n     fn bind(&mut self, address: IpAddr) {\n         match address {\n             Ipv4(*) => {\n-                let addr = ip4_to_uv_ip4(address);\n-                let result = unsafe {\n-                    uvll::tcp_bind(self.native_handle(), &addr)\n-                };\n-                // XXX: bind is likely to fail. need real error handling\n-                fail_unless!(result == 0);\n+                do ip4_as_uv_ip4(address) |addr| {\n+                    let result = unsafe {\n+                        uvll::tcp_bind(self.native_handle(), addr)\n+                    };\n+                    // XXX: bind is likely to fail. need real error handling\n+                    fail_unless!(result == 0);\n+                }\n             }\n             _ => fail!()\n         }\n@@ -363,11 +370,12 @@ pub impl TcpWatcher {\n             let connect_handle = connect_watcher.native_handle();\n             match address {\n                 Ipv4(*) => {\n-                    let addr = ip4_to_uv_ip4(address);\n-                    rtdebug!(\"connect_t: %x\", connect_handle as uint);\n-                    fail_unless!(0 == uvll::tcp_connect(connect_handle,\n-                                                        self.native_handle(),\n-                                                        &addr, connect_cb));\n+                    do ip4_as_uv_ip4(address) |addr| {\n+                        rtdebug!(\"connect_t: %x\", connect_handle as uint);\n+                        fail_unless!(0 == uvll::tcp_connect(connect_handle,\n+                                                            self.native_handle(),\n+                                                            addr, connect_cb));\n+                    }\n                 }\n                 _ => fail!()\n             }\n@@ -443,7 +451,7 @@ impl ConnectRequest {\n \n     static fn new() -> ConnectRequest {\n         let connect_handle = unsafe {\n-            malloc(size_of::<uvll::uv_connect_t>() as size_t)\n+            malloc_req(UV_CONNECT)\n         };\n         fail_unless!(connect_handle.is_not_null());\n         let connect_handle = connect_handle as *uvll::uv_connect_t;\n@@ -460,7 +468,7 @@ impl ConnectRequest {\n     }\n \n     fn delete(self) {\n-        unsafe { free(self.native_handle() as *c_void) }\n+        unsafe { free_req(self.native_handle() as *c_void) }\n     }\n }\n \n@@ -482,7 +490,7 @@ impl WriteRequest {\n \n     static fn new() -> WriteRequest {\n         let write_handle = unsafe {\n-            malloc(size_of::<uvll::uv_write_t>() as size_t)\n+            malloc_req(UV_WRITE)\n         };\n         fail_unless!(write_handle.is_not_null());\n         let write_handle = write_handle as *uvll::uv_write_t;\n@@ -498,7 +506,7 @@ impl WriteRequest {\n     }\n \n     fn delete(self) {\n-        unsafe { free(self.native_handle() as *c_void) }\n+        unsafe { free_req(self.native_handle() as *c_void) }\n     }\n }\n "}, {"sha": "1332ddf112732c05065327113cdfd0814b3600f8", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 283, "deletions": 1746, "changes": 2029, "blob_url": "https://github.com/rust-lang/rust/blob/54bb7226e16090b471d791af5615016d01000504/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54bb7226e16090b471d791af5615016d01000504/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=54bb7226e16090b471d791af5615016d01000504", "patch": "@@ -14,1190 +14,356 @@\n  * This module contains a set of direct, 'bare-metal' wrappers around\n  * the libuv C-API.\n  *\n- * Also contained herein are a set of rust records that map, in\n- * approximate memory-size, to the libuv data structures. The record\n- * implementations are adjusted, per-platform, to match their respective\n- * representations.\n+ * We're not bothering yet to redefine uv's structs as Rust structs\n+ * because they are quite large and change often between versions.\n+ * The maintenance burden is just too high. Instead we use the uv's\n+ * `uv_handle_size` and `uv_req_size` to find the correct size of the\n+ * structs and allocate them on the heap. This can be revisited later.\n  *\n  * There are also a collection of helper functions to ease interacting\n- * with the low-level API (such as a function to return the latest\n- * libuv error as a rust-formatted string).\n+ * with the low-level API.\n  *\n  * As new functionality, existant in uv.h, is added to the rust stdlib,\n  * the mappings should be added in this module.\n- *\n- * This module's implementation will hopefully be, eventually, replaced\n- * with per-platform, generated source files from rust-bindgen.\n  */\n \n #[allow(non_camel_case_types)]; // C types\n \n-use libc::size_t;\n-use libc::c_void;\n+use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n+use libc::{malloc, free};\n use prelude::*;\n use ptr::to_unsafe_ptr;\n \n+pub struct uv_err_t {\n+    code: c_int,\n+    sys_errno_: c_int\n+}\n+\n+pub struct uv_buf_t {\n+    base: *u8,\n+    len: libc::size_t,\n+}\n+\n pub type uv_handle_t = c_void;\n pub type uv_loop_t = c_void;\n pub type uv_idle_t = c_void;\n+pub type uv_tcp_t = c_void;\n+pub type uv_connect_t = c_void;\n+pub type uv_write_t = c_void;\n+pub type uv_async_t = c_void;\n+pub type uv_timer_t = c_void;\n+pub type uv_stream_t = c_void;\n+\n pub type uv_idle_cb = *u8;\n \n-// libuv struct mappings\n-pub struct uv_ip4_addr {\n-    ip: ~[u8],\n-    port: int,\n-}\n-pub type uv_ip6_addr = uv_ip4_addr;\n+pub type sockaddr_in = c_void;\n+pub type sockaddr_in6 = c_void;\n \n+#[deriving_eq]\n pub enum uv_handle_type {\n-    UNKNOWN_HANDLE = 0,\n-    UV_TCP,\n-    UV_UDP,\n-    UV_NAMED_PIPE,\n-    UV_TTY,\n-    UV_FILE,\n-    UV_TIMER,\n-    UV_PREPARE,\n+    UV_UNKNOWN_HANDLE,\n+    UV_ASYNC,\n     UV_CHECK,\n+    UV_FS_EVENT,\n+    UV_FS_POLL,\n+    UV_HANDLE,\n     UV_IDLE,\n-    UV_ASYNC,\n-    UV_ARES_TASK,\n-    UV_ARES_EVENT,\n+    UV_NAMED_PIPE,\n+    UV_POLL,\n+    UV_PREPARE,\n     UV_PROCESS,\n-    UV_FS_EVENT\n-}\n-\n-pub type handle_type = libc::c_uint;\n-\n-pub struct uv_handle_fields {\n-   loop_handle: *libc::c_void,\n-   type_: handle_type,\n-   close_cb: *u8,\n-   data: *libc::c_void,\n-}\n-\n-// unix size: 8\n-pub struct uv_err_t {\n-    code: libc::c_int,\n-    sys_errno_: libc::c_int\n-}\n-\n-// don't create one of these directly. instead,\n-// count on it appearing in libuv callbacks or embedded\n-// in other types as a pointer to be used in other\n-// operations (so mostly treat it as opaque, once you\n-// have it in this form..)\n-pub struct uv_stream_t {\n-    fields: uv_handle_fields,\n-}\n-\n-// 64bit unix size: 216\n-#[cfg(target_os=\"macos\")]\n-pub struct uv_tcp_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n-    a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n-    a20: *u8, a21: *u8, a22: *u8,\n-    a23: uv_tcp_t_osx_riders\n-}\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct uv_tcp_t_osx_riders {\n-    a23: *u8,\n-}\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-pub struct uv_tcp_t_osx_riders {\n-    a23: *u8,\n-    a24: *u8, a25: *u8,\n-}\n-#[cfg(target_os=\"linux\")]\n-#[cfg(target_os=\"freebsd\")]\n-#[cfg(target_os=\"android\")]\n-pub struct uv_tcp_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n-    a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n-    a20: *u8, a21: *u8,\n-    a22: uv_tcp_t_32bit_unix_riders,\n-}\n-// 32bit unix size: 328 (164)\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct uv_tcp_t_32bit_unix_riders {\n-    a29: *u8,\n-}\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-pub struct uv_tcp_t_32bit_unix_riders {\n-    a29: *u8, a30: *u8, a31: *u8,\n-}\n-\n-// 32bit win32 size: 240 (120)\n-#[cfg(windows)]\n-pub struct uv_tcp_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n-    a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n-    a20: *u8, a21: *u8, a22: *u8, a23: *u8,\n-    a24: *u8, a25: *u8,\n-}\n-\n-// unix size: 64\n-#[cfg(unix)]\n-pub struct uv_connect_t {\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8\n-}\n-// win32 size: 88 (44)\n-#[cfg(windows)]\n-pub struct uv_connect_t {\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8,\n-}\n-\n-// unix size: 16\n-pub struct uv_buf_t {\n-    base: *u8,\n-    len: libc::size_t,\n+    UV_STREAM,\n+    UV_TCP,\n+    UV_TIMER,\n+    UV_TTY,\n+    UV_UDP,\n+    UV_SIGNAL,\n+    UV_FILE,\n+    UV_HANDLE_TYPE_MAX\n }\n-// no gen stub method.. should create\n-// it via uv::direct::buf_init()\n \n-// unix size: 160\n-#[cfg(unix)]\n-pub struct uv_write_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8,\n-    a14: uv_write_t_32bit_unix_riders,\n-}\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct uv_write_t_32bit_unix_riders {\n-    a13: *u8, a14: *u8, a15: *u8\n-}\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-pub struct uv_write_t_32bit_unix_riders {\n-    a13: *u8, a14: *u8, a15: *u8,\n-    a16: *u8,\n-}\n-// win32 size: 136 (68)\n-#[cfg(windows)]\n-pub struct uv_write_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8,\n-}\n-// 64bit unix size: 96\n-// 32bit unix size: 152 (76)\n-#[cfg(unix)]\n-pub struct uv_async_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8,\n-    a07: uv_async_t_32bit_unix_riders,\n-}\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct uv_async_t_32bit_unix_riders {\n-    a10: *u8,\n-}\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-pub struct uv_async_t_32bit_unix_riders {\n-    a10: *u8,\n-}\n-// win32 size 132 (68)\n-#[cfg(windows)]\n-pub struct uv_async_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8,\n+#[deriving_eq]\n+pub enum uv_req_type {\n+    UV_UNKNOWN_REQ,\n+    UV_REQ,\n+    UV_CONNECT,\n+    UV_WRITE,\n+    UV_SHUTDOWN,\n+    UV_UDP_SEND,\n+    UV_FS,\n+    UV_WORK,\n+    UV_GETADDRINFO,\n+    UV_REQ_TYPE_MAX\n }\n \n-// 64bit unix size: 120\n-// 32bit unix size: 84\n-#[cfg(unix)]\n-pub struct uv_timer_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8,\n-    a11: uv_timer_t_32bit_unix_riders,\n-}\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct uv_timer_t_32bit_unix_riders {\n-    a10: *u8,\n-}\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-pub struct uv_timer_t_32bit_unix_riders {\n-    a10: *u8, a11: *u8, a12: *u8\n-}\n-// win32 size: 64\n-#[cfg(windows)]\n-pub struct uv_timer_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n+pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n+    fail_unless!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n+    let size = unsafe { rust_uv_handle_size(handle as uint) };\n+    let p = malloc(size);\n+    fail_unless!(p.is_not_null());\n+    return p;\n }\n \n-// unix size: 16\n-pub struct sockaddr_in {\n-    sin_family: u16,\n-    sin_port: u16,\n-    sin_addr: u32, // in_addr: this is an opaque, per-platform struct\n-    sin_zero: (u8, u8, u8, u8, u8, u8, u8, u8),\n+pub unsafe fn free_handle(v: *c_void) {\n+    free(v)\n }\n \n-// unix size: 28 .. FIXME #1645\n-// stuck with 32 becuse of rust padding structs?\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct sockaddr_in6 {\n-    a0: *u8, a1: *u8,\n-    a2: *u8, a3: *u8,\n-}\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-pub struct sockaddr_in6 {\n-    a0: *u8, a1: *u8,\n-    a2: *u8, a3: *u8,\n-    a4: *u8, a5: *u8,\n-    a6: *u8, a7: *u8,\n+pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n+    fail_unless!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n+    let size = unsafe { rust_uv_req_size(req as uint) };\n+    let p = malloc(size);\n+    fail_unless!(p.is_not_null());\n+    return p;\n }\n \n-// unix size: 28 .. FIXME #1645\n-// stuck with 32 becuse of rust padding structs?\n-pub type addr_in = addr_in_impl::addr_in;\n-#[cfg(unix)]\n-pub mod addr_in_impl {\n-    #[cfg(target_arch=\"x86_64\")]\n-    pub struct addr_in {\n-        a0: *u8, a1: *u8,\n-        a2: *u8, a3: *u8,\n-    }\n-    #[cfg(target_arch=\"x86\")]\n-    #[cfg(target_arch=\"arm\")]\n-    #[cfg(target_arch=\"mips\")]\n-    pub struct addr_in {\n-        a0: *u8, a1: *u8,\n-        a2: *u8, a3: *u8,\n-        a4: *u8, a5: *u8,\n-        a6: *u8, a7: *u8,\n-    }\n-}\n-#[cfg(windows)]\n-pub mod addr_in_impl {\n-    pub struct addr_in {\n-        a0: *u8, a1: *u8,\n-        a2: *u8, a3: *u8,\n-    }\n+pub unsafe fn free_req(v: *c_void) {\n+    free(v)\n }\n \n-// unix size: 48, 32bit: 32\n-pub type addrinfo = addrinfo_impl::addrinfo;\n-#[cfg(target_os=\"linux\")]\n-#[cfg(target_os=\"android\")]\n-pub mod addrinfo_impl {\n-    #[cfg(target_arch=\"x86_64\")]\n-    pub struct addrinfo {\n-        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8,\n-    }\n-    #[cfg(target_arch=\"x86\")]\n-    #[cfg(target_arch=\"arm\")]\n-    #[cfg(target_arch=\"mips\")]\n-    pub struct addrinfo {\n-        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    }\n-}\n-#[cfg(target_os=\"macos\")]\n-#[cfg(target_os=\"freebsd\")]\n-pub mod addrinfo_impl {\n-    pub struct addrinfo {\n-        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8,\n-    }\n-}\n-#[cfg(windows)]\n-pub mod addrinfo_impl {\n-    pub struct addrinfo {\n-        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8,\n+#[test]\n+fn handle_sanity_check() {\n+    unsafe {\n+        fail_unless!(UV_HANDLE_TYPE_MAX as uint == rust_uv_handle_type_max());\n     }\n }\n \n-// unix size: 72\n-pub struct uv_getaddrinfo_t {\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8, a04: *u8, a05: *u8,\n-    a06: *u8, a07: *u8, a08: *u8, a09: *u8,\n-    a10: *u8, a11: *u8, a12: *u8, a13: *u8, a14: *u8, a15: *u8\n-}\n-\n-pub mod uv_ll_struct_stubgen {\n-\n-    use ptr;\n-\n-    use super::{\n-        uv_async_t,\n-        uv_connect_t,\n-        uv_getaddrinfo_t,\n-        uv_handle_fields,\n-        uv_tcp_t,\n-        uv_timer_t,\n-        uv_write_t,\n-    };\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"android\")]\n-    #[cfg(target_os = \"macos\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    use super::{\n-        uv_async_t_32bit_unix_riders,\n-        uv_tcp_t_32bit_unix_riders,\n-        uv_timer_t_32bit_unix_riders,\n-        uv_write_t_32bit_unix_riders,\n-    };\n-\n-    pub fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n-        return gen_stub_os();\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        pub fn gen_stub_os() -> uv_tcp_t {\n-            return gen_stub_arch();\n-            #[cfg(target_arch=\"x86_64\")]\n-            pub fn gen_stub_arch() -> uv_tcp_t {\n-                uv_tcp_t {\n-                    fields: uv_handle_fields {\n-                        loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        data: ptr::null(),\n-                    },\n-                    a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                    a03: 0 as *u8,\n-                    a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                    a07: 0 as *u8,\n-                    a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                    a11: 0 as *u8,\n-                    a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n-                    a15: 0 as *u8,\n-                    a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n-                    a19: 0 as *u8,\n-                    a20: 0 as *u8, a21: 0 as *u8,\n-                    a22: uv_tcp_t_32bit_unix_riders { a29: 0 as *u8 },\n-                }\n-            }\n-            #[cfg(target_arch=\"x86\")]\n-            #[cfg(target_arch=\"arm\")]\n-            #[cfg(target_arch=\"mips\")]\n-            pub fn gen_stub_arch() -> uv_tcp_t {\n-                uv_tcp_t {\n-                    fields: uv_handle_fields {\n-                        loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        data: ptr::null(),\n-                    },\n-                    a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                    a03: 0 as *u8,\n-                    a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                    a07: 0 as *u8,\n-                    a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                    a11: 0 as *u8,\n-                    a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n-                    a15: 0 as *u8,\n-                    a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n-                    a19: 0 as *u8,\n-                    a20: 0 as *u8, a21: 0 as *u8,\n-                    a22: uv_tcp_t_32bit_unix_riders {\n-                        a29: 0 as *u8, a30: 0 as *u8, a31: 0 as *u8,\n-                    },\n-                }\n-            }\n-        }\n-        #[cfg(windows)]\n-        pub fn gen_stub_os() -> uv_tcp_t {\n-            uv_tcp_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: 0 as *u8,\n-                a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                a11: 0 as *u8,\n-                a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n-                a15: 0 as *u8,\n-                a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n-                a19: 0 as *u8,\n-                a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8,\n-                a23: 0 as *u8,\n-                a24: 0 as *u8, a25: 0 as *u8,\n-            }\n-        }\n-        #[cfg(target_os = \"macos\")]\n-        pub fn gen_stub_os() -> uv_tcp_t {\n-            use super::uv_tcp_t_osx_riders;\n-\n-            return gen_stub_arch();\n-\n-            #[cfg(target_arch = \"x86_64\")]\n-            fn gen_stub_arch() -> uv_tcp_t {\n-                uv_tcp_t {\n-                    fields: uv_handle_fields {\n-                        loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        data: ptr::null(),\n-                    },\n-                    a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                    a03: 0 as *u8,\n-                    a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                    a07: 0 as *u8,\n-                    a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                    a11: 0 as *u8,\n-                    a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n-                    a15: 0 as *u8,\n-                    a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n-                    a19: 0 as *u8,\n-                    a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8,\n-                    a23: uv_tcp_t_osx_riders {\n-                        a23: 0 as *u8,\n-                    }\n-                }\n-            }\n-\n-            #[cfg(target_arch = \"x86\")]\n-            #[cfg(target_arch = \"arm\")]\n-            fn gen_stub_arch() -> uv_tcp_t {\n-                uv_tcp_t {\n-                    fields: uv_handle_fields {\n-                        loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        data: ptr::null(),\n-                    },\n-                    a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                    a03: 0 as *u8,\n-                    a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                    a07: 0 as *u8,\n-                    a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                    a11: 0 as *u8,\n-                    a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n-                    a15: 0 as *u8,\n-                    a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n-                    a19: 0 as *u8,\n-                    a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8,\n-                    a23: uv_tcp_t_osx_riders {\n-                        a23: 0 as *u8,\n-                        a24: 0 as *u8, a25: 0 as *u8,\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(unix)]\n-    pub fn gen_stub_uv_connect_t() -> uv_connect_t {\n-        uv_connect_t {\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-            a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-            a07: 0 as *u8\n-        }\n-    }\n-    #[cfg(windows)]\n-    pub fn gen_stub_uv_connect_t() -> uv_connect_t {\n-        uv_connect_t {\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-            a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-            a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-        }\n-    }\n-    #[cfg(unix)]\n-    pub fn gen_stub_uv_async_t() -> uv_async_t {\n-        return gen_stub_arch();\n-        #[cfg(target_arch = \"x86_64\")]\n-        pub fn gen_stub_arch() -> uv_async_t {\n-            uv_async_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: uv_async_t_32bit_unix_riders { a10: 0 as *u8 },\n-            }\n-        }\n-        #[cfg(target_arch = \"x86\")]\n-        #[cfg(target_arch=\"arm\")]\n-        #[cfg(target_arch=\"mips\")]\n-        pub fn gen_stub_arch() -> uv_async_t {\n-            uv_async_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: uv_async_t_32bit_unix_riders {\n-                    a10: 0 as *u8,\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(windows)]\n-    pub fn gen_stub_uv_async_t() -> uv_async_t {\n-        uv_async_t {\n-            fields: uv_handle_fields {\n-                loop_handle: ptr::null(), type_: 0u32,\n-                close_cb: ptr::null(),\n-                data: ptr::null(),\n-            },\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-            a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-            a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-            a11: 0 as *u8,\n-            a12: 0 as *u8,\n-        }\n-    }\n-    #[cfg(unix)]\n-    pub fn gen_stub_uv_timer_t() -> uv_timer_t {\n-        return gen_stub_arch();\n-        #[cfg(target_arch = \"x86_64\")]\n-        pub fn gen_stub_arch() -> uv_timer_t {\n-            uv_timer_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: 0 as *u8,\n-                a08: 0 as *u8, a09: 0 as *u8,\n-                a11: uv_timer_t_32bit_unix_riders {\n-                    a10: 0 as *u8\n-                },\n-            }\n-        }\n-        #[cfg(target_arch = \"x86\")]\n-        #[cfg(target_arch=\"arm\")]\n-        #[cfg(target_arch=\"mips\")]\n-        pub fn gen_stub_arch() -> uv_timer_t {\n-            uv_timer_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: 0 as *u8,\n-                a08: 0 as *u8, a09: 0 as *u8,\n-                a11: uv_timer_t_32bit_unix_riders {\n-                    a10: 0 as *u8, a11: 0 as *u8,\n-                    a12: 0 as *u8,\n-                },\n-            }\n-        }\n+#[test]\n+fn request_sanity_check() {\n+    unsafe {\n+        fail_unless!(UV_REQ_TYPE_MAX as uint == rust_uv_req_type_max());\n     }\n-    #[cfg(windows)]\n-    pub fn gen_stub_uv_timer_t() -> uv_timer_t {\n-        uv_timer_t {\n-            fields: uv_handle_fields {\n-                loop_handle: ptr::null(), type_: 0u32,\n-                close_cb: ptr::null(),\n-                data: ptr::null(),\n-            },\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-            a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-            a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-            a11: 0 as *u8,\n-        }\n-    }\n-    #[cfg(unix)]\n-    pub fn gen_stub_uv_write_t() -> uv_write_t {\n-        return gen_stub_arch();\n-        #[cfg(target_arch=\"x86_64\")]\n-        pub fn gen_stub_arch() -> uv_write_t {\n-            uv_write_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: 0 as *u8,\n-                a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                a11: 0 as *u8,\n-                a12: 0 as *u8,\n-                a14: uv_write_t_32bit_unix_riders { a13: 0 as *u8,\n-                                                   a14: 0 as *u8,\n-                                                   a15: 0 as *u8},\n-            }\n-        }\n-        #[cfg(target_arch=\"x86\")]\n-        #[cfg(target_arch=\"arm\")]\n-        #[cfg(target_arch=\"mips\")]\n-        pub fn gen_stub_arch() -> uv_write_t {\n-            uv_write_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: 0 as *u8,\n-                a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                a11: 0 as *u8,\n-                a12: 0 as *u8,\n-                a14: uv_write_t_32bit_unix_riders {\n-                    a13: 0 as *u8,\n-                    a14: 0 as *u8,\n-                    a15: 0 as *u8,\n-                    a16: 0 as *u8,\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(windows)]\n-    pub fn gen_stub_uv_write_t() -> uv_write_t {\n-        uv_write_t {\n-            fields: uv_handle_fields {\n-                loop_handle: ptr::null(), type_: 0u32,\n-                close_cb: ptr::null(),\n-                data: ptr::null(),\n-            },\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-            a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-            a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-            a11: 0 as *u8,\n-            a12: 0 as *u8\n-        }\n-    }\n-    pub fn gen_stub_uv_getaddrinfo_t() -> uv_getaddrinfo_t {\n-        uv_getaddrinfo_t {\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8,\n-            a10: 1 as *u8, a11: 1 as *u8, a12: 1 as *u8, a13: 1 as *u8,\n-            a14: 1 as *u8, a15: 1 as *u8\n-        }\n-    }\n-}\n-\n-#[nolink]\n-extern mod rustrt {\n-\n-    // libuv public API\n-    unsafe fn rust_uv_loop_new() -> *libc::c_void;\n-    unsafe fn rust_uv_loop_delete(lp: *libc::c_void);\n-    unsafe fn rust_uv_run(loop_handle: *libc::c_void);\n-    unsafe fn rust_uv_close(handle: *libc::c_void, cb: *u8);\n-    unsafe fn rust_uv_walk(loop_handle: *libc::c_void, cb: *u8,\n-                           arg: *libc::c_void);\n-\n-    unsafe fn rust_uv_idle_new() -> *uv_idle_t;\n-    unsafe fn rust_uv_idle_delete(handle: *uv_idle_t);\n-    unsafe fn rust_uv_idle_init(loop_handle: *uv_loop_t,\n-                                handle: *uv_idle_t) -> libc::c_int;\n-    unsafe fn rust_uv_idle_start(handle: *uv_idle_t,\n-                                 cb: uv_idle_cb) -> libc::c_int;\n-    unsafe fn rust_uv_idle_stop(handle: *uv_idle_t) -> libc::c_int;\n-\n-    unsafe fn rust_uv_async_send(handle: *uv_async_t);\n-    unsafe fn rust_uv_async_init(loop_handle: *libc::c_void,\n-                          async_handle: *uv_async_t,\n-                          cb: *u8) -> libc::c_int;\n-    unsafe fn rust_uv_tcp_init(\n-        loop_handle: *libc::c_void,\n-        handle_ptr: *uv_tcp_t) -> libc::c_int;\n-    // FIXME ref #2604 .. ?\n-    unsafe fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8,\n-                        len: libc::size_t);\n-    unsafe fn rust_uv_last_error(loop_handle: *libc::c_void) -> uv_err_t;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_strerror(err: *uv_err_t) -> *libc::c_char;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_err_name(err: *uv_err_t) -> *libc::c_char;\n-    unsafe fn rust_uv_ip4_addr(ip: *u8, port: libc::c_int)\n-        -> sockaddr_in;\n-    unsafe fn rust_uv_ip6_addr(ip: *u8, port: libc::c_int)\n-        -> sockaddr_in6;\n-    unsafe fn rust_uv_ip4_name(src: *sockaddr_in,\n-                               dst: *u8,\n-                               size: libc::size_t)\n-                            -> libc::c_int;\n-    unsafe fn rust_uv_ip6_name(src: *sockaddr_in6,\n-                               dst: *u8,\n-                               size: libc::size_t)\n-                            -> libc::c_int;\n-    unsafe fn rust_uv_ip4_port(src: *sockaddr_in) -> libc::c_uint;\n-    unsafe fn rust_uv_ip6_port(src: *sockaddr_in6) -> libc::c_uint;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n-                                  tcp_handle_ptr: *uv_tcp_t,\n-                                  ++after_cb: *u8,\n-                                  ++addr: *sockaddr_in) -> libc::c_int;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n-                               ++addr: *sockaddr_in) -> libc::c_int;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n-                                   tcp_handle_ptr: *uv_tcp_t,\n-                                   ++after_cb: *u8,\n-                                   ++addr: *sockaddr_in6) -> libc::c_int;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t,\n-                                ++addr: *sockaddr_in6) -> libc::c_int;\n-    unsafe fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n-                                      ++name: *sockaddr_in) -> libc::c_int;\n-    unsafe fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n-                                       ++name: *sockaddr_in6) ->libc::c_int;\n-    unsafe fn rust_uv_listen(stream: *libc::c_void,\n-                             backlog: libc::c_int,\n-                             cb: *u8) -> libc::c_int;\n-    unsafe fn rust_uv_accept(server: *libc::c_void, client: *libc::c_void)\n-                          -> libc::c_int;\n-    unsafe fn rust_uv_write(req: *libc::c_void,\n-                            stream: *libc::c_void,\n-                            ++buf_in: *uv_buf_t,\n-                            buf_cnt: libc::c_int,\n-                            cb: *u8)\n-        -> libc::c_int;\n-    unsafe fn rust_uv_read_start(stream: *libc::c_void,\n-                                 on_alloc: *u8,\n-                                 on_read: *u8)\n-        -> libc::c_int;\n-    unsafe fn rust_uv_read_stop(stream: *libc::c_void) -> libc::c_int;\n-    unsafe fn rust_uv_timer_init(loop_handle: *libc::c_void,\n-                                 timer_handle: *uv_timer_t)\n-        -> libc::c_int;\n-    unsafe fn rust_uv_timer_start(\n-        timer_handle: *uv_timer_t,\n-        cb: *u8,\n-        timeout: libc::c_uint,\n-        repeat: libc::c_uint) -> libc::c_int;\n-    unsafe fn rust_uv_timer_stop(handle: *uv_timer_t) -> libc::c_int;\n-\n-    unsafe fn rust_uv_getaddrinfo(loop_ptr: *libc::c_void,\n-                                  handle: *uv_getaddrinfo_t,\n-                                  cb: *u8,\n-                                  node_name_ptr: *u8,\n-                                  service_name_ptr: *u8,\n-                                  // should probably only pass ptr::null()\n-                                  hints: *addrinfo)\n-        -> libc::c_int;\n-    unsafe fn rust_uv_freeaddrinfo(res: *addrinfo);\n-\n-    // data accessors/helpers for rust-mapped uv structs\n-    unsafe fn rust_uv_helper_get_INADDR_NONE() -> u32;\n-    unsafe fn rust_uv_is_ipv4_addrinfo(input: *addrinfo) -> bool;\n-    unsafe fn rust_uv_is_ipv6_addrinfo(input: *addrinfo) -> bool;\n-    unsafe fn rust_uv_get_next_addrinfo(input: *addrinfo) -> *addrinfo;\n-    unsafe fn rust_uv_addrinfo_as_sockaddr_in(input: *addrinfo)\n-        -> *sockaddr_in;\n-    unsafe fn rust_uv_addrinfo_as_sockaddr_in6(input: *addrinfo)\n-        -> *sockaddr_in6;\n-    unsafe fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n-    unsafe fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n-    unsafe fn rust_uv_get_stream_handle_from_connect_req(\n-        connect_req: *uv_connect_t)\n-        -> *uv_stream_t;\n-    unsafe fn rust_uv_get_stream_handle_from_write_req(\n-        write_req: *uv_write_t)\n-        -> *uv_stream_t;\n-    unsafe fn rust_uv_get_loop_for_uv_handle(handle: *libc::c_void)\n-        -> *libc::c_void;\n-    unsafe fn rust_uv_get_data_for_uv_loop(loop_ptr: *libc::c_void)\n-        -> *libc::c_void;\n-    unsafe fn rust_uv_set_data_for_uv_loop(loop_ptr: *libc::c_void,\n-                                           data: *libc::c_void);\n-    unsafe fn rust_uv_get_data_for_uv_handle(handle: *libc::c_void)\n-        -> *libc::c_void;\n-    unsafe fn rust_uv_set_data_for_uv_handle(handle: *libc::c_void,\n-                                             data: *libc::c_void);\n-    unsafe fn rust_uv_get_data_for_req(req: *libc::c_void)\n-        -> *libc::c_void;\n-    unsafe fn rust_uv_set_data_for_req(req: *libc::c_void,\n-                                       data: *libc::c_void);\n-    unsafe fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n-    unsafe fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n-\n-    // sizeof testing helpers\n-    unsafe fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_connect_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_buf_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_write_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_sockaddr_in6_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_async_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_timer_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_getaddrinfo_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_addrinfo_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_addr_in_size() -> libc::c_uint;\n }\n \n-pub unsafe fn loop_new() -> *libc::c_void {\n-    return rustrt::rust_uv_loop_new();\n+pub unsafe fn loop_new() -> *c_void {\n+    return rust_uv_loop_new();\n }\n \n-pub unsafe fn loop_delete(loop_handle: *libc::c_void) {\n-    rustrt::rust_uv_loop_delete(loop_handle);\n+pub unsafe fn loop_delete(loop_handle: *c_void) {\n+    rust_uv_loop_delete(loop_handle);\n }\n \n-pub unsafe fn run(loop_handle: *libc::c_void) {\n-    rustrt::rust_uv_run(loop_handle);\n+pub unsafe fn run(loop_handle: *c_void) {\n+    rust_uv_run(loop_handle);\n }\n \n pub unsafe fn close<T>(handle: *T, cb: *u8) {\n-    rustrt::rust_uv_close(handle as *libc::c_void, cb);\n+    rust_uv_close(handle as *c_void, cb);\n }\n \n-pub unsafe fn walk(loop_handle: *libc::c_void, cb: *u8, arg: *libc::c_void) {\n-    rustrt::rust_uv_walk(loop_handle, cb, arg);\n+pub unsafe fn walk(loop_handle: *c_void, cb: *u8, arg: *c_void) {\n+    rust_uv_walk(loop_handle, cb, arg);\n }\n \n pub unsafe fn idle_new() -> *uv_idle_t {\n-    rustrt::rust_uv_idle_new()\n+    rust_uv_idle_new()\n }\n \n pub unsafe fn idle_delete(handle: *uv_idle_t) {\n-    rustrt::rust_uv_idle_delete(handle)\n+    rust_uv_idle_delete(handle)\n }\n \n pub unsafe fn idle_init(loop_handle: *uv_loop_t,\n-                        handle: *uv_idle_t) -> libc::c_int {\n-    rustrt::rust_uv_idle_init(loop_handle, handle)\n+                        handle: *uv_idle_t) -> c_int {\n+    rust_uv_idle_init(loop_handle, handle)\n }\n \n-pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> libc::c_int {\n-    rustrt::rust_uv_idle_start(handle, cb)\n+pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int {\n+    rust_uv_idle_start(handle, cb)\n }\n \n-pub unsafe fn idle_stop(handle: *uv_idle_t) -> libc::c_int {\n-    rustrt::rust_uv_idle_stop(handle)\n+pub unsafe fn idle_stop(handle: *uv_idle_t) -> c_int {\n+    rust_uv_idle_stop(handle)\n }\n \n-pub unsafe fn tcp_init(loop_handle: *libc::c_void, handle: *uv_tcp_t)\n-    -> libc::c_int {\n-    return rustrt::rust_uv_tcp_init(loop_handle, handle);\n+pub unsafe fn tcp_init(loop_handle: *c_void, handle: *uv_tcp_t) -> c_int {\n+    return rust_uv_tcp_init(loop_handle, handle);\n }\n+\n // FIXME ref #2064\n pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n-                      tcp_handle_ptr: *uv_tcp_t,\n-                      addr_ptr: *sockaddr_in,\n-                      after_connect_cb: *u8)\n+                          tcp_handle_ptr: *uv_tcp_t,\n+                          addr_ptr: *sockaddr_in,\n+                          after_connect_cb: *u8)\n -> libc::c_int {\n-    debug!(\"b4 foreign tcp_connect--addr port: %u cb: %u\",\n-                    (*addr_ptr).sin_port as uint, after_connect_cb as uint);\n-    return rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n-                                    after_connect_cb, addr_ptr);\n+    return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n+                                       after_connect_cb, addr_ptr);\n }\n // FIXME ref #2064\n pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t,\n-                      tcp_handle_ptr: *uv_tcp_t,\n-                      addr_ptr: *sockaddr_in6,\n-                      after_connect_cb: *u8)\n--> libc::c_int {\n-    return rustrt::rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr,\n-                                    after_connect_cb, addr_ptr);\n+                           tcp_handle_ptr: *uv_tcp_t,\n+                           addr_ptr: *sockaddr_in6,\n+                           after_connect_cb: *u8) -> c_int {\n+    return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr,\n+                                        after_connect_cb, addr_ptr);\n }\n // FIXME ref #2064\n pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t,\n-                   addr_ptr: *sockaddr_in) -> libc::c_int {\n-    return rustrt::rust_uv_tcp_bind(tcp_server_ptr,\n+                       addr_ptr: *sockaddr_in) -> c_int {\n+    return rust_uv_tcp_bind(tcp_server_ptr,\n                                  addr_ptr);\n }\n // FIXME ref #2064\n pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t,\n-                   addr_ptr: *sockaddr_in6) -> libc::c_int {\n-    return rustrt::rust_uv_tcp_bind6(tcp_server_ptr,\n+                        addr_ptr: *sockaddr_in6) -> c_int {\n+    return rust_uv_tcp_bind6(tcp_server_ptr,\n                                  addr_ptr);\n }\n \n pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n-                              name: *sockaddr_in) -> libc::c_int {\n-    return rustrt::rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n+                              name: *sockaddr_in) -> c_int {\n+    return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n }\n \n pub unsafe fn tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n-                               name: *sockaddr_in6) ->libc::c_int {\n-    return rustrt::rust_uv_tcp_getpeername6(tcp_handle_ptr, name);\n+                               name: *sockaddr_in6) ->c_int {\n+    return rust_uv_tcp_getpeername6(tcp_handle_ptr, name);\n }\n \n-pub unsafe fn listen<T>(stream: *T, backlog: libc::c_int,\n-                 cb: *u8) -> libc::c_int {\n-    return rustrt::rust_uv_listen(stream as *libc::c_void, backlog, cb);\n+pub unsafe fn listen<T>(stream: *T, backlog: c_int,\n+                        cb: *u8) -> c_int {\n+    return rust_uv_listen(stream as *c_void, backlog, cb);\n }\n \n-pub unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n-    -> libc::c_int {\n-    return rustrt::rust_uv_accept(server as *libc::c_void,\n-                               client as *libc::c_void);\n+pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n+    return rust_uv_accept(server as *c_void,\n+                               client as *c_void);\n }\n \n pub unsafe fn write<T>(req: *uv_write_t, stream: *T,\n-         buf_in: *~[uv_buf_t], cb: *u8) -> libc::c_int {\n+         buf_in: *~[uv_buf_t], cb: *u8) -> c_int {\n     let buf_ptr = vec::raw::to_ptr(*buf_in);\n     let buf_cnt = vec::len(*buf_in) as i32;\n-    return rustrt::rust_uv_write(req as *libc::c_void,\n-                              stream as *libc::c_void,\n+    return rust_uv_write(req as *c_void,\n+                              stream as *c_void,\n                               buf_ptr, buf_cnt, cb);\n }\n pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8,\n-                     on_read: *u8) -> libc::c_int {\n-    return rustrt::rust_uv_read_start(stream as *libc::c_void,\n+                     on_read: *u8) -> c_int {\n+    return rust_uv_read_start(stream as *c_void,\n                                    on_alloc, on_read);\n }\n \n-pub unsafe fn read_stop(stream: *uv_stream_t) -> libc::c_int {\n-    return rustrt::rust_uv_read_stop(stream as *libc::c_void);\n+pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n+    return rust_uv_read_stop(stream as *c_void);\n }\n \n-pub unsafe fn last_error(loop_handle: *libc::c_void) -> uv_err_t {\n-    return rustrt::rust_uv_last_error(loop_handle);\n+pub unsafe fn last_error(loop_handle: *c_void) -> uv_err_t {\n+    return rust_uv_last_error(loop_handle);\n }\n \n-pub unsafe fn strerror(err: *uv_err_t) -> *libc::c_char {\n-    return rustrt::rust_uv_strerror(err);\n+pub unsafe fn strerror(err: *uv_err_t) -> *c_char {\n+    return rust_uv_strerror(err);\n }\n-pub unsafe fn err_name(err: *uv_err_t) -> *libc::c_char {\n-    return rustrt::rust_uv_err_name(err);\n+pub unsafe fn err_name(err: *uv_err_t) -> *c_char {\n+    return rust_uv_err_name(err);\n }\n \n-pub unsafe fn async_init(loop_handle: *libc::c_void,\n-                     async_handle: *uv_async_t,\n-                     cb: *u8) -> libc::c_int {\n-    return rustrt::rust_uv_async_init(loop_handle,\n-                                   async_handle,\n-                                   cb);\n+pub unsafe fn async_init(loop_handle: *c_void,\n+                         async_handle: *uv_async_t,\n+                         cb: *u8) -> c_int {\n+    return rust_uv_async_init(loop_handle,\n+                                      async_handle,\n+                                      cb);\n }\n \n pub unsafe fn async_send(async_handle: *uv_async_t) {\n-    return rustrt::rust_uv_async_send(async_handle);\n+    return rust_uv_async_send(async_handle);\n }\n pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n-    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as libc::size_t };\n+    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as size_t };\n     let out_buf_ptr = ptr::addr_of(&out_buf);\n-    debug!(\"buf_init - input %u len %u out_buf: %u\",\n-                     input as uint,\n-                     len as uint,\n-                     out_buf_ptr as uint);\n-    // yuck :/\n-    rustrt::rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n-    //let result = rustrt::rust_uv_buf_init_2(input, len as size_t);\n-    debug!(\"after rust_uv_buf_init\");\n-    let res_base = get_base_from_buf(out_buf);\n-    let res_len = get_len_from_buf(out_buf);\n-    //let res_base = get_base_from_buf(result);\n-    debug!(\"buf_init - result %u len %u\",\n-                     res_base as uint,\n-                     res_len as uint);\n+    rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n     return out_buf;\n-    //return result;\n-}\n-pub unsafe fn ip4_addr(ip: &str, port: int)\n--> sockaddr_in {\n-    do str::as_c_str(ip) |ip_buf| {\n-        rustrt::rust_uv_ip4_addr(ip_buf as *u8,\n-                                 port as libc::c_int)\n-    }\n-}\n-pub unsafe fn ip6_addr(ip: &str, port: int)\n--> sockaddr_in6 {\n-    do str::as_c_str(ip) |ip_buf| {\n-        rustrt::rust_uv_ip6_addr(ip_buf as *u8,\n-                                 port as libc::c_int)\n-    }\n-}\n-pub unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n-    // ipv4 addr max size: 15 + 1 trailing null byte\n-    let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                     0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8];\n-    do vec::as_imm_buf(dst) |dst_buf, size| {\n-        rustrt::rust_uv_ip4_name(to_unsafe_ptr(src),\n-                                 dst_buf, size as libc::size_t);\n-        // seems that checking the result of uv_ip4_name\n-        // doesn't work too well..\n-        // you're stuck looking at the value of dst_buf\n-        // to see if it is the string representation of\n-        // INADDR_NONE (0xffffffff or 255.255.255.255 on\n-        // many platforms)\n-        str::raw::from_buf(dst_buf)\n-    }\n-}\n-pub unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n-    // ipv6 addr max size: 45 + 1 trailing null byte\n-    let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                       0u8,0u8,0u8,0u8,0u8,0u8];\n-    do vec::as_imm_buf(dst) |dst_buf, size| {\n-        let src_unsafe_ptr = to_unsafe_ptr(src);\n-        debug!(\"val of src *sockaddr_in6: %? sockaddr_in6: %?\",\n-                        src_unsafe_ptr, src);\n-        let result = rustrt::rust_uv_ip6_name(src_unsafe_ptr,\n-                                              dst_buf, size as libc::size_t);\n-        match result {\n-          0i32 => str::raw::from_buf(dst_buf),\n-          _ => ~\"\"\n-        }\n-    }\n-}\n-pub unsafe fn ip4_port(src: &sockaddr_in) -> uint {\n-    rustrt::rust_uv_ip4_port(to_unsafe_ptr(src)) as uint\n-}\n-pub unsafe fn ip6_port(src: &sockaddr_in6) -> uint {\n-    rustrt::rust_uv_ip6_port(to_unsafe_ptr(src)) as uint\n }\n \n-pub unsafe fn timer_init(loop_ptr: *libc::c_void,\n-                     timer_ptr: *uv_timer_t) -> libc::c_int {\n-    return rustrt::rust_uv_timer_init(loop_ptr, timer_ptr);\n+pub unsafe fn timer_init(loop_ptr: *c_void,\n+                         timer_ptr: *uv_timer_t) -> c_int {\n+    return rust_uv_timer_init(loop_ptr, timer_ptr);\n }\n pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n-                      repeat: uint) -> libc::c_int {\n-    return rustrt::rust_uv_timer_start(timer_ptr, cb, timeout as libc::c_uint,\n-                                    repeat as libc::c_uint);\n+                          repeat: uint) -> c_int {\n+    return rust_uv_timer_start(timer_ptr, cb, timeout as c_uint,\n+                                       repeat as c_uint);\n }\n-pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> libc::c_int {\n-    return rustrt::rust_uv_timer_stop(timer_ptr);\n-}\n-pub unsafe fn getaddrinfo(loop_ptr: *libc::c_void,\n-                           handle: *uv_getaddrinfo_t,\n-                           cb: *u8,\n-                           node_name_ptr: *u8,\n-                           service_name_ptr: *u8,\n-                           hints: *addrinfo) -> libc::c_int {\n-    rustrt::rust_uv_getaddrinfo(loop_ptr,\n-                           handle,\n-                           cb,\n-                           node_name_ptr,\n-                           service_name_ptr,\n-                           hints)\n-}\n-pub unsafe fn freeaddrinfo(res: *addrinfo) {\n-    rustrt::rust_uv_freeaddrinfo(res);\n+pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n+    return rust_uv_timer_stop(timer_ptr);\n }\n \n-// libuv struct initializers\n-pub unsafe fn tcp_t() -> uv_tcp_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_tcp_t();\n-}\n-pub unsafe fn connect_t() -> uv_connect_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_connect_t();\n-}\n-pub unsafe fn write_t() -> uv_write_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_write_t();\n+pub unsafe fn malloc_ip4_addr(ip: &str, port: int)\n+-> *sockaddr_in {\n+    do str::as_c_str(ip) |ip_buf| {\n+        rust_uv_ip4_addrp(ip_buf as *u8,\n+                                  port as libc::c_int)\n+    }\n }\n-pub unsafe fn async_t() -> uv_async_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_async_t();\n+pub unsafe fn malloc_ip6_addr(ip: &str, port: int)\n+-> *sockaddr_in6 {\n+    do str::as_c_str(ip) |ip_buf| {\n+        rust_uv_ip6_addrp(ip_buf as *u8,\n+                                  port as libc::c_int)\n+    }\n }\n-pub unsafe fn timer_t() -> uv_timer_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_timer_t();\n+\n+pub unsafe fn free_ip4_addr(addr: *sockaddr_in) {\n+    rust_uv_free_ip4_addr(addr);\n }\n-pub unsafe fn getaddrinfo_t() -> uv_getaddrinfo_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_getaddrinfo_t();\n+\n+pub unsafe fn free_ip6_addr(addr: *sockaddr_in6) {\n+    rust_uv_free_ip6_addr(addr);\n }\n \n // data access helpers\n-pub unsafe fn get_loop_for_uv_handle<T>(handle: *T)\n-    -> *libc::c_void {\n-    return rustrt::rust_uv_get_loop_for_uv_handle(handle as *libc::c_void);\n+pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n+    return rust_uv_get_loop_for_uv_handle(handle as *c_void);\n }\n pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t)\n     -> *uv_stream_t {\n-    return rustrt::rust_uv_get_stream_handle_from_connect_req(\n+    return rust_uv_get_stream_handle_from_connect_req(\n         connect);\n }\n pub unsafe fn get_stream_handle_from_write_req(\n     write_req: *uv_write_t)\n     -> *uv_stream_t {\n-    return rustrt::rust_uv_get_stream_handle_from_write_req(\n+    return rust_uv_get_stream_handle_from_write_req(\n         write_req);\n }\n-pub unsafe fn get_data_for_uv_loop(loop_ptr: *libc::c_void) -> *libc::c_void {\n-    rustrt::rust_uv_get_data_for_uv_loop(loop_ptr)\n+pub unsafe fn get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void {\n+    rust_uv_get_data_for_uv_loop(loop_ptr)\n }\n-pub unsafe fn set_data_for_uv_loop(loop_ptr: *libc::c_void,\n-                                   data: *libc::c_void) {\n-    rustrt::rust_uv_set_data_for_uv_loop(loop_ptr, data);\n+pub unsafe fn set_data_for_uv_loop(loop_ptr: *c_void,\n+                                   data: *c_void) {\n+    rust_uv_set_data_for_uv_loop(loop_ptr, data);\n }\n-pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *libc::c_void {\n-    return rustrt::rust_uv_get_data_for_uv_handle(handle as *libc::c_void);\n+pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *c_void {\n+    return rust_uv_get_data_for_uv_handle(handle as *c_void);\n }\n pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T,\n                     data: *U) {\n-    rustrt::rust_uv_set_data_for_uv_handle(handle as *libc::c_void,\n-                                           data as *libc::c_void);\n+    rust_uv_set_data_for_uv_handle(handle as *c_void,\n+                                           data as *c_void);\n }\n-pub unsafe fn get_data_for_req<T>(req: *T) -> *libc::c_void {\n-    return rustrt::rust_uv_get_data_for_req(req as *libc::c_void);\n+pub unsafe fn get_data_for_req<T>(req: *T) -> *c_void {\n+    return rust_uv_get_data_for_req(req as *c_void);\n }\n pub unsafe fn set_data_for_req<T, U>(req: *T,\n-                    data: *U) {\n-    rustrt::rust_uv_set_data_for_req(req as *libc::c_void,\n-                                     data as *libc::c_void);\n+                                     data: *U) {\n+    rust_uv_set_data_for_req(req as *c_void,\n+                                     data as *c_void);\n }\n pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n-    return rustrt::rust_uv_get_base_from_buf(buf);\n+    return rust_uv_get_base_from_buf(buf);\n }\n-pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> libc::size_t {\n-    return rustrt::rust_uv_get_len_from_buf(buf);\n+pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n+    return rust_uv_get_len_from_buf(buf);\n }\n-pub unsafe fn malloc_buf_base_of(suggested_size: libc::size_t)\n-    -> *u8 {\n-    return rustrt::rust_uv_malloc_buf_base_of(suggested_size);\n+pub unsafe fn malloc_buf_base_of(suggested_size: size_t) -> *u8 {\n+    return rust_uv_malloc_buf_base_of(suggested_size);\n }\n pub unsafe fn free_base_of_buf(buf: uv_buf_t) {\n-    rustrt::rust_uv_free_base_of_buf(buf);\n+    rust_uv_free_base_of_buf(buf);\n }\n \n-pub unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n+pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n     let err = last_error(uv_loop);\n     let err_ptr = ptr::addr_of(&err);\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n@@ -1219,721 +385,92 @@ pub struct uv_err_data {\n     err_msg: ~str,\n }\n \n-pub unsafe fn is_ipv4_addrinfo(input: *addrinfo) -> bool {\n-    rustrt::rust_uv_is_ipv4_addrinfo(input)\n-}\n-pub unsafe fn is_ipv6_addrinfo(input: *addrinfo) -> bool {\n-    rustrt::rust_uv_is_ipv6_addrinfo(input)\n-}\n-pub unsafe fn get_INADDR_NONE() -> u32 {\n-    rustrt::rust_uv_helper_get_INADDR_NONE()\n-}\n-pub unsafe fn get_next_addrinfo(input: *addrinfo) -> *addrinfo {\n-    rustrt::rust_uv_get_next_addrinfo(input)\n-}\n-pub unsafe fn addrinfo_as_sockaddr_in(input: *addrinfo) -> *sockaddr_in {\n-    rustrt::rust_uv_addrinfo_as_sockaddr_in(input)\n-}\n-pub unsafe fn addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6 {\n-    rustrt::rust_uv_addrinfo_as_sockaddr_in6(input)\n-}\n-\n-#[cfg(test)]\n-pub mod test {\n-    use prelude::*;\n-    use super::*;\n-    use comm::{SharedChan, stream, GenericChan, GenericPort};\n+extern {\n \n-    enum tcp_read_data {\n-        tcp_read_eof,\n-        tcp_read_more(~[u8]),\n-        tcp_read_error\n-    }\n-\n-    struct request_wrapper {\n-        write_req: *uv_write_t,\n-        req_buf: *~[uv_buf_t],\n-        read_chan: SharedChan<~str>,\n-    }\n+    fn rust_uv_handle_size(type_: uintptr_t) -> size_t;\n+    fn rust_uv_req_size(type_: uintptr_t) -> size_t;\n+    fn rust_uv_handle_type_max() -> uintptr_t;\n+    fn rust_uv_req_type_max() -> uintptr_t;\n \n-    extern fn after_close_cb(handle: *libc::c_void) {\n-        debug!(\"after uv_close! handle ptr: %?\",\n-                        handle);\n-    }\n-\n-    extern fn on_alloc_cb(handle: *libc::c_void,\n-                         suggested_size: libc::size_t)\n-        -> uv_buf_t {\n-        unsafe {\n-            debug!(\"on_alloc_cb!\");\n-            let char_ptr = malloc_buf_base_of(suggested_size);\n-            debug!(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n-                             handle,\n-                             char_ptr as uint,\n-                             suggested_size as uint);\n-            return buf_init(char_ptr, suggested_size as uint);\n-        }\n-    }\n-\n-    extern fn on_read_cb(stream: *uv_stream_t,\n-                        nread: libc::ssize_t,\n-                        ++buf: uv_buf_t) {\n-        unsafe {\n-            let nread = nread as int;\n-            debug!(\"CLIENT entering on_read_cb nred: %d\",\n-                            nread);\n-            if (nread > 0) {\n-                // we have data\n-                debug!(\"CLIENT read: data! nread: %d\", nread);\n-                read_stop(stream);\n-                let client_data =\n-                    get_data_for_uv_handle(stream as *libc::c_void)\n-                      as *request_wrapper;\n-                let buf_base = get_base_from_buf(buf);\n-                let bytes = vec::from_buf(buf_base, nread as uint);\n-                let read_chan = (*client_data).read_chan.clone();\n-                let msg_from_server = str::from_bytes(bytes);\n-                read_chan.send(msg_from_server);\n-                close(stream as *libc::c_void, after_close_cb)\n-            }\n-            else if (nread == -1) {\n-                // err .. possibly EOF\n-                debug!(\"read: eof!\");\n-            }\n-            else {\n-                // nread == 0 .. do nothing, just free buf as below\n-                debug!(\"read: do nothing!\");\n-            }\n-            // when we're done\n-            free_base_of_buf(buf);\n-            debug!(\"CLIENT exiting on_read_cb\");\n-        }\n-    }\n-\n-    extern fn on_write_complete_cb(write_req: *uv_write_t,\n-                                  status: libc::c_int) {\n-        unsafe {\n-            debug!(\n-                \"CLIENT beginning on_write_complete_cb status: %d\",\n-                     status as int);\n-            let stream = get_stream_handle_from_write_req(write_req);\n-            debug!(\n-                \"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n-                stream as int, write_req as int);\n-            let result = read_start(stream, on_alloc_cb, on_read_cb);\n-            debug!(\n-                \"CLIENT ending on_write_complete_cb .. status: %d\",\n-                     result as int);\n-        }\n-    }\n-\n-    extern fn on_connect_cb(connect_req_ptr: *uv_connect_t,\n-                                 status: libc::c_int) {\n-        unsafe {\n-            debug!(\"beginning on_connect_cb .. status: %d\",\n-                             status as int);\n-            let stream =\n-                get_stream_handle_from_connect_req(connect_req_ptr);\n-            if (status == 0i32) {\n-                debug!(\"on_connect_cb: in status=0 if..\");\n-                let client_data = get_data_for_req(\n-                    connect_req_ptr as *libc::c_void)\n-                    as *request_wrapper;\n-                let write_handle = (*client_data).write_req;\n-                debug!(\"on_connect_cb: tcp: %d write_hdl: %d\",\n-                                stream as int, write_handle as int);\n-                let write_result = write(write_handle,\n-                                  stream as *libc::c_void,\n-                                  (*client_data).req_buf,\n-                                  on_write_complete_cb);\n-                debug!(\"on_connect_cb: write() status: %d\",\n-                                 write_result as int);\n-            }\n-            else {\n-                let test_loop = get_loop_for_uv_handle(\n-                    stream as *libc::c_void);\n-                let err_msg = get_last_err_info(test_loop);\n-                debug!(\"%?\", err_msg);\n-                fail_unless!(false);\n-            }\n-            debug!(\"finishing on_connect_cb\");\n-        }\n-    }\n-\n-    fn impl_uv_tcp_request(ip: &str, port: int, req_str: &str,\n-                          client_chan: SharedChan<~str>) {\n-        unsafe {\n-            let test_loop = loop_new();\n-            let tcp_handle = tcp_t();\n-            let tcp_handle_ptr = ptr::addr_of(&tcp_handle);\n-            let connect_handle = connect_t();\n-            let connect_req_ptr = ptr::addr_of(&connect_handle);\n-\n-            // this is the persistent payload of data that we\n-            // need to pass around to get this example to work.\n-            // In C, this would be a malloc'd or stack-allocated\n-            // struct that we'd cast to a void* and store as the\n-            // data field in our uv_connect_t struct\n-            let req_str_bytes = str::to_bytes(req_str);\n-            let req_msg_ptr: *u8 = vec::raw::to_ptr(req_str_bytes);\n-            debug!(\"req_msg ptr: %u\", req_msg_ptr as uint);\n-            let req_msg = ~[\n-                buf_init(req_msg_ptr, vec::len(req_str_bytes))\n-            ];\n-            // this is the enclosing record, we'll pass a ptr to\n-            // this to C..\n-            let write_handle = write_t();\n-            let write_handle_ptr = ptr::addr_of(&write_handle);\n-            debug!(\"tcp req: tcp stream: %d write_handle: %d\",\n-                             tcp_handle_ptr as int,\n-                             write_handle_ptr as int);\n-            let client_data = request_wrapper {\n-                write_req: write_handle_ptr,\n-                req_buf: ptr::addr_of(&req_msg),\n-                read_chan: client_chan\n-            };\n-\n-            let tcp_init_result = tcp_init(\n-                test_loop as *libc::c_void, tcp_handle_ptr);\n-            if (tcp_init_result == 0i32) {\n-                debug!(\"sucessful tcp_init_result\");\n-\n-                debug!(\"building addr...\");\n-                let addr = ip4_addr(ip, port);\n-                // FIXME ref #2064\n-                let addr_ptr = ptr::addr_of(&addr);\n-                debug!(\"after build addr in rust. port: %u\",\n-                                 addr.sin_port as uint);\n-\n-                // this should set up the connection request..\n-                debug!(\"b4 call tcp_connect connect cb: %u \",\n-                                on_connect_cb as uint);\n-                let tcp_connect_result = tcp_connect(\n-                    connect_req_ptr, tcp_handle_ptr,\n-                    addr_ptr, on_connect_cb);\n-                if (tcp_connect_result == 0i32) {\n-                    // not set the data on the connect_req\n-                    // until its initialized\n-                    set_data_for_req(\n-                        connect_req_ptr as *libc::c_void,\n-                        ptr::addr_of(&client_data) as *libc::c_void);\n-                    set_data_for_uv_handle(\n-                        tcp_handle_ptr as *libc::c_void,\n-                        ptr::addr_of(&client_data) as *libc::c_void);\n-                    debug!(\"before run tcp req loop\");\n-                    run(test_loop);\n-                    debug!(\"after run tcp req loop\");\n-                }\n-                else {\n-                   debug!(\"tcp_connect() failure\");\n-                   fail_unless!(false);\n-                }\n-            }\n-            else {\n-                debug!(\"tcp_init() failure\");\n-                fail_unless!(false);\n-            }\n-            loop_delete(test_loop);\n-        }\n-    }\n-\n-    extern fn server_after_close_cb(handle: *libc::c_void) {\n-        unsafe {\n-            debug!(\"SERVER server stream closed, should exit. h: %?\",\n-                       handle);\n-        }\n-    }\n-\n-    extern fn client_stream_after_close_cb(handle: *libc::c_void) {\n-        unsafe {\n-            debug!(\n-                \"SERVER: closed client stream, now closing server stream\");\n-            let client_data = get_data_for_uv_handle(\n-                handle) as\n-                *tcp_server_data;\n-            close((*client_data).server as *libc::c_void,\n-                          server_after_close_cb);\n-        }\n-    }\n-\n-    extern fn after_server_resp_write(req: *uv_write_t) {\n-        unsafe {\n-            let client_stream_ptr =\n-                get_stream_handle_from_write_req(req);\n-            debug!(\"SERVER: resp sent... closing client stream\");\n-            close(client_stream_ptr as *libc::c_void,\n-                          client_stream_after_close_cb)\n-        }\n-    }\n-\n-    extern fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n-                               nread: libc::ssize_t,\n-                               ++buf: uv_buf_t) {\n-        unsafe {\n-            let nread = nread as int;\n-            if (nread > 0) {\n-                // we have data\n-                debug!(\"SERVER read: data! nread: %d\", nread);\n-\n-                // pull out the contents of the write from the client\n-                let buf_base = get_base_from_buf(buf);\n-                let buf_len = get_len_from_buf(buf) as uint;\n-                debug!(\"SERVER buf base: %u, len: %u, nread: %d\",\n-                                buf_base as uint,\n-                                buf_len as uint,\n-                                nread);\n-                let bytes = vec::from_buf(buf_base, nread as uint);\n-                let request_str = str::from_bytes(bytes);\n-\n-                let client_data = get_data_for_uv_handle(\n-                    client_stream_ptr as *libc::c_void) as *tcp_server_data;\n-\n-                let server_kill_msg = copy (*client_data).server_kill_msg;\n-                let write_req = (*client_data).server_write_req;\n-                if str::contains(request_str, server_kill_msg) {\n-                    debug!(\"SERVER: client req contains kill_msg!\");\n-                    debug!(\"SERVER: sending response to client\");\n-                    read_stop(client_stream_ptr);\n-                    let server_chan = (*client_data).server_chan.clone();\n-                    server_chan.send(request_str);\n-                    let write_result = write(\n-                        write_req,\n-                        client_stream_ptr as *libc::c_void,\n-                        (*client_data).server_resp_buf,\n-                        after_server_resp_write);\n-                    debug!(\"SERVER: resp write result: %d\",\n-                                write_result as int);\n-                    if (write_result != 0i32) {\n-                        debug!(\"bad result for server resp write()\");\n-                        debug!(\"%s\", get_last_err_info(\n-                            get_loop_for_uv_handle(client_stream_ptr\n-                                as *libc::c_void)));\n-                        fail_unless!(false);\n-                    }\n-                }\n-                else {\n-                    debug!(\"SERVER: client req !contain kill_msg!\");\n-                }\n-            }\n-            else if (nread == -1) {\n-                // err .. possibly EOF\n-                debug!(\"read: eof!\");\n-            }\n-            else {\n-                // nread == 0 .. do nothing, just free buf as below\n-                debug!(\"read: do nothing!\");\n-            }\n-            // when we're done\n-            free_base_of_buf(buf);\n-            debug!(\"SERVER exiting on_read_cb\");\n-        }\n-    }\n-\n-    extern fn server_connection_cb(server_stream_ptr:\n-                                    *uv_stream_t,\n-                                  status: libc::c_int) {\n-        unsafe {\n-            debug!(\"client connecting!\");\n-            let test_loop = get_loop_for_uv_handle(\n-                                   server_stream_ptr as *libc::c_void);\n-            if status != 0i32 {\n-                let err_msg = get_last_err_info(test_loop);\n-                debug!(\"server_connect_cb: non-zero status: %?\",\n-                             err_msg);\n-                return;\n-            }\n-            let server_data = get_data_for_uv_handle(\n-                server_stream_ptr as *libc::c_void) as *tcp_server_data;\n-            let client_stream_ptr = (*server_data).client;\n-            let client_init_result = tcp_init(test_loop,\n-                                                      client_stream_ptr);\n-            set_data_for_uv_handle(\n-                client_stream_ptr as *libc::c_void,\n-                server_data as *libc::c_void);\n-            if (client_init_result == 0i32) {\n-                debug!(\"successfully initialized client stream\");\n-                let accept_result = accept(server_stream_ptr as\n-                                                     *libc::c_void,\n-                                                   client_stream_ptr as\n-                                                     *libc::c_void);\n-                if (accept_result == 0i32) {\n-                    // start reading\n-                    let read_result = read_start(\n-                        client_stream_ptr as *uv_stream_t,\n-                                                         on_alloc_cb,\n-                                                         on_server_read_cb);\n-                    if (read_result == 0i32) {\n-                        debug!(\"successful server read start\");\n-                    }\n-                    else {\n-                        debug!(\"server_connection_cb: bad read:%d\",\n-                                        read_result as int);\n-                        fail_unless!(false);\n-                    }\n-                }\n-                else {\n-                    debug!(\"server_connection_cb: bad accept: %d\",\n-                                accept_result as int);\n-                    fail_unless!(false);\n-                }\n-            }\n-            else {\n-                debug!(\"server_connection_cb: bad client init: %d\",\n-                            client_init_result as int);\n-                fail_unless!(false);\n-            }\n-        }\n-    }\n-\n-    struct tcp_server_data {\n-        client: *uv_tcp_t,\n-        server: *uv_tcp_t,\n-        server_kill_msg: ~str,\n-        server_resp_buf: *~[uv_buf_t],\n-        server_chan: SharedChan<~str>,\n-        server_write_req: *uv_write_t,\n-    }\n-\n-    struct async_handle_data {\n-        continue_chan: SharedChan<bool>,\n-    }\n-\n-    extern fn async_close_cb(handle: *libc::c_void) {\n-        debug!(\"SERVER: closing async cb... h: %?\",\n-                   handle);\n-    }\n-\n-    extern fn continue_async_cb(async_handle: *uv_async_t,\n-                               status: libc::c_int) {\n-        unsafe {\n-            // once we're in the body of this callback,\n-            // the tcp server's loop is set up, so we\n-            // can continue on to let the tcp client\n-            // do its thang\n-            let data = get_data_for_uv_handle(\n-                async_handle as *libc::c_void) as *async_handle_data;\n-            let continue_chan = (*data).continue_chan.clone();\n-            let should_continue = status == 0i32;\n-            continue_chan.send(should_continue);\n-            close(async_handle as *libc::c_void, async_close_cb);\n-        }\n-    }\n-\n-    fn impl_uv_tcp_server(server_ip: &str,\n-                          server_port: int,\n-                          kill_server_msg: ~str,\n-                          server_resp_msg: ~str,\n-                          server_chan: SharedChan<~str>,\n-                          continue_chan: SharedChan<bool>) {\n-        unsafe {\n-            let test_loop = loop_new();\n-            let tcp_server = tcp_t();\n-            let tcp_server_ptr = ptr::addr_of(&tcp_server);\n-\n-            let tcp_client = tcp_t();\n-            let tcp_client_ptr = ptr::addr_of(&tcp_client);\n-\n-            let server_write_req = write_t();\n-            let server_write_req_ptr = ptr::addr_of(&server_write_req);\n-\n-            let resp_str_bytes = str::to_bytes(server_resp_msg);\n-            let resp_msg_ptr: *u8 = vec::raw::to_ptr(resp_str_bytes);\n-            debug!(\"resp_msg ptr: %u\", resp_msg_ptr as uint);\n-            let resp_msg = ~[\n-                buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n-            ];\n-\n-            let continue_async_handle = async_t();\n-            let continue_async_handle_ptr =\n-                ptr::addr_of(&continue_async_handle);\n-            let async_data =\n-                async_handle_data { continue_chan: continue_chan };\n-            let async_data_ptr = ptr::addr_of(&async_data);\n-\n-            let server_data = tcp_server_data {\n-                client: tcp_client_ptr,\n-                server: tcp_server_ptr,\n-                server_kill_msg: kill_server_msg,\n-                server_resp_buf: ptr::addr_of(&resp_msg),\n-                server_chan: server_chan,\n-                server_write_req: server_write_req_ptr\n-            };\n-            let server_data_ptr = ptr::addr_of(&server_data);\n-            set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n-                                           server_data_ptr as *libc::c_void);\n-\n-            // uv_tcp_init()\n-            let tcp_init_result = tcp_init(\n-                test_loop as *libc::c_void, tcp_server_ptr);\n-            if (tcp_init_result == 0i32) {\n-                let server_addr = ip4_addr(server_ip, server_port);\n-                // FIXME ref #2064\n-                let server_addr_ptr = ptr::addr_of(&server_addr);\n-\n-                // uv_tcp_bind()\n-                let bind_result = tcp_bind(tcp_server_ptr,\n-                                                   server_addr_ptr);\n-                if (bind_result == 0i32) {\n-                    debug!(\"successful uv_tcp_bind, listening\");\n-\n-                    // uv_listen()\n-                    let listen_result = listen(tcp_server_ptr as\n-                                                         *libc::c_void,\n-                                                       128i32,\n-                                                       server_connection_cb);\n-                    if (listen_result == 0i32) {\n-                        // let the test know it can set up the tcp server,\n-                        // now.. this may still present a race, not sure..\n-                        let async_result = async_init(test_loop,\n-                                           continue_async_handle_ptr,\n-                                           continue_async_cb);\n-                        if (async_result == 0i32) {\n-                            set_data_for_uv_handle(\n-                                continue_async_handle_ptr as *libc::c_void,\n-                                async_data_ptr as *libc::c_void);\n-                            async_send(continue_async_handle_ptr);\n-                            // uv_run()\n-                            run(test_loop);\n-                            debug!(\"server uv::run() has returned\");\n-                        }\n-                        else {\n-                            debug!(\"uv_async_init failure: %d\",\n-                                    async_result as int);\n-                            fail_unless!(false);\n-                        }\n-                    }\n-                    else {\n-                        debug!(\"non-zero result on uv_listen: %d\",\n-                                    listen_result as int);\n-                        fail_unless!(false);\n-                    }\n-                }\n-                else {\n-                    debug!(\"non-zero result on uv_tcp_bind: %d\",\n-                                bind_result as int);\n-                    fail_unless!(false);\n-                }\n-            }\n-            else {\n-                debug!(\"non-zero result on uv_tcp_init: %d\",\n-                            tcp_init_result as int);\n-                fail_unless!(false);\n-            }\n-            loop_delete(test_loop);\n-        }\n-    }\n-\n-    // this is the impl for a test that is (maybe) ran on a\n-    // per-platform/arch basis below\n-    pub fn impl_uv_tcp_server_and_request() {\n-        unsafe {\n-            let bind_ip = ~\"0.0.0.0\";\n-            let request_ip = ~\"127.0.0.1\";\n-            let port = 8886;\n-            let kill_server_msg = ~\"does a dog have buddha nature?\";\n-            let server_resp_msg = ~\"mu!\";\n-            let (client_port, client_chan) = stream::<~str>();\n-            let client_chan = SharedChan(client_chan);\n-            let (server_port, server_chan) = stream::<~str>();\n-            let server_chan = SharedChan(server_chan);\n-\n-            let (continue_port, continue_chan) = stream::<bool>();\n-            let continue_chan = SharedChan(continue_chan);\n-\n-            let kill_server_msg_copy = copy kill_server_msg;\n-            let server_resp_msg_copy = copy server_resp_msg;\n-            do task::spawn_sched(task::ManualThreads(1)) {\n-                impl_uv_tcp_server(bind_ip, port,\n-                                   copy kill_server_msg_copy,\n-                                   copy server_resp_msg_copy,\n-                                   server_chan.clone(),\n-                                   continue_chan.clone());\n-            };\n-\n-            // block until the server up is.. possibly a race?\n-            debug!(\"before receiving on server continue_port\");\n-            continue_port.recv();\n-            debug!(\"received on continue port, set up tcp client\");\n-\n-            let kill_server_msg_copy = copy kill_server_msg;\n-            do task::spawn_sched(task::ManualThreads(1u)) {\n-                impl_uv_tcp_request(request_ip, port,\n-                                   kill_server_msg_copy,\n-                                   client_chan.clone());\n-            };\n-\n-            let msg_from_client = server_port.recv();\n-            let msg_from_server = client_port.recv();\n-\n-            fail_unless!(str::contains(msg_from_client, kill_server_msg));\n-            fail_unless!(str::contains(msg_from_server, server_resp_msg));\n-        }\n-    }\n-\n-    // FIXME don't run on fbsd or linux 32 bit(#2064)\n-    #[cfg(target_os=\"win32\")]\n-    #[cfg(target_os=\"darwin\")]\n-    #[cfg(target_os=\"linux\")]\n-    #[cfg(target_os=\"android\")]\n-    pub mod tcp_and_server_client_test {\n-        #[cfg(target_arch=\"x86_64\")]\n-        pub mod impl64 {\n-            #[test]\n-            pub fn test_uv_ll_tcp_server_and_request() {\n-                unsafe {\n-                    super::super::impl_uv_tcp_server_and_request();\n-                }\n-            }\n-        }\n-        #[cfg(target_arch=\"x86\")]\n-        #[cfg(target_arch=\"arm\")]\n-        #[cfg(target_arch=\"mips\")]\n-        pub mod impl32 {\n-            #[test]\n-            #[ignore(cfg(target_os = \"linux\"))]\n-            pub fn test_uv_ll_tcp_server_and_request() {\n-                unsafe {\n-                    super::super::impl_uv_tcp_server_and_request();\n-                }\n-            }\n-        }\n-    }\n-\n-    fn struct_size_check_common<TStruct>(t_name: ~str,\n-                                         foreign_size: libc::c_uint) {\n-        unsafe {\n-            let rust_size = sys::size_of::<TStruct>();\n-            let sizes_match = foreign_size as uint == rust_size;\n-            if !sizes_match {\n-                let output = fmt!(\n-                    \"STRUCT_SIZE FAILURE: %s -- actual: %u expected: %u\",\n-                    t_name, rust_size, foreign_size as uint);\n-                debug!(\"%s\", output);\n-            }\n-            fail_unless!(sizes_match);\n-        }\n-    }\n-\n-    // struct size tests\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_tcp_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_tcp_t>(\n-                ~\"uv_tcp_t\",\n-                super::rustrt::rust_uv_helper_uv_tcp_t_size()\n-            );\n-        }\n-    }\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_connect_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_connect_t>(\n-                ~\"uv_connect_t\",\n-                super::rustrt::rust_uv_helper_uv_connect_t_size()\n-            );\n-        }\n-    }\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_buf_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_buf_t>(\n-                ~\"uv_buf_t\",\n-                super::rustrt::rust_uv_helper_uv_buf_t_size()\n-            );\n-        }\n-    }\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_write_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_write_t>(\n-                ~\"uv_write_t\",\n-                super::rustrt::rust_uv_helper_uv_write_t_size()\n-            );\n-        }\n-    }\n-\n-    #[test]\n-    fn test_uv_ll_struct_size_sockaddr_in() {\n-        unsafe {\n-            struct_size_check_common::<sockaddr_in>(\n-                ~\"sockaddr_in\",\n-                super::rustrt::rust_uv_helper_sockaddr_in_size()\n-            );\n-        }\n-    }\n-    #[test]\n-    fn test_uv_ll_struct_size_sockaddr_in6() {\n-        unsafe {\n-            let foreign_handle_size =\n-                super::rustrt::rust_uv_helper_sockaddr_in6_size();\n-            let rust_handle_size = sys::size_of::<sockaddr_in6>();\n-            let output = fmt!(\"sockaddr_in6 -- foreign: %u rust: %u\",\n-                              foreign_handle_size as uint, rust_handle_size);\n-            debug!(output);\n-            // FIXME #1645 .. rust appears to pad structs to the nearest\n-            // byte..?\n-            // .. can't get the uv::ll::sockaddr_in6 to == 28 :/\n-            // .. so the type always appears to be 32 in size.. which is\n-            // good, i guess.. better too big than too little\n-            fail_unless!((4u+foreign_handle_size as uint) ==\n-                rust_handle_size);\n-        }\n-    }\n-    #[test]\n-    #[ignore(reason = \"questionable size calculations\")]\n-    fn test_uv_ll_struct_size_addr_in() {\n-        unsafe {\n-            let foreign_handle_size =\n-                super::rustrt::rust_uv_helper_addr_in_size();\n-            let rust_handle_size = sys::size_of::<addr_in>();\n-            let output = fmt!(\"addr_in -- foreign: %u rust: %u\",\n-                              foreign_handle_size as uint, rust_handle_size);\n-            debug!(output);\n-            // FIXME #1645 .. see note above about struct padding\n-            fail_unless!((4u+foreign_handle_size as uint) ==\n-                rust_handle_size);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_async_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_async_t>(\n-                ~\"uv_async_t\",\n-                super::rustrt::rust_uv_helper_uv_async_t_size()\n-            );\n-        }\n-    }\n-\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_timer_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_timer_t>(\n-                ~\"uv_timer_t\",\n-                super::rustrt::rust_uv_helper_uv_timer_t_size()\n-            );\n-        }\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_uv_ll_struct_size_uv_getaddrinfo_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_getaddrinfo_t>(\n-                ~\"uv_getaddrinfo_t\",\n-                super::rustrt::rust_uv_helper_uv_getaddrinfo_t_size()\n-            );\n-        }\n-    }\n-    #[test]\n-    #[ignore(cfg(target_os = \"macos\"))]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_uv_ll_struct_size_addrinfo() {\n-        unsafe {\n-            struct_size_check_common::<uv_timer_t>(\n-                ~\"addrinfo\",\n-                super::rustrt::rust_uv_helper_uv_timer_t_size()\n-            );\n-        }\n-    }\n+    // libuv public API\n+    fn rust_uv_loop_new() -> *c_void;\n+    fn rust_uv_loop_delete(lp: *c_void);\n+    fn rust_uv_run(loop_handle: *c_void);\n+    fn rust_uv_close(handle: *c_void, cb: *u8);\n+    fn rust_uv_walk(loop_handle: *c_void, cb: *u8, arg: *c_void);\n+\n+    fn rust_uv_idle_new() -> *uv_idle_t;\n+    fn rust_uv_idle_delete(handle: *uv_idle_t);\n+    fn rust_uv_idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int;\n+    fn rust_uv_idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int;\n+    fn rust_uv_idle_stop(handle: *uv_idle_t) -> c_int;\n+\n+    fn rust_uv_async_send(handle: *uv_async_t);\n+    fn rust_uv_async_init(loop_handle: *c_void,\n+                          async_handle: *uv_async_t,\n+                          cb: *u8) -> c_int;\n+    fn rust_uv_tcp_init(loop_handle: *c_void, handle_ptr: *uv_tcp_t) -> c_int;\n+    // FIXME ref #2604 .. ?\n+    fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8, len: size_t);\n+    fn rust_uv_last_error(loop_handle: *c_void) -> uv_err_t;\n+    // FIXME ref #2064\n+    fn rust_uv_strerror(err: *uv_err_t) -> *c_char;\n+    // FIXME ref #2064\n+    fn rust_uv_err_name(err: *uv_err_t) -> *c_char;\n+    fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n+    fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n+    fn rust_uv_free_ip4_addr(addr: *sockaddr_in);\n+    fn rust_uv_free_ip6_addr(addr: *sockaddr_in6);\n+    fn rust_uv_ip4_name(src: *sockaddr_in, dst: *u8, size: size_t) -> c_int;\n+    fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: size_t) -> c_int;\n+    fn rust_uv_ip4_port(src: *sockaddr_in) -> c_uint;\n+    fn rust_uv_ip6_port(src: *sockaddr_in6) -> c_uint;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n+                           tcp_handle_ptr: *uv_tcp_t,\n+                           ++after_cb: *u8,\n+                           ++addr: *sockaddr_in) -> c_int;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t, ++addr: *sockaddr_in) -> c_int;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n+                            tcp_handle_ptr: *uv_tcp_t,\n+                            ++after_cb: *u8,\n+                            ++addr: *sockaddr_in6) -> c_int;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, ++addr: *sockaddr_in6) -> c_int;\n+    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, ++name: *sockaddr_in) -> c_int;\n+    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, ++name: *sockaddr_in6) ->c_int;\n+    fn rust_uv_listen(stream: *c_void, backlog: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;\n+    fn rust_uv_write(req: *c_void,\n+                     stream: *c_void,\n+                     ++buf_in: *uv_buf_t,\n+                     buf_cnt: c_int,\n+                     cb: *u8) -> c_int;\n+    fn rust_uv_read_start(stream: *c_void,\n+                          on_alloc: *u8,\n+                          on_read: *u8) -> c_int;\n+    fn rust_uv_read_stop(stream: *c_void) -> c_int;\n+    fn rust_uv_timer_init(loop_handle: *c_void,\n+                          timer_handle: *uv_timer_t) -> c_int;\n+    fn rust_uv_timer_start(timer_handle: *uv_timer_t,\n+                           cb: *u8,\n+                           timeout: c_uint,\n+                           repeat: c_uint) -> c_int;\n+    fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n+\n+    fn rust_uv_malloc_buf_base_of(sug_size: size_t) -> *u8;\n+    fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n+    fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n+    fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;\n+    fn rust_uv_get_loop_for_uv_handle(handle: *c_void) -> *c_void;\n+    fn rust_uv_get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void);\n+    fn rust_uv_get_data_for_uv_handle(handle: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_uv_handle(handle: *c_void, data: *c_void);\n+    fn rust_uv_get_data_for_req(req: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n+    fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n+    fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> size_t;\n }"}, {"sha": "b89441d055d77c71a4cd7ea5739a558d5d6d6095", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/54bb7226e16090b471d791af5615016d01000504/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54bb7226e16090b471d791af5615016d01000504/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=54bb7226e16090b471d791af5615016d01000504", "patch": "@@ -930,8 +930,6 @@ pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n                       addr_ptr: *sockaddr_in,\n                       after_connect_cb: *u8)\n -> libc::c_int {\n-    log(debug, fmt!(\"b4 foreign tcp_connect--addr port: %u cb: %u\",\n-                    (*addr_ptr).sin_port as uint, after_connect_cb as uint));\n     return rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n                                     after_connect_cb, addr_ptr);\n }\n@@ -1021,22 +1019,8 @@ pub unsafe fn async_send(async_handle: *uv_async_t) {\n pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = uv_buf_t { base: ptr::null(), len: 0 as libc::size_t };\n     let out_buf_ptr = ptr::addr_of(&out_buf);\n-    log(debug, fmt!(\"buf_init - input %u len %u out_buf: %u\",\n-                     input as uint,\n-                     len as uint,\n-                     out_buf_ptr as uint));\n-    // yuck :/\n     rustrt::rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n-    //let result = rustrt::rust_uv_buf_init_2(input, len as size_t);\n-    log(debug, ~\"after rust_uv_buf_init\");\n-    let res_base = get_base_from_buf(out_buf);\n-    let res_len = get_len_from_buf(out_buf);\n-    //let res_base = get_base_from_buf(result);\n-    log(debug, fmt!(\"buf_init - result %u len %u\",\n-                     res_base as uint,\n-                     res_len as uint));\n     return out_buf;\n-    //return result;\n }\n pub unsafe fn ip4_addr(ip: &str, port: int)\n -> sockaddr_in {\n@@ -1078,8 +1062,6 @@ pub unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n                        0u8,0u8,0u8,0u8,0u8,0u8];\n     do vec::as_imm_buf(dst) |dst_buf, size| {\n         let src_unsafe_ptr = to_unsafe_ptr(src);\n-        log(debug, fmt!(\"val of src *sockaddr_in6: %? sockaddr_in6: %?\",\n-                        src_unsafe_ptr, src));\n         let result = rustrt::rust_uv_ip6_name(src_unsafe_ptr,\n                                               dst_buf, size as libc::size_t);\n         match result {"}, {"sha": "325b10b92df6b5f9ea8dad9ac66c4f37dbb5ff9b", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/54bb7226e16090b471d791af5615016d01000504/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/54bb7226e16090b471d791af5615016d01000504/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=54bb7226e16090b471d791af5615016d01000504", "patch": "@@ -479,6 +479,34 @@ extern \"C\" struct sockaddr_in6\n rust_uv_ip6_addr(const char* ip, int port) {\n     return uv_ip6_addr(ip, port);\n }\n+\n+extern \"C\" struct sockaddr_in*\n+rust_uv_ip4_addrp(const char* ip, int port) {\n+  struct sockaddr_in addr = uv_ip4_addr(ip, port);\n+  struct sockaddr_in *addrp = (sockaddr_in*)malloc(sizeof(struct sockaddr_in));\n+  assert(addrp);\n+  memcpy(addrp, &addr, sizeof(struct sockaddr_in));\n+  return addrp;\n+}\n+extern \"C\" struct sockaddr_in6*\n+rust_uv_ip6_addrp(const char* ip, int port) {\n+  struct sockaddr_in6 addr = uv_ip6_addr(ip, port);\n+  struct sockaddr_in6 *addrp = (sockaddr_in6*)malloc(sizeof(struct sockaddr_in6));\n+  assert(addrp);\n+  memcpy(addrp, &addr, sizeof(struct sockaddr_in6));\n+  return addrp;\n+}\n+\n+extern \"C\" void\n+rust_uv_free_ip4_addr(sockaddr_in *addrp) {\n+  free(addrp);\n+}\n+\n+extern \"C\" void\n+rust_uv_free_ip6_addr(sockaddr_in6 *addrp) {\n+  free(addrp);\n+}\n+\n extern \"C\" int\n rust_uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size) {\n     return uv_ip4_name(src, dst, size);\n@@ -563,3 +591,23 @@ extern \"C\" int\n rust_uv_idle_stop(uv_idle_t* idle) {\n   return uv_idle_stop(idle);\n }\n+\n+extern \"C\" size_t\n+rust_uv_handle_size(uintptr_t type) {\n+  return uv_handle_size((uv_handle_type)type);\n+}\n+\n+extern \"C\" size_t\n+rust_uv_req_size(uintptr_t type) {\n+  return uv_req_size((uv_req_type)type);\n+}\n+\n+extern \"C\" uintptr_t\n+rust_uv_handle_type_max() {\n+  return UV_HANDLE_TYPE_MAX;\n+}\n+\n+extern \"C\" uintptr_t\n+rust_uv_req_type_max() {\n+  return UV_REQ_TYPE_MAX;\n+}"}, {"sha": "4fde952ba956507f2270c1722542051be0c78526", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/54bb7226e16090b471d791af5615016d01000504/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/54bb7226e16090b471d791af5615016d01000504/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=54bb7226e16090b471d791af5615016d01000504", "patch": "@@ -202,3 +202,12 @@ rust_dbg_extern_identity_TwoU64s\n rust_dbg_extern_identity_double\n rust_dbg_extern_identity_u8\n rust_get_rt_env\n+rust_uv_handle_size\n+rust_uv_req_size\n+rust_uv_handle_type_max\n+rust_uv_req_type_max\n+rust_uv_ip4_addrp\n+rust_uv_ip6_addrp\n+rust_uv_free_ip4_addr\n+rust_uv_free_ip6_addr\n+"}]}