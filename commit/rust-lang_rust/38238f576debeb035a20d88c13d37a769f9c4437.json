{"sha": "38238f576debeb035a20d88c13d37a769f9c4437", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MjM4ZjU3NmRlYmViMDM1YTIwZDg4YzEzZDM3YTc2OWY5YzQ0Mzc=", "commit": {"author": {"name": "Yati Sagade", "email": "yati.sagade@gmail.com", "date": "2016-12-31T21:35:39Z"}, "committer": {"name": "Yati Sagade", "email": "yati.sagade@gmail.com", "date": "2017-04-08T21:30:34Z"}, "message": "[needless_continue] Add comments explaining terminology used thoughout in the code.", "tree": {"sha": "098c86d69f18fccb0673c2fe6d7d95cdcdfcf5b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/098c86d69f18fccb0673c2fe6d7d95cdcdfcf5b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38238f576debeb035a20d88c13d37a769f9c4437", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38238f576debeb035a20d88c13d37a769f9c4437", "html_url": "https://github.com/rust-lang/rust/commit/38238f576debeb035a20d88c13d37a769f9c4437", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38238f576debeb035a20d88c13d37a769f9c4437/comments", "author": {"login": "yati-sagade", "id": 966274, "node_id": "MDQ6VXNlcjk2NjI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/966274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yati-sagade", "html_url": "https://github.com/yati-sagade", "followers_url": "https://api.github.com/users/yati-sagade/followers", "following_url": "https://api.github.com/users/yati-sagade/following{/other_user}", "gists_url": "https://api.github.com/users/yati-sagade/gists{/gist_id}", "starred_url": "https://api.github.com/users/yati-sagade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yati-sagade/subscriptions", "organizations_url": "https://api.github.com/users/yati-sagade/orgs", "repos_url": "https://api.github.com/users/yati-sagade/repos", "events_url": "https://api.github.com/users/yati-sagade/events{/privacy}", "received_events_url": "https://api.github.com/users/yati-sagade/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yati-sagade", "id": 966274, "node_id": "MDQ6VXNlcjk2NjI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/966274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yati-sagade", "html_url": "https://github.com/yati-sagade", "followers_url": "https://api.github.com/users/yati-sagade/followers", "following_url": "https://api.github.com/users/yati-sagade/following{/other_user}", "gists_url": "https://api.github.com/users/yati-sagade/gists{/gist_id}", "starred_url": "https://api.github.com/users/yati-sagade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yati-sagade/subscriptions", "organizations_url": "https://api.github.com/users/yati-sagade/orgs", "repos_url": "https://api.github.com/users/yati-sagade/repos", "events_url": "https://api.github.com/users/yati-sagade/events{/privacy}", "received_events_url": "https://api.github.com/users/yati-sagade/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9396120008745a1caf3027c6f8badaf4aef3587c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9396120008745a1caf3027c6f8badaf4aef3587c", "html_url": "https://github.com/rust-lang/rust/commit/9396120008745a1caf3027c6f8badaf4aef3587c"}], "stats": {"total": 170, "additions": 109, "deletions": 61}, "files": [{"sha": "c6ae0113f91fde49784abcb2439def2af2f8db65", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 109, "deletions": 61, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/38238f576debeb035a20d88c13d37a769f9c4437/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38238f576debeb035a20d88c13d37a769f9c4437/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=38238f576debeb035a20d88c13d37a769f9c4437", "patch": "@@ -33,7 +33,6 @@ use syntax::ast;\n use syntax::codemap::{original_sp,DUMMY_SP};\n \n use utils::{in_macro, span_help_and_lint, snippet_block, snippet};\n-use self::LintType::*;\n \n /// **What it does:** The lint checks for `if`-statements appearing in loops\n /// that contain a `continue` statement in either their main blocks or their\n@@ -117,34 +116,78 @@ impl EarlyLintPass for NeedlessContinue {\n     }\n }\n \n-/// Given an Expr, returns true if either of the following is true\n+/* This lint has to mainly deal with two cases of needless continue statements.\n+ *\n+ * Case 1 [Continue inside else block]:\n+ *\n+ *     loop {\n+ *         // region A\n+ *         if cond {\n+ *             // region B\n+ *         } else {\n+ *             continue;\n+ *         }\n+ *         // region C\n+ *     }\n+ *\n+ * This code can better be written as follows:\n+ *\n+ *     loop {\n+ *         // region A\n+ *         if cond {\n+ *             // region B\n+ *             // region C\n+ *         }\n+ *     }\n+ *\n+ * Case 2 [Continue inside then block]:\n+ *\n+ *     loop {\n+ *       // region A\n+ *       if cond {\n+ *           continue;\n+ *           // potentially more code here.\n+ *       } else {\n+ *           // region B\n+ *       }\n+ *       // region C\n+ *     }\n+ *\n+ *\n+ * This snippet can be refactored to:\n+ *\n+ *     loop {\n+ *       // region A\n+ *       if !cond {\n+ *           // region B\n+ *           // region C\n+ *       }\n+ *     }\n+ */\n+\n+/// Given an expression, returns true if either of the following is true\n ///\n-/// - The Expr is a `continue` node.\n-/// - The Expr node is a block with the first statement being a `continue`.\n+/// - The expression is a `continue` node.\n+/// - The expression node is a block with the first statement being a `continue`.\n ///\n fn needless_continue_in_else(else_expr: &ast::Expr) -> bool {\n-    let mut found = false;\n     match else_expr.node {\n-        ast::ExprKind::Block(ref else_block) => {\n-            found = is_first_block_stmt_continue(else_block);\n-        },\n-        ast::ExprKind::Continue(_) => { found = true },\n-        _ => { },\n-    };\n-    found\n+        ast::ExprKind::Block(ref else_block) => is_first_block_stmt_continue(else_block),\n+        ast::ExprKind::Continue(_) => true,\n+        _ => false,\n+    }\n }\n \n fn is_first_block_stmt_continue(block: &ast::Block) -> bool {\n-    let mut ret = false;\n-    block.stmts.get(0).map(|stmt| {\n-        if_let_chain! {[\n-            let ast::StmtKind::Semi(ref e) = stmt.node,\n-            let ast::ExprKind::Continue(_) = e.node,\n-        ], {\n-            ret = true;\n-        }}\n-    });\n-    ret\n+    block.stmts.get(0).map_or(false, |stmt| match stmt.node {\n+        ast::StmtKind::Semi(ref e) |\n+        ast::StmtKind::Expr(ref e) => if let ast::ExprKind::Continue(_) = e.node {\n+            true\n+        } else {\n+            false\n+        },\n+        _ => false,\n+    })\n }\n \n /// If `expr` is a loop expression (while/while let/for/loop), calls `func` with\n@@ -159,13 +202,13 @@ fn with_loop_block<F>(expr: &ast::Expr, mut func: F) where F: FnMut(&ast::Block)\n     }\n }\n \n-/// If `stmt` is an if expression node with an else branch, calls func with the\n+/// If `stmt` is an if expression node with an `else` branch, calls func with the\n /// following:\n ///\n-/// - The if Expr,\n-/// - The if condition Expr,\n-/// - The then block of this if Expr, and\n-/// - The else expr.\n+/// - The `if` expression itself,\n+/// - The `if` condition expression,\n+/// - The `then` block, and\n+/// - The `else` expression.\n ///\n fn with_if_expr<F>(stmt: &ast::Stmt, mut func: F)\n         where F: FnMut(&ast::Expr, &ast::Expr, &ast::Block, &ast::Expr) {\n@@ -188,15 +231,19 @@ enum LintType {\n \n /// Data we pass around for construction of help messages.\n struct LintData<'a> {\n-    if_expr:     &'a ast::Expr,    // The `if` expr encountered in the above loop.\n-    if_cond:     &'a ast::Expr,    // The condition expression for the above `if`.\n-    if_block:    &'a ast::Block,   // The `then` block of the `if` statement.\n-    else_expr:   &'a ast::Expr,    /* The `else` block of the `if` statement.\n-                                      Note that we only work with `if` exprs that\n-                                      have an `else` branch. */\n-    stmt_idx:    usize,            /* The 0-based index of the `if` statement in\n-                                      the containing loop block. */\n-    block_stmts: &'a [ast::Stmt],  // The statements of the loop block.\n+    /// The `if` expression encountered in the above loop.\n+    if_expr: &'a ast::Expr,\n+    /// The condition expression for the above `if`.\n+    if_cond: &'a ast::Expr,\n+    /// The `then` block of the `if` statement.\n+    if_block: &'a ast::Block,\n+    /// The `else` block of the `if` statement.\n+    /// Note that we only work with `if` exprs that have an `else` branch.\n+    else_expr: &'a ast::Expr,\n+    /// The 0-based index of the `if` statement in the containing loop block.\n+    stmt_idx: usize,\n+    /// The statements of the loop block.\n+    block_stmts: &'a [ast::Stmt],\n }\n \n const MSG_REDUNDANT_ELSE_BLOCK: &'static str = \"This else block is redundant.\\n\";\n@@ -219,12 +266,12 @@ fn emit_warning<'a>(ctx: &EarlyContext,\n     // message is the warning message.\n     // expr    is the expression which the lint warning message refers to.\n     let (snip, message, expr) = match typ {\n-        ContinueInsideElseBlock => {\n+        LintType::ContinueInsideElseBlock => {\n             (suggestion_snippet_for_continue_inside_else(ctx, data, header),\n              MSG_REDUNDANT_ELSE_BLOCK,\n              data.else_expr)\n         },\n-        ContinueInsideThenBlock => {\n+        LintType::ContinueInsideThenBlock => {\n             (suggestion_snippet_for_continue_inside_if(ctx, data, header),\n              MSG_ELSE_BLOCK_NOT_NEEDED,\n              data.if_expr)\n@@ -236,7 +283,7 @@ fn emit_warning<'a>(ctx: &EarlyContext,\n fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext,\n                                                 data: &'a LintData,\n                                                 header: &str) -> String {\n-    let cond_code = &snippet(ctx, data.if_cond.span, \"..\").into_owned();\n+    let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n \n     let if_code   = format!(\"if {} {{\\n    continue;\\n}}\\n\", cond_code);\n                                    /*  ^^^^--- Four spaces of indentation. */\n@@ -256,14 +303,14 @@ fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext,\n                                                    data: &'a LintData,\n                                                    header: &str) -> String\n {\n-    let cond_code = &snippet(ctx, data.if_cond.span, \"..\").into_owned();\n+    let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n     let mut if_code   = format!(\"if {} {{\\n\", cond_code);\n \n     // Region B\n     let block_code = &snippet(ctx, data.if_block.span, \"..\").into_owned();\n     let block_code = erode_block(block_code);\n     let block_code = trim_indent(&block_code, false);\n-    let block_code = left_pad_lines_with_spaces(&block_code, 4usize);\n+    let block_code = left_pad_lines_with_spaces(&block_code, 4_usize);\n \n     if_code.push_str(&block_code);\n \n@@ -300,9 +347,9 @@ fn check_and_warn<'a>(ctx: &EarlyContext, expr: &'a ast::Expr) {\n                     block_stmts: &loop_block.stmts,\n                 };\n                 if needless_continue_in_else(else_expr) {\n-                    emit_warning(ctx, data, DROP_ELSE_BLOCK_AND_MERGE_MSG, ContinueInsideElseBlock);\n+                    emit_warning(ctx, data, DROP_ELSE_BLOCK_AND_MERGE_MSG, LintType::ContinueInsideElseBlock);\n                 } else if is_first_block_stmt_continue(then_block) {\n-                    emit_warning(ctx, data, DROP_ELSE_BLOCK_MSG, ContinueInsideThenBlock);\n+                    emit_warning(ctx, data, DROP_ELSE_BLOCK_MSG, LintType::ContinueInsideThenBlock);\n                 }\n             });\n         }\n@@ -361,7 +408,7 @@ fn indent_level(s: &str) -> usize {\n     s.chars()\n      .enumerate()\n      .find(|&(_, c)| !c.is_whitespace())\n-     .map_or(0usize, |(i, _)| i)\n+     .map_or(0_usize, |(i, _)| i)\n }\n \n /// Trims indentation from a snippet such that the line with the minimum\n@@ -372,7 +419,7 @@ fn trim_indent(s: &str, skip_first_line: bool) -> String {\n                             .skip(skip_first_line as usize)\n                             .map(indent_level)\n                             .min()\n-                            .unwrap_or(0usize);\n+                            .unwrap_or(0_usize);\n     let ret = s.lines().map(|line| {\n         if is_null(line) {\n             String::from(line)\n@@ -421,14 +468,14 @@ fn align_two_snippets(s: &str, t: &str) -> String {\n                          .rev()\n                          .skip_while(|line| line.is_empty() || is_all_whitespace(line))\n                          .next()\n-                         .map_or(0usize, indent_level);\n+                         .map_or(0_usize, indent_level);\n \n     // We want to align the first nonempty, non-all-whitespace line of t to\n     // have the same indent level as target_ilevel\n     let level = t.lines()\n                  .skip_while(|line| line.is_empty() || is_all_whitespace(line))\n                  .next()\n-                 .map_or(0usize, indent_level);\n+                 .map_or(0_usize, indent_level);\n \n     let add_or_not_remove = target_ilevel > level; /* when true, we add spaces,\n                                                       otherwise eat. */\n@@ -440,28 +487,29 @@ fn align_two_snippets(s: &str, t: &str) -> String {\n     };\n \n     let new_t = t.lines()\n-                 .filter(|line| !is_null(line))\n-                 .map(|line| if add_or_not_remove {\n-                     left_pad_with_spaces(line, delta)\n-                 } else {\n-                     remove_whitespace_from_left(line, delta)\n+                 .filter_map(|line| {\n+                     if is_null(line) {\n+                         None\n+                     } else if add_or_not_remove {\n+                         Some(left_pad_with_spaces(line, delta))\n+                     } else {\n+                         Some(remove_whitespace_from_left(line, delta))\n+                     }\n                  })\n                  .collect::<Vec<_>>().join(\"\\n\");\n \n     format!(\"{}\\n{}\", s, new_t)\n }\n \n fn align_snippets(xs: &[&str]) -> String {\n-    match xs.len() {\n-        0 => String::from(\"\"),\n-        _ => {\n-            let mut ret = String::new();\n-            ret.push_str(xs[0]);\n-            for x in xs.iter().skip(1usize) {\n-                ret = align_two_snippets(&ret, x);\n-            }\n-            ret\n+    if xs.is_empty() {\n+        String::from(\"\")\n+    } else {\n+        let mut ret = xs[0].to_string();\n+        for x in xs.iter().skip(1_usize) {\n+            ret = align_two_snippets(&ret, x);\n         }\n+        ret\n     }\n }\n "}]}