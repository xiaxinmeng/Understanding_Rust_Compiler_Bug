{"sha": "95fb05d4d87e5cbf42d2208b218ba8c10d4c311a", "node_id": "C_kwDOAAsO6NoAKDk1ZmIwNWQ0ZDg3ZTVjYmY0MmQyMjA4YjIxOGJhOGMxMGQ0YzMxMWE", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-22T19:03:33Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-05-13T17:42:52Z"}, "message": "rustdoc: Remove `ResolutionFailure::Dummy`\n\nThe variant resolution check didn't make sense, and derive trait collision could be processed in a different way", "tree": {"sha": "3819c8acffcab1a527d278abe1ee20e8fc5bc620", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3819c8acffcab1a527d278abe1ee20e8fc5bc620"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95fb05d4d87e5cbf42d2208b218ba8c10d4c311a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95fb05d4d87e5cbf42d2208b218ba8c10d4c311a", "html_url": "https://github.com/rust-lang/rust/commit/95fb05d4d87e5cbf42d2208b218ba8c10d4c311a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95fb05d4d87e5cbf42d2208b218ba8c10d4c311a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c979ef5d8c1347a26fd63035ef256931df9f8a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/c979ef5d8c1347a26fd63035ef256931df9f8a91", "html_url": "https://github.com/rust-lang/rust/commit/c979ef5d8c1347a26fd63035ef256931df9f8a91"}], "stats": {"total": 57, "additions": 20, "deletions": 37}, "files": [{"sha": "2a999ed6567c66c5b1012150e73a3be3c439d077", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 20, "deletions": 37, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/95fb05d4d87e5cbf42d2208b218ba8c10d4c311a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fb05d4d87e5cbf42d2208b218ba8c10d4c311a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=95fb05d4d87e5cbf42d2208b218ba8c10d4c311a", "patch": "@@ -181,11 +181,6 @@ enum ResolutionFailure<'a> {\n         /// In `[std::io::Error::x]`, `x` would be unresolved.\n         unresolved: Cow<'a, str>,\n     },\n-    /// Used to communicate that this should be ignored, but shouldn't be reported to the user.\n-    ///\n-    /// This happens when there is no disambiguator and one of the namespaces\n-    /// failed to resolve.\n-    Dummy,\n }\n \n #[derive(Clone, Copy, Debug)]\n@@ -405,35 +400,22 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let ty_res = self.resolve_path(&path, TypeNS, item_id, module_id).ok_or_else(no_res)?;\n \n         match ty_res {\n-            Res::Def(DefKind::Enum, did) => {\n-                if tcx\n-                    .inherent_impls(did)\n-                    .iter()\n-                    .flat_map(|imp| tcx.associated_items(*imp).in_definition_order())\n-                    .any(|item| item.name == variant_name)\n-                {\n-                    // This is just to let `fold_item` know that this shouldn't be considered;\n-                    // it's a bug for the error to make it to the user\n-                    return Err(ResolutionFailure::Dummy.into());\n-                }\n-                match tcx.type_of(did).kind() {\n-                    ty::Adt(def, _) if def.is_enum() => {\n-                        if let Some(field) = def.all_fields().find(|f| f.name == variant_field_name)\n-                        {\n-                            Ok((ty_res, Some(ItemFragment(FragmentKind::VariantField, field.did))))\n-                        } else {\n-                            Err(ResolutionFailure::NotResolved {\n-                                item_id,\n-                                module_id,\n-                                partial_res: Some(Res::Def(DefKind::Enum, def.did())),\n-                                unresolved: variant_field_name.to_string().into(),\n-                            }\n-                            .into())\n+            Res::Def(DefKind::Enum, did) => match tcx.type_of(did).kind() {\n+                ty::Adt(def, _) if def.is_enum() => {\n+                    if let Some(field) = def.all_fields().find(|f| f.name == variant_field_name) {\n+                        Ok((ty_res, Some(ItemFragment(FragmentKind::VariantField, field.did))))\n+                    } else {\n+                        Err(ResolutionFailure::NotResolved {\n+                            item_id,\n+                            module_id,\n+                            partial_res: Some(Res::Def(DefKind::Enum, def.did())),\n+                            unresolved: variant_field_name.to_string().into(),\n                         }\n+                        .into())\n                     }\n-                    _ => unreachable!(),\n                 }\n-            }\n+                _ => unreachable!(),\n+            },\n             _ => Err(ResolutionFailure::NotResolved {\n                 item_id,\n                 module_id,\n@@ -1535,7 +1517,7 @@ impl LinkCollector<'_, '_> {\n             }\n             None => {\n                 // Try everything!\n-                let mut candidates = PerNS {\n+                let candidates = PerNS {\n                     macro_ns: self\n                         .resolve_macro(path_str, item_id, base_node)\n                         .map(|res| (res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n@@ -1611,11 +1593,13 @@ impl LinkCollector<'_, '_> {\n                 } else if len == 2 && is_derive_trait_collision(&candidates) {\n                     Some(candidates.type_ns.unwrap())\n                 } else {\n-                    if is_derive_trait_collision(&candidates) {\n-                        candidates.macro_ns = Err(ResolutionFailure::Dummy);\n-                    }\n+                    let ignore_macro = is_derive_trait_collision(&candidates);\n                     // If we're reporting an ambiguity, don't mention the namespaces that failed\n-                    let candidates = candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n+                    let mut candidates =\n+                        candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n+                    if ignore_macro {\n+                        candidates.macro_ns = None;\n+                    }\n                     ambiguity_error(self.cx, diag, path_str, candidates.present_items().collect());\n                     None\n                 }\n@@ -2092,7 +2076,6 @@ fn resolution_failure(\n                 }\n                 let note = match failure {\n                     ResolutionFailure::NotResolved { .. } => unreachable!(\"handled above\"),\n-                    ResolutionFailure::Dummy => continue,\n                     ResolutionFailure::WrongNamespace { res, expected_ns } => {\n                         suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n "}]}