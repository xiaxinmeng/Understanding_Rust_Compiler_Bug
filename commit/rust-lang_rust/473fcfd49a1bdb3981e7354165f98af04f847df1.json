{"sha": "473fcfd49a1bdb3981e7354165f98af04f847df1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3M2ZjZmQ0OWExYmRiMzk4MWU3MzU0MTY1Zjk4YWYwNGY4NDdkZjE=", "commit": {"author": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2017-12-21T20:54:16Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-22T09:51:27Z"}, "message": "new function to pull the links from a chunk of markdown", "tree": {"sha": "4ce2496dc4a574068dd7560d1ca3153b44d12480", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ce2496dc4a574068dd7560d1ca3153b44d12480"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/473fcfd49a1bdb3981e7354165f98af04f847df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/473fcfd49a1bdb3981e7354165f98af04f847df1", "html_url": "https://github.com/rust-lang/rust/commit/473fcfd49a1bdb3981e7354165f98af04f847df1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/473fcfd49a1bdb3981e7354165f98af04f847df1/comments", "author": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc072ed0ca8e2e9f8c79fb04e85b47b5c0e8d6ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc072ed0ca8e2e9f8c79fb04e85b47b5c0e8d6ae", "html_url": "https://github.com/rust-lang/rust/commit/bc072ed0ca8e2e9f8c79fb04e85b47b5c0e8d6ae"}], "stats": {"total": 417, "additions": 250, "deletions": 167}, "files": [{"sha": "498c8911dc0362b79b9347279b21f7bc2bef5e42", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 250, "deletions": 167, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/473fcfd49a1bdb3981e7354165f98af04f847df1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473fcfd49a1bdb3981e7354165f98af04f847df1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=473fcfd49a1bdb3981e7354165f98af04f847df1", "patch": "@@ -527,6 +527,7 @@ struct MyOpaque {\n                            *const hoedown_buffer, *const hoedown_renderer_data,\n                            libc::size_t),\n     toc_builder: Option<TocBuilder>,\n+    links: Option<Vec<String>>,\n }\n \n extern {\n@@ -555,201 +556,203 @@ impl hoedown_buffer {\n     }\n }\n \n-pub fn render(w: &mut fmt::Formatter,\n-              s: &str,\n-              print_toc: bool,\n-              html_flags: libc::c_uint) -> fmt::Result {\n-    extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n-                    lang: *const hoedown_buffer, data: *const hoedown_renderer_data,\n-                    line: libc::size_t) {\n-        unsafe {\n-            if orig_text.is_null() { return }\n-\n-            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n-            let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n-            let text = (*orig_text).as_bytes();\n-            let origtext = str::from_utf8(text).unwrap();\n-            let origtext = origtext.trim_left();\n-            debug!(\"docblock: ==============\\n{:?}\\n=======\", text);\n-            let mut compile_fail = false;\n-            let mut ignore = false;\n-\n-            let rendered = if lang.is_null() || origtext.is_empty() {\n-                false\n+extern fn hoedown_block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n+                        lang: *const hoedown_buffer, data: *const hoedown_renderer_data,\n+                        line: libc::size_t) {\n+    unsafe {\n+        if orig_text.is_null() { return }\n+\n+        let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n+        let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n+        let text = (*orig_text).as_bytes();\n+        let origtext = str::from_utf8(text).unwrap();\n+        let origtext = origtext.trim_left();\n+        debug!(\"docblock: ==============\\n{:?}\\n=======\", text);\n+        let mut compile_fail = false;\n+        let mut ignore = false;\n+\n+        let rendered = if lang.is_null() || origtext.is_empty() {\n+            false\n+        } else {\n+            let rlang = (*lang).as_bytes();\n+            let rlang = str::from_utf8(rlang).unwrap();\n+            let parse_result = LangString::parse(rlang);\n+            compile_fail = parse_result.compile_fail;\n+            ignore = parse_result.ignore;\n+            if !parse_result.rust {\n+                (my_opaque.dfltblk)(ob, orig_text, lang,\n+                                    opaque as *const hoedown_renderer_data,\n+                                    line);\n+                true\n             } else {\n-                let rlang = (*lang).as_bytes();\n-                let rlang = str::from_utf8(rlang).unwrap();\n-                let parse_result = LangString::parse(rlang);\n-                compile_fail = parse_result.compile_fail;\n-                ignore = parse_result.ignore;\n-                if !parse_result.rust {\n-                    (my_opaque.dfltblk)(ob, orig_text, lang,\n-                                        opaque as *const hoedown_renderer_data,\n-                                        line);\n-                    true\n+                false\n+            }\n+        };\n+\n+        let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n+        let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n+        if rendered { return }\n+        PLAYGROUND.with(|play| {\n+            // insert newline to clearly separate it from the\n+            // previous block so we can shorten the html output\n+            let mut s = String::from(\"\\n\");\n+            let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n+                if url.is_empty() {\n+                    return None;\n+                }\n+                let test = origtext.lines()\n+                    .map(|l| map_line(l).for_code())\n+                    .collect::<Vec<&str>>().join(\"\\n\");\n+                let krate = krate.as_ref().map(|s| &**s);\n+                let (test, _) = test::make_test(&test, krate, false,\n+                                                &Default::default());\n+                let channel = if test.contains(\"#![feature(\") {\n+                    \"&amp;version=nightly\"\n                 } else {\n-                    false\n+                    \"\"\n+                };\n+                // These characters don't need to be escaped in a URI.\n+                // FIXME: use a library function for percent encoding.\n+                fn dont_escape(c: u8) -> bool {\n+                    (b'a' <= c && c <= b'z') ||\n+                    (b'A' <= c && c <= b'Z') ||\n+                    (b'0' <= c && c <= b'9') ||\n+                    c == b'-' || c == b'_' || c == b'.' ||\n+                    c == b'~' || c == b'!' || c == b'\\'' ||\n+                    c == b'(' || c == b')' || c == b'*'\n                 }\n-            };\n-\n-            let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n-            let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-            if rendered { return }\n-            PLAYGROUND.with(|play| {\n-                // insert newline to clearly separate it from the\n-                // previous block so we can shorten the html output\n-                let mut s = String::from(\"\\n\");\n-                let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n-                    if url.is_empty() {\n-                        return None;\n-                    }\n-                    let test = origtext.lines()\n-                        .map(|l| map_line(l).for_code())\n-                        .collect::<Vec<&str>>().join(\"\\n\");\n-                    let krate = krate.as_ref().map(|s| &**s);\n-                    let (test, _) = test::make_test(&test, krate, false,\n-                                               &Default::default());\n-                    let channel = if test.contains(\"#![feature(\") {\n-                        \"&amp;version=nightly\"\n+                let mut test_escaped = String::new();\n+                for b in test.bytes() {\n+                    if dont_escape(b) {\n+                        test_escaped.push(char::from(b));\n                     } else {\n-                        \"\"\n-                    };\n-                    // These characters don't need to be escaped in a URI.\n-                    // FIXME: use a library function for percent encoding.\n-                    fn dont_escape(c: u8) -> bool {\n-                        (b'a' <= c && c <= b'z') ||\n-                        (b'A' <= c && c <= b'Z') ||\n-                        (b'0' <= c && c <= b'9') ||\n-                        c == b'-' || c == b'_' || c == b'.' ||\n-                        c == b'~' || c == b'!' || c == b'\\'' ||\n-                        c == b'(' || c == b')' || c == b'*'\n-                    }\n-                    let mut test_escaped = String::new();\n-                    for b in test.bytes() {\n-                        if dont_escape(b) {\n-                            test_escaped.push(char::from(b));\n-                        } else {\n-                            write!(test_escaped, \"%{:02X}\", b).unwrap();\n-                        }\n+                        write!(test_escaped, \"%{:02X}\", b).unwrap();\n                     }\n-                    Some(format!(\n-                        r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}\">Run</a>\"#,\n-                        url, test_escaped, channel\n-                    ))\n-                });\n-                let tooltip = if ignore {\n-                    Some((\"This example is not tested\", \"ignore\"))\n-                } else if compile_fail {\n-                    Some((\"This example deliberately fails to compile\", \"compile_fail\"))\n-                } else {\n-                    None\n-                };\n-                s.push_str(&highlight::render_with_highlighting(\n-                               &text,\n-                               Some(&format!(\"rust-example-rendered{}\",\n-                                             if ignore { \" ignore\" }\n-                                             else if compile_fail { \" compile_fail\" }\n-                                             else { \"\" })),\n-                               None,\n-                               playground_button.as_ref().map(String::as_str),\n-                               tooltip));\n-                hoedown_buffer_put(ob, s.as_ptr(), s.len());\n-            })\n-        }\n+                }\n+                Some(format!(\n+                    r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}\">Run</a>\"#,\n+                    url, test_escaped, channel\n+                ))\n+            });\n+            let tooltip = if ignore {\n+                Some((\"This example is not tested\", \"ignore\"))\n+            } else if compile_fail {\n+                Some((\"This example deliberately fails to compile\", \"compile_fail\"))\n+            } else {\n+                None\n+            };\n+            s.push_str(&highlight::render_with_highlighting(\n+                           &text,\n+                           Some(&format!(\"rust-example-rendered{}\",\n+                                         if ignore { \" ignore\" }\n+                                         else if compile_fail { \" compile_fail\" }\n+                                         else { \"\" })),\n+                           None,\n+                           playground_button.as_ref().map(String::as_str),\n+                           tooltip));\n+            hoedown_buffer_put(ob, s.as_ptr(), s.len());\n+        })\n     }\n+}\n \n-    extern fn header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n-                     level: libc::c_int, data: *const hoedown_renderer_data,\n-                     _: libc::size_t) {\n-        // hoedown does this, we may as well too\n-        unsafe { hoedown_buffer_put(ob, \"\\n\".as_ptr(), 1); }\n+extern fn hoedown_header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n+                         level: libc::c_int, data: *const hoedown_renderer_data,\n+                         _: libc::size_t) {\n+    // hoedown does this, we may as well too\n+    unsafe { hoedown_buffer_put(ob, \"\\n\".as_ptr(), 1); }\n \n-        // Extract the text provided\n-        let s = if text.is_null() {\n-            \"\".to_owned()\n-        } else {\n-            let s = unsafe { (*text).as_bytes() };\n-            str::from_utf8(&s).unwrap().to_owned()\n-        };\n+    // Extract the text provided\n+    let s = if text.is_null() {\n+        \"\".to_owned()\n+    } else {\n+        let s = unsafe { (*text).as_bytes() };\n+        str::from_utf8(&s).unwrap().to_owned()\n+    };\n \n-        // Discard '<em>', '<code>' tags and some escaped characters,\n-        // transform the contents of the header into a hyphenated string\n-        // without non-alphanumeric characters other than '-' and '_'.\n-        //\n-        // This is a terrible hack working around how hoedown gives us rendered\n-        // html for text rather than the raw text.\n-        let mut id = s.clone();\n-        let repl_sub = vec![\"<em>\", \"</em>\", \"<code>\", \"</code>\",\n-                            \"<strong>\", \"</strong>\",\n-                            \"&lt;\", \"&gt;\", \"&amp;\", \"&#39;\", \"&quot;\"];\n-        for sub in repl_sub {\n-            id = id.replace(sub, \"\");\n-        }\n-        let id = id.chars().filter_map(|c| {\n-            if c.is_alphanumeric() || c == '-' || c == '_' {\n-                if c.is_ascii() {\n-                    Some(c.to_ascii_lowercase())\n-                } else {\n-                    Some(c)\n-                }\n-            } else if c.is_whitespace() && c.is_ascii() {\n-                Some('-')\n+    // Discard '<em>', '<code>' tags and some escaped characters,\n+    // transform the contents of the header into a hyphenated string\n+    // without non-alphanumeric characters other than '-' and '_'.\n+    //\n+    // This is a terrible hack working around how hoedown gives us rendered\n+    // html for text rather than the raw text.\n+    let mut id = s.clone();\n+    let repl_sub = vec![\"<em>\", \"</em>\", \"<code>\", \"</code>\",\n+                        \"<strong>\", \"</strong>\",\n+                        \"&lt;\", \"&gt;\", \"&amp;\", \"&#39;\", \"&quot;\"];\n+    for sub in repl_sub {\n+        id = id.replace(sub, \"\");\n+    }\n+    let id = id.chars().filter_map(|c| {\n+        if c.is_alphanumeric() || c == '-' || c == '_' {\n+            if c.is_ascii() {\n+                Some(c.to_ascii_lowercase())\n             } else {\n-                None\n+                Some(c)\n             }\n-        }).collect::<String>();\n+        } else if c.is_whitespace() && c.is_ascii() {\n+            Some('-')\n+        } else {\n+            None\n+        }\n+    }).collect::<String>();\n \n-        let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n-        let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n+    let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n+    let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n \n-        let id = derive_id(id);\n+    let id = derive_id(id);\n \n-        let sec = opaque.toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n-            format!(\"{} \", builder.push(level as u32, s.clone(), id.clone()))\n-        });\n+    let sec = opaque.toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n+        format!(\"{} \", builder.push(level as u32, s.clone(), id.clone()))\n+    });\n \n-        // Render the HTML\n-        let text = format!(\"<h{lvl} id='{id}' class='section-header'>\\\n-                           <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n-                           s, lvl = level, id = id, sec = sec);\n+    // Render the HTML\n+    let text = format!(\"<h{lvl} id='{id}' class='section-header'>\\\n+                       <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n+                       s, lvl = level, id = id, sec = sec);\n \n-        unsafe { hoedown_buffer_put(ob, text.as_ptr(), text.len()); }\n-    }\n+    unsafe { hoedown_buffer_put(ob, text.as_ptr(), text.len()); }\n+}\n \n-    extern fn codespan(\n-        ob: *mut hoedown_buffer,\n-        text: *const hoedown_buffer,\n-        _: *const hoedown_renderer_data,\n-        _: libc::size_t\n-    ) -> libc::c_int {\n-        let content = if text.is_null() {\n-            \"\".to_owned()\n-        } else {\n-            let bytes = unsafe { (*text).as_bytes() };\n-            let s = str::from_utf8(bytes).unwrap();\n-            collapse_whitespace(s)\n-        };\n+extern fn hoedown_codespan(\n+    ob: *mut hoedown_buffer,\n+    text: *const hoedown_buffer,\n+    _: *const hoedown_renderer_data,\n+    _: libc::size_t\n+) -> libc::c_int {\n+    let content = if text.is_null() {\n+        \"\".to_owned()\n+    } else {\n+        let bytes = unsafe { (*text).as_bytes() };\n+        let s = str::from_utf8(bytes).unwrap();\n+        collapse_whitespace(s)\n+    };\n \n-        let content = format!(\"<code>{}</code>\", Escape(&content));\n-        unsafe {\n-            hoedown_buffer_put(ob, content.as_ptr(), content.len());\n-        }\n-        // Return anything except 0, which would mean \"also print the code span verbatim\".\n-        1\n+    let content = format!(\"<code>{}</code>\", Escape(&content));\n+    unsafe {\n+        hoedown_buffer_put(ob, content.as_ptr(), content.len());\n     }\n+    // Return anything except 0, which would mean \"also print the code span verbatim\".\n+    1\n+}\n+\n+pub fn render(w: &mut fmt::Formatter,\n+              s: &str,\n+              print_toc: bool,\n+              html_flags: libc::c_uint) -> fmt::Result {\n \n     unsafe {\n         let ob = hoedown_buffer_new(DEF_OUNIT);\n         let renderer = hoedown_html_renderer_new(html_flags, 0);\n         let mut opaque = MyOpaque {\n             dfltblk: (*renderer).blockcode.unwrap(),\n-            toc_builder: if print_toc {Some(TocBuilder::new())} else {None}\n+            toc_builder: if print_toc {Some(TocBuilder::new())} else {None},\n+            links: None,\n         };\n         (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n                 = &mut opaque as *mut _ as *mut libc::c_void;\n-        (*renderer).blockcode = Some(block);\n-        (*renderer).header = Some(header);\n-        (*renderer).codespan = Some(codespan);\n+        (*renderer).blockcode = Some(hoedown_block);\n+        (*renderer).header = Some(hoedown_header);\n+        (*renderer).codespan = Some(hoedown_codespan);\n \n         let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n         hoedown_document_render(document, ob, s.as_ptr(),\n@@ -1140,6 +1143,86 @@ pub fn plain_summary_line(md: &str) -> String {\n     s\n }\n \n+pub fn markdown_links(md: &str, render_type: RenderType) -> Vec<String> {\n+    if md.is_empty() {\n+        return vec![];\n+    }\n+\n+    match render_type {\n+        RenderType::Hoedown => {\n+            extern fn hoedown_link(\n+                _ob: *mut hoedown_buffer,\n+                _content: *const hoedown_buffer,\n+                link: *const hoedown_buffer,\n+                _title: *const hoedown_buffer,\n+                data: *const hoedown_renderer_data,\n+                _line: libc::size_t\n+            ) -> libc::c_int {\n+                if link.is_null() {\n+                    return 0;\n+                }\n+\n+                let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n+                let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n+\n+                if let Some(ref mut links) = opaque.links {\n+                    let s = unsafe { (*link).as_bytes() };\n+                    let s = str::from_utf8(&s).unwrap().to_owned();\n+\n+                    links.push(s);\n+                }\n+\n+                //returning 0 here means \"emit the span verbatim\", but we're not using the output\n+                //anyway so we don't really care\n+                0\n+            }\n+\n+            unsafe {\n+                let ob = hoedown_buffer_new(DEF_OUNIT);\n+                let renderer = hoedown_html_renderer_new(0, 0);\n+                let mut opaque = MyOpaque {\n+                    dfltblk: (*renderer).blockcode.unwrap(),\n+                    toc_builder: None,\n+                    links: Some(vec![]),\n+                };\n+                (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n+                        = &mut opaque as *mut _ as *mut libc::c_void;\n+                (*renderer).blockcode = Some(hoedown_block);\n+                (*renderer).header = Some(hoedown_header);\n+                (*renderer).codespan = Some(hoedown_codespan);\n+                (*renderer).link = Some(hoedown_link);\n+\n+                let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n+                hoedown_document_render(document, ob, md.as_ptr(),\n+                                        md.len() as libc::size_t);\n+                hoedown_document_free(document);\n+\n+                hoedown_html_renderer_free(renderer);\n+\n+                opaque.links.unwrap()\n+            }\n+        }\n+        RenderType::Pulldown => {\n+            let mut opts = Options::empty();\n+            opts.insert(OPTION_ENABLE_TABLES);\n+            opts.insert(OPTION_ENABLE_FOOTNOTES);\n+\n+            let p = Parser::new_ext(md, opts);\n+\n+            let iter = Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None)));\n+            let mut links = vec![];\n+\n+            for ev in iter {\n+                if let Event::Start(Tag::Link(dest, _)) = ev {\n+                    links.push(dest.into_owned());\n+                }\n+            }\n+\n+            links\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::{LangString, Markdown, MarkdownHtml};"}]}