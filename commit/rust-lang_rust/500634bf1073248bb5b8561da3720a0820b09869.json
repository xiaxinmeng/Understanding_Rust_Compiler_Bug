{"sha": "500634bf1073248bb5b8561da3720a0820b09869", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMDYzNGJmMTA3MzI0OGJiNWI4NTYxZGEzNzIwYTA4MjBiMDk4Njk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-02T07:16:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-02T07:16:28Z"}, "message": "Rollup merge of #73622 - LeSeulArtichaut:unsafe-libcore, r=nikomatsakis\n\nDeny unsafe ops in unsafe fns in libcore\n\nAfter `liballoc`, It's time for `libcore` :D\n\nI planned to do this bit by bit to avoid having a big chunk of diffs, so to make reviews easier, and to make the unsafe blocks narrower and take the time to document them properly.\n\nr? @nikomatsakis cc @RalfJung", "tree": {"sha": "8cf1714bfa8e19c1e1d78bd65bbc39ec141e74da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cf1714bfa8e19c1e1d78bd65bbc39ec141e74da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/500634bf1073248bb5b8561da3720a0820b09869", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/YnMCRBK7hj4Ov3rIwAAdHIIADVsgfY8wPesoaPKVLDCUxpM\nOs6t0EOEO5IZJV2mwajEzbblYqjBRlnAcsPp/rZBHiiz4ZzPcZtKVeVKcejNzxEj\nD88OCeSQqYroTK1ErYrppfXqaiq6OfMePKMG9k3pK5WOQmRrHrmPdrEe09c1jig+\nDC4LhOJS0KdDnK0tocQBsxCndqqID7OL/P56sNvlRqBmKJSc7hobdEw2jp/RpXZC\nZUMJ61PnJo33ZNhXqMv8Vrzth6PXu6hX0Yop6Pvno2MhOzC1zufjXe0tDC4RCP5+\ncUlVTMh34lL7RzK6b7EACvSmA5+EaUv3h6ti/uFOtUEgkw+mpVUwmP7RH3Wa34I=\n=junY\n-----END PGP SIGNATURE-----\n", "payload": "tree 8cf1714bfa8e19c1e1d78bd65bbc39ec141e74da\nparent 1c68bb6ec9c6fa3eab136a917778ec0625fbdd20\nparent 6a7a6528f69ddb32574e486471c400fee6de8fd7\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593674188 -0700\ncommitter GitHub <noreply@github.com> 1593674188 -0700\n\nRollup merge of #73622 - LeSeulArtichaut:unsafe-libcore, r=nikomatsakis\n\nDeny unsafe ops in unsafe fns in libcore\n\nAfter `liballoc`, It's time for `libcore` :D\n\nI planned to do this bit by bit to avoid having a big chunk of diffs, so to make reviews easier, and to make the unsafe blocks narrower and take the time to document them properly.\n\nr? @nikomatsakis cc @RalfJung\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/500634bf1073248bb5b8561da3720a0820b09869", "html_url": "https://github.com/rust-lang/rust/commit/500634bf1073248bb5b8561da3720a0820b09869", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/500634bf1073248bb5b8561da3720a0820b09869/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c68bb6ec9c6fa3eab136a917778ec0625fbdd20", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c68bb6ec9c6fa3eab136a917778ec0625fbdd20", "html_url": "https://github.com/rust-lang/rust/commit/1c68bb6ec9c6fa3eab136a917778ec0625fbdd20"}, {"sha": "6a7a6528f69ddb32574e486471c400fee6de8fd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a7a6528f69ddb32574e486471c400fee6de8fd7", "html_url": "https://github.com/rust-lang/rust/commit/6a7a6528f69ddb32574e486471c400fee6de8fd7"}], "stats": {"total": 1313, "additions": 877, "deletions": 436}, "files": [{"sha": "c198797e650f6f05e263fc850f0fd2820c44533c", "filename": "src/libcore/alloc/global.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Falloc%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Falloc%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fglobal.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -127,9 +127,12 @@ pub unsafe trait GlobalAlloc {\n     #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n         let size = layout.size();\n-        let ptr = self.alloc(layout);\n+        // SAFETY: the safety contract for `alloc` must be upheld by the caller.\n+        let ptr = unsafe { self.alloc(layout) };\n         if !ptr.is_null() {\n-            ptr::write_bytes(ptr, 0, size);\n+            // SAFETY: as allocation succeeded, the region from `ptr`\n+            // of size `size` is guaranteed to be valid for writes.\n+            unsafe { ptr::write_bytes(ptr, 0, size) };\n         }\n         ptr\n     }\n@@ -187,11 +190,18 @@ pub unsafe trait GlobalAlloc {\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let new_ptr = self.alloc(new_layout);\n+        // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+        // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid.\n+        let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        // SAFETY: the caller must ensure that `new_layout` is greater than zero.\n+        let new_ptr = unsafe { self.alloc(new_layout) };\n         if !new_ptr.is_null() {\n-            ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n-            self.dealloc(ptr, layout);\n+            // SAFETY: the previously allocated block cannot overlap the newly allocated block.\n+            // The safety contract for `dealloc` must be upheld by the caller.\n+            unsafe {\n+                ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n+                self.dealloc(ptr, layout);\n+            }\n         }\n         new_ptr\n     }"}, {"sha": "ae7ae7044655bae38bfd4e7dae87938e31e3b726", "filename": "src/libcore/alloc/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Flayout.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -90,7 +90,8 @@ impl Layout {\n     #[rustc_const_stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n     pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n-        Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n+        // SAFETY: the caller must ensure that `align` is greater than zero.\n+        Layout { size_: size, align_: unsafe { NonZeroUsize::new_unchecked(align) } }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout."}, {"sha": "be4e051b1ca42b71e32f4218eebd39a8ea1e4d1a", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -54,7 +54,9 @@ impl AllocInit {\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub unsafe fn init(self, memory: MemoryBlock) {\n-        self.init_offset(memory, 0)\n+        // SAFETY: the safety contract for `init_offset` must be\n+        // upheld by the caller.\n+        unsafe { self.init_offset(memory, 0) }\n     }\n \n     /// Initialize the memory block like specified by `init` at the specified `offset`.\n@@ -78,7 +80,10 @@ impl AllocInit {\n         match self {\n             AllocInit::Uninitialized => (),\n             AllocInit::Zeroed => {\n-                memory.ptr.as_ptr().add(offset).write_bytes(0, memory.size - offset)\n+                // SAFETY: the caller must guarantee that `offset` is smaller than or equal to `memory.size`,\n+                // so the memory from `memory.ptr + offset` of length `memory.size - offset`\n+                // is guaranteed to be contaned in `memory` and thus valid for writes.\n+                unsafe { memory.ptr.as_ptr().add(offset).write_bytes(0, memory.size - offset) }\n             }\n         }\n     }\n@@ -281,11 +286,23 @@ pub unsafe trait AllocRef {\n                     return Ok(MemoryBlock { ptr, size });\n                 }\n \n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                    // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+                    // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+                    // The caller must ensure that `new_size` is greater than zero.\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 let new_memory = self.alloc(new_layout, init)?;\n-                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n-                self.dealloc(ptr, layout);\n-                Ok(new_memory)\n+\n+                // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n+                // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n+                // allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+                // `copy_nonoverlapping` is safe.\n+                // The safety contract for `dealloc` must be upheld by the caller.\n+                unsafe {\n+                    ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n+                    self.dealloc(ptr, layout);\n+                    Ok(new_memory)\n+                }\n             }\n         }\n     }\n@@ -356,11 +373,23 @@ pub unsafe trait AllocRef {\n                     return Ok(MemoryBlock { ptr, size });\n                 }\n \n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+                // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+                // The caller must ensure that `new_size` is greater than zero.\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 let new_memory = self.alloc(new_layout, AllocInit::Uninitialized)?;\n-                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n-                self.dealloc(ptr, layout);\n-                Ok(new_memory)\n+\n+                // SAFETY: because `new_size` must be lower than or equal to `size`, both the old and new\n+                // memory allocation are valid for reads and writes for `new_size` bytes. Also, because the\n+                // old allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+                // `copy_nonoverlapping` is safe.\n+                // The safety contract for `dealloc` must be upheld by the caller.\n+                unsafe {\n+                    ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n+                    self.dealloc(ptr, layout);\n+                    Ok(new_memory)\n+                }\n             }\n         }\n     }\n@@ -386,7 +415,8 @@ where\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-        (**self).dealloc(ptr, layout)\n+        // SAFETY: the safety contract must be upheld by the caller\n+        unsafe { (**self).dealloc(ptr, layout) }\n     }\n \n     #[inline]\n@@ -398,7 +428,8 @@ where\n         placement: ReallocPlacement,\n         init: AllocInit,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        (**self).grow(ptr, layout, new_size, placement, init)\n+        // SAFETY: the safety contract must be upheld by the caller\n+        unsafe { (**self).grow(ptr, layout, new_size, placement, init) }\n     }\n \n     #[inline]\n@@ -409,6 +440,7 @@ where\n         new_size: usize,\n         placement: ReallocPlacement,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        (**self).shrink(ptr, layout, new_size, placement)\n+        // SAFETY: the safety contract must be upheld by the caller\n+        unsafe { (**self).shrink(ptr, layout, new_size, placement) }\n     }\n }"}, {"sha": "51d9695687f4afad7a141c95afb3cde5103715dc", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -1005,7 +1005,12 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub unsafe fn try_borrow_unguarded(&self) -> Result<&T, BorrowError> {\n         if !is_writing(self.borrow.get()) {\n-            Ok(&*self.value.get())\n+            // SAFETY: We check that nobody is actively writing now, but it is\n+            // the caller's responsibility to ensure that nobody writes until\n+            // the returned reference is no longer in use.\n+            // Also, `self.value.get()` refers to the value owned by `self`\n+            // and is thus guaranteed to be valid for the lifetime of `self`.\n+            Ok(unsafe { &*self.value.get() })\n         } else {\n             Err(BorrowError { _private: () })\n         }"}, {"sha": "c329eec76ac3d9e28afc61a2adae447ffa1006b5", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -99,7 +99,8 @@ pub fn from_u32(i: u32) -> Option<char> {\n #[inline]\n #[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n pub unsafe fn from_u32_unchecked(i: u32) -> char {\n-    if cfg!(debug_assertions) { char::from_u32(i).unwrap() } else { transmute(i) }\n+    // SAFETY: the caller must guarantee that `i` is a valid char value.\n+    if cfg!(debug_assertions) { char::from_u32(i).unwrap() } else { unsafe { transmute(i) } }\n }\n \n #[stable(feature = \"char_convert\", since = \"1.13.0\")]"}, {"sha": "72555d781ed38e2580a6c2c15be5fc037938b035", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -183,7 +183,8 @@ impl char {\n     #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n     #[inline]\n     pub unsafe fn from_u32_unchecked(i: u32) -> char {\n-        super::convert::from_u32_unchecked(i)\n+        // SAFETY: the safety contract must be upheld by the caller.\n+        unsafe { super::convert::from_u32_unchecked(i) }\n     }\n \n     /// Converts a digit in the given radix to a `char`."}, {"sha": "336c0b26bc7d71afffc08dae0d249eaf3ae0ffa5", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -28,7 +28,8 @@ macro_rules! impl_float_to_int {\n                 #[doc(hidden)]\n                 #[inline]\n                 unsafe fn to_int_unchecked(self) -> $Int {\n-                    crate::intrinsics::float_to_int_unchecked(self)\n+                    // SAFETY: the safety contract must be upheld by the caller.\n+                    unsafe { crate::intrinsics::float_to_int_unchecked(self) }\n                 }\n             }\n         )+"}, {"sha": "ca4632006509fec3f368a96001265ad5dacb9224", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -333,7 +333,8 @@ impl<'f> VaListImpl<'f> {\n     /// Advance to the next arg.\n     #[inline]\n     pub unsafe fn arg<T: sealed_trait::VaArgSafe>(&mut self) -> T {\n-        va_arg(self)\n+        // SAFETY: the caller must uphold the safety contract for `va_arg`.\n+        unsafe { va_arg(self) }\n     }\n \n     /// Copies the `va_list` at the current location.\n@@ -343,7 +344,10 @@ impl<'f> VaListImpl<'f> {\n     {\n         let mut ap = self.clone();\n         let ret = f(ap.as_va_list());\n-        va_end(&mut ap);\n+        // SAFETY: the caller must uphold the safety contract for `va_end`.\n+        unsafe {\n+            va_end(&mut ap);\n+        }\n         ret\n     }\n }"}, {"sha": "2555d91ae8d9a287a60d256ebc5adecae70eda38", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -85,5 +85,7 @@ where\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]\n pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n-    &mut *cx.0.as_ptr().cast()\n+    // SAFETY: the caller must guarantee that `cx.0` is a valid pointer\n+    // that fulfills all the requirements for a mutable reference.\n+    unsafe { &mut *cx.0.as_ptr().cast() }\n }"}, {"sha": "f2bbf646f3272b87d1c5beb7e8b22721f985abce", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -130,15 +130,19 @@ unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n     let mut i = 0; // current byte index (from LSB) in the output u64\n     let mut out = 0;\n     if i + 3 < len {\n-        out = load_int_le!(buf, start + i, u32) as u64;\n+        // SAFETY: `i` cannot be greater than `len`, and the caller must guarantee\n+        // that the index start..start+len is in bounds.\n+        out = unsafe { load_int_le!(buf, start + i, u32) } as u64;\n         i += 4;\n     }\n     if i + 1 < len {\n-        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+        // SAFETY: same as above.\n+        out |= (unsafe { load_int_le!(buf, start + i, u16) } as u64) << (i * 8);\n         i += 2\n     }\n     if i < len {\n-        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+        // SAFETY: same as above.\n+        out |= (unsafe { *buf.get_unchecked(start + i) } as u64) << (i * 8);\n         i += 1;\n     }\n     debug_assert_eq!(i, len);"}, {"sha": "9ebcde79b633d3ea0492f5c90991a1d803e15e0f", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -46,7 +46,9 @@ use crate::intrinsics;\n #[inline]\n #[stable(feature = \"unreachable\", since = \"1.27.0\")]\n pub unsafe fn unreachable_unchecked() -> ! {\n-    intrinsics::unreachable()\n+    // SAFETY: the safety contract for `intrinsics::unreachable` must\n+    // be upheld by the caller.\n+    unsafe { intrinsics::unreachable() }\n }\n \n /// Emits a machine instruction hinting to the processor that it is running in busy-wait"}, {"sha": "7206cbd198fca4d5e3e26c71197041a8e5f640ca", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -2099,7 +2099,10 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    copy_nonoverlapping(src, dst, count)\n+\n+    // SAFETY: the safety contract for `copy_nonoverlapping` must be\n+    // upheld by the caller.\n+    unsafe { copy_nonoverlapping(src, dst, count) }\n }\n \n /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n@@ -2165,7 +2168,9 @@ pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    copy(src, dst, count)\n+\n+    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n+    unsafe { copy(src, dst, count) }\n }\n \n /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n@@ -2248,5 +2253,7 @@ pub unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n     }\n \n     debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n-    write_bytes(dst, val, count)\n+\n+    // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n+    unsafe { write_bytes(dst, val, count) }\n }"}, {"sha": "d2e2fc04a2b7661001f1741c256d14de124f23e1", "filename": "src/libcore/iter/adapters/fuse.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -178,9 +178,10 @@ where\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n         match self.iter {\n-            Some(ref mut iter) => iter.get_unchecked(i),\n+            // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+            Some(ref mut iter) => unsafe { iter.get_unchecked(i) },\n             // SAFETY: the caller asserts there is an item at `i`, so we're not exhausted.\n-            None => intrinsics::unreachable(),\n+            None => unsafe { intrinsics::unreachable() },\n         }\n     }\n "}, {"sha": "133643a0c7f0368c0b7f1cf6eb78c4d1c538dc6f", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -272,7 +272,8 @@ where\n     T: Copy,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        *self.it.get_unchecked(i)\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { *self.it.get_unchecked(i) }\n     }\n \n     #[inline]\n@@ -402,7 +403,8 @@ where\n     T: Clone,\n {\n     default unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        self.it.get_unchecked(i).clone()\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { self.it.get_unchecked(i) }.clone()\n     }\n \n     #[inline]\n@@ -418,7 +420,8 @@ where\n     T: Copy,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        *self.it.get_unchecked(i)\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { *self.it.get_unchecked(i) }\n     }\n \n     #[inline]\n@@ -930,7 +933,8 @@ where\n     F: FnMut(I::Item) -> B,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        (self.f)(self.iter.get_unchecked(i))\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        (self.f)(unsafe { self.iter.get_unchecked(i) })\n     }\n     #[inline]\n     fn may_have_side_effect() -> bool {\n@@ -1392,7 +1396,8 @@ where\n     I: TrustedRandomAccess,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n-        (self.count + i, self.iter.get_unchecked(i))\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        (self.count + i, unsafe { self.iter.get_unchecked(i) })\n     }\n \n     fn may_have_side_effect() -> bool {"}, {"sha": "985e6561665c7e923511274e8cb31d2ca7b992e8", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -271,7 +271,8 @@ where\n     B: TrustedRandomAccess,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n-        (self.a.get_unchecked(i), self.b.get_unchecked(i))\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { (self.a.get_unchecked(i), self.b.get_unchecked(i)) }\n     }\n \n     fn may_have_side_effect() -> bool {"}, {"sha": "ee53b6a13f837627028c2f1530aaeaf8aa6ec288", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -189,12 +189,14 @@ macro_rules! step_identical_methods {\n     () => {\n         #[inline]\n         unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n-            start.unchecked_add(n as Self)\n+            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n+            unsafe { start.unchecked_add(n as Self) }\n         }\n \n         #[inline]\n         unsafe fn backward_unchecked(start: Self, n: usize) -> Self {\n-            start.unchecked_sub(n as Self)\n+            // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.\n+            unsafe { start.unchecked_sub(n as Self) }\n         }\n \n         #[inline]\n@@ -450,21 +452,33 @@ unsafe impl Step for char {\n     #[inline]\n     unsafe fn forward_unchecked(start: char, count: usize) -> char {\n         let start = start as u32;\n-        let mut res = Step::forward_unchecked(start, count);\n+        // SAFETY: the caller must guarantee that this doesn't overflow\n+        // the range of values for a char.\n+        let mut res = unsafe { Step::forward_unchecked(start, count) };\n         if start < 0xD800 && 0xD800 <= res {\n-            res = Step::forward_unchecked(res, 0x800);\n+            // SAFETY: the caller must guarantee that this doesn't overflow\n+            // the range of values for a char.\n+            res = unsafe { Step::forward_unchecked(res, 0x800) };\n         }\n-        char::from_u32_unchecked(res)\n+        // SAFETY: because of the previous contract, this is guaranteed\n+        // by the caller to be a valid char.\n+        unsafe { char::from_u32_unchecked(res) }\n     }\n \n     #[inline]\n     unsafe fn backward_unchecked(start: char, count: usize) -> char {\n         let start = start as u32;\n-        let mut res = Step::backward_unchecked(start, count);\n+        // SAFETY: the caller must guarantee that this doesn't overflow\n+        // the range of values for a char.\n+        let mut res = unsafe { Step::backward_unchecked(start, count) };\n         if start >= 0xE000 && 0xE000 > res {\n-            res = Step::backward_unchecked(res, 0x800);\n+            // SAFETY: the caller must guarantee that this doesn't overflow\n+            // the range of values for a char.\n+            res = unsafe { Step::backward_unchecked(res, 0x800) };\n         }\n-        char::from_u32_unchecked(res)\n+        // SAFETY: because of the previous contract, this is guaranteed\n+        // by the caller to be a valid char.\n+        unsafe { char::from_u32_unchecked(res) }\n     }\n }\n "}, {"sha": "50c56434fa9a188771987492b97a72a618513924", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -149,6 +149,8 @@\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n #![feature(no_niche)] // rust-lang/rust#68303\n+#![feature(unsafe_block_in_unsafe_fn)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n #[prelude_import]\n #[allow(unused)]\n@@ -279,7 +281,13 @@ pub mod primitive;\n // set up in such a way that directly pulling it here works such that the\n // crate uses the this crate as its libcore.\n #[path = \"../stdarch/crates/core_arch/src/mod.rs\"]\n-#[allow(missing_docs, missing_debug_implementations, dead_code, unused_imports)]\n+#[allow(\n+    missing_docs,\n+    missing_debug_implementations,\n+    dead_code,\n+    unused_imports,\n+    unsafe_op_in_unsafe_fn\n+)]\n // FIXME: This annotation should be moved into rust-lang/stdarch after clashing_extern_declarations is\n // merged. It currently cannot because bootstrap fails as the lint hasn't been defined yet.\n #[cfg_attr(not(bootstrap), allow(clashing_extern_declarations))]"}, {"sha": "920f5e9c0bd28521e732e3e5159862168fd1c807", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -122,7 +122,9 @@ impl<T> ManuallyDrop<T> {\n     #[stable(feature = \"manually_drop_take\", since = \"1.42.0\")]\n     #[inline]\n     pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n-        ptr::read(&slot.value)\n+        // SAFETY: we are reading from a reference, which is guaranteed\n+        // to be valid for reads.\n+        unsafe { ptr::read(&slot.value) }\n     }\n }\n \n@@ -152,7 +154,10 @@ impl<T: ?Sized> ManuallyDrop<T> {\n     #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n-        ptr::drop_in_place(&mut slot.value)\n+        // SAFETY: we are dropping the value pointed to by a mutable reference\n+        // which is guaranteed to be valid for writes.\n+        // It is up to the caller to make sure that `slot` isn't dropped again.\n+        unsafe { ptr::drop_in_place(&mut slot.value) }\n     }\n }\n "}, {"sha": "7732525a0fc28a0556be5acac26724fbfd39dd20", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -494,8 +494,12 @@ impl<T> MaybeUninit<T> {\n     #[inline(always)]\n     #[rustc_diagnostic_item = \"assume_init\"]\n     pub unsafe fn assume_init(self) -> T {\n-        intrinsics::assert_inhabited::<T>();\n-        ManuallyDrop::into_inner(self.value)\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // This also means that `self` must be a `value` variant.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            ManuallyDrop::into_inner(self.value)\n+        }\n     }\n \n     /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n@@ -558,8 +562,12 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n     pub unsafe fn read(&self) -> T {\n-        intrinsics::assert_inhabited::<T>();\n-        self.as_ptr().read()\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // Reading from `self.as_ptr()` is safe since `self` should be initialized.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            self.as_ptr().read()\n+        }\n     }\n \n     /// Gets a shared reference to the contained value.\n@@ -620,8 +628,12 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n-        intrinsics::assert_inhabited::<T>();\n-        &*self.value\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // This also means that `self` must be a `value` variant.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            &*self.value\n+        }\n     }\n \n     /// Gets a mutable (unique) reference to the contained value.\n@@ -738,8 +750,12 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n-        intrinsics::assert_inhabited::<T>();\n-        &mut *self.value\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // This also means that `self` must be a `value` variant.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            &mut *self.value\n+        }\n     }\n \n     /// Assuming all the elements are initialized, get a slice to them.\n@@ -752,7 +768,11 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"none\")]\n     #[inline(always)]\n     pub unsafe fn slice_get_ref(slice: &[Self]) -> &[T] {\n-        &*(slice as *const [Self] as *const [T])\n+        // SAFETY: casting slice to a `*const [T]` is safe since the caller guarantees that\n+        // `slice` is initialized, and`MaybeUninit` is guaranteed to have the same layout as `T`.\n+        // The pointer obtained is valid since it refers to memory owned by `slice` which is a\n+        // reference and thus guaranteed to be valid for reads.\n+        unsafe { &*(slice as *const [Self] as *const [T]) }\n     }\n \n     /// Assuming all the elements are initialized, get a mutable slice to them.\n@@ -765,7 +785,9 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"none\")]\n     #[inline(always)]\n     pub unsafe fn slice_get_mut(slice: &mut [Self]) -> &mut [T] {\n-        &mut *(slice as *mut [Self] as *mut [T])\n+        // SAFETY: similar to safety notes for `slice_get_ref`, but we have a\n+        // mutable reference which is also guaranteed to be valid for writes.\n+        unsafe { &mut *(slice as *mut [Self] as *mut [T]) }\n     }\n \n     /// Gets a pointer to the first element of the array."}, {"sha": "272088815ece90194a40aa0645902a484d7837fe", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -623,8 +623,11 @@ pub const fn needs_drop<T>() -> bool {\n #[allow(deprecated)]\n #[rustc_diagnostic_item = \"mem_zeroed\"]\n pub unsafe fn zeroed<T>() -> T {\n-    intrinsics::assert_zero_valid::<T>();\n-    MaybeUninit::zeroed().assume_init()\n+    // SAFETY: the caller must guarantee that an all-zero value is valid for `T`.\n+    unsafe {\n+        intrinsics::assert_zero_valid::<T>();\n+        MaybeUninit::zeroed().assume_init()\n+    }\n }\n \n /// Bypasses Rust's normal memory-initialization checks by pretending to\n@@ -656,8 +659,11 @@ pub unsafe fn zeroed<T>() -> T {\n #[allow(deprecated)]\n #[rustc_diagnostic_item = \"mem_uninitialized\"]\n pub unsafe fn uninitialized<T>() -> T {\n-    intrinsics::assert_uninit_valid::<T>();\n-    MaybeUninit::uninit().assume_init()\n+    // SAFETY: the caller must guarantee that an unitialized value is valid for `T`.\n+    unsafe {\n+        intrinsics::assert_uninit_valid::<T>();\n+        MaybeUninit::uninit().assume_init()\n+    }\n }\n \n /// Swaps the values at two mutable locations, without deinitializing either one.\n@@ -922,9 +928,14 @@ pub fn drop<T>(_x: T) {}\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     // If U has a higher alignment requirement, src may not be suitably aligned.\n     if align_of::<U>() > align_of::<T>() {\n-        ptr::read_unaligned(src as *const T as *const U)\n+        // SAFETY: `src` is a reference which is guaranteed to be valid for reads.\n+        // The caller must guarantee that the actual transmutation is safe.\n+        unsafe { ptr::read_unaligned(src as *const T as *const U) }\n     } else {\n-        ptr::read(src as *const T as *const U)\n+        // SAFETY: `src` is a reference which is guaranteed to be valid for reads.\n+        // We just checked that `src as *const U` was properly aligned.\n+        // The caller must guarantee that the actual transmutation is safe.\n+        unsafe { ptr::read(src as *const T as *const U) }\n     }\n }\n "}, {"sha": "061d1ea6b1c46974ffe7f7e11d3c3a6a878c8842", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -629,7 +629,9 @@ impl f32 {\n     where\n         Self: FloatToInt<Int>,\n     {\n-        FloatToInt::<Int>::to_int_unchecked(self)\n+        // SAFETY: the caller must uphold the safety contract for\n+        // `FloatToInt::to_int_unchecked`.\n+        unsafe { FloatToInt::<Int>::to_int_unchecked(self) }\n     }\n \n     /// Raw transmutation to `u32`."}, {"sha": "b0df4d64f6ee1880583c42f5bc83c8a5a6dbd9d2", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -643,7 +643,9 @@ impl f64 {\n     where\n         Self: FloatToInt<Int>,\n     {\n-        FloatToInt::<Int>::to_int_unchecked(self)\n+        // SAFETY: the caller must uphold the safety contract for\n+        // `FloatToInt::to_int_unchecked`.\n+        unsafe { FloatToInt::<Int>::to_int_unchecked(self) }\n     }\n \n     /// Raw transmutation to `u64`."}, {"sha": "2ded2e9c086c83c5d45df0cec711b90acbf967a3", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -74,7 +74,8 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n                 #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n                 #[inline]\n                 pub const unsafe fn new_unchecked(n: $Int) -> Self {\n-                    Self(n)\n+                    // SAFETY: this is guaranteed to be safe by the caller.\n+                    unsafe { Self(n) }\n                 }\n \n                 /// Creates a non-zero if the given value is not zero.\n@@ -762,7 +763,9 @@ cannot occur. This results in undefined behavior when `self + rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_add(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_add`.\n+                unsafe { intrinsics::unchecked_add(self, rhs) }\n             }\n         }\n \n@@ -804,7 +807,9 @@ cannot occur. This results in undefined behavior when `self - rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_sub(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_sub`.\n+                unsafe { intrinsics::unchecked_sub(self, rhs) }\n             }\n         }\n \n@@ -846,7 +851,9 @@ cannot occur. This results in undefined behavior when `self * rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_mul(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_mul`.\n+                unsafe { intrinsics::unchecked_mul(self, rhs) }\n             }\n         }\n \n@@ -2998,7 +3005,9 @@ cannot occur. This results in undefined behavior when `self + rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_add(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_add`.\n+                unsafe { intrinsics::unchecked_add(self, rhs) }\n             }\n         }\n \n@@ -3038,7 +3047,9 @@ cannot occur. This results in undefined behavior when `self - rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_sub(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_sub`.\n+                unsafe { intrinsics::unchecked_sub(self, rhs) }\n             }\n         }\n \n@@ -3078,7 +3089,9 @@ cannot occur. This results in undefined behavior when `self * rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_mul(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_mul`.\n+                unsafe { intrinsics::unchecked_mul(self, rhs) }\n             }\n         }\n "}, {"sha": "da299f026f8f16c87f0d7dd4f64fe3e62f37491b", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -679,7 +679,10 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     {\n         let pointer = &*self.pointer;\n         let new_pointer = func(pointer);\n-        Pin::new_unchecked(new_pointer)\n+\n+        // SAFETY: the safety contract for `new_unchecked` must be\n+        // upheld by the caller.\n+        unsafe { Pin::new_unchecked(new_pointer) }\n     }\n \n     /// Gets a shared reference out of a pin.\n@@ -769,9 +772,13 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n         U: ?Sized,\n         F: FnOnce(&mut T) -> &mut U,\n     {\n-        let pointer = Pin::get_unchecked_mut(self);\n+        // SAFETY: the caller is responsible for not moving the\n+        // value out of this reference.\n+        let pointer = unsafe { Pin::get_unchecked_mut(self) };\n         let new_pointer = func(pointer);\n-        Pin::new_unchecked(new_pointer)\n+        // SAFETY: as the value of `this` is guaranteed to not have\n+        // been moved out, this call to `new_unchecked` is safe.\n+        unsafe { Pin::new_unchecked(new_pointer) }\n     }\n }\n "}, {"sha": "d1d7a71523822a12c2679917a2f355f064857783", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -95,7 +95,9 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() { None } else { Some(&*self) }\n+        // SAFETY: the caller must guarantee that `self` is valid\n+        // for a reference if it isn't null.\n+        if self.is_null() { None } else { unsafe { Some(&*self) } }\n     }\n \n     /// Calculates the offset from a pointer.\n@@ -157,7 +159,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        intrinsics::offset(self, count)\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { intrinsics::offset(self, count) }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -292,7 +295,8 @@ impl<T: ?Sized> *const T {\n     {\n         let pointee_size = mem::size_of::<T>();\n         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n-        intrinsics::ptr_offset_from(self, origin)\n+        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from`.\n+        unsafe { intrinsics::ptr_offset_from(self, origin) }\n     }\n \n     /// Returns whether two pointers are guaranteed to be equal.\n@@ -471,7 +475,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        self.offset(count as isize)\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset(count as isize) }\n     }\n \n     /// Calculates the offset from a pointer (convenience for\n@@ -534,7 +539,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        self.offset((count as isize).wrapping_neg())\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset((count as isize).wrapping_neg()) }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -663,7 +669,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        read(self)\n+        // SAFETY: the caller must uphold the safety contract for `read`.\n+        unsafe { read(self) }\n     }\n \n     /// Performs a volatile read of the value from `self` without moving it. This\n@@ -682,7 +689,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        read_volatile(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_volatile`.\n+        unsafe { read_volatile(self) }\n     }\n \n     /// Reads the value from `self` without moving it. This leaves the\n@@ -699,7 +707,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        read_unaligned(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_unaligned`.\n+        unsafe { read_unaligned(self) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -716,7 +725,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        copy(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy`.\n+        unsafe { copy(self, dest, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -733,7 +743,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        copy_nonoverlapping(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.\n+        unsafe { copy_nonoverlapping(self, dest, count) }\n     }\n \n     /// Computes the offset that needs to be applied to the pointer in order to make it aligned to"}, {"sha": "5f028f9ea76cac453c771afc7f5cbbb42021d4e0", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 93, "deletions": 33, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -184,7 +184,9 @@ mod mut_ptr;\n pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n     // Code here does not matter - this is replaced by the\n     // real drop glue by the compiler.\n-    drop_in_place(to_drop)\n+\n+    // SAFETY: see comment above\n+    unsafe { drop_in_place(to_drop) }\n }\n \n /// Creates a null raw pointer.\n@@ -374,9 +376,15 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     let mut tmp = MaybeUninit::<T>::uninit();\n \n     // Perform the swap\n-    copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n-    copy(y, x, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping(tmp.as_ptr(), y, 1);\n+    // SAFETY: the caller must guarantee that `x` and `y` are\n+    // valid for writes and properly aligned. `tmp` cannot be\n+    // overlapping either `x` or `y` because `tmp` was just allocated\n+    // on the stack as a separate allocated object.\n+    unsafe {\n+        copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n+        copy(y, x, 1); // `x` and `y` may overlap\n+        copy_nonoverlapping(tmp.as_ptr(), y, 1);\n+    }\n }\n \n /// Swaps `count * size_of::<T>()` bytes between the two regions of memory\n@@ -432,19 +440,26 @@ pub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n     let x = x as *mut u8;\n     let y = y as *mut u8;\n     let len = mem::size_of::<T>() * count;\n-    swap_nonoverlapping_bytes(x, y, len)\n+    // SAFETY: the caller must guarantee that `x` and `y` are\n+    // valid for writes and properly aligned.\n+    unsafe { swap_nonoverlapping_bytes(x, y, len) }\n }\n \n #[inline]\n pub(crate) unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n     // For types smaller than the block optimization below,\n     // just swap directly to avoid pessimizing codegen.\n     if mem::size_of::<T>() < 32 {\n-        let z = read(x);\n-        copy_nonoverlapping(y, x, 1);\n-        write(y, z);\n+        // SAFETY: the caller must guarantee that `x` and `y` are valid\n+        // for writes, properly aligned, and non-overlapping.\n+        unsafe {\n+            let z = read(x);\n+            copy_nonoverlapping(y, x, 1);\n+            write(y, z);\n+        }\n     } else {\n-        swap_nonoverlapping(x, y, 1);\n+        // SAFETY: the caller must uphold the safety contract for `swap_nonoverlapping`.\n+        unsafe { swap_nonoverlapping(x, y, 1) };\n     }\n }\n \n@@ -471,14 +486,23 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n         // Declaring `t` here avoids aligning the stack when this loop is unused\n         let mut t = mem::MaybeUninit::<Block>::uninit();\n         let t = t.as_mut_ptr() as *mut u8;\n-        let x = x.add(i);\n-        let y = y.add(i);\n \n-        // Swap a block of bytes of x & y, using t as a temporary buffer\n-        // This should be optimized into efficient SIMD operations where available\n-        copy_nonoverlapping(x, t, block_size);\n-        copy_nonoverlapping(y, x, block_size);\n-        copy_nonoverlapping(t, y, block_size);\n+        // SAFETY: As `i < len`, and as the caller must guarantee that `x` and `y` are valid\n+        // for `len` bytes, `x + i` and `y + i` must be valid adresses, which fulfills the\n+        // safety contract for `add`.\n+        //\n+        // Also, the caller must guarantee that `x` and `y` are valid for writes, properly aligned,\n+        // and non-overlapping, which fulfills the safety contract for `copy_nonoverlapping`.\n+        unsafe {\n+            let x = x.add(i);\n+            let y = y.add(i);\n+\n+            // Swap a block of bytes of x & y, using t as a temporary buffer\n+            // This should be optimized into efficient SIMD operations where available\n+            copy_nonoverlapping(x, t, block_size);\n+            copy_nonoverlapping(y, x, block_size);\n+            copy_nonoverlapping(t, y, block_size);\n+        }\n         i += block_size;\n     }\n \n@@ -488,12 +512,16 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n         let rem = len - i;\n \n         let t = t.as_mut_ptr() as *mut u8;\n-        let x = x.add(i);\n-        let y = y.add(i);\n \n-        copy_nonoverlapping(x, t, rem);\n-        copy_nonoverlapping(y, x, rem);\n-        copy_nonoverlapping(t, y, rem);\n+        // SAFETY: see previous safety comment.\n+        unsafe {\n+            let x = x.add(i);\n+            let y = y.add(i);\n+\n+            copy_nonoverlapping(x, t, rem);\n+            copy_nonoverlapping(y, x, rem);\n+            copy_nonoverlapping(t, y, rem);\n+        }\n     }\n }\n \n@@ -540,7 +568,13 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n-    mem::swap(&mut *dst, &mut src); // cannot overlap\n+    // SAFETY: the caller must guarantee that `dst` is valid to be\n+    // cast to a mutable reference (valid for writes, aligned, initialized),\n+    // and cannot overlap `src` since `dst` must point to a distinct\n+    // allocated object.\n+    unsafe {\n+        mem::swap(&mut *dst, &mut src); // cannot overlap\n+    }\n     src\n }\n \n@@ -658,8 +692,16 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n pub unsafe fn read<T>(src: *const T) -> T {\n     // `copy_nonoverlapping` takes care of debug_assert.\n     let mut tmp = MaybeUninit::<T>::uninit();\n-    copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-    tmp.assume_init()\n+    // SAFETY: the caller must guarantee that `src` is valid for reads.\n+    // `src` cannot overlap `tmp` because `tmp` was just allocated on\n+    // the stack as a separate allocated object.\n+    //\n+    // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n+    // to be properly initialized.\n+    unsafe {\n+        copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+        tmp.assume_init()\n+    }\n }\n \n /// Reads the value from `src` without moving it. This leaves the\n@@ -752,8 +794,16 @@ pub unsafe fn read<T>(src: *const T) -> T {\n pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n     // `copy_nonoverlapping` takes care of debug_assert.\n     let mut tmp = MaybeUninit::<T>::uninit();\n-    copy_nonoverlapping(src as *const u8, tmp.as_mut_ptr() as *mut u8, mem::size_of::<T>());\n-    tmp.assume_init()\n+    // SAFETY: the caller must guarantee that `src` is valid for reads.\n+    // `src` cannot overlap `tmp` because `tmp` was just allocated on\n+    // the stack as a separate allocated object.\n+    //\n+    // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n+    // to be properly initialized.\n+    unsafe {\n+        copy_nonoverlapping(src as *const u8, tmp.as_mut_ptr() as *mut u8, mem::size_of::<T>());\n+        tmp.assume_init()\n+    }\n }\n \n /// Overwrites a memory location with the given value without reading or\n@@ -847,7 +897,8 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    intrinsics::move_val_init(&mut *dst, src)\n+    // SAFETY: the caller must uphold the safety contract for `move_val_init`.\n+    unsafe { intrinsics::move_val_init(&mut *dst, src) }\n }\n \n /// Overwrites a memory location with the given value without reading or\n@@ -939,8 +990,13 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n-    // `copy_nonoverlapping` takes care of debug_assert.\n-    copy_nonoverlapping(&src as *const T as *const u8, dst as *mut u8, mem::size_of::<T>());\n+    // SAFETY: the caller must guarantee that `dst` is valid for writes.\n+    // `dst` cannot overlap `src` because the caller has mutable access\n+    // to `dst` while `src` is owned by this function.\n+    unsafe {\n+        // `copy_nonoverlapping` takes care of debug_assert.\n+        copy_nonoverlapping(&src as *const T as *const u8, dst as *mut u8, mem::size_of::<T>());\n+    }\n     mem::forget(src);\n }\n \n@@ -1015,7 +1071,8 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    intrinsics::volatile_load(src)\n+    // SAFETY: the caller must uphold the safety contract for `volatile_load`.\n+    unsafe { intrinsics::volatile_load(src) }\n }\n \n /// Performs a volatile write of a memory location with the given value without\n@@ -1087,7 +1144,10 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    intrinsics::volatile_store(dst, src);\n+    // SAFETY: the caller must uphold the safety contract for `volatile_store`.\n+    unsafe {\n+        intrinsics::volatile_store(dst, src);\n+    }\n }\n \n /// Align pointer `p`.\n@@ -1173,8 +1233,8 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     }\n \n     let smoda = stride & a_minus_one;\n-    // a is power-of-two so cannot be 0. stride = 0 is handled above.\n-    let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n+    // SAFETY: a is power-of-two so cannot be 0. stride = 0 is handled above.\n+    let gcdpow = unsafe { intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a)) };\n     let gcd = 1usize << gcdpow;\n \n     if p as usize & (gcd.wrapping_sub(1)) == 0 {"}, {"sha": "7d4b6339b511f2b2e2ea331e156319b09af88da1", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -89,7 +89,9 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() { None } else { Some(&*self) }\n+        // SAFETY: the caller must guarantee that `self` is valid for a\n+        // reference if it isn't null.\n+        if self.is_null() { None } else { unsafe { Some(&*self) } }\n     }\n \n     /// Calculates the offset from a pointer.\n@@ -151,7 +153,10 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        intrinsics::offset(self, count) as *mut T\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        // The obtained pointer is valid for writes since the caller must\n+        // guarantee that it points to the same allocated object as `self`.\n+        unsafe { intrinsics::offset(self, count) as *mut T }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -270,7 +275,9 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n-        if self.is_null() { None } else { Some(&mut *self) }\n+        // SAFETY: the caller must guarantee that `self` is be valid for\n+        // a mutable reference if it isn't null.\n+        if self.is_null() { None } else { unsafe { Some(&mut *self) } }\n     }\n \n     /// Returns whether two pointers are guaranteed to be equal.\n@@ -406,7 +413,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        (self as *const T).offset_from(origin)\n+        // SAFETY: the caller must uphold the safety contract for `offset_from`.\n+        unsafe { (self as *const T).offset_from(origin) }\n     }\n \n     /// Calculates the distance between two pointers. The returned value is in\n@@ -518,7 +526,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        self.offset(count as isize)\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset(count as isize) }\n     }\n \n     /// Calculates the offset from a pointer (convenience for\n@@ -581,7 +590,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        self.offset((count as isize).wrapping_neg())\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset((count as isize).wrapping_neg()) }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -710,7 +720,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        read(self)\n+        // SAFETY: the caller must uphold the safety contract for ``.\n+        unsafe { read(self) }\n     }\n \n     /// Performs a volatile read of the value from `self` without moving it. This\n@@ -729,7 +740,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        read_volatile(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_volatile`.\n+        unsafe { read_volatile(self) }\n     }\n \n     /// Reads the value from `self` without moving it. This leaves the\n@@ -746,7 +758,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        read_unaligned(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_unaligned`.\n+        unsafe { read_unaligned(self) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -763,7 +776,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy`.\n+        unsafe { copy(self, dest, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -780,7 +794,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy_nonoverlapping(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.\n+        unsafe { copy_nonoverlapping(self, dest, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n@@ -797,7 +812,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy(src, self, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy`.\n+        unsafe { copy(src, self, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n@@ -814,7 +830,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy_nonoverlapping(src, self, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.\n+        unsafe { copy_nonoverlapping(src, self, count) }\n     }\n \n     /// Executes the destructor (if any) of the pointed-to value.\n@@ -825,7 +842,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn drop_in_place(self) {\n-        drop_in_place(self)\n+        // SAFETY: the caller must uphold the safety contract for `drop_in_place`.\n+        unsafe { drop_in_place(self) }\n     }\n \n     /// Overwrites a memory location with the given value without reading or\n@@ -840,7 +858,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write(self, val)\n+        // SAFETY: the caller must uphold the safety contract for `write`.\n+        unsafe { write(self, val) }\n     }\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n@@ -855,7 +874,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write_bytes(self, val, count)\n+        // SAFETY: the caller must uphold the safety contract for `write_bytes`.\n+        unsafe { write_bytes(self, val, count) }\n     }\n \n     /// Performs a volatile write of a memory location with the given value without\n@@ -874,7 +894,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write_volatile(self, val)\n+        // SAFETY: the caller must uphold the safety contract for `write_volatile`.\n+        unsafe { write_volatile(self, val) }\n     }\n \n     /// Overwrites a memory location with the given value without reading or\n@@ -891,7 +912,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write_unaligned(self, val)\n+        // SAFETY: the caller must uphold the safety contract for `write_unaligned`.\n+        unsafe { write_unaligned(self, val) }\n     }\n \n     /// Replaces the value at `self` with `src`, returning the old\n@@ -906,7 +928,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        replace(self, src)\n+        // SAFETY: the caller must uphold the safety contract for `replace`.\n+        unsafe { replace(self, src) }\n     }\n \n     /// Swaps the values at two mutable locations of the same type, without\n@@ -922,7 +945,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        swap(self, with)\n+        // SAFETY: the caller must uphold the safety contract for `swap`.\n+        unsafe { swap(self, with) }\n     }\n \n     /// Computes the offset that needs to be applied to the pointer in order to make it aligned to"}, {"sha": "c2d31bfb6a4ee717f01d547f2ca5133aa72a9e87", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -87,7 +87,8 @@ impl<T: ?Sized> NonNull<T> {\n     #[rustc_const_stable(feature = \"const_nonnull_new_unchecked\", since = \"1.32.0\")]\n     #[inline]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        NonNull { pointer: ptr as _ }\n+        // SAFETY: the caller must guarantee that `ptr` is non-null.\n+        unsafe { NonNull { pointer: ptr as _ } }\n     }\n \n     /// Creates a new `NonNull` if `ptr` is non-null.\n@@ -118,7 +119,9 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_ref(&self) -> &T {\n-        &*self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        unsafe { &*self.as_ptr() }\n     }\n \n     /// Mutably dereferences the content.\n@@ -129,7 +132,9 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n-        &mut *self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a mutable reference.\n+        unsafe { &mut *self.as_ptr() }\n     }\n \n     /// Casts to a pointer of another type."}, {"sha": "78647eee3389a3ee0d5a897b8af10fc8a3ced3b8", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -87,7 +87,8 @@ impl<T: ?Sized> Unique<T> {\n     /// `ptr` must be non-null.\n     #[inline]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        Unique { pointer: ptr as _, _marker: PhantomData }\n+        // SAFETY: the caller must guarantee that `ptr` is non-null.\n+        unsafe { Unique { pointer: ptr as _, _marker: PhantomData } }\n     }\n \n     /// Creates a new `Unique` if `ptr` is non-null.\n@@ -114,7 +115,9 @@ impl<T: ?Sized> Unique<T> {\n     /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n     #[inline]\n     pub unsafe fn as_ref(&self) -> &T {\n-        &*self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        unsafe { &*self.as_ptr() }\n     }\n \n     /// Mutably dereferences the content.\n@@ -124,7 +127,9 @@ impl<T: ?Sized> Unique<T> {\n     /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n     #[inline]\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n-        &mut *self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a mutable reference.\n+        unsafe { &mut *self.as_ptr() }\n     }\n \n     /// Casts to a pointer of another type."}, {"sha": "e7a2d7adedea0ddc56e62475a11c83dcb9408063", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 100, "deletions": 43, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -310,7 +310,8 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        index.get_unchecked(self)\n+        // SAFETY: the caller must uphold the safety requirements for `get_unchecked`.\n+        unsafe { index.get_unchecked(self) }\n     }\n \n     /// Returns a mutable reference to an element or subslice, without doing\n@@ -341,7 +342,8 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        index.get_unchecked_mut(self)\n+        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`.\n+        unsafe { index.get_unchecked_mut(self) }\n     }\n \n     /// Returns a raw pointer to the slice's buffer.\n@@ -2581,18 +2583,21 @@ impl<T> [T] {\n         // First, find at what point do we split between the first and 2nd slice. Easy with\n         // ptr.align_offset.\n         let ptr = self.as_ptr();\n-        let offset = crate::ptr::align_offset(ptr, mem::align_of::<U>());\n+        let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n         if offset > self.len() {\n             (self, &[], &[])\n         } else {\n             let (left, rest) = self.split_at(offset);\n-            // now `rest` is definitely aligned, so `from_raw_parts_mut` below is okay\n             let (us_len, ts_len) = rest.align_to_offsets::<U>();\n-            (\n-                left,\n-                from_raw_parts(rest.as_ptr() as *const U, us_len),\n-                from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n-            )\n+            // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,\n+            // since the caller guarantees that we can transmute `T` to `U` safely.\n+            unsafe {\n+                (\n+                    left,\n+                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n+                    from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n+                )\n+            }\n         }\n     }\n \n@@ -2637,21 +2642,23 @@ impl<T> [T] {\n         // First, find at what point do we split between the first and 2nd slice. Easy with\n         // ptr.align_offset.\n         let ptr = self.as_ptr();\n-        let offset = crate::ptr::align_offset(ptr, mem::align_of::<U>());\n+        let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n         if offset > self.len() {\n             (self, &mut [], &mut [])\n         } else {\n             let (left, rest) = self.split_at_mut(offset);\n-            // now `rest` is definitely aligned, so `from_raw_parts_mut` below is okay\n             let (us_len, ts_len) = rest.align_to_offsets::<U>();\n             let rest_len = rest.len();\n             let mut_ptr = rest.as_mut_ptr();\n             // We can't use `rest` again after this, that would invalidate its alias `mut_ptr`!\n-            (\n-                left,\n-                from_raw_parts_mut(mut_ptr as *mut U, us_len),\n-                from_raw_parts_mut(mut_ptr.add(rest_len - ts_len), ts_len),\n-            )\n+            // SAFETY: see comments for `align_to`.\n+            unsafe {\n+                (\n+                    left,\n+                    from_raw_parts_mut(mut_ptr as *mut U, us_len),\n+                    from_raw_parts_mut(mut_ptr.add(rest_len - ts_len), ts_len),\n+                )\n+            }\n         }\n     }\n \n@@ -2976,12 +2983,18 @@ impl<T> SliceIndex<[T]> for usize {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n-        &*slice.as_ptr().add(self)\n+        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n+        // the caller guarantees that `self` is in bounds of `slice`\n+        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n+        // The obtained pointer comes from a reference which is guaranteed\n+        // to be valid.\n+        unsafe { &*slice.as_ptr().add(self) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n-        &mut *slice.as_mut_ptr().add(self)\n+        // SAFETY: see comments for `get_unchecked` above.\n+        unsafe { &mut *slice.as_mut_ptr().add(self) }\n     }\n \n     #[inline]\n@@ -3021,12 +3034,18 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start)\n+        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n+        // the caller guarantees that `self` is in bounds of `slice`\n+        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n+        // Also, since the caller guarantees that `self` is in bounds of `slice`,\n+        // `from_raw_parts` will give a subslice of `slice` which is always safe.\n+        unsafe { from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n+        // SAFETY: see comments for `get_unchecked` above.\n+        unsafe { from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start) }\n     }\n \n     #[inline]\n@@ -3066,12 +3085,14 @@ impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (0..self.end).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (0..self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0..self.end).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (0..self.end).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3101,12 +3122,14 @@ impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (self.start..slice.len()).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (self.start..slice.len()).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (self.start..slice.len()).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (self.start..slice.len()).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3175,12 +3198,14 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (*self.start()..self.end() + 1).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (*self.start()..self.end() + 1).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3216,12 +3241,14 @@ impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (0..=self.end).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (0..=self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0..=self.end).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (0..=self.end).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3370,7 +3397,9 @@ macro_rules! iterator {\n                     self.ptr.as_ptr()\n                 } else {\n                     let old = self.ptr.as_ptr();\n-                    self.ptr = NonNull::new_unchecked(self.ptr.as_ptr().offset(offset));\n+                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n+                    // so this new pointer is inside `self` and thus guaranteed to be non-null.\n+                    self.ptr = unsafe { NonNull::new_unchecked(self.ptr.as_ptr().offset(offset)) };\n                     old\n                 }\n             }\n@@ -3384,7 +3413,10 @@ macro_rules! iterator {\n                     zst_shrink!(self, offset);\n                     self.ptr.as_ptr()\n                 } else {\n-                    self.end = self.end.offset(-offset);\n+                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n+                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n+                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n+                    self.end = unsafe { self.end.offset(-offset) };\n                     self.end\n                 }\n             }\n@@ -4702,7 +4734,11 @@ impl<T> FusedIterator for Windows<'_, T> {}\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for Windows<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n-        from_raw_parts(self.v.as_ptr().add(i), self.size)\n+        // SAFETY: since the caller guarantees that `i` is in bounds,\n+        // which means that `i` cannot overflow an `isize`, and the\n+        // slice created by `from_raw_parts` is a subslice of `self.v`\n+        // thus is guaranteed to be valid for the lifetime `'a` of `self.v`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(i), self.size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -4846,7 +4882,14 @@ unsafe impl<'a, T> TrustedRandomAccess for Chunks<'a, T> {\n             None => self.v.len(),\n             Some(end) => cmp::min(end, self.v.len()),\n         };\n-        from_raw_parts(self.v.as_ptr().add(start), end - start)\n+        // SAFETY: the caller guarantees that `i` is in bounds,\n+        // which means that `start` must be in bounds of the\n+        // underlying `self.v` slice, and we made sure that `end`\n+        // is also in bounds of `self.v`. Thus, `start` cannot overflow\n+        // an `isize`, and the slice constructed by `from_raw_parts`\n+        // is a subslice of `self.v` which is guaranteed to be valid\n+        // for the lifetime `'a` of `self.v`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -4988,7 +5031,8 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n             None => self.v.len(),\n             Some(end) => cmp::min(end, self.v.len()),\n         };\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start)\n+        // SAFETY: see comments for `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5125,7 +5169,8 @@ impl<T> FusedIterator for ChunksExact<'_, T> {}\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let start = i * self.chunk_size;\n-        from_raw_parts(self.v.as_ptr().add(start), self.chunk_size)\n+        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5259,7 +5304,8 @@ impl<T> FusedIterator for ChunksExactMut<'_, T> {}\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let start = i * self.chunk_size;\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size)\n+        // SAFETY: see comments for `ChunksExactMut::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5406,7 +5452,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunks<'a, T> {\n             None => 0,\n             Some(start) => start,\n         };\n-        from_raw_parts(self.v.as_ptr().add(start), end - start)\n+        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5551,7 +5598,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksMut<'a, T> {\n             None => 0,\n             Some(start) => start,\n         };\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start)\n+        // SAFETY: see comments for `RChunks::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5692,7 +5740,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExact<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let end = self.v.len() - i * self.chunk_size;\n         let start = end - self.chunk_size;\n-        from_raw_parts(self.v.as_ptr().add(start), self.chunk_size)\n+        // SAFETY: mostmy identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5831,7 +5880,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let end = self.v.len() - i * self.chunk_size;\n         let start = end - self.chunk_size;\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size)\n+        // SAFETY: see comments for `RChunksExact::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5927,7 +5977,8 @@ pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n         mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n         \"attempt to create slice covering at least half the address space\"\n     );\n-    &*ptr::slice_from_raw_parts(data, len)\n+    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n+    unsafe { &*ptr::slice_from_raw_parts(data, len) }\n }\n \n /// Performs the same functionality as [`from_raw_parts`], except that a\n@@ -5967,7 +6018,8 @@ pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T]\n         mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n         \"attempt to create slice covering at least half the address space\"\n     );\n-    &mut *ptr::slice_from_raw_parts_mut(data, len)\n+    // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n+    unsafe { &mut *ptr::slice_from_raw_parts_mut(data, len) }\n }\n \n /// Converts a reference to T into a slice of length 1 (without copying).\n@@ -6243,7 +6295,11 @@ impl_marker_for!(BytewiseEquality,\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n-        &*self.ptr.as_ptr().add(i)\n+        // SAFETY: the caller must guarantee that `i` is in bounds\n+        // of the underlying slice, so `i` cannot overflow an `isize`,\n+        // and the returned references is guaranteed to refer to an element\n+        // of the slice and thus guaranteed to be valid.\n+        unsafe { &*self.ptr.as_ptr().add(i) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -6253,7 +6309,8 @@ unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n-        &mut *self.ptr.as_ptr().add(i)\n+        // SAFETY: see comments for `Iter::get_unchecked`.\n+        unsafe { &mut *self.ptr.as_ptr().add(i) }\n     }\n     fn may_have_side_effect() -> bool {\n         false"}, {"sha": "a89596b15ef94c31122c845e3f6041449f6018e8", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -1,3 +1,5 @@\n+// ignore-tidy-undocumented-unsafe\n+\n use crate::cmp;\n use crate::mem::{self, MaybeUninit};\n use crate::ptr;\n@@ -77,9 +79,9 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // the way until about `left + right == 32`, but the worst case performance breaks even\n             // around 16. 24 was chosen as middle ground. If the size of `T` is larger than 4\n             // `usize`s, this algorithm also outperforms other algorithms.\n-            let x = mid.sub(left);\n+            let x = unsafe { mid.sub(left) };\n             // beginning of first round\n-            let mut tmp: T = x.read();\n+            let mut tmp: T = unsafe { x.read() };\n             let mut i = right;\n             // `gcd` can be found before hand by calculating `gcd(left + right, right)`,\n             // but it is faster to do one loop which calculates the gcd as a side effect, then\n@@ -90,15 +92,15 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // the very end. This is possibly due to the fact that swapping or replacing temporaries\n             // uses only one memory address in the loop instead of needing to manage two.\n             loop {\n-                tmp = x.add(i).replace(tmp);\n+                tmp = unsafe { x.add(i).replace(tmp) };\n                 // instead of incrementing `i` and then checking if it is outside the bounds, we\n                 // check if `i` will go outside the bounds on the next increment. This prevents\n                 // any wrapping of pointers or `usize`.\n                 if i >= left {\n                     i -= left;\n                     if i == 0 {\n                         // end of first round\n-                        x.write(tmp);\n+                        unsafe { x.write(tmp) };\n                         break;\n                     }\n                     // this conditional must be here if `left + right >= 15`\n@@ -111,14 +113,14 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             }\n             // finish the chunk with more rounds\n             for start in 1..gcd {\n-                tmp = x.add(start).read();\n+                tmp = unsafe { x.add(start).read() };\n                 i = start + right;\n                 loop {\n-                    tmp = x.add(i).replace(tmp);\n+                    tmp = unsafe { x.add(i).replace(tmp) };\n                     if i >= left {\n                         i -= left;\n                         if i == start {\n-                            x.add(start).write(tmp);\n+                            unsafe { x.add(start).write(tmp) };\n                             break;\n                         }\n                     } else {\n@@ -133,15 +135,19 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // The `[T; 0]` here is to ensure this is appropriately aligned for T\n             let mut rawarray = MaybeUninit::<(BufType, [T; 0])>::uninit();\n             let buf = rawarray.as_mut_ptr() as *mut T;\n-            let dim = mid.sub(left).add(right);\n+            let dim = unsafe { mid.sub(left).add(right) };\n             if left <= right {\n-                ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n-                ptr::copy(mid, mid.sub(left), right);\n-                ptr::copy_nonoverlapping(buf, dim, left);\n+                unsafe {\n+                    ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n+                    ptr::copy(mid, mid.sub(left), right);\n+                    ptr::copy_nonoverlapping(buf, dim, left);\n+                }\n             } else {\n-                ptr::copy_nonoverlapping(mid, buf, right);\n-                ptr::copy(mid.sub(left), dim, left);\n-                ptr::copy_nonoverlapping(buf, mid.sub(left), right);\n+                unsafe {\n+                    ptr::copy_nonoverlapping(mid, buf, right);\n+                    ptr::copy(mid.sub(left), dim, left);\n+                    ptr::copy_nonoverlapping(buf, mid.sub(left), right);\n+                }\n             }\n             return;\n         } else if left >= right {\n@@ -150,8 +156,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // of this algorithm would be, and swapping using that last chunk instead of swapping\n             // adjacent chunks like this algorithm is doing, but this way is still faster.\n             loop {\n-                ptr::swap_nonoverlapping(mid.sub(right), mid, right);\n-                mid = mid.sub(right);\n+                unsafe {\n+                    ptr::swap_nonoverlapping(mid.sub(right), mid, right);\n+                    mid = mid.sub(right);\n+                }\n                 left -= right;\n                 if left < right {\n                     break;\n@@ -160,8 +168,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n         } else {\n             // Algorithm 3, `left < right`\n             loop {\n-                ptr::swap_nonoverlapping(mid.sub(left), mid, left);\n-                mid = mid.add(left);\n+                unsafe {\n+                    ptr::swap_nonoverlapping(mid.sub(left), mid, left);\n+                    mid = mid.add(left);\n+                }\n                 right -= left;\n                 if right < left {\n                     break;"}, {"sha": "0014501d2c4d0624958317bcde37ecd587454180", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 77, "deletions": 22, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -419,7 +419,11 @@ pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n-    &*(v as *const [u8] as *const str)\n+    // SAFETY: the caller must guarantee that the bytes `v`\n+    // are valid UTF-8, thus the cast to `*const str` is safe.\n+    // Also, the pointer dereference is safe because that pointer\n+    // comes from a reference which is guaranteed to be valid for reads.\n+    unsafe { &*(v as *const [u8] as *const str) }\n }\n \n /// Converts a slice of bytes to a string slice without checking\n@@ -444,7 +448,11 @@ pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n #[inline]\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n-    &mut *(v as *mut [u8] as *mut str)\n+    // SAFETY: the caller must guarantee that the bytes `v`\n+    // are valid UTF-8, thus the cast to `*mut str` is safe.\n+    // Also, the pointer dereference is safe because that pointer\n+    // comes from a reference which is guaranteed to be valid for writes.\n+    unsafe { &mut *(v as *mut [u8] as *mut str) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -867,7 +875,9 @@ unsafe impl TrustedLen for Bytes<'_> {}\n #[doc(hidden)]\n unsafe impl TrustedRandomAccess for Bytes<'_> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> u8 {\n-        self.0.get_unchecked(i)\n+        // SAFETY: the caller must uphold the safety contract\n+        // for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { self.0.get_unchecked(i) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -1904,15 +1914,27 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            let ptr = slice.as_ptr().add(self.start);\n+            // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n+            // which satisfies all the conditions for `add`.\n+            let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n+            // we can safely construct a subslice with `from_raw_parts` and use it\n+            // since we return a shared thus immutable reference.\n+            // The call to `from_utf8_unchecked` is safe since the data comes from\n+            // a `str` which is guaranteed to be valid utf8, since the caller\n+            // must guarantee that `self.start` and `self.end` are char boundaries.\n+            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_mut_ptr().add(self.start);\n+            // SAFETY: see comments for `get_unchecked`.\n+            let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len))\n+            // SAFETY: mostly identical to the comments for `get_unchecked`, except that we\n+            // can return a mutable reference since the caller passed a mutable reference\n+            // and is thus guaranteed to have exclusive write access to `slice`.\n+            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -1974,12 +1996,21 @@ mod traits {\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n             let ptr = slice.as_ptr();\n-            super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end))\n+            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n+            // we can safely construct a subslice with `from_raw_parts` and use it\n+            // since we return a shared thus immutable reference.\n+            // The call to `from_utf8_unchecked` is safe since the data comes from\n+            // a `str` which is guaranteed to be valid utf8, since the caller\n+            // must guarantee that `self.end` is a char boundary.\n+            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end)) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n             let ptr = slice.as_mut_ptr();\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, self.end))\n+            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n+            // return a mutable reference since the caller passed a mutable reference\n+            // and is thus guaranteed to have exclusive write access to `slice`.\n+            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, self.end)) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2036,15 +2067,27 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            let ptr = slice.as_ptr().add(self.start);\n+            // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n+            // which satisfies all the conditions for `add`.\n+            let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n+            // we can safely construct a subslice with `from_raw_parts` and use it\n+            // since we return a shared thus immutable reference.\n+            // The call to `from_utf8_unchecked` is safe since the data comes from\n+            // a `str` which is guaranteed to be valid utf8, since the caller\n+            // must guarantee that `self.start` is a char boundary.\n+            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_mut_ptr().add(self.start);\n+            // SAFETY: identical to `get_unchecked`.\n+            let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len))\n+            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n+            // return a mutable reference since the caller passed a mutable reference\n+            // and is thus guaranteed to have exclusive write access to `slice`.\n+            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2099,11 +2142,13 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            (*self.start()..self.end() + 1).get_unchecked(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+            unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            (*self.start()..self.end() + 1).get_unchecked_mut(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+            unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2148,11 +2193,13 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            (..self.end + 1).get_unchecked(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+            unsafe { (..self.end + 1).get_unchecked(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            (..self.end + 1).get_unchecked_mut(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+            unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2373,7 +2420,11 @@ impl str {\n     #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n     #[inline(always)]\n     pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n-        &mut *(self as *mut str as *mut [u8])\n+        // SAFETY: the cast from `&str` to `&[u8]` is safe since `str`\n+        // has the same layout as `&[u8]` (only libstd can make this guarantee).\n+        // The pointer dereference is safe since it comes from a mutable reference which\n+        // is guaranteed to be valid for writes.\n+        unsafe { &mut *(self as *mut str as *mut [u8]) }\n     }\n \n     /// Converts a string slice to a raw pointer.\n@@ -2509,7 +2560,8 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        i.get_unchecked(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+        unsafe { i.get_unchecked(self) }\n     }\n \n     /// Returns a mutable, unchecked subslice of `str`.\n@@ -2541,7 +2593,8 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        i.get_unchecked_mut(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { i.get_unchecked_mut(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2591,7 +2644,8 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        (begin..end).get_unchecked(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+        unsafe { (begin..end).get_unchecked(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2622,7 +2676,8 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked_mut(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        (begin..end).get_unchecked_mut(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (begin..end).get_unchecked_mut(self) }\n     }\n \n     /// Divide one string slice into two at an index."}, {"sha": "fcae6c86774f24c9397aee4d6626e55a2526f9db", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 149, "deletions": 104, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -2335,61 +2335,76 @@ fn strongest_failure_ordering(order: Ordering) -> Ordering {\n \n #[inline]\n unsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {\n-    match order {\n-        Release => intrinsics::atomic_store_rel(dst, val),\n-        Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_store(dst, val),\n-        Acquire => panic!(\"there is no such thing as an acquire store\"),\n-        AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_store`.\n+    unsafe {\n+        match order {\n+            Release => intrinsics::atomic_store_rel(dst, val),\n+            Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_store(dst, val),\n+            Acquire => panic!(\"there is no such thing as an acquire store\"),\n+            AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n+        }\n     }\n }\n \n #[inline]\n unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_load_acq(dst),\n-        Relaxed => intrinsics::atomic_load_relaxed(dst),\n-        SeqCst => intrinsics::atomic_load(dst),\n-        Release => panic!(\"there is no such thing as a release load\"),\n-        AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_load`.\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_load_acq(dst),\n+            Relaxed => intrinsics::atomic_load_relaxed(dst),\n+            SeqCst => intrinsics::atomic_load(dst),\n+            Release => panic!(\"there is no such thing as a release load\"),\n+            AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n+        }\n     }\n }\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xchg_acq(dst, val),\n-        Release => intrinsics::atomic_xchg_rel(dst, val),\n-        AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_xchg(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_swap`.\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_xchg_acq(dst, val),\n+            Release => intrinsics::atomic_xchg_rel(dst, val),\n+            AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_xchg(dst, val),\n+        }\n     }\n }\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xadd_acq(dst, val),\n-        Release => intrinsics::atomic_xadd_rel(dst, val),\n-        AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_xadd(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_add`.\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_xadd_acq(dst, val),\n+            Release => intrinsics::atomic_xadd_rel(dst, val),\n+            AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_xadd(dst, val),\n+        }\n     }\n }\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xsub_acq(dst, val),\n-        Release => intrinsics::atomic_xsub_rel(dst, val),\n-        AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_xsub(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_sub`.\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_xsub_acq(dst, val),\n+            Release => intrinsics::atomic_xsub_rel(dst, val),\n+            AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_xsub(dst, val),\n+        }\n     }\n }\n \n@@ -2402,19 +2417,22 @@ unsafe fn atomic_compare_exchange<T: Copy>(\n     success: Ordering,\n     failure: Ordering,\n ) -> Result<T, T> {\n-    let (val, ok) = match (success, failure) {\n-        (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n-        (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n-        (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n-        (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n-        (SeqCst, SeqCst) => intrinsics::atomic_cxchg(dst, old, new),\n-        (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n-        (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n-        (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n-        (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n-        (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n-        (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n-        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange`.\n+    let (val, ok) = unsafe {\n+        match (success, failure) {\n+            (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n+            (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n+            (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n+            (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n+            (SeqCst, SeqCst) => intrinsics::atomic_cxchg(dst, old, new),\n+            (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n+            (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n+            (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n+            (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n+            (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+            (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n+            _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+        }\n     };\n     if ok { Ok(val) } else { Err(val) }\n }\n@@ -2428,120 +2446,147 @@ unsafe fn atomic_compare_exchange_weak<T: Copy>(\n     success: Ordering,\n     failure: Ordering,\n ) -> Result<T, T> {\n-    let (val, ok) = match (success, failure) {\n-        (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n-        (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n-        (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n-        (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n-        (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak(dst, old, new),\n-        (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n-        (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n-        (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n-        (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n-        (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n-        (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n-        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange_weak`.\n+    let (val, ok) = unsafe {\n+        match (success, failure) {\n+            (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n+            (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n+            (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n+            (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n+            (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak(dst, old, new),\n+            (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n+            (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n+            (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n+            (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n+            (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+            (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n+            _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+        }\n     };\n     if ok { Ok(val) } else { Err(val) }\n }\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_and_acq(dst, val),\n-        Release => intrinsics::atomic_and_rel(dst, val),\n-        AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_and(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_and`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_and_acq(dst, val),\n+            Release => intrinsics::atomic_and_rel(dst, val),\n+            AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_and(dst, val),\n+        }\n     }\n }\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_nand_acq(dst, val),\n-        Release => intrinsics::atomic_nand_rel(dst, val),\n-        AcqRel => intrinsics::atomic_nand_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_nand(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_nand`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_nand_acq(dst, val),\n+            Release => intrinsics::atomic_nand_rel(dst, val),\n+            AcqRel => intrinsics::atomic_nand_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_nand(dst, val),\n+        }\n     }\n }\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_or_acq(dst, val),\n-        Release => intrinsics::atomic_or_rel(dst, val),\n-        AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_or(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_or`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_or_acq(dst, val),\n+            Release => intrinsics::atomic_or_rel(dst, val),\n+            AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_or(dst, val),\n+        }\n     }\n }\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xor_acq(dst, val),\n-        Release => intrinsics::atomic_xor_rel(dst, val),\n-        AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_xor(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_xor`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_xor_acq(dst, val),\n+            Release => intrinsics::atomic_xor_rel(dst, val),\n+            AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_xor(dst, val),\n+        }\n     }\n }\n \n /// returns the max value (signed comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_max_acq(dst, val),\n-        Release => intrinsics::atomic_max_rel(dst, val),\n-        AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_max(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_max`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_max_acq(dst, val),\n+            Release => intrinsics::atomic_max_rel(dst, val),\n+            AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_max(dst, val),\n+        }\n     }\n }\n \n /// returns the min value (signed comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_min_acq(dst, val),\n-        Release => intrinsics::atomic_min_rel(dst, val),\n-        AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_min(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_min`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_min_acq(dst, val),\n+            Release => intrinsics::atomic_min_rel(dst, val),\n+            AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_min(dst, val),\n+        }\n     }\n }\n \n /// returns the max value (unsigned comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_umax_acq(dst, val),\n-        Release => intrinsics::atomic_umax_rel(dst, val),\n-        AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_umax(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_umax`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_umax_acq(dst, val),\n+            Release => intrinsics::atomic_umax_rel(dst, val),\n+            AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_umax(dst, val),\n+        }\n     }\n }\n \n /// returns the min value (unsigned comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_umin_acq(dst, val),\n-        Release => intrinsics::atomic_umin_rel(dst, val),\n-        AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_umin(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_umin`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_umin_acq(dst, val),\n+            Release => intrinsics::atomic_umin_rel(dst, val),\n+            AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_umin(dst, val),\n+        }\n     }\n }\n "}, {"sha": "68a5e20a66fdc8a89bfad516b3057a3a6ac2bb23", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -44,6 +44,8 @@\n #![feature(option_unwrap_none)]\n #![feature(peekable_next_if)]\n #![feature(partition_point)]\n+#![feature(unsafe_block_in_unsafe_fn)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;\n "}, {"sha": "1fa3992cc5afdb13c89365180d43112595758ac9", "filename": "src/test/ui/consts/miri_unleashed/drop.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -4,7 +4,9 @@ error[E0080]: could not evaluate static initializer\n LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n LL | |     // Code here does not matter - this is replaced by the\n LL | |     // real drop glue by the compiler.\n-LL | |     drop_in_place(to_drop)\n+LL | |\n+LL | |     // SAFETY: see comment above\n+LL | |     unsafe { drop_in_place(to_drop) }\n LL | | }\n    | | ^\n    | | |"}, {"sha": "aa65f4de3e17ee7a1269bb3c33f5ac4f0e1b8029", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -1,12 +1,12 @@\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |           intrinsics::ptr_offset_from(self, origin)\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |           |\n-   |           ptr_offset_from cannot compute offset of pointers into different allocations.\n-   |           inside `std::ptr::const_ptr::<impl *const Struct>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |           inside `DIFFERENT_ALLOC` at $DIR/offset_from_ub.rs:17:27\n+LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    ptr_offset_from cannot compute offset of pointers into different allocations.\n+   |                    inside `std::ptr::const_ptr::<impl *const Struct>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                    inside `DIFFERENT_ALLOC` at $DIR/offset_from_ub.rs:17:27\n    | \n   ::: $DIR/offset_from_ub.rs:11:1\n    |\n@@ -24,12 +24,12 @@ LL | | };\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |           intrinsics::ptr_offset_from(self, origin)\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |           |\n-   |           unable to turn bytes into a pointer\n-   |           inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |           inside `NOT_PTR` at $DIR/offset_from_ub.rs:23:14\n+LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    unable to turn bytes into a pointer\n+   |                    inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                    inside `NOT_PTR` at $DIR/offset_from_ub.rs:23:14\n    | \n   ::: $DIR/offset_from_ub.rs:21:1\n    |\n@@ -42,12 +42,12 @@ LL | | };\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |           intrinsics::ptr_offset_from(self, origin)\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |           |\n-   |           exact_div: 1_isize cannot be divided by 2_isize without remainder\n-   |           inside `std::ptr::const_ptr::<impl *const u16>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |           inside `NOT_MULTIPLE_OF_SIZE` at $DIR/offset_from_ub.rs:31:14\n+LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    exact_div: 1_isize cannot be divided by 2_isize without remainder\n+   |                    inside `std::ptr::const_ptr::<impl *const u16>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                    inside `NOT_MULTIPLE_OF_SIZE` at $DIR/offset_from_ub.rs:31:14\n    | \n   ::: $DIR/offset_from_ub.rs:26:1\n    |\n@@ -63,12 +63,12 @@ LL | | };\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |           intrinsics::ptr_offset_from(self, origin)\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |           |\n-   |           inbounds test failed: 0x0 is not a valid pointer\n-   |           inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |           inside `OFFSET_FROM_NULL` at $DIR/offset_from_ub.rs:37:14\n+LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    inbounds test failed: 0x0 is not a valid pointer\n+   |                    inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                    inside `OFFSET_FROM_NULL` at $DIR/offset_from_ub.rs:37:14\n    | \n   ::: $DIR/offset_from_ub.rs:34:1\n    |\n@@ -82,12 +82,12 @@ LL | | };\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |           intrinsics::ptr_offset_from(self, origin)\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |           |\n-   |           unable to turn bytes into a pointer\n-   |           inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |           inside `DIFFERENT_INT` at $DIR/offset_from_ub.rs:44:14\n+LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    unable to turn bytes into a pointer\n+   |                    inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                    inside `DIFFERENT_INT` at $DIR/offset_from_ub.rs:44:14\n    | \n   ::: $DIR/offset_from_ub.rs:40:1\n    |"}, {"sha": "0a144a6bac2f18ae0124aee27d10cf0dcd3dfac0", "filename": "src/test/ui/consts/offset_ub.stderr", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -1,12 +1,12 @@\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         overflowing in-bounds pointer arithmetic\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `BEFORE_START` at $DIR/offset_ub.rs:7:46\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  overflowing in-bounds pointer arithmetic\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `BEFORE_START` at $DIR/offset_ub.rs:7:46\n    | \n   ::: $DIR/offset_ub.rs:7:1\n    |\n@@ -18,12 +18,12 @@ LL | pub const BEFORE_START: *const u8 = unsafe { (&0u8 as *const u8).offset(-1)\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         inbounds test failed: pointer must be in-bounds at offset 2, but is outside bounds of allocN which has size 1\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `AFTER_END` at $DIR/offset_ub.rs:8:43\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  inbounds test failed: pointer must be in-bounds at offset 2, but is outside bounds of allocN which has size 1\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `AFTER_END` at $DIR/offset_ub.rs:8:43\n    | \n   ::: $DIR/offset_ub.rs:8:1\n    |\n@@ -33,12 +33,12 @@ LL | pub const AFTER_END: *const u8 = unsafe { (&0u8 as *const u8).offset(2) };\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         inbounds test failed: pointer must be in-bounds at offset 101, but is outside bounds of allocN which has size 100\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `AFTER_ARRAY` at $DIR/offset_ub.rs:9:45\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  inbounds test failed: pointer must be in-bounds at offset 101, but is outside bounds of allocN which has size 100\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `AFTER_ARRAY` at $DIR/offset_ub.rs:9:45\n    | \n   ::: $DIR/offset_ub.rs:9:1\n    |\n@@ -48,12 +48,12 @@ LL | pub const AFTER_ARRAY: *const u8 = unsafe { [0u8; 100].as_ptr().offset(101)\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         overflowing in-bounds pointer arithmetic\n-   |         inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `OVERFLOW` at $DIR/offset_ub.rs:11:43\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  overflowing in-bounds pointer arithmetic\n+   |                  inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `OVERFLOW` at $DIR/offset_ub.rs:11:43\n    | \n   ::: $DIR/offset_ub.rs:11:1\n    |\n@@ -63,12 +63,12 @@ LL | pub const OVERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         overflowing in-bounds pointer arithmetic\n-   |         inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `UNDERFLOW` at $DIR/offset_ub.rs:12:44\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  overflowing in-bounds pointer arithmetic\n+   |                  inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `UNDERFLOW` at $DIR/offset_ub.rs:12:44\n    | \n   ::: $DIR/offset_ub.rs:12:1\n    |\n@@ -78,12 +78,12 @@ LL | pub const UNDERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize:\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         overflowing in-bounds pointer arithmetic\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `OVERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:13:56\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  overflowing in-bounds pointer arithmetic\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `OVERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:13:56\n    | \n   ::: $DIR/offset_ub.rs:13:1\n    |\n@@ -93,12 +93,12 @@ LL | pub const OVERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (usize::MAX as *cons\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         overflowing in-bounds pointer arithmetic\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `UNDERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:14:57\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  overflowing in-bounds pointer arithmetic\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `UNDERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:14:57\n    | \n   ::: $DIR/offset_ub.rs:14:1\n    |\n@@ -108,12 +108,12 @@ LL | pub const UNDERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (1 as *const u8).of\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         inbounds test failed: pointer must be in-bounds at offset 1, but is outside bounds of allocN which has size 0\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `ZERO_SIZED_ALLOC` at $DIR/offset_ub.rs:16:50\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  inbounds test failed: pointer must be in-bounds at offset 1, but is outside bounds of allocN which has size 0\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `ZERO_SIZED_ALLOC` at $DIR/offset_ub.rs:16:50\n    | \n   ::: $DIR/offset_ub.rs:16:1\n    |\n@@ -123,12 +123,12 @@ LL | pub const ZERO_SIZED_ALLOC: *const u8 = unsafe { [0u8; 0].as_ptr().offset(1\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count) as *mut T\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         unable to turn bytes into a pointer\n-   |         inside `std::ptr::mut_ptr::<impl *mut u8>::offset` at $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n-   |         inside `DANGLING` at $DIR/offset_ub.rs:17:42\n+LL |         unsafe { intrinsics::offset(self, count) as *mut T }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  unable to turn bytes into a pointer\n+   |                  inside `std::ptr::mut_ptr::<impl *mut u8>::offset` at $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n+   |                  inside `DANGLING` at $DIR/offset_ub.rs:17:42\n    | \n   ::: $DIR/offset_ub.rs:17:1\n    |\n@@ -138,12 +138,12 @@ LL | pub const DANGLING: *const u8 = unsafe { ptr::NonNull::<u8>::dangling().as_\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         inbounds test failed: 0x0 is not a valid pointer\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `NULL_OFFSET_ZERO` at $DIR/offset_ub.rs:20:50\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  inbounds test failed: 0x0 is not a valid pointer\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `NULL_OFFSET_ZERO` at $DIR/offset_ub.rs:20:50\n    | \n   ::: $DIR/offset_ub.rs:20:1\n    |\n@@ -153,12 +153,12 @@ LL | pub const NULL_OFFSET_ZERO: *const u8 = unsafe { ptr::null::<u8>().offset(0\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         unable to turn bytes into a pointer\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `UNDERFLOW_ABS` at $DIR/offset_ub.rs:23:47\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  unable to turn bytes into a pointer\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `UNDERFLOW_ABS` at $DIR/offset_ub.rs:23:47\n    | \n   ::: $DIR/offset_ub.rs:23:1\n    |"}, {"sha": "3296a2cb094a15f67d3d02677b3a2c69ba46ea05", "filename": "src/test/ui/recursion/issue-38591-non-regular-dropck-recursion.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/500634bf1073248bb5b8561da3720a0820b09869/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/500634bf1073248bb5b8561da3720a0820b09869/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr?ref=500634bf1073248bb5b8561da3720a0820b09869", "patch": "@@ -4,7 +4,9 @@ error: reached the recursion limit while instantiating `std::intrinsics::drop_in\n LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n LL | |     // Code here does not matter - this is replaced by the\n LL | |     // real drop glue by the compiler.\n-LL | |     drop_in_place(to_drop)\n+LL | |\n+LL | |     // SAFETY: see comment above\n+LL | |     unsafe { drop_in_place(to_drop) }\n LL | | }\n    | |_^\n    |\n@@ -14,7 +16,9 @@ note: `std::intrinsics::drop_in_place` defined here\n LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n LL | |     // Code here does not matter - this is replaced by the\n LL | |     // real drop glue by the compiler.\n-LL | |     drop_in_place(to_drop)\n+LL | |\n+LL | |     // SAFETY: see comment above\n+LL | |     unsafe { drop_in_place(to_drop) }\n LL | | }\n    | |_^\n "}]}