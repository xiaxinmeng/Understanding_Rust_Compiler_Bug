{"sha": "8e2d952c6815d8ab3a0192cc3085737ee48c2377", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMmQ5NTJjNjgxNWQ4YWIzYTAxOTJjYzMwODU3MzdlZTQ4YzIzNzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T16:25:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T16:25:34Z"}, "message": "Revert \"debuginfo: Clean the debuginfo module up a bit.\"\n\nThis reverts commit 34a6fcf19566e5015c1ef4c144a408a2f182cf4d.", "tree": {"sha": "3617122f7b569079fbf69dfd37ffbb1c752bba41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3617122f7b569079fbf69dfd37ffbb1c752bba41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e2d952c6815d8ab3a0192cc3085737ee48c2377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e2d952c6815d8ab3a0192cc3085737ee48c2377", "html_url": "https://github.com/rust-lang/rust/commit/8e2d952c6815d8ab3a0192cc3085737ee48c2377", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e2d952c6815d8ab3a0192cc3085737ee48c2377/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f450695183184db5fb0df2c4196b412668c678be", "url": "https://api.github.com/repos/rust-lang/rust/commits/f450695183184db5fb0df2c4196b412668c678be", "html_url": "https://github.com/rust-lang/rust/commit/f450695183184db5fb0df2c4196b412668c678be"}], "stats": {"total": 162, "additions": 74, "deletions": 88}, "files": [{"sha": "0cf09460969cc90955589a682c3ac421579b0381", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 74, "deletions": 88, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/8e2d952c6815d8ab3a0192cc3085737ee48c2377/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2d952c6815d8ab3a0192cc3085737ee48c2377/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=8e2d952c6815d8ab3a0192cc3085737ee48c2377", "patch": "@@ -182,6 +182,7 @@\n //! comparatively expensive to construct, though, `ty::type_id()` is still used\n //! additionally as an optimization for cases where the exact same type has been\n //! seen before (which is most of the time).\n+use self::FunctionDebugContextRepr::*;\n use self::VariableAccess::*;\n use self::VariableKind::*;\n use self::MemberOffset::*;\n@@ -678,8 +679,12 @@ impl<'tcx> CrateDebugContext<'tcx> {\n     }\n }\n \n-pub enum FunctionDebugContext {\n-    RegularContext(Box<FunctionDebugContextData>),\n+pub struct FunctionDebugContext {\n+    repr: FunctionDebugContextRepr,\n+}\n+\n+enum FunctionDebugContextRepr {\n+    DebugInfo(Box<FunctionDebugContextData>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n@@ -689,13 +694,13 @@ impl FunctionDebugContext {\n                    cx: &CrateContext,\n                    span: Span)\n                    -> &'a FunctionDebugContextData {\n-        match *self {\n-            FunctionDebugContext::RegularContext(box ref data) => data,\n-            FunctionDebugContext::DebugInfoDisabled => {\n+        match self.repr {\n+            DebugInfo(box ref data) => data,\n+            DebugInfoDisabled => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::debuginfo_disabled_message());\n             }\n-            FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            FunctionWithoutDebugInfo => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::should_be_ignored_message());\n             }\n@@ -839,8 +844,6 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n /// Creates debug information for the given local variable.\n ///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// local in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n     if fn_should_be_ignored(bcx.fcx) {\n@@ -849,10 +852,11 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n \n     let cx = bcx.ccx();\n     let def_map = &cx.tcx().def_map;\n-    let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_ident| {\n-        let datum = match locals.get(&node_id) {\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n+        let var_ident = path1.node;\n+\n+        let datum = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -861,15 +865,10 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            cx.sess().span_bug(span, \"debuginfo::create_local_var_metadata() - \\\n-                                      Referenced variable location is not an alloca!\");\n-        }\n-\n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n         declare_local(bcx,\n-                      var_ident.node,\n+                      var_ident,\n                       datum.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: datum.val },\n@@ -982,7 +981,7 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n     // actually have `T**`. So to get the actual variable we need to dereference once\n     // more. For ByCopy we just use the stack slot we created for the binding.\n-    let var_access = match binding.trmode {\n+    let var_type = match binding.trmode {\n         TrByCopy(llbinding) => DirectVariable {\n             alloca: llbinding\n         },\n@@ -999,31 +998,27 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   variable_ident,\n                   binding.ty,\n                   scope_metadata,\n-                  var_access,\n+                  var_type,\n                   LocalVariable,\n                   binding.span);\n }\n \n /// Creates debug information for the given function argument.\n ///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// argument in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n-    let def_map = &bcx.tcx().def_map;\n-    let scope_metadata = bcx\n-                         .fcx\n-                         .debug_context\n-                         .get_ref(bcx.ccx(), arg.pat.span)\n-                         .fn_metadata;\n-    let locals = bcx.fcx.lllocals.borrow();\n-\n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_ident| {\n-        let datum = match locals.get(&node_id) {\n+    let fcx = bcx.fcx;\n+    let cx = fcx.ccx;\n+\n+    let def_map = &cx.tcx().def_map;\n+    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n+\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n+        let llarg = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1032,47 +1027,40 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            bcx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n-                                       Referenced variable location is not an alloca!\");\n+        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null_mut() {\n+            cx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n+                                    Referenced variable location is not an alloca!\");\n         }\n \n         let argument_index = {\n-            let counter = &bcx\n-                          .fcx\n-                          .debug_context\n-                          .get_ref(bcx.ccx(), span)\n-                          .argument_counter;\n+            let counter = &fcx.debug_context.get_ref(cx, span).argument_counter;\n             let argument_index = counter.get();\n             counter.set(argument_index + 1);\n             argument_index\n         };\n \n         declare_local(bcx,\n-                      var_ident.node,\n-                      datum.ty,\n+                      path1.node,\n+                      llarg.ty,\n                       scope_metadata,\n-                      DirectVariable { alloca: datum.val },\n+                      DirectVariable { alloca: llarg.val },\n                       ArgumentVariable(argument_index),\n                       span);\n     })\n }\n \n /// Creates debug information for the given for-loop variable.\n ///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// loop variable in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n     let def_map = &bcx.tcx().def_map;\n-    let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, pat, |_, node_id, span, var_ident| {\n-        let datum = match locals.get(&node_id) {\n+    pat_util::pat_bindings(def_map, pat, |_, node_id, span, spanned_ident| {\n+        let datum = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1089,7 +1077,7 @@ pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n         declare_local(bcx,\n-                      var_ident.node,\n+                      spanned_ident.node,\n                       datum.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: datum.val },\n@@ -1166,13 +1154,13 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n                            span: Span) {\n-    match fcx.debug_context {\n-        FunctionDebugContext::DebugInfoDisabled => return,\n-        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+    match fcx.debug_context.repr {\n+        DebugInfoDisabled => return,\n+        FunctionWithoutDebugInfo => {\n             set_debug_location(fcx.ccx, UnknownLocation);\n             return;\n         }\n-        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n+        DebugInfo(box ref function_debug_context) => {\n             let cx = fcx.ccx;\n \n             debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n@@ -1209,8 +1197,8 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is translated.\n pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n-    match fcx.debug_context {\n-        FunctionDebugContext::RegularContext(box ref data) => {\n+    match fcx.debug_context.repr {\n+        DebugInfo(box ref data) => {\n             data.source_locations_enabled.set(true)\n         },\n         _ => { /* safe to ignore */ }\n@@ -1228,7 +1216,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                param_substs: &Substs<'tcx>,\n                                                llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n-        return FunctionDebugContext::DebugInfoDisabled;\n+        return FunctionDebugContext { repr: DebugInfoDisabled };\n     }\n \n     // Clear the debug location so we don't assign them in the function prelude.\n@@ -1238,7 +1226,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     if fn_ast_id == ast::DUMMY_NODE_ID {\n         // This is a function not linked to any source location, so don't\n         // generate debuginfo for it.\n-        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n     }\n \n     let empty_generics = ast_util::empty_generics();\n@@ -1248,7 +1236,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::NodeItem(ref item) => {\n             if contains_nodebug_attribute(item.attrs.as_slice()) {\n-                return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n             }\n \n             match item.node {\n@@ -1265,7 +1253,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **item {\n                 ast::MethodImplItem(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                        return FunctionDebugContext {\n+                            repr: FunctionWithoutDebugInfo\n+                        };\n                     }\n \n                     (method.pe_ident(),\n@@ -1304,7 +1294,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **trait_method {\n                 ast::ProvidedMethod(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                        return FunctionDebugContext {\n+                            repr: FunctionWithoutDebugInfo\n+                        };\n                     }\n \n                     (method.pe_ident(),\n@@ -1325,7 +1317,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeForeignItem(..) |\n         ast_map::NodeVariant(..) |\n         ast_map::NodeStructCtor(..) => {\n-            return FunctionDebugContext::FunctionWithoutDebugInfo;\n+            return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n@@ -1334,7 +1326,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // This can be the case for functions inlined from another crate\n     if span == codemap::DUMMY_SP {\n-        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n     }\n \n     let loc = span_start(cx, span);\n@@ -1401,23 +1393,22 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n     });\n \n-    let scope_map = create_scope_map(cx,\n-                                     fn_decl.inputs.as_slice(),\n-                                     &*top_level_block,\n-                                     fn_metadata,\n-                                     fn_ast_id);\n-\n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n-        scope_map: RefCell::new(scope_map),\n+        scope_map: RefCell::new(NodeMap::new()),\n         fn_metadata: fn_metadata,\n         argument_counter: Cell::new(1),\n         source_locations_enabled: Cell::new(false),\n     };\n \n+    populate_scope_map(cx,\n+                       fn_decl.inputs.as_slice(),\n+                       &*top_level_block,\n+                       fn_metadata,\n+                       fn_ast_id,\n+                       &mut *fn_debug_context.scope_map.borrow_mut());\n \n-\n-    return FunctionDebugContext::RegularContext(fn_debug_context);\n+    return FunctionDebugContext { repr: DebugInfo(fn_debug_context) };\n \n     fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                         fn_ast_id: ast::NodeId,\n@@ -3180,8 +3171,8 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n }\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n-    match fcx.debug_context {\n-        FunctionDebugContext::RegularContext(_) => false,\n+    match fcx.debug_context.repr {\n+        DebugInfo(_) => false,\n         _ => true\n     }\n }\n@@ -3215,14 +3206,12 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n // what belongs to which scope, creating DIScope DIEs along the way, and\n // introducing *artificial* lexical scope descriptors where necessary. These\n // artificial scopes allow GDB to correctly handle name shadowing.\n-fn create_scope_map(cx: &CrateContext,\n-                    args: &[ast::Arg],\n-                    fn_entry_block: &ast::Block,\n-                    fn_metadata: DISubprogram,\n-                    fn_ast_id: ast::NodeId)\n-                 -> NodeMap<DIScope> {\n-    let mut scope_map = NodeMap::new();\n-\n+fn populate_scope_map(cx: &CrateContext,\n+                      args: &[ast::Arg],\n+                      fn_entry_block: &ast::Block,\n+                      fn_metadata: DISubprogram,\n+                      fn_ast_id: ast::NodeId,\n+                      scope_map: &mut NodeMap<DIScope>) {\n     let def_map = &cx.tcx().def_map;\n \n     struct ScopeStackEntry {\n@@ -3248,14 +3237,11 @@ fn create_scope_map(cx: &CrateContext,\n     with_new_scope(cx,\n                    fn_entry_block.span,\n                    &mut scope_stack,\n-                   &mut scope_map,\n+                   scope_map,\n                    |cx, scope_stack, scope_map| {\n         walk_block(cx, fn_entry_block, scope_stack, scope_map);\n     });\n \n-    return scope_map;\n-\n-\n     // local helper functions for walking the AST.\n     fn with_new_scope<F>(cx: &CrateContext,\n                          scope_span: Span,\n@@ -3491,7 +3477,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::PatMac(_) => {\n-                cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n+                cx.sess().span_bug(pat.span, \"debuginfo::populate_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n         }\n@@ -3577,7 +3563,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprIfLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n                                               Found unexpanded if-let.\");\n             }\n \n@@ -3594,7 +3580,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprWhileLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n                                               Found unexpanded while-let.\");\n             }\n \n@@ -3619,7 +3605,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprMac(_) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n "}]}