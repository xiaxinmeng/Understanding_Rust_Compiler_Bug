{"sha": "d492d09f31699ff2ef1cda9da71ab3f1910a649f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0OTJkMDlmMzE2OTlmZjJlZjFjZGE5ZGE3MWFiM2YxOTEwYTY0OWY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-25T10:11:02Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:51Z"}, "message": "trans: Apply ZExt and StructRet attributes uniformly.", "tree": {"sha": "a245b6f3581e83e2482c306316164fab51ca6aa1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a245b6f3581e83e2482c306316164fab51ca6aa1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d492d09f31699ff2ef1cda9da71ab3f1910a649f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d492d09f31699ff2ef1cda9da71ab3f1910a649f", "html_url": "https://github.com/rust-lang/rust/commit/d492d09f31699ff2ef1cda9da71ab3f1910a649f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d492d09f31699ff2ef1cda9da71ab3f1910a649f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac60318cf52946027050c18ad68ec85e52555853", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac60318cf52946027050c18ad68ec85e52555853", "html_url": "https://github.com/rust-lang/rust/commit/ac60318cf52946027050c18ad68ec85e52555853"}], "stats": {"total": 224, "additions": 67, "deletions": 157}, "files": [{"sha": "a0351e32259a914c69b5cdc1e0aa9bee4933e120", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -10,8 +10,7 @@\n \n pub use self::ArgKind::*;\n \n-use llvm::{self, AttrHelper, ValueRef};\n-use trans::attributes;\n+use llvm;\n use trans::common::{return_type_is_void, type_is_fat_ptr};\n use trans::context::CrateContext;\n use trans::cabi_x86;\n@@ -23,7 +22,7 @@ use trans::cabi_powerpc;\n use trans::cabi_powerpc64;\n use trans::cabi_mips;\n use trans::cabi_asmjs;\n-use trans::machine::llsize_of_alloc;\n+use trans::machine::{llsize_of_alloc, llsize_of_real};\n use trans::type_::Type;\n use trans::type_of;\n \n@@ -191,6 +190,13 @@ impl FnType {\n             cconv: cconv\n         };\n \n+        // Add ZExt attributes to i1 arguments and returns.\n+        for arg in Some(&mut fty.ret).into_iter().chain(&mut fty.args) {\n+            if arg.ty == Type::i1(ccx) {\n+                arg.attr = Some(llvm::Attribute::ZExt);\n+            }\n+        }\n+\n         if abi == Rust || abi == RustCall {\n             let fixup = |arg: &mut ArgType| {\n                 if !arg.ty.is_aggregate() {\n@@ -246,7 +252,7 @@ impl FnType {\n         fty\n     }\n \n-    pub fn to_llvm(&self, ccx: &CrateContext) -> Type {\n+    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n         let mut llargument_tys = Vec::new();\n \n         let llreturn_ty = if self.ret.is_indirect() {\n@@ -281,19 +287,29 @@ impl FnType {\n         }\n     }\n \n-    pub fn add_attributes(&self, llfn: ValueRef) {\n-        let mut i = if self.ret.is_indirect() {\n-            1\n-        } else {\n-            0\n+    pub fn llvm_attrs(&self, ccx: &CrateContext) -> llvm::AttrBuilder {\n+        let mut attrs = llvm::AttrBuilder::new();\n+        let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n+\n+        // Add attributes that are always applicable, independent of the concrete foreign ABI\n+        if self.ret.is_indirect() {\n+            let llret_sz = llsize_of_real(ccx, self.ret.ty);\n+\n+            // The outptr can be noalias and nocapture because it's entirely\n+            // invisible to the program. We also know it's nonnull as well\n+            // as how many bytes we can dereference\n+            attrs.arg(i, llvm::Attribute::StructRet)\n+                 .arg(i, llvm::Attribute::NoAlias)\n+                 .arg(i, llvm::Attribute::NoCapture)\n+                 .arg(i, llvm::DereferenceableAttribute(llret_sz));\n         };\n \n+        // Add attributes that depend on the concrete foreign ABI\n         if let Some(attr) = self.ret.attr {\n-            attr.apply_llfn(i, llfn);\n+            attrs.arg(i, attr);\n         }\n \n         i += 1;\n-\n         for arg in &self.args {\n             if arg.is_ignore() {\n                 continue;\n@@ -302,12 +318,12 @@ impl FnType {\n             if arg.pad.is_some() { i += 1; }\n \n             if let Some(attr) = arg.attr {\n-                attr.apply_llfn(i, llfn);\n+                attrs.arg(i, attr);\n             }\n \n             i += 1;\n         }\n \n-        attributes::unwind(llfn, false);\n+        attrs\n     }\n }"}, {"sha": "65d2ad9c4fa62a93937b342f0171d993b70b5710", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n use trans::abi::{FnType, ArgType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -163,9 +163,6 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n \n fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n     if is_reg_ty(ret.ty) {\n-        if ret.ty == Type::i1(ccx) {\n-            ret.attr = Some(Attribute::ZExt)\n-        }\n         return;\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n@@ -189,14 +186,10 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n         return;\n     }\n     ret.kind = Indirect;\n-    ret.attr = Some(Attribute::StructRet);\n }\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n     if is_reg_ty(arg.ty) {\n-        if arg.ty == Type::i1(ccx) {\n-            arg.attr = Some(Attribute::ZExt);\n-        }\n         return;\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {"}, {"sha": "77941a853e60e544fa57c088ffff911f123c925c", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n use trans::abi::{FnType, ArgType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -131,9 +131,6 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType, align_fn: TyAlignFn) {\n     if is_reg_ty(ret.ty) {\n-        if ret.ty == Type::i1(ccx) {\n-            ret.attr = Some(Attribute::ZExt);\n-        }\n         return;\n     }\n     let size = ty_size(ret.ty, align_fn);\n@@ -149,14 +146,10 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType, align_fn: TyAlignFn) {\n         return;\n     }\n     ret.kind = Indirect;\n-    ret.attr = Some(Attribute::StructRet);\n }\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, align_fn: TyAlignFn) {\n     if is_reg_ty(arg.ty) {\n-        if arg.ty == Type::i1(ccx) {\n-            arg.attr = Some(Attribute::ZExt);\n-        }\n         return;\n     }\n     let align = align_fn(arg.ty);"}, {"sha": "5c9bf28e4e0bcf978fd6919d67f98c5857d2fb63", "filename": "src/librustc_trans/trans/cabi_asmjs.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -20,46 +20,36 @@ use trans::type_::Type;\n // See the https://github.com/kripken/emscripten-fastcomp-clang repository.\n // The class `EmscriptenABIInfo` in `/lib/CodeGen/TargetInfo.cpp` contains the ABI definitions.\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+fn classify_ret_ty(ret: &mut ArgType) {\n     match ret.ty.kind() {\n         Struct => {\n             let field_types = ret.ty.field_types();\n             if field_types.len() == 1 {\n                 ret.cast = Some(field_types[0]);\n             } else {\n                 ret.kind = Indirect;\n-                ret.attr = Some(Attribute::StructRet);\n             }\n-        },\n+        }\n         Array => {\n             ret.kind = Indirect;\n-            ret.attr = Some(Attribute::StructRet);\n-        },\n-        _ => {\n-            if ret.ty == Type::i1(ccx) {\n-                ret.attr = Some(Attribute::ZExt);\n-            }\n         }\n+        _ => {}\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+fn classify_arg_ty(arg: &mut ArgType) {\n     if arg.ty.is_aggregate() {\n         arg.kind = Indirect;\n         arg.attr = Some(Attribute::ByVal);\n-    } else {\n-        if arg.ty == Type::i1(ccx) {\n-            arg.attr = Some(Attribute::ZExt);\n-        }\n     }\n }\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     if fty.ret.ty != Type::void(ccx) {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(arg);\n     }\n }"}, {"sha": "419c56072b437fd5bd7f6bff9695a728851a67ce", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -13,7 +13,7 @@\n use libc::c_uint;\n use std::cmp;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n use trans::abi::{ArgType, FnType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -86,17 +86,6 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n-        if ret.ty == Type::i1(ccx) {\n-            ret.attr = Some(Attribute::ZExt);\n-        }\n-    } else {\n-        ret.kind = Indirect;\n-        ret.attr = Some(Attribute::StructRet);\n-    }\n-}\n-\n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     let orig_offset = *offset;\n     let size = ty_size(arg.ty) * 8;\n@@ -106,11 +95,7 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     *offset = align_up_to(*offset, align);\n     *offset += align_up_to(size, align * 8) / 8;\n \n-    if is_reg_ty(arg.ty) {\n-        if arg.ty == Type::i1(ccx) {\n-            arg.attr = Some(Attribute::ZExt);\n-        }\n-    } else {\n+    if !is_reg_ty(arg.ty) {\n         arg.cast = Some(struct_ty(ccx, arg.ty));\n         arg.pad = padding_ty(ccx, align, orig_offset);\n     }\n@@ -162,7 +147,9 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     if fty.ret.ty != Type::void(ccx) {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        if !is_reg_ty(fty.ret.ty) {\n+            fty.ret.kind = Indirect;\n+        }\n     }\n \n     let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };"}, {"sha": "ecd5b71ada968938aaa1f7d725a9a6440f8f4502", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -10,7 +10,7 @@\n \n use libc::c_uint;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Attribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n use trans::abi::{FnType, ArgType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -82,17 +82,6 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n-        if ret.ty == Type::i1(ccx) {\n-            ret.attr = Some(Attribute::ZExt);\n-        }\n-    } else {\n-        ret.kind = Indirect;\n-        ret.attr = Some(Attribute::StructRet);\n-    }\n-}\n-\n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     let orig_offset = *offset;\n     let size = ty_size(arg.ty) * 8;\n@@ -102,11 +91,7 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     *offset = align_up_to(*offset, align);\n     *offset += align_up_to(size, align * 8) / 8;\n \n-    if is_reg_ty(arg.ty) {\n-        if arg.ty == Type::i1(ccx) {\n-            arg.attr = Some(Attribute::ZExt);\n-        }\n-    } else {\n+    if !is_reg_ty(arg.ty) {\n         arg.cast = Some(struct_ty(ccx, arg.ty));\n         arg.pad = padding_ty(ccx, align, orig_offset);\n     }\n@@ -157,7 +142,9 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     if fty.ret.ty != Type::void(ccx) {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        if !is_reg_ty(fty.ret.ty) {\n+            fty.ret.kind = Indirect;\n+        }\n     }\n \n     let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };"}, {"sha": "b28ec618650a36e37c4fe471ea2b446818ec9e7a", "filename": "src/librustc_trans/trans/cabi_powerpc64.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -15,7 +15,7 @@\n // Alignment of 128 bit types is not currently handled, this will\n // need to be fixed when PowerPC vector support is added.\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Attribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n use trans::abi::{FnType, ArgType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -153,16 +153,12 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n \n fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n     if is_reg_ty(ret.ty) {\n-        if ret.ty == Type::i1(ccx) {\n-            ret.attr = Some(Attribute::ZExt);\n-        }\n         return;\n     }\n \n     // The PowerPC64 big endian ABI doesn't return aggregates in registers\n     if ccx.sess().target.target.target_endian == \"big\" {\n         ret.kind = Indirect;\n-        ret.attr = Some(Attribute::StructRet);\n     }\n \n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n@@ -187,14 +183,10 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n     }\n \n     ret.kind = Indirect;\n-    ret.attr = Some(Attribute::StructRet);\n }\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n     if is_reg_ty(arg.ty) {\n-        if arg.ty == Type::i1(ccx) {\n-            arg.attr = Some(Attribute::ZExt);\n-        }\n         return;\n     }\n "}, {"sha": "fd1b8b21401a12f0952a944097dfa314f5d69410", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -30,17 +30,11 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n                 2 => fty.ret.cast = Some(Type::i16(ccx)),\n                 4 => fty.ret.cast = Some(Type::i32(ccx)),\n                 8 => fty.ret.cast = Some(Type::i64(ccx)),\n-                _ => {\n-                    fty.ret.kind = Indirect;\n-                    fty.ret.attr = Some(Attribute::StructRet);\n-                }\n+                _ => fty.ret.kind = Indirect\n             }\n         } else {\n             fty.ret.kind = Indirect;\n-            fty.ret.attr = Some(Attribute::StructRet);\n         }\n-    } else if fty.ret.ty == Type::i1(ccx) {\n-        fty.ret.attr = Some(Attribute::ZExt);\n     }\n \n     for arg in &mut fty.args {\n@@ -51,8 +45,6 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n                 arg.kind = Indirect;\n                 arg.attr = Some(Attribute::ByVal);\n             }\n-        } else if arg.ty == Type::i1(ccx) {\n-            arg.attr = Some(Attribute::ZExt);\n         }\n     }\n }"}, {"sha": "ab32ca206fc6ac290aee02d5b19bcf9066348980", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -387,21 +387,17 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     fn x86_64_ty<F>(ccx: &CrateContext,\n                     arg: &mut ArgType,\n                     is_mem_cls: F,\n-                    ind_attr: Attribute)\n+                    ind_attr: Option<Attribute>)\n         where F: FnOnce(&[RegClass]) -> bool\n     {\n         if !arg.ty.is_reg_ty() {\n             let cls = classify_ty(arg.ty);\n             if is_mem_cls(&cls) {\n                 arg.kind = Indirect;\n-                arg.attr = Some(ind_attr);\n+                arg.attr = ind_attr;\n             } else {\n                 arg.cast = Some(llreg_ty(ccx, &cls));\n             }\n-        } else {\n-            if arg.ty == Type::i1(ccx) {\n-                arg.attr = Some(Attribute::ZExt);\n-            }\n         }\n     }\n \n@@ -417,7 +413,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n             } else {\n                 false\n             }\n-        }, Attribute::StructRet);\n+        }, None);\n     }\n \n     for arg in &mut fty.args {\n@@ -436,7 +432,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n                 sse_regs -= needed_sse;\n             }\n             in_mem\n-        }, Attribute::ByVal);\n+        }, Some(Attribute::ByVal));\n \n         // An integer, pointer, double or float parameter\n         // thus the above closure passed to `x86_64_ty` won't"}, {"sha": "e9a06fd8d6b82802f5bbbe5e751a86bd21468f54", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -17,27 +17,22 @@ use trans::type_::Type;\n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    let fixup = |a: &mut ArgType, indirect_attr| {\n+    let fixup = |a: &mut ArgType| {\n         if a.ty.kind() == Struct {\n             match llsize_of_alloc(ccx, a.ty) {\n                 1 => a.cast = Some(Type::i8(ccx)),\n                 2 => a.cast = Some(Type::i16(ccx)),\n                 4 => a.cast = Some(Type::i32(ccx)),\n                 8 => a.cast = Some(Type::i64(ccx)),\n-                _ => {\n-                    a.kind = Indirect;\n-                    a.attr = indirect_attr;\n-                }\n+                _ => a.kind = Indirect\n             }\n-        } else if a.ty == Type::i1(ccx) {\n-            a.attr = Some(Attribute::ZExt);\n         }\n     };\n \n     if fty.ret.ty != Type::void(ccx) {\n-        fixup(&mut fty.ret, Some(Attribute::StructRet));\n+        fixup(&mut fty.ret);\n     }\n     for arg in &mut fty.args {\n-        fixup(arg, None);\n+        fixup(arg);\n     }\n }"}, {"sha": "f7bc22a44824a678efec10ead5a6a6dccd98d985", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -103,17 +103,20 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n     let fty = FnType::new(ccx, f.abi, &sig, &[]);\n-    let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.to_llvm(ccx));\n+    let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.llvm_type(ccx));\n \n     if sig.output == ty::FnDiverging {\n         llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n     }\n \n-    if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n-        attributes::from_fn_type(ccx, fn_type).apply_llfn(llfn);\n+    let attrs = if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n+        attributes::from_fn_type(ccx, fn_type)\n     } else {\n-        fty.add_attributes(llfn);\n-    }\n+        attributes::unwind(llfn, false);\n+        fty.llvm_attrs(ccx)\n+    };\n+\n+    attrs.apply_llfn(llfn);\n \n     llfn\n }"}, {"sha": "870853af1ee290424313fd329d96d764829bac00", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -247,47 +247,13 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // A function pointer is called without the declaration available, so we have to apply\n     // any attributes with ABI implications directly to the call instruction.\n-    let mut attrs = llvm::AttrBuilder::new();\n \n-    // Add attributes that are always applicable, independent of the concrete foreign ABI\n-    if fn_type.ret.is_indirect() {\n-        let llret_sz = machine::llsize_of_real(ccx, fn_type.ret.ty);\n-\n-        // The outptr can be noalias and nocapture because it's entirely\n-        // invisible to the program. We also know it's nonnull as well\n-        // as how many bytes we can dereference\n-        attrs.arg(1, llvm::Attribute::NoAlias)\n-             .arg(1, llvm::Attribute::NoCapture)\n-             .arg(1, llvm::DereferenceableAttribute(llret_sz));\n-    };\n-\n-    // Add attributes that depend on the concrete foreign ABI\n-    let mut arg_idx = if fn_type.ret.is_indirect() { 1 } else { 0 };\n-    match fn_type.ret.attr {\n-        Some(attr) => { attrs.arg(arg_idx, attr); },\n-        _ => ()\n-    }\n-\n-    arg_idx += 1;\n-    for arg_ty in &fn_type.args {\n-        if arg_ty.is_ignore() {\n-            continue;\n-        }\n-        // skip padding\n-        if arg_ty.pad.is_some() { arg_idx += 1; }\n-\n-        if let Some(attr) = arg_ty.attr {\n-            attrs.arg(arg_idx, attr);\n-        }\n-\n-        arg_idx += 1;\n-    }\n \n     let llforeign_retval = CallWithConv(bcx,\n                                         llfn,\n                                         &llargs_foreign[..],\n                                         fn_type.cconv,\n-                                        Some(attrs),\n+                                        Some(fn_type.llvm_attrs(ccx)),\n                                         call_debug_loc);\n \n     // If the function we just called does not use an outpointer,"}, {"sha": "634d33d445ed107c6adecf90ca879d557d820cda", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492d09f31699ff2ef1cda9da71ab3f1910a649f/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=d492d09f31699ff2ef1cda9da71ab3f1910a649f", "patch": "@@ -322,7 +322,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyFnPtr(f) => {\n         let sig = cx.tcx().erase_late_bound_regions(&f.sig);\n         let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n-        FnType::new(cx, f.abi, &sig, &[]).to_llvm(cx).ptr_to()\n+        FnType::new(cx, f.abi, &sig, &[]).llvm_type(cx).ptr_to()\n       }\n       ty::TyTuple(ref tys) if tys.is_empty() => Type::nil(cx),\n       ty::TyTuple(..) => {"}]}