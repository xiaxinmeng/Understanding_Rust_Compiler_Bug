{"sha": "8f3b0ecf31100c0912d42e9fbe0430f0ca0251bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmM2IwZWNmMzExMDBjMDkxMmQ0MmU5ZmJlMDQzMGYwY2EwMjUxYmM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-16T18:18:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-16T18:18:59Z"}, "message": "Rollup merge of #74391 - ssomers:btree_refactor, r=Mark-Simulacrum\n\nBtreeMap: superficially refactor root access\n\nRemove or comment every unwrap in BTreeMap's main code and more.\n\nr? @Mark-Simulacrum", "tree": {"sha": "d4dbe296916e96d1b01dc53307830ba409f0789c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4dbe296916e96d1b01dc53307830ba409f0789c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f3b0ecf31100c0912d42e9fbe0430f0ca0251bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfEJoTCRBK7hj4Ov3rIwAAdHIIAKpa5sYT7bRQP4ryB/QPCG/2\nDp4YeU7YNQonU5iUvdVQSIeGLiric0Id5rtMusPjSiihrvR0A8qeP50kE23sYcXx\nvgXooWZsTZ/5ylTUjIl5EIAIV9c1dI/zsOBu85O7FDg/L9jO2by0Bg/icQm/FMfI\nbShcvFnSN94B0IUYor/vCXbx/StbsgR5nkh78bg8JWW/B8qCub11r4iMl9iKigsb\nd+jxQlbEYzSfheW4NVZYYiSmGBCzPNs/Gduz7wnvma0aL7SKrD9C7dXcqcvM8FXJ\nncLtgEv7/qGBbxnDRpa+Dvyn1o0l8CMIxRb0cWzSgxpAUD7TGxlT6Z2Uub1+AdE=\n=CfJU\n-----END PGP SIGNATURE-----\n", "payload": "tree d4dbe296916e96d1b01dc53307830ba409f0789c\nparent f821109ee2662cf152acb6bb3257ff0f0a158711\nparent b82d332c52dde1680b21c0281f08cc5f30edc082\nauthor Manish Goregaokar <manishsmail@gmail.com> 1594923539 -0700\ncommitter GitHub <noreply@github.com> 1594923539 -0700\n\nRollup merge of #74391 - ssomers:btree_refactor, r=Mark-Simulacrum\n\nBtreeMap: superficially refactor root access\n\nRemove or comment every unwrap in BTreeMap's main code and more.\n\nr? @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f3b0ecf31100c0912d42e9fbe0430f0ca0251bc", "html_url": "https://github.com/rust-lang/rust/commit/8f3b0ecf31100c0912d42e9fbe0430f0ca0251bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f3b0ecf31100c0912d42e9fbe0430f0ca0251bc/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f821109ee2662cf152acb6bb3257ff0f0a158711", "url": "https://api.github.com/repos/rust-lang/rust/commits/f821109ee2662cf152acb6bb3257ff0f0a158711", "html_url": "https://github.com/rust-lang/rust/commit/f821109ee2662cf152acb6bb3257ff0f0a158711"}, {"sha": "b82d332c52dde1680b21c0281f08cc5f30edc082", "url": "https://api.github.com/repos/rust-lang/rust/commits/b82d332c52dde1680b21c0281f08cc5f30edc082", "html_url": "https://github.com/rust-lang/rust/commit/b82d332c52dde1680b21c0281f08cc5f30edc082"}], "stats": {"total": 180, "additions": 88, "deletions": 92}, "files": [{"sha": "bf5748739d470422e0d110770812baf6bc9a1bbc", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 83, "deletions": 92, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/8f3b0ecf31100c0912d42e9fbe0430f0ca0251bc/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3b0ecf31100c0912d42e9fbe0430f0ca0251bc/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=8f3b0ecf31100c0912d42e9fbe0430f0ca0251bc", "patch": "@@ -151,7 +151,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                     let mut out_tree = BTreeMap { root: Some(node::Root::new_leaf()), length: 0 };\n \n                     {\n-                        let root = out_tree.root.as_mut().unwrap();\n+                        let root = out_tree.root.as_mut().unwrap(); // unwrap succeeds because we just wrapped\n                         let mut out_node = match root.as_mut().force() {\n                             Leaf(leaf) => leaf,\n                             Internal(_) => unreachable!(),\n@@ -171,14 +171,10 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                 }\n                 Internal(internal) => {\n                     let mut out_tree = clone_subtree(internal.first_edge().descend());\n-                    out_tree.ensure_root_is_owned();\n \n                     {\n-                        // Ideally we'd use the return of ensure_root_is_owned\n-                        // instead of re-unwrapping here but unfortunately that\n-                        // borrows all of out_tree and we need access to the\n-                        // length below.\n-                        let mut out_node = out_tree.root.as_mut().unwrap().push_level();\n+                        let out_root = BTreeMap::ensure_is_owned(&mut out_tree.root);\n+                        let mut out_node = out_root.push_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n@@ -212,7 +208,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             // Ord` constraint, which this method lacks.\n             BTreeMap { root: None, length: 0 }\n         } else {\n-            clone_subtree(self.root.as_ref().unwrap().as_ref())\n+            clone_subtree(self.root.as_ref().unwrap().as_ref()) // unwrap succeeds because not empty\n         }\n     }\n }\n@@ -243,8 +239,8 @@ where\n     }\n \n     fn replace(&mut self, key: K) -> Option<K> {\n-        self.ensure_root_is_owned();\n-        match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut()?.as_mut(), &key) {\n+        let root = Self::ensure_is_owned(&mut self.root);\n+        match search::search_tree::<marker::Mut<'_>, K, (), K>(root.as_mut(), &key) {\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n                 VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData }\n@@ -943,7 +939,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         // Second, we build a tree from the sorted sequence in linear time.\n         self.from_sorted_iter(iter);\n-        self.fix_right_edge();\n     }\n \n     /// Constructs a double-ended iterator over a sub-range of elements in the map.\n@@ -1058,8 +1053,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n-        self.ensure_root_is_owned();\n-        match search::search_tree(self.root.as_mut().unwrap().as_mut(), &key) {\n+        let root = Self::ensure_is_owned(&mut self.root);\n+        match search::search_tree(root.as_mut(), &key) {\n             Found(handle) => {\n                 Occupied(OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData })\n             }\n@@ -1070,8 +1065,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n-        self.ensure_root_is_owned();\n-        let mut cur_node = self.root.as_mut().unwrap().as_mut().last_leaf_edge().into_node();\n+        let root = Self::ensure_is_owned(&mut self.root);\n+        let mut cur_node = root.as_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -1116,11 +1111,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n             self.length += 1;\n         }\n+        Self::fix_right_edge(root)\n     }\n \n-    fn fix_right_edge(&mut self) {\n+    fn fix_right_edge(root: &mut node::Root<K, V>) {\n         // Handle underfull nodes, start from the top.\n-        let mut cur_node = self.root.as_mut().unwrap().as_mut();\n+        let mut cur_node = root.as_mut();\n         while let Internal(internal) = cur_node.force() {\n             // Check if right-most child is underfull.\n             let mut last_edge = internal.last_edge();\n@@ -1179,16 +1175,17 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n \n         let total_num = self.len();\n+        let left_root = self.root.as_mut().unwrap(); // unwrap succeeds because not empty\n \n         let mut right = Self::new();\n-        let right_root = right.ensure_root_is_owned();\n-        for _ in 0..(self.root.as_ref().unwrap().as_ref().height()) {\n+        let right_root = Self::ensure_is_owned(&mut right.root);\n+        for _ in 0..left_root.height() {\n             right_root.push_level();\n         }\n \n         {\n-            let mut left_node = self.root.as_mut().unwrap().as_mut();\n-            let mut right_node = right.root.as_mut().unwrap().as_mut();\n+            let mut left_node = left_root.as_mut();\n+            let mut right_node = right_root.as_mut();\n \n             loop {\n                 let mut split_edge = match search::search_node(left_node, key) {\n@@ -1214,12 +1211,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             }\n         }\n \n-        self.fix_right_border();\n-        right.fix_left_border();\n+        left_root.fix_right_border();\n+        right_root.fix_left_border();\n \n-        if self.root.as_ref().unwrap().as_ref().height()\n-            < right.root.as_ref().unwrap().as_ref().height()\n-        {\n+        if left_root.height() < right_root.height() {\n             self.recalc_length();\n             right.length = total_num - self.len();\n         } else {\n@@ -1301,69 +1296,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         self.length = dfs(self.root.as_ref().unwrap().as_ref());\n     }\n-\n-    /// Removes empty levels on the top.\n-    fn fix_top(&mut self) {\n-        loop {\n-            {\n-                let node = self.root.as_ref().unwrap().as_ref();\n-                if node.height() == 0 || node.len() > 0 {\n-                    break;\n-                }\n-            }\n-            self.root.as_mut().unwrap().pop_level();\n-        }\n-    }\n-\n-    fn fix_right_border(&mut self) {\n-        self.fix_top();\n-\n-        {\n-            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n-\n-            while let Internal(node) = cur_node.force() {\n-                let mut last_kv = node.last_kv();\n-\n-                if last_kv.can_merge() {\n-                    cur_node = last_kv.merge().descend();\n-                } else {\n-                    let right_len = last_kv.reborrow().right_edge().descend().len();\n-                    // `MINLEN + 1` to avoid readjust if merge happens on the next level.\n-                    if right_len < node::MIN_LEN + 1 {\n-                        last_kv.bulk_steal_left(node::MIN_LEN + 1 - right_len);\n-                    }\n-                    cur_node = last_kv.right_edge().descend();\n-                }\n-            }\n-        }\n-\n-        self.fix_top();\n-    }\n-\n-    /// The symmetric clone of `fix_right_border`.\n-    fn fix_left_border(&mut self) {\n-        self.fix_top();\n-\n-        {\n-            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n-\n-            while let Internal(node) = cur_node.force() {\n-                let mut first_kv = node.first_kv();\n-\n-                if first_kv.can_merge() {\n-                    cur_node = first_kv.merge().descend();\n-                } else {\n-                    let left_len = first_kv.reborrow().left_edge().descend().len();\n-                    if left_len < node::MIN_LEN + 1 {\n-                        first_kv.bulk_steal_right(node::MIN_LEN + 1 - left_len);\n-                    }\n-                    cur_node = first_kv.left_edge().descend();\n-                }\n-            }\n-        }\n-\n-        self.fix_top();\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2321,9 +2253,9 @@ impl<K, V> BTreeMap<K, V> {\n     }\n \n     /// If the root node is the empty (non-allocated) root node, allocate our\n-    /// own node.\n-    fn ensure_root_is_owned(&mut self) -> &mut node::Root<K, V> {\n-        self.root.get_or_insert_with(node::Root::new_leaf)\n+    /// own node. Is an associated function to avoid borrowing the entire BTreeMap.\n+    fn ensure_is_owned(root: &mut Option<node::Root<K, V>>) -> &mut node::Root<K, V> {\n+        root.get_or_insert_with(node::Root::new_leaf)\n     }\n }\n \n@@ -2825,6 +2757,65 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n     }\n }\n \n+impl<K, V> node::Root<K, V> {\n+    /// Removes empty levels on the top, but keep an empty leaf if the entire tree is empty.\n+    fn fix_top(&mut self) {\n+        while self.height() > 0 && self.as_ref().len() == 0 {\n+            self.pop_level();\n+        }\n+    }\n+\n+    fn fix_right_border(&mut self) {\n+        self.fix_top();\n+\n+        {\n+            let mut cur_node = self.as_mut();\n+\n+            while let Internal(node) = cur_node.force() {\n+                let mut last_kv = node.last_kv();\n+\n+                if last_kv.can_merge() {\n+                    cur_node = last_kv.merge().descend();\n+                } else {\n+                    let right_len = last_kv.reborrow().right_edge().descend().len();\n+                    // `MINLEN + 1` to avoid readjust if merge happens on the next level.\n+                    if right_len < node::MIN_LEN + 1 {\n+                        last_kv.bulk_steal_left(node::MIN_LEN + 1 - right_len);\n+                    }\n+                    cur_node = last_kv.right_edge().descend();\n+                }\n+            }\n+        }\n+\n+        self.fix_top();\n+    }\n+\n+    /// The symmetric clone of `fix_right_border`.\n+    fn fix_left_border(&mut self) {\n+        self.fix_top();\n+\n+        {\n+            let mut cur_node = self.as_mut();\n+\n+            while let Internal(node) = cur_node.force() {\n+                let mut first_kv = node.first_kv();\n+\n+                if first_kv.can_merge() {\n+                    cur_node = first_kv.merge().descend();\n+                } else {\n+                    let left_len = first_kv.reborrow().left_edge().descend().len();\n+                    if left_len < node::MIN_LEN + 1 {\n+                        first_kv.bulk_steal_right(node::MIN_LEN + 1 - left_len);\n+                    }\n+                    cur_node = first_kv.left_edge().descend();\n+                }\n+            }\n+        }\n+\n+        self.fix_top();\n+    }\n+}\n+\n enum UnderflowResult<'a, K, V> {\n     AtRoot,\n     Merged(Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge>, bool, usize),"}, {"sha": "f7bd64608d63cd40205364fa604979009f141b21", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f3b0ecf31100c0912d42e9fbe0430f0ca0251bc/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3b0ecf31100c0912d42e9fbe0430f0ca0251bc/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=8f3b0ecf31100c0912d42e9fbe0430f0ca0251bc", "patch": "@@ -153,6 +153,11 @@ unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> {}\n unsafe impl<K: Send, V: Send> Send for Root<K, V> {}\n \n impl<K, V> Root<K, V> {\n+    /// Returns the number of levels below the root.\n+    pub fn height(&self) -> usize {\n+        self.height\n+    }\n+\n     /// Returns a new owned tree, with its own root node that is initially empty.\n     pub fn new_leaf() -> Self {\n         Root { node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })), height: 0 }"}]}