{"sha": "1ab7066e32ab482c70ea5c9bba7585eba275476a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhYjcwNjZlMzJhYjQ4MmM3MGVhNWM5YmJhNzU4NWViYTI3NTQ3NmE=", "commit": {"author": {"name": "Lenard Pratt", "email": "l3np27@gmail.com", "date": "2019-04-18T18:35:47Z"}, "committer": {"name": "Lenard Pratt", "email": "l3np27@gmail.com", "date": "2019-04-23T09:17:31Z"}, "message": "Introduced resolve_macro_call on resolver\n\nchanged to manual expansion\n\nfix for nested macros", "tree": {"sha": "a754785d91783b713e54b70058f2f16984d25074", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a754785d91783b713e54b70058f2f16984d25074"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ab7066e32ab482c70ea5c9bba7585eba275476a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ab7066e32ab482c70ea5c9bba7585eba275476a", "html_url": "https://github.com/rust-lang/rust/commit/1ab7066e32ab482c70ea5c9bba7585eba275476a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ab7066e32ab482c70ea5c9bba7585eba275476a/comments", "author": {"login": "Lapz", "id": 19998186, "node_id": "MDQ6VXNlcjE5OTk4MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/19998186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lapz", "html_url": "https://github.com/Lapz", "followers_url": "https://api.github.com/users/Lapz/followers", "following_url": "https://api.github.com/users/Lapz/following{/other_user}", "gists_url": "https://api.github.com/users/Lapz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lapz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lapz/subscriptions", "organizations_url": "https://api.github.com/users/Lapz/orgs", "repos_url": "https://api.github.com/users/Lapz/repos", "events_url": "https://api.github.com/users/Lapz/events{/privacy}", "received_events_url": "https://api.github.com/users/Lapz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Lapz", "id": 19998186, "node_id": "MDQ6VXNlcjE5OTk4MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/19998186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lapz", "html_url": "https://github.com/Lapz", "followers_url": "https://api.github.com/users/Lapz/followers", "following_url": "https://api.github.com/users/Lapz/following{/other_user}", "gists_url": "https://api.github.com/users/Lapz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lapz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lapz/subscriptions", "organizations_url": "https://api.github.com/users/Lapz/orgs", "repos_url": "https://api.github.com/users/Lapz/repos", "events_url": "https://api.github.com/users/Lapz/events{/privacy}", "received_events_url": "https://api.github.com/users/Lapz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce211434a6501e88cb83462f2443db085f1557d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce211434a6501e88cb83462f2443db085f1557d3", "html_url": "https://github.com/rust-lang/rust/commit/ce211434a6501e88cb83462f2443db085f1557d3"}], "stats": {"total": 171, "additions": 113, "deletions": 58}, "files": [{"sha": "9aafc8bd3358e83b2753077e881b2a401db39b38", "filename": ".vscode/launch.json", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ab7066e32ab482c70ea5c9bba7585eba275476a/.vscode%2Flaunch.json", "raw_url": "https://github.com/rust-lang/rust/raw/1ab7066e32ab482c70ea5c9bba7585eba275476a/.vscode%2Flaunch.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Flaunch.json?ref=1ab7066e32ab482c70ea5c9bba7585eba275476a", "patch": "@@ -14,9 +14,7 @@\n         \"--disable-extensions\"\n       ],\n       \"env\": {\n-        \"__RA_LSP_SERVER_DEBUG\": \"${workspaceFolder}/target/debug/ra_lsp_server\",\n-        \"RUST_LOG\" :\"ra_hir=debug\",\n-        \"RA_INTERNAL_MODE\":\"1\"\n+        \"__RA_LSP_SERVER_DEBUG\": \"${workspaceFolder}/target/debug/ra_lsp_server\"\n       },\n       \"outFiles\": [\"${workspaceFolder}/editors/code/out/**/*.js\"],\n       \"preLaunchTask\": \"Build All\""}, {"sha": "db74d28e8e4d3e3624dbbd257e3c31d5ba5a3e7f", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 55, "deletions": 49, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1ab7066e32ab482c70ea5c9bba7585eba275476a/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab7066e32ab482c70ea5c9bba7585eba275476a/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=1ab7066e32ab482c70ea5c9bba7585eba275476a", "patch": "@@ -5,14 +5,14 @@ use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_syntax::{\n-    SyntaxNodePtr, AstPtr, AstNode,\n+    SyntaxNodePtr, AstPtr, AstNode,TreeArc,\n     ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralKind,ArrayExprKind, TypeAscriptionOwner}\n };\n \n use crate::{\n     Path, Name, HirDatabase, Resolver,DefWithBody, Either,\n     name::AsName,\n-    ids::{MacroCallLoc,HirFileId},\n+    ids::{MacroCallId},\n     type_ref::{Mutability, TypeRef},\n };\n use crate::{path::GenericArgs, ty::primitive::{IntTy, UncertainIntTy, FloatTy, UncertainFloatTy}};\n@@ -488,23 +488,45 @@ pub(crate) struct ExprCollector<DB> {\n     params: Vec<PatId>,\n     body_expr: Option<ExprId>,\n     resolver: Resolver,\n+    // FIXEME: Its a quick hack,see issue #1196\n+    is_in_macro: bool,\n }\n \n impl<'a, DB> ExprCollector<&'a DB>\n where\n     DB: HirDatabase,\n {\n+    fn new(owner: DefWithBody, resolver: Resolver, db: &'a DB) -> Self {\n+        ExprCollector {\n+            owner,\n+            resolver,\n+            db,\n+            exprs: Arena::default(),\n+            pats: Arena::default(),\n+            source_map: BodySourceMap::default(),\n+            params: Vec::new(),\n+            body_expr: None,\n+            is_in_macro: false,\n+        }\n+    }\n     fn alloc_expr(&mut self, expr: Expr, syntax_ptr: SyntaxNodePtr) -> ExprId {\n         let id = self.exprs.alloc(expr);\n-        self.source_map.expr_map.insert(syntax_ptr, id);\n-        self.source_map.expr_map_back.insert(id, syntax_ptr);\n+        if !self.is_in_macro {\n+            self.source_map.expr_map.insert(syntax_ptr, id);\n+            self.source_map.expr_map_back.insert(id, syntax_ptr);\n+        }\n+\n         id\n     }\n \n     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n         let id = self.pats.alloc(pat);\n-        self.source_map.pat_map.insert(ptr, id);\n-        self.source_map.pat_map_back.insert(id, ptr);\n+\n+        if !self.is_in_macro {\n+            self.source_map.pat_map.insert(ptr, id);\n+            self.source_map.pat_map_back.insert(id, ptr);\n+        }\n+\n         id\n     }\n \n@@ -790,40 +812,19 @@ where\n             ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::MacroCall(e) => {\n-                // very hacky.TODO change to use the macro resolution\n-                let name = e\n-                    .path()\n-                    .and_then(Path::from_ast)\n-                    .and_then(|path| path.expand_macro_expr())\n-                    .unwrap_or_else(Name::missing);\n-\n-                if let Some(macro_id) = self.resolver.resolve_macro_call(&name) {\n-                    if let Some((module, _)) = self.resolver.module() {\n-                        // we do this to get the ast_id for the macro call\n-                        // if we used the ast_id from the macro_id variable\n-                        // it gives us the ast_id of the defenition site\n-                        let module = module.mk_module(module.root());\n-                        let hir_file_id = module.definition_source(self.db).0;\n-                        let ast_id =\n-                            self.db.ast_id_map(hir_file_id).ast_id(e).with_file_id(hir_file_id);\n-\n-                        let call_loc = MacroCallLoc { def: *macro_id, ast_id };\n-                        let call_id = call_loc.id(self.db);\n-                        let file_id: HirFileId = call_id.into();\n-\n-                        log::debug!(\n-                            \"expanded macro ast {}\",\n-                            self.db.hir_parse(file_id).syntax().debug_dump()\n-                        );\n-\n-                        self.db\n-                            .hir_parse(file_id)\n-                            .syntax()\n-                            .descendants()\n-                            .find_map(ast::Expr::cast)\n-                            .map(|expr| self.collect_expr(expr))\n-                            .unwrap_or(self.alloc_expr(Expr::Missing, syntax_ptr))\n+                // very hacky.FIXME change to use the macro resolution\n+                let path = e.path().and_then(Path::from_ast);\n+\n+                if let Some(call_id) = self.resolver.resolve_macro_call(self.db, path, e) {\n+                    if let Some(expr) = expand_macro_to_expr(self.db, call_id, e.token_tree()) {\n+                        log::debug!(\"macro expansion {}\", expr.syntax().debug_dump());\n+                        let old = std::mem::replace(&mut self.is_in_macro, true);\n+                        let id = self.collect_expr(&expr);\n+                        self.is_in_macro = old;\n+                        id\n                     } else {\n+                        // FIXME: Instead of just dropping the error from expansion\n+                        // report it\n                         self.alloc_expr(Expr::Missing, syntax_ptr)\n                     }\n                 } else {\n@@ -987,20 +988,25 @@ where\n     }\n }\n \n+fn expand_macro_to_expr(\n+    db: &impl HirDatabase,\n+    macro_call: MacroCallId,\n+    args: Option<&ast::TokenTree>,\n+) -> Option<TreeArc<ast::Expr>> {\n+    let rules = db.macro_def(macro_call.loc(db).def)?;\n+\n+    let args = mbe::ast_to_token_tree(args?)?.0;\n+\n+    let expanded = rules.expand(&args).ok()?;\n+\n+    mbe::token_tree_to_expr(&expanded).ok()\n+}\n+\n pub(crate) fn body_with_source_map_query(\n     db: &impl HirDatabase,\n     def: DefWithBody,\n ) -> (Arc<Body>, Arc<BodySourceMap>) {\n-    let mut collector = ExprCollector {\n-        db,\n-        owner: def,\n-        resolver: def.resolver(db),\n-        exprs: Arena::default(),\n-        pats: Arena::default(),\n-        source_map: BodySourceMap::default(),\n-        params: Vec::new(),\n-        body_expr: None,\n-    };\n+    let mut collector = ExprCollector::new(def, def.resolver(db), db);\n \n     match def {\n         DefWithBody::Const(ref c) => collector.collect_const_body(&c.source(db).1),"}, {"sha": "c7849c995b009ccf839cef94a1b7fea8b1070eba", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ab7066e32ab482c70ea5c9bba7585eba275476a/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab7066e32ab482c70ea5c9bba7585eba275476a/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=1ab7066e32ab482c70ea5c9bba7585eba275476a", "patch": "@@ -101,7 +101,7 @@ fn parse_macro(\n         return Err(format!(\"Total tokens count exceed limit : count = {}\", count));\n     }\n \n-    Some(mbe::token_tree_to_ast_item_list(&tt))\n+    Ok(mbe::token_tree_to_ast_item_list(&tt))\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "b34c9b8e69702a79a79e61f06debe712e016fbdb", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ab7066e32ab482c70ea5c9bba7585eba275476a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab7066e32ab482c70ea5c9bba7585eba275476a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=1ab7066e32ab482c70ea5c9bba7585eba275476a", "patch": "@@ -524,7 +524,7 @@ where\n         {\n             let macro_call_id = MacroCallLoc { def: *macro_id, ast_id }.id(self.def_collector.db);\n \n-            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_id);\n+            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, *macro_id);\n             return;\n         }\n \n@@ -616,6 +616,7 @@ mod tests {\n                 modules,\n                 public_macros: FxHashMap::default(),\n                 poison_macros: FxHashSet::default(),\n+                local_macros: FxHashMap::default(),\n                 diagnostics: Vec::new(),\n             }\n         };"}, {"sha": "d1f97c1047b3394cf1efbe483cedf3baffdc1346", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1ab7066e32ab482c70ea5c9bba7585eba275476a/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab7066e32ab482c70ea5c9bba7585eba275476a/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=1ab7066e32ab482c70ea5c9bba7585eba275476a", "patch": "@@ -1,12 +1,15 @@\n //! Name resolution.\n use std::sync::Arc;\n \n+use ra_syntax::ast;\n+\n use rustc_hash::FxHashMap;\n \n use crate::{\n     ModuleDef,\n     code_model_api::Crate,\n-    MacroDefId,\n+    MacroCallId,\n+    MacroCallLoc,\n     db::HirDatabase,\n     name::{Name, KnownName},\n     nameres::{PerNs, CrateDefMap, CrateModuleId},\n@@ -131,8 +134,29 @@ impl Resolver {\n         resolution\n     }\n \n-    pub fn resolve_macro_call(&self, name: &Name) -> Option<&MacroDefId> {\n-        self.module().and_then(|(module, _)| module.find_macro(name))\n+    pub fn resolve_macro_call(\n+        &self,\n+        db: &impl HirDatabase,\n+        path: Option<Path>,\n+        call: &ast::MacroCall,\n+    ) -> Option<MacroCallId> {\n+        let name = path.and_then(|path| path.expand_macro_expr()).unwrap_or_else(Name::missing);\n+        let macro_def_id = self.module().and_then(|(module, _)| module.find_macro(&name));\n+        if let Some(def_id) = macro_def_id {\n+            self.module().and_then(|(module, _)| {\n+                // we do this to get the ast_id for the macro call\n+                // if we used the ast_id from the def_id variable\n+                // it gives us the ast_id of the defenition site\n+                let module = module.mk_module(module.root());\n+                let hir_file_id = module.definition_source(db).0;\n+                let ast_id = db.ast_id_map(hir_file_id).ast_id(call).with_file_id(hir_file_id);\n+                let call_loc = MacroCallLoc { def: *def_id, ast_id }.id(db);\n+\n+                Some(call_loc)\n+            })\n+        } else {\n+            None\n+        }\n     }\n \n     /// Returns the resolved path segments\n@@ -197,7 +221,7 @@ impl Resolver {\n             .flatten()\n     }\n \n-    pub(crate) fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n+    fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),\n "}, {"sha": "c76a5012f07ee108ddf5d054cb83cc29aeb1d198", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1ab7066e32ab482c70ea5c9bba7585eba275476a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab7066e32ab482c70ea5c9bba7585eba275476a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=1ab7066e32ab482c70ea5c9bba7585eba275476a", "patch": "@@ -2417,6 +2417,30 @@ fn test() -> u64 {\n     );\n }\n \n+#[test]\n+fn infer_macros_expanded() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+struct Foo(Vec<i32>);\n+\n+macro_rules! foo {\n+    ($($item:expr),*) => {\n+            {\n+                Foo(vec![$($item,)*])\n+            }\n+    };\n+}\n+\n+fn main() {\n+    let x = foo!(1,2);\n+}\n+\"#),\n+        @r###\"\n+[156; 182) '{     ...,2); }': ()\n+[166; 167) 'x': Foo\"###\n+    );\n+}\n+\n #[ignore]\n #[test]\n fn method_resolution_trait_before_autoref() {\n@@ -2510,6 +2534,7 @@ fn type_at(content: &str) -> String {\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.parse(file_id);\n+\n     let mut acc = String::new();\n     acc.push_str(\"\\n\");\n \n@@ -2532,6 +2557,7 @@ fn infer(content: &str) -> String {\n             };\n             types.push((syntax_ptr, ty));\n         }\n+\n         // sort ranges for consistency\n         types.sort_by_key(|(ptr, _)| (ptr.range().start(), ptr.range().end()));\n         for (syntax_ptr, ty) in &types {"}]}