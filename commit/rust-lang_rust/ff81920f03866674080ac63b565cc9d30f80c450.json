{"sha": "ff81920f03866674080ac63b565cc9d30f80c450", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmODE5MjBmMDM4NjY2NzQwODBhYzYzYjU2NWNjOWQzMGY4MGM0NTA=", "commit": {"author": {"name": "Cesar Eduardo Barros", "email": "cesarb@cesarb.eti.br", "date": "2015-07-20T03:23:37Z"}, "committer": {"name": "Cesar Eduardo Barros", "email": "cesarb@cesarb.eti.br", "date": "2015-08-24T22:10:08Z"}, "message": "Implement read_exact for the Read trait\n\nThis implements the proposed \"read_exact\" RFC\n(https://github.com/rust-lang/rfcs/pull/980).", "tree": {"sha": "9619a464863630730373297a9a35e7bccba94fcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9619a464863630730373297a9a35e7bccba94fcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff81920f03866674080ac63b565cc9d30f80c450", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff81920f03866674080ac63b565cc9d30f80c450", "html_url": "https://github.com/rust-lang/rust/commit/ff81920f03866674080ac63b565cc9d30f80c450", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff81920f03866674080ac63b565cc9d30f80c450/comments", "author": {"login": "cesarb", "id": 31324, "node_id": "MDQ6VXNlcjMxMzI0", "avatar_url": "https://avatars.githubusercontent.com/u/31324?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cesarb", "html_url": "https://github.com/cesarb", "followers_url": "https://api.github.com/users/cesarb/followers", "following_url": "https://api.github.com/users/cesarb/following{/other_user}", "gists_url": "https://api.github.com/users/cesarb/gists{/gist_id}", "starred_url": "https://api.github.com/users/cesarb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cesarb/subscriptions", "organizations_url": "https://api.github.com/users/cesarb/orgs", "repos_url": "https://api.github.com/users/cesarb/repos", "events_url": "https://api.github.com/users/cesarb/events{/privacy}", "received_events_url": "https://api.github.com/users/cesarb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cesarb", "id": 31324, "node_id": "MDQ6VXNlcjMxMzI0", "avatar_url": "https://avatars.githubusercontent.com/u/31324?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cesarb", "html_url": "https://github.com/cesarb", "followers_url": "https://api.github.com/users/cesarb/followers", "following_url": "https://api.github.com/users/cesarb/following{/other_user}", "gists_url": "https://api.github.com/users/cesarb/gists{/gist_id}", "starred_url": "https://api.github.com/users/cesarb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cesarb/subscriptions", "organizations_url": "https://api.github.com/users/cesarb/orgs", "repos_url": "https://api.github.com/users/cesarb/repos", "events_url": "https://api.github.com/users/cesarb/events{/privacy}", "received_events_url": "https://api.github.com/users/cesarb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef04b07239d75f2b6bb66f18855f3af695d76e1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef04b07239d75f2b6bb66f18855f3af695d76e1c", "html_url": "https://github.com/rust-lang/rust/commit/ef04b07239d75f2b6bb66f18855f3af695d76e1c"}], "stats": {"total": 140, "additions": 140, "deletions": 0}, "files": [{"sha": "d55721db12617271304ab810c155542a2035e207", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff81920f03866674080ac63b565cc9d30f80c450/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff81920f03866674080ac63b565cc9d30f80c450/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=ff81920f03866674080ac63b565cc9d30f80c450", "patch": "@@ -147,6 +147,15 @@ pub enum ErrorKind {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Other,\n \n+    /// An error returned when an operation could not be completed because an\n+    /// \"end of file\" was reached prematurely.\n+    ///\n+    /// This typically means that an operation could only succeed if it read a\n+    /// particular number of bytes but only a smaller number of bytes could be\n+    /// read.\n+    #[unstable(feature = \"read_exact\", reason = \"recently added\")]\n+    UnexpectedEOF,\n+\n     /// Any I/O error not part of this list.\n     #[unstable(feature = \"io_error_internals\",\n                reason = \"better expressed through extensible enums that this \\"}, {"sha": "4d9edfbefef0c400eab3252e7af3e8c55ec73ae2", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ff81920f03866674080ac63b565cc9d30f80c450/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff81920f03866674080ac63b565cc9d30f80c450/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=ff81920f03866674080ac63b565cc9d30f80c450", "patch": "@@ -38,6 +38,11 @@ impl<'a, R: Read + ?Sized> Read for &'a mut R {\n     fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n         (**self).read_to_string(buf)\n     }\n+\n+    #[inline]\n+    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n+        (**self).read_exact(buf)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, W: Write + ?Sized> Write for &'a mut W {\n@@ -97,6 +102,11 @@ impl<R: Read + ?Sized> Read for Box<R> {\n     fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n         (**self).read_to_string(buf)\n     }\n+\n+    #[inline]\n+    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n+        (**self).read_exact(buf)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write + ?Sized> Write for Box<W> {\n@@ -153,6 +163,17 @@ impl<'a> Read for &'a [u8] {\n         *self = b;\n         Ok(amt)\n     }\n+\n+    #[inline]\n+    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n+        if buf.len() > self.len() {\n+            return Err(Error::new(ErrorKind::UnexpectedEOF, \"failed to fill whole buffer\"));\n+        }\n+        let (a, b) = self.split_at(buf.len());\n+        slice::bytes::copy_memory(a, buf);\n+        *self = b;\n+        Ok(())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "d2b8b40ca5cc5a644f77a73fd06f0478074b5d3d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ff81920f03866674080ac63b565cc9d30f80c450/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff81920f03866674080ac63b565cc9d30f80c450/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=ff81920f03866674080ac63b565cc9d30f80c450", "patch": "@@ -315,6 +315,72 @@ pub trait Read {\n         append_to_string(buf, |b| read_to_end(self, b))\n     }\n \n+    /// Read the exact number of bytes required to fill `buf`.\n+    ///\n+    /// This function reads as many bytes as necessary to completely fill the\n+    /// specified buffer `buf`.\n+    ///\n+    /// No guarantees are provided about the contents of `buf` when this\n+    /// function is called, implementations cannot rely on any property of the\n+    /// contents of `buf` being true. It is recommended that implementations\n+    /// only write data to `buf` instead of reading its contents.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters an error of the kind\n+    /// `ErrorKind::Interrupted` then the error is ignored and the operation\n+    /// will continue.\n+    ///\n+    /// If this function encounters an \"end of file\" before completely filling\n+    /// the buffer, it returns an error of the kind `ErrorKind::UnexpectedEOF`.\n+    /// The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If any other read error is encountered then this function immediately\n+    /// returns. The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If this function returns an error, it is unspecified how many bytes it\n+    /// has read, but it will never read more than would be necessary to\n+    /// completely fill the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// #![feature(read_exact)]\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = [0; 10];\n+    ///\n+    /// // read exactly 10 bytes\n+    /// try!(f.read_exact(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    #[unstable(feature = \"read_exact\", reason = \"recently added\")]\n+    fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<()> {\n+        while !buf.is_empty() {\n+            match self.read(buf) {\n+                Ok(0) => break,\n+                Ok(n) => { let tmp = buf; buf = &mut tmp[n..]; }\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        if !buf.is_empty() {\n+            Err(Error::new(ErrorKind::UnexpectedEOF,\n+                           \"failed to fill whole buffer\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Creates a \"by reference\" adaptor for this instance of `Read`.\n     ///\n     /// The returned adaptor also implements `Read` and will simply borrow this\n@@ -1556,6 +1622,47 @@ mod tests {\n         assert!(c.read_to_string(&mut v).is_err());\n     }\n \n+    #[test]\n+    fn read_exact() {\n+        let mut buf = [0; 4];\n+\n+        let mut c = Cursor::new(&b\"\"[..]);\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n+                   io::ErrorKind::UnexpectedEOF);\n+\n+        let mut c = Cursor::new(&b\"123\"[..]).chain(Cursor::new(&b\"456789\"[..]));\n+        c.read_exact(&mut buf).unwrap();\n+        assert_eq!(&buf, b\"1234\");\n+        c.read_exact(&mut buf).unwrap();\n+        assert_eq!(&buf, b\"5678\");\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n+                   io::ErrorKind::UnexpectedEOF);\n+    }\n+\n+    #[test]\n+    fn read_exact_slice() {\n+        let mut buf = [0; 4];\n+\n+        let mut c = &b\"\"[..];\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n+                   io::ErrorKind::UnexpectedEOF);\n+\n+        let mut c = &b\"123\"[..];\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n+                   io::ErrorKind::UnexpectedEOF);\n+        // make sure the optimized (early returning) method is being used\n+        assert_eq!(&buf, &[0; 4]);\n+\n+        let mut c = &b\"1234\"[..];\n+        c.read_exact(&mut buf).unwrap();\n+        assert_eq!(&buf, b\"1234\");\n+\n+        let mut c = &b\"56789\"[..];\n+        c.read_exact(&mut buf).unwrap();\n+        assert_eq!(&buf, b\"5678\");\n+        assert_eq!(c, b\"9\");\n+    }\n+\n     #[test]\n     fn take_eof() {\n         struct R;"}, {"sha": "88f40d764e23e6de6ff61f369af2347674dfd37a", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff81920f03866674080ac63b565cc9d30f80c450/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff81920f03866674080ac63b565cc9d30f80c450/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=ff81920f03866674080ac63b565cc9d30f80c450", "patch": "@@ -271,6 +271,9 @@ impl Read for Stdin {\n     fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n         self.lock().read_to_string(buf)\n     }\n+    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n+        self.lock().read_exact(buf)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}