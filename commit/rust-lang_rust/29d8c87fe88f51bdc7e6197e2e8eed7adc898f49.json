{"sha": "29d8c87fe88f51bdc7e6197e2e8eed7adc898f49", "node_id": "C_kwDOAAsO6NoAKDI5ZDhjODdmZTg4ZjUxYmRjN2U2MTk3ZTJlOGVlZDdhZGM4OThmNDk", "commit": {"author": {"name": "Jhonny Bill Mena", "email": "jhonnybillm@gmail.com", "date": "2022-11-27T01:28:01Z"}, "committer": {"name": "Jhonny Bill Mena", "email": "jhonnybillm@gmail.com", "date": "2022-12-28T01:59:22Z"}, "message": "DELETE - fn span_invalid_monomorphization_error and localize intrinsics macros", "tree": {"sha": "5086fa91c2c1254f4fc7bf149152e220307f338c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5086fa91c2c1254f4fc7bf149152e220307f338c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49", "html_url": "https://github.com/rust-lang/rust/commit/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49/comments", "author": {"login": "JhonnyBillM", "id": 18747072, "node_id": "MDQ6VXNlcjE4NzQ3MDcy", "avatar_url": "https://avatars.githubusercontent.com/u/18747072?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JhonnyBillM", "html_url": "https://github.com/JhonnyBillM", "followers_url": "https://api.github.com/users/JhonnyBillM/followers", "following_url": "https://api.github.com/users/JhonnyBillM/following{/other_user}", "gists_url": "https://api.github.com/users/JhonnyBillM/gists{/gist_id}", "starred_url": "https://api.github.com/users/JhonnyBillM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JhonnyBillM/subscriptions", "organizations_url": "https://api.github.com/users/JhonnyBillM/orgs", "repos_url": "https://api.github.com/users/JhonnyBillM/repos", "events_url": "https://api.github.com/users/JhonnyBillM/events{/privacy}", "received_events_url": "https://api.github.com/users/JhonnyBillM/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JhonnyBillM", "id": 18747072, "node_id": "MDQ6VXNlcjE4NzQ3MDcy", "avatar_url": "https://avatars.githubusercontent.com/u/18747072?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JhonnyBillM", "html_url": "https://github.com/JhonnyBillM", "followers_url": "https://api.github.com/users/JhonnyBillM/followers", "following_url": "https://api.github.com/users/JhonnyBillM/following{/other_user}", "gists_url": "https://api.github.com/users/JhonnyBillM/gists{/gist_id}", "starred_url": "https://api.github.com/users/JhonnyBillM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JhonnyBillM/subscriptions", "organizations_url": "https://api.github.com/users/JhonnyBillM/orgs", "repos_url": "https://api.github.com/users/JhonnyBillM/repos", "events_url": "https://api.github.com/users/JhonnyBillM/events{/privacy}", "received_events_url": "https://api.github.com/users/JhonnyBillM/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27744460e2d0b960a55a28637ba46835484e4335", "url": "https://api.github.com/repos/rust-lang/rust/commits/27744460e2d0b960a55a28637ba46835484e4335", "html_url": "https://github.com/rust-lang/rust/commit/27744460e2d0b960a55a28637ba46835484e4335"}], "stats": {"total": 923, "additions": 670, "deletions": 253}, "files": [{"sha": "680d810f78eb9b4121e98955f6cbad23629f52a3", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 282, "deletions": 247, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=29d8c87fe88f51bdc7e6197e2e8eed7adc898f49", "patch": "@@ -8,9 +8,8 @@ use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n use rustc_codegen_ssa::base::{compare_simd_types, wants_msvc_seh};\n-use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n-use rustc_codegen_ssa::errors::InvalidMonomorphization;\n+use rustc_codegen_ssa::errors::{ExpectedPointerMutability, InvalidMonomorphization};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n@@ -835,40 +834,24 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     llret_ty: &'ll Type,\n     span: Span,\n ) -> Result<&'ll Value, ()> {\n-    // macros for error handling:\n-    #[allow(unused_macro_rules)]\n-    macro_rules! emit_error {\n-        ($msg: tt) => {\n-            emit_error!($msg, )\n-        };\n-        ($msg: tt, $($fmt: tt)*) => {\n-            span_invalid_monomorphization_error(\n-                bx.sess(), span,\n-                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                         name, $($fmt)*));\n-        }\n-    }\n-\n     macro_rules! return_error {\n-        ($($fmt: tt)*) => {\n-            {\n-                emit_error!($($fmt)*);\n-                return Err(());\n-            }\n-        }\n+        ($diag: expr) => {{\n+            bx.sess().emit_err($diag);\n+            return Err(());\n+        }};\n     }\n \n     macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n+        ($cond: expr, $diag: expr) => {\n             if !$cond {\n-                return_error!($($fmt)*);\n+                return_error!($diag);\n             }\n         };\n     }\n \n     macro_rules! require_simd {\n-        ($ty: expr, $position: expr) => {\n-            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+        ($ty: expr, $diag: expr) => {\n+            require!($ty.is_simd(), $diag)\n         };\n     }\n \n@@ -878,7 +861,11 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     let arg_tys = sig.inputs();\n \n     if name == sym::simd_select_bitmask {\n-        require_simd!(arg_tys[1], \"argument\");\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdArgument { span, name, ty: arg_tys[1] }\n+        );\n+\n         let (len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n \n         let expected_int_bits = (len.max(8) - 1).next_power_of_two();\n@@ -899,12 +886,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let ptr = bx.pointercast(place.llval, bx.cx.type_ptr_to(int_ty));\n                 bx.load(int_ty, ptr, Align::ONE)\n             }\n-            _ => return_error!(\n-                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n+            _ => return_error!(InvalidMonomorphization::InvalidBitmask {\n+                span,\n+                name,\n                 mask_ty,\n                 expected_int_bits,\n                 expected_bytes\n-            ),\n+            }),\n         };\n \n         let i1 = bx.type_i1();\n@@ -916,7 +904,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     }\n \n     // every intrinsic below takes a SIMD vector as its first argument\n-    require_simd!(arg_tys[0], \"input\");\n+    require_simd!(arg_tys[0], InvalidMonomorphization::SimdInput { span, name, ty: arg_tys[0] });\n     let in_ty = arg_tys[0];\n \n     let comparison = match name {\n@@ -931,23 +919,24 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n \n     let (in_len, in_elem) = arg_tys[0].simd_size_and_type(bx.tcx());\n     if let Some(cmp_op) = comparison {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n \n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n+\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         require!(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n-            \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphization::ReturnIntegerType { span, name, ret_ty, out_ty }\n         );\n \n         return Ok(compare_simd_types(\n@@ -972,34 +961,27 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                         span_bug!(span, \"could not evaluate shuffle index array length\")\n                     })\n                 }\n-                _ => return_error!(\n-                    \"simd_shuffle index must be an array of `u32`, got `{}`\",\n-                    args[2].layout.ty\n-                ),\n+                _ => return_error!(InvalidMonomorphization::SimdShuffle {\n+                    span,\n+                    name,\n+                    ty: args[2].layout.ty\n+                }),\n             }\n         } else {\n             stripped.parse().unwrap_or_else(|_| {\n                 span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n             })\n         };\n \n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             out_len == n,\n-            \"expected return type of length {}, found `{}` with length {}\",\n-            n,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLength { span, name, in_len: n, ret_ty, out_len }\n         );\n         require!(\n             in_elem == out_ty,\n-            \"expected return element type `{}` (element of input `{}`), \\\n-             found `{}` with element type `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphization::ReturnElement { span, name, in_elem, in_ty, ret_ty, out_ty }\n         );\n \n         let total_len = u128::from(in_len) * 2;\n@@ -1012,15 +994,20 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let val = bx.const_get_elt(vector, i as u64);\n                 match bx.const_to_opt_u128(val, true) {\n                     None => {\n-                        emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n+                        bx.sess().emit_err(InvalidMonomorphization::ShuffleIndexNotConstant {\n+                            span,\n+                            name,\n+                            arg_idx,\n+                        });\n                         None\n                     }\n                     Some(idx) if idx >= total_len => {\n-                        emit_error!(\n-                            \"shuffle index #{} is out of bounds (limit {})\",\n+                        bx.sess().emit_err(InvalidMonomorphization::ShuffleIndexOutOfBounds {\n+                            span,\n+                            name,\n                             arg_idx,\n-                            total_len\n-                        );\n+                            total_len,\n+                        });\n                         None\n                     }\n                     Some(idx) => Some(bx.const_i32(idx as i32)),\n@@ -1041,10 +1028,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n-            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            arg_tys[2]\n+            InvalidMonomorphization::InsertedType {\n+                span,\n+                name,\n+                in_elem,\n+                in_ty,\n+                out_ty: arg_tys[2]\n+            }\n         );\n         return Ok(bx.insert_element(\n             args[0].immediate(),\n@@ -1055,28 +1045,26 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n-            \"expected return type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty\n+            InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n         );\n         return Ok(bx.extract_element(args[0].immediate(), args[1].immediate()));\n     }\n \n     if name == sym::simd_select {\n         let m_elem_ty = in_elem;\n         let m_len = in_len;\n-        require_simd!(arg_tys[1], \"argument\");\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdArgument { span, name, ty: arg_tys[1] }\n+        );\n         let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             m_len == v_len,\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n+            InvalidMonomorphization::MismatchedLengths { span, name, m_len, v_len }\n         );\n         match m_elem_ty.kind() {\n             ty::Int(_) => {}\n-            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+            _ => return_error!(InvalidMonomorphization::MaskType { span, name, ty: m_elem_ty }),\n         }\n         // truncate the mask to a vector of i1s\n         let i1 = bx.type_i1();\n@@ -1108,11 +1096,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 args[0].immediate(),\n                 i.bit_width().unwrap_or_else(|| bx.data_layout().pointer_size.bits()),\n             ),\n-            _ => return_error!(\n-                \"vector argument `{}`'s element type `{}`, expected integer element type\",\n+            _ => return_error!(InvalidMonomorphization::VectorArgument {\n+                span,\n+                name,\n                 in_ty,\n                 in_elem\n-            ),\n+            }),\n         };\n \n         // Shift the MSB to the right by \"in_elem_bitwidth - 1\" into the first bit position.\n@@ -1147,12 +1136,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n                 return Ok(bx.load(array_ty, ptr, Align::ONE));\n             }\n-            _ => return_error!(\n-                \"cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+            _ => return_error!(InvalidMonomorphization::CannotReturn {\n+                span,\n+                name,\n                 ret_ty,\n                 expected_int_bits,\n                 expected_bytes\n-            ),\n+            }),\n         }\n     }\n \n@@ -1165,24 +1155,27 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         span: Span,\n         args: &[OperandRef<'tcx, &'ll Value>],\n     ) -> Result<&'ll Value, ()> {\n+        macro_rules! return_error {\n+            ($diag: expr) => {{\n+                bx.sess().emit_err($diag);\n+                return Err(());\n+            }};\n+        }\n+\n         let (elem_ty_str, elem_ty) = if let ty::Float(f) = in_elem.kind() {\n             let elem_ty = bx.cx.type_float_from_ty(*f);\n             match f.bit_width() {\n                 32 => (\"f32\", elem_ty),\n                 64 => (\"f64\", elem_ty),\n-                _ => {\n-                    bx.sess().emit_err(InvalidMonomorphization::FloatingPointVector {\n-                        span,\n-                        name,\n-                        f_ty: *f,\n-                        in_ty,\n-                    });\n-                    return Err(());\n-                }\n+                _ => return_error!(InvalidMonomorphization::FloatingPointVector {\n+                    span,\n+                    name,\n+                    f_ty: *f,\n+                    in_ty,\n+                }),\n             }\n         } else {\n-            bx.sess().emit_err(InvalidMonomorphization::FloatingPointType { span, name, in_ty });\n-            return Err(());\n+            return_error!(InvalidMonomorphization::FloatingPointType { span, name, in_ty });\n         };\n \n         let vec_ty = bx.type_vector(elem_ty, in_len);\n@@ -1204,10 +1197,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n-            _ => {\n-                bx.sess().emit_err(InvalidMonomorphization::UnrecognizedIntrinsic { span, name });\n-                return Err(());\n-            }\n+            _ => return_error!(InvalidMonomorphization::UnrecognizedIntrinsic { span, name }),\n         };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let f = bx.declare_cfn(llvm_name, llvm::UnnamedAddr::No, fn_ty);\n@@ -1301,37 +1291,48 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         // * M: any integer width is supported, will be truncated to i1\n \n         // All types must be simd vector types\n-        require_simd!(in_ty, \"first\");\n-        require_simd!(arg_tys[1], \"second\");\n-        require_simd!(arg_tys[2], \"third\");\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(in_ty, InvalidMonomorphization::SimdFirst { span, name, ty: in_ty });\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdSecond { span, name, ty: arg_tys[1] }\n+        );\n+        require_simd!(\n+            arg_tys[2],\n+            InvalidMonomorphization::SimdThird { span, name, ty: arg_tys[2] }\n+        );\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n \n         // Of the same length:\n         let (out_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (out_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            out_len\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len\n+            }\n         );\n         require!(\n             in_len == out_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            out_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: out_len2\n+            }\n         );\n \n         // The return type must match the first argument type\n-        require!(ret_ty == in_ty, \"expected return type `{}`, found `{}`\", in_ty, ret_ty);\n+        require!(\n+            ret_ty == in_ty,\n+            InvalidMonomorphization::ExpectedReturnType { span, name, in_ty, ret_ty }\n+        );\n \n         // This counts how many pointers\n         fn ptr_count(t: Ty<'_>) -> usize {\n@@ -1358,15 +1359,15 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                        to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*_ {}`\",\n-                    element_ty1,\n-                    arg_tys[1],\n-                    in_elem,\n-                    in_ty,\n-                    element_ty1,\n-                    in_elem\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Not,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -1382,10 +1383,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                                 to be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -1434,32 +1437,40 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         // * M: any integer width is supported, will be truncated to i1\n \n         // All types must be simd vector types\n-        require_simd!(in_ty, \"first\");\n-        require_simd!(arg_tys[1], \"second\");\n-        require_simd!(arg_tys[2], \"third\");\n+        require_simd!(in_ty, InvalidMonomorphization::SimdFirst { span, name, ty: in_ty });\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdSecond { span, name, ty: arg_tys[1] }\n+        );\n+        require_simd!(\n+            arg_tys[2],\n+            InvalidMonomorphization::SimdThird { span, name, ty: arg_tys[2] }\n+        );\n \n         // Of the same length:\n         let (element_len1, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == element_len1,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            element_len1\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len: element_len1\n+            }\n         );\n         require!(\n             in_len == element_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            element_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: element_len2\n+            }\n         );\n \n         // This counts how many pointers\n@@ -1490,15 +1501,15 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                        to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*mut {}`\",\n-                    element_ty1,\n-                    arg_tys[1],\n-                    in_elem,\n-                    in_ty,\n-                    element_ty1,\n-                    in_elem\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Mut,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -1513,10 +1524,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                         be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -1563,10 +1576,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n@@ -1589,25 +1599,28 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                                 32 => bx.const_real(bx.type_f32(), $identity),\n                                 64 => bx.const_real(bx.type_f64(), $identity),\n                                 v => return_error!(\n-                                    r#\"\n-unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n-                                    sym::$name,\n-                                    in_ty,\n-                                    in_elem,\n-                                    v,\n-                                    ret_ty\n+                                    InvalidMonomorphization::UnsupportedSymbolOfSize {\n+                                        span,\n+                                        name,\n+                                        symbol: sym::$name,\n+                                        in_ty,\n+                                        in_elem,\n+                                        size: v,\n+                                        ret_ty\n+                                    }\n                                 ),\n                             }\n                         };\n                         Ok(bx.$float_reduce(acc, args[0].immediate()))\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1635,22 +1648,20 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_i) => Ok(bx.$int_red(args[0].immediate(), true)),\n                     ty::Uint(_u) => Ok(bx.$int_red(args[0].immediate(), false)),\n                     ty::Float(_f) => Ok(bx.$float_red(args[0].immediate())),\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1668,22 +1679,20 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                 let input = if !$boolean {\n                     require!(\n                         ret_ty == in_elem,\n-                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                        in_elem,\n-                        in_ty,\n-                        ret_ty\n+                        InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                     );\n                     args[0].immediate()\n                 } else {\n                     match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n-                        _ => return_error!(\n-                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                            sym::$name,\n+                        _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                            span,\n+                            name,\n+                            symbol: sym::$name,\n                             in_ty,\n                             in_elem,\n                             ret_ty\n-                        ),\n+                        }),\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n@@ -1696,13 +1705,14 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                         let r = bx.$red(input);\n                         Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1715,16 +1725,18 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     bitwise_red!(simd_reduce_any: vector_reduce_or, true);\n \n     if name == sym::simd_cast_ptr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n@@ -1733,19 +1745,29 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     bx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), ty)\n                 });\n                 assert!(!check_sized); // we are in codegen, so we shouldn't see these types\n-                require!(metadata.is_unit(), \"cannot cast fat pointer `{}`\", in_elem)\n+                require!(\n+                    metadata.is_unit(),\n+                    InvalidMonomorphization::CastFatPointer { span, name, ty: in_elem }\n+                );\n+            }\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: in_elem })\n             }\n-            _ => return_error!(\"expected pointer, got `{}`\", in_elem),\n         }\n         match out_elem.kind() {\n             ty::RawPtr(p) => {\n                 let (metadata, check_sized) = p.ty.ptr_metadata_ty(bx.tcx, |ty| {\n                     bx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), ty)\n                 });\n                 assert!(!check_sized); // we are in codegen, so we shouldn't see these types\n-                require!(metadata.is_unit(), \"cannot cast to fat pointer `{}`\", out_elem)\n+                require!(\n+                    metadata.is_unit(),\n+                    InvalidMonomorphization::CastFatPointer { span, name, ty: out_elem }\n+                );\n+            }\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: out_elem })\n             }\n-            _ => return_error!(\"expected pointer, got `{}`\", out_elem),\n         }\n \n         if in_elem == out_elem {\n@@ -1756,66 +1778,76 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     }\n \n     if name == sym::simd_expose_addr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n             ty::RawPtr(_) => {}\n-            _ => return_error!(\"expected pointer, got `{}`\", in_elem),\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: in_elem })\n+            }\n         }\n         match out_elem.kind() {\n             ty::Uint(ty::UintTy::Usize) => {}\n-            _ => return_error!(\"expected `usize`, got `{}`\", out_elem),\n+            _ => return_error!(InvalidMonomorphization::ExpectedUsize { span, name, ty: out_elem }),\n         }\n \n         return Ok(bx.ptrtoint(args[0].immediate(), llret_ty));\n     }\n \n     if name == sym::simd_from_exposed_addr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n             ty::Uint(ty::UintTy::Usize) => {}\n-            _ => return_error!(\"expected `usize`, got `{}`\", in_elem),\n+            _ => return_error!(InvalidMonomorphization::ExpectedUsize { span, name, ty: in_elem }),\n         }\n         match out_elem.kind() {\n             ty::RawPtr(_) => {}\n-            _ => return_error!(\"expected pointer, got `{}`\", out_elem),\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: out_elem })\n+            }\n         }\n \n         return Ok(bx.inttoptr(args[0].immediate(), llret_ty));\n     }\n \n     if name == sym::simd_cast || name == sym::simd_as {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         // casting cares about nominal type, not just structural type\n         if in_elem == out_elem {\n@@ -1894,11 +1926,14 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         }\n         require!(\n             false,\n-            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n+            InvalidMonomorphization::UnsupportedCast {\n+                span,\n+                name,\n+                in_ty,\n+                in_elem,\n+                ret_ty,\n+                out_elem\n+            }\n         );\n     }\n     macro_rules! arith_binary {\n@@ -1910,10 +1945,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::UnsupportedOperation { span, name, in_ty, in_elem }\n+                );\n             })*\n         }\n     }\n@@ -1941,10 +1976,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::UnsupportedOperation { span, name, in_ty, in_elem }\n+                );\n             })*\n         }\n     }\n@@ -1982,12 +2017,12 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n             ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n             _ => {\n-                return_error!(\n-                    \"expected element type `{}` of vector type `{}` \\\n-                     to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                    arg_tys[0]\n-                );\n+                return_error!(InvalidMonomorphization::ExpectedVectorElementType {\n+                    span,\n+                    name,\n+                    expected_element: arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    vector_type: arg_tys[0]\n+                });\n             }\n         };\n         let llvm_intrinsic = &format!("}, {"sha": "e1abb73a504a3bea8ce211910cc63bd15ffcbd75", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=29d8c87fe88f51bdc7e6197e2e8eed7adc898f49", "patch": "@@ -1,10 +1,8 @@\n #![allow(non_camel_case_types)]\n \n-use rustc_errors::struct_span_err;\n use rustc_hir::LangItem;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n-use rustc_session::Session;\n use rustc_span::Span;\n \n use crate::base;\n@@ -193,10 +191,6 @@ pub fn shift_mask_val<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-pub fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n-    struct_span_err!(a, b, E0511, \"{}\", c).emit();\n-}\n-\n pub fn asm_const_to_str<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,"}, {"sha": "29876b95422418db010789f0385778e6ed2b556e", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=29d8c87fe88f51bdc7e6197e2e8eed7adc898f49", "patch": "@@ -663,4 +663,326 @@ pub enum InvalidMonomorphization<'tcx> {\n         span: Span,\n         name: Symbol,\n     },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_argument, code = \"E0511\")]\n+    SimdArgument {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_input, code = \"E0511\")]\n+    SimdInput {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_first, code = \"E0511\")]\n+    SimdFirst {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_second, code = \"E0511\")]\n+    SimdSecond {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_third, code = \"E0511\")]\n+    SimdThird {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_return, code = \"E0511\")]\n+    SimdReturn {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+    InvalidBitmask {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        mask_ty: Ty<'tcx>,\n+        expected_int_bits: u64,\n+        expected_bytes: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+    ReturnLengthInputType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_second_argument_length, code = \"E0511\")]\n+    SecondArgumentLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        arg_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_third_argument_length, code = \"E0511\")]\n+    ThirdArgumentLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        arg_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+    ReturnIntegerType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ret_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+    SimdShuffle {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_length, code = \"E0511\")]\n+    ReturnLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        ret_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_element, code = \"E0511\")]\n+    ReturnElement {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_shuffle_index_not_constant, code = \"E0511\")]\n+    ShuffleIndexNotConstant {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        arg_idx: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds, code = \"E0511\")]\n+    ShuffleIndexOutOfBounds {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        arg_idx: u64,\n+        total_len: u128,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_inserted_type, code = \"E0511\")]\n+    InsertedType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_type, code = \"E0511\")]\n+    ReturnType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_return_type, code = \"E0511\")]\n+    ExpectedReturnType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+    MismatchedLengths {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        m_len: u64,\n+        v_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_mask_type, code = \"E0511\")]\n+    MaskType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_vector_argument, code = \"E0511\")]\n+    VectorArgument {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_cannot_return, code = \"E0511\")]\n+    CannotReturn {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ret_ty: Ty<'tcx>,\n+        expected_int_bits: u64,\n+        expected_bytes: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_element_type, code = \"E0511\")]\n+    ExpectedElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        second_arg: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        mutability: ExpectedPointerMutability,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_third_arg_element_type, code = \"E0511\")]\n+    ThirdArgElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        third_arg: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size, code = \"E0511\")]\n+    UnsupportedSymbolOfSize {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        symbol: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        size: u64,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_symbol, code = \"E0511\")]\n+    UnsupportedSymbol {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        symbol: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_cast_fat_pointer, code = \"E0511\")]\n+    CastFatPointer {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_pointer, code = \"E0511\")]\n+    ExpectedPointer {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_usize, code = \"E0511\")]\n+    ExpectedUsize {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+    UnsupportedCast {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+    UnsupportedOperation {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_vector_element_type, code = \"E0511\")]\n+    ExpectedVectorElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        vector_type: Ty<'tcx>,\n+    },\n+}\n+\n+pub enum ExpectedPointerMutability {\n+    Mut,\n+    Not,\n+}\n+\n+impl IntoDiagnosticArg for ExpectedPointerMutability {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        match self {\n+            ExpectedPointerMutability::Mut => DiagnosticArgValue::Str(Cow::Borrowed(\"*mut\")),\n+            ExpectedPointerMutability::Not => DiagnosticArgValue::Str(Cow::Borrowed(\"*_\")),\n+        }\n+    }\n }"}, {"sha": "c59c992afb2323488d206023ebb89e5e0a50aaa6", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/29d8c87fe88f51bdc7e6197e2e8eed7adc898f49/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=29d8c87fe88f51bdc7e6197e2e8eed7adc898f49", "patch": "@@ -226,4 +226,70 @@ codegen_ssa_invalid_monomorphization_floating_point_type = invalid monomorphizat\n \n codegen_ssa_invalid_monomorphization_unrecognized_intrinsic = invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n \n+codegen_ssa_invalid_monomorphization_simd_argument = invalid monomorphization of `{$name}` intrinsic: expected SIMD argument type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_input = invalid monomorphization of `{$name}` intrinsic: expected SIMD input type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_first = invalid monomorphization of `{$name}` intrinsic: expected SIMD first type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_second = invalid monomorphization of `{$name}` intrinsic: expected SIMD second type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_third = invalid monomorphization of `{$name}` intrinsic: expected SIMD third type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_return = invalid monomorphization of `{$name}` intrinsic: expected SIMD return type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_invalid_bitmask = invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$mask_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n codegen_ssa_polymorphic_constant_too_generic = codegen encountered polymorphic constant: TooGeneric\n+\n+codegen_ssa_invalid_monomorphization_return_length_input_type = invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_second_argument_length = invalid monomorphization of `{$name}` intrinsic: expected second argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_third_argument_length = invalid monomorphization of `{$name}` intrinsic: expected third argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_return_integer_type = invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_shuffle = invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_return_length = invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_return_element = invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_shuffle_index_not_constant = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is not a constant\n+\n+codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is out of bounds (limit {$total_len})\n+\n+codegen_ssa_invalid_monomorphization_inserted_type = invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_ty}`, found `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_mismatched_lengths = invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+\n+codegen_ssa_invalid_monomorphization_mask_type = invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n+\n+codegen_ssa_invalid_monomorphization_vector_argument = invalid monomorphization of `{$name}` intrinsic: vector argument `{$in_ty}`'s element type `{$in_elem}`, expected integer element type\n+\n+codegen_ssa_invalid_monomorphization_cannot_return = invalid monomorphization of `{$name}` intrinsic: cannot return `{$ret_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_ssa_invalid_monomorphization_expected_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of second argument `{$second_arg}` to be a pointer to the element type `{$in_elem}` of the first argument `{$in_ty}`, found `{$expected_element}` != `{$mutability} {$in_elem}`\n+\n+codegen_ssa_invalid_monomorphization_third_arg_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of third argument `{$third_arg}` to be a signed integer type\n+\n+codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` of size `{$size}` to `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_symbol = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_cast_fat_pointer = invalid monomorphization of `{$name}` intrinsic: cannot cast fat pointer `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_pointer = invalid monomorphization of `{$name}` intrinsic: expected pointer, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_usize = invalid monomorphization of `{$name}` intrinsic: expected `usize`, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_cast = invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_operation = invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n+\n+codegen_ssa_invalid_monomorphization_expected_vector_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of vector type `{$vector_type}` to be a signed or unsigned integer type"}]}