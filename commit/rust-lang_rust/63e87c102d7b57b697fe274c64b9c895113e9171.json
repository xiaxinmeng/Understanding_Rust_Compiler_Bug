{"sha": "63e87c102d7b57b697fe274c64b9c895113e9171", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZTg3YzEwMmQ3YjU3YjY5N2ZlMjc0YzY0YjljODk1MTEzZTkxNzE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-13T02:03:52Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-13T02:03:52Z"}, "message": "typestate_check can now handle expr_block, expr_if, and expr_binary\n(caveat for the latter: it assumes that binary operations are strict;\na TODO is to detect or and and and correctly reflect that they're lazy\nin the second argument). I had to add an ann field to ast.block,\nresulting in the usual boilerplate changes.\n\nTest cases that currently work (if you uncomment the typestate pass\nin the driver) (all these are under test/compile-fail):\n\nfru-typestate\nret-uninit\nuse-uninit\nuse-uninit-2\nuse-uninit-3", "tree": {"sha": "b349625cabef2df8754b228b5126e7ade1c80788", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b349625cabef2df8754b228b5126e7ade1c80788"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63e87c102d7b57b697fe274c64b9c895113e9171", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63e87c102d7b57b697fe274c64b9c895113e9171", "html_url": "https://github.com/rust-lang/rust/commit/63e87c102d7b57b697fe274c64b9c895113e9171", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63e87c102d7b57b697fe274c64b9c895113e9171/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3409f63687dae6096f4ed01a5ea6981a3cf0f65", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3409f63687dae6096f4ed01a5ea6981a3cf0f65", "html_url": "https://github.com/rust-lang/rust/commit/d3409f63687dae6096f4ed01a5ea6981a3cf0f65"}], "stats": {"total": 519, "additions": 358, "deletions": 161}, "files": [{"sha": "b0035ba618e3a67bb25720ac9b31c2799227b230", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=63e87c102d7b57b697fe274c64b9c895113e9171", "patch": "@@ -100,7 +100,8 @@ tag block_index_entry {\n }\n type block_ = rec(vec[@stmt] stmts,\n                   option.t[@expr] expr,\n-                  hashmap[ident,block_index_entry] index);\n+                  hashmap[ident,block_index_entry] index,\n+                  ann a); /* ann is only meaningful for the ts_ann field */\n \n type variant_def = tup(def_id /* tag */, def_id /* variant */);\n "}, {"sha": "ab44f6380d933ed9a354c55cc29f4581d660a90b", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=63e87c102d7b57b697fe274c64b9c895113e9171", "patch": "@@ -1598,7 +1598,7 @@ fn index_block(vec[@ast.stmt] stmts, option.t[@ast.expr] expr) -> ast.block_ {\n     for (@ast.stmt s in stmts) {\n         ast.index_stmt(index, s);\n     }\n-    ret rec(stmts=stmts, expr=expr, index=index);\n+    ret rec(stmts=stmts, expr=expr, index=index, a=ast.ann_none);\n }\n \n fn index_arm(@ast.pat pat) -> hashmap[ast.ident,ast.def_id] {"}, {"sha": "fbf43c55a338127f8aa512f4bc14b0b02332049d", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=63e87c102d7b57b697fe274c64b9c895113e9171", "patch": "@@ -871,7 +871,8 @@ fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n         }\n     }\n \n-    ret respan(blk.span, rec(stmts=stmts, expr=expr, index=index));\n+    auto aa = fld.fold_ann(env, blk.node.a); \n+    ret respan(blk.span, rec(stmts=stmts, expr=expr, index=index, a=aa));\n }\n \n fn fold_arm[ENV](&ENV env, ast_fold[ENV] fld, &arm a) -> arm {"}, {"sha": "f87460569c8d47d0c98cb1ad1b5b33ba604de3f3", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=63e87c102d7b57b697fe274c64b9c895113e9171", "patch": "@@ -1399,7 +1399,8 @@ mod Pushdown {\n                 auto e_1 = pushdown_expr(fcx, expected, e_0);\n                 auto block_ = rec(stmts=bloc.node.stmts,\n                                   expr=some[@ast.expr](e_1),\n-                                  index=bloc.node.index);\n+                                  index=bloc.node.index,\n+                                  a=boring_ann());\n                 ret fold.respan[ast.block_](bloc.span, block_);\n             }\n             case (none[@ast.expr]) {\n@@ -2569,7 +2570,8 @@ fn check_block(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n \n     ret fold.respan[ast.block_](block.span,\n                                 rec(stmts=stmts, expr=expr,\n-                                    index=block.node.index));\n+                                    index=block.node.index,\n+                                    a=boring_ann()));\n }\n \n fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,"}, {"sha": "11aad9a2d4aa01b2747f3962ad3ee1ee8acb045b", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 345, "deletions": 156, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=63e87c102d7b57b697fe274c64b9c895113e9171", "patch": "@@ -27,8 +27,11 @@ import front.ast.expr_index;\n import front.ast.expr_log;\n import front.ast.expr_block;\n import front.ast.expr_rec;\n+import front.ast.expr_if;\n+import front.ast.expr_binary;\n import front.ast.expr_assign;\n import front.ast.expr_lit;\n+import front.ast.expr_ret;\n import front.ast.path;\n import front.ast.crate_directive;\n import front.ast.fn_decl;\n@@ -71,6 +74,7 @@ import util.common.field_exprs;\n import util.typestate_ann;\n import util.typestate_ann.ts_ann;\n import util.typestate_ann.empty_pre_post;\n+import util.typestate_ann.empty_poststate;\n import util.typestate_ann.true_precond;\n import util.typestate_ann.true_postcond;\n import util.typestate_ann.postcond;\n@@ -95,6 +99,7 @@ import util.typestate_ann.empty_prestate;\n import util.typestate_ann.empty_ann;\n import util.typestate_ann.extend_prestate;\n import util.typestate_ann.extend_poststate;\n+import util.typestate_ann.intersect;\n \n import middle.ty;\n import middle.ty.ann_to_type;\n@@ -494,6 +499,48 @@ fn expr_pp(&expr e) -> pre_and_post {\n   }\n }\n \n+/* fails if b has no annotation */\n+/* FIXME: factor out code in the following two functions (block_ts_ann) */\n+fn block_pp(&block b) -> pre_and_post {\n+    alt (b.node.a) {\n+       case (ann_none) {\n+           log \"block_pp: the impossible happened (no ann)\";\n+           fail;\n+       }\n+       case (ann_type(_,_,?t)) {\n+           alt (t) {\n+               case (none[@ts_ann]) {\n+                   log \"block_pp: the impossible happened (no ty)\";\n+                   fail;\n+               }\n+               case (some[@ts_ann](?ts)) {\n+                   ret ts.conditions;\n+               }\n+           }\n+       }\n+    }\n+}\n+\n+fn block_states(&block b) -> pre_and_post_state {\n+    alt (b.node.a) {\n+       case (ann_none) {\n+           log \"block_pp: the impossible happened (no ann)\";\n+           fail;\n+       }\n+       case (ann_type(_,_,?t)) {\n+           alt (t) {\n+               case (none[@ts_ann]) {\n+                   log \"block_states: the impossible happened (no ty)\";\n+                   fail;\n+               }\n+               case (some[@ts_ann](?ts)) {\n+                   ret ts.states;\n+               }\n+           }\n+       }\n+    }\n+}\n+\n fn stmt_states(&stmt s, uint nv) -> pre_and_post_state {\n   alt (stmt_to_ann(s)) {\n     case (none[@ts_ann]) {\n@@ -545,6 +592,14 @@ fn stmt_poststate(&stmt s, uint nv) -> poststate {\n   ret (stmt_states(s, nv)).poststate;\n }\n \n+fn block_postcond(&block b) -> postcond {\n+    ret (block_pp(b)).postcondition;\n+}\n+\n+fn block_poststate(&block b) -> poststate {\n+    ret (block_states(b)).poststate;\n+}\n+\n /* returns a new annotation where the pre_and_post is p */\n fn with_pp(ann a, pre_and_post p) -> ann {\n   alt (a) {\n@@ -581,6 +636,8 @@ fn seq_preconds(uint num_vars, vec[pre_and_post] pps) -> precond {\n   ret (first.precondition);\n }\n \n+/* works on either postconds or preconds\n+ should probably rethink the whole type synonym situation */\n fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n   auto sz = _vec.len[postcond](rest);\n \n@@ -599,6 +656,26 @@ fn union_postconds(&vec[postcond] pcs) -> postcond {\n   ret union_postconds_go(bitv.clone(pcs.(0)), pcs);\n }\n \n+/* Gee, maybe we could use foldl or something */\n+fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n+  auto sz = _vec.len[postcond](rest);\n+\n+  if (sz > 0u) {\n+    auto other = rest.(0);\n+    intersect(first, other);\n+    intersect_postconds_go(first, slice[postcond](rest, 1u,\n+                                                  len[postcond](rest)));\n+  }\n+\n+  ret first;\n+}\n+\n+fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n+  check (len[postcond](pcs) > 0u);\n+\n+  ret intersect_postconds_go(bitv.clone(pcs.(0)), pcs);\n+}\n+\n /******* AST-traversing code ********/\n \n fn find_pre_post_mod(&_mod m) -> _mod {\n@@ -616,7 +693,7 @@ fn find_pre_post_obj(_obj o) -> _obj {\n fn find_pre_post_item(_fn_info_map fm, fn_info enclosing, &item i) -> () {\n   alt (i.node) {\n     case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n-      find_pre_post_expr(enclosing, *e);\n+        find_pre_post_expr(fm, enclosing, *e);\n     }\n     case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n       check (fm.contains_key(di));\n@@ -641,167 +718,230 @@ fn find_pre_post_item(_fn_info_map fm, fn_info enclosing, &item i) -> () {\n }\n \n /* Fills in annotations as a side effect. Does not rebuild the expr */\n-fn find_pre_post_expr(&fn_info enclosing, &expr e) -> () {\n-  auto num_local_vars = num_locals(enclosing);\n+fn find_pre_post_expr(&_fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n+    auto num_local_vars = num_locals(enclosing);\n \n-  fn do_rand_(fn_info enclosing, &@expr e) -> () {\n-    find_pre_post_expr(enclosing, *e);\n-  }\n-  fn pp_one(&@expr e) -> pre_and_post {\n-      be expr_pp(*e);\n-  }\n+    fn do_rand_(_fn_info_map fm, fn_info enclosing, &@expr e) -> () {\n+        find_pre_post_expr(fm, enclosing, *e);\n+    }\n+    fn pp_one(&@expr e) -> pre_and_post {\n+        be expr_pp(*e);\n+    }\n \n-  alt(e.node) {\n-    case(expr_call(?operator, ?operands, ?a)) {\n-      find_pre_post_expr(enclosing, *operator);\n+    alt(e.node) {\n+        case(expr_call(?operator, ?operands, ?a)) {\n+            find_pre_post_expr(fm, enclosing, *operator);\n \n-      auto do_rand = bind do_rand_(enclosing,_);\n-      auto f = do_rand;\n-      _vec.map[@expr, ()](f, operands);\n+            auto do_rand = bind do_rand_(fm, enclosing,_);\n+            auto f = do_rand;\n+            _vec.map[@expr, ()](f, operands);\n       \n-      auto g = pp_one;\n-      auto pps = _vec.map[@expr, pre_and_post](g, operands);\n-      _vec.push[pre_and_post](pps, expr_pp(*operator));\n-      auto h = get_post;\n-      auto res_postconds = _vec.map[pre_and_post, postcond](h, pps);\n-      auto res_postcond = union_postconds(res_postconds);\n+            auto g = pp_one;\n+            auto pps = _vec.map[@expr, pre_and_post](g, operands);\n+            _vec.push[pre_and_post](pps, expr_pp(*operator));\n+            auto h = get_post;\n+            auto res_postconds = _vec.map[pre_and_post, postcond](h, pps);\n+            auto res_postcond = union_postconds(res_postconds);\n       \n-      let pre_and_post pp =\n-        rec(precondition=seq_preconds(num_local_vars, pps),\n-             postcondition=res_postcond);\n-      set_pre_and_post(a, pp);\n-      ret;\n-    }\n-    case(expr_path(?p, ?maybe_def, ?a)) {\n-      auto df;\n-      alt (maybe_def) {\n-        case (none[def])\n-          { log(\"expr_path should have a def\"); fail; }\n-        case (some[def](?d)) { df = d; }\n-      }\n-\n-      auto res = empty_pre_post(num_local_vars);\n-\n-      alt (df) {\n-        case (def_local(?d_id)) {\n-          auto i = bit_num(d_id, enclosing);\n-          require_and_preserve(i, res);\n+            let pre_and_post pp =\n+                rec(precondition=seq_preconds(num_local_vars, pps),\n+                    postcondition=res_postcond);\n+            set_pre_and_post(a, pp);\n+            ret;\n         }\n-        case (_) { /* nothing to check */ }\n-      }\n+        case(expr_path(?p, ?maybe_def, ?a)) {\n+            auto df;\n+            alt (maybe_def) {\n+                case (none[def])\n+                    { log(\"expr_path should have a def\"); fail; }\n+                case (some[def](?d)) { df = d; }\n+            }\n \n-      // Otherwise, variable is global, so it must be initialized\n-      set_pre_and_post(a, res);\n-    }\n-    case(expr_log(?arg, ?a)) {\n-      find_pre_post_expr(enclosing, *arg);\n-      set_pre_and_post(a, expr_pp(*arg));\n-    }\n-    case (expr_block(?b, ?a)) {\n-      log(\"block!\");\n-      fail;\n-    }\n-    case (expr_rec(?fields,?maybe_base,?a)) {\n-        /* factor out this code */\n-        auto es = field_exprs(fields);\n-        auto do_rand = bind do_rand_(enclosing,_);\n-        auto f = do_rand;\n-        _vec.map[@expr, ()](f, es);\n-        auto g = pp_one;\n-        auto h = get_post;\n-        /* FIXME avoid repeated code */\n-        alt (maybe_base) {\n-            case (none[@expr]) {\n-                auto pps = _vec.map[@expr, pre_and_post](g, es);\n-                auto res_postconds = _vec.map[pre_and_post, postcond](h, pps);\n-                auto res_postcond = union_postconds(res_postconds);\n-                let pre_and_post pp =\n-                    rec(precondition=seq_preconds(num_local_vars, pps),\n-                        postcondition=res_postcond);\n-                set_pre_and_post(a, pp);\n+            auto res = empty_pre_post(num_local_vars);\n+\n+            alt (df) {\n+                case (def_local(?d_id)) {\n+                    auto i = bit_num(d_id, enclosing);\n+                    require_and_preserve(i, res);\n+                }\n+                case (_) { /* nothing to check */ }\n             }\n-            case (some[@expr](?base_exp)) {\n-                find_pre_post_expr(enclosing, *base_exp);\n+\n+            // Otherwise, variable is global, so it must be initialized\n+            set_pre_and_post(a, res);\n+        }\n+        case(expr_log(?arg, ?a)) {\n+            find_pre_post_expr(fm, enclosing, *arg);\n+            set_pre_and_post(a, expr_pp(*arg));\n+        }\n+        case (expr_block(?b, ?a)) {\n+            find_pre_post_block(fm, enclosing, b);\n+            set_pre_and_post(a, block_pp(b));\n+        }\n+        case (expr_rec(?fields,?maybe_base,?a)) {\n+            /* factor out this code */\n+            auto es = field_exprs(fields);\n+            auto do_rand = bind do_rand_(fm, enclosing,_);\n+            auto f = do_rand;\n+            _vec.map[@expr, ()](f, es);\n+            auto g = pp_one;\n+            auto h = get_post;\n+            /* FIXME avoid repeated code */\n+            alt (maybe_base) {\n+                case (none[@expr]) {\n+                    auto pps = _vec.map[@expr, pre_and_post](g, es);\n+                    auto res_postconds = _vec.map[pre_and_post, postcond]\n+                        (h, pps);\n+                    auto res_postcond = union_postconds(res_postconds);\n+                    let pre_and_post pp =\n+                        rec(precondition=seq_preconds(num_local_vars, pps),\n+                            postcondition=res_postcond);\n+                    set_pre_and_post(a, pp);\n+                }\n+                case (some[@expr](?base_exp)) {\n+                    find_pre_post_expr(fm, enclosing, *base_exp);\n         \n-                es += vec(base_exp);\n-                auto pps = _vec.map[@expr, pre_and_post](g, es);\n-                auto res_postconds = _vec.map[pre_and_post, postcond](h, pps);\n-                auto res_postcond = union_postconds(res_postconds);\n-\n-                let pre_and_post pp =\n-                    rec(precondition=seq_preconds(num_local_vars, pps),\n-                        postcondition=res_postcond);\n-                set_pre_and_post(a, pp);\n+                    es += vec(base_exp);\n+                    auto pps = _vec.map[@expr, pre_and_post](g, es);\n+                    auto res_postconds = _vec.map[pre_and_post, postcond]\n+                        (h, pps);\n+                    auto res_postcond = union_postconds(res_postconds);\n+\n+                    let pre_and_post pp =\n+                        rec(precondition=seq_preconds(num_local_vars, pps),\n+                            postcondition=res_postcond);\n+                    set_pre_and_post(a, pp);\n+                }\n             }\n+            ret;\n         }\n-        ret;\n-    }\n-    case (expr_assign(?lhs, ?rhs, ?a)) {\n-        // what's below should be compressed into two cases:\n-        // path of a local, and non-path-of-a-local\n-        alt (lhs.node) {\n-            case (expr_field(?e,?id,?a_lhs)) {\n-                // lhs is already initialized, so this doesn't initialize\n-                // anything anew\n-                find_pre_post_expr(enclosing, *e);\n-                set_pre_and_post(a_lhs, expr_pp(*e));\n-\n-                find_pre_post_expr(enclosing, *rhs);\n-                let pre_and_post expr_assign_pp = \n-                    rec(precondition=seq_preconds\n-                         (num_local_vars,\n-                          vec(expr_pp(*e), expr_pp(*rhs))),\n-                        postcondition=union_postconds\n-                        (vec(expr_postcond(*e), expr_postcond(*rhs))));\n-                set_pre_and_post(a, expr_assign_pp);\n-            }\n-            case (expr_path(?p,?maybe_def,?a_lhs)) {\n-                find_pre_post_expr(enclosing, *rhs);\n-                set_pre_and_post(a_lhs, empty_pre_post(num_local_vars));\n-                find_pre_post_expr(enclosing, *rhs);\n-                alt (maybe_def) {\n-                    // is this a local variable?\n-                    // if so, the only case in which an assign actually\n-                    // causes a variable to become initialized\n-                    case (some[def](def_local(?d_id))) {\n-                        set_pre_and_post(a, expr_pp(*rhs));\n-                        gen(enclosing, a, d_id);\n-                    }\n-                    case (_) {\n-                        // already initialized\n-                        set_pre_and_post(a, expr_pp(*rhs));\n+        case (expr_assign(?lhs, ?rhs, ?a)) {\n+            // what's below should be compressed into two cases:\n+            // path of a local, and non-path-of-a-local\n+            alt (lhs.node) {\n+                case (expr_field(?e,?id,?a_lhs)) {\n+                    // lhs is already initialized, so this doesn't initialize\n+                    // anything anew\n+                    find_pre_post_expr(fm, enclosing, *e);\n+                    set_pre_and_post(a_lhs, expr_pp(*e));\n+\n+                    find_pre_post_expr(fm, enclosing, *rhs);\n+                    let pre_and_post expr_assign_pp = \n+                        rec(precondition=seq_preconds\n+                            (num_local_vars,\n+                             vec(expr_pp(*e), expr_pp(*rhs))),\n+                            postcondition=union_postconds\n+                            (vec(expr_postcond(*e), expr_postcond(*rhs))));\n+                    set_pre_and_post(a, expr_assign_pp);\n+                }\n+                case (expr_path(?p,?maybe_def,?a_lhs)) {\n+                    find_pre_post_expr(fm, enclosing, *rhs);\n+                    set_pre_and_post(a_lhs, empty_pre_post(num_local_vars));\n+                    find_pre_post_expr(fm, enclosing, *rhs);\n+                    alt (maybe_def) {\n+                        // is this a local variable?\n+                        // if so, the only case in which an assign actually\n+                        // causes a variable to become initialized\n+                        case (some[def](def_local(?d_id))) {\n+                            set_pre_and_post(a, expr_pp(*rhs));\n+                            gen(enclosing, a, d_id);\n+                        }\n+                        case (_) {\n+                            // already initialized\n+                            set_pre_and_post(a, expr_pp(*rhs));\n+                        }\n                     }\n                 }\n-            }\n-            case (expr_index(?e,?sub,_)) {\n-                // lhs is already initialized\n-                // assuming the array subscript gets evaluated before the\n-                // array\n-                find_pre_post_expr(enclosing, *lhs);\n-                find_pre_post_expr(enclosing, *rhs);\n-                set_pre_and_post(a, \n-                   rec(precondition=\n-                        seq_preconds\n-                          (num_local_vars, vec(expr_pp(*lhs), expr_pp(*rhs))),\n-                       postcondition=\n-                          union_postconds(vec(expr_postcond(*lhs),\n-                                              expr_postcond(*rhs)))));\n+                case (expr_index(?e,?sub,_)) {\n+                    // lhs is already initialized\n+                    // assuming the array subscript gets evaluated before the\n+                    // array\n+                    find_pre_post_expr(fm, enclosing, *lhs);\n+                    find_pre_post_expr(fm, enclosing, *rhs);\n+                    set_pre_and_post(a, \n+                       rec(precondition=\n+                           seq_preconds\n+                           (num_local_vars, vec(expr_pp(*lhs), \n+                                                expr_pp(*rhs))),\n+                           postcondition=\n+                           union_postconds(vec(expr_postcond(*lhs),\n+                                               expr_postcond(*rhs)))));\n                 \n+                }\n+                case (_) {\n+                    log(\"find_pre_post_for_expr: non-lval on lhs of assign\");\n+                    fail;\n+                }\n             }\n-            case (_) {\n-                log(\"find_pre_post_for_expr: non-lval on lhs of assign\");\n-                fail;\n+        }\n+        case (expr_lit(_,?a)) {\n+            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+        }\n+        case (expr_ret(?maybe_val, ?a)) {\n+            alt (maybe_val) {\n+                case (none[@expr]) {\n+                    set_pre_and_post(a, empty_pre_post(num_local_vars));\n+                }\n+                case (some[@expr](?ret_val)) {\n+                    find_pre_post_expr(fm, enclosing, *ret_val);\n+                    let pre_and_post pp =\n+                        rec(precondition=expr_precond(*ret_val),\n+                            postcondition=empty_poststate(num_local_vars));\n+                    set_pre_and_post(a, pp);\n+                }\n             }\n         }\n+        case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n+            find_pre_post_expr(fm, enclosing, *antec);\n+            find_pre_post_block(fm, enclosing, conseq);\n+            alt (maybe_alt) {\n+                case (none[@expr]) {\n+                    auto precond_res = seq_preconds(num_local_vars,\n+                                                    vec(expr_pp(*antec),\n+                                                        block_pp(conseq)));\n+                    set_pre_and_post(a, rec(precondition=precond_res,\n+                                            postcondition=\n+                                            expr_poststate(*antec)));\n+                }\n+                case (some[@expr](?altern)) {\n+                    find_pre_post_expr(fm, enclosing, *altern);\n+                    auto precond_true_case =\n+                        seq_preconds(num_local_vars,\n+                                     vec(expr_pp(*antec), block_pp(conseq)));\n+                    auto postcond_true_case = union_postconds\n+                        (vec(expr_postcond(*antec), block_postcond(conseq)));\n+                    auto precond_false_case = seq_preconds\n+                        (num_local_vars,\n+                         vec(expr_pp(*antec), expr_pp(*altern)));\n+                    auto postcond_false_case = union_postconds\n+                        (vec(expr_postcond(*antec), expr_postcond(*altern)));\n+                    auto precond_res = union_postconds(vec(precond_true_case,\n+                                                       precond_false_case));\n+                    auto postcond_res = intersect_postconds\n+                        (vec(postcond_true_case, postcond_false_case));\n+                    set_pre_and_post(a, rec(precondition=precond_res,\n+                                            postcondition=postcond_res));\n+                }\n+            }\n+        }\n+        case (expr_binary(?bop,?l,?r,?a)) {\n+            /* *unless* bop is lazy (e.g. and, or)? \n+             FIXME */\n+            find_pre_post_expr(fm, enclosing, *l);\n+            find_pre_post_expr(fm, enclosing, *r);\n+            set_pre_and_post(a, \n+                             rec(precondition=\n+                                 seq_preconds(num_local_vars,\n+                                              vec(expr_pp(*l), expr_pp(*r))),\n+                                 postcondition=\n+                                 union_postconds(vec(expr_postcond(*l),\n+                                                     expr_postcond(*r)))));\n+        }\n+        case(_) {\n+            log(\"this sort of expr isn't implemented!\");\n+            fail;\n+        }\n     }\n-    case (expr_lit(_,?a)) {\n-        set_pre_and_post(a, empty_pre_post(num_local_vars));\n-    }\n-    case(_) {\n-      log(\"this sort of expr isn't implemented!\");\n-      fail;\n-    }\n-  }\n }\n \n impure fn gen(&fn_info enclosing, &ann a, def_id id) -> bool {\n@@ -827,7 +967,7 @@ fn find_pre_post_stmt(_fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n             case(ast.decl_local(?alocal)) {\n                 alt(alocal.init) {\n                     case(some[ast.initializer](?an_init)) {\n-                        find_pre_post_expr(enclosing, *an_init.expr);\n+                        find_pre_post_expr(fm, enclosing, *an_init.expr);\n                         auto rhs_pp = expr_pp(*an_init.expr);\n                         set_pre_and_post(alocal.ann, rhs_pp);\n \n@@ -851,7 +991,7 @@ fn find_pre_post_stmt(_fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n         }\n     }\n     case(stmt_expr(?e,?a)) {\n-        find_pre_post_expr(enclosing, *e);\n+        find_pre_post_expr(fm, enclosing, *e);\n         set_pre_and_post(a, expr_pp(*e));\n     }    \n   }\n@@ -865,11 +1005,12 @@ fn find_pre_post_block(&_fn_info_map fm, &fn_info enclosing, block b)\n     auto do_one = bind do_one_(fm, enclosing, _);\n     \n     _vec.map[@stmt, ()](do_one, b.node.stmts);\n-    fn do_inner_(fn_info i, &@expr e) -> () {\n-        find_pre_post_expr(i, *e);\n+    fn do_inner_(_fn_info_map fm, fn_info i, &@expr e) -> () {\n+        find_pre_post_expr(fm, i, *e);\n     }\n-    auto do_inner = bind do_inner_(enclosing, _);\n+    auto do_inner = bind do_inner_(fm, enclosing, _);\n     option.map[@expr, ()](do_inner, b.node.expr);\n+    /* FIXME needs to set up the ann for b!!!!!!!!!!! */\n }\n \n fn find_pre_post_fn(&_fn_info_map fm, &fn_info fi, &_fn f) -> () {\n@@ -993,8 +1134,7 @@ impure fn pure_exp(&ann a, &prestate p) -> bool {\n fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n                             &prestate pres, &@expr e) -> bool {\n   auto changed = false;\n-\n-  /* a bit confused about when setting the states happens */\n+  auto num_local_vars = num_locals(enclosing);\n \n   alt (e.node) {\n     case (expr_vec(?elts, _, ?a)) {\n@@ -1025,8 +1165,11 @@ fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n         ret pure_exp(a, pres);\n     }\n     case (expr_block(?b,?a)) {\n-        log(\"find_pre_post_state_expr: block!\");\n-        fail;\n+        changed = find_pre_post_state_block(fm, enclosing, pres, b)\n+           || changed;\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, block_poststate(b)) || changed;\n+        ret changed;\n     }\n     case (expr_rec(?fields,?maybe_base,?a)) {\n         changed = find_pre_post_state_exprs(fm, enclosing, pres, a,\n@@ -1067,6 +1210,49 @@ fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n         }\n         ret changed;\n     }\n+    case (expr_ret(?maybe_ret_val, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        set_poststate_ann(a, empty_poststate(num_local_vars));\n+        alt(maybe_ret_val) {\n+            case (none[@expr]) { /* do nothing */ }\n+            case (some[@expr](?ret_val)) {\n+                changed = find_pre_post_state_expr(fm, enclosing,\n+                             pres, ret_val) || changed;\n+            }\n+        }\n+        ret changed;\n+    }\n+    case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, antec)\n+            || changed;\n+        changed = find_pre_post_state_block(fm, enclosing,\n+          expr_poststate(*antec), conseq) || changed;\n+        alt (maybe_alt) {\n+            case (none[@expr]) {\n+                changed = extend_poststate_ann(a, expr_poststate(*antec))\n+                    || changed;\n+            }\n+            case (some[@expr](?altern)) {\n+                changed = find_pre_post_state_expr(fm, enclosing,\n+                   expr_poststate(*antec), altern) || changed;\n+                auto poststate_res = intersect_postconds\n+                    (vec(block_poststate(conseq), expr_poststate(*altern)));\n+                changed = extend_poststate_ann(a, poststate_res) || changed;\n+            }\n+        }\n+        ret changed;\n+    }\n+    case (expr_binary(?bop, ?l, ?r, ?a)) {\n+        /* FIXME: what if bop is lazy? */\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, l)\n+                    || changed;\n+        changed = find_pre_post_state_expr(fm,\n+                    enclosing, expr_poststate(*l), r) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*r)) || changed;\n+        ret changed;\n+    }\n     case (_) {\n       log(\"find_pre_post_state_expr: implement this case!\");\n       fail;\n@@ -1157,14 +1343,15 @@ fn find_pre_post_state_stmt(&_fn_info_map fm, &fn_info enclosing,\n \n /* Updates the pre- and post-states of statements in the block,\n    returns a boolean flag saying whether any pre- or poststates changed */\n-fn find_pre_post_state_block(&_fn_info_map fm, &fn_info enclosing, block b)\n+fn find_pre_post_state_block(&_fn_info_map fm, &fn_info enclosing,\n+                             &prestate pres0, block b)\n   -> bool {\n \n   auto changed = false;\n   auto num_local_vars = num_locals(enclosing);\n \n   /* First, set the pre-states and post-states for every expression */\n-  auto pres = empty_prestate(num_local_vars);\n+  auto pres = pres0;\n   \n   /* Iterate over each stmt. The new prestate is <pres>. The poststate\n    consist of improving <pres> with whatever variables this stmt initializes.\n@@ -1185,7 +1372,9 @@ fn find_pre_post_state_block(&_fn_info_map fm, &fn_info enclosing, block b)\n \n fn find_pre_post_state_fn(&_fn_info_map f_info, &fn_info fi, &ast._fn f)\n   -> bool {\n-  ret find_pre_post_state_block(f_info, fi, f.body);\n+    auto num_local_vars = num_locals(fi);\n+    ret find_pre_post_state_block(f_info, fi,\n+                                  empty_prestate(num_local_vars), f.body);\n }\n \n fn fixed_point_states(_fn_info_map fm, fn_info f_info,"}, {"sha": "9ccb87318f3d553fd11250a1e3b5ec2cfa08de46", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e87c102d7b57b697fe274c64b9c895113e9171/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=63e87c102d7b57b697fe274c64b9c895113e9171", "patch": "@@ -75,6 +75,10 @@ fn union(&precond p1, &precond p2) -> bool {\n   be bitv.union(p1, p2);\n }\n \n+fn intersect(&precond p1, &precond p2) -> bool {\n+  be bitv.intersect(p1, p2);\n+}\n+\n fn pps_len(&pre_and_post p) -> uint {\n   // gratuitous check\n   check (p.precondition.nbits == p.postcondition.nbits);"}]}