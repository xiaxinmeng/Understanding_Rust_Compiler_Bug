{"sha": "48f5f01e8bb874b789821dba4d18d5930ec33172", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZjVmMDFlOGJiODc0Yjc4OTgyMWRiYTRkMThkNTkzMGVjMzMxNzI=", "commit": {"author": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-05-09T23:01:31Z"}, "committer": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-05-09T23:01:31Z"}, "message": "move logic to a function", "tree": {"sha": "61d148cb52a856ce55a32f2842dad52ca41bbafd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61d148cb52a856ce55a32f2842dad52ca41bbafd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48f5f01e8bb874b789821dba4d18d5930ec33172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48f5f01e8bb874b789821dba4d18d5930ec33172", "html_url": "https://github.com/rust-lang/rust/commit/48f5f01e8bb874b789821dba4d18d5930ec33172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48f5f01e8bb874b789821dba4d18d5930ec33172/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efc8f65b852b7ce5203ce22f54066a0e647019a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/efc8f65b852b7ce5203ce22f54066a0e647019a5", "html_url": "https://github.com/rust-lang/rust/commit/efc8f65b852b7ce5203ce22f54066a0e647019a5"}], "stats": {"total": 160, "additions": 79, "deletions": 81}, "files": [{"sha": "3aaa269cd4bcf1a08f7ce67c088fdfc657430eab", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 79, "deletions": 81, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/48f5f01e8bb874b789821dba4d18d5930ec33172/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f5f01e8bb874b789821dba4d18d5930ec33172/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=48f5f01e8bb874b789821dba4d18d5930ec33172", "patch": "@@ -424,87 +424,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                         match label {\n                             Some((true, err_help_span, suggested_code)) => {\n-                                /// User cannot make signature of a trait mutable\n-                                /// without changing the trait. So we find if this\n-                                /// error belongs to a trait and if so we move\n-                                /// suggestion to the trait or disable it if it is\n-                                /// out of scope of this crate\n-                                let (is_trait_sig, local_trait) = {\n-                                    if self.body.local_kind(local) != LocalKind::Arg {\n-                                        (false, None)\n-                                    } else {\n-                                        let hir_map = self.infcx.tcx.hir();\n-                                        let my_hir = hir_map.local_def_id_to_hir_id(\n-                                            self.body.source.def_id().as_local().unwrap(),\n-                                        );\n-                                        match hir_map.find(hir_map.get_parent_node(my_hir)) {\n-                                            Some(Node::Item(hir::Item {\n-                                                kind:\n-                                                    hir::ItemKind::Impl(hir::Impl {\n-                                                        of_trait:\n-                                                            Some(hir::TraitRef {\n-                                                                path:\n-                                                                    hir::Path {\n-                                                                        res:\n-                                                                            hir::def::Res::Def(_, td),\n-                                                                        ..\n-                                                                    },\n-                                                                ..\n-                                                            }),\n-                                                        ..\n-                                                    }),\n-                                                ..\n-                                            })) => {\n-                                                (true, td.as_local().and_then(|tld| {\n-                                                    let h = hir_map.local_def_id_to_hir_id(tld);\n-                                                    match hir_map.find(h) {\n-                                                        Some(Node::Item(hir::Item {\n-                                                            kind: hir::ItemKind::Trait(\n-                                                                _, _, _, _,\n-                                                                items\n-                                                            ),\n-                                                            ..\n-                                                        })) => {\n-                                                            let mut f_in_trait_opt = None;\n-                                                            for hir::TraitItemRef { id: fi, kind: k, .. } in *items {\n-                                                                let hi = fi.hir_id();\n-                                                                if !matches!(k, hir::AssocItemKind::Fn { .. }) {\n-                                                                    continue;\n-                                                                }\n-                                                                if hir_map.name(hi) != hir_map.name(my_hir) {\n-                                                                    continue;\n-                                                                }\n-                                                                f_in_trait_opt = Some(hi);\n-                                                                break;\n-                                                            }\n-                                                            f_in_trait_opt.and_then(|f_in_trait| {\n-                                                                match hir_map.find(f_in_trait) {\n-                                                                    Some(Node::TraitItem(hir::TraitItem {\n-                                                                        kind: hir::TraitItemKind::Fn(hir::FnSig {\n-                                                                            decl: hir::FnDecl {\n-                                                                                inputs,\n-                                                                                ..\n-                                                                            },\n-                                                                            ..\n-                                                                        }, _),\n-                                                                        ..\n-                                                                    })) => {\n-                                                                        let hir::Ty { span, .. } = inputs[local.index() - 1];\n-                                                                        Some(span)\n-                                                                    },\n-                                                                    _ => None,\n-                                                                }\n-                                                            })\n-                                                            //Some(hir_map.span(h))\n-                                                        }\n-                                                        _ => None\n-                                                    }\n-                                                }))\n-                                            }\n-                                            _ => (false, None),\n-                                        }\n-                                    }\n-                                };\n+                                let (is_trait_sig, local_trait) = self.is_error_in_trait(local);\n                                 if !is_trait_sig {\n                                     err.span_suggestion(\n                                         err_help_span,\n@@ -595,6 +515,84 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         err.buffer(&mut self.errors_buffer);\n     }\n+    \n+    /// User cannot make signature of a trait mutable without changing the\n+    /// trait. So we find if this error belongs to a trait and if so we move\n+    /// suggestion to the trait or disable it if it is out of scope of this crate                            \n+    fn is_error_in_trait(&self, local: Local) -> (bool, Option<Span>) {\n+        if self.body.local_kind(local) != LocalKind::Arg {\n+            return (false, None);\n+        }\n+        let hir_map = self.infcx.tcx.hir();\n+        let my_hir = hir_map.local_def_id_to_hir_id(\n+            self.body.source.def_id().as_local().unwrap(),\n+        );\n+        match hir_map.find(hir_map.get_parent_node(my_hir)) {\n+            Some(Node::Item(hir::Item {\n+                kind:\n+                    hir::ItemKind::Impl(hir::Impl {\n+                        of_trait:\n+                            Some(hir::TraitRef {\n+                                path:\n+                                    hir::Path {\n+                                        res:\n+                                            hir::def::Res::Def(_, td),\n+                                        ..\n+                                    },\n+                                ..\n+                            }),\n+                        ..\n+                    }),\n+                ..\n+            })) => {\n+                (true, td.as_local().and_then(|tld| {\n+                    let h = hir_map.local_def_id_to_hir_id(tld);\n+                    match hir_map.find(h) {\n+                        Some(Node::Item(hir::Item {\n+                            kind: hir::ItemKind::Trait(\n+                                _, _, _, _,\n+                                items\n+                            ),\n+                            ..\n+                        })) => {\n+                            let mut f_in_trait_opt = None;\n+                            for hir::TraitItemRef { id: fi, kind: k, .. } in *items {\n+                                let hi = fi.hir_id();\n+                                if !matches!(k, hir::AssocItemKind::Fn { .. }) {\n+                                    continue;\n+                                }\n+                                if hir_map.name(hi) != hir_map.name(my_hir) {\n+                                    continue;\n+                                }\n+                                f_in_trait_opt = Some(hi);\n+                                break;\n+                            }\n+                            f_in_trait_opt.and_then(|f_in_trait| {\n+                                match hir_map.find(f_in_trait) {\n+                                    Some(Node::TraitItem(hir::TraitItem {\n+                                        kind: hir::TraitItemKind::Fn(hir::FnSig {\n+                                            decl: hir::FnDecl {\n+                                                inputs,\n+                                                ..\n+                                            },\n+                                            ..\n+                                        }, _),\n+                                        ..\n+                                    })) => {\n+                                        let hir::Ty { span, .. } = inputs[local.index() - 1];\n+                                        Some(span)\n+                                    },\n+                                    _ => None,\n+                                }\n+                            })\n+                        }\n+                        _ => None\n+                    }\n+                }))\n+            }\n+            _ => (false, None),\n+        }\n+    }\n \n     // point to span of upvar making closure call require mutable borrow\n     fn show_mutating_upvar("}]}