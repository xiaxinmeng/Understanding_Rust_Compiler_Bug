{"sha": "ebf0e9698d6d38c8d43e618d3adc86016724f872", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZjBlOTY5OGQ2ZDM4YzhkNDNlNjE4ZDNhZGM4NjAxNjcyNGY4NzI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T08:03:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T17:26:40Z"}, "message": "rollup merge of #19651: Gankro/ptr-docs\n\nr? @steveklabnik @thestinger", "tree": {"sha": "efd1c387b2c3555400eecd66d8ccefba8f117b53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efd1c387b2c3555400eecd66d8ccefba8f117b53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebf0e9698d6d38c8d43e618d3adc86016724f872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebf0e9698d6d38c8d43e618d3adc86016724f872", "html_url": "https://github.com/rust-lang/rust/commit/ebf0e9698d6d38c8d43e618d3adc86016724f872", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebf0e9698d6d38c8d43e618d3adc86016724f872/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c141f223d4fd4d8c8be8649877e08ddceaa43783", "url": "https://api.github.com/repos/rust-lang/rust/commits/c141f223d4fd4d8c8be8649877e08ddceaa43783", "html_url": "https://github.com/rust-lang/rust/commit/c141f223d4fd4d8c8be8649877e08ddceaa43783"}, {"sha": "ce10c0114fca9d9e19a40fca184344db9273a161", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce10c0114fca9d9e19a40fca184344db9273a161", "html_url": "https://github.com/rust-lang/rust/commit/ce10c0114fca9d9e19a40fca184344db9273a161"}], "stats": {"total": 134, "additions": 94, "deletions": 40}, "files": [{"sha": "950c47c636987082964acdc9c679c0da12994cac", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ebf0e9698d6d38c8d43e618d3adc86016724f872/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebf0e9698d6d38c8d43e618d3adc86016724f872/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=ebf0e9698d6d38c8d43e618d3adc86016724f872", "patch": "@@ -222,7 +222,7 @@ extern \"rust-intrinsic\" {\n     /// Both types must have the same size and alignment, and this guarantee\n     /// is enforced at compile-time.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::mem;\n@@ -253,14 +253,20 @@ extern \"rust-intrinsic\" {\n     /// integer, since the conversion would throw away aliasing information.\n     pub fn offset<T>(dst: *const T, offset: int) -> *const T;\n \n-    /// Copies data from one location to another.\n-    ///\n-    /// Copies `count` elements (not bytes) from `src` to `dst`. The source\n+    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may *not* overlap.\n     ///\n     /// `copy_nonoverlapping_memory` is semantically equivalent to C's `memcpy`.\n     ///\n-    /// # Example\n+    /// # Safety\n+    ///\n+    /// Beyond requiring that both regions of memory be allocated, it is Undefined Behaviour\n+    /// for source and destination to overlap. Care must also be taken with the ownership of\n+    /// `src` and `dst`. This method semantically moves the values of `src` into `dst`.\n+    /// However it does not drop the contents of `dst`, or prevent the contents of `src`\n+    /// from being dropped or used.\n+    ///\n+    /// # Examples\n     ///\n     /// A safe swap function:\n     ///\n@@ -284,22 +290,22 @@ extern \"rust-intrinsic\" {\n     ///     }\n     /// }\n     /// ```\n-    ///\n-    /// # Safety Note\n-    ///\n-    /// If the source and destination overlap then the behavior of this\n-    /// function is undefined.\n     #[unstable]\n     pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n-    /// Copies data from one location to another.\n-    ///\n-    /// Copies `count` elements (not bytes) from `src` to `dst`. The source\n+    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n     ///\n     /// `copy_memory` is semantically equivalent to C's `memmove`.\n     ///\n-    /// # Example\n+    /// # Safety\n+    ///\n+    /// Care must be taken with the ownership of `src` and `dst`.\n+    /// This method semantically moves the values of `src` into `dst`.\n+    /// However it does not drop the contents of `dst`, or prevent the contents of `src`\n+    /// from being dropped or used.\n+    ///\n+    /// # Examples\n     ///\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///"}, {"sha": "d9d90bf77c2a31c38bb11dbf57dfdef6603cf3d2", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 74, "deletions": 26, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ebf0e9698d6d38c8d43e618d3adc86016724f872/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebf0e9698d6d38c8d43e618d3adc86016724f872/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=ebf0e9698d6d38c8d43e618d3adc86016724f872", "patch": "@@ -97,13 +97,20 @@ use cmp::{PartialEq, Eq, Ord, PartialOrd, Equiv};\n use cmp::Ordering;\n use cmp::Ordering::{Less, Equal, Greater};\n \n-pub use intrinsics::copy_memory;\n+// FIXME #19649: instrinsic docs don't render, so these have no docs :(\n+\n+#[unstable]\n pub use intrinsics::copy_nonoverlapping_memory;\n+\n+#[unstable]\n+pub use intrinsics::copy_memory;\n+\n+#[experimental = \"uncertain about naming and semantics\"]\n pub use intrinsics::set_memory;\n \n-/// Create a null pointer.\n+/// Creates a null raw pointer.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::ptr;\n@@ -115,9 +122,9 @@ pub use intrinsics::set_memory;\n #[unstable = \"may need a different name after pending changes to pointer types\"]\n pub fn null<T>() -> *const T { 0 as *const T }\n \n-/// Create an unsafe mutable null pointer.\n+/// Creates a null mutable raw pointer.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::ptr;\n@@ -129,16 +136,26 @@ pub fn null<T>() -> *const T { 0 as *const T }\n #[unstable = \"may need a different name after pending changes to pointer types\"]\n pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n-/// Zeroes out `count * size_of::<T>` bytes of memory at `dst`\n+/// Zeroes out `count * size_of::<T>` bytes of memory at `dst`. `count` may be `0`.\n+///\n+/// # Safety\n+///\n+/// Beyond accepting a raw pointer, this is unsafe because it will not drop the contents of `dst`,\n+/// and may be used to create invalid instances of `T`.\n #[inline]\n #[experimental = \"uncertain about naming and semantics\"]\n #[allow(experimental)]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n     set_memory(dst, 0, count);\n }\n \n-/// Swap the values at two mutable locations of the same type, without\n-/// deinitialising either. They may overlap.\n+/// Swaps the values at two mutable locations of the same type, without\n+/// deinitialising either. They may overlap, unlike `mem::swap` which is otherwise\n+/// equivalent.\n+///\n+/// # Safety\n+///\n+/// This is only unsafe because it accepts a raw pointer.\n #[inline]\n #[unstable]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n@@ -156,16 +173,31 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     mem::forget(tmp);\n }\n \n-/// Replace the value at a mutable location with a new one, returning the old\n-/// value, without deinitialising either.\n+/// Replaces the value at `dest` with `src`, returning the old\n+/// value, without dropping either.\n+///\n+/// # Safety\n+///\n+/// This is only unsafe because it accepts a raw pointer.\n+/// Otherwise, this operation is identical to `mem::replace`.\n #[inline]\n #[unstable]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     mem::swap(mem::transmute(dest), &mut src); // cannot overlap\n     src\n }\n \n-/// Reads the value from `*src` and returns it.\n+/// Reads the value from `src` without dropping it. This leaves the\n+/// memory in `src` unchanged.\n+///\n+/// # Safety\n+///\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n #[inline(always)]\n #[unstable]\n pub unsafe fn read<T>(src: *const T) -> T {\n@@ -174,8 +206,11 @@ pub unsafe fn read<T>(src: *const T) -> T {\n     tmp\n }\n \n-/// Reads the value from `*src` and nulls it out.\n-/// This currently prevents destructors from executing.\n+/// Reads the value from `src` and nulls it out without dropping it.\n+///\n+/// # Safety\n+///\n+/// This is unsafe for the same reasons that `read` is unsafe.\n #[inline(always)]\n #[experimental]\n #[allow(experimental)]\n@@ -189,12 +224,17 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     tmp\n }\n \n-/// Unsafely overwrite a memory location with the given value without destroying\n+/// Overwrites a memory location with the given value without reading or dropping\n /// the old value.\n ///\n-/// This operation is unsafe because it does not destroy the previous value\n-/// contained at the location `dst`. This could leak allocations or resources,\n-/// so care must be taken to previously deallocate the value at `dst`.\n+/// # Safety\n+///\n+/// Beyond accepting a raw pointer, this operation is unsafe because it does\n+/// not drop the contents of `dst`. This could leak allocations or resources,\n+/// so care must be taken not to overwrite an object that should be dropped.\n+///\n+/// This is appropriate for initializing uninitialized memory, or overwritting memory\n+/// that has previously been `read` from.\n #[inline]\n #[unstable]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n@@ -203,39 +243,47 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n \n /// Methods on raw pointers\n pub trait RawPtr<T> {\n-    /// Returns the null pointer.\n+    /// Returns a null raw pointer.\n     fn null() -> Self;\n \n-    /// Returns true if the pointer is equal to the null pointer.\n+    /// Returns true if the pointer is null.\n     fn is_null(&self) -> bool;\n \n-    /// Returns true if the pointer is not equal to the null pointer.\n+    /// Returns true if the pointer is not null.\n     fn is_not_null(&self) -> bool { !self.is_null() }\n \n-    /// Returns the value of this pointer (ie, the address it points to)\n+    /// Returns the address of the pointer.\n     fn to_uint(&self) -> uint;\n \n     /// Returns `None` if the pointer is null, or else returns a reference to the\n     /// value wrapped in `Some`.\n     ///\n-    /// # Safety Notes\n+    /// # Safety\n     ///\n     /// While this method and its mutable counterpart are useful for null-safety,\n     /// it is important to note that this is still an unsafe operation because\n     /// the returned value could be pointing to invalid memory.\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T>;\n \n-    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n-    /// the object, or one-byte-past-the-end.  `count` is in units of T; e.g. a\n+    /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n     /// `count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The offset must be in-bounds of the object, or one-byte-past-the-end. Otherwise\n+    /// `offset` invokes Undefined Behaviour, regardless of whether the pointer is used.\n     unsafe fn offset(self, count: int) -> Self;\n }\n \n /// Methods on mutable raw pointers\n pub trait RawMutPtr<T>{\n     /// Returns `None` if the pointer is null, or else returns a mutable reference\n-    /// to the value wrapped in `Some`. As with `as_ref`, this is unsafe because\n-    /// it cannot verify the validity of the returned pointer.\n+    /// to the value wrapped in `Some`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with `as_ref`, this is unsafe because it cannot verify the validity\n+    /// of the returned pointer.\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut T>;\n }\n "}]}