{"sha": "c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NGZkYjhiM2VkZTkwZGI3YWZmN2JlYWFhOTAwMTRiMGM1ZTk2YmE=", "commit": {"author": {"name": "vlakreeh", "email": "zeb@zebulon.dev", "date": "2020-09-29T18:48:43Z"}, "committer": {"name": "vlakreeh", "email": "zeb@zebulon.dev", "date": "2020-09-29T18:48:43Z"}, "message": "Add convert integer literal assist", "tree": {"sha": "9717f547b8242f66d6b1cc3d84e07f0c80ded441", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9717f547b8242f66d6b1cc3d84e07f0c80ded441"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba", "html_url": "https://github.com/rust-lang/rust/commit/c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba/comments", "author": {"login": "zebp", "id": 14242997, "node_id": "MDQ6VXNlcjE0MjQyOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/14242997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zebp", "html_url": "https://github.com/zebp", "followers_url": "https://api.github.com/users/zebp/followers", "following_url": "https://api.github.com/users/zebp/following{/other_user}", "gists_url": "https://api.github.com/users/zebp/gists{/gist_id}", "starred_url": "https://api.github.com/users/zebp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zebp/subscriptions", "organizations_url": "https://api.github.com/users/zebp/orgs", "repos_url": "https://api.github.com/users/zebp/repos", "events_url": "https://api.github.com/users/zebp/events{/privacy}", "received_events_url": "https://api.github.com/users/zebp/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zebp", "id": 14242997, "node_id": "MDQ6VXNlcjE0MjQyOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/14242997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zebp", "html_url": "https://github.com/zebp", "followers_url": "https://api.github.com/users/zebp/followers", "following_url": "https://api.github.com/users/zebp/following{/other_user}", "gists_url": "https://api.github.com/users/zebp/gists{/gist_id}", "starred_url": "https://api.github.com/users/zebp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zebp/subscriptions", "organizations_url": "https://api.github.com/users/zebp/orgs", "repos_url": "https://api.github.com/users/zebp/repos", "events_url": "https://api.github.com/users/zebp/events{/privacy}", "received_events_url": "https://api.github.com/users/zebp/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e315fd9bb0e0647ab8b0e118d264d2103e271586", "url": "https://api.github.com/repos/rust-lang/rust/commits/e315fd9bb0e0647ab8b0e118d264d2103e271586", "html_url": "https://github.com/rust-lang/rust/commit/e315fd9bb0e0647ab8b0e118d264d2103e271586"}], "stats": {"total": 150, "additions": 150, "deletions": 0}, "files": [{"sha": "889f5d03069890b689b6d2e2fad713e59d16603a", "filename": "crates/assists/src/handlers/convert_integer_literal.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba/crates%2Fassists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba/crates%2Fassists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs?ref=c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba", "patch": "@@ -0,0 +1,135 @@\n+use syntax::{ast, AstNode, SmolStr};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n+\n+// Assist: convert_integer_literal\n+//\n+// Converts the base of integer literals to other bases.\n+//\n+// ```\n+// const _: i32 = 10<|>;\n+// ```\n+// ->\n+// ```\n+// const _: i32 = 0b1010;\n+// ```\n+pub(crate) fn convert_integer_literal(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let literal = ctx.find_node_at_offset::<ast::Literal>()?;\n+    let range = literal.syntax().text_range();\n+    let group_id = GroupLabel(\"Convert integer base\".into());\n+\n+    let suffix = match literal.kind() {\n+        ast::LiteralKind::IntNumber { suffix } => suffix,\n+        _ => return None,\n+    };\n+    let suffix_len = suffix.as_ref().map(|s| s.len()).unwrap_or(0);\n+    let raw_literal_text = literal.syntax().to_string();\n+\n+    // Gets the literal's text without the type suffix and without underscores.\n+    let literal_text = raw_literal_text\n+        .chars()\n+        .take(raw_literal_text.len() - suffix_len)\n+        .filter(|c| *c != '_')\n+        .collect::<SmolStr>();\n+    let literal_base = IntegerLiteralBase::identify(&literal_text)?;\n+\n+    for base in IntegerLiteralBase::bases() {\n+        if *base == literal_base {\n+            continue;\n+        }\n+\n+        let mut converted = literal_base.convert(&literal_text, base);\n+\n+        let label = if let Some(suffix) = &suffix {\n+            format!(\"Convert {} ({}) to {}\", &literal_text, suffix, &converted)\n+        } else {\n+            format!(\"Convert {} to {}\", &literal_text, &converted)\n+        };\n+\n+        // Appends the type suffix back into the new literal if it exists.\n+        if let Some(suffix) = &suffix {\n+            converted.push_str(&suffix);\n+        }\n+\n+        acc.add_group(\n+            &group_id,\n+            AssistId(\"convert_integer_literal\", AssistKind::RefactorInline),\n+            label,\n+            range,\n+            |builder| builder.replace(range, converted),\n+        );\n+    }\n+\n+    Some(())\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum IntegerLiteralBase {\n+    Binary,\n+    Octal,\n+    Decimal,\n+    Hexadecimal,\n+}\n+\n+impl IntegerLiteralBase {\n+    fn identify(literal_text: &str) -> Option<Self> {\n+        // We cannot express a literal in anything other than decimal in under 3 characters, so we return here if possible.\n+        if literal_text.len() < 3 && literal_text.chars().all(|c| c.is_digit(10)) {\n+            return Some(Self::Decimal);\n+        }\n+\n+        let base = match &literal_text[..2] {\n+            \"0b\" => Self::Binary,\n+            \"0o\" => Self::Octal,\n+            \"0x\" => Self::Hexadecimal,\n+            _ => Self::Decimal,\n+        };\n+\n+        // Checks that all characters after the base prefix are all valid digits for that base.\n+        if literal_text[base.prefix_len()..]\n+            .chars()\n+            .all(|c| c.is_digit(base.base()))\n+        {\n+            Some(base)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn convert(&self, literal_text: &str, to: &IntegerLiteralBase) -> String {\n+        let digits = &literal_text[self.prefix_len()..];\n+        let value = u128::from_str_radix(digits, self.base()).unwrap();\n+\n+        match to {\n+            Self::Binary => format!(\"0b{:b}\", value),\n+            Self::Octal => format!(\"0o{:o}\", value),\n+            Self::Decimal => value.to_string(),\n+            Self::Hexadecimal => format!(\"0x{:X}\", value),\n+        }\n+    }\n+\n+    const fn base(&self) -> u32 {\n+        match self {\n+            Self::Binary => 2,\n+            Self::Octal => 8,\n+            Self::Decimal => 10,\n+            Self::Hexadecimal => 16,\n+        }\n+    }\n+\n+    const fn prefix_len(&self) -> usize {\n+        match self {\n+            Self::Decimal => 0,\n+            _ => 2,\n+        }\n+    }\n+\n+    const fn bases() -> &'static [IntegerLiteralBase] {\n+        &[\n+            IntegerLiteralBase::Binary,\n+            IntegerLiteralBase::Octal,\n+            IntegerLiteralBase::Decimal,\n+            IntegerLiteralBase::Hexadecimal,\n+        ]\n+    }\n+}"}, {"sha": "a2bec818c1a4590746d2d46541b21a7ac3d5ab3a", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba", "patch": "@@ -128,6 +128,7 @@ mod handlers {\n     mod auto_import;\n     mod change_return_type_to_result;\n     mod change_visibility;\n+    mod convert_integer_literal;\n     mod early_return;\n     mod expand_glob_import;\n     mod extract_struct_from_enum_variant;\n@@ -172,6 +173,7 @@ mod handlers {\n             auto_import::auto_import,\n             change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n+            convert_integer_literal::convert_integer_literal,\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,"}, {"sha": "7f6e98a548cb1bca8cb598a957c4c8e7dd9e76e7", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=c84fdb8b3ede90db7aff7beaaa90014b0c5e96ba", "patch": "@@ -203,6 +203,19 @@ pub(crate) fn frobnicate() {}\n     )\n }\n \n+#[test]\n+fn doctest_convert_integer_literal() {\n+    check_doc_test(\n+        \"convert_integer_literal\",\n+        r#####\"\n+const _: i32 = 10<|>;\n+\"#####,\n+        r#####\"\n+const _: i32 = 0b1010;\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_to_guarded_return() {\n     check_doc_test("}]}