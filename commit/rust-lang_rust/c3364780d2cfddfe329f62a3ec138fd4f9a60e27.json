{"sha": "c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMzY0NzgwZDJjZmRkZmUzMjlmNjJhM2VjMTM4ZmQ0ZjlhNjBlMjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-05T02:24:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-05T02:24:05Z"}, "message": "Auto merge of #75173 - jackh726:chalk-0.21, r=nikomatsakis\n\nUpgrade Chalk to 0.21\n\nTwo commits here. First commit actually does the upgrade. Second commit has some changes to make more tests in compare-mode=chalk pass.\n\nThe `PlaceholdersCollector` and `RegionsSubstitutor` bits are bit a hacky, but only insomuch as `ParamsSubstitutor` is. These won't be needed eventually.\n\nr? @nikomatsakis", "tree": {"sha": "ac119325a2e075c4657d9e6ab72b66f1ca9e62dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac119325a2e075c4657d9e6ab72b66f1ca9e62dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "html_url": "https://github.com/rust-lang/rust/commit/c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70c5f6efc445963bbfa5dd53f81c245741eac8cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/70c5f6efc445963bbfa5dd53f81c245741eac8cb", "html_url": "https://github.com/rust-lang/rust/commit/70c5f6efc445963bbfa5dd53f81c245741eac8cb"}, {"sha": "0aa215305a19fb3bab31b31898ee031cc3e10d7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aa215305a19fb3bab31b31898ee031cc3e10d7c", "html_url": "https://github.com/rust-lang/rust/commit/0aa215305a19fb3bab31b31898ee031cc3e10d7c"}], "stats": {"total": 1236, "additions": 726, "deletions": 510}, "files": [{"sha": "d4e718cb603e889517005972a01a7d07c8ccf304", "filename": "Cargo.lock", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "patch": "@@ -427,9 +427,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.14.0\"\n+version = \"0.21.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d463e01905d607e181de72e8608721d3269f29176c9a14ce037011316ae7131d\"\n+checksum = \"c1df0dbb57d74b4acd20f20fa66ab2acd09776b79eaeb9d8f947b2f3e01c40bf\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -439,40 +439,42 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.14.0\"\n+version = \"0.21.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"efaf428f5398d36284f79690cf988762b7c091249f50a6c11db613a46c057000\"\n+checksum = \"fb7c65a13f32f02aba8f1d9a37f206af615f77ac564624b81a4c593c6c1735b9\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n+ \"chalk-solve\",\n  \"rustc-hash\",\n  \"tracing\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.14.0\"\n+version = \"0.21.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fd3fdc1e9f68498ffe80f4a23b0b95f1ca6fb21d5a4c9b0c085fab3ca712bdbe\"\n+checksum = \"44361a25dbdb1dc428f56ad7a3c21ba9ca12f3225c26a47919ff6fcb10a583d4\"\n dependencies = [\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.14.0\"\n+version = \"0.21.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5b9fd4102807b7ebe8fb034fa0f488c5656e1966d3261b558b81a08d519cdb29\"\n+checksum = \"a886da37a0dc457057d86f78f026f7a09c6d8088aa13f4f4127fdb8dc80119a3\"\n dependencies = [\n  \"chalk-derive\",\n- \"chalk-engine\",\n  \"chalk-ir\",\n  \"ena\",\n  \"itertools 0.9.0\",\n  \"petgraph\",\n  \"rustc-hash\",\n  \"tracing\",\n+ \"tracing-subscriber\",\n+ \"tracing-tree\",\n ]\n \n [[package]]\n@@ -4038,6 +4040,7 @@ dependencies = [\n name = \"rustc_traits\"\n version = \"0.0.0\"\n dependencies = [\n+ \"chalk-engine\",\n  \"chalk-ir\",\n  \"chalk-solve\",\n  \"rustc_ast\",\n@@ -4996,21 +4999,61 @@ dependencies = [\n  \"lazy_static\",\n ]\n \n+[[package]]\n+name = \"tracing-log\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5e0f8c7178e13481ff6765bd169b33e8d554c5d2bbede5e32c356194be02b9b9\"\n+dependencies = [\n+ \"lazy_static\",\n+ \"log\",\n+ \"tracing-core\",\n+]\n+\n+[[package]]\n+name = \"tracing-serde\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b6ccba2f8f16e0ed268fc765d9b7ff22e965e7185d32f8f1ec8294fe17d86e79\"\n+dependencies = [\n+ \"serde\",\n+ \"tracing-core\",\n+]\n+\n [[package]]\n name = \"tracing-subscriber\"\n version = \"0.2.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"abd165311cc4d7a555ad11cc77a37756df836182db0d81aac908c8184c584f40\"\n dependencies = [\n  \"ansi_term 0.12.1\",\n+ \"chrono\",\n  \"lazy_static\",\n  \"matchers\",\n  \"parking_lot 0.11.0\",\n  \"regex\",\n+ \"serde\",\n+ \"serde_json\",\n  \"sharded-slab\",\n  \"smallvec 1.4.2\",\n  \"thread_local\",\n  \"tracing-core\",\n+ \"tracing-log\",\n+ \"tracing-serde\",\n+]\n+\n+[[package]]\n+name = \"tracing-tree\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e1a3dc4774db3a6b2d66a4f8d8de670e874ec3ed55615860c994927419b32c5f\"\n+dependencies = [\n+ \"ansi_term 0.12.1\",\n+ \"atty\",\n+ \"chrono\",\n+ \"termcolor\",\n+ \"tracing\",\n+ \"tracing-subscriber\",\n ]\n \n [[package]]"}, {"sha": "302a907538c84ea6f3f3beec6b233c68b4024917", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "patch": "@@ -27,7 +27,7 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n byteorder = { version = \"1.3\" }\n-chalk-ir = \"0.14.0\"\n+chalk-ir = \"0.21.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.7.1\"\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "763b078e7703ed135fc7dcdae44a8753082616b1", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "patch": "@@ -75,6 +75,7 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n     type InternedQuantifiedWhereClauses = Vec<chalk_ir::QuantifiedWhereClause<Self>>;\n     type InternedVariableKinds = Vec<chalk_ir::VariableKind<Self>>;\n     type InternedCanonicalVarKinds = Vec<chalk_ir::CanonicalVarKind<Self>>;\n+    type InternedConstraints = Vec<chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>>;\n     type DefId = DefId;\n     type InternedAdtId = &'tcx AdtDef;\n     type Identifier = ();\n@@ -108,8 +109,42 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         application_ty: &chalk_ir::ApplicationTy<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n-        Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n+        match application_ty.name {\n+            chalk_ir::TypeName::Ref(mutbl) => {\n+                let data = application_ty.substitution.interned();\n+                match (&**data[0].interned(), &**data[1].interned()) {\n+                    (\n+                        chalk_ir::GenericArgData::Lifetime(lifetime),\n+                        chalk_ir::GenericArgData::Ty(ty),\n+                    ) => Some(match mutbl {\n+                        chalk_ir::Mutability::Not => write!(fmt, \"(&{:?} {:?})\", lifetime, ty),\n+                        chalk_ir::Mutability::Mut => write!(fmt, \"(&{:?} mut {:?})\", lifetime, ty),\n+                    }),\n+                    _ => unreachable!(),\n+                }\n+            }\n+            chalk_ir::TypeName::Array => {\n+                let data = application_ty.substitution.interned();\n+                match (&**data[0].interned(), &**data[1].interned()) {\n+                    (chalk_ir::GenericArgData::Ty(ty), chalk_ir::GenericArgData::Const(len)) => {\n+                        Some(write!(fmt, \"[{:?}; {:?}]\", ty, len))\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+            chalk_ir::TypeName::Slice => {\n+                let data = application_ty.substitution.interned();\n+                let ty = match &**data[0].interned() {\n+                    chalk_ir::GenericArgData::Ty(t) => t,\n+                    _ => unreachable!(),\n+                };\n+                Some(write!(fmt, \"[{:?}]\", ty))\n+            }\n+            _ => {\n+                let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n+                Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n+            }\n+        }\n     }\n \n     fn debug_substitution(\n@@ -321,6 +356,20 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n     ) -> &'a [chalk_ir::CanonicalVarKind<Self>] {\n         canonical_var_kinds\n     }\n+\n+    fn intern_constraints<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>, E>>,\n+    ) -> Result<Self::InternedConstraints, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn constraints_data<'a>(\n+        &self,\n+        constraints: &'a Self::InternedConstraints,\n+    ) -> &'a [chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>] {\n+        constraints\n+    }\n }\n \n impl<'tcx> chalk_ir::interner::HasInterner for RustInterner<'tcx> {"}, {"sha": "3571ff17f31be1abe06ce9f38472524959974df3", "filename": "compiler/rustc_traits/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2FCargo.toml?ref=c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "patch": "@@ -12,8 +12,9 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-chalk-ir = \"0.14.0\"\n-chalk-solve = \"0.14.0\"\n+chalk-ir = \"0.21.0\"\n+chalk-solve = \"0.21.0\"\n+chalk-engine = \"0.21.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "7cc567dabb28f7f59daaaab5a96670b1428a54f5", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 171, "deletions": 172, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "patch": "@@ -8,20 +8,22 @@\n \n use rustc_middle::traits::ChalkRustInterner as RustInterner;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, AssocItemContainer, AssocKind, TyCtxt};\n+use rustc_middle::ty::{self, AssocItemContainer, AssocKind, TyCtxt, TypeFoldable};\n \n use rustc_hir::def_id::DefId;\n+use rustc_hir::Unsafety;\n \n use rustc_span::symbol::sym;\n \n use std::fmt;\n use std::sync::Arc;\n \n-use crate::chalk::lowering::LowerInto;\n+use crate::chalk::lowering::{self, LowerInto};\n \n pub struct RustIrDatabase<'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub interner: RustInterner<'tcx>,\n+    pub(crate) interner: RustInterner<'tcx>,\n+    pub(crate) restatic_placeholder: ty::Region<'tcx>,\n+    pub(crate) reempty_placeholder: ty::Region<'tcx>,\n }\n \n impl fmt::Debug for RustIrDatabase<'_> {\n@@ -30,6 +32,26 @@ impl fmt::Debug for RustIrDatabase<'_> {\n     }\n }\n \n+impl<'tcx> RustIrDatabase<'tcx> {\n+    fn where_clauses_for(\n+        &self,\n+        def_id: DefId,\n+        bound_vars: SubstsRef<'tcx>,\n+    ) -> Vec<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n+        let predicates = self.interner.tcx.predicates_of(def_id).predicates;\n+        let mut regions_substitutor = lowering::RegionsSubstitutor::new(\n+            self.interner.tcx,\n+            self.restatic_placeholder,\n+            self.reempty_placeholder,\n+        );\n+        predicates\n+            .iter()\n+            .map(|(wc, _)| wc.subst(self.interner.tcx, bound_vars))\n+            .map(|wc| wc.fold_with(&mut regions_substitutor))\n+            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect()\n+    }\n+}\n+\n impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'tcx> {\n     fn interner(&self) -> &RustInterner<'tcx> {\n         &self.interner\n@@ -40,7 +62,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         assoc_type_id: chalk_ir::AssocTypeId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::AssociatedTyDatum<RustInterner<'tcx>>> {\n         let def_id = assoc_type_id.0;\n-        let assoc_item = self.tcx.associated_item(def_id);\n+        let assoc_item = self.interner.tcx.associated_item(def_id);\n         let trait_def_id = match assoc_item.container {\n             AssocItemContainer::TraitContainer(def_id) => def_id,\n             _ => unimplemented!(\"Not possible??\"),\n@@ -49,16 +71,12 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             AssocKind::Type => {}\n             _ => unimplemented!(\"Not possible??\"),\n         }\n-        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n         // FIXME(chalk): this really isn't right I don't think. The functions\n         // for GATs are a bit hard to figure out. Are these supposed to be where\n         // clauses or bounds?\n-        let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n-        let where_clauses: Vec<_> = predicates\n-            .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+        let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n         Arc::new(chalk_solve::rust_ir::AssociatedTyDatum {\n             trait_id: chalk_ir::TraitId(trait_def_id),\n@@ -76,41 +94,63 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::TraitDatum<RustInterner<'tcx>>> {\n         let def_id = trait_id.0;\n-        let trait_def = self.tcx.trait_def(def_id);\n+        let trait_def = self.interner.tcx.trait_def(def_id);\n \n-        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n-        let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n-        let where_clauses: Vec<_> = predicates\n-            .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+\n+        let where_clauses = self.where_clauses_for(def_id, bound_vars);\n+\n         let associated_ty_ids: Vec<_> = self\n+            .interner\n             .tcx\n             .associated_items(def_id)\n             .in_definition_order()\n             .filter(|i| i.kind == AssocKind::Type)\n             .map(|i| chalk_ir::AssocTypeId(i.def_id))\n             .collect();\n \n-        let well_known =\n-            if self.tcx.lang_items().sized_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::Sized)\n-            } else if self.tcx.lang_items().copy_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::Copy)\n-            } else if self.tcx.lang_items().clone_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::Clone)\n-            } else if self.tcx.lang_items().drop_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::Drop)\n-            } else if self.tcx.lang_items().fn_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::Fn)\n-            } else if self.tcx.lang_items().fn_once_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::FnOnce)\n-            } else if self.tcx.lang_items().fn_mut_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::FnMut)\n-            } else {\n-                None\n-            };\n+        let well_known = if self\n+            .interner\n+            .tcx\n+            .lang_items()\n+            .sized_trait()\n+            .map(|t| def_id == t)\n+            .unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Sized)\n+        } else if self.interner.tcx.lang_items().copy_trait().map(|t| def_id == t).unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Copy)\n+        } else if self.interner.tcx.lang_items().clone_trait().map(|t| def_id == t).unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Clone)\n+        } else if self.interner.tcx.lang_items().drop_trait().map(|t| def_id == t).unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Drop)\n+        } else if self.interner.tcx.lang_items().fn_trait().map(|t| def_id == t).unwrap_or(false) {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Fn)\n+        } else if self\n+            .interner\n+            .tcx\n+            .lang_items()\n+            .fn_once_trait()\n+            .map(|t| def_id == t)\n+            .unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::FnOnce)\n+        } else if self\n+            .interner\n+            .tcx\n+            .lang_items()\n+            .fn_mut_trait()\n+            .map(|t| def_id == t)\n+            .unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::FnMut)\n+        } else {\n+            None\n+        };\n         Arc::new(chalk_solve::rust_ir::TraitDatum {\n             id: trait_id,\n             binders: chalk_ir::Binders::new(\n@@ -121,7 +161,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 auto: trait_def.has_auto_impl,\n                 marker: trait_def.is_marker,\n                 upstream: !def_id.is_local(),\n-                fundamental: self.tcx.has_attr(def_id, sym::fundamental),\n+                fundamental: self.interner.tcx.has_attr(def_id, sym::fundamental),\n                 non_enumerable: true,\n                 coinductive: false,\n             },\n@@ -136,76 +176,76 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Arc<chalk_solve::rust_ir::AdtDatum<RustInterner<'tcx>>> {\n         let adt_def = adt_id.0;\n \n-        let bound_vars = bound_vars_for_item(self.tcx, adt_def.did);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, adt_def.did);\n         let binders = binders_for(&self.interner, bound_vars);\n \n-        let predicates = self.tcx.predicates_of(adt_def.did).predicates;\n-        let where_clauses: Vec<_> = predicates\n+        let where_clauses = self.where_clauses_for(adt_def.did, bound_vars);\n+\n+        let variants: Vec<_> = adt_def\n+            .variants\n             .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner))\n-            .collect();\n-        let fields = match adt_def.adt_kind() {\n-            ty::AdtKind::Struct | ty::AdtKind::Union => {\n-                let variant = adt_def.non_enum_variant();\n-                variant\n+            .map(|variant| chalk_solve::rust_ir::AdtVariantDatum {\n+                fields: variant\n                     .fields\n                     .iter()\n-                    .map(|field| {\n-                        self.tcx\n-                            .type_of(field.did)\n-                            .subst(self.tcx, bound_vars)\n-                            .lower_into(&self.interner)\n-                    })\n-                    .collect()\n-            }\n-            // FIXME(chalk): handle enums; force_impl_for requires this\n-            ty::AdtKind::Enum => vec![],\n-        };\n-        let struct_datum = Arc::new(chalk_solve::rust_ir::AdtDatum {\n+                    .map(|field| field.ty(self.interner.tcx, bound_vars).lower_into(&self.interner))\n+                    .collect(),\n+            })\n+            .collect();\n+        Arc::new(chalk_solve::rust_ir::AdtDatum {\n             id: adt_id,\n             binders: chalk_ir::Binders::new(\n                 binders,\n-                chalk_solve::rust_ir::AdtDatumBound { fields, where_clauses },\n+                chalk_solve::rust_ir::AdtDatumBound { variants, where_clauses },\n             ),\n             flags: chalk_solve::rust_ir::AdtFlags {\n                 upstream: !adt_def.did.is_local(),\n                 fundamental: adt_def.is_fundamental(),\n                 phantom_data: adt_def.is_phantom_data(),\n             },\n-        });\n-        struct_datum\n+            kind: match adt_def.adt_kind() {\n+                ty::AdtKind::Struct => chalk_solve::rust_ir::AdtKind::Struct,\n+                ty::AdtKind::Union => chalk_solve::rust_ir::AdtKind::Union,\n+                ty::AdtKind::Enum => chalk_solve::rust_ir::AdtKind::Enum,\n+            },\n+        })\n+    }\n+\n+    fn adt_repr(\n+        &self,\n+        adt_id: chalk_ir::AdtId<RustInterner<'tcx>>,\n+    ) -> chalk_solve::rust_ir::AdtRepr {\n+        let adt_def = adt_id.0;\n+        chalk_solve::rust_ir::AdtRepr {\n+            repr_c: adt_def.repr.c(),\n+            repr_packed: adt_def.repr.packed(),\n+        }\n     }\n \n     fn fn_def_datum(\n         &self,\n         fn_def_id: chalk_ir::FnDefId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::FnDefDatum<RustInterner<'tcx>>> {\n         let def_id = fn_def_id.0;\n-        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n \n-        let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n-        let where_clauses: Vec<_> = predicates\n-            .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+        let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n-        let sig = self.tcx.fn_sig(def_id);\n-        let inputs_and_output = sig.inputs_and_output();\n+        let sig = self.interner.tcx.fn_sig(def_id);\n         let (inputs_and_output, iobinders, _) = crate::chalk::lowering::collect_bound_vars(\n             &self.interner,\n-            self.tcx,\n-            &inputs_and_output,\n+            self.interner.tcx,\n+            &sig.inputs_and_output().subst(self.interner.tcx, bound_vars),\n         );\n \n         let argument_types = inputs_and_output[..inputs_and_output.len() - 1]\n             .iter()\n-            .map(|t| t.subst(self.tcx, &bound_vars).lower_into(&self.interner))\n+            .map(|t| t.subst(self.interner.tcx, &bound_vars).lower_into(&self.interner))\n             .collect();\n \n         let return_type = inputs_and_output[inputs_and_output.len() - 1]\n-            .subst(self.tcx, &bound_vars)\n+            .subst(self.interner.tcx, &bound_vars)\n             .lower_into(&self.interner);\n \n         let bound = chalk_solve::rust_ir::FnDefDatumBound {\n@@ -218,6 +258,11 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         Arc::new(chalk_solve::rust_ir::FnDefDatum {\n             id: fn_def_id,\n             abi: sig.abi(),\n+            safety: match sig.unsafety() {\n+                Unsafety::Normal => chalk_ir::Safety::Safe,\n+                Unsafety::Unsafe => chalk_ir::Safety::Unsafe,\n+            },\n+            variadic: sig.c_variadic(),\n             binders: chalk_ir::Binders::new(binders, bound),\n         })\n     }\n@@ -227,17 +272,19 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         impl_id: chalk_ir::ImplId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::ImplDatum<RustInterner<'tcx>>> {\n         let def_id = impl_id.0;\n-        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n \n-        let trait_ref = self.tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n-        let trait_ref = trait_ref.subst(self.tcx, bound_vars);\n+        let trait_ref = self.interner.tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+        let trait_ref = trait_ref.subst(self.interner.tcx, bound_vars);\n+        let mut regions_substitutor = lowering::RegionsSubstitutor::new(\n+            self.interner.tcx,\n+            self.restatic_placeholder,\n+            self.reempty_placeholder,\n+        );\n+        let trait_ref = trait_ref.fold_with(&mut regions_substitutor);\n \n-        let predicates = self.tcx.predicates_of(def_id).predicates;\n-        let where_clauses: Vec<_> = predicates\n-            .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+        let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n         let value = chalk_solve::rust_ir::ImplDatumBound {\n             trait_ref: trait_ref.lower_into(&self.interner),\n@@ -256,21 +303,28 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         &self,\n         trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n         parameters: &[chalk_ir::GenericArg<RustInterner<'tcx>>],\n+        _binders: &chalk_ir::CanonicalVarKinds<RustInterner<'tcx>>,\n     ) -> Vec<chalk_ir::ImplId<RustInterner<'tcx>>> {\n         let def_id = trait_id.0;\n \n         // FIXME(chalk): use TraitDef::for_each_relevant_impl, but that will\n         // require us to be able to interconvert `Ty<'tcx>`, and we're\n         // not there yet.\n \n-        let all_impls = self.tcx.all_impls(def_id);\n+        let all_impls = self.interner.tcx.all_impls(def_id);\n         let matched_impls = all_impls.filter(|impl_def_id| {\n             use chalk_ir::could_match::CouldMatch;\n-            let trait_ref = self.tcx.impl_trait_ref(*impl_def_id).unwrap();\n-            let bound_vars = bound_vars_for_item(self.tcx, *impl_def_id);\n+            let trait_ref = self.interner.tcx.impl_trait_ref(*impl_def_id).unwrap();\n+            let bound_vars = bound_vars_for_item(self.interner.tcx, *impl_def_id);\n \n             let self_ty = trait_ref.self_ty();\n-            let self_ty = self_ty.subst(self.tcx, bound_vars);\n+            let self_ty = self_ty.subst(self.interner.tcx, bound_vars);\n+            let mut regions_substitutor = lowering::RegionsSubstitutor::new(\n+                self.interner.tcx,\n+                self.restatic_placeholder,\n+                self.reempty_placeholder,\n+            );\n+            let self_ty = self_ty.fold_with(&mut regions_substitutor);\n             let lowered_ty = self_ty.lower_into(&self.interner);\n \n             parameters[0].assert_ty_ref(&self.interner).could_match(&self.interner, &lowered_ty)\n@@ -287,9 +341,9 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> bool {\n         let trait_def_id = auto_trait_id.0;\n         let adt_def = adt_id.0;\n-        let all_impls = self.tcx.all_impls(trait_def_id);\n+        let all_impls = self.interner.tcx.all_impls(trait_def_id);\n         for impl_def_id in all_impls {\n-            let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n+            let trait_ref = self.interner.tcx.impl_trait_ref(impl_def_id).unwrap();\n             let self_ty = trait_ref.self_ty();\n             match *self_ty.kind() {\n                 ty::Adt(impl_adt_def, _) => {\n@@ -308,7 +362,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         associated_ty_id: chalk_solve::rust_ir::AssociatedTyValueId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::AssociatedTyValue<RustInterner<'tcx>>> {\n         let def_id = associated_ty_id.0;\n-        let assoc_item = self.tcx.associated_item(def_id);\n+        let assoc_item = self.interner.tcx.associated_item(def_id);\n         let impl_id = match assoc_item.container {\n             AssocItemContainer::TraitContainer(def_id) => def_id,\n             _ => unimplemented!(\"Not possible??\"),\n@@ -317,9 +371,9 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             AssocKind::Type => {}\n             _ => unimplemented!(\"Not possible??\"),\n         }\n-        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n-        let ty = self.tcx.type_of(def_id);\n+        let ty = self.interner.tcx.type_of(def_id);\n \n         Arc::new(chalk_solve::rust_ir::AssociatedTyValue {\n             impl_id: chalk_ir::ImplId(impl_id),\n@@ -346,78 +400,20 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         &self,\n         opaque_ty_id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n-        let bound_vars = bound_vars_for_item(self.tcx, opaque_ty_id.0);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, opaque_ty_id.0);\n         let binders = binders_for(&self.interner, bound_vars);\n-        let predicates = self.tcx.predicates_defined_on(opaque_ty_id.0).predicates;\n-        let where_clauses: Vec<_> = predicates\n-            .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+        let where_clauses = self.where_clauses_for(opaque_ty_id.0, bound_vars);\n \n         let value = chalk_solve::rust_ir::OpaqueTyDatumBound {\n-            bounds: chalk_ir::Binders::new(binders, where_clauses),\n+            bounds: chalk_ir::Binders::new(binders.clone(), vec![]),\n+            where_clauses: chalk_ir::Binders::new(binders, where_clauses),\n         };\n         Arc::new(chalk_solve::rust_ir::OpaqueTyDatum {\n             opaque_ty_id,\n-            bound: chalk_ir::Binders::new(chalk_ir::VariableKinds::new(&self.interner), value),\n+            bound: chalk_ir::Binders::empty(&self.interner, value),\n         })\n     }\n \n-    /// Since Chalk can't handle all Rust types currently, we have to handle\n-    /// some specially for now. Over time, these `Some` returns will change to\n-    /// `None` and eventually this function will be removed.\n-    fn force_impl_for(\n-        &self,\n-        well_known: chalk_solve::rust_ir::WellKnownTrait,\n-        ty: &chalk_ir::TyData<RustInterner<'tcx>>,\n-    ) -> Option<bool> {\n-        use chalk_ir::TyData::*;\n-        match well_known {\n-            chalk_solve::rust_ir::WellKnownTrait::Sized => match ty {\n-                Apply(apply) => match apply.name {\n-                    chalk_ir::TypeName::Adt(chalk_ir::AdtId(adt_def)) => match adt_def.adt_kind() {\n-                        ty::AdtKind::Struct | ty::AdtKind::Union => None,\n-                        ty::AdtKind::Enum => {\n-                            let constraint = self.tcx.adt_sized_constraint(adt_def.did);\n-                            if !constraint.0.is_empty() { unimplemented!() } else { Some(true) }\n-                        }\n-                    },\n-                    _ => None,\n-                },\n-                Dyn(_)\n-                | Alias(_)\n-                | Placeholder(_)\n-                | Function(_)\n-                | InferenceVar(_, _)\n-                | BoundVar(_) => None,\n-            },\n-            chalk_solve::rust_ir::WellKnownTrait::Copy\n-            | chalk_solve::rust_ir::WellKnownTrait::Clone => match ty {\n-                Apply(apply) => match apply.name {\n-                    chalk_ir::TypeName::Adt(chalk_ir::AdtId(adt_def)) => match adt_def.adt_kind() {\n-                        ty::AdtKind::Struct | ty::AdtKind::Union => None,\n-                        ty::AdtKind::Enum => {\n-                            let constraint = self.tcx.adt_sized_constraint(adt_def.did);\n-                            if !constraint.0.is_empty() { unimplemented!() } else { Some(true) }\n-                        }\n-                    },\n-                    _ => None,\n-                },\n-                Dyn(_)\n-                | Alias(_)\n-                | Placeholder(_)\n-                | Function(_)\n-                | InferenceVar(_, _)\n-                | BoundVar(_) => None,\n-            },\n-            chalk_solve::rust_ir::WellKnownTrait::Drop => None,\n-            chalk_solve::rust_ir::WellKnownTrait::Fn => None,\n-            chalk_solve::rust_ir::WellKnownTrait::FnMut => None,\n-            chalk_solve::rust_ir::WellKnownTrait::FnOnce => None,\n-            chalk_solve::rust_ir::WellKnownTrait::Unsize => None,\n-        }\n-    }\n-\n     fn program_clauses_for_env(\n         &self,\n         environment: &chalk_ir::Environment<RustInterner<'tcx>>,\n@@ -431,36 +427,39 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Option<chalk_ir::TraitId<RustInterner<'tcx>>> {\n         use chalk_solve::rust_ir::WellKnownTrait::*;\n         let def_id = match well_known_trait {\n-            Sized => self.tcx.lang_items().sized_trait(),\n-            Copy => self.tcx.lang_items().copy_trait(),\n-            Clone => self.tcx.lang_items().clone_trait(),\n-            Drop => self.tcx.lang_items().drop_trait(),\n-            Fn => self.tcx.lang_items().fn_trait(),\n-            FnMut => self.tcx.lang_items().fn_mut_trait(),\n-            FnOnce => self.tcx.lang_items().fn_once_trait(),\n-            Unsize => self.tcx.lang_items().unsize_trait(),\n+            Sized => self.interner.tcx.lang_items().sized_trait(),\n+            Copy => self.interner.tcx.lang_items().copy_trait(),\n+            Clone => self.interner.tcx.lang_items().clone_trait(),\n+            Drop => self.interner.tcx.lang_items().drop_trait(),\n+            Fn => self.interner.tcx.lang_items().fn_trait(),\n+            FnMut => self.interner.tcx.lang_items().fn_mut_trait(),\n+            FnOnce => self.interner.tcx.lang_items().fn_once_trait(),\n+            Unsize => self.interner.tcx.lang_items().unsize_trait(),\n         };\n         def_id.map(chalk_ir::TraitId)\n     }\n \n     fn is_object_safe(&self, trait_id: chalk_ir::TraitId<RustInterner<'tcx>>) -> bool {\n-        self.tcx.is_object_safe(trait_id.0)\n+        self.interner.tcx.is_object_safe(trait_id.0)\n     }\n \n     fn hidden_opaque_type(\n         &self,\n         _id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n     ) -> chalk_ir::Ty<RustInterner<'tcx>> {\n         // FIXME(chalk): actually get hidden ty\n-        self.tcx.mk_ty(ty::Tuple(self.tcx.intern_substs(&[]))).lower_into(&self.interner)\n+        self.interner\n+            .tcx\n+            .mk_ty(ty::Tuple(self.interner.tcx.intern_substs(&[])))\n+            .lower_into(&self.interner)\n     }\n \n     fn closure_kind(\n         &self,\n         _closure_id: chalk_ir::ClosureId<RustInterner<'tcx>>,\n         substs: &chalk_ir::Substitution<RustInterner<'tcx>>,\n     ) -> chalk_solve::rust_ir::ClosureKind {\n-        let kind = &substs.parameters(&self.interner)[substs.len(&self.interner) - 3];\n+        let kind = &substs.as_slice(&self.interner)[substs.len(&self.interner) - 3];\n         match kind.assert_ty_ref(&self.interner).data(&self.interner) {\n             chalk_ir::TyData::Apply(apply) => match apply.name {\n                 chalk_ir::TypeName::Scalar(scalar) => match scalar {\n@@ -484,10 +483,10 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         substs: &chalk_ir::Substitution<RustInterner<'tcx>>,\n     ) -> chalk_ir::Binders<chalk_solve::rust_ir::FnDefInputsAndOutputDatum<RustInterner<'tcx>>>\n     {\n-        let sig = &substs.parameters(&self.interner)[substs.len(&self.interner) - 2];\n+        let sig = &substs.as_slice(&self.interner)[substs.len(&self.interner) - 2];\n         match sig.assert_ty_ref(&self.interner).data(&self.interner) {\n             chalk_ir::TyData::Function(f) => {\n-                let substitution = f.substitution.parameters(&self.interner);\n+                let substitution = f.substitution.as_slice(&self.interner);\n                 let return_type =\n                     substitution.last().unwrap().assert_ty_ref(&self.interner).clone();\n                 // Closure arguments are tupled\n@@ -506,7 +505,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 };\n \n                 chalk_ir::Binders::new(\n-                    chalk_ir::VariableKinds::from(\n+                    chalk_ir::VariableKinds::from_iter(\n                         &self.interner,\n                         (0..f.num_binders).map(|_| chalk_ir::VariableKind::Lifetime),\n                     ),\n@@ -523,7 +522,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         substs: &chalk_ir::Substitution<RustInterner<'tcx>>,\n     ) -> chalk_ir::Binders<chalk_ir::Ty<RustInterner<'tcx>>> {\n         let inputs_and_output = self.closure_inputs_and_output(_closure_id, substs);\n-        let tuple = substs.parameters(&self.interner).last().unwrap().assert_ty_ref(&self.interner);\n+        let tuple = substs.as_slice(&self.interner).last().unwrap().assert_ty_ref(&self.interner);\n         inputs_and_output.map_ref(|_| tuple.clone())\n     }\n \n@@ -532,8 +531,8 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         _closure_id: chalk_ir::ClosureId<RustInterner<'tcx>>,\n         substs: &chalk_ir::Substitution<RustInterner<'tcx>>,\n     ) -> chalk_ir::Substitution<RustInterner<'tcx>> {\n-        let substitution = &substs.parameters(&self.interner)[0..substs.len(&self.interner) - 3];\n-        chalk_ir::Substitution::from(&self.interner, substitution)\n+        let substitution = &substs.as_slice(&self.interner)[0..substs.len(&self.interner) - 3];\n+        chalk_ir::Substitution::from_iter(&self.interner, substitution)\n     }\n }\n \n@@ -573,7 +572,7 @@ fn binders_for<'tcx>(\n     interner: &RustInterner<'tcx>,\n     bound_vars: SubstsRef<'tcx>,\n ) -> chalk_ir::VariableKinds<RustInterner<'tcx>> {\n-    chalk_ir::VariableKinds::from(\n+    chalk_ir::VariableKinds::from_iter(\n         interner,\n         bound_vars.iter().map(|arg| match arg.unpack() {\n             ty::subst::GenericArgKind::Lifetime(_re) => chalk_ir::VariableKind::Lifetime,"}, {"sha": "e89a51a81768d55085a885be1c8f00062f7a49c4", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 395, "deletions": 210, "changes": 605, "blob_url": "https://github.com/rust-lang/rust/blob/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "patch": "@@ -56,7 +56,13 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Substitution<RustInterner<'tcx>>> for Subst\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_ir::Substitution<RustInterner<'tcx>> {\n-        chalk_ir::Substitution::from(interner, self.iter().map(|s| s.lower_into(interner)))\n+        chalk_ir::Substitution::from_iter(interner, self.iter().map(|s| s.lower_into(interner)))\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, SubstsRef<'tcx>> for &chalk_ir::Substitution<RustInterner<'tcx>> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> SubstsRef<'tcx> {\n+        interner.tcx.mk_substs(self.iter(interner).map(|subst| subst.lower_into(interner)))\n     }\n }\n \n@@ -76,78 +82,29 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n-        let clauses = self.environment.into_iter().filter_map(|clause| match clause {\n+        let clauses = self.environment.into_iter().map(|clause| match clause {\n             ChalkEnvironmentClause::Predicate(predicate) => {\n-                // FIXME(chalk): forall\n-                match predicate.bound_atom(interner.tcx).skip_binder() {\n-                    ty::PredicateAtom::Trait(predicate, _) => {\n-                        let predicate = ty::Binder::bind(predicate);\n-                        let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                        Some(\n-                            chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n-                                binders,\n-                                chalk_ir::ProgramClauseImplication {\n-                                    consequence: chalk_ir::DomainGoal::FromEnv(\n-                                        chalk_ir::FromEnv::Trait(\n-                                            predicate.trait_ref.lower_into(interner),\n-                                        ),\n-                                    ),\n-                                    conditions: chalk_ir::Goals::new(interner),\n-                                    priority: chalk_ir::ClausePriority::High,\n-                                },\n-                            ))\n-                            .intern(interner),\n-                        )\n-                    }\n-                    ty::PredicateAtom::RegionOutlives(predicate) => {\n-                        let predicate = ty::Binder::bind(predicate);\n-                        let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                        Some(\n-                            chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n-                                binders,\n-                                chalk_ir::ProgramClauseImplication {\n-                                    consequence: chalk_ir::DomainGoal::Holds(\n-                                        chalk_ir::WhereClause::LifetimeOutlives(\n-                                            chalk_ir::LifetimeOutlives {\n-                                                a: predicate.0.lower_into(interner),\n-                                                b: predicate.1.lower_into(interner),\n-                                            },\n-                                        ),\n-                                    ),\n-                                    conditions: chalk_ir::Goals::new(interner),\n-                                    priority: chalk_ir::ClausePriority::High,\n-                                },\n-                            ))\n-                            .intern(interner),\n-                        )\n-                    }\n-                    // FIXME(chalk): need to add TypeOutlives\n-                    ty::PredicateAtom::TypeOutlives(_) => None,\n-                    ty::PredicateAtom::Projection(predicate) => {\n-                        let predicate = ty::Binder::bind(predicate);\n-                        let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                        Some(\n-                            chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n-                                binders,\n-                                chalk_ir::ProgramClauseImplication {\n-                                    consequence: chalk_ir::DomainGoal::Holds(\n-                                        chalk_ir::WhereClause::AliasEq(\n-                                            predicate.lower_into(interner),\n-                                        ),\n-                                    ),\n-                                    conditions: chalk_ir::Goals::new(interner),\n-                                    priority: chalk_ir::ClausePriority::High,\n-                                },\n-                            ))\n-                            .intern(interner),\n-                        )\n-                    }\n+                let (predicate, binders, _named_regions) =\n+                    collect_bound_vars(interner, interner.tcx, &predicate.bound_atom(interner.tcx));\n+                let consequence = match predicate {\n+                    ty::PredicateAtom::Trait(predicate, _) => chalk_ir::DomainGoal::FromEnv(\n+                        chalk_ir::FromEnv::Trait(predicate.trait_ref.lower_into(interner)),\n+                    ),\n+                    ty::PredicateAtom::RegionOutlives(predicate) => chalk_ir::DomainGoal::Holds(\n+                        chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n+                            a: predicate.0.lower_into(interner),\n+                            b: predicate.1.lower_into(interner),\n+                        }),\n+                    ),\n+                    ty::PredicateAtom::TypeOutlives(predicate) => chalk_ir::DomainGoal::Holds(\n+                        chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n+                            ty: predicate.0.lower_into(interner),\n+                            lifetime: predicate.1.lower_into(interner),\n+                        }),\n+                    ),\n+                    ty::PredicateAtom::Projection(predicate) => chalk_ir::DomainGoal::Holds(\n+                        chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)),\n+                    ),\n                     ty::PredicateAtom::WellFormed(..)\n                     | ty::PredicateAtom::ObjectSafe(..)\n                     | ty::PredicateAtom::ClosureKind(..)\n@@ -156,27 +113,35 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                     | ty::PredicateAtom::ConstEquate(..) => {\n                         bug!(\"unexpected predicate {}\", predicate)\n                     }\n-                }\n+                };\n+                let value = chalk_ir::ProgramClauseImplication {\n+                    consequence,\n+                    conditions: chalk_ir::Goals::empty(interner),\n+                    priority: chalk_ir::ClausePriority::High,\n+                    constraints: chalk_ir::Constraints::empty(interner),\n+                };\n+                chalk_ir::ProgramClauseData(chalk_ir::Binders::new(binders, value)).intern(interner)\n             }\n-            ChalkEnvironmentClause::TypeFromEnv(ty) => Some(\n+            ChalkEnvironmentClause::TypeFromEnv(ty) => {\n                 chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n-                    chalk_ir::VariableKinds::new(interner),\n+                    chalk_ir::VariableKinds::empty(interner),\n                     chalk_ir::ProgramClauseImplication {\n                         consequence: chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Ty(\n                             ty.lower_into(interner).shifted_in(interner),\n                         )),\n-                        conditions: chalk_ir::Goals::new(interner),\n+                        conditions: chalk_ir::Goals::empty(interner),\n                         priority: chalk_ir::ClausePriority::High,\n+                        constraints: chalk_ir::Constraints::empty(interner),\n                     },\n                 ))\n-                .intern(interner),\n-            ),\n+                .intern(interner)\n+            }\n         });\n \n         let goal: chalk_ir::GoalData<RustInterner<'tcx>> = self.goal.lower_into(&interner);\n         chalk_ir::InEnvironment {\n             environment: chalk_ir::Environment {\n-                clauses: chalk_ir::ProgramClauses::from(&interner, clauses),\n+                clauses: chalk_ir::ProgramClauses::from_iter(&interner, clauses),\n             },\n             goal: goal.intern(&interner),\n         }\n@@ -185,63 +150,52 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        // FIXME(chalk): forall\n-        match self.bound_atom(interner.tcx).skip_binder() {\n+        let (predicate, binders, _named_regions) =\n+            collect_bound_vars(interner, interner.tcx, &self.bound_atom(interner.tcx));\n+\n+        let value = match predicate {\n             ty::PredicateAtom::Trait(predicate, _) => {\n-                ty::Binder::bind(predicate).lower_into(interner)\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n+                ))\n             }\n             ty::PredicateAtom::RegionOutlives(predicate) => {\n-                let predicate = ty::Binder::bind(predicate);\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                chalk_ir::GoalData::Quantified(\n-                    chalk_ir::QuantifierKind::ForAll,\n-                    chalk_ir::Binders::new(\n-                        binders,\n-                        chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n-                            chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n-                                a: predicate.0.lower_into(interner),\n-                                b: predicate.1.lower_into(interner),\n-                            }),\n-                        ))\n-                        .intern(interner),\n-                    ),\n-                )\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n+                        a: predicate.0.lower_into(interner),\n+                        b: predicate.1.lower_into(interner),\n+                    }),\n+                ))\n             }\n-            // FIXME(chalk): TypeOutlives\n-            ty::PredicateAtom::TypeOutlives(_predicate) => {\n-                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+            ty::PredicateAtom::TypeOutlives(predicate) => {\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n+                        ty: predicate.0.lower_into(interner),\n+                        lifetime: predicate.1.lower_into(interner),\n+                    }),\n+                ))\n             }\n             ty::PredicateAtom::Projection(predicate) => {\n-                ty::Binder::bind(predicate).lower_into(interner)\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)),\n+                ))\n             }\n             ty::PredicateAtom::WellFormed(arg) => match arg.unpack() {\n                 GenericArgKind::Type(ty) => match ty.kind() {\n                     // FIXME(chalk): In Chalk, a placeholder is WellFormed if it\n                     // `FromEnv`. However, when we \"lower\" Params, we don't update\n                     // the environment.\n-                    ty::Placeholder(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n-\n-                    _ => {\n-                        let (ty, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, &ty::Binder::bind(ty));\n-\n-                        chalk_ir::GoalData::Quantified(\n-                            chalk_ir::QuantifierKind::ForAll,\n-                            chalk_ir::Binders::new(\n-                                binders,\n-                                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n-                                    chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n-                                ))\n-                                .intern(interner),\n-                            ),\n-                        )\n+                    ty::Placeholder(..) => {\n+                        chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n                     }\n+\n+                    _ => chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n+                        chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n+                    )),\n                 },\n                 // FIXME(chalk): handle well formed consts\n                 GenericArgKind::Const(..) => {\n-                    chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+                    chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n                 }\n                 GenericArgKind::Lifetime(lt) => bug!(\"unexpect well formed predicate: {:?}\", lt),\n             },\n@@ -258,9 +212,14 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             | ty::PredicateAtom::Subtype(..)\n             | ty::PredicateAtom::ConstEvaluatable(..)\n             | ty::PredicateAtom::ConstEquate(..) => {\n-                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+                chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n             }\n-        }\n+        };\n+\n+        chalk_ir::GoalData::Quantified(\n+            chalk_ir::QuantifierKind::ForAll,\n+            chalk_ir::Binders::new(binders, value.intern(interner)),\n+        )\n     }\n }\n \n@@ -275,25 +234,6 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::TraitRef<RustInterner<'tcx>>>\n     }\n }\n \n-impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>>\n-    for ty::PolyTraitPredicate<'tcx>\n-{\n-    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        let (ty, binders, _named_regions) = collect_bound_vars(interner, interner.tcx, &self);\n-\n-        chalk_ir::GoalData::Quantified(\n-            chalk_ir::QuantifierKind::ForAll,\n-            chalk_ir::Binders::new(\n-                binders,\n-                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n-                    chalk_ir::WhereClause::Implemented(ty.trait_ref.lower_into(interner)),\n-                ))\n-                .intern(interner),\n-            ),\n-        )\n-    }\n-}\n-\n impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n     for rustc_middle::ty::ProjectionPredicate<'tcx>\n {\n@@ -305,25 +245,6 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n     }\n }\n \n-impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>>\n-    for ty::PolyProjectionPredicate<'tcx>\n-{\n-    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        let (ty, binders, _named_regions) = collect_bound_vars(interner, interner.tcx, &self);\n-\n-        chalk_ir::GoalData::Quantified(\n-            chalk_ir::QuantifierKind::ForAll,\n-            chalk_ir::Binders::new(\n-                binders,\n-                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n-                    chalk_ir::WhereClause::AliasEq(ty.lower_into(interner)),\n-                ))\n-                .intern(interner),\n-            ),\n-        )\n-    }\n-}\n-\n impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Ty<RustInterner<'tcx>> {\n         use chalk_ir::TyData;\n@@ -364,7 +285,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                 ast::FloatTy::F64 => float(chalk_ir::FloatTy::F64),\n             },\n             Adt(def, substs) => apply(struct_ty(def.did), substs.lower_into(interner)),\n-            Foreign(_def_id) => unimplemented!(),\n+            // FIXME(chalk): lower Foreign\n+            Foreign(def_id) => apply(chalk_ir::TypeName::FnDef(chalk_ir::FnDefId(def_id)), empty()),\n             Str => apply(chalk_ir::TypeName::Str, empty()),\n             Array(ty, len) => {\n                 let value = match len.val {\n@@ -381,7 +303,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                 };\n                 apply(\n                     chalk_ir::TypeName::Array,\n-                    chalk_ir::Substitution::from(\n+                    chalk_ir::Substitution::from_iter(\n                         interner,\n                         &[\n                             chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n@@ -415,7 +337,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                 };\n                 apply(\n                     name,\n-                    chalk_ir::Substitution::from(\n+                    chalk_ir::Substitution::from_iter(\n                         interner,\n                         &[\n                             chalk_ir::GenericArgData::Lifetime(region.lower_into(interner))\n@@ -432,14 +354,20 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             FnPtr(sig) => {\n                 let (inputs_and_outputs, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, &sig.inputs_and_output());\n-                TyData::Function(chalk_ir::Fn {\n+                TyData::Function(chalk_ir::FnPointer {\n                     num_binders: binders.len(interner),\n-                    substitution: chalk_ir::Substitution::from(\n+                    substitution: chalk_ir::Substitution::from_iter(\n                         interner,\n                         inputs_and_outputs.iter().map(|ty| {\n                             chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner)\n                         }),\n                     ),\n+                    abi: sig.abi(),\n+                    safety: match sig.unsafety() {\n+                        rustc_hir::Unsafety::Normal => chalk_ir::Safety::Safe,\n+                        rustc_hir::Unsafety::Unsafe => chalk_ir::Safety::Unsafe,\n+                    },\n+                    variadic: sig.c_variadic(),\n                 })\n                 .intern(interner)\n             }\n@@ -485,6 +413,111 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> Ty<'tcx> {\n+        use chalk_ir::TyData;\n+        use rustc_ast::ast;\n+\n+        let kind = match self.data(interner) {\n+            TyData::Apply(application_ty) => match application_ty.name {\n+                chalk_ir::TypeName::Adt(struct_id) => {\n+                    ty::Adt(struct_id.0, application_ty.substitution.lower_into(interner))\n+                }\n+                chalk_ir::TypeName::Scalar(scalar) => match scalar {\n+                    chalk_ir::Scalar::Bool => ty::Bool,\n+                    chalk_ir::Scalar::Char => ty::Char,\n+                    chalk_ir::Scalar::Int(int_ty) => match int_ty {\n+                        chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n+                        chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n+                        chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n+                        chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n+                        chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n+                        chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n+                    },\n+                    chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n+                        chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n+                        chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n+                        chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n+                        chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n+                        chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n+                        chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n+                    },\n+                    chalk_ir::Scalar::Float(float_ty) => match float_ty {\n+                        chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n+                        chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n+                    },\n+                },\n+                chalk_ir::TypeName::Array => unimplemented!(),\n+                chalk_ir::TypeName::FnDef(id) => {\n+                    ty::FnDef(id.0, application_ty.substitution.lower_into(interner))\n+                }\n+                chalk_ir::TypeName::Closure(closure) => {\n+                    ty::Closure(closure.0, application_ty.substitution.lower_into(interner))\n+                }\n+                chalk_ir::TypeName::Never => ty::Never,\n+                chalk_ir::TypeName::Tuple(_size) => {\n+                    ty::Tuple(application_ty.substitution.lower_into(interner))\n+                }\n+                chalk_ir::TypeName::Slice => ty::Slice(\n+                    application_ty.substitution.as_slice(interner)[0]\n+                        .ty(interner)\n+                        .unwrap()\n+                        .lower_into(interner),\n+                ),\n+                chalk_ir::TypeName::Raw(mutbl) => ty::RawPtr(ty::TypeAndMut {\n+                    ty: application_ty.substitution.as_slice(interner)[0]\n+                        .ty(interner)\n+                        .unwrap()\n+                        .lower_into(interner),\n+                    mutbl: match mutbl {\n+                        chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n+                        chalk_ir::Mutability::Not => ast::Mutability::Not,\n+                    },\n+                }),\n+                chalk_ir::TypeName::Ref(mutbl) => ty::Ref(\n+                    application_ty.substitution.as_slice(interner)[0]\n+                        .lifetime(interner)\n+                        .unwrap()\n+                        .lower_into(interner),\n+                    application_ty.substitution.as_slice(interner)[1]\n+                        .ty(interner)\n+                        .unwrap()\n+                        .lower_into(interner),\n+                    match mutbl {\n+                        chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n+                        chalk_ir::Mutability::Not => ast::Mutability::Not,\n+                    },\n+                ),\n+                chalk_ir::TypeName::Str => ty::Str,\n+                chalk_ir::TypeName::OpaqueType(opaque_ty) => {\n+                    ty::Opaque(opaque_ty.0, application_ty.substitution.lower_into(interner))\n+                }\n+                chalk_ir::TypeName::AssociatedType(assoc_ty) => ty::Projection(ty::ProjectionTy {\n+                    substs: application_ty.substitution.lower_into(interner),\n+                    item_def_id: assoc_ty.0,\n+                }),\n+                chalk_ir::TypeName::Error => unimplemented!(),\n+            },\n+            TyData::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n+                universe: ty::UniverseIndex::from_usize(placeholder.ui.counter),\n+                name: ty::BoundVar::from_usize(placeholder.idx),\n+            }),\n+            TyData::Alias(_alias_ty) => unimplemented!(),\n+            TyData::Function(_quantified_ty) => unimplemented!(),\n+            TyData::BoundVar(_bound) => ty::Bound(\n+                ty::DebruijnIndex::from_usize(_bound.debruijn.depth() as usize),\n+                ty::BoundTy {\n+                    var: ty::BoundVar::from_usize(_bound.index),\n+                    kind: ty::BoundTyKind::Anon,\n+                },\n+            ),\n+            TyData::InferenceVar(_, _) => unimplemented!(),\n+            TyData::Dyn(_) => unimplemented!(),\n+        };\n+        interner.tcx.mk_ty(kind)\n+    }\n+}\n+\n impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Lifetime<RustInterner<'tcx>> {\n         use rustc_middle::ty::RegionKind::*;\n@@ -522,6 +555,59 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'tcx>> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> Region<'tcx> {\n+        let kind = match self.data(interner) {\n+            chalk_ir::LifetimeData::BoundVar(var) => ty::RegionKind::ReLateBound(\n+                ty::DebruijnIndex::from_u32(var.debruijn.depth()),\n+                ty::BoundRegion::BrAnon(var.index as u32),\n+            ),\n+            chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n+            chalk_ir::LifetimeData::Placeholder(p) => {\n+                ty::RegionKind::RePlaceholder(ty::Placeholder {\n+                    universe: ty::UniverseIndex::from_usize(p.ui.counter),\n+                    name: ty::BoundRegion::BrAnon(p.idx as u32),\n+                })\n+            }\n+            chalk_ir::LifetimeData::Phantom(_, _) => unimplemented!(),\n+        };\n+        interner.tcx.mk_region(kind)\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Const<RustInterner<'tcx>>> for ty::Const<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Const<RustInterner<'tcx>> {\n+        let ty = self.ty.lower_into(interner);\n+        let value = match self.val {\n+            ty::ConstKind::Value(val) => {\n+                chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst { interned: val })\n+            }\n+            ty::ConstKind::Bound(db, bound) => chalk_ir::ConstValue::BoundVar(\n+                chalk_ir::BoundVar::new(chalk_ir::DebruijnIndex::new(db.as_u32()), bound.index()),\n+            ),\n+            _ => unimplemented!(\"Const not implemented. {:?}\", self),\n+        };\n+        chalk_ir::ConstData { ty, value }.intern(interner)\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, ty::Const<'tcx>> for &chalk_ir::Const<RustInterner<'tcx>> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> ty::Const<'tcx> {\n+        let data = self.data(interner);\n+        let ty = data.ty.lower_into(interner);\n+        let val = match data.value {\n+            chalk_ir::ConstValue::BoundVar(var) => ty::ConstKind::Bound(\n+                ty::DebruijnIndex::from_u32(var.debruijn.depth()),\n+                ty::BoundVar::from_u32(var.index as u32),\n+            ),\n+            chalk_ir::ConstValue::InferenceVar(_var) => unimplemented!(),\n+            chalk_ir::ConstValue::Placeholder(_p) => unimplemented!(),\n+            chalk_ir::ConstValue::Concrete(c) => ty::ConstKind::Value(c.interned),\n+        };\n+        ty::Const { ty, val }\n+    }\n+}\n+\n impl<'tcx> LowerInto<'tcx, chalk_ir::GenericArg<RustInterner<'tcx>>> for GenericArg<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GenericArg<RustInterner<'tcx>> {\n         match self.unpack() {\n@@ -531,18 +617,35 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GenericArg<RustInterner<'tcx>>> for Generic\n             ty::subst::GenericArgKind::Lifetime(lifetime) => {\n                 chalk_ir::GenericArgData::Lifetime(lifetime.lower_into(interner))\n             }\n-            ty::subst::GenericArgKind::Const(_) => chalk_ir::GenericArgData::Ty(\n-                chalk_ir::TyData::Apply(chalk_ir::ApplicationTy {\n-                    name: chalk_ir::TypeName::Tuple(0),\n-                    substitution: chalk_ir::Substitution::empty(interner),\n-                })\n-                .intern(interner),\n-            ),\n+            ty::subst::GenericArgKind::Const(c) => {\n+                chalk_ir::GenericArgData::Const(c.lower_into(interner))\n+            }\n         }\n         .intern(interner)\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, ty::subst::GenericArg<'tcx>>\n+    for &chalk_ir::GenericArg<RustInterner<'tcx>>\n+{\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> ty::subst::GenericArg<'tcx> {\n+        match self.data(interner) {\n+            chalk_ir::GenericArgData::Ty(ty) => {\n+                let t: Ty<'tcx> = ty.lower_into(interner);\n+                t.into()\n+            }\n+            chalk_ir::GenericArgData::Lifetime(lifetime) => {\n+                let r: Region<'tcx> = lifetime.lower_into(interner);\n+                r.into()\n+            }\n+            chalk_ir::GenericArgData::Const(c) => {\n+                let c: ty::Const<'tcx> = c.lower_into(interner);\n+                interner.tcx.mk_const(c).into()\n+            }\n+        }\n+    }\n+}\n+\n // We lower into an Option here since there are some predicates which Chalk\n // doesn't have a representation for yet (as a `WhereClause`), but are so common\n // that we just are accepting the unsoundness for now. The `Option` will\n@@ -554,41 +657,36 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        // FIXME(chalk): forall\n-        match self.bound_atom(interner.tcx).skip_binder() {\n+        let (predicate, binders, _named_regions) =\n+            collect_bound_vars(interner, interner.tcx, &self.bound_atom(interner.tcx));\n+        let value = match predicate {\n             ty::PredicateAtom::Trait(predicate, _) => {\n-                let predicate = ty::Binder::bind(predicate);\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                Some(chalk_ir::Binders::new(\n-                    binders,\n-                    chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n-                ))\n+                Some(chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)))\n             }\n             ty::PredicateAtom::RegionOutlives(predicate) => {\n-                let predicate = ty::Binder::bind(predicate);\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                Some(chalk_ir::Binders::new(\n-                    binders,\n-                    chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n-                        a: predicate.0.lower_into(interner),\n-                        b: predicate.1.lower_into(interner),\n-                    }),\n-                ))\n+                Some(chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n+                    a: predicate.0.lower_into(interner),\n+                    b: predicate.1.lower_into(interner),\n+                }))\n+            }\n+            ty::PredicateAtom::TypeOutlives(predicate) => {\n+                Some(chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n+                    ty: predicate.0.lower_into(interner),\n+                    lifetime: predicate.1.lower_into(interner),\n+                }))\n+            }\n+            ty::PredicateAtom::Projection(predicate) => {\n+                Some(chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)))\n             }\n-            ty::PredicateAtom::TypeOutlives(_predicate) => None,\n-            ty::PredicateAtom::Projection(_predicate) => None,\n             ty::PredicateAtom::WellFormed(_ty) => None,\n \n             ty::PredicateAtom::ObjectSafe(..)\n             | ty::PredicateAtom::ClosureKind(..)\n             | ty::PredicateAtom::Subtype(..)\n             | ty::PredicateAtom::ConstEvaluatable(..)\n             | ty::PredicateAtom::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n-        }\n+        };\n+        value.map(|value| chalk_ir::Binders::new(binders, value))\n     }\n }\n \n@@ -601,26 +699,34 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n     ) -> chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<RustInterner<'tcx>>> {\n         let (predicates, binders, _named_regions) =\n             collect_bound_vars(interner, interner.tcx, &self);\n+        let self_ty = interner.tcx.mk_ty(ty::Bound(\n+            // This is going to be wrapped in a binder\n+            ty::DebruijnIndex::from_usize(1),\n+            ty::BoundTy { var: ty::BoundVar::from_usize(0), kind: ty::BoundTyKind::Anon },\n+        ));\n         let where_clauses = predicates.into_iter().map(|predicate| match predicate {\n             ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef { def_id, substs }) => {\n                 chalk_ir::Binders::new(\n-                    chalk_ir::VariableKinds::new(interner),\n+                    chalk_ir::VariableKinds::empty(interner),\n                     chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n                         trait_id: chalk_ir::TraitId(def_id),\n-                        substitution: substs.lower_into(interner),\n+                        substitution: interner\n+                            .tcx\n+                            .mk_substs_trait(self_ty, substs)\n+                            .lower_into(interner),\n                     }),\n                 )\n             }\n             ty::ExistentialPredicate::Projection(_predicate) => unimplemented!(),\n             ty::ExistentialPredicate::AutoTrait(def_id) => chalk_ir::Binders::new(\n-                chalk_ir::VariableKinds::new(interner),\n+                chalk_ir::VariableKinds::empty(interner),\n                 chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n                     trait_id: chalk_ir::TraitId(def_id),\n-                    substitution: chalk_ir::Substitution::empty(interner),\n+                    substitution: interner.tcx.mk_substs_trait(self_ty, &[]).lower_into(interner),\n                 }),\n             ),\n         });\n-        let value = chalk_ir::QuantifiedWhereClauses::from(interner, where_clauses);\n+        let value = chalk_ir::QuantifiedWhereClauses::from_iter(interner, where_clauses);\n         chalk_ir::Binders::new(binders, value)\n     }\n }\n@@ -662,7 +768,8 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n             .or_else(|| bug!(\"Skipped bound var index: ty={:?}, parameters={:?}\", ty, parameters));\n     });\n \n-    let binders = chalk_ir::VariableKinds::from(interner, parameters.into_iter().map(|(_, v)| v));\n+    let binders =\n+        chalk_ir::VariableKinds::from_iter(interner, parameters.into_iter().map(|(_, v)| v));\n \n     (new_ty, binders, named_parameters)\n }\n@@ -773,10 +880,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n         result\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        t.super_fold_with(self)\n-    }\n-\n     fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n         match r {\n             ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n@@ -807,16 +910,18 @@ crate struct ParamsSubstitutor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     binder_index: ty::DebruijnIndex,\n     list: Vec<rustc_middle::ty::ParamTy>,\n+    next_ty_placeholder: usize,\n     crate params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n     crate named_regions: BTreeMap<DefId, u32>,\n }\n \n impl<'tcx> ParamsSubstitutor<'tcx> {\n-    crate fn new(tcx: TyCtxt<'tcx>) -> Self {\n+    crate fn new(tcx: TyCtxt<'tcx>, next_ty_placeholder: usize) -> Self {\n         ParamsSubstitutor {\n             tcx,\n             binder_index: ty::INNERMOST,\n             list: vec![],\n+            next_ty_placeholder,\n             params: rustc_data_structures::fx::FxHashMap::default(),\n             named_regions: BTreeMap::default(),\n         }\n@@ -842,13 +947,13 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n             // first pass to collect placeholders. Then we can insert params after.\n             ty::Placeholder(_) => unimplemented!(),\n             ty::Param(param) => match self.list.iter().position(|r| r == &param) {\n-                Some(_idx) => self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                Some(idx) => self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::from_usize(0),\n-                    name: ty::BoundVar::from_usize(_idx),\n+                    name: ty::BoundVar::from_usize(idx),\n                 })),\n                 None => {\n                     self.list.push(param);\n-                    let idx = self.list.len() - 1;\n+                    let idx = self.list.len() - 1 + self.next_ty_placeholder;\n                     self.params.insert(idx, param);\n                     self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                         universe: ty::UniverseIndex::from_usize(0),\n@@ -884,3 +989,83 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n         }\n     }\n }\n+\n+/// Used to collect `Placeholder`s.\n+crate struct PlaceholdersCollector {\n+    universe_index: ty::UniverseIndex,\n+    crate next_ty_placeholder: usize,\n+    crate next_anon_region_placeholder: u32,\n+}\n+\n+impl PlaceholdersCollector {\n+    crate fn new() -> Self {\n+        PlaceholdersCollector {\n+            universe_index: ty::UniverseIndex::ROOT,\n+            next_ty_placeholder: 0,\n+            next_anon_region_placeholder: 0,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        match t.kind() {\n+            ty::Placeholder(p) if p.universe == self.universe_index => {\n+                self.next_ty_placeholder = self.next_ty_placeholder.max(p.name.as_usize() + 1);\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: Region<'tcx>) -> bool {\n+        match r {\n+            ty::RePlaceholder(p) if p.universe == self.universe_index => {\n+                if let ty::BoundRegion::BrAnon(anon) = p.name {\n+                    self.next_anon_region_placeholder = self.next_anon_region_placeholder.max(anon);\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+/// Used to substitute specific `Regions`s with placeholders.\n+crate struct RegionsSubstitutor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    restatic_placeholder: ty::Region<'tcx>,\n+    reempty_placeholder: ty::Region<'tcx>,\n+}\n+\n+impl<'tcx> RegionsSubstitutor<'tcx> {\n+    crate fn new(\n+        tcx: TyCtxt<'tcx>,\n+        restatic_placeholder: ty::Region<'tcx>,\n+        reempty_placeholder: ty::Region<'tcx>,\n+    ) -> Self {\n+        RegionsSubstitutor { tcx, restatic_placeholder, reempty_placeholder }\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for RegionsSubstitutor<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+        match r {\n+            ty::ReStatic => self.restatic_placeholder,\n+            ty::ReEmpty(ui) => {\n+                assert_eq!(ui.as_usize(), 0);\n+                self.reempty_placeholder\n+            }\n+\n+            _ => r.super_fold_with(self),\n+        }\n+    }\n+}"}, {"sha": "c0d4a5d0e7e5c2ea78cb50502a3f2d309542e454", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 39, "deletions": 108, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "patch": "@@ -15,17 +15,17 @@ use rustc_middle::infer::canonical::{CanonicalTyVarKind, CanonicalVarKind};\n use rustc_middle::traits::ChalkRustInterner;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArg;\n-use rustc_middle::ty::{\n-    self, Bound, BoundVar, ParamTy, Region, RegionKind, Ty, TyCtxt, TypeFoldable,\n-};\n+use rustc_middle::ty::{self, BoundVar, ParamTy, TyCtxt, TypeFoldable};\n \n use rustc_infer::infer::canonical::{\n     Canonical, CanonicalVarValues, Certainty, QueryRegionConstraints, QueryResponse,\n };\n use rustc_infer::traits::{self, ChalkCanonicalGoal};\n \n use crate::chalk::db::RustIrDatabase as ChalkRustIrDatabase;\n-use crate::chalk::lowering::{LowerInto, ParamsSubstitutor};\n+use crate::chalk::lowering::{\n+    LowerInto, ParamsSubstitutor, PlaceholdersCollector, RegionsSubstitutor,\n+};\n \n use chalk_solve::Solution;\n \n@@ -40,16 +40,35 @@ crate fn evaluate_goal<'tcx>(\n     let interner = ChalkRustInterner { tcx };\n \n     // Chalk doesn't have a notion of `Params`, so instead we use placeholders.\n-    let mut params_substitutor = ParamsSubstitutor::new(tcx);\n+    let mut placeholders_collector = PlaceholdersCollector::new();\n+    obligation.visit_with(&mut placeholders_collector);\n+\n+    let restatic_placeholder = tcx.mk_region(ty::RegionKind::RePlaceholder(ty::Placeholder {\n+        universe: ty::UniverseIndex::ROOT,\n+        name: ty::BoundRegion::BrAnon(placeholders_collector.next_anon_region_placeholder),\n+    }));\n+    let reempty_placeholder = tcx.mk_region(ty::RegionKind::RePlaceholder(ty::Placeholder {\n+        universe: ty::UniverseIndex::ROOT,\n+        name: ty::BoundRegion::BrAnon(placeholders_collector.next_anon_region_placeholder + 1),\n+    }));\n+\n+    let mut params_substitutor =\n+        ParamsSubstitutor::new(tcx, placeholders_collector.next_ty_placeholder);\n     let obligation = obligation.fold_with(&mut params_substitutor);\n+    // FIXME(chalk): we really should be substituting these back in the solution\n     let _params: FxHashMap<usize, ParamTy> = params_substitutor.params;\n+\n+    let mut regions_substitutor =\n+        RegionsSubstitutor::new(tcx, restatic_placeholder, reempty_placeholder);\n+    let obligation = obligation.fold_with(&mut regions_substitutor);\n+\n     let max_universe = obligation.max_universe.index();\n \n-    let _lowered_goal: chalk_ir::UCanonical<\n+    let lowered_goal: chalk_ir::UCanonical<\n         chalk_ir::InEnvironment<chalk_ir::Goal<ChalkRustInterner<'tcx>>>,\n     > = chalk_ir::UCanonical {\n         canonical: chalk_ir::Canonical {\n-            binders: chalk_ir::CanonicalVarKinds::from(\n+            binders: chalk_ir::CanonicalVarKinds::from_iter(\n                 &interner,\n                 obligation.variables.iter().map(|v| match v.kind {\n                     CanonicalVarKind::PlaceholderTy(_ty) => unimplemented!(),\n@@ -81,108 +100,20 @@ crate fn evaluate_goal<'tcx>(\n         universes: max_universe + 1,\n     };\n \n-    let solver_choice = chalk_solve::SolverChoice::SLG { max_size: 32, expected_answers: None };\n-    let mut solver = solver_choice.into_solver::<ChalkRustInterner<'tcx>>();\n-\n-    let db = ChalkRustIrDatabase { tcx, interner };\n-    let solution = solver.solve(&db, &_lowered_goal);\n+    use chalk_solve::Solver;\n+    let mut solver = chalk_engine::solve::SLGSolver::new(32, None);\n+    let db = ChalkRustIrDatabase { interner, restatic_placeholder, reempty_placeholder };\n+    let solution = chalk_solve::logging::with_tracing_logs(|| solver.solve(&db, &lowered_goal));\n \n     // Ideally, the code to convert *back* to rustc types would live close to\n     // the code to convert *from* rustc types. Right now though, we don't\n     // really need this and so it's really minimal.\n     // Right now, we also treat a `Unique` solution the same as\n     // `Ambig(Definite)`. This really isn't right.\n-    let make_solution = |_subst: chalk_ir::Substitution<_>| {\n+    let make_solution = |subst: chalk_ir::Substitution<_>| {\n         let mut var_values: IndexVec<BoundVar, GenericArg<'tcx>> = IndexVec::new();\n-        _subst.parameters(&interner).iter().for_each(|p| {\n-            // FIXME(chalk): we should move this elsewhere, since this is\n-            // essentially inverse of lowering a `GenericArg`.\n-            let _data = p.data(&interner);\n-            match _data {\n-                chalk_ir::GenericArgData::Ty(_t) => {\n-                    use chalk_ir::TyData;\n-                    use rustc_ast as ast;\n-\n-                    let _data = _t.data(&interner);\n-                    let kind = match _data {\n-                        TyData::Apply(_application_ty) => match _application_ty.name {\n-                            chalk_ir::TypeName::Adt(_struct_id) => unimplemented!(),\n-                            chalk_ir::TypeName::Scalar(scalar) => match scalar {\n-                                chalk_ir::Scalar::Bool => ty::Bool,\n-                                chalk_ir::Scalar::Char => ty::Char,\n-                                chalk_ir::Scalar::Int(int_ty) => match int_ty {\n-                                    chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n-                                    chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n-                                    chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n-                                    chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n-                                    chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n-                                    chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n-                                },\n-                                chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n-                                    chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n-                                    chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n-                                    chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n-                                    chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n-                                    chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n-                                    chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n-                                },\n-                                chalk_ir::Scalar::Float(float_ty) => match float_ty {\n-                                    chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n-                                    chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n-                                },\n-                            },\n-                            chalk_ir::TypeName::Array => unimplemented!(),\n-                            chalk_ir::TypeName::FnDef(_) => unimplemented!(),\n-                            chalk_ir::TypeName::Closure(_) => unimplemented!(),\n-                            chalk_ir::TypeName::Never => unimplemented!(),\n-                            chalk_ir::TypeName::Tuple(_size) => unimplemented!(),\n-                            chalk_ir::TypeName::Slice => unimplemented!(),\n-                            chalk_ir::TypeName::Raw(_) => unimplemented!(),\n-                            chalk_ir::TypeName::Ref(_) => unimplemented!(),\n-                            chalk_ir::TypeName::Str => unimplemented!(),\n-                            chalk_ir::TypeName::OpaqueType(_ty) => unimplemented!(),\n-                            chalk_ir::TypeName::AssociatedType(_assoc_ty) => unimplemented!(),\n-                            chalk_ir::TypeName::Error => unimplemented!(),\n-                        },\n-                        TyData::Placeholder(_placeholder) => {\n-                            unimplemented!();\n-                        }\n-                        TyData::Alias(_alias_ty) => unimplemented!(),\n-                        TyData::Function(_quantified_ty) => unimplemented!(),\n-                        TyData::BoundVar(_bound) => Bound(\n-                            ty::DebruijnIndex::from_usize(_bound.debruijn.depth() as usize),\n-                            ty::BoundTy {\n-                                var: ty::BoundVar::from_usize(_bound.index),\n-                                kind: ty::BoundTyKind::Anon,\n-                            },\n-                        ),\n-                        TyData::InferenceVar(_, _) => unimplemented!(),\n-                        TyData::Dyn(_) => unimplemented!(),\n-                    };\n-                    let _ty: Ty<'_> = tcx.mk_ty(kind);\n-                    let _arg: GenericArg<'_> = _ty.into();\n-                    var_values.push(_arg);\n-                }\n-                chalk_ir::GenericArgData::Lifetime(_l) => {\n-                    let _data = _l.data(&interner);\n-                    let _lifetime: Region<'_> = match _data {\n-                        chalk_ir::LifetimeData::BoundVar(_var) => {\n-                            tcx.mk_region(RegionKind::ReLateBound(\n-                                rustc_middle::ty::DebruijnIndex::from_usize(\n-                                    _var.debruijn.depth() as usize\n-                                ),\n-                                rustc_middle::ty::BoundRegion::BrAnon(_var.index as u32),\n-                            ))\n-                        }\n-                        chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n-                        chalk_ir::LifetimeData::Placeholder(_index) => unimplemented!(),\n-                        chalk_ir::LifetimeData::Phantom(_, _) => unimplemented!(),\n-                    };\n-                    let _arg: GenericArg<'_> = _lifetime.into();\n-                    var_values.push(_arg);\n-                }\n-                chalk_ir::GenericArgData::Const(_) => unimplemented!(),\n-            }\n+        subst.as_slice(&interner).iter().for_each(|p| {\n+            var_values.push(p.lower_into(&interner));\n         });\n         let sol = Canonical {\n             max_universe: ty::UniverseIndex::from_usize(0),\n@@ -194,17 +125,17 @@ crate fn evaluate_goal<'tcx>(\n                 value: (),\n             },\n         };\n-        &*tcx.arena.alloc(sol)\n+        tcx.arena.alloc(sol)\n     };\n     solution\n         .map(|s| match s {\n-            Solution::Unique(_subst) => {\n+            Solution::Unique(subst) => {\n                 // FIXME(chalk): handle constraints\n-                make_solution(_subst.value.subst)\n+                make_solution(subst.value.subst)\n             }\n-            Solution::Ambig(_guidance) => {\n-                match _guidance {\n-                    chalk_solve::Guidance::Definite(_subst) => make_solution(_subst.value),\n+            Solution::Ambig(guidance) => {\n+                match guidance {\n+                    chalk_solve::Guidance::Definite(subst) => make_solution(subst.value),\n                     chalk_solve::Guidance::Suggested(_) => unimplemented!(),\n                     chalk_solve::Guidance::Unknown => {\n                         // chalk_fulfill doesn't use the var_values here, so"}, {"sha": "369777a7904af85e2e74fbfdc3363fe113003173", "filename": "src/test/ui/chalkify/type_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs?ref=c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "patch": "@@ -24,5 +24,5 @@ fn main() {\n \n     // Here we have two solutions so we get back the behavior of the old-style\n     // trait solver.\n-    only_bar(x); //~ ERROR the trait bound `f64: Bar` is not satisfied\n+    only_bar(x); //~ ERROR the trait bound `{float}: Bar` is not satisfied\n }"}, {"sha": "fb8ccbfc660bf9c0929b26c45a9365c982ad5a99", "filename": "src/test/ui/chalkify/type_inference.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr?ref=c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "patch": "@@ -1,11 +1,15 @@\n-error[E0277]: the trait bound `f64: Bar` is not satisfied\n+error[E0277]: the trait bound `{float}: Bar` is not satisfied\n   --> $DIR/type_inference.rs:27:5\n    |\n LL | fn only_bar<T: Bar>(_x: T) { }\n    |                --- required by this bound in `only_bar`\n ...\n LL |     only_bar(x);\n-   |     ^^^^^^^^ the trait `Bar` is not implemented for `f64`\n+   |     ^^^^^^^^ the trait `Bar` is not implemented for `{float}`\n+   |\n+   = help: the following implementations were found:\n+             <i32 as Bar>\n+             <u32 as Bar>\n \n error: aborting due to previous error\n "}, {"sha": "dd83a03fdf691cbcc9b7c623ba4864636848a6fa", "filename": "src/test/ui/chalkify/type_wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs?ref=c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "patch": "@@ -15,7 +15,7 @@ fn main() {\n        x: 5,\n     };\n \n-    let s = S { //~ ERROR the trait bound `f64: Foo` is not satisfied\n+    let s = S { //~ ERROR the trait bound `{float}: Foo` is not satisfied\n         x: 5.0,\n     };\n "}, {"sha": "3cd60369454930eb138acded147f096dcdd24919", "filename": "src/test/ui/chalkify/type_wf.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c3364780d2cfddfe329f62a3ec138fd4f9a60e27/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr?ref=c3364780d2cfddfe329f62a3ec138fd4f9a60e27", "patch": "@@ -1,11 +1,15 @@\n-error[E0277]: the trait bound `f64: Foo` is not satisfied\n+error[E0277]: the trait bound `{float}: Foo` is not satisfied\n   --> $DIR/type_wf.rs:18:13\n    |\n LL | struct S<T: Foo> {\n    | ---------------- required by `S`\n ...\n LL |     let s = S {\n-   |             ^ the trait `Foo` is not implemented for `f64`\n+   |             ^ the trait `Foo` is not implemented for `{float}`\n+   |\n+   = help: the following implementations were found:\n+             <Option<T> as Foo>\n+             <i32 as Foo>\n \n error: aborting due to previous error\n "}]}