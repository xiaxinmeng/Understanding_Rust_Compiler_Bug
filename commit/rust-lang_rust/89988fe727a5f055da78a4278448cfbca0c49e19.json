{"sha": "89988fe727a5f055da78a4278448cfbca0c49e19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5OTg4ZmU3MjdhNWYwNTVkYTc4YTQyNzg0NDhjZmJjYTBjNDllMTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-18T22:50:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-18T22:50:40Z"}, "message": "Auto merge of #72330 - Dylan-DPC:rollup-yuxadv8, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #71599 (Support coercion between (FnDef | Closure) and (FnDef | Closure))\n - #71973 (Lazy normalization of constants (Reprise))\n - #72283 (Drop Elaboration Elaboration)\n - #72290 (Add newer rust versions to linker-plugin-lto.md)\n - #72318 (Add help text for remote-test-client)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "627511ba79ef59483b8162d6a03d15aa59be3cfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/627511ba79ef59483b8162d6a03d15aa59be3cfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89988fe727a5f055da78a4278448cfbca0c49e19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89988fe727a5f055da78a4278448cfbca0c49e19", "html_url": "https://github.com/rust-lang/rust/commit/89988fe727a5f055da78a4278448cfbca0c49e19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89988fe727a5f055da78a4278448cfbca0c49e19/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8878868c8d7ef3779e7243953fc050cbb0e0565", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8878868c8d7ef3779e7243953fc050cbb0e0565", "html_url": "https://github.com/rust-lang/rust/commit/d8878868c8d7ef3779e7243953fc050cbb0e0565"}, {"sha": "256ce18dcb8f3c3c77c18e087f5642d30e1e68f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/256ce18dcb8f3c3c77c18e087f5642d30e1e68f1", "html_url": "https://github.com/rust-lang/rust/commit/256ce18dcb8f3c3c77c18e087f5642d30e1e68f1"}], "stats": {"total": 1559, "additions": 1343, "deletions": 216}, "files": [{"sha": "c0b14352b7d1a6be4dacb64f0c05188db98d0b4a", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -100,11 +100,17 @@ LLVM. However, the approximation is usually reliable.\n \n The following table shows known good combinations of toolchain versions.\n \n-|           |  Clang 7  |  Clang 8  |\n-|-----------|-----------|-----------|\n-| Rust 1.34 |     \u2717     |     \u2713     |\n-| Rust 1.35 |     \u2717     |     \u2713     |\n-| Rust 1.36 |     \u2717     |     \u2713     |\n-| Rust 1.37 |     \u2717     |     \u2713     |\n+|           |  Clang 7  |  Clang 8  |  Clang 9  |\n+|-----------|-----------|-----------|-----------|\n+| Rust 1.34 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.35 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.36 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.37 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.38 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.39 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.40 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.41 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.42 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.43 |     \u2717     |     \u2717     |     \u2713     |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "c7a7cf89b4f1b738a16a6909f15784648e48e390", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, BoundVar, Ty, TyCtxt};\n+use rustc_middle::ty::{self, BoundVar, Const, Ty, TyCtxt};\n use std::fmt::Debug;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n@@ -671,6 +671,13 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         });\n     }\n \n+    fn const_equate(&mut self, _a: &'tcx Const<'tcx>, _b: &'tcx Const<'tcx>) {\n+        span_bug!(\n+            self.cause.span(self.infcx.tcx),\n+            \"lazy_normalization_consts: unreachable `const_equate`\"\n+        );\n+    }\n+\n     fn normalization() -> NormalizationStrategy {\n         NormalizationStrategy::Eager\n     }"}, {"sha": "3467457b44997a0d21a8440684f899b86592b00e", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -39,7 +39,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n+use rustc_middle::ty::{self, InferConst, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{IntType, UintType};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -126,7 +126,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n     where\n-        R: TypeRelation<'tcx>,\n+        R: ConstEquateRelation<'tcx>,\n     {\n         debug!(\"{}.consts({:?}, {:?})\", relation.tag(), a, b);\n         if a == b {\n@@ -164,7 +164,22 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             (_, ty::ConstKind::Infer(InferConst::Var(vid))) => {\n                 return self.unify_const_variable(!a_is_expected, vid, a);\n             }\n-\n+            (ty::ConstKind::Unevaluated(..), _) if self.tcx.lazy_normalization() => {\n+                // FIXME(#59490): Need to remove the leak check to accomodate\n+                // escaping bound variables here.\n+                if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n+                    relation.const_equate_obligation(a, b);\n+                }\n+                return Ok(b);\n+            }\n+            (_, ty::ConstKind::Unevaluated(..)) if self.tcx.lazy_normalization() => {\n+                // FIXME(#59490): Need to remove the leak check to accomodate\n+                // escaping bound variables here.\n+                if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n+                    relation.const_equate_obligation(a, b);\n+                }\n+                return Ok(a);\n+            }\n             _ => {}\n         }\n \n@@ -375,6 +390,20 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         debug!(\"generalize: success {{ {:?}, {:?} }}\", ty, needs_wf);\n         Ok(Generalization { ty, needs_wf })\n     }\n+\n+    pub fn add_const_equate_obligation(\n+        &mut self,\n+        a_is_expected: bool,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) {\n+        let predicate = if a_is_expected {\n+            ty::Predicate::ConstEquate(a, b)\n+        } else {\n+            ty::Predicate::ConstEquate(b, a)\n+        };\n+        self.obligations.push(Obligation::new(self.trace.cause.clone(), self.param_env, predicate));\n+    }\n }\n \n struct Generalizer<'cx, 'tcx> {\n@@ -637,11 +666,19 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     }\n                 }\n             }\n+            ty::ConstKind::Unevaluated(..) if self.tcx().lazy_normalization() => Ok(c),\n             _ => relate::super_relate_consts(self, c, c),\n         }\n     }\n }\n \n+pub trait ConstEquateRelation<'tcx>: TypeRelation<'tcx> {\n+    /// Register an obligation that both constants must be equal to each other.\n+    ///\n+    /// If they aren't equal then the relation doesn't hold.\n+    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>);\n+}\n+\n pub trait RelateResultCompare<'tcx, T> {\n     fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T>\n     where"}, {"sha": "e3cafb82719dd4e714dae122c8976b175b03c40f", "filename": "src/librustc_infer/infer/equate.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fequate.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1,4 +1,4 @@\n-use super::combine::{CombineFields, RelationDir};\n+use super::combine::{CombineFields, ConstEquateRelation, RelationDir};\n use super::Subtype;\n \n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n@@ -140,3 +140,9 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> ConstEquateRelation<'tcx> for Equate<'_, '_, 'tcx> {\n+    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>) {\n+        self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n+    }\n+}"}, {"sha": "ec219a95b94414aa1ecf401aaacfb787ef08d109", "filename": "src/librustc_infer/infer/glb.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fglb.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -3,6 +3,7 @@ use super::lattice::{self, LatticeDir};\n use super::InferCtxt;\n use super::Subtype;\n \n+use crate::infer::combine::ConstEquateRelation;\n use crate::traits::ObligationCause;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -116,3 +117,9 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n         Ok(())\n     }\n }\n+\n+impl<'tcx> ConstEquateRelation<'tcx> for Glb<'_, '_, 'tcx> {\n+    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>) {\n+        self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n+    }\n+}"}, {"sha": "a0453db2cb4994d7dc7182bb4a15f830c5284b7b", "filename": "src/librustc_infer/infer/lub.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flub.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -3,6 +3,7 @@ use super::lattice::{self, LatticeDir};\n use super::InferCtxt;\n use super::Subtype;\n \n+use crate::infer::combine::ConstEquateRelation;\n use crate::traits::ObligationCause;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -100,6 +101,12 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n     }\n }\n \n+impl<'tcx> ConstEquateRelation<'tcx> for Lub<'_, '_, 'tcx> {\n+    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>) {\n+        self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n+    }\n+}\n+\n impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx, 'tcx> {\n     fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'tcx> {\n         self.fields.infcx"}, {"sha": "9c81a1153958b5a22cc5dfca7dec50cd7ac4c3ae", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1490,6 +1490,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.report_and_explain_type_error(trace, &err)\n     }\n \n+    pub fn report_mismatched_consts(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: &'tcx ty::Const<'tcx>,\n+        actual: &'tcx ty::Const<'tcx>,\n+        err: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let trace = TypeTrace::consts(cause, true, expected, actual);\n+        self.report_and_explain_type_error(trace, &err)\n+    }\n+\n     pub fn replace_bound_vars_with_fresh_vars<T>(\n         &self,\n         span: Span,\n@@ -1777,6 +1788,15 @@ impl<'tcx> TypeTrace<'tcx> {\n         TypeTrace { cause: cause.clone(), values: Types(ExpectedFound::new(a_is_expected, a, b)) }\n     }\n \n+    pub fn consts(\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> TypeTrace<'tcx> {\n+        TypeTrace { cause: cause.clone(), values: Consts(ExpectedFound::new(a_is_expected, a, b)) }\n+    }\n+\n     pub fn dummy(tcx: TyCtxt<'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             cause: ObligationCause::dummy(),"}, {"sha": "8de892510060828e12c6ddc238a8650794178660", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -21,6 +21,7 @@\n //!   thing we relate in chalk are basically domain goals and their\n //!   constituents)\n \n+use crate::infer::combine::ConstEquateRelation;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use rustc_data_structures::fx::FxHashMap;\n@@ -77,6 +78,8 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// delegate.\n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n \n+    fn const_equate(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>);\n+\n     /// Creates a new universe index. Used when instantiating placeholders.\n     fn create_next_universe(&mut self) -> ty::UniverseIndex;\n \n@@ -715,6 +718,15 @@ where\n     }\n }\n \n+impl<'tcx, D> ConstEquateRelation<'tcx> for TypeRelating<'_, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>) {\n+        self.delegate.const_equate(a, b);\n+    }\n+}\n+\n /// When we encounter a binder like `for<..> fn(..)`, we actually have\n /// to walk the `fn` value to find all the values bound by the `for`\n /// (these are not explicitly present in the ty representation right\n@@ -976,6 +988,7 @@ where\n                     }\n                 }\n             }\n+            ty::ConstKind::Unevaluated(..) if self.tcx().lazy_normalization() => Ok(a),\n             _ => relate::super_relate_consts(self, a, a),\n         }\n     }"}, {"sha": "289457e2bd0c294ea1fcfa63b235d044d9caf14f", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -19,7 +19,8 @@ pub fn explicit_outlives_bounds<'tcx>(\n         | ty::Predicate::ObjectSafe(..)\n         | ty::Predicate::ClosureKind(..)\n         | ty::Predicate::TypeOutlives(..)\n-        | ty::Predicate::ConstEvaluatable(..) => None,\n+        | ty::Predicate::ConstEvaluatable(..)\n+        | ty::Predicate::ConstEquate(..) => None,\n         ty::Predicate::RegionOutlives(ref data) => data\n             .no_bound_vars()\n             .map(|ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a)),"}, {"sha": "1ec67ef2efa9d2f129bcd73f99ba98381749e200", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1,6 +1,7 @@\n use super::combine::{CombineFields, RelationDir};\n use super::SubregionOrigin;\n \n+use crate::infer::combine::ConstEquateRelation;\n use crate::traits::Obligation;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n@@ -169,3 +170,9 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         self.fields.higher_ranked_sub(a, b, self.a_is_expected)\n     }\n }\n+\n+impl<'tcx> ConstEquateRelation<'tcx> for Sub<'_, '_, 'tcx> {\n+    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>) {\n+        self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n+    }\n+}"}, {"sha": "8d95904b355da7247def7b9629a384dd624b917e", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -10,7 +10,7 @@ pub mod util;\n \n use rustc_hir as hir;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Const, Ty};\n use rustc_span::Span;\n \n pub use self::FulfillmentErrorCode::*;\n@@ -81,6 +81,7 @@ pub enum FulfillmentErrorCode<'tcx> {\n     CodeSelectionError(SelectionError<'tcx>),\n     CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n     CodeSubtypeError(ExpectedFound<Ty<'tcx>>, TypeError<'tcx>), // always comes from a SubtypePredicate\n+    CodeConstEquateError(ExpectedFound<&'tcx Const<'tcx>>, TypeError<'tcx>),\n     CodeAmbiguity,\n }\n "}, {"sha": "c48e58c04824e03a13e3a2a461957754bb58c0d1", "filename": "src/librustc_infer/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -41,6 +41,9 @@ impl<'tcx> fmt::Debug for traits::FulfillmentErrorCode<'tcx> {\n             super::CodeSubtypeError(ref a, ref b) => {\n                 write!(f, \"CodeSubtypeError({:?}, {:?})\", a, b)\n             }\n+            super::CodeConstEquateError(ref a, ref b) => {\n+                write!(f, \"CodeConstEquateError({:?}, {:?})\", a, b)\n+            }\n             super::CodeAmbiguity => write!(f, \"Ambiguity\"),\n         }\n     }"}, {"sha": "ee903b676bae95cf7e3a600fa2ab197bd5e13635", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -42,6 +42,8 @@ pub fn anonymize_predicate<'tcx>(\n         ty::Predicate::ConstEvaluatable(def_id, substs) => {\n             ty::Predicate::ConstEvaluatable(def_id, substs)\n         }\n+\n+        ty::Predicate::ConstEquate(c1, c2) => ty::Predicate::ConstEquate(c1, c2),\n     }\n }\n \n@@ -187,6 +189,10 @@ impl Elaborator<'tcx> {\n                 // Currently, we do not elaborate const-evaluatable\n                 // predicates.\n             }\n+            ty::Predicate::ConstEquate(..) => {\n+                // Currently, we do not elaborate const-equate\n+                // predicates.\n+            }\n             ty::Predicate::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }"}, {"sha": "bca91fb7b5d168629a4bff103892fb9eb26d2ff4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1221,7 +1221,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n                     ObjectSafe(..) |\n                     ClosureKind(..) |\n                     Subtype(..) |\n-                    ConstEvaluatable(..) => continue,\n+                    ConstEvaluatable(..) |\n+                    ConstEquate(..) => continue,\n                 };\n                 if predicate.is_global() {\n                     cx.struct_span_lint(TRIVIAL_BOUNDS, span, |lint| {"}, {"sha": "c005455a3aab6a588bdbde3bde2bf7bf8720445d", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1339,7 +1339,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// What mode(s) of borrowck should we run? AST? MIR? both?\n     /// (Also considers the `#![feature(nll)]` setting.)\n-    pub fn borrowck_mode(&self) -> BorrowckMode {\n+    pub fn borrowck_mode(self) -> BorrowckMode {\n         // Here are the main constraints we need to deal with:\n         //\n         // 1. An opts.borrowck_mode of `BorrowckMode::Migrate` is\n@@ -1369,6 +1369,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.sess.opts.borrowck_mode\n     }\n \n+    /// If `true`, we should use lazy normalization for constants, otherwise\n+    /// we still evaluate them eagerly.\n+    #[inline]\n+    pub fn lazy_normalization(self) -> bool {\n+        self.features().const_generics\n+    }\n+\n     #[inline]\n     pub fn local_crate_exports_generics(self) -> bool {\n         debug_assert!(self.sess.opts.share_generics());\n@@ -2069,24 +2076,25 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_fn_ptr(sig.map_bound(|sig| ty::FnSig { unsafety: hir::Unsafety::Unsafe, ..sig }))\n     }\n \n-    /// Given a closure signature `sig`, returns an equivalent `fn`\n-    /// type with the same signature. Detuples and so forth -- so\n-    /// e.g., if we have a sig with `Fn<(u32, i32)>` then you would get\n-    /// a `fn(u32, i32)`.\n-    /// `unsafety` determines the unsafety of the `fn` type. If you pass\n+    /// Given a closure signature, returns an equivalent fn signature. Detuples\n+    /// and so forth -- so e.g., if we have a sig with `Fn<(u32, i32)>` then\n+    /// you would get a `fn(u32, i32)`.\n+    /// `unsafety` determines the unsafety of the fn signature. If you pass\n     /// `hir::Unsafety::Unsafe` in the previous example, then you would get\n     /// an `unsafe fn (u32, i32)`.\n     /// It cannot convert a closure that requires unsafe.\n-    pub fn coerce_closure_fn_ty(self, sig: PolyFnSig<'tcx>, unsafety: hir::Unsafety) -> Ty<'tcx> {\n-        let converted_sig = sig.map_bound(|s| {\n+    pub fn signature_unclosure(\n+        self,\n+        sig: PolyFnSig<'tcx>,\n+        unsafety: hir::Unsafety,\n+    ) -> PolyFnSig<'tcx> {\n+        sig.map_bound(|s| {\n             let params_iter = match s.inputs()[0].kind {\n                 ty::Tuple(params) => params.into_iter().map(|k| k.expect_ty()),\n                 _ => bug!(),\n             };\n             self.mk_fn_sig(params_iter, s.output(), s.c_variadic, unsafety, abi::Abi::Rust)\n-        });\n-\n-        self.mk_fn_ptr(converted_sig)\n+        })\n     }\n \n     #[allow(rustc::usage_of_ty_tykind)]"}, {"sha": "36bc44f5e50329b9734a8bd37168e33b9a334b78", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1054,6 +1054,9 @@ pub enum Predicate<'tcx> {\n \n     /// Constant initializer must evaluate successfully.\n     ConstEvaluatable(DefId, SubstsRef<'tcx>),\n+\n+    /// Constants must be equal. The first component is the const that is expected.\n+    ConstEquate(&'tcx Const<'tcx>, &'tcx Const<'tcx>),\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -1172,6 +1175,9 @@ impl<'tcx> Predicate<'tcx> {\n             Predicate::ConstEvaluatable(def_id, const_substs) => {\n                 Predicate::ConstEvaluatable(def_id, const_substs.subst(tcx, substs))\n             }\n+            Predicate::ConstEquate(c1, c2) => {\n+                Predicate::ConstEquate(c1.subst(tcx, substs), c2.subst(tcx, substs))\n+            }\n         }\n     }\n }\n@@ -1349,7 +1355,8 @@ impl<'tcx> Predicate<'tcx> {\n             | Predicate::ObjectSafe(..)\n             | Predicate::ClosureKind(..)\n             | Predicate::TypeOutlives(..)\n-            | Predicate::ConstEvaluatable(..) => None,\n+            | Predicate::ConstEvaluatable(..)\n+            | Predicate::ConstEquate(..) => None,\n         }\n     }\n \n@@ -1363,7 +1370,8 @@ impl<'tcx> Predicate<'tcx> {\n             | Predicate::WellFormed(..)\n             | Predicate::ObjectSafe(..)\n             | Predicate::ClosureKind(..)\n-            | Predicate::ConstEvaluatable(..) => None,\n+            | Predicate::ConstEvaluatable(..)\n+            | Predicate::ConstEquate(..) => None,\n         }\n     }\n }"}, {"sha": "3e6a12df6887dd49416923986fb668abad80c5e8", "filename": "src/librustc_middle/ty/outlives.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Foutlives.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -83,6 +83,11 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                 }\n             }\n \n+            ty::Array(element, _) => {\n+                // Don't look into the len const as it doesn't affect regions\n+                compute_components(tcx, element, out);\n+            }\n+\n             ty::Closure(_, ref substs) => {\n                 for upvar_ty in substs.as_closure().upvar_tys() {\n                     compute_components(tcx, upvar_ty, out);\n@@ -158,7 +163,6 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n             ty::Opaque(..) |      // OutlivesNominalType (ish)\n             ty::Foreign(..) |     // OutlivesNominalType\n             ty::Str |             // OutlivesScalar (ish)\n-            ty::Array(..) |       // ...\n             ty::Slice(..) |       // ...\n             ty::RawPtr(..) |      // ...\n             ty::Ref(..) |         // OutlivesReference"}, {"sha": "2502a4a13a8f0e7550658d00c33a17a7a0707ee9", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -2058,6 +2058,13 @@ define_print_and_forward_display! {\n                    print_value_path(def_id, substs),\n                    write(\"` can be evaluated\"))\n             }\n+            ty::Predicate::ConstEquate(c1, c2) => {\n+                p!(write(\"the constant `\"),\n+                   print(c1),\n+                   write(\"` equals `\"),\n+                   print(c2),\n+                   write(\"`\"))\n+            }\n         }\n     }\n "}, {"sha": "594ffbcd83613ef888bff691ca8f74e9c04008ea", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -431,6 +431,9 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             let t = relation.relate(&a_t, &b_t)?;\n             match relation.relate(&sz_a, &sz_b) {\n                 Ok(sz) => Ok(tcx.mk_ty(ty::Array(t, sz))),\n+                // FIXME(#72219) Implement improved diagnostics for mismatched array\n+                // length?\n+                Err(err) if relation.tcx().lazy_normalization() => Err(err),\n                 Err(err) => {\n                     // Check whether the lengths are both concrete/known values,\n                     // but are unequal, for better diagnostics."}, {"sha": "cdb7e34546af8999f3e2fd84f83f476174554925", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -240,6 +240,7 @@ impl fmt::Debug for ty::Predicate<'tcx> {\n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                 write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n             }\n+            ty::Predicate::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n         }\n     }\n }\n@@ -492,6 +493,9 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                 tcx.lift(&substs).map(|substs| ty::Predicate::ConstEvaluatable(def_id, substs))\n             }\n+            ty::Predicate::ConstEquate(c1, c2) => {\n+                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::Predicate::ConstEquate(c1, c2))\n+            }\n         }\n     }\n }"}, {"sha": "526914721bebe21c866732874554f0ea0cea93a4", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -2088,7 +2088,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             ty::Closure(_, substs) => substs.as_closure().sig(),\n                             _ => bug!(),\n                         };\n-                        let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig, *unsafety);\n+                        let ty_fn_ptr_from = tcx.mk_fn_ptr(tcx.signature_unclosure(sig, *unsafety));\n \n                         if let Err(terr) = self.eq_types(\n                             ty_fn_ptr_from,"}, {"sha": "7ff12820db8151858fbf33b6e89221ecaac237bc", "filename": "src/librustc_mir/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -2,7 +2,7 @@ use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRe\n use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Const, Ty};\n use rustc_trait_selection::traits::query::Fallible;\n \n use crate::borrow_check::constraints::OutlivesConstraint;\n@@ -99,6 +99,10 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n         }\n     }\n \n+    // We don't have to worry about the equality of consts during borrow checking\n+    // as consts always have a static lifetime.\n+    fn const_equate(&mut self, _a: &'tcx Const<'tcx>, _b: &'tcx Const<'tcx>) {}\n+\n     fn normalization() -> NormalizationStrategy {\n         NormalizationStrategy::Eager\n     }"}, {"sha": "e3982c654d5fa809cb34ba80d967d3c87fe56e19", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -277,7 +277,18 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n     }\n \n     fn drop_style(&self, _path: Self::Path, mode: DropFlagMode) -> DropStyle {\n-        if let DropFlagMode::Shallow = mode { DropStyle::Static } else { DropStyle::Open }\n+        match mode {\n+            DropFlagMode::Shallow => {\n+                // Drops for the contained fields are \"shallow\" and \"static\" - they will simply call\n+                // the field's own drop glue.\n+                DropStyle::Static\n+            }\n+            DropFlagMode::Deep => {\n+                // The top-level drop is \"deep\" and \"open\" - it will be elaborated to a drop ladder\n+                // dropping each field contained in the value.\n+                DropStyle::Open\n+            }\n+        }\n     }\n \n     fn get_drop_flag(&mut self, _path: Self::Path) -> Option<Operand<'tcx>> {"}, {"sha": "a2e2c1bf9eda30e1dece280f9c82f4301732a36e", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -28,7 +28,8 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n                 | Predicate::TypeOutlives(_)\n                 | Predicate::WellFormed(_)\n                 | Predicate::Projection(_)\n-                | Predicate::ConstEvaluatable(..) => continue,\n+                | Predicate::ConstEvaluatable(..)\n+                | Predicate::ConstEquate(..) => continue,\n                 Predicate::ObjectSafe(_) => {\n                     bug!(\"object safe predicate on function: {:#?}\", predicate)\n                 }"}, {"sha": "ed999c6871bb67fca0e73cc370f42d0d9ffb143e", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 87, "deletions": 8, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -12,10 +12,15 @@ use std::fmt;\n \n use std::convert::TryInto;\n \n+/// The value of an inserted drop flag.\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum DropFlagState {\n-    Present, // i.e., initialized\n-    Absent,  // i.e., deinitialized or \"moved\"\n+    /// The tracked value is initialized and needs to be dropped when leaving its scope.\n+    Present,\n+\n+    /// The tracked value is uninitialized or was moved out of and does not need to be dropped when\n+    /// leaving its scope.\n+    Absent,\n }\n \n impl DropFlagState {\n@@ -27,23 +32,42 @@ impl DropFlagState {\n     }\n }\n \n+/// Describes how/if a value should be dropped.\n #[derive(Debug)]\n pub enum DropStyle {\n+    /// The value is already dead at the drop location, no drop will be executed.\n     Dead,\n+\n+    /// The value is known to always be initialized at the drop location, drop will always be\n+    /// executed.\n     Static,\n+\n+    /// Whether the value needs to be dropped depends on its drop flag.\n     Conditional,\n+\n+    /// An \"open\" drop is one where only the fields of a value are dropped.\n+    ///\n+    /// For example, this happens when moving out of a struct field: The rest of the struct will be\n+    /// dropped in such an \"open\" drop. It is also used to generate drop glue for the individual\n+    /// components of a value, for example for dropping array elements.\n     Open,\n }\n \n+/// Which drop flags to affect/check with an operation.\n #[derive(Debug)]\n pub enum DropFlagMode {\n+    /// Only affect the top-level drop flag, not that of any contained fields.\n     Shallow,\n+    /// Affect all nested drop flags in addition to the top-level one.\n     Deep,\n }\n \n+/// Describes if unwinding is necessary and where to unwind to if a panic occurs.\n #[derive(Copy, Clone, Debug)]\n pub enum Unwind {\n+    /// Unwind to this block.\n     To(BasicBlock),\n+    /// Already in an unwind path, any panic will cause an abort.\n     InCleanup,\n }\n \n@@ -74,20 +98,58 @@ impl Unwind {\n }\n \n pub trait DropElaborator<'a, 'tcx>: fmt::Debug {\n+    /// The type representing paths that can be moved out of.\n+    ///\n+    /// Users can move out of individual fields of a struct, such as `a.b.c`. This type is used to\n+    /// represent such move paths. Sometimes tracking individual move paths is not necessary, in\n+    /// which case this may be set to (for example) `()`.\n     type Path: Copy + fmt::Debug;\n \n+    // Accessors\n+\n     fn patch(&mut self) -> &mut MirPatch<'tcx>;\n     fn body(&self) -> &'a Body<'tcx>;\n     fn tcx(&self) -> TyCtxt<'tcx>;\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n \n+    // Drop logic\n+\n+    /// Returns how `path` should be dropped, given `mode`.\n     fn drop_style(&self, path: Self::Path, mode: DropFlagMode) -> DropStyle;\n+\n+    /// Returns the drop flag of `path` as a MIR `Operand` (or `None` if `path` has no drop flag).\n     fn get_drop_flag(&mut self, path: Self::Path) -> Option<Operand<'tcx>>;\n+\n+    /// Modifies the MIR patch so that the drop flag of `path` (if any) is cleared at `location`.\n+    ///\n+    /// If `mode` is deep, drop flags of all child paths should also be cleared by inserting\n+    /// additional statements.\n     fn clear_drop_flag(&mut self, location: Location, path: Self::Path, mode: DropFlagMode);\n \n+    // Subpaths\n+\n+    /// Returns the subpath of a field of `path` (or `None` if there is no dedicated subpath).\n+    ///\n+    /// If this returns `None`, `field` will not get a dedicated drop flag.\n     fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path>;\n+\n+    /// Returns the subpath of a dereference of `path` (or `None` if there is no dedicated subpath).\n+    ///\n+    /// If this returns `None`, `*path` will not get a dedicated drop flag.\n+    ///\n+    /// This is only relevant for `Box<T>`, where the contained `T` can be moved out of the box.\n     fn deref_subpath(&self, path: Self::Path) -> Option<Self::Path>;\n+\n+    /// Returns the subpath of downcasting `path` to one of its variants.\n+    ///\n+    /// If this returns `None`, the downcast of `path` will not get a dedicated drop flag.\n     fn downcast_subpath(&self, path: Self::Path, variant: VariantIdx) -> Option<Self::Path>;\n+\n+    /// Returns the subpath of indexing a fixed-size array `path`.\n+    ///\n+    /// If this returns `None`, elements of `path` will not get a dedicated drop flag.\n+    ///\n+    /// This is only relevant for array patterns, which can move out of individual array elements.\n     fn array_subpath(&self, path: Self::Path, index: u32, size: u32) -> Option<Self::Path>;\n }\n \n@@ -106,6 +168,14 @@ where\n     unwind: Unwind,\n }\n \n+/// \"Elaborates\" a drop of `place`/`path` and patches `bb`'s terminator to execute it.\n+///\n+/// The passed `elaborator` is used to determine what should happen at the drop terminator. It\n+/// decides whether the drop can be statically determined or whether it needs a dynamic drop flag,\n+/// and whether the drop is \"open\", ie. should be expanded to drop all subfields of the dropped\n+/// value.\n+///\n+/// When this returns, the MIR patch in the `elaborator` contains the necessary changes.\n pub fn elaborate_drop<'b, 'tcx, D>(\n     elaborator: &mut D,\n     source_info: SourceInfo,\n@@ -346,9 +416,7 @@ where\n         let interior = self.tcx().mk_place_deref(self.place);\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n-        let succ = self.succ; // FIXME(#43234)\n-        let unwind = self.unwind;\n-        let succ = self.box_free_block(adt, substs, succ, unwind);\n+        let succ = self.box_free_block(adt, substs, self.succ, self.unwind);\n         let unwind_succ =\n             self.unwind.map(|unwind| self.box_free_block(adt, substs, unwind, Unwind::InCleanup));\n \n@@ -829,6 +897,8 @@ where\n         self.drop_flag_test_block(drop_block, succ, unwind)\n     }\n \n+    /// Creates a block that resets the drop flag. If `mode` is deep, all children drop flags will\n+    /// also be cleared.\n     fn drop_flag_reset_block(\n         &mut self,\n         mode: DropFlagMode,\n@@ -850,13 +920,15 @@ where\n \n     fn elaborated_drop_block(&mut self) -> BasicBlock {\n         debug!(\"elaborated_drop_block({:?})\", self);\n-        let unwind = self.unwind; // FIXME(#43234)\n-        let succ = self.succ;\n-        let blk = self.drop_block(succ, unwind);\n+        let blk = self.drop_block(self.succ, self.unwind);\n         self.elaborate_drop(blk);\n         blk\n     }\n \n+    /// Creates a block that frees the backing memory of a `Box` if its drop is required (either\n+    /// statically or by checking its drop flag).\n+    ///\n+    /// The contained value will not be dropped.\n     fn box_free_block(\n         &mut self,\n         adt: &'tcx ty::AdtDef,\n@@ -868,6 +940,8 @@ where\n         self.drop_flag_test_block(block, target, unwind)\n     }\n \n+    /// Creates a block that frees the backing memory of a `Box` (without dropping the contained\n+    /// value).\n     fn unelaborated_free_block(\n         &mut self,\n         adt: &'tcx ty::AdtDef,\n@@ -914,6 +988,11 @@ where\n         self.new_block(unwind, block)\n     }\n \n+    /// Returns the block to jump to in order to test the drop flag and execute the drop.\n+    ///\n+    /// Depending on the required `DropStyle`, this might be a generated block with an `if`\n+    /// terminator (for dynamic/open drops), or it might be `on_set` or `on_unset` itself, in case\n+    /// the drop can be statically determined.\n     fn drop_flag_test_block(\n         &mut self,\n         on_set: BasicBlock,"}, {"sha": "396965fcfb8b790c63b5eedaaa694b8d3b897bbf", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1277,7 +1277,8 @@ crate fn required_region_bounds(\n                 | ty::Predicate::ObjectSafe(..)\n                 | ty::Predicate::ClosureKind(..)\n                 | ty::Predicate::RegionOutlives(..)\n-                | ty::Predicate::ConstEvaluatable(..) => None,\n+                | ty::Predicate::ConstEvaluatable(..)\n+                | ty::Predicate::ConstEquate(..) => None,\n                 ty::Predicate::TypeOutlives(predicate) => {\n                     // Search for a bound of the form `erased_self_ty\n                     // : 'a`, but be wary of something like `for<'a>"}, {"sha": "139b86007222447b02bc49be1fee5fe3a289021a", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -615,6 +615,17 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             obligation\n                         )\n                     }\n+\n+                    ty::Predicate::ConstEquate(..) => {\n+                        // Errors for `ConstEquate` predicates show up as\n+                        // `SelectionError::ConstEvalFailure`,\n+                        // not `Unimplemented`.\n+                        span_bug!(\n+                            span,\n+                            \"const-equate requirement gave wrong error: `{:?}`\",\n+                            obligation\n+                        )\n+                    }\n                 }\n             }\n \n@@ -1092,6 +1103,15 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 )\n                 .emit();\n             }\n+            FulfillmentErrorCode::CodeConstEquateError(ref expected_found, ref err) => {\n+                self.report_mismatched_consts(\n+                    &error.obligation.cause,\n+                    expected_found.expected,\n+                    expected_found.found,\n+                    err.clone(),\n+                )\n+                .emit();\n+            }\n         }\n     }\n "}, {"sha": "98f6ac0e5472846c326a727447cd932c6dfb7ff2", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -2,9 +2,11 @@ use crate::infer::{InferCtxt, TyOrConstInferVar};\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n+use rustc_errors::ErrorReported;\n use rustc_infer::traits::{TraitEngine, TraitEngineExt as _};\n+use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n-use rustc_middle::ty::{self, ToPolyTraitRef, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, Const, ToPolyTraitRef, Ty, TypeFoldable};\n use std::marker::PhantomData;\n \n use super::project;\n@@ -520,6 +522,68 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                     Err(err) => ProcessResult::Error(CodeSelectionError(ConstEvalFailure(err))),\n                 }\n             }\n+\n+            ty::Predicate::ConstEquate(c1, c2) => {\n+                debug!(\"equating consts: c1={:?} c2={:?}\", c1, c2);\n+\n+                let stalled_on = &mut pending_obligation.stalled_on;\n+\n+                let mut evaluate = |c: &'tcx Const<'tcx>| {\n+                    if let ty::ConstKind::Unevaluated(def_id, substs, promoted) = c.val {\n+                        match self.selcx.infcx().const_eval_resolve(\n+                            obligation.param_env,\n+                            def_id,\n+                            substs,\n+                            promoted,\n+                            Some(obligation.cause.span),\n+                        ) {\n+                            Ok(val) => Ok(Const::from_value(self.selcx.tcx(), val, c.ty)),\n+                            Err(ErrorHandled::TooGeneric) => {\n+                                stalled_on.append(\n+                                    &mut substs\n+                                        .types()\n+                                        .filter_map(|ty| TyOrConstInferVar::maybe_from_ty(ty))\n+                                        .collect(),\n+                                );\n+                                Err(ErrorHandled::TooGeneric)\n+                            }\n+                            Err(err) => Err(err),\n+                        }\n+                    } else {\n+                        Ok(c)\n+                    }\n+                };\n+\n+                match (evaluate(c1), evaluate(c2)) {\n+                    (Ok(c1), Ok(c2)) => {\n+                        match self\n+                            .selcx\n+                            .infcx()\n+                            .at(&obligation.cause, obligation.param_env)\n+                            .eq(c1, c2)\n+                        {\n+                            Ok(_) => ProcessResult::Changed(vec![]),\n+                            Err(err) => {\n+                                ProcessResult::Error(FulfillmentErrorCode::CodeConstEquateError(\n+                                    ExpectedFound::new(true, c1, c2),\n+                                    err,\n+                                ))\n+                            }\n+                        }\n+                    }\n+                    (Err(ErrorHandled::Reported(ErrorReported)), _)\n+                    | (_, Err(ErrorHandled::Reported(ErrorReported))) => ProcessResult::Error(\n+                        CodeSelectionError(ConstEvalFailure(ErrorHandled::Reported(ErrorReported))),\n+                    ),\n+                    (Err(ErrorHandled::Linted), _) | (_, Err(ErrorHandled::Linted)) => span_bug!(\n+                        obligation.cause.span(self.selcx.tcx()),\n+                        \"ConstEquate: const_eval_resolve returned an unexpected error\"\n+                    ),\n+                    (Err(ErrorHandled::TooGeneric), _) | (_, Err(ErrorHandled::TooGeneric)) => {\n+                        ProcessResult::Unchanged\n+                    }\n+                }\n+            }\n         }\n     }\n "}, {"sha": "1bfcacd6ccdc12828b2dde3150e0a9db6f19ab3a", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 58, "deletions": 41, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -16,8 +16,9 @@ use crate::traits::{self, Obligation, ObligationCause};\n use rustc_errors::{Applicability, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst};\n-use rustc_middle::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n+use rustc_middle::ty::subst::{GenericArg, InternalSubsts, Subst};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor, WithConstness};\n+use rustc_middle::ty::{Predicate, ToPredicate};\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -281,7 +282,8 @@ fn predicates_reference_self(\n                 | ty::Predicate::RegionOutlives(..)\n                 | ty::Predicate::ClosureKind(..)\n                 | ty::Predicate::Subtype(..)\n-                | ty::Predicate::ConstEvaluatable(..) => None,\n+                | ty::Predicate::ConstEvaluatable(..)\n+                | ty::Predicate::ConstEquate(..) => None,\n             }\n         })\n         .collect()\n@@ -313,7 +315,8 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         | ty::Predicate::ObjectSafe(..)\n         | ty::Predicate::ClosureKind(..)\n         | ty::Predicate::TypeOutlives(..)\n-        | ty::Predicate::ConstEvaluatable(..) => false,\n+        | ty::Predicate::ConstEvaluatable(..)\n+        | ty::Predicate::ConstEquate(..) => false,\n     })\n }\n \n@@ -724,51 +727,65 @@ fn contains_illegal_self_type_reference<'tcx>(\n     // object type, and we cannot resolve `Self as SomeOtherTrait`\n     // without knowing what `Self` is.\n \n-    let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n-    let self_ty = tcx.types.self_param;\n-\n-    let mut walker = ty.walk();\n-    while let Some(arg) = walker.next() {\n-        if arg == self_ty.into() {\n-            return true;\n-        }\n-\n-        // Special-case projections (everything else is walked normally).\n-        if let GenericArgKind::Type(ty) = arg.unpack() {\n-            if let ty::Projection(ref data) = ty.kind {\n-                // This is a projected type `<Foo as SomeTrait>::X`.\n+    struct IllegalSelfTypeVisitor<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        self_ty: Ty<'tcx>,\n+        trait_def_id: DefId,\n+        supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>>,\n+    }\n \n-                // Compute supertraits of current trait lazily.\n-                if supertraits.is_none() {\n-                    let trait_ref = ty::Binder::bind(ty::TraitRef::identity(tcx, trait_def_id));\n-                    supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n-                }\n+    impl<'tcx> TypeVisitor<'tcx> for IllegalSelfTypeVisitor<'tcx> {\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+            match t.kind {\n+                ty::Param(_) => t == self.self_ty,\n+                ty::Projection(ref data) => {\n+                    // This is a projected type `<Foo as SomeTrait>::X`.\n+\n+                    // Compute supertraits of current trait lazily.\n+                    if self.supertraits.is_none() {\n+                        let trait_ref =\n+                            ty::Binder::bind(ty::TraitRef::identity(self.tcx, self.trait_def_id));\n+                        self.supertraits = Some(traits::supertraits(self.tcx, trait_ref).collect());\n+                    }\n \n-                // Determine whether the trait reference `Foo as\n-                // SomeTrait` is in fact a supertrait of the\n-                // current trait. In that case, this type is\n-                // legal, because the type `X` will be specified\n-                // in the object type.  Note that we can just use\n-                // direct equality here because all of these types\n-                // are part of the formal parameter listing, and\n-                // hence there should be no inference variables.\n-                let projection_trait_ref = ty::Binder::bind(data.trait_ref(tcx));\n-                let is_supertrait_of_current_trait =\n-                    supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n-\n-                if is_supertrait_of_current_trait {\n-                    // Do not walk contained types, do not report error, do collect $200.\n-                    walker.skip_current_subtree();\n+                    // Determine whether the trait reference `Foo as\n+                    // SomeTrait` is in fact a supertrait of the\n+                    // current trait. In that case, this type is\n+                    // legal, because the type `X` will be specified\n+                    // in the object type.  Note that we can just use\n+                    // direct equality here because all of these types\n+                    // are part of the formal parameter listing, and\n+                    // hence there should be no inference variables.\n+                    let projection_trait_ref = ty::Binder::bind(data.trait_ref(self.tcx));\n+                    let is_supertrait_of_current_trait =\n+                        self.supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n+\n+                    if is_supertrait_of_current_trait {\n+                        false // do not walk contained types, do not report error, do collect $200\n+                    } else {\n+                        t.super_visit_with(self) // DO walk contained types, POSSIBLY reporting an error\n+                    }\n                 }\n-\n-                // DO walk contained types, POSSIBLY reporting an error.\n+                _ => t.super_visit_with(self), // walk contained types, if any\n             }\n         }\n \n-        // Walk contained types, if any.\n+        fn visit_const(&mut self, _c: &ty::Const<'tcx>) -> bool {\n+            // FIXME(#72219) Look into the unevaluated constants for object safety violations.\n+            // Do not walk substitutions of unevaluated consts, as they contain `Self`, even\n+            // though the const expression doesn't necessary use it. Currently type variables\n+            // inside array length expressions are forbidden, so they can't break the above\n+            // rules.\n+            false\n+        }\n     }\n \n-    false\n+    ty.visit_with(&mut IllegalSelfTypeVisitor {\n+        tcx,\n+        self_ty: tcx.types.self_param,\n+        trait_def_id,\n+        supertraits: None,\n+    })\n }\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {"}, {"sha": "c4cb72fa08c08c1c4806c7743919c4282b341fd6", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -388,8 +388,12 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n \n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        let constant = constant.super_fold_with(self);\n-        constant.eval(self.selcx.tcx(), self.param_env)\n+        if self.selcx.tcx().lazy_normalization() {\n+            constant\n+        } else {\n+            let constant = constant.super_fold_with(self);\n+            constant.eval(self.selcx.tcx(), self.param_env)\n+        }\n     }\n }\n "}, {"sha": "70c6cbef102c53c1da1532c22b2b548b9a9870b7", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -38,11 +38,13 @@ use crate::traits::project::ProjectionCacheKeyExt;\n use rustc_ast::attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n+use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n+use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n@@ -503,9 +505,48 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     None,\n                 ) {\n                     Ok(_) => Ok(EvaluatedToOk),\n+                    Err(ErrorHandled::TooGeneric) => Ok(EvaluatedToAmbig),\n                     Err(_) => Ok(EvaluatedToErr),\n                 }\n             }\n+\n+            ty::Predicate::ConstEquate(c1, c2) => {\n+                debug!(\"evaluate_predicate_recursively: equating consts c1={:?} c2={:?}\", c1, c2);\n+\n+                let evaluate = |c: &'tcx ty::Const<'tcx>| {\n+                    if let ty::ConstKind::Unevaluated(def_id, substs, promoted) = c.val {\n+                        self.infcx\n+                            .const_eval_resolve(\n+                                obligation.param_env,\n+                                def_id,\n+                                substs,\n+                                promoted,\n+                                Some(obligation.cause.span),\n+                            )\n+                            .map(|val| ty::Const::from_value(self.tcx(), val, c.ty))\n+                    } else {\n+                        Ok(c)\n+                    }\n+                };\n+\n+                match (evaluate(c1), evaluate(c2)) {\n+                    (Ok(c1), Ok(c2)) => {\n+                        match self.infcx().at(&obligation.cause, obligation.param_env).eq(c1, c2) {\n+                            Ok(_) => Ok(EvaluatedToOk),\n+                            Err(_) => Ok(EvaluatedToErr),\n+                        }\n+                    }\n+                    (Err(ErrorHandled::Reported(ErrorReported)), _)\n+                    | (_, Err(ErrorHandled::Reported(ErrorReported))) => Ok(EvaluatedToErr),\n+                    (Err(ErrorHandled::Linted), _) | (_, Err(ErrorHandled::Linted)) => span_bug!(\n+                        obligation.cause.span(self.tcx()),\n+                        \"ConstEquate: const_eval_resolve returned an unexpected error\"\n+                    ),\n+                    (Err(ErrorHandled::TooGeneric), _) | (_, Err(ErrorHandled::TooGeneric)) => {\n+                        Ok(EvaluatedToAmbig)\n+                    }\n+                }\n+            }\n         }\n     }\n "}, {"sha": "4d3bbfa77c37d99e0088fb35f573b71952d23316", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -102,6 +102,10 @@ pub fn predicate_obligations<'a, 'tcx>(\n                 wf.compute(ty);\n             }\n         }\n+        ty::Predicate::ConstEquate(c1, c2) => {\n+            wf.compute(c1.ty);\n+            wf.compute(c2.ty);\n+        }\n     }\n \n     wf.normalize()"}, {"sha": "184b9a9dc104027464af718f8fbc2eb5b27140aa", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -126,9 +126,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                     | ty::Predicate::ObjectSafe(..)\n                     | ty::Predicate::ClosureKind(..)\n                     | ty::Predicate::Subtype(..)\n-                    | ty::Predicate::ConstEvaluatable(..) => {\n-                        bug!(\"unexpected predicate {}\", predicate)\n-                    }\n+                    | ty::Predicate::ConstEvaluatable(..)\n+                    | ty::Predicate::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n                 }\n             }\n             ChalkEnvironmentClause::TypeFromEnv(ty) => Some(\n@@ -192,9 +191,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             Predicate::ObjectSafe(..)\n             | Predicate::ClosureKind(..)\n             | Predicate::Subtype(..)\n-            | Predicate::ConstEvaluatable(..) => {\n-                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n-            }\n+            | Predicate::ConstEvaluatable(..)\n+            | Predicate::ConstEquate(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n         }\n     }\n }\n@@ -459,7 +457,8 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             Predicate::ObjectSafe(..)\n             | Predicate::ClosureKind(..)\n             | Predicate::Subtype(..)\n-            | Predicate::ConstEvaluatable(..) => bug!(\"unexpected predicate {}\", &self),\n+            | Predicate::ConstEvaluatable(..)\n+            | Predicate::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n         }\n     }\n }"}, {"sha": "eaaab87ab747467aa1952c653391b60458f04769", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -100,7 +100,8 @@ fn compute_implied_outlives_bounds<'tcx>(\n                 | ty::Predicate::Projection(..)\n                 | ty::Predicate::ClosureKind(..)\n                 | ty::Predicate::ObjectSafe(..)\n-                | ty::Predicate::ConstEvaluatable(..) => vec![],\n+                | ty::Predicate::ConstEvaluatable(..)\n+                | ty::Predicate::ConstEquate(..) => vec![],\n \n                 ty::Predicate::WellFormed(subty) => {\n                     wf_types.push(subty);"}, {"sha": "ed30ed5313e5c591ff3eca0df43cd70ea0c64c81", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -48,6 +48,7 @@ fn not_outlives_predicate(p: &ty::Predicate<'_>) -> bool {\n         | ty::Predicate::ObjectSafe(..)\n         | ty::Predicate::ClosureKind(..)\n         | ty::Predicate::Subtype(..)\n-        | ty::Predicate::ConstEvaluatable(..) => true,\n+        | ty::Predicate::ConstEvaluatable(..)\n+        | ty::Predicate::ConstEquate(..) => true,\n     }\n }"}, {"sha": "54562cf38addd1eb2ae3915d780ab6b1e2613c1a", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 69, "deletions": 22, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -793,7 +793,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 //     `unsafe fn(arg0,arg1,...) -> _`\n                 let closure_sig = substs_a.as_closure().sig();\n                 let unsafety = fn_ty.unsafety();\n-                let pointer_ty = self.tcx.coerce_closure_fn_ty(closure_sig, unsafety);\n+                let pointer_ty =\n+                    self.tcx.mk_fn_ptr(self.tcx.signature_unclosure(closure_sig, unsafety));\n                 debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\", a, b, pointer_ty);\n                 self.unify_and(\n                     pointer_ty,\n@@ -909,23 +910,63 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"coercion::try_find_coercion_lub({:?}, {:?})\", prev_ty, new_ty);\n \n         // Special-case that coercion alone cannot handle:\n-        // Two function item types of differing IDs or InternalSubsts.\n-        if let (&ty::FnDef(..), &ty::FnDef(..)) = (&prev_ty.kind, &new_ty.kind) {\n-            // Don't reify if the function types have a LUB, i.e., they\n-            // are the same function and their parameters have a LUB.\n-            let lub_ty = self\n-                .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n-                .map(|ok| self.register_infer_ok_obligations(ok));\n-\n-            if lub_ty.is_ok() {\n-                // We have a LUB of prev_ty and new_ty, just return it.\n-                return lub_ty;\n+        // Function items or non-capturing closures of differing IDs or InternalSubsts.\n+        let (a_sig, b_sig) = {\n+            let is_capturing_closure = |ty| {\n+                if let &ty::Closure(_, substs) = ty {\n+                    substs.as_closure().upvar_tys().next().is_some()\n+                } else {\n+                    false\n+                }\n+            };\n+            if is_capturing_closure(&prev_ty.kind) || is_capturing_closure(&new_ty.kind) {\n+                (None, None)\n+            } else {\n+                match (&prev_ty.kind, &new_ty.kind) {\n+                    (&ty::FnDef(..), &ty::FnDef(..)) => {\n+                        // Don't reify if the function types have a LUB, i.e., they\n+                        // are the same function and their parameters have a LUB.\n+                        match self\n+                            .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n+                        {\n+                            // We have a LUB of prev_ty and new_ty, just return it.\n+                            Ok(ok) => return Ok(self.register_infer_ok_obligations(ok)),\n+                            Err(_) => {\n+                                (Some(prev_ty.fn_sig(self.tcx)), Some(new_ty.fn_sig(self.tcx)))\n+                            }\n+                        }\n+                    }\n+                    (&ty::Closure(_, substs), &ty::FnDef(..)) => {\n+                        let b_sig = new_ty.fn_sig(self.tcx);\n+                        let a_sig = self\n+                            .tcx\n+                            .signature_unclosure(substs.as_closure().sig(), b_sig.unsafety());\n+                        (Some(a_sig), Some(b_sig))\n+                    }\n+                    (&ty::FnDef(..), &ty::Closure(_, substs)) => {\n+                        let a_sig = prev_ty.fn_sig(self.tcx);\n+                        let b_sig = self\n+                            .tcx\n+                            .signature_unclosure(substs.as_closure().sig(), a_sig.unsafety());\n+                        (Some(a_sig), Some(b_sig))\n+                    }\n+                    (&ty::Closure(_, substs_a), &ty::Closure(_, substs_b)) => (\n+                        Some(self.tcx.signature_unclosure(\n+                            substs_a.as_closure().sig(),\n+                            hir::Unsafety::Normal,\n+                        )),\n+                        Some(self.tcx.signature_unclosure(\n+                            substs_b.as_closure().sig(),\n+                            hir::Unsafety::Normal,\n+                        )),\n+                    ),\n+                    _ => (None, None),\n+                }\n             }\n-\n+        };\n+        if let (Some(a_sig), Some(b_sig)) = (a_sig, b_sig) {\n             // The signature must match.\n-            let a_sig = prev_ty.fn_sig(self.tcx);\n             let a_sig = self.normalize_associated_types_in(new.span, &a_sig);\n-            let b_sig = new_ty.fn_sig(self.tcx);\n             let b_sig = self.normalize_associated_types_in(new.span, &b_sig);\n             let sig = self\n                 .at(cause, self.param_env)\n@@ -935,17 +976,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Reify both sides and return the reified fn pointer type.\n             let fn_ptr = self.tcx.mk_fn_ptr(sig);\n-            for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n-                // The only adjustment that can produce an fn item is\n-                // `NeverToAny`, so this should always be valid.\n+            let prev_adjustment = match prev_ty.kind {\n+                ty::Closure(..) => Adjust::Pointer(PointerCast::ClosureFnPointer(a_sig.unsafety())),\n+                ty::FnDef(..) => Adjust::Pointer(PointerCast::ReifyFnPointer),\n+                _ => unreachable!(),\n+            };\n+            let next_adjustment = match new_ty.kind {\n+                ty::Closure(..) => Adjust::Pointer(PointerCast::ClosureFnPointer(b_sig.unsafety())),\n+                ty::FnDef(..) => Adjust::Pointer(PointerCast::ReifyFnPointer),\n+                _ => unreachable!(),\n+            };\n+            for expr in exprs.iter().map(|e| e.as_coercion_site()) {\n                 self.apply_adjustments(\n                     expr,\n-                    vec![Adjustment {\n-                        kind: Adjust::Pointer(PointerCast::ReifyFnPointer),\n-                        target: fn_ptr,\n-                    }],\n+                    vec![Adjustment { kind: prev_adjustment.clone(), target: fn_ptr }],\n                 );\n             }\n+            self.apply_adjustments(new, vec![Adjustment { kind: next_adjustment, target: fn_ptr }]);\n             return Ok(fn_ptr);\n         }\n "}, {"sha": "e21db9035e25d11da0e565561fd774accf9c5404", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -810,7 +810,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             | ty::Predicate::ObjectSafe(..)\n             | ty::Predicate::ClosureKind(..)\n             | ty::Predicate::TypeOutlives(..)\n-            | ty::Predicate::ConstEvaluatable(..) => None,\n+            | ty::Predicate::ConstEvaluatable(..)\n+            | ty::Predicate::ConstEquate(..) => None,\n         });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {"}, {"sha": "d72c74e4188ee04c2826ccb593dfca5f5796cd39", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1648,6 +1648,16 @@ fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: LocalDefId,\n \n             r.super_visit_with(self)\n         }\n+\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+            if let ty::ConstKind::Unevaluated(..) = c.val {\n+                // FIXME(#72219) We currenctly don't detect lifetimes within substs\n+                // which would violate this check. Even though the particular substitution is not used\n+                // within the const, this should still be fixed.\n+                return false;\n+            }\n+            c.super_visit_with(self)\n+        }\n     }\n \n     let prohibit_opaque = match item.kind {\n@@ -3858,6 +3868,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ty::Predicate::WellFormed(..) => None,\n                 ty::Predicate::ObjectSafe(..) => None,\n                 ty::Predicate::ConstEvaluatable(..) => None,\n+                ty::Predicate::ConstEquate(..) => None,\n                 // N.B., this predicate is created by breaking down a\n                 // `ClosureType: FnFoo()` predicate, where\n                 // `ClosureType` represents some `Closure`. It can't"}, {"sha": "7cfb89f3ff048eeb29d6c744ea6064663ecc44a8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1164,15 +1164,16 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n             Some(tcx.hir().local_def_id(parent_id).to_def_id())\n         }\n-        // FIXME(#43408) enable this always when we get lazy normalization.\n+        // FIXME(#43408) always enable this once `lazy_normalization` is\n+        // stable enough and does not need a feature gate anymore.\n         Node::AnonConst(_) => {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n             let parent_def_id = tcx.hir().local_def_id(parent_id);\n \n             // HACK(eddyb) this provides the correct generics when\n             // `feature(const_generics)` is enabled, so that const expressions\n             // used with const generics, e.g. `Foo<{N+1}>`, can work at all.\n-            if tcx.features().const_generics {\n+            if tcx.lazy_normalization() {\n                 Some(parent_def_id.to_def_id())\n             } else {\n                 let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));"}, {"sha": "919bcc9943d4883920cd80890f51f5a158cab023", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -413,6 +413,7 @@ fn trait_predicate_kind<'tcx>(\n         | ty::Predicate::Subtype(_)\n         | ty::Predicate::ObjectSafe(_)\n         | ty::Predicate::ClosureKind(..)\n-        | ty::Predicate::ConstEvaluatable(..) => None,\n+        | ty::Predicate::ConstEvaluatable(..)\n+        | ty::Predicate::ConstEquate(..) => None,\n     }\n }"}, {"sha": "66daf0e7f7d9df6df31870c5f66743e7203c2153", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -58,7 +58,8 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     | ty::Predicate::ObjectSafe(..)\n                     | ty::Predicate::ClosureKind(..)\n                     | ty::Predicate::Subtype(..)\n-                    | ty::Predicate::ConstEvaluatable(..) => (),\n+                    | ty::Predicate::ConstEvaluatable(..)\n+                    | ty::Predicate::ConstEquate(..) => (),\n                 }\n             }\n "}, {"sha": "c130ed3f46dbb5d7916d1d2896e17c066a2a569a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -493,7 +493,8 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n             Predicate::WellFormed(..)\n             | Predicate::ObjectSafe(..)\n             | Predicate::ClosureKind(..)\n-            | Predicate::ConstEvaluatable(..) => panic!(\"not user writable\"),\n+            | Predicate::ConstEvaluatable(..)\n+            | Predicate::ConstEquate(..) => panic!(\"not user writable\"),\n         }\n     }\n }"}, {"sha": "9133a292103089ed8e4221aad2a9d4f8c8f0f237", "filename": "src/test/ui/closures/closure_cap_coerce_many_fail.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,39 @@\n+fn add(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+fn main() {\n+    // We shouldn't coerce capturing closure to a function\n+    let cap = 0;\n+    let _ = match \"+\" {\n+        \"+\" => add,\n+        \"-\" => |a, b| (a - b + cap) as i32,\n+        _ => unimplemented!(),\n+    };\n+    //~^^^ ERROR `match` arms have incompatible types\n+\n+\n+    // We shouldn't coerce capturing closure to a non-capturing closure\n+    let _ = match \"+\" {\n+        \"+\" => |a, b| (a + b) as i32,\n+        \"-\" => |a, b| (a - b + cap) as i32,\n+        _ => unimplemented!(),\n+    };\n+    //~^^^ ERROR `match` arms have incompatible types\n+\n+\n+    // We shouldn't coerce non-capturing closure to a capturing closure\n+    let _ = match \"+\" {\n+        \"+\" => |a, b| (a + b + cap) as i32,\n+        \"-\" => |a, b| (a - b) as i32,\n+        _ => unimplemented!(),\n+    };\n+    //~^^^ ERROR `match` arms have incompatible types\n+\n+    // We shouldn't coerce capturing closure to a capturing closure\n+    let _ = match \"+\" {\n+        \"+\" => |a, b| (a + b + cap) as i32,\n+        \"-\" => |a, b| (a - b + cap) as i32,\n+        _ => unimplemented!(),\n+    };\n+    //~^^^ ERROR `match` arms have incompatible types\n+}"}, {"sha": "63eb0bd8fabad3d4bc4ba84bb021832474f22088", "filename": "src/test/ui/closures/closure_cap_coerce_many_fail.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,73 @@\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/closure_cap_coerce_many_fail.rs:9:16\n+   |\n+LL |       let _ = match \"+\" {\n+   |  _____________-\n+LL | |         \"+\" => add,\n+   | |                --- this is found to be of type `fn(i32, i32) -> i32 {add}`\n+LL | |         \"-\" => |a, b| (a - b + cap) as i32,\n+   | |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected fn item, found closure\n+LL | |         _ => unimplemented!(),\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `fn(i32, i32) -> i32 {add}`\n+           found closure `[closure@$DIR/closure_cap_coerce_many_fail.rs:9:16: 9:43 cap:_]`\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/closure_cap_coerce_many_fail.rs:18:16\n+   |\n+LL |       let _ = match \"+\" {\n+   |  _____________-\n+LL | |         \"+\" => |a, b| (a + b) as i32,\n+   | |                --------------------- this is found to be of type `[closure@$DIR/closure_cap_coerce_many_fail.rs:17:16: 17:37]`\n+LL | |         \"-\" => |a, b| (a - b + cap) as i32,\n+   | |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found a different closure\n+LL | |         _ => unimplemented!(),\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `[closure@$DIR/closure_cap_coerce_many_fail.rs:17:16: 17:37]`\n+           found closure `[closure@$DIR/closure_cap_coerce_many_fail.rs:18:16: 18:43 cap:_]`\n+   = note: no two closures, even if identical, have the same type\n+   = help: consider boxing your closure and/or using it as a trait object\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/closure_cap_coerce_many_fail.rs:27:16\n+   |\n+LL |       let _ = match \"+\" {\n+   |  _____________-\n+LL | |         \"+\" => |a, b| (a + b + cap) as i32,\n+   | |                --------------------------- this is found to be of type `[closure@$DIR/closure_cap_coerce_many_fail.rs:26:16: 26:43 cap:_]`\n+LL | |         \"-\" => |a, b| (a - b) as i32,\n+   | |                ^^^^^^^^^^^^^^^^^^^^^ expected closure, found a different closure\n+LL | |         _ => unimplemented!(),\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `[closure@$DIR/closure_cap_coerce_many_fail.rs:26:16: 26:43 cap:_]`\n+           found closure `[closure@$DIR/closure_cap_coerce_many_fail.rs:27:16: 27:37]`\n+   = note: no two closures, even if identical, have the same type\n+   = help: consider boxing your closure and/or using it as a trait object\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/closure_cap_coerce_many_fail.rs:35:16\n+   |\n+LL |       let _ = match \"+\" {\n+   |  _____________-\n+LL | |         \"+\" => |a, b| (a + b + cap) as i32,\n+   | |                --------------------------- this is found to be of type `[closure@$DIR/closure_cap_coerce_many_fail.rs:34:16: 34:43 cap:_]`\n+LL | |         \"-\" => |a, b| (a - b + cap) as i32,\n+   | |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found a different closure\n+LL | |         _ => unimplemented!(),\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `[closure@$DIR/closure_cap_coerce_many_fail.rs:34:16: 34:43 cap:_]`\n+           found closure `[closure@$DIR/closure_cap_coerce_many_fail.rs:35:16: 35:43 cap:_]`\n+   = note: no two closures, even if identical, have the same type\n+   = help: consider boxing your closure and/or using it as a trait object\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "ce461810ec990239c82cab6cfa126a0e11e9e45c", "filename": "src/test/ui/closures/closure_no_cap_coerce_many_check_pass.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_check_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_check_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_check_pass.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,166 @@\n+// check-pass\n+// Ensure non-capturing Closure passes CoerceMany.\n+fn foo(x: usize) -> usize {\n+    0\n+}\n+\n+fn bar(x: usize) -> usize {\n+    1\n+}\n+\n+fn main() {\n+    // One FnDef and one non-capturing Closure\n+    let _ = match 0 {\n+        0 => foo,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = match 0 {\n+        2 => |a| 2,\n+        0 => foo,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = [foo, |a| 2];\n+    let _ = [|a| 2, foo];\n+\n+\n+\n+    // Two FnDefs and one non-capturing Closure\n+    let _ = match 0 {\n+        0 => foo,\n+        1 => bar,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = match 0 {\n+        0 => foo,\n+        2 => |a| 2,\n+        1 => bar,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = match 0 {\n+        2 => |a| 2,\n+        0 => foo,\n+        1 => bar,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = [foo, bar, |a| 2];\n+    let _ = [foo, |a| 2, bar];\n+    let _ = [|a| 2, foo, bar];\n+\n+\n+\n+    // One FnDef and two non-capturing Closures\n+    let _ = match 0 {\n+        0 => foo,\n+        1 => |a| 1,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = match 0 {\n+        1 => |a| 1,\n+        0 => foo,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = match 0 {\n+        1 => |a| 1,\n+        2 => |a| 2,\n+        0 => foo,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = [foo, |a| 1, |a| 2];\n+    let _ = [|a| 1, foo, |a| 2];\n+    let _ = [|a| 1, |a| 2, foo];\n+\n+\n+\n+    // Three non-capturing Closures\n+    let _ = match 0 {\n+        0 => |a: usize| 0,\n+        1 => |a| 1,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = [|a: usize| 0, |a| 1, |a| 2];\n+\n+\n+\n+    // Three non-capturing Closures variable\n+    let clo0 = |a: usize| 0;\n+    let clo1 = |a| 1;\n+    let clo2 = |a| 2;\n+    let _ = match 0 {\n+        0 => clo0,\n+        1 => clo1,\n+        2 => clo2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let clo0 = |a: usize| 0;\n+    let clo1 = |a| 1;\n+    let clo2 = |a| 2;\n+    let _ = [clo0, clo1, clo2];\n+\n+\n+\n+    // --- Function pointer related part\n+\n+    // Closure is not in a variable\n+    type FnPointer = fn(usize) -> usize;\n+\n+    let _ = match 0 {\n+        0 => foo as FnPointer,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+    let _ = match 0 {\n+        2 => |a| 2,\n+        0 => foo as FnPointer,\n+        _ => unimplemented!(),\n+    };\n+    let _ = [foo as FnPointer, |a| 2];\n+    let _ = [|a| 2, foo as FnPointer];\n+    let _ = [foo, bar, |x| x];\n+    let _ = [foo as FnPointer, bar, |x| x];\n+    let _ = [foo, bar as FnPointer, |x| x];\n+    let _ = [foo, bar, (|x| x) as FnPointer];\n+    let _ = [foo as FnPointer, bar as FnPointer, |x| x];\n+\n+    // Closure is in a variable\n+    let x = |a| 2;\n+    let _ = match 0 {\n+        0 => foo as FnPointer,\n+        2 => x,\n+        _ => unimplemented!(),\n+    };\n+    let x = |a| 2;\n+    let _ = match 0 {\n+        2 => x,\n+        0 => foo as FnPointer,\n+        _ => unimplemented!(),\n+    };\n+    let x = |a| 2;\n+    let _ = [foo as FnPointer, x];\n+    let _ = [x, foo as FnPointer];\n+\n+    let x = |a| 2;\n+    let _ = [foo, bar, x];\n+    let x: FnPointer = |a| 2;\n+    let _ = [foo, bar, x];\n+    let x = |a| 2;\n+    let _ = [foo, bar as FnPointer, x];\n+    let x = |a| 2;\n+    let _ = [foo as FnPointer, bar, x];\n+    let x = |a| 2;\n+    let _ = [foo as FnPointer, bar as FnPointer, x];\n+}"}, {"sha": "3c5fe8a55027656ea72970caa1eb35bb1cd01421", "filename": "src/test/ui/closures/closure_no_cap_coerce_many_run_pass.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_run_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_run_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_run_pass.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,59 @@\n+// run-pass\n+// Ensure non-capturing Closure passing CoerceMany work correctly.\n+fn foo(_: usize) -> usize {\n+    0\n+}\n+\n+fn bar(_: usize) -> usize {\n+    1\n+}\n+\n+fn add(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+\n+fn main() {\n+    // Coerce result check\n+\n+    type FnPointer = fn(usize) -> usize;\n+\n+    let c = |x| x;\n+    let c_pointer: FnPointer = c;\n+    assert_eq!(c_pointer(42), 42);\n+\n+    let f = match 0 {\n+        0 => foo,\n+        1 => |_| 1,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(f(42), 0);\n+\n+    let f = match 2 {\n+        2 => |_| 2,\n+        0 => foo,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(f(42), 2);\n+\n+    let f = match 1 {\n+        0 => foo,\n+        1 => bar,\n+        2 => |_| 2,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(f(42), 1);\n+\n+    let clo0 = |_: usize| 0;\n+    let clo1 = |_| 1;\n+    let clo2 = |_| 2;\n+    let f = match 0 {\n+        0 => clo0,\n+        1 => clo1,\n+        2 => clo2,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(f(42), 0);\n+\n+    let funcs = [add, |a, b| (a - b) as i32];\n+    assert_eq!([funcs[0](5, 5), funcs[1](5, 5)], [10, 0]);\n+}"}, {"sha": "76a0f2914103d5c304b4e70402f68664bed980f8", "filename": "src/test/ui/closures/closure_no_cap_coerce_many_unsafe_0.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,22 @@\n+// Ensure we get unsafe function after coercion\n+unsafe fn add(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+fn main() {\n+    // We can coerce non-capturing closure to unsafe function\n+    let foo = match \"+\" {\n+        \"+\" => add,\n+        \"-\" => |a, b| (a - b) as i32,\n+        _ => unimplemented!(),\n+    };\n+    let result: i32 = foo(5, 5); //~ ERROR call to unsafe function\n+\n+\n+    // We can coerce unsafe function to non-capturing closure\n+    let foo = match \"+\" {\n+        \"-\" => |a, b| (a - b) as i32,\n+        \"+\" => add,\n+        _ => unimplemented!(),\n+    };\n+    let result: i32 = foo(5, 5); //~ ERROR call to unsafe function\n+}"}, {"sha": "190b4792ebcbc5e563fb973e759584f79d179d90", "filename": "src/test/ui/closures/closure_no_cap_coerce_many_unsafe_0.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,19 @@\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n+  --> $DIR/closure_no_cap_coerce_many_unsafe_0.rs:12:23\n+   |\n+LL |     let result: i32 = foo(5, 5);\n+   |                       ^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n+  --> $DIR/closure_no_cap_coerce_many_unsafe_0.rs:21:23\n+   |\n+LL |     let result: i32 = foo(5, 5);\n+   |                       ^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0133`."}, {"sha": "a6d6125a1b9f9d689bb3242dac4ad04d8f5f128e", "filename": "src/test/ui/closures/closure_no_cap_coerce_many_unsafe_1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_1.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+// Ensure we get correct unsafe function after coercion\n+unsafe fn add(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+fn main() {\n+    // We can coerce non-capturing closure to unsafe function\n+    let foo = match \"+\" {\n+        \"+\" => add,\n+        \"-\" => |a, b| (a - b) as i32,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(unsafe { foo(5, 5) }, 10);\n+\n+\n+    // We can coerce unsafe function to non-capturing closure\n+    let foo = match \"-\" {\n+        \"-\" => |a, b| (a - b) as i32,\n+        \"+\" => add,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(unsafe { foo(5, 5) }, 0);\n+}"}, {"sha": "cd8dc486906bbb0559a79bb3bee3b79d5fc6cd52", "filename": "src/test/ui/closures/issue-46742.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fissue-46742.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fissue-46742.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-46742.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+fn main() {\n+    let _: i32 = (match \"\" {\n+        \"+\" => ::std::ops::Add::add,\n+        \"-\" => ::std::ops::Sub::sub,\n+        \"<\" => |a,b| (a < b) as i32,\n+        _ => unimplemented!(),\n+    })(5, 5);\n+}"}, {"sha": "ce1f2a0364764b3da61064f4e79989865f0dbc86", "filename": "src/test/ui/closures/issue-48109.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fissue-48109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fclosures%2Fissue-48109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-48109.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+fn useful(i: usize) -> usize {\n+    i\n+}\n+\n+fn useful2(i: usize) -> usize {\n+    i\n+}\n+\n+fn main() {\n+    for f in &[useful, useful2, |x| x] {\n+        println!(\"{}\", f(6));\n+    }\n+}"}, {"sha": "7eb826b8a36b119a0fc6d4ca7ef261d279be62f9", "filename": "src/test/ui/const-generics/different_byref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -13,8 +13,8 @@ error[E0308]: mismatched types\n LL |     x = Const::<{ [4] }> {};\n    |         ^^^^^^^^^^^^^^^^^^^ expected `3usize`, found `4usize`\n    |\n-   = note: expected struct `Const<[3usize]>`\n-              found struct `Const<[4usize]>`\n+   = note: expected type `[3usize]`\n+              found type `[4usize]`\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "de41d2984a655e5f505157a14ca0e0c109ce567a", "filename": "src/test/ui/const-generics/fn-const-param-infer.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -11,12 +11,10 @@ error[E0308]: mismatched types\n   --> $DIR/fn-const-param-infer.rs:16:31\n    |\n LL |     let _: Checked<not_one> = Checked::<not_two>;\n-   |            ----------------   ^^^^^^^^^^^^^^^^^^ expected `{not_one as fn(usize) -> bool}`, found `{not_two as fn(usize) -> bool}`\n-   |            |\n-   |            expected due to this\n+   |                               ^^^^^^^^^^^^^^^^^^ expected `{not_one as fn(usize) -> bool}`, found `{not_two as fn(usize) -> bool}`\n    |\n-   = note: expected struct `Checked<{not_one as fn(usize) -> bool}>`\n-              found struct `Checked<{not_two as fn(usize) -> bool}>`\n+   = note: expected type `{not_one as fn(usize) -> bool}`\n+              found type `{not_two as fn(usize) -> bool}`\n \n error[E0308]: mismatched types\n   --> $DIR/fn-const-param-infer.rs:20:24\n@@ -37,12 +35,10 @@ error[E0308]: mismatched types\n   --> $DIR/fn-const-param-infer.rs:25:40\n    |\n LL |     let _: Checked<{generic::<u32>}> = Checked::<{generic::<u16>}>;\n-   |            -------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{generic::<u32> as fn(usize) -> bool}`, found `{generic::<u16> as fn(usize) -> bool}`\n-   |            |\n-   |            expected due to this\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{generic::<u32> as fn(usize) -> bool}`, found `{generic::<u16> as fn(usize) -> bool}`\n    |\n-   = note: expected struct `Checked<{generic::<u32> as fn(usize) -> bool}>`\n-              found struct `Checked<{generic::<u16> as fn(usize) -> bool}>`\n+   = note: expected type `{generic::<u32> as fn(usize) -> bool}`\n+              found type `{generic::<u16> as fn(usize) -> bool}`\n \n error: aborting due to 4 previous errors; 1 warning emitted\n "}, {"sha": "5c987e63a9e070c480478143c48393a317db1979", "filename": "src/test/ui/const-generics/issues/issue-61935.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete\n+\n+trait Foo {}\n+\n+impl<const N: usize> Foo for [(); N]\n+    where\n+        Self:FooImpl<{N==0}>\n+{}\n+\n+trait FooImpl<const IS_ZERO: bool>{}\n+\n+impl FooImpl<true> for [(); 0] {}\n+\n+impl<const N:usize> FooImpl<false> for [();N] {}\n+\n+fn foo(_: impl Foo) {}\n+\n+fn main() {\n+    foo([]);\n+    foo([()]);\n+}"}, {"sha": "cf0c0e24a7604b47dc2eabb0a7ae59b752154dde", "filename": "src/test/ui/const-generics/issues/issue-61935.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-61935.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "4e05aadd3930f4f81c7b4fa7b7472c0345b07dd9", "filename": "src/test/ui/const-generics/issues/issue-62504.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -16,8 +16,7 @@ struct ArrayHolder<const X: usize>([u32; X]);\n impl<const X: usize> ArrayHolder<X> {\n     pub const fn new() -> Self {\n         ArrayHolder([0; Self::SIZE])\n-        //~^ ERROR: mismatched types\n-        //~| ERROR constant expression depends on a generic parameter\n+        //~^ ERROR constant expression depends on a generic parameter\n     }\n }\n "}, {"sha": "f09af76325e96c9f98906e2acc435667099a00b3", "filename": "src/test/ui/const-generics/issues/issue-62504.stderr", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1,12 +1,3 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-62504.rs:18:21\n-   |\n-LL |         ArrayHolder([0; Self::SIZE])\n-   |                     ^^^^^^^^^^^^^^^ expected `X`, found `Self::SIZE`\n-   |\n-   = note: expected array `[u32; X]`\n-              found array `[u32; _]`\n-\n error: constant expression depends on a generic parameter\n   --> $DIR/issue-62504.rs:18:25\n    |\n@@ -15,6 +6,5 @@ LL |         ArrayHolder([0; Self::SIZE])\n    |\n    = note: this may fail depending on what value the parameter takes\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "76bde1815be18e10ec6e3472099a459a58cc3b56", "filename": "src/test/ui/const-generics/issues/issue-66205.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1,5 +1,6 @@\n #![allow(incomplete_features, dead_code, unconditional_recursion)]\n #![feature(const_generics)]\n+#![feature(lazy_normalization_consts)]\n \n fn fact<const N: usize>() {\n     fact::<{ N - 1 }>();"}, {"sha": "416b675b56d28cdec77fa8c77d7b79827fa5deed", "filename": "src/test/ui/const-generics/issues/issue-66205.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -1,5 +1,5 @@\n error: constant expression depends on a generic parameter\n-  --> $DIR/issue-66205.rs:5:12\n+  --> $DIR/issue-66205.rs:6:12\n    |\n LL |     fact::<{ N - 1 }>();\n    |            ^^^^^^^^^"}, {"sha": "b08057851a1ba9e946cab228a80cf51891f4d4b6", "filename": "src/test/ui/const-generics/issues/issue-67185-1.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-1.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete\n+\n+trait Baz {\n+    type Quaks;\n+}\n+impl Baz for u8 {\n+    type Quaks = [u16; 3];\n+}\n+\n+trait Bar {}\n+impl Bar for [u16; 3] {}\n+impl Bar for [[u16; 3]; 2] {}\n+\n+trait Foo\n+    where\n+        [<u8 as Baz>::Quaks; 2]: Bar,\n+        <u8 as Baz>::Quaks: Bar,\n+{\n+}\n+\n+struct FooImpl;\n+\n+impl Foo for FooImpl {}\n+\n+fn f(_: impl Foo) {}\n+\n+fn main() {\n+    f(FooImpl)\n+}"}, {"sha": "9cc797d6d8a017b704cf77c2830ec0f68e19b7fd", "filename": "src/test/ui/const-generics/issues/issue-67185-1.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-1.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-67185-1.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "111b718dd5efd52f6a0801d861646f1352ed00e6", "filename": "src/test/ui/const-generics/issues/issue-67185-2.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-2.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,35 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete\n+\n+trait Baz {\n+    type Quaks;\n+}\n+impl Baz for u8 {\n+    type Quaks = [u16; 3];\n+}\n+\n+trait Bar {}\n+impl Bar for [u16; 4] {}\n+impl Bar for [[u16; 3]; 3] {}\n+\n+trait Foo  //~ ERROR the trait bound `[u16; 3]: Bar` is not satisfied [E0277]\n+           //~^ ERROR the trait bound `[[u16; 3]; 2]: Bar` is not satisfied [E0277]\n+    where\n+        [<u8 as Baz>::Quaks; 2]: Bar,\n+        <u8 as Baz>::Quaks: Bar,\n+{\n+}\n+\n+struct FooImpl;\n+\n+impl Foo for FooImpl {}\n+//~^ ERROR the trait bound `[u16; 3]: Bar` is not satisfied [E0277]\n+//~^^ ERROR the trait bound `[[u16; 3]; 2]: Bar` is not satisfied [E0277]\n+\n+fn f(_: impl Foo) {}\n+//~^ ERROR the trait bound `[u16; 3]: Bar` is not satisfied [E0277]\n+//~^^ ERROR the trait bound `[[u16; 3]; 2]: Bar` is not satisfied [E0277]\n+\n+fn main() {\n+    f(FooImpl)\n+}"}, {"sha": "7d947a907a0ee02936f20629607e6c71a21ac6dc", "filename": "src/test/ui/const-generics/issues/issue-67185-2.stderr", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-2.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,112 @@\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-67185-2.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n+\n+error[E0277]: the trait bound `[u16; 3]: Bar` is not satisfied\n+  --> $DIR/issue-67185-2.rs:15:1\n+   |\n+LL | / trait Foo\n+LL | |\n+LL | |     where\n+LL | |         [<u8 as Baz>::Quaks; 2]: Bar,\n+LL | |         <u8 as Baz>::Quaks: Bar,\n+LL | | {\n+LL | | }\n+   | |_^ the trait `Bar` is not implemented for `[u16; 3]`\n+   |\n+   = help: the following implementations were found:\n+             <[[u16; 3]; 3] as Bar>\n+             <[u16; 4] as Bar>\n+   = help: see issue #48214\n+   = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable\n+\n+error[E0277]: the trait bound `[[u16; 3]; 2]: Bar` is not satisfied\n+  --> $DIR/issue-67185-2.rs:15:1\n+   |\n+LL | / trait Foo\n+LL | |\n+LL | |     where\n+LL | |         [<u8 as Baz>::Quaks; 2]: Bar,\n+LL | |         <u8 as Baz>::Quaks: Bar,\n+LL | | {\n+LL | | }\n+   | |_^ the trait `Bar` is not implemented for `[[u16; 3]; 2]`\n+   |\n+   = help: the following implementations were found:\n+             <[[u16; 3]; 3] as Bar>\n+             <[u16; 4] as Bar>\n+   = help: see issue #48214\n+   = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable\n+\n+error[E0277]: the trait bound `[u16; 3]: Bar` is not satisfied\n+  --> $DIR/issue-67185-2.rs:25:6\n+   |\n+LL | trait Foo\n+   |       --- required by a bound in this\n+...\n+LL |         <u8 as Baz>::Quaks: Bar,\n+   |                             --- required by this bound in `Foo`\n+...\n+LL | impl Foo for FooImpl {}\n+   |      ^^^ the trait `Bar` is not implemented for `[u16; 3]`\n+   |\n+   = help: the following implementations were found:\n+             <[[u16; 3]; 3] as Bar>\n+             <[u16; 4] as Bar>\n+\n+error[E0277]: the trait bound `[[u16; 3]; 2]: Bar` is not satisfied\n+  --> $DIR/issue-67185-2.rs:25:6\n+   |\n+LL | trait Foo\n+   |       --- required by a bound in this\n+...\n+LL |         [<u8 as Baz>::Quaks; 2]: Bar,\n+   |                                  --- required by this bound in `Foo`\n+...\n+LL | impl Foo for FooImpl {}\n+   |      ^^^ the trait `Bar` is not implemented for `[[u16; 3]; 2]`\n+   |\n+   = help: the following implementations were found:\n+             <[[u16; 3]; 3] as Bar>\n+             <[u16; 4] as Bar>\n+\n+error[E0277]: the trait bound `[[u16; 3]; 2]: Bar` is not satisfied\n+  --> $DIR/issue-67185-2.rs:29:14\n+   |\n+LL | trait Foo\n+   |       --- required by a bound in this\n+...\n+LL |         [<u8 as Baz>::Quaks; 2]: Bar,\n+   |                                  --- required by this bound in `Foo`\n+...\n+LL | fn f(_: impl Foo) {}\n+   |              ^^^ the trait `Bar` is not implemented for `[[u16; 3]; 2]`\n+   |\n+   = help: the following implementations were found:\n+             <[[u16; 3]; 3] as Bar>\n+             <[u16; 4] as Bar>\n+\n+error[E0277]: the trait bound `[u16; 3]: Bar` is not satisfied\n+  --> $DIR/issue-67185-2.rs:29:14\n+   |\n+LL | trait Foo\n+   |       --- required by a bound in this\n+...\n+LL |         <u8 as Baz>::Quaks: Bar,\n+   |                             --- required by this bound in `Foo`\n+...\n+LL | fn f(_: impl Foo) {}\n+   |              ^^^ the trait `Bar` is not implemented for `[u16; 3]`\n+   |\n+   = help: the following implementations were found:\n+             <[[u16; 3]; 3] as Bar>\n+             <[u16; 4] as Bar>\n+\n+error: aborting due to 6 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2befbe56d85c7c5d42a6ba2249e3211b7598a575", "filename": "src/test/ui/const-generics/issues/issue-69654.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8878868c8d7ef3779e7243953fc050cbb0e0565/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8878868c8d7ef3779e7243953fc050cbb0e0565/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.rs?ref=d8878868c8d7ef3779e7243953fc050cbb0e0565", "patch": "@@ -1,18 +0,0 @@\n-#![feature(const_generics)]\n-#![allow(incomplete_features)]\n-\n-trait Bar<O> {}\n-impl<O> Bar<O> for [u8; O] {}\n-//~^ ERROR expected value, found type parameter `O`\n-\n-struct Foo<const O: usize> {}\n-impl<const O: usize> Foo<O>\n-where\n-    [u8; O]: Bar<[(); O]>,\n-{\n-    fn foo() {}\n-}\n-\n-fn main() {\n-    Foo::foo();\n-}"}, {"sha": "9d52603f462bedaec02beed21129c40348ade380", "filename": "src/test/ui/const-generics/issues/issue-69654.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d8878868c8d7ef3779e7243953fc050cbb0e0565/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8878868c8d7ef3779e7243953fc050cbb0e0565/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.stderr?ref=d8878868c8d7ef3779e7243953fc050cbb0e0565", "patch": "@@ -1,14 +0,0 @@\n-error[E0423]: expected value, found type parameter `O`\n-  --> $DIR/issue-69654.rs:5:25\n-   |\n-LL | impl<O> Bar<O> for [u8; O] {}\n-   |                         ^ help: a tuple variant with a similar name exists: `Ok`\n-   | \n-  ::: $SRC_DIR/libcore/result.rs:LL:COL\n-   |\n-LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     --------------------------------------------------- similarly named tuple variant `Ok` defined here\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0423`."}, {"sha": "36513f94a9e97562431adca9dc10b06c0fa67139", "filename": "src/test/ui/const-generics/lazy-normalization/issue-71922.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+trait Foo {}\n+\n+impl<const N: usize> Foo for [(); N] where Self: FooImpl<{ N == 0 }> {}\n+\n+trait FooImpl<const IS_ZERO: bool> {}\n+\n+impl FooImpl<{ 0u8 == 0u8 }> for [(); 0] {}\n+\n+impl<const N: usize> FooImpl<{ 0u8 != 0u8 }> for [(); N] {}\n+\n+fn foo<T: Foo>(_: T) {}\n+\n+fn main() {\n+    foo([]);\n+    foo([()]);\n+}"}, {"sha": "048ed18c927bfa25e9a03b76cef939ac5c80f99d", "filename": "src/test/ui/const-generics/lazy-normalization/issue-71986.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71986.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -0,0 +1,8 @@\n+// check-pass\n+#![allow(incomplete_features)]\n+#![feature(const_generics)]\n+\n+pub trait Foo<const B: bool> {}\n+pub fn bar<T: Foo<{ true }>>() {}\n+\n+fn main() {}"}, {"sha": "7a665397c1207fd90c753fc5a21581f9f074f3ca", "filename": "src/test/ui/const-generics/raw-ptr-const-param.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -11,12 +11,10 @@ error[E0308]: mismatched types\n   --> $DIR/raw-ptr-const-param.rs:7:40\n    |\n LL |     let _: Const<{ 15 as *const _ }> = Const::<{ 10 as *const _ }>;\n-   |            -------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{0xf as *const u32}`, found `{0xa as *const u32}`\n-   |            |\n-   |            expected due to this\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{0xf as *const u32}`, found `{0xa as *const u32}`\n    |\n-   = note: expected struct `Const<{0xf as *const u32}>`\n-              found struct `Const<{0xa as *const u32}>`\n+   = note: expected type `{0xf as *const u32}`\n+              found type `{0xa as *const u32}`\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "53328c2e89bf4ea2c58e6ca737e2fd4bc36ab2c1", "filename": "src/test/ui/const-generics/types-mismatch-const-args.stderr", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -11,12 +11,10 @@ error[E0308]: mismatched types\n   --> $DIR/types-mismatch-const-args.rs:13:41\n    |\n LL |     let _: A<'a, u32, {2u32}, {3u32}> = A::<'a, u32, {4u32}, {3u32}> { data: PhantomData };\n-   |            --------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `2u32`, found `4u32`\n-   |            |\n-   |            expected due to this\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `2u32`, found `4u32`\n    |\n-   = note: expected struct `A<'_, _, 2u32, _>`\n-              found struct `A<'_, _, 4u32, _>`\n+   = note: expected type `2u32`\n+              found type `4u32`\n \n error[E0308]: mismatched types\n   --> $DIR/types-mismatch-const-args.rs:15:41\n@@ -26,8 +24,8 @@ LL |     let _: A<'a, u16, {2u32}, {3u32}> = A::<'b, u32, {2u32}, {3u32}> { data\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `A<'a, u16, _, _>`\n-              found struct `A<'b, u32, _, _>`\n+   = note: expected struct `A<'a, u16, {2u32}, {3u32}>`\n+              found struct `A<'b, u32, {2u32}, {3u32}>`\n \n error: aborting due to 2 previous errors; 1 warning emitted\n "}, {"sha": "7df036c8e3a45ddbcb8b3cc1aefc57dca24d81ea", "filename": "src/test/ui/issues/issue-24036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fissues%2Fissue-24036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fissues%2Fissue-24036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24036.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -10,7 +10,7 @@ fn closure_from_match() {\n         2 => |c| c - 1,\n         _ => |c| c - 1\n     };\n-    //~^^^ ERROR `match` arms have incompatible types\n+    //~^^^^ ERROR type annotations needed\n }\n \n fn main() { }"}, {"sha": "e6b8367f74fb56830708e4251c91ed79e4161d6a", "filename": "src/test/ui/issues/issue-24036.stderr", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -11,24 +11,13 @@ LL |     x = |c| c + 1;\n    = note: no two closures, even if identical, have the same type\n    = help: consider boxing your closure and/or using it as a trait object\n \n-error[E0308]: `match` arms have incompatible types\n-  --> $DIR/issue-24036.rs:10:14\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-24036.rs:9:15\n    |\n-LL |       let x = match 1usize {\n-   |  _____________-\n-LL | |         1 => |c| c + 1,\n-   | |              --------- this is found to be of type `[closure@$DIR/issue-24036.rs:9:14: 9:23]`\n-LL | |         2 => |c| c - 1,\n-   | |              ^^^^^^^^^ expected closure, found a different closure\n-LL | |         _ => |c| c - 1\n-LL | |     };\n-   | |_____- `match` arms have incompatible types\n-   |\n-   = note: expected type `[closure@$DIR/issue-24036.rs:9:14: 9:23]`\n-           found closure `[closure@$DIR/issue-24036.rs:10:14: 10:23]`\n-   = note: no two closures, even if identical, have the same type\n-   = help: consider boxing your closure and/or using it as a trait object\n+LL |         1 => |c| c + 1,\n+   |               ^ consider giving this closure parameter a type\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0282, E0308.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "88f8dbe1a7d72cbbdd7827bb71d128c576d5c581", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -25,7 +25,7 @@ error: non-defining opaque type use in defining scope\n LL | fn concrete_const() -> OneConst<{123}> {\n    |                        ^^^^^^^^^^^^^^^\n    |\n-note: used non-generic constant `123usize` for generic parameter\n+note: used non-generic constant `{123}` for generic parameter\n   --> $DIR/generic_nondefining_use.rs:10:21\n    |\n LL | type OneConst<const X: usize> = impl Debug;"}, {"sha": "3379d82eda829d4e4f188814d8a4dab6a4ed126a", "filename": "src/tools/remote-test-client/src/main.rs", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89988fe727a5f055da78a4278448cfbca0c49e19/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs?ref=89988fe727a5f055da78a4278448cfbca0c49e19", "patch": "@@ -18,6 +18,7 @@ use std::thread;\n use std::time::Duration;\n \n const REMOTE_ADDR_ENV: &str = \"TEST_DEVICE_ADDR\";\n+const DEFAULT_ADDR: &str = \"127.0.0.1:12345\";\n \n macro_rules! t {\n     ($e:expr) => {\n@@ -30,8 +31,12 @@ macro_rules! t {\n \n fn main() {\n     let mut args = env::args().skip(1);\n+    let next = args.next();\n+    if next.is_none() {\n+        return help();\n+    }\n \n-    match &args.next().unwrap()[..] {\n+    match &next.unwrap()[..] {\n         \"spawn-emulator\" => spawn_emulator(\n             &args.next().unwrap(),\n             Path::new(&args.next().unwrap()),\n@@ -40,12 +45,16 @@ fn main() {\n         ),\n         \"push\" => push(Path::new(&args.next().unwrap())),\n         \"run\" => run(args.next().unwrap(), args.collect()),\n-        cmd => panic!(\"unknown command: {}\", cmd),\n+        \"help\" | \"-h\" | \"--help\" => help(),\n+        cmd => {\n+            println!(\"unknown command: {}\", cmd);\n+            help();\n+        }\n     }\n }\n \n fn spawn_emulator(target: &str, server: &Path, tmpdir: &Path, rootfs: Option<PathBuf>) {\n-    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(\"127.0.0.1:12345\".to_string());\n+    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(DEFAULT_ADDR.to_string());\n \n     if env::var(REMOTE_ADDR_ENV).is_ok() {\n         println!(\"Connecting to remote device {} ...\", device_address);\n@@ -172,7 +181,7 @@ fn start_qemu_emulator(target: &str, rootfs: &Path, server: &Path, tmpdir: &Path\n }\n \n fn push(path: &Path) {\n-    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(\"127.0.0.1:12345\".to_string());\n+    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(DEFAULT_ADDR.to_string());\n     let client = t!(TcpStream::connect(device_address));\n     let mut client = BufWriter::new(client);\n     t!(client.write_all(b\"push\"));\n@@ -189,7 +198,7 @@ fn push(path: &Path) {\n }\n \n fn run(files: String, args: Vec<String>) {\n-    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(\"127.0.0.1:12345\".to_string());\n+    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(DEFAULT_ADDR.to_string());\n     let client = t!(TcpStream::connect(device_address));\n     let mut client = BufWriter::new(client);\n     t!(client.write_all(b\"run \"));\n@@ -284,3 +293,40 @@ fn send(path: &Path, dst: &mut dyn Write) {\n     t!(dst.write_all(&[(amt >> 24) as u8, (amt >> 16) as u8, (amt >> 8) as u8, (amt >> 0) as u8,]));\n     t!(io::copy(&mut file, dst));\n }\n+\n+fn help() {\n+    println!(\n+        \"\n+Usage: {0} <command> [<args>]\n+\n+Sub-commands:\n+    spawn-emulator <target> <server> <tmpdir> [rootfs]   See below\n+    push <path>                                          Copy <path> to emulator\n+    run <files> [args...]                                Run program on emulator\n+    help                                                 Display help message\n+\n+Spawning an emulator:\n+\n+For Android <target>s, adb will push the <server>, set up TCP forwarding and run\n+the <server>. Otherwise qemu emulates the target using a rootfs image created in\n+<tmpdir> and generated from <rootfs> plus the <server> executable.\n+If {1} is set in the environment, this step is skipped.\n+\n+Pushing a path to a running emulator:\n+\n+A running emulator or adb device is connected to at the IP address and port in\n+the {1} environment variable or {2} if this isn't\n+specified. The file at <path> is sent to this target.\n+\n+Executing commands on a running emulator:\n+\n+First the target emulator/adb session is connected to as for pushing files. Next\n+the colon separated list of <files> is pushed to the target. Finally, the first\n+file in <files> is executed in the emulator, preserving the current environment.\n+That command's status code is returned.\n+\",\n+        env::args().next().unwrap(),\n+        REMOTE_ADDR_ENV,\n+        DEFAULT_ADDR\n+    );\n+}"}]}