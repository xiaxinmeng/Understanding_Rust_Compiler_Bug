{"sha": "2eb07a05a3fa1e604f4243ddd5659f294d6b69b9", "node_id": "C_kwDOAAsO6NoAKDJlYjA3YTA1YTNmYTFlNjA0ZjQyNDNkZGQ1NjU5ZjI5NGQ2YjY5Yjk", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-10-31T02:14:45Z"}, "committer": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-11-05T21:47:51Z"}, "message": "fix shared behavior and add tests", "tree": {"sha": "a8f8cc08547483b595424edb5c3088af2d62f27d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8f8cc08547483b595424edb5c3088af2d62f27d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9", "html_url": "https://github.com/rust-lang/rust/commit/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2f7e8497e12e6d79d7963729ef6746b912a32eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2f7e8497e12e6d79d7963729ef6746b912a32eb", "html_url": "https://github.com/rust-lang/rust/commit/a2f7e8497e12e6d79d7963729ef6746b912a32eb"}], "stats": {"total": 293, "additions": 290, "deletions": 3}, "files": [{"sha": "8f414d98dba5f70a979aa132a0caac8bbdd979c5", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=2eb07a05a3fa1e604f4243ddd5659f294d6b69b9", "patch": "@@ -12,7 +12,7 @@ const INIT_ONCE_ID_OFFSET: u64 = 0;\n const CONDVAR_ID_OFFSET: u64 = 0;\n \n impl<'mir, 'tcx> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n-pub trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Try to reacquire the lock associated with the condition variable after we\n     /// were signaled.\n     fn reacquire_cond_lock(\n@@ -26,13 +26,13 @@ pub trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tc\n \n         match mode {\n             RwLockMode::Read =>\n-                if this.rwlock_is_locked(lock) {\n+                if this.rwlock_is_write_locked(lock) {\n                     this.rwlock_enqueue_and_block_reader(lock, thread);\n                 } else {\n                     this.rwlock_reader_lock(lock, thread);\n                 },\n             RwLockMode::Write =>\n-                if this.rwlock_is_write_locked(lock) {\n+                if this.rwlock_is_locked(lock) {\n                     this.rwlock_enqueue_and_block_writer(lock, thread);\n                 } else {\n                     this.rwlock_writer_lock(lock, thread);"}, {"sha": "d89320bfe59718988be92feab3da341baadea0ca", "filename": "src/tools/miri/tests/pass/concurrency/windows_condvar_shared.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs?ref=2eb07a05a3fa1e604f4243ddd5659f294d6b69b9", "patch": "@@ -0,0 +1,227 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+use std::ffi::c_void;\n+use std::ptr::null_mut;\n+use std::thread;\n+\n+#[derive(Copy, Clone)]\n+struct SendPtr<T>(*mut T);\n+\n+unsafe impl<T> Send for SendPtr<T> {}\n+\n+extern \"system\" {\n+    fn SleepConditionVariableSRW(\n+        condvar: *mut *mut c_void,\n+        lock: *mut *mut c_void,\n+        timeout: u32,\n+        flags: u32,\n+    ) -> i32;\n+    fn WakeAllConditionVariable(condvar: *mut *mut c_void);\n+\n+    fn AcquireSRWLockExclusive(lock: *mut *mut c_void);\n+    fn AcquireSRWLockShared(lock: *mut *mut c_void);\n+    fn ReleaseSRWLockExclusive(lock: *mut *mut c_void);\n+    fn ReleaseSRWLockShared(lock: *mut *mut c_void);\n+}\n+\n+const CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1;\n+const INFINITE: u32 = u32::MAX;\n+\n+/// threads should be able to reacquire the lock while it is locked by multiple other threads in shared mode\n+fn all_shared() {\n+    println!(\"all_shared\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut handles = Vec::with_capacity(10);\n+\n+    // waiters\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"exclusive waiter {i} locked\");\n+\n+            let r = unsafe {\n+                SleepConditionVariableSRW(\n+                    condvar_ptr.0,\n+                    lock_ptr.0,\n+                    INFINITE,\n+                    CONDITION_VARIABLE_LOCKMODE_SHARED,\n+                )\n+            };\n+            assert_ne!(r, 0);\n+\n+            println!(\"exclusive waiter {i} reacquired lock\");\n+\n+            // unlocking is unnecessary because the lock is never used again\n+        }));\n+    }\n+\n+    // ensures each waiter is waiting by this point\n+    thread::yield_now();\n+\n+    // readers\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} locked\");\n+\n+            // switch to next reader or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} unlocked\");\n+        }));\n+    }\n+\n+    // ensures each reader has acquired the lock\n+    thread::yield_now();\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    for handle in handles {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+// reacquiring a lock should wait until the lock is not exclusively locked\n+fn shared_sleep_and_exclusive_lock() {\n+    println!(\"shared_sleep_and_exclusive_lock\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut waiters = Vec::with_capacity(5);\n+    for i in 0..5 {\n+        waiters.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"shared waiter {i} locked\");\n+\n+            let r = unsafe {\n+                SleepConditionVariableSRW(\n+                    condvar_ptr.0,\n+                    lock_ptr.0,\n+                    INFINITE,\n+                    CONDITION_VARIABLE_LOCKMODE_SHARED,\n+                )\n+            };\n+            assert_ne!(r, 0);\n+\n+            println!(\"shared waiter {i} reacquired lock\");\n+\n+            // unlocking is unnecessary because the lock is never used again\n+        }));\n+    }\n+\n+    // ensures each waiter is waiting by this point\n+    thread::yield_now();\n+\n+    unsafe {\n+        AcquireSRWLockExclusive(lock_ptr.0);\n+    }\n+    println!(\"main locked\");\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    // waiters are now waiting for the lock to be unlocked\n+    thread::yield_now();\n+\n+    unsafe {\n+        ReleaseSRWLockExclusive(lock_ptr.0);\n+    }\n+    println!(\"main unlocked\");\n+\n+    for handle in waiters {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+// threads reacquiring locks should wait for all locks to be released first\n+fn exclusive_sleep_and_shared_lock() {\n+    println!(\"exclusive_sleep_and_shared_lock\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut handles = Vec::with_capacity(10);\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockExclusive(lock_ptr.0);\n+            }\n+\n+            println!(\"exclusive waiter {i} locked\");\n+\n+            let r = unsafe { SleepConditionVariableSRW(condvar_ptr.0, lock_ptr.0, INFINITE, 0) };\n+            assert_ne!(r, 0);\n+\n+            println!(\"exclusive waiter {i} reacquired lock\");\n+\n+            // switch to next waiter or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockExclusive(lock_ptr.0);\n+            }\n+            println!(\"exclusive waiter {i} unlocked\");\n+        }));\n+    }\n+\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} locked\");\n+\n+            // switch to next reader or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} unlocked\");\n+        }));\n+    }\n+\n+    // ensures each reader has acquired the lock\n+    thread::yield_now();\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    for handle in handles {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+fn main() {\n+    all_shared();\n+    shared_sleep_and_exclusive_lock();\n+    exclusive_sleep_and_shared_lock();\n+}"}, {"sha": "918b54668f201cfafb6aab0df18cdb9041b8bf9f", "filename": "src/tools/miri/tests/pass/concurrency/windows_condvar_shared.stdout", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout?ref=2eb07a05a3fa1e604f4243ddd5659f294d6b69b9", "patch": "@@ -0,0 +1,60 @@\n+all_shared\n+exclusive waiter 0 locked\n+exclusive waiter 1 locked\n+exclusive waiter 2 locked\n+exclusive waiter 3 locked\n+exclusive waiter 4 locked\n+reader 0 locked\n+reader 1 locked\n+reader 2 locked\n+reader 3 locked\n+reader 4 locked\n+exclusive waiter 0 reacquired lock\n+exclusive waiter 1 reacquired lock\n+exclusive waiter 2 reacquired lock\n+exclusive waiter 3 reacquired lock\n+exclusive waiter 4 reacquired lock\n+reader 0 unlocked\n+reader 1 unlocked\n+reader 2 unlocked\n+reader 3 unlocked\n+reader 4 unlocked\n+shared_sleep_and_exclusive_lock\n+shared waiter 0 locked\n+shared waiter 1 locked\n+shared waiter 2 locked\n+shared waiter 3 locked\n+shared waiter 4 locked\n+main locked\n+main unlocked\n+shared waiter 0 reacquired lock\n+shared waiter 1 reacquired lock\n+shared waiter 2 reacquired lock\n+shared waiter 3 reacquired lock\n+shared waiter 4 reacquired lock\n+exclusive_sleep_and_shared_lock\n+exclusive waiter 0 locked\n+exclusive waiter 1 locked\n+exclusive waiter 2 locked\n+exclusive waiter 3 locked\n+exclusive waiter 4 locked\n+reader 0 locked\n+reader 1 locked\n+reader 2 locked\n+reader 3 locked\n+reader 4 locked\n+reader 0 unlocked\n+reader 1 unlocked\n+reader 2 unlocked\n+reader 3 unlocked\n+reader 4 unlocked\n+exclusive waiter 0 reacquired lock\n+exclusive waiter 0 unlocked\n+exclusive waiter 1 reacquired lock\n+exclusive waiter 1 unlocked\n+exclusive waiter 2 reacquired lock\n+exclusive waiter 2 unlocked\n+exclusive waiter 3 reacquired lock\n+exclusive waiter 3 unlocked\n+exclusive waiter 4 reacquired lock\n+exclusive waiter 4 unlocked"}]}