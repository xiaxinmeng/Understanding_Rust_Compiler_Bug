{"sha": "c8553d8162709879bd215e8444335f0a58f8b085", "node_id": "C_kwDOAAsO6NoAKGM4NTUzZDgxNjI3MDk4NzliZDIxNWU4NDQ0MzM1ZjBhNThmOGIwODU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-07T19:03:57Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-08T13:57:25Z"}, "message": "fix Windows stdout/stderr", "tree": {"sha": "f623ee37ac9ea33ccac09a7187bda07fc7476daf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f623ee37ac9ea33ccac09a7187bda07fc7476daf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8553d8162709879bd215e8444335f0a58f8b085", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8553d8162709879bd215e8444335f0a58f8b085", "html_url": "https://github.com/rust-lang/rust/commit/c8553d8162709879bd215e8444335f0a58f8b085", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8553d8162709879bd215e8444335f0a58f8b085/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1556c857692b9595357a35bcd567f6761c2abc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1556c857692b9595357a35bcd567f6761c2abc4", "html_url": "https://github.com/rust-lang/rust/commit/e1556c857692b9595357a35bcd567f6761c2abc4"}], "stats": {"total": 144, "additions": 96, "deletions": 48}, "files": [{"sha": "ac9e085b5d7c927b9ff34f6ab028054faa86f840", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 78, "deletions": 4, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c8553d8162709879bd215e8444335f0a58f8b085/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8553d8162709879bd215e8444335f0a58f8b085/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=c8553d8162709879bd215e8444335f0a58f8b085", "patch": "@@ -1,17 +1,24 @@\n use rustc_middle::mir;\n+use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n+use log::trace;\n+\n+use crate::helpers::check_arg_count;\n use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n-pub enum Dlsym {}\n+pub enum Dlsym {\n+    NtWriteFile,\n+}\n \n impl Dlsym {\n     // Returns an error for unsupported symbols, and None if this symbol\n     // should become a NULL pointer (pretend it does not exist).\n     pub fn from_str(name: &str) -> InterpResult<'static, Option<Dlsym>> {\n         Ok(match name {\n             \"GetSystemTimePreciseAsFileTime\" => None,\n+            \"NtWriteFile\" => Some(Dlsym::NtWriteFile),\n             _ => throw_unsup_format!(\"unsupported Windows dlsym: {}\", name),\n         })\n     }\n@@ -23,15 +30,82 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         dlsym: Dlsym,\n         abi: Abi,\n-        _args: &[OpTy<'tcx, Tag>],\n+        args: &[OpTy<'tcx, Tag>],\n         ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let (_dest, _ret) = ret.expect(\"we don't support any diverging dlsym\");\n+        let (dest, ret) = ret.expect(\"we don't support any diverging dlsym\");\n         assert!(this.tcx.sess.target.os == \"windows\");\n \n         this.check_abi(abi, Abi::System { unwind: false })?;\n \n-        match dlsym {}\n+        match dlsym {\n+            Dlsym::NtWriteFile => {\n+                if !this.frame_in_std() {\n+                    throw_unsup_format!(\n+                        \"NtWriteFile support is crude and just enough for stdout to work\"\n+                    );\n+                }\n+\n+                let &[\n+                    ref handle,\n+                    ref _event,\n+                    ref _apc_routine,\n+                    ref _apc_context,\n+                    ref io_status_block,\n+                    ref buf,\n+                    ref n,\n+                    ref byte_offset,\n+                    ref _key,\n+                ] = check_arg_count(args)?;\n+                let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n+                let buf = this.read_pointer(buf)?;\n+                let n = this.read_scalar(n)?.to_u32()?;\n+                let byte_offset = this.read_scalar(byte_offset)?.to_machine_usize(this)?; // is actually a pointer\n+                let io_status_block = this.deref_operand(io_status_block)?;\n+\n+                if byte_offset != 0 {\n+                    throw_unsup_format!(\n+                        \"NtWriteFile ByteOffset paremeter is non-null, which is unsupported\"\n+                    );\n+                }\n+\n+                let written = if handle == -11 || handle == -12 {\n+                    // stdout/stderr\n+                    use std::io::{self, Write};\n+\n+                    let buf_cont = this.read_bytes_ptr(buf, Size::from_bytes(u64::from(n)))?;\n+                    let res = if handle == -11 {\n+                        io::stdout().write(buf_cont)\n+                    } else {\n+                        io::stderr().write(buf_cont)\n+                    };\n+                    res.ok().map(|n| n as u32)\n+                } else {\n+                    throw_unsup_format!(\n+                        \"on Windows, writing to anything except stdout/stderr is not supported\"\n+                    )\n+                };\n+                // We have to put the result into io_status_block.\n+                if let Some(n) = written {\n+                    let io_status_information =\n+                        this.mplace_field_named(&io_status_block, \"Information\")?;\n+                    this.write_scalar(\n+                        Scalar::from_machine_usize(n.into(), this),\n+                        &io_status_information.into(),\n+                    )?;\n+                }\n+                // Return whether this was a success. >= 0 is success.\n+                // For the error code we arbitrarily pick 0xC0000185, STATUS_IO_DEVICE_ERROR.\n+                this.write_scalar(\n+                    Scalar::from_i32(if written.is_some() { 0 } else { 0xC0000185u32 as i32 }),\n+                    dest,\n+                )?;\n+            }\n+        }\n+\n+        trace!(\"{:?}\", this.dump_place(**dest));\n+        this.go_to_block(ret);\n+        Ok(())\n     }\n }"}, {"sha": "d72302794318e08e66100c9e0d7a11478be0ce4e", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 17, "deletions": 43, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c8553d8162709879bd215e8444335f0a58f8b085/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8553d8162709879bd215e8444335f0a58f8b085/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=c8553d8162709879bd215e8444335f0a58f8b085", "patch": "@@ -23,6 +23,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Windows API stubs.\n         // HANDLE = isize\n+        // NTSTATUS = LONH = i32\n         // DWORD = ULONG = u32\n         // BOOL = i32\n         // BOOLEAN = u8\n@@ -64,49 +65,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n-            // File related shims\n-            \"GetStdHandle\" => {\n-                let &[ref which] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                let which = this.read_scalar(which)?.to_i32()?;\n-                // We just make this the identity function, so we know later in `WriteFile`\n-                // which one it is.\n-                this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n-            }\n-            \"WriteFile\" => {\n-                let &[ref handle, ref buf, ref n, ref written_ptr, ref overlapped] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_scalar(overlapped)?.to_machine_usize(this)?; // this is a poiner, that we ignore\n-                let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n-                let buf = this.read_pointer(buf)?;\n-                let n = this.read_scalar(n)?.to_u32()?;\n-                let written_place = this.deref_operand(written_ptr)?;\n-                // Spec says to always write `0` first.\n-                this.write_null(&written_place.into())?;\n-                let written = if handle == -11 || handle == -12 {\n-                    // stdout/stderr\n-                    use std::io::{self, Write};\n-\n-                    let buf_cont = this.read_bytes_ptr(buf, Size::from_bytes(u64::from(n)))?;\n-                    let res = if handle == -11 {\n-                        io::stdout().write(buf_cont)\n-                    } else {\n-                        io::stderr().write(buf_cont)\n-                    };\n-                    res.ok().map(|n| n as u32)\n-                } else {\n-                    throw_unsup_format!(\n-                        \"on Windows, writing to anything except stdout/stderr is not supported\"\n-                    )\n-                };\n-                // If there was no error, write back how much was written.\n-                if let Some(n) = written {\n-                    this.write_scalar(Scalar::from_u32(n), &written_place.into())?;\n-                }\n-                // Return whether this was a success.\n-                this.write_scalar(Scalar::from_i32(if written.is_some() { 1 } else { 0 }), dest)?;\n-            }\n-\n             // Allocation\n             \"HeapAlloc\" => {\n                 let &[ref handle, ref flags, ref size] =\n@@ -333,6 +291,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // value if this call does result in switching to another thread.\n                 this.write_null(dest)?;\n             }\n+            \"GetStdHandle\" => {\n+                let &[ref which] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let which = this.read_scalar(which)?.to_i32()?;\n+                // We just make this the identity function, so we know later in `NtWriteFile` which\n+                // one it is. This is very fake, but libtest needs it so we cannot make it a\n+                // std-only shim.\n+                this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n+            }\n \n             // Better error for attempts to create a thread\n             \"CreateThread\" => {\n@@ -350,6 +317,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Just fake a HANDLE\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n+            \"GetModuleHandleA\" if this.frame_in_std() => {\n+                #[allow(non_snake_case)]\n+                let &[_lpModuleName] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                // We need to return something non-null here to make `compat_fn!` work.\n+                this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n+            }\n             \"SetConsoleTextAttribute\" if this.frame_in_std() => {\n                 #[allow(non_snake_case)]\n                 let &[ref _hConsoleOutput, ref _wAttribute] ="}, {"sha": "fa6707632dc766b5fb363b2296a3e18f82047abf", "filename": "tests/run-pass/vecdeque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8553d8162709879bd215e8444335f0a58f8b085/tests%2Frun-pass%2Fvecdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8553d8162709879bd215e8444335f0a58f8b085/tests%2Frun-pass%2Fvecdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvecdeque.rs?ref=c8553d8162709879bd215e8444335f0a58f8b085", "patch": "@@ -26,7 +26,7 @@ fn main() {\n       assert_eq!(**a, 2);\n     }\n \n-    // Regression test for Debug and Diaplay impl's\n+    // Regression test for Debug impl's\n     println!(\"{:?} {:?}\", dst, dst.iter());\n     println!(\"{:?}\", VecDeque::<u32>::new().iter());\n "}]}