{"sha": "8d50216e9dfb055d28abf9da35f91542c2e9fe90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNTAyMTZlOWRmYjA1NWQyOGFiZjlkYTM1ZjkxNTQyYzJlOWZlOTA=", "commit": {"author": {"name": "Geoffrey Thomas", "email": "geofft@ldpreload.com", "date": "2015-05-12T19:34:52Z"}, "committer": {"name": "Geoffrey Thomas", "email": "geofft@ldpreload.com", "date": "2015-05-13T00:21:21Z"}, "message": "trpl/enums: Rewrite", "tree": {"sha": "300579ec6d39a6fa5a07f38423a8592f9870d955", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/300579ec6d39a6fa5a07f38423a8592f9870d955"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d50216e9dfb055d28abf9da35f91542c2e9fe90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d50216e9dfb055d28abf9da35f91542c2e9fe90", "html_url": "https://github.com/rust-lang/rust/commit/8d50216e9dfb055d28abf9da35f91542c2e9fe90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d50216e9dfb055d28abf9da35f91542c2e9fe90/comments", "author": {"login": "geofft", "id": 74644, "node_id": "MDQ6VXNlcjc0NjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/74644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geofft", "html_url": "https://github.com/geofft", "followers_url": "https://api.github.com/users/geofft/followers", "following_url": "https://api.github.com/users/geofft/following{/other_user}", "gists_url": "https://api.github.com/users/geofft/gists{/gist_id}", "starred_url": "https://api.github.com/users/geofft/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geofft/subscriptions", "organizations_url": "https://api.github.com/users/geofft/orgs", "repos_url": "https://api.github.com/users/geofft/repos", "events_url": "https://api.github.com/users/geofft/events{/privacy}", "received_events_url": "https://api.github.com/users/geofft/received_events", "type": "User", "site_admin": false}, "committer": {"login": "geofft", "id": 74644, "node_id": "MDQ6VXNlcjc0NjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/74644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geofft", "html_url": "https://github.com/geofft", "followers_url": "https://api.github.com/users/geofft/followers", "following_url": "https://api.github.com/users/geofft/following{/other_user}", "gists_url": "https://api.github.com/users/geofft/gists{/gist_id}", "starred_url": "https://api.github.com/users/geofft/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geofft/subscriptions", "organizations_url": "https://api.github.com/users/geofft/orgs", "repos_url": "https://api.github.com/users/geofft/repos", "events_url": "https://api.github.com/users/geofft/events{/privacy}", "received_events_url": "https://api.github.com/users/geofft/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "797d8e28695a9f349a3155958e06c527250bdac9", "url": "https://api.github.com/repos/rust-lang/rust/commits/797d8e28695a9f349a3155958e06c527250bdac9", "html_url": "https://github.com/rust-lang/rust/commit/797d8e28695a9f349a3155958e06c527250bdac9"}], "stats": {"total": 97, "additions": 46, "deletions": 51}, "files": [{"sha": "b8b249fafe1c94fd4e40a92737c97c6cd33a98e2", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d50216e9dfb055d28abf9da35f91542c2e9fe90/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d50216e9dfb055d28abf9da35f91542c2e9fe90/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=8d50216e9dfb055d28abf9da35f91542c2e9fe90", "patch": "@@ -27,9 +27,9 @@\n     * [References and Borrowing](references-and-borrowing.md)\n     * [Lifetimes](lifetimes.md)\n     * [Mutability](mutability.md)\n+    * [Structs](structs.md)\n     * [Enums](enums.md)\n     * [Match](match.md)\n-    * [Structs](structs.md)\n     * [Patterns](patterns.md)\n     * [Method Syntax](method-syntax.md)\n     * [Vectors](vectors.md)"}, {"sha": "443f569a3e5abbac21baa3a07c7c106d9f184fc8", "filename": "src/doc/trpl/enums.md", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8d50216e9dfb055d28abf9da35f91542c2e9fe90/src%2Fdoc%2Ftrpl%2Fenums.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d50216e9dfb055d28abf9da35f91542c2e9fe90/src%2Fdoc%2Ftrpl%2Fenums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fenums.md?ref=8d50216e9dfb055d28abf9da35f91542c2e9fe90", "patch": "@@ -1,68 +1,63 @@\n % Enums\n \n-Rust has a \u2018sum type\u2019, an `enum`. Enums are an incredibly useful feature of\n-Rust, and are used throughout the standard library. An `enum` is a type which\n-relates a set of alternates to a specific name. For example, below we define\n-`Character` to be either a `Digit` or something else.\n+An `enum` in Rust is a type that represents data that could be one of\n+several possible variants:\n \n ```rust\n-enum Character {\n-    Digit(i32),\n-    Other,\n+enum Message {\n+    Quit,\n+    ChangeColor(i32, i32, i32),\n+    Move { x: i32, y: i32 },\n+    Write(String),\n }\n ```\n \n-Most types are allowed as the variant components of an `enum`. Here are some\n-examples:\n+Each variant can optionally have data associated with it. The syntax for\n+defining variants resembles the syntaxes used to define structs: you can\n+have variants with no data (like unit-like structs), variants with named\n+data, and variants with unnamed data (like tuple structs). Unlike\n+separate struct definitions, however, an `enum` is a single type. A\n+value of the enum can match any of the variants. For this reason, an\n+enum is sometimes called a \u2018sum type\u2019: the set of possible values of the\n+enum is the sum of the sets of possible values for each variant.\n \n-```rust\n-struct Empty;\n-struct Color(i32, i32, i32);\n-struct Length(i32);\n-struct Stats { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n-struct HeightDatabase(Vec<i32>);\n-```\n-\n-You see that, depending on its type, an `enum` variant may or may not hold data.\n-In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n-value, where `Other` is only a name. However, the fact that they represent\n-distinct categories of `Character` is a very useful property.\n-\n-The variants of an `enum` by default are not comparable with equality operators\n-(`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not support other\n-binary operations such as `*` and `+`. As such, the following code is invalid\n-for the example `Character` type:\n-\n-```rust,ignore\n-// These assignments both succeed\n-let ten  = Character::Digit(10);\n-let four = Character::Digit(4);\n-\n-// Error: `*` is not implemented for type `Character`\n-let forty = ten * four;\n+We use the `::` syntax to use the name of each variant: they\u2019re scoped by the name\n+of the `enum` itself. This allows both of these to work:\n \n-// Error: `<=` is not implemented for type `Character`\n-let four_is_smaller = four <= ten;\n+```rust\n+# enum Message {\n+#     Move { x: i32, y: i32 },\n+# }\n+let x: Message = Message::Move { x: 3, y: 4 };\n+\n+enum BoardGameTurn {\n+    Move { squares: i32 },\n+    Pass,\n+}\n \n-// Error: `==` is not implemented for type `Character`\n-let four_equals_ten = four == ten;\n+let y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };\n ```\n \n-We use the `::` syntax to use the name of each variant: They\u2019re scoped by the name\n-of the `enum` itself. This allows both of these to work:\n+Both variants are named `Move`, but since they\u2019re scoped to the name of\n+the enum, they can both be used without conflict.\n+\n+A value of an enum type contains information about which variant it is,\n+in addition to any data associated with that variant. This is sometimes\n+referred to as a \u2018tagged union\u2019, since the data includes a \u2018tag\u2019\n+indicating what type it is. The compiler uses this information to\n+enforce that you\u2019re accessing the data in the enum safely. For instance,\n+you can\u2019t simply try to destructure a value as if it were one of the\n+possible variants:\n \n ```rust,ignore\n-Character::Digit(10);\n-Hand::Digit;\n+fn process_color_change(msg: Message) {\n+    let Message::ChangeColor(r, g, b) = msg; // compile-time error\n+}\n ```\n \n-Both variants are named `Digit`, but since they\u2019re scoped to the `enum` name,\n-\n-Not supporting these operations may seem rather limiting, but it\u2019s a limitation\n-which we can overcome. There are two ways: by implementing equality ourselves,\n-or by pattern matching variants with [`match`][match] expressions, which you\u2019ll\n-learn in the next section. We don\u2019t know enough about Rust to implement\n-equality yet, but we\u2019ll find out in the [`traits`][traits] section.\n+We\u2019ll see how to safely get data out of enums when we learn about the\n+[`match`][match] and [`if let`][if-let] statements in the next few\n+chapters.\n \n [match]: match.html\n-[traits]: traits.html\n+[if-let]: if-let.html"}]}