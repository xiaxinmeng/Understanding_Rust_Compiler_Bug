{"sha": "a399f0ca8429db2399f007cdb12dad687b8973d9", "node_id": "C_kwDOAAsO6NoAKGEzOTlmMGNhODQyOWRiMjM5OWYwMDdjZGIxMmRhZDY4N2I4OTczZDk", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-02-05T01:49:50Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-02-05T02:47:58Z"}, "message": "rustc_passes: remove huge error imports", "tree": {"sha": "0841edaffb2c6c98b0fc779346d6f83f36dd0391", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0841edaffb2c6c98b0fc779346d6f83f36dd0391"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a399f0ca8429db2399f007cdb12dad687b8973d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a399f0ca8429db2399f007cdb12dad687b8973d9", "html_url": "https://github.com/rust-lang/rust/commit/a399f0ca8429db2399f007cdb12dad687b8973d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a399f0ca8429db2399f007cdb12dad687b8973d9/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3478b162f35650acc009cd6ce9919a6251e81a33", "url": "https://api.github.com/repos/rust-lang/rust/commits/3478b162f35650acc009cd6ce9919a6251e81a33", "html_url": "https://github.com/rust-lang/rust/commit/3478b162f35650acc009cd6ce9919a6251e81a33"}], "stats": {"total": 113, "additions": 57, "deletions": 56}, "files": [{"sha": "238ec9ca30f704a99b0e72eb65e8d58454180062", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a399f0ca8429db2399f007cdb12dad687b8973d9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a399f0ca8429db2399f007cdb12dad687b8973d9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=a399f0ca8429db2399f007cdb12dad687b8973d9", "patch": "@@ -4,11 +4,7 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use crate::errors::{\n-    self, AttrApplication, DebugVisualizerUnreadable, InvalidAttrAtCrateLevel, ObjectLifetimeErr,\n-    OnlyHasEffectOn, ProcMacroDiffArguments, ProcMacroInvalidAbi, ProcMacroMissingArguments,\n-    ProcMacroTypeError, ProcMacroUnsafe, TransparentIncompatible, UnrecognizedReprHint,\n-};\n+use crate::errors;\n use rustc_ast::{ast, AttrStyle, Attribute, LitKind, MetaItemKind, MetaItemLit, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{fluent, Applicability, IntoDiagnosticArg, MultiSpan};\n@@ -399,7 +395,7 @@ impl CheckAttrVisitor<'_> {\n                 UNUSED_ATTRIBUTES,\n                 hir_id,\n                 attr.span,\n-                OnlyHasEffectOn {\n+                errors::OnlyHasEffectOn {\n                     attr_name: attr.name_or_empty(),\n                     target_name: allowed_target.name().replace(' ', \"_\"),\n                 },\n@@ -468,7 +464,7 @@ impl CheckAttrVisitor<'_> {\n                     ObjectLifetimeDefault::Param(def_id) => tcx.item_name(def_id).to_string(),\n                     ObjectLifetimeDefault::Ambiguous => \"Ambiguous\".to_owned(),\n                 };\n-                tcx.sess.emit_err(ObjectLifetimeErr { span: p.span, repr });\n+                tcx.sess.emit_err(errors::ObjectLifetimeErr { span: p.span, repr });\n             }\n         }\n     }\n@@ -1715,7 +1711,7 @@ impl CheckAttrVisitor<'_> {\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n                         _ => {\n-                            self.tcx.sess.emit_err(AttrApplication::StructEnumUnion {\n+                            self.tcx.sess.emit_err(errors::AttrApplication::StructEnumUnion {\n                                 hint_span: hint.span(),\n                                 span,\n                             });\n@@ -1736,16 +1732,18 @@ impl CheckAttrVisitor<'_> {\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum | Target::Fn => continue,\n                         _ => {\n-                            self.tcx.sess.emit_err(AttrApplication::StructEnumFunctionUnion {\n-                                hint_span: hint.span(),\n-                                span,\n-                            });\n+                            self.tcx.sess.emit_err(\n+                                errors::AttrApplication::StructEnumFunctionUnion {\n+                                    hint_span: hint.span(),\n+                                    span,\n+                                },\n+                            );\n                         }\n                     }\n                 }\n                 sym::packed => {\n                     if target != Target::Struct && target != Target::Union {\n-                        self.tcx.sess.emit_err(AttrApplication::StructUnion {\n+                        self.tcx.sess.emit_err(errors::AttrApplication::StructUnion {\n                             hint_span: hint.span(),\n                             span,\n                         });\n@@ -1756,9 +1754,10 @@ impl CheckAttrVisitor<'_> {\n                 sym::simd => {\n                     is_simd = true;\n                     if target != Target::Struct {\n-                        self.tcx\n-                            .sess\n-                            .emit_err(AttrApplication::Struct { hint_span: hint.span(), span });\n+                        self.tcx.sess.emit_err(errors::AttrApplication::Struct {\n+                            hint_span: hint.span(),\n+                            span,\n+                        });\n                     } else {\n                         continue;\n                     }\n@@ -1768,7 +1767,7 @@ impl CheckAttrVisitor<'_> {\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n                         _ => {\n-                            self.tcx.sess.emit_err(AttrApplication::StructEnumUnion {\n+                            self.tcx.sess.emit_err(errors::AttrApplication::StructEnumUnion {\n                                 hint_span: hint.span(),\n                                 span,\n                             });\n@@ -1789,15 +1788,16 @@ impl CheckAttrVisitor<'_> {\n                 | sym::usize => {\n                     int_reprs += 1;\n                     if target != Target::Enum {\n-                        self.tcx\n-                            .sess\n-                            .emit_err(AttrApplication::Enum { hint_span: hint.span(), span });\n+                        self.tcx.sess.emit_err(errors::AttrApplication::Enum {\n+                            hint_span: hint.span(),\n+                            span,\n+                        });\n                     } else {\n                         continue;\n                     }\n                 }\n                 _ => {\n-                    self.tcx.sess.emit_err(UnrecognizedReprHint { span: hint.span() });\n+                    self.tcx.sess.emit_err(errors::UnrecognizedReprHint { span: hint.span() });\n                     continue;\n                 }\n             };\n@@ -1810,9 +1810,10 @@ impl CheckAttrVisitor<'_> {\n         // Error on repr(transparent, <anything else>).\n         if is_transparent && hints.len() > 1 {\n             let hint_spans: Vec<_> = hint_spans.clone().collect();\n-            self.tcx\n-                .sess\n-                .emit_err(TransparentIncompatible { hint_spans, target: target.to_string() });\n+            self.tcx.sess.emit_err(errors::TransparentIncompatible {\n+                hint_spans,\n+                target: target.to_string(),\n+            });\n         }\n         // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n         if (int_reprs > 1)\n@@ -1965,7 +1966,7 @@ impl CheckAttrVisitor<'_> {\n         match std::fs::File::open(&file) {\n             Ok(_) => true,\n             Err(error) => {\n-                self.tcx.sess.emit_err(DebugVisualizerUnreadable {\n+                self.tcx.sess.emit_err(errors::DebugVisualizerUnreadable {\n                     span: meta_item.span,\n                     file: &file,\n                     error,\n@@ -2175,20 +2176,23 @@ impl CheckAttrVisitor<'_> {\n             let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n \n             if sig.abi != Abi::Rust {\n-                tcx.sess.emit_err(ProcMacroInvalidAbi { span: hir_sig.span, abi: sig.abi.name() });\n+                tcx.sess.emit_err(errors::ProcMacroInvalidAbi {\n+                    span: hir_sig.span,\n+                    abi: sig.abi.name(),\n+                });\n                 self.abort.set(true);\n             }\n \n             if sig.unsafety == Unsafety::Unsafe {\n-                tcx.sess.emit_err(ProcMacroUnsafe { span: hir_sig.span });\n+                tcx.sess.emit_err(errors::ProcMacroUnsafe { span: hir_sig.span });\n                 self.abort.set(true);\n             }\n \n             let output = sig.output();\n \n             // Typecheck the output\n             if !drcx.types_may_unify(output, tokenstream) {\n-                tcx.sess.emit_err(ProcMacroTypeError {\n+                tcx.sess.emit_err(errors::ProcMacroTypeError {\n                     span: hir_sig.decl.output.span(),\n                     found: output,\n                     kind,\n@@ -2198,7 +2202,7 @@ impl CheckAttrVisitor<'_> {\n             }\n \n             if sig.inputs().len() < expected_input_count {\n-                tcx.sess.emit_err(ProcMacroMissingArguments {\n+                tcx.sess.emit_err(errors::ProcMacroMissingArguments {\n                     expected_input_count,\n                     span: hir_sig.span,\n                     kind,\n@@ -2213,7 +2217,7 @@ impl CheckAttrVisitor<'_> {\n                     sig.inputs().iter().zip(hir_sig.decl.inputs).take(expected_input_count)\n                 {\n                     if !drcx.types_may_unify(*arg, tokenstream) {\n-                        tcx.sess.emit_err(ProcMacroTypeError {\n+                        tcx.sess.emit_err(errors::ProcMacroTypeError {\n                             span: input.span,\n                             found: *arg,\n                             kind,\n@@ -2228,7 +2232,7 @@ impl CheckAttrVisitor<'_> {\n             let body_id = tcx.hir().body_owned_by(id.def_id);\n             let excess = tcx.hir().body(body_id).params.get(expected_input_count..);\n             if let Some(excess @ [begin @ end] | excess @ [begin, .., end]) = excess {\n-                tcx.sess.emit_err(ProcMacroDiffArguments {\n+                tcx.sess.emit_err(errors::ProcMacroDiffArguments {\n                     span: begin.span.to(end.span),\n                     count: excess.len(),\n                     kind,\n@@ -2378,7 +2382,7 @@ fn check_invalid_crate_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n         if attr.style == AttrStyle::Inner {\n             for attr_to_check in ATTRS_TO_CHECK {\n                 if attr.has_name(*attr_to_check) {\n-                    tcx.sess.emit_err(InvalidAttrAtCrateLevel {\n+                    tcx.sess.emit_err(errors::InvalidAttrAtCrateLevel {\n                         span: attr.span,\n                         snippet: tcx.sess.source_map().span_to_snippet(attr.span).ok(),\n                         name: *attr_to_check,"}, {"sha": "7299fc9705cc6036046b3d3036b561042931f123", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a399f0ca8429db2399f007cdb12dad687b8973d9/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a399f0ca8429db2399f007cdb12dad687b8973d9/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=a399f0ca8429db2399f007cdb12dad687b8973d9", "patch": "@@ -1,12 +1,7 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n-use crate::errors::{\n-    self, CannotStabilizeDeprecated, DeprecatedAttribute, DuplicateFeatureErr,\n-    FeatureOnlyOnNightly, ImpliedFeatureNotExist, InvalidDeprecationVersion, InvalidStability,\n-    MissingConstErr, MissingConstStabAttr, MissingStabilityAttr, TraitImplConstStable,\n-    UnknownFeature, UselessStability,\n-};\n+use crate::errors;\n use rustc_attr::{\n     self as attr, rust_version_symbol, ConstStability, Stability, StabilityLevel, Unstable,\n     UnstableReason, VERSION_PLACEHOLDER,\n@@ -185,7 +180,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 {\n                     self.tcx\n                         .sess\n-                        .emit_err(MissingConstErr { fn_sig_span: fn_sig.span, const_span });\n+                        .emit_err(errors::MissingConstErr { fn_sig_span: fn_sig.span, const_span });\n                 }\n             }\n         }\n@@ -203,7 +198,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n \n         if let Some((rustc_attr::Deprecation { is_since_rustc_version: true, .. }, span)) = &depr {\n             if stab.is_none() {\n-                self.tcx.sess.emit_err(DeprecatedAttribute { span: *span });\n+                self.tcx.sess.emit_err(errors::DeprecatedAttribute { span: *span });\n             }\n         }\n \n@@ -219,7 +214,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             if kind == AnnotationKind::Prohibited\n                 || (kind == AnnotationKind::Container && stab.level.is_stable() && is_deprecated)\n             {\n-                self.tcx.sess.emit_err(UselessStability { span, item_sp });\n+                self.tcx.sess.emit_err(errors::UselessStability { span, item_sp });\n             }\n \n             debug!(\"annotate: found {:?}\", stab);\n@@ -235,25 +230,27 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 {\n                     match stab_v.parse::<u64>() {\n                         Err(_) => {\n-                            self.tcx.sess.emit_err(InvalidStability { span, item_sp });\n+                            self.tcx.sess.emit_err(errors::InvalidStability { span, item_sp });\n                             break;\n                         }\n                         Ok(stab_vp) => match dep_v.parse::<u64>() {\n                             Ok(dep_vp) => match dep_vp.cmp(&stab_vp) {\n                                 Ordering::Less => {\n-                                    self.tcx\n-                                        .sess\n-                                        .emit_err(CannotStabilizeDeprecated { span, item_sp });\n+                                    self.tcx.sess.emit_err(errors::CannotStabilizeDeprecated {\n+                                        span,\n+                                        item_sp,\n+                                    });\n                                     break;\n                                 }\n                                 Ordering::Equal => continue,\n                                 Ordering::Greater => break,\n                             },\n                             Err(_) => {\n                                 if dep_v != \"TBD\" {\n-                                    self.tcx\n-                                        .sess\n-                                        .emit_err(InvalidDeprecationVersion { span, item_sp });\n+                                    self.tcx.sess.emit_err(errors::InvalidDeprecationVersion {\n+                                        span,\n+                                        item_sp,\n+                                    });\n                                 }\n                                 break;\n                             }\n@@ -527,7 +524,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n             && self.effective_visibilities.is_reachable(def_id)\n         {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.emit_err(MissingStabilityAttr { span, descr });\n+            self.tcx.sess.emit_err(errors::MissingStabilityAttr { span, descr });\n         }\n     }\n \n@@ -555,7 +552,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n \n         if is_const && is_stable && missing_const_stability_attribute && is_reachable {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.emit_err(MissingConstStabAttr { span, descr });\n+            self.tcx.sess.emit_err(errors::MissingConstStabAttr { span, descr });\n         }\n     }\n }\n@@ -768,7 +765,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                         && *constness == hir::Constness::Const\n                         && const_stab.map_or(false, |(stab, _)| stab.is_const_stable())\n                     {\n-                        self.tcx.sess.emit_err(TraitImplConstStable { span: item.span });\n+                        self.tcx.sess.emit_err(errors::TraitImplConstStable { span: item.span });\n                     }\n                 }\n \n@@ -947,22 +944,22 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n         }\n         if !lang_features.insert(feature) {\n             // Warn if the user enables a lang feature multiple times.\n-            tcx.sess.emit_err(DuplicateFeatureErr { span, feature });\n+            tcx.sess.emit_err(errors::DuplicateFeatureErr { span, feature });\n         }\n     }\n \n     let declared_lib_features = &tcx.features().declared_lib_features;\n     let mut remaining_lib_features = FxIndexMap::default();\n     for (feature, span) in declared_lib_features {\n         if !tcx.sess.opts.unstable_features.is_nightly_build() {\n-            tcx.sess.emit_err(FeatureOnlyOnNightly {\n+            tcx.sess.emit_err(errors::FeatureOnlyOnNightly {\n                 span: *span,\n                 release_channel: env!(\"CFG_RELEASE_CHANNEL\"),\n             });\n         }\n         if remaining_lib_features.contains_key(&feature) {\n             // Warn if the user enables a lib feature multiple times.\n-            tcx.sess.emit_err(DuplicateFeatureErr { span: *span, feature: *feature });\n+            tcx.sess.emit_err(errors::DuplicateFeatureErr { span: *span, feature: *feature });\n         }\n         remaining_lib_features.insert(feature, *span);\n     }\n@@ -1063,7 +1060,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     }\n \n     for (feature, span) in remaining_lib_features {\n-        tcx.sess.emit_err(UnknownFeature { span, feature: *feature });\n+        tcx.sess.emit_err(errors::UnknownFeature { span, feature: *feature });\n     }\n \n     for (implied_by, feature) in remaining_implications {\n@@ -1074,7 +1071,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n             .map(|(_, span)| span)\n             .or_else(|| local_defined_features.unstable.get(&feature))\n             .expect(\"feature that implied another does not exist\");\n-        tcx.sess.emit_err(ImpliedFeatureNotExist { span, feature, implied_by });\n+        tcx.sess.emit_err(errors::ImpliedFeatureNotExist { span, feature, implied_by });\n     }\n \n     // FIXME(#44232): the `used_features` table no longer exists, so we"}]}