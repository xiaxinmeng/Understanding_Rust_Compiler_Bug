{"sha": "1ebfab5104ba354d5d3283fd16e086d0a8549623", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYmZhYjUxMDRiYTM1NGQ1ZDMyODNmZDE2ZTA4NmQwYTg1NDk2MjM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-12T15:35:30Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-12T15:39:01Z"}, "message": "trans: Collect all accesses between trans-items, not just inlining edges.", "tree": {"sha": "4b32f27dec1bce90bcb1b6110a8cf28896640ee3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b32f27dec1bce90bcb1b6110a8cf28896640ee3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ebfab5104ba354d5d3283fd16e086d0a8549623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ebfab5104ba354d5d3283fd16e086d0a8549623", "html_url": "https://github.com/rust-lang/rust/commit/1ebfab5104ba354d5d3283fd16e086d0a8549623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ebfab5104ba354d5d3283fd16e086d0a8549623/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bba5ad3098e3f20ab3c506e5a421df5da010df9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bba5ad3098e3f20ab3c506e5a421df5da010df9", "html_url": "https://github.com/rust-lang/rust/commit/8bba5ad3098e3f20ab3c506e5a421df5da010df9"}], "stats": {"total": 134, "additions": 105, "deletions": 29}, "files": [{"sha": "19d7198b49b7b1b614fac1b256c6488ebd0d10bd", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 105, "deletions": 29, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/1ebfab5104ba354d5d3283fd16e086d0a8549623/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebfab5104ba354d5d3283fd16e086d0a8549623/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=1ebfab5104ba354d5d3283fd16e086d0a8549623", "patch": "@@ -208,6 +208,8 @@ use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n use trans_item::{TransItem, DefPathBasedNames, InstantiationMode};\n \n+use rustc_data_structures::bitvec::BitVector;\n+\n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n     Eager,\n@@ -217,12 +219,16 @@ pub enum TransItemCollectionMode {\n /// Maps every translation item to all translation items it references in its\n /// body.\n pub struct InliningMap<'tcx> {\n-    // Maps a source translation item to a range of target translation items\n-    // that are potentially inlined by LLVM into the source.\n+    // Maps a source translation item to the range of translation items\n+    // accessed by it.\n     // The two numbers in the tuple are the start (inclusive) and\n     // end index (exclusive) within the `targets` vecs.\n     index: FxHashMap<TransItem<'tcx>, (usize, usize)>,\n     targets: Vec<TransItem<'tcx>>,\n+\n+    // Contains one bit per translation item in the `targets` field. That bit\n+    // is true if that translation item needs to be inlined into every CGU.\n+    inlines: BitVector,\n }\n \n impl<'tcx> InliningMap<'tcx> {\n@@ -231,33 +237,61 @@ impl<'tcx> InliningMap<'tcx> {\n         InliningMap {\n             index: FxHashMap(),\n             targets: Vec::new(),\n+            inlines: BitVector::new(1024),\n         }\n     }\n \n-    fn record_inlining_canditates<I>(&mut self,\n-                                     source: TransItem<'tcx>,\n-                                     targets: I)\n-        where I: Iterator<Item=TransItem<'tcx>>\n+    fn record_accesses<I>(&mut self,\n+                          source: TransItem<'tcx>,\n+                          targets: I)\n+        where I: Iterator<Item=(TransItem<'tcx>, bool)>\n     {\n         assert!(!self.index.contains_key(&source));\n \n         let start_index = self.targets.len();\n-        self.targets.extend(targets);\n+        let (targets_size_hint, targets_size_hint_max) = targets.size_hint();\n+        debug_assert_eq!(targets_size_hint_max, Some(targets_size_hint));\n+        let new_items_count = targets_size_hint;\n+        let new_items_count_total = new_items_count + self.targets.len();\n+\n+        self.targets.reserve(new_items_count);\n+        self.inlines.grow(new_items_count_total);\n+\n+        for (i, (target, inline)) in targets.enumerate() {\n+            self.targets.push(target);\n+            if inline {\n+                self.inlines.insert(i + start_index);\n+            }\n+        }\n+\n         let end_index = self.targets.len();\n         self.index.insert(source, (start_index, end_index));\n     }\n \n     // Internally iterate over all items referenced by `source` which will be\n     // made available for inlining.\n     pub fn with_inlining_candidates<F>(&self, source: TransItem<'tcx>, mut f: F)\n-        where F: FnMut(TransItem<'tcx>) {\n-        if let Some(&(start_index, end_index)) = self.index.get(&source)\n-        {\n-            for candidate in &self.targets[start_index .. end_index] {\n-                f(*candidate)\n+        where F: FnMut(TransItem<'tcx>)\n+    {\n+        if let Some(&(start_index, end_index)) = self.index.get(&source) {\n+            for (i, candidate) in self.targets[start_index .. end_index]\n+                                      .iter()\n+                                      .enumerate() {\n+                if self.inlines.contains(start_index + i) {\n+                    f(*candidate);\n+                }\n             }\n         }\n     }\n+\n+    // Internally iterate over all items and the things each accesses.\n+    pub fn iter_accesses<F>(&self, mut f: F)\n+        where F: FnMut(TransItem<'tcx>, &[TransItem<'tcx>])\n+    {\n+        for (&accessor, &(start_index, end_index)) in &self.index {\n+            f(accessor, &self.targets[start_index .. end_index])\n+        }\n+    }\n }\n \n pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -340,7 +374,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n \n             recursion_depth_reset = None;\n \n-            collect_neighbours(scx, instance, &mut neighbors);\n+            collect_neighbours(scx, instance, true, &mut neighbors);\n         }\n         TransItem::Fn(instance) => {\n             // Sanity check whether this ended up being collected accidentally\n@@ -352,14 +386,14 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                                recursion_depths));\n             check_type_length_limit(scx.tcx(), instance);\n \n-            collect_neighbours(scx, instance, &mut neighbors);\n+            collect_neighbours(scx, instance, false, &mut neighbors);\n         }\n         TransItem::GlobalAsm(..) => {\n             recursion_depth_reset = None;\n         }\n     }\n \n-    record_inlining_canditates(scx.tcx(), starting_point, &neighbors[..], inlining_map);\n+    record_accesses(scx.tcx(), starting_point, &neighbors[..], inlining_map);\n \n     for neighbour in neighbors {\n         collect_items_rec(scx, neighbour, visited, recursion_depths, inlining_map);\n@@ -372,19 +406,20 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n }\n \n-fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         caller: TransItem<'tcx>,\n                                         callees: &[TransItem<'tcx>],\n                                         inlining_map: &mut InliningMap<'tcx>) {\n     let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n         trans_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n     };\n \n-    let inlining_candidates = callees.into_iter()\n-                                     .map(|x| *x)\n-                                     .filter(is_inlining_candidate);\n+    let accesses = callees.into_iter()\n+                          .map(|trans_item| {\n+                             (*trans_item, is_inlining_candidate(trans_item))\n+                          });\n \n-    inlining_map.record_inlining_canditates(caller, inlining_candidates);\n+    inlining_map.record_accesses(caller, accesses);\n }\n \n fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -459,7 +494,8 @@ struct MirNeighborCollector<'a, 'tcx: 'a> {\n     scx: &'a SharedCrateContext<'a, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n     output: &'a mut Vec<TransItem<'tcx>>,\n-    param_substs: &'tcx Substs<'tcx>\n+    param_substs: &'tcx Substs<'tcx>,\n+    const_context: bool,\n }\n \n impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n@@ -540,7 +576,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             let substs = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n                                                                  &substs);\n             let instance = monomorphize::resolve(self.scx, def_id, substs);\n-            collect_neighbours(self.scx, instance, self.output);\n+            collect_neighbours(self.scx, instance, true, self.output);\n         }\n \n         self.super_constant(constant, location);\n@@ -556,8 +592,16 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.mir, tcx);\n-                let callee_ty = tcx.trans_apply_param_substs(self.param_substs, &callee_ty);\n-                visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n+\n+                let skip_const = self.const_context && match callee_ty.sty {\n+                    ty::TyFnDef(def_id, _) => self.scx.tcx().is_const_fn(def_id),\n+                    _ => false\n+                };\n+\n+                if !skip_const {\n+                    let callee_ty = tcx.trans_apply_param_substs(self.param_substs, &callee_ty);\n+                    visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n+                }\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n@@ -576,6 +620,22 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n         self.super_terminator_kind(block, kind, location);\n     }\n+\n+    fn visit_static(&mut self,\n+                    static_: &mir::Static<'tcx>,\n+                    context: mir::visit::LvalueContext<'tcx>,\n+                    location: Location) {\n+        debug!(\"visiting static {:?} @ {:?}\", static_.def_id, location);\n+\n+        let tcx = self.scx.tcx();\n+        let instance = Instance::mono(tcx, static_.def_id);\n+        if should_trans_locally(tcx, &instance) {\n+            let node_id = tcx.hir.as_local_node_id(static_.def_id).unwrap();\n+            self.output.push(TransItem::Static(node_id));\n+        }\n+\n+        self.super_static(static_, context, location);\n+    }\n }\n \n fn visit_drop_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -850,8 +910,14 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 // const items only generate translation items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n             }\n-            hir::ItemFn(.., ref generics, _) => {\n-                if !generics.is_type_parameterized() {\n+            hir::ItemFn(_, _, constness, _, ref generics, _) => {\n+                let is_const = match constness {\n+                    hir::Constness::Const => true,\n+                    hir::Constness::NotConst => false,\n+                };\n+\n+                if !generics.is_type_parameterized() &&\n+                   (!is_const || self.mode == TransItemCollectionMode::Eager) {\n                     let def_id = self.scx.tcx().hir.local_def_id(item.id);\n \n                     debug!(\"RootCollector: ItemFn({})\",\n@@ -872,12 +938,13 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Method(hir::MethodSig {\n+                constness,\n                 ref generics,\n                 ..\n             }, _) => {\n                 let hir_map = &self.scx.tcx().hir;\n                 let parent_node_id = hir_map.get_parent_node(ii.id);\n-                let is_impl_generic = match hir_map.expect_item(parent_node_id) {\n+                let is_impl_generic = || match hir_map.expect_item(parent_node_id) {\n                     &hir::Item {\n                         node: hir::ItemImpl(_, _, _, ref generics, ..),\n                         ..\n@@ -889,7 +956,14 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                     }\n                 };\n \n-                if !generics.is_type_parameterized() && !is_impl_generic {\n+                let is_const = match constness {\n+                    hir::Constness::Const => true,\n+                    hir::Constness::NotConst => false,\n+                };\n+\n+                if (!is_const || self.mode == TransItemCollectionMode::Eager) &&\n+                   !generics.is_type_parameterized() &&\n+                   !is_impl_generic() {\n                     let def_id = self.scx.tcx().hir.local_def_id(ii.id);\n \n                     debug!(\"RootCollector: MethodImplItem({})\",\n@@ -958,6 +1032,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n /// Scan the MIR in order to find function calls, closures, and drop-glue\n fn collect_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 instance: Instance<'tcx>,\n+                                const_context: bool,\n                                 output: &mut Vec<TransItem<'tcx>>)\n {\n     let mir = scx.tcx().instance_mir(instance.def);\n@@ -966,7 +1041,8 @@ fn collect_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         scx: scx,\n         mir: &mir,\n         output: output,\n-        param_substs: instance.substs\n+        param_substs: instance.substs,\n+        const_context,\n     };\n \n     visitor.visit_mir(&mir);"}]}