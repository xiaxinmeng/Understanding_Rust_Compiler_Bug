{"sha": "0b6f079e4987ded15c13a15b734e7cfb8176839f", "node_id": "C_kwDOAAsO6NoAKDBiNmYwNzllNDk4N2RlZDE1YzEzYTE1YjczNGU3Y2ZiODE3NjgzOWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-07T14:23:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-07T14:23:01Z"}, "message": "Auto merge of #91224 - couchand:2021-11/avr-asm, r=Amanieu\n\nSupport AVR for inline asm!\n\nA first pass at support for the AVR platform in inline `asm!`.  Passes the initial compiler tests, have not yet done more complete verification.\n\nIn particular, the register classes could use a lot more fleshing out, this draft PR so far only includes the most basic.\n\ncc `@Amanieu` `@dylanmckay`", "tree": {"sha": "3b189f1f470117f8ebc422b9a9fab4519114ca43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b189f1f470117f8ebc422b9a9fab4519114ca43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b6f079e4987ded15c13a15b734e7cfb8176839f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b6f079e4987ded15c13a15b734e7cfb8176839f", "html_url": "https://github.com/rust-lang/rust/commit/0b6f079e4987ded15c13a15b734e7cfb8176839f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b6f079e4987ded15c13a15b734e7cfb8176839f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5c94945096265b6d675b2f55a247c4799de8d87", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5c94945096265b6d675b2f55a247c4799de8d87", "html_url": "https://github.com/rust-lang/rust/commit/c5c94945096265b6d675b2f55a247c4799de8d87"}, {"sha": "c6e8ae1a6ceeffe343c214859e4eb686b7a71c95", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6e8ae1a6ceeffe343c214859e4eb686b7a71c95", "html_url": "https://github.com/rust-lang/rust/commit/c6e8ae1a6ceeffe343c214859e4eb686b7a71c95"}], "stats": {"total": 550, "additions": 549, "deletions": 1}, "files": [{"sha": "7481b5db755e7a4a60f4957329c64afd101dcd1e", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b6f079e4987ded15c13a15b734e7cfb8176839f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6f079e4987ded15c13a15b734e7cfb8176839f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=0b6f079e4987ded15c13a15b734e7cfb8176839f", "patch": "@@ -577,6 +577,7 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => unimplemented!(),\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => unimplemented!(),\n+            InlineAsmRegClass::Avr(_) => unimplemented!(),\n             InlineAsmRegClass::Bpf(_) => unimplemented!(),\n             InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => unimplemented!(),\n@@ -639,6 +640,7 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n             unimplemented!()\n         }\n+        InlineAsmRegClass::Avr(_) => unimplemented!(),\n         InlineAsmRegClass::Bpf(_) => unimplemented!(),\n         InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => cx.type_i32(),\n@@ -747,6 +749,7 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n             unimplemented!()\n         }\n+        InlineAsmRegClass::Avr(_) => unimplemented!(),\n         InlineAsmRegClass::Bpf(_) => unimplemented!(),\n         InlineAsmRegClass::Hexagon(_) => unimplemented!(),\n         InlineAsmRegClass::Mips(_) => unimplemented!(),"}, {"sha": "90d3c0fb2f173acbbc335415334d0169b7fa940e", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b6f079e4987ded15c13a15b734e7cfb8176839f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6f079e4987ded15c13a15b734e7cfb8176839f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=0b6f079e4987ded15c13a15b734e7cfb8176839f", "patch": "@@ -319,6 +319,9 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         \"~{vxrm}\".to_string(),\n                     ]);\n                 }\n+                InlineAsmArch::Avr => {\n+                    constraints.push(\"~{sreg}\".to_string());\n+                }\n                 InlineAsmArch::Nvptx64 => {}\n                 InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {}\n                 InlineAsmArch::Hexagon => {}\n@@ -669,6 +672,11 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>)\n             InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => \"r\",\n             InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => \"w\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_upper) => \"d\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_pair) => \"r\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_iw) => \"w\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => \"e\",\n             InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n@@ -749,6 +757,14 @@ fn modifier_to_llvm(\n         }\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => None,\n         InlineAsmRegClass::Bpf(_) => None,\n+        InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_pair)\n+        | InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_iw)\n+        | InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => match modifier {\n+            Some('h') => Some('B'),\n+            Some('l') => Some('A'),\n+            _ => None,\n+        },\n+        InlineAsmRegClass::Avr(_) => None,\n         InlineAsmRegClass::S390x(_) => None,\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n@@ -812,6 +828,11 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => cx.type_i32(),\n         InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => cx.type_i64(),\n         InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => cx.type_i32(),\n+        InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg) => cx.type_i8(),\n+        InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_upper) => cx.type_i8(),\n+        InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_pair) => cx.type_i16(),\n+        InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_iw) => cx.type_i16(),\n+        InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => cx.type_i16(),\n         InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => cx.type_f64(),\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {"}, {"sha": "a4280047c70689b1bf0e1976c7547f795cdc4adc", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b6f079e4987ded15c13a15b734e7cfb8176839f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6f079e4987ded15c13a15b734e7cfb8176839f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=0b6f079e4987ded15c13a15b734e7cfb8176839f", "patch": "@@ -1053,8 +1053,12 @@ symbols! {\n         reg64,\n         reg_abcd,\n         reg_byte,\n+        reg_iw,\n         reg_nonzero,\n+        reg_pair,\n+        reg_ptr,\n         reg_thumb,\n+        reg_upper,\n         register_attr,\n         register_tool,\n         relaxed_adts,"}, {"sha": "82a4f8bacb3fadbd887283529adae08062ac57e9", "filename": "compiler/rustc_target/src/asm/avr.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/0b6f079e4987ded15c13a15b734e7cfb8176839f/compiler%2Frustc_target%2Fsrc%2Fasm%2Favr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6f079e4987ded15c13a15b734e7cfb8176839f/compiler%2Frustc_target%2Fsrc%2Fasm%2Favr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Favr.rs?ref=0b6f079e4987ded15c13a15b734e7cfb8176839f", "patch": "@@ -0,0 +1,196 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    Avr AvrInlineAsmRegClass {\n+        reg,\n+        reg_upper,\n+        reg_pair,\n+        reg_iw,\n+        reg_ptr,\n+    }\n+}\n+\n+impl AvrInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: InlineAsmArch) -> &'static [char] {\n+        match self {\n+            Self::reg_pair | Self::reg_iw | Self::reg_ptr => &['h', 'l'],\n+            _ => &[],\n+        }\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg => types! { _: I8; },\n+            Self::reg_upper => types! { _: I8; },\n+            Self::reg_pair => types! { _: I16; },\n+            Self::reg_iw => types! { _: I16; },\n+            Self::reg_ptr => types! { _: I16; },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    Avr AvrInlineAsmReg AvrInlineAsmRegClass {\n+        r2: reg = [\"r2\"],\n+        r3: reg = [\"r3\"],\n+        r4: reg = [\"r4\"],\n+        r5: reg = [\"r5\"],\n+        r6: reg = [\"r6\"],\n+        r7: reg = [\"r7\"],\n+        r8: reg = [\"r8\"],\n+        r9: reg = [\"r9\"],\n+        r10: reg = [\"r10\"],\n+        r11: reg = [\"r11\"],\n+        r12: reg = [\"r12\"],\n+        r13: reg = [\"r13\"],\n+        r14: reg = [\"r14\"],\n+        r15: reg = [\"r15\"],\n+        r16: reg, reg_upper = [\"r16\"],\n+        r17: reg, reg_upper = [\"r17\"],\n+        r18: reg, reg_upper = [\"r18\"],\n+        r19: reg, reg_upper = [\"r19\"],\n+        r20: reg, reg_upper = [\"r20\"],\n+        r21: reg, reg_upper = [\"r21\"],\n+        r22: reg, reg_upper = [\"r22\"],\n+        r23: reg, reg_upper = [\"r23\"],\n+        r24: reg, reg_upper = [\"r24\"],\n+        r25: reg, reg_upper = [\"r25\"],\n+        r26: reg, reg_upper = [\"r26\", \"XL\"],\n+        r27: reg, reg_upper = [\"r27\", \"XH\"],\n+        r30: reg, reg_upper = [\"r30\", \"ZL\"],\n+        r31: reg, reg_upper = [\"r31\", \"ZH\"],\n+\n+        r3r2: reg_pair = [\"r3r2\"],\n+        r5r4: reg_pair = [\"r5r4\"],\n+        r7r6: reg_pair = [\"r7r6\"],\n+        r9r8: reg_pair = [\"r9r8\"],\n+        r11r10: reg_pair = [\"r11r10\"],\n+        r13r12: reg_pair = [\"r13r12\"],\n+        r15r14: reg_pair = [\"r15r14\"],\n+        r17r16: reg_pair = [\"r17r16\"],\n+        r19r18: reg_pair = [\"r19r18\"],\n+        r21r20: reg_pair = [\"r21r20\"],\n+        r23r22: reg_pair = [\"r23r22\"],\n+\n+        r25r24: reg_iw, reg_pair = [\"r25r24\"],\n+\n+        X: reg_ptr, reg_iw, reg_pair = [\"r27r26\", \"X\"],\n+        Z: reg_ptr, reg_iw, reg_pair = [\"r31r30\", \"Z\"],\n+\n+        #error = [\"Y\", \"YL\", \"YH\"] =>\n+            \"the frame pointer cannot be used as an operand for inline asm\",\n+        #error = [\"SP\", \"SPL\", \"SPH\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"r0\", \"r1\", \"r1r0\"] =>\n+            \"r0 and r1 are not available due to an issue in LLVM\",\n+    }\n+}\n+\n+macro_rules! emit_pairs {\n+    (\n+        $self:ident $modifier:ident,\n+        $($pair:ident $name:literal $hi:literal $lo:literal,)*\n+    ) => {\n+        match ($self, $modifier) {\n+            $(\n+                (AvrInlineAsmReg::$pair, Some('h')) => $hi,\n+                (AvrInlineAsmReg::$pair, Some('l')) => $lo,\n+                (AvrInlineAsmReg::$pair, _) => $name,\n+            )*\n+            _ => $self.name(),\n+        }\n+    };\n+}\n+\n+impl AvrInlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        modifier: Option<char>,\n+    ) -> fmt::Result {\n+        let name = emit_pairs! {\n+            self modifier,\n+            Z \"Z\" \"ZH\" \"ZL\",\n+            X \"X\" \"XH\" \"XL\",\n+            r25r24 \"r25:r24\" \"r25\" \"r24\",\n+            r23r22 \"r23:r22\" \"r23\" \"r22\",\n+            r21r20 \"r21:r20\" \"r21\" \"r20\",\n+            r19r18 \"r19:r18\" \"r19\" \"r18\",\n+            r17r16 \"r17:r16\" \"r17\" \"r16\",\n+            r15r14 \"r15:r14\" \"r15\" \"r14\",\n+            r13r12 \"r13:r12\" \"r13\" \"r12\",\n+            r11r10 \"r11:r10\" \"r11\" \"r10\",\n+            r9r8 \"r9:r8\" \"r9\" \"r8\",\n+            r7r6 \"r7:r6\" \"r7\" \"r6\",\n+            r5r4 \"r5:r4\" \"r5\" \"r4\",\n+            r3r2 \"r3:r2\" \"r3\" \"r2\",\n+        };\n+        out.write_str(name)\n+    }\n+\n+    pub fn overlapping_regs(self, mut cb: impl FnMut(AvrInlineAsmReg)) {\n+        cb(self);\n+\n+        macro_rules! reg_conflicts {\n+            (\n+                $(\n+                    $pair:ident : $hi:ident $lo:ident,\n+                )*\n+            ) => {\n+                match self {\n+                    $(\n+                        Self::$pair => {\n+                            cb(Self::$hi);\n+                            cb(Self::$lo);\n+                        }\n+                        Self::$hi => {\n+                            cb(Self::$pair);\n+                        }\n+                        Self::$lo => {\n+                            cb(Self::$pair);\n+                        }\n+                    )*\n+                }\n+            };\n+        }\n+\n+        reg_conflicts! {\n+            Z : r31 r30,\n+            X : r27 r26,\n+            r25r24 : r25 r24,\n+            r23r22 : r23 r22,\n+            r21r20 : r21 r20,\n+            r19r18 : r19 r18,\n+            r17r16 : r17 r16,\n+            r15r14 : r15 r14,\n+            r13r12 : r13 r12,\n+            r11r10 : r11 r10,\n+            r9r8 : r9 r8,\n+            r7r6 : r7 r6,\n+            r5r4 : r5 r4,\n+            r3r2 : r3 r2,\n+        }\n+    }\n+}"}, {"sha": "cf940594bc459a616bbdac3298b836f0bcd14a75", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0b6f079e4987ded15c13a15b734e7cfb8176839f/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6f079e4987ded15c13a15b734e7cfb8176839f/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=0b6f079e4987ded15c13a15b734e7cfb8176839f", "patch": "@@ -148,6 +148,7 @@ macro_rules! types {\n \n mod aarch64;\n mod arm;\n+mod avr;\n mod bpf;\n mod hexagon;\n mod mips;\n@@ -161,6 +162,7 @@ mod x86;\n \n pub use aarch64::{AArch64InlineAsmReg, AArch64InlineAsmRegClass};\n pub use arm::{ArmInlineAsmReg, ArmInlineAsmRegClass};\n+pub use avr::{AvrInlineAsmReg, AvrInlineAsmRegClass};\n pub use bpf::{BpfInlineAsmReg, BpfInlineAsmRegClass};\n pub use hexagon::{HexagonInlineAsmReg, HexagonInlineAsmRegClass};\n pub use mips::{MipsInlineAsmReg, MipsInlineAsmRegClass};\n@@ -191,6 +193,7 @@ pub enum InlineAsmArch {\n     Wasm32,\n     Wasm64,\n     Bpf,\n+    Avr,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -215,6 +218,7 @@ impl FromStr for InlineAsmArch {\n             \"wasm32\" => Ok(Self::Wasm32),\n             \"wasm64\" => Ok(Self::Wasm64),\n             \"bpf\" => Ok(Self::Bpf),\n+            \"avr\" => Ok(Self::Avr),\n             _ => Err(()),\n         }\n     }\n@@ -245,6 +249,7 @@ pub enum InlineAsmReg {\n     SpirV(SpirVInlineAsmReg),\n     Wasm(WasmInlineAsmReg),\n     Bpf(BpfInlineAsmReg),\n+    Avr(AvrInlineAsmReg),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -261,6 +266,7 @@ impl InlineAsmReg {\n             Self::Mips(r) => r.name(),\n             Self::S390x(r) => r.name(),\n             Self::Bpf(r) => r.name(),\n+            Self::Avr(r) => r.name(),\n             Self::Err => \"<reg>\",\n         }\n     }\n@@ -276,6 +282,7 @@ impl InlineAsmReg {\n             Self::Mips(r) => InlineAsmRegClass::Mips(r.reg_class()),\n             Self::S390x(r) => InlineAsmRegClass::S390x(r.reg_class()),\n             Self::Bpf(r) => InlineAsmRegClass::Bpf(r.reg_class()),\n+            Self::Avr(r) => InlineAsmRegClass::Avr(r.reg_class()),\n             Self::Err => InlineAsmRegClass::Err,\n         }\n     }\n@@ -326,6 +333,9 @@ impl InlineAsmReg {\n             InlineAsmArch::Bpf => {\n                 Self::Bpf(BpfInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n+            InlineAsmArch::Avr => {\n+                Self::Avr(AvrInlineAsmReg::parse(arch, has_feature, target, &name)?)\n+            }\n         })\n     }\n \n@@ -347,6 +357,7 @@ impl InlineAsmReg {\n             Self::Mips(r) => r.emit(out, arch, modifier),\n             Self::S390x(r) => r.emit(out, arch, modifier),\n             Self::Bpf(r) => r.emit(out, arch, modifier),\n+            Self::Avr(r) => r.emit(out, arch, modifier),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -362,6 +373,7 @@ impl InlineAsmReg {\n             Self::Mips(_) => cb(self),\n             Self::S390x(_) => cb(self),\n             Self::Bpf(r) => r.overlapping_regs(|r| cb(Self::Bpf(r))),\n+            Self::Avr(r) => r.overlapping_regs(|r| cb(Self::Avr(r))),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -392,6 +404,7 @@ pub enum InlineAsmRegClass {\n     SpirV(SpirVInlineAsmRegClass),\n     Wasm(WasmInlineAsmRegClass),\n     Bpf(BpfInlineAsmRegClass),\n+    Avr(AvrInlineAsmRegClass),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -411,6 +424,7 @@ impl InlineAsmRegClass {\n             Self::SpirV(r) => r.name(),\n             Self::Wasm(r) => r.name(),\n             Self::Bpf(r) => r.name(),\n+            Self::Avr(r) => r.name(),\n             Self::Err => rustc_span::symbol::sym::reg,\n         }\n     }\n@@ -432,6 +446,7 @@ impl InlineAsmRegClass {\n             Self::SpirV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::SpirV),\n             Self::Wasm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Wasm),\n             Self::Bpf(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Bpf),\n+            Self::Avr(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Avr),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -460,6 +475,7 @@ impl InlineAsmRegClass {\n             Self::SpirV(r) => r.suggest_modifier(arch, ty),\n             Self::Wasm(r) => r.suggest_modifier(arch, ty),\n             Self::Bpf(r) => r.suggest_modifier(arch, ty),\n+            Self::Avr(r) => r.suggest_modifier(arch, ty),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -484,6 +500,7 @@ impl InlineAsmRegClass {\n             Self::SpirV(r) => r.default_modifier(arch),\n             Self::Wasm(r) => r.default_modifier(arch),\n             Self::Bpf(r) => r.default_modifier(arch),\n+            Self::Avr(r) => r.default_modifier(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -507,6 +524,7 @@ impl InlineAsmRegClass {\n             Self::SpirV(r) => r.supported_types(arch),\n             Self::Wasm(r) => r.supported_types(arch),\n             Self::Bpf(r) => r.supported_types(arch),\n+            Self::Avr(r) => r.supported_types(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -535,6 +553,7 @@ impl InlineAsmRegClass {\n                 Self::Wasm(WasmInlineAsmRegClass::parse(arch, name)?)\n             }\n             InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(arch, name)?),\n         })\n     }\n \n@@ -554,6 +573,7 @@ impl InlineAsmRegClass {\n             Self::SpirV(r) => r.valid_modifiers(arch),\n             Self::Wasm(r) => r.valid_modifiers(arch),\n             Self::Bpf(r) => r.valid_modifiers(arch),\n+            Self::Avr(r) => r.valid_modifiers(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -739,6 +759,11 @@ pub fn allocatable_registers(\n             bpf::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n+        InlineAsmArch::Avr => {\n+            let mut map = avr::regclass_map();\n+            avr::fill_reg_map(arch, has_feature, target, &mut map);\n+            map\n+        }\n     }\n }\n "}, {"sha": "dffa3a8b80f0f38430f31f5e9e1fa50882181e5a", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b6f079e4987ded15c13a15b734e7cfb8176839f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b6f079e4987ded15c13a15b734e7cfb8176839f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=0b6f079e4987ded15c13a15b734e7cfb8176839f", "patch": "@@ -32,6 +32,7 @@ Inline assembly is currently supported on the following architectures:\n - wasm32\n - BPF\n - SPIR-V\n+- AVR\n \n ## Basic usage\n \n@@ -471,6 +472,7 @@ Inline assembly is currently supported on the following architectures:\n - wasm32\n - BPF\n - SPIR-V\n+- AVR\n \n Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n \n@@ -593,6 +595,11 @@ Here is the list of currently supported register classes:\n | wasm32 | `local` | None\\* | `r` |\n | BPF | `reg` |\u00a0`r[0-10]` | `r` |\n | BPF | `wreg` |\u00a0`w[0-10]` | `w` |\n+| AVR | `reg` | `r[2-25]`, `XH`, `XL`, `ZH`, `ZL` | `r` |\n+| AVR | `reg_upper` | `r[16-25]`, `XH`, `XL`, `ZH`, `ZL` | `d` |\n+| AVR | `reg_pair` | `r3r2` .. `r25r24`, `X`, `Z` | `r` |\n+| AVR | `reg_iw` | `r25r24`, `X`, `Z` | `w` |\n+| AVR | `reg_ptr` | `X`, `Z` | `e` |\n \n > **Note**: On x86 we treat `reg_byte` differently from `reg` because the compiler can allocate `al` and `ah` separately whereas `reg` reserves the whole register.\n >\n@@ -648,6 +655,8 @@ Each register class has constraints on which value types they can be used with.\n | wasm32 | `local` | None | `i8` `i16` `i32` `i64` `f32` `f64` |\n | BPF |\u00a0`reg` |\u00a0None | `i8` `i16` `i32` `i64` |\n | BPF |\u00a0`wreg` |\u00a0`alu32` | `i8` `i16` `i32` |\n+| AVR | `reg`, `reg_upper` | None | `i8` |\n+| AVR | `reg_pair`, `reg_iw`, `reg_ptr` | None | `i16` |\n \n > **Note**: For the purposes of the above table pointers, function pointers and `isize`/`usize` are treated as the equivalent integer type (`i16`/`i32`/`i64` depending on the target).\n \n@@ -708,13 +717,17 @@ Some registers have multiple names. These are all treated by the compiler as ide\n | Hexagon | `r30` | `fr` |\n | Hexagon | `r31` | `lr` |\n | BPF | `r[0-10]` | `w[0-10]` |\n+| AVR | `XH` | `r27` |\n+| AVR | `XL` | `r26` |\n+| AVR | `ZH` | `r31` |\n+| AVR | `ZL` | `r30` |\n \n Some registers cannot be used for input or output operands:\n \n | Architecture | Unsupported register | Reason |\n | ------------ | -------------------- | ------ |\n | All | `sp` | The stack pointer must be restored to its original value at the end of an asm code block. |\n-| All | `bp` (x86), `x29` (AArch64), `x8` (RISC-V), `fr` (Hexagon), `$fp` (MIPS) | The frame pointer cannot be used as an input or output. |\n+| All | `bp` (x86), `x29` (AArch64), `x8` (RISC-V), `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR) | The frame pointer cannot be used as an input or output. |\n | ARM | `r7` or `r11` | On ARM the frame pointer can be either `r7` or `r11` depending on the target. The frame pointer cannot be used as an input or output. |\n | All | `si` (x86-32), `bx` (x86-64), `r6` (ARM), `x19` (AArch64), `r19` (Hexagon), `x9` (RISC-V) | This is used internally by LLVM as a \"base pointer\" for functions with complex stack frames. |\n | x86 | `k0` | This is a constant zero register which can't be modified. |\n@@ -732,11 +745,13 @@ Some registers cannot be used for input or output operands:\n | RISC-V | `x0` | This is a constant zero register which can't be modified. |\n | RISC-V | `gp`, `tp` | These registers are reserved and cannot be used as inputs or outputs. |\n | Hexagon | `lr` | This is the link register which cannot be used as an input or output. |\n+| AVR | `r0`, `r1`, `r1r0` | Due to an issue in LLVM, the `r0` and `r1` registers cannot be used as inputs or outputs.  If modified, they must be restored to their original values before the end of the block. |\n \n In some cases LLVM will allocate a \"reserved register\" for `reg` operands even though this register cannot be explicitly specified. Assembly code making use of reserved registers should be careful since `reg` operands may alias with those registers. Reserved registers are the frame pointer and base pointer\n - The frame pointer and LLVM base pointer on all architectures.\n - `r9` on ARM.\n - `x18` on AArch64.\n+- `r0` and `r1` on AVR.\n \n ## Template modifiers\n \n@@ -882,6 +897,8 @@ The compiler performs some additional checks on options:\n   - RISC-V\n     - Floating-point exception flags in `fcsr` (`fflags`).\n     - Vector extension state (`vtype`, `vl`, `vcsr`).\n+  - AVR\n+    - The status register `SREG`.\n - On x86, the direction flag (DF in `EFLAGS`) is clear on entry to an asm block and must be clear on exit.\n   - Behavior is undefined if the direction flag is set on exiting an asm block.\n - The requirement of restoring the stack pointer and non-output registers to their original value only applies when exiting an `asm!` block."}, {"sha": "aba4c982c7305ac9e311ec1b3f0819bb9171c1aa", "filename": "src/test/assembly/asm/avr-modifiers.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0b6f079e4987ded15c13a15b734e7cfb8176839f/src%2Ftest%2Fassembly%2Fasm%2Favr-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6f079e4987ded15c13a15b734e7cfb8176839f/src%2Ftest%2Fassembly%2Fasm%2Favr-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Favr-modifiers.rs?ref=0b6f079e4987ded15c13a15b734e7cfb8176839f", "patch": "@@ -0,0 +1,60 @@\n+// min-llvm-version: 13.0\n+// assembly-output: emit-asm\n+// compile-flags: --target avr-unknown-gnu-atmega328\n+// needs-llvm-components: avr\n+\n+#![feature(no_core, lang_items, rustc_attrs, asm_experimental_arch)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *const u64;\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for i64 {}\n+impl Copy for ptr {}\n+\n+macro_rules! check {\n+    ($func:ident $hi:literal $lo:literal $reg:tt) => {\n+        #[no_mangle]\n+        unsafe fn $func() -> i16 {\n+            let y;\n+            asm!(concat!(\"mov {0:\", $hi, \"}, {0:\", $lo, \"}\"), out($reg) y);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: reg_pair_modifiers:\n+// CHECK: ;APP\n+// CHECK: mov r{{[1-9]?[13579]}}, r{{[1-9]?[24680]}}\n+// CHECK: ;NO_APP\n+check!(reg_pair_modifiers \"h\" \"l\" reg_pair);\n+\n+// CHECK-LABEL: reg_iw_modifiers:\n+// CHECK: ;APP\n+// CHECK: mov r{{[1-9]?[13579]}}, r{{[1-9]?[24680]}}\n+// CHECK: ;NO_APP\n+check!(reg_iw_modifiers \"h\" \"l\" reg_iw);\n+\n+// CHECK-LABEL: reg_ptr_modifiers:\n+// CHECK: ;APP\n+// CHECK: mov r{{[1-9]?[13579]}}, r{{[1-9]?[24680]}}\n+// CHECK: ;NO_APP\n+check!(reg_ptr_modifiers \"h\" \"l\" reg_ptr);"}, {"sha": "53a601e51c8bf75be9cf71a80abbd98740879e47", "filename": "src/test/assembly/asm/avr-types.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/0b6f079e4987ded15c13a15b734e7cfb8176839f/src%2Ftest%2Fassembly%2Fasm%2Favr-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6f079e4987ded15c13a15b734e7cfb8176839f/src%2Ftest%2Fassembly%2Fasm%2Favr-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Favr-types.rs?ref=0b6f079e4987ded15c13a15b734e7cfb8176839f", "patch": "@@ -0,0 +1,222 @@\n+// min-llvm-version: 13.0\n+// assembly-output: emit-asm\n+// compile-flags: --target avr-unknown-gnu-atmega328\n+// needs-llvm-components: avr\n+\n+#![feature(no_core, lang_items, rustc_attrs, asm_sym, asm_experimental_arch)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *const u64;\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for i64 {}\n+impl Copy for ptr {}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(\"mov {}, {}\", lateout($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+macro_rules! checkw {\n+    ($func:ident $ty:ident $class:ident) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(\"movw {}, {}\", lateout($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+macro_rules! check_reg {\n+    ($func:ident $ty:ident $reg:tt) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(concat!(\"mov \", $reg, \", \", $reg), lateout($reg) y, in($reg) x);\n+            y\n+        }\n+    };\n+}\n+\n+macro_rules! check_regw {\n+    ($func:ident $ty:ident $reg:tt $reg_lit:tt) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(concat!(\"movw \", $reg_lit, \", \", $reg_lit), lateout($reg) y, in($reg) x);\n+            y\n+        }\n+    };\n+}\n+\n+extern \"C\" {\n+    fn extern_func();\n+    static extern_static: i8;\n+}\n+\n+// CHECK-LABEL: sym_fn\n+// CHECK: ;APP\n+// CHECK: call extern_func\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_fn() {\n+    asm!(\"call {}\", sym extern_func);\n+}\n+\n+// CHECK-LABEL: sym_static\n+// CHECK: ;APP\n+// CHECK: lds r{{[0-9]+}}, extern_static\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_static() -> i8 {\n+    let y;\n+    asm!(\"lds {}, {}\", lateout(reg) y, sym extern_static);\n+    y\n+}\n+\n+// CHECK-LABEL: ld_z:\n+// CHECK: ;APP\n+// CHECK: ld r{{[0-9]+}}, Z\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn ld_z(x: i16) -> i8 {\n+    let y;\n+    asm!(\"ld {}, Z\", out(reg) y, in(\"Z\") x);\n+    y\n+}\n+\n+// CHECK-LABEL: ldd_z:\n+// CHECK: ;APP\n+// CHECK: ldd r{{[0-9]+}}, Z+4\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn ldd_z(x: i16) -> i8 {\n+    let y;\n+    asm!(\"ldd {}, Z+4\", out(reg) y, in(\"Z\") x);\n+    y\n+}\n+\n+// CHECK-LABEL: ld_predecrement:\n+// CHECK: ;APP\n+// CHECK: ld r{{[0-9]+}}, -Z\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn ld_predecrement(x: i16) -> i8 {\n+    let y;\n+    asm!(\"ld {}, -Z\", out(reg) y, in(\"Z\") x);\n+    y\n+}\n+\n+// CHECK-LABEL: ld_postincrement:\n+// CHECK: ;APP\n+// CHECK: ld r{{[0-9]+}}, Z+\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn ld_postincrement(x: i16) -> i8 {\n+    let y;\n+    asm!(\"ld {}, Z+\", out(reg) y, in(\"Z\") x);\n+    y\n+}\n+\n+// CHECK-LABEL: muls_clobber:\n+// CHECK: ;APP\n+// CHECK: muls r{{[0-9]+}}, r{{[0-9]+}}\n+// CHECK: movw r{{[0-9]+}}, r0\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn muls_clobber(x: i8, y: i8) -> i16 {\n+    let z;\n+    asm!(\n+        \"muls {}, {}\",\n+        \"movw {}, r1:r0\",\n+        out(reg_iw) z,\n+        in(reg) x,\n+        in(reg) y,\n+    );\n+    z\n+}\n+\n+// CHECK-LABEL: reg_i8:\n+// CHECK: ;APP\n+// CHECK: mov r{{[0-9]+}}, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+check!(reg_i8 i8 reg);\n+\n+// CHECK-LABEL: reg_upper_i8:\n+// CHECK: ;APP\n+// CHECK: mov r{{[1-3][0-9]}}, r{{[1-3][0-9]}}\n+// CHECK: ;NO_APP\n+check!(reg_upper_i8 i8 reg_upper);\n+\n+// CHECK-LABEL: reg_pair_i16:\n+// CHECK: ;APP\n+// CHECK: movw r{{[0-9]+}}, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+checkw!(reg_pair_i16 i16 reg_pair);\n+\n+// CHECK-LABEL: reg_iw_i16:\n+// CHECK: ;APP\n+// CHECK: movw r{{[0-9]+}}, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+checkw!(reg_iw_i16 i16 reg_iw);\n+\n+// CHECK-LABEL: reg_ptr_i16:\n+// CHECK: ;APP\n+// CHECK: movw r{{[0-9]+}}, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+checkw!(reg_ptr_i16 i16 reg_ptr);\n+\n+// CHECK-LABEL: r2_i8:\n+// CHECK: ;APP\n+// CHECK: mov r2, r2\n+// CHECK: ;NO_APP\n+check_reg!(r2_i8 i8 \"r2\");\n+\n+// CHECK-LABEL: xl_i8:\n+// CHECK: ;APP\n+// CHECK: mov r26, r26\n+// CHECK: ;NO_APP\n+check_reg!(xl_i8 i8 \"XL\");\n+\n+// CHECK-LABEL: xh_i8:\n+// CHECK: ;APP\n+// CHECK: mov r27, r27\n+// CHECK: ;NO_APP\n+check_reg!(xh_i8 i8 \"XH\");\n+\n+// CHECK-LABEL: x_i16:\n+// CHECK: ;APP\n+// CHECK: movw r26, r26\n+// CHECK: ;NO_APP\n+check_regw!(x_i16 i16 \"X\" \"X\");\n+\n+// CHECK-LABEL: r25r24_i16:\n+// CHECK: ;APP\n+// CHECK: movw r24, r24\n+// CHECK: ;NO_APP\n+check_regw!(r25r24_i16 i16 \"r25r24\" \"r24\");"}]}