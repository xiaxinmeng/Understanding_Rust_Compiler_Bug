{"sha": "1e68d576829c09a64dd2f0ac802165a8e3376ac2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNjhkNTc2ODI5YzA5YTY0ZGQyZjBhYzgwMjE2NWE4ZTMzNzZhYzI=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-01T13:46:14Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-20T15:08:57Z"}, "message": "Add support for fixed size vectors in let/arg patterns\n\nFixes #7784", "tree": {"sha": "d3e3b7d63d860941910383a1b4fbcb7e7192e086", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3e3b7d63d860941910383a1b4fbcb7e7192e086"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e68d576829c09a64dd2f0ac802165a8e3376ac2", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e68d576829c09a64dd2f0ac802165a8e3376ac2", "html_url": "https://github.com/rust-lang/rust/commit/1e68d576829c09a64dd2f0ac802165a8e3376ac2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e68d576829c09a64dd2f0ac802165a8e3376ac2/comments", "author": null, "committer": null, "parents": [{"sha": "34407dcdbb489a38b15fac0167a88cb94c3d12ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/34407dcdbb489a38b15fac0167a88cb94c3d12ac", "html_url": "https://github.com/rust-lang/rust/commit/34407dcdbb489a38b15fac0167a88cb94c3d12ac"}], "stats": {"total": 55, "additions": 48, "deletions": 7}, "files": [{"sha": "5b9c89f6250931f4f8a8713263bebcaeb776e1e4", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1e68d576829c09a64dd2f0ac802165a8e3376ac2/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e68d576829c09a64dd2f0ac802165a8e3376ac2/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1e68d576829c09a64dd2f0ac802165a8e3376ac2", "patch": "@@ -988,8 +988,7 @@ fn extract_vec_elems<'a>(\n                      pat_id: ast::NodeId,\n                      elem_count: uint,\n                      slice: Option<uint>,\n-                     val: ValueRef,\n-                     count: ValueRef)\n+                     val: ValueRef)\n                      -> ExtractedBlock<'a> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(bcx, val, pat_id);\n@@ -1003,7 +1002,7 @@ fn extract_vec_elems<'a>(\n             Some(n) if i < n => GEPi(bcx, base, [i]),\n             Some(n) if i > n => {\n                 InBoundsGEP(bcx, base, [\n-                    Sub(bcx, count,\n+                    Sub(bcx, len,\n                         C_int(bcx.ccx(), (elem_count - i) as int))])\n             }\n             _ => unsafe { llvm::LLVMGetUndef(vt.llunit_ty.to_ref()) }\n@@ -1765,7 +1764,7 @@ fn compile_submatch_continue<'a, 'b>(\n                     vec_len_eq => (n, None)\n                 };\n                 let args = extract_vec_elems(opt_cx, pat_id, n,\n-                                             slice, val, test_val);\n+                                             slice, val);\n                 size = args.vals.len();\n                 unpacked = args.vals.clone();\n                 opt_cx = args.bcx;\n@@ -2264,9 +2263,21 @@ fn bind_irrefutable_pat<'a>(\n             let loaded_val = Load(bcx, val);\n             bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode, cleanup_scope);\n         }\n-        ast::PatVec(..) => {\n-            bcx.sess().span_bug(pat.span,\n-                                \"vector patterns are never irrefutable!\");\n+        ast::PatVec(ref before, ref slice, ref after) => {\n+            let extracted = extract_vec_elems(\n+                bcx, pat.id, before.len() + 1u + after.len(),\n+                slice.map(|_| before.len()), val\n+            );\n+            bcx = before\n+                .iter().map(|v| Some(*v))\n+                .chain(Some(*slice).move_iter())\n+                .chain(after.iter().map(|v| Some(*v)))\n+                .zip(extracted.vals.iter())\n+                .fold(bcx, |bcx, (inner, elem)| {\n+                    inner.map_or(bcx, |inner| {\n+                        bind_irrefutable_pat(bcx, inner, *elem, binding_mode, cleanup_scope)\n+                    })\n+                });\n         }\n         ast::PatMac(..) => {\n             bcx.sess().span_bug(pat.span, \"unexpanded macro\");"}, {"sha": "06d22149b81d3bb0a45890ec53a77ffeae91c1e5", "filename": "src/test/run-pass/issue-7784.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1e68d576829c09a64dd2f0ac802165a8e3376ac2/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e68d576829c09a64dd2f0ac802165a8e3376ac2/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=1e68d576829c09a64dd2f0ac802165a8e3376ac2", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<T: Add<T, T> + Clone>([x, y, z]: [T, ..3]) -> (T, T, T) {\n+    (x.clone(), x.clone() + y.clone(), x + y + z)\n+}\n+fn bar(a: &'static str, b: &'static str) -> [&'static str, ..4] {\n+    [a, b, b, a]\n+}\n+\n+fn main() {\n+    assert_eq!(foo([1, 2, 3]), (1, 3, 6));\n+\n+    let [a, b, c, d] = bar(\"foo\", \"bar\");\n+    assert_eq!(a, \"foo\");\n+    assert_eq!(b, \"bar\");\n+    assert_eq!(c, \"bar\");\n+    assert_eq!(d, \"foo\");\n+\n+    let [a, _, _, d] = bar(\"baz\", \"foo\");\n+    assert_eq!(a, \"baz\");\n+    assert_eq!(d, \"baz\");\n+}\n\\ No newline at end of file"}]}