{"sha": "27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OTc1YzQ5YTY0M2QwYjJmOGNiY2Q3ODU0OTMxYzRjOWE4YzVkYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-30T01:45:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-30T01:45:46Z"}, "message": "Auto merge of #26667 - arielb1:audit-walk, r=eddyb\n\nThis was originally motivated by checking for HRTB hygiene, but I found several other bugs on the way.\r\n\r\nThis does not fix the biggest user of ty_walk, which is dtorck - I would prefer to coordinate that with @pnkfelix.\r\n\r\nr? @eddyb", "tree": {"sha": "5a19cbed20e5d7aca8684e58ed2b90a98b296b98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a19cbed20e5d7aca8684e58ed2b90a98b296b98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "html_url": "https://github.com/rust-lang/rust/commit/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faa04a8b9c326bb71b1d21e962dd96912ce234c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/faa04a8b9c326bb71b1d21e962dd96912ce234c6", "html_url": "https://github.com/rust-lang/rust/commit/faa04a8b9c326bb71b1d21e962dd96912ce234c6"}, {"sha": "fb5dd398f677213e8f0943638c9205172a634efe", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5dd398f677213e8f0943638c9205172a634efe", "html_url": "https://github.com/rust-lang/rust/commit/fb5dd398f677213e8f0943638c9205172a634efe"}], "stats": {"total": 633, "additions": 314, "deletions": 319}, "files": [{"sha": "64063623f6776f7a92840bf81086e87267d5556e", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -359,7 +359,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n     where T: TypeFoldable<'tcx>,\n           F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n-    unbound_value.fold_with(&mut ty_fold::RegionFolder::new(tcx, &mut |region, current_depth| {\n+    ty_fold::fold_regions(tcx, unbound_value, &mut false, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n         // because the ones at the current level should have been replaced\n         // with fresh variables\n@@ -369,7 +369,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n         });\n \n         fldr(region, ty::DebruijnIndex::new(current_depth))\n-    }))\n+    })\n }\n \n impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n@@ -437,11 +437,10 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n         let escaping_types =\n             self.type_variables.borrow().types_escaping_snapshot(&snapshot.type_snapshot);\n \n-        let escaping_region_vars: FnvHashSet<_> =\n-            escaping_types\n-            .iter()\n-            .flat_map(|&t| ty_fold::collect_regions(self.tcx, &t))\n-            .collect();\n+        let mut escaping_region_vars = FnvHashSet();\n+        for ty in &escaping_types {\n+            ty_fold::collect_regions(self.tcx, ty, &mut escaping_region_vars);\n+        }\n \n         region_vars.retain(|&region_vid| {\n             let r = ty::ReInfer(ty::ReVar(region_vid));\n@@ -649,7 +648,7 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     // binder is that we encountered in `value`. The caller is\n     // responsible for ensuring that (a) `value` contains at least one\n     // binder and (b) that binder is the one we want to use.\n-    let result = ty_fold::fold_regions(infcx.tcx, &value, |r, current_depth| {\n+    let result = ty_fold::fold_regions(infcx.tcx, &value, &mut false, |r, current_depth| {\n         match inv_skol_map.get(&r) {\n             None => r,\n             Some(br) => {"}, {"sha": "dc3ccd417b8f7be506eaf267c7f179731a87f7b1", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -421,16 +421,18 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             // regions.  If there are, we will call this obligation an\n             // error. Eventually we should be able to support some\n             // cases here, I imagine (e.g., `for<'a> int : 'a`).\n-            if selcx.tcx().count_late_bound_regions(binder) != 0 {\n-                errors.push(\n-                    FulfillmentError::new(\n-                        obligation.clone(),\n-                        CodeSelectionError(Unimplemented)));\n-            } else {\n-                let ty::OutlivesPredicate(t_a, r_b) = binder.0;\n-                register_region_obligation(t_a, r_b,\n-                                           obligation.cause.clone(),\n-                                           region_obligations);\n+            match selcx.tcx().no_late_bound_regions(binder) {\n+                None => {\n+                    errors.push(\n+                        FulfillmentError::new(\n+                            obligation.clone(),\n+                            CodeSelectionError(Unimplemented)))\n+                }\n+                Some(ty::OutlivesPredicate(t_a, r_b)) => {\n+                    register_region_obligation(t_a, r_b,\n+                                               obligation.cause.clone(),\n+                                               region_obligations);\n+                }\n             }\n             true\n         }\n@@ -501,5 +503,3 @@ impl<'tcx> FulfilledPredicates<'tcx> {\n         !self.set.insert(p.clone())\n     }\n }\n-\n-"}, {"sha": "fe52fba49c6e5459e060f2b8f8c328d69d53da1a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 36, "deletions": 70, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -1713,6 +1713,16 @@ impl Region {\n             _ => false,\n         }\n     }\n+\n+    /// Returns the depth of `self` from the (1-based) binding level `depth`\n+    pub fn from_depth(&self, depth: u32) -> Region {\n+        match *self {\n+            ty::ReLateBound(debruijn, r) => ty::ReLateBound(DebruijnIndex {\n+                depth: debruijn.depth - (depth - 1)\n+            }, r),\n+            r => r\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n@@ -6783,60 +6793,6 @@ pub enum ExplicitSelfCategory {\n     ByBoxExplicitSelfCategory,\n }\n \n-impl<'tcx> TyS<'tcx> {\n-    /// Pushes all the lifetimes in the given type onto the given list. A\n-    /// \"lifetime in a type\" is a lifetime specified by a reference or a lifetime\n-    /// in a list of type substitutions. This does *not* traverse into nominal\n-    /// types, nor does it resolve fictitious types.\n-    pub fn accumulate_lifetimes_in_type(&self, accumulator: &mut Vec<ty::Region>) {\n-        for ty in self.walk() {\n-            match ty.sty {\n-                TyRef(region, _) => {\n-                    accumulator.push(*region)\n-                }\n-                TyTrait(ref t) => {\n-                    accumulator.push_all(t.principal.0.substs.regions().as_slice());\n-                }\n-                TyEnum(_, substs) |\n-                TyStruct(_, substs) => {\n-                    accum_substs(accumulator, substs);\n-                }\n-                TyClosure(_, substs) => {\n-                    accum_substs(accumulator, substs);\n-                }\n-                TyBool |\n-                TyChar |\n-                TyInt(_) |\n-                TyUint(_) |\n-                TyFloat(_) |\n-                TyBox(_) |\n-                TyStr |\n-                TyArray(_, _) |\n-                TySlice(_) |\n-                TyRawPtr(_) |\n-                TyBareFn(..) |\n-                TyTuple(_) |\n-                TyProjection(_) |\n-                TyParam(_) |\n-                TyInfer(_) |\n-                TyError => {\n-                }\n-            }\n-        }\n-\n-        fn accum_substs(accumulator: &mut Vec<Region>, substs: &Substs) {\n-            match substs.regions {\n-                subst::ErasedRegions => {}\n-                subst::NonerasedRegions(ref regions) => {\n-                    for region in regions {\n-                        accumulator.push(*region)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n /// A free variable referred to in a function.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct Freevar {\n@@ -6897,27 +6853,15 @@ impl<'tcx> ctxt<'tcx> {\n             |br| ty::ReFree(ty::FreeRegion{scope: all_outlive_scope, bound_region: br})).0\n     }\n \n-    pub fn count_late_bound_regions<T>(&self, value: &Binder<T>) -> usize\n-        where T : TypeFoldable<'tcx>\n-    {\n-        let (_, skol_map) = ty_fold::replace_late_bound_regions(self, value, |_| ty::ReStatic);\n-        skol_map.len()\n-    }\n-\n-    pub fn binds_late_bound_regions<T>(&self, value: &Binder<T>) -> bool\n-        where T : TypeFoldable<'tcx>\n-    {\n-        self.count_late_bound_regions(value) > 0\n-    }\n-\n     /// Flattens two binding levels into one. So `for<'a> for<'b> Foo`\n     /// becomes `for<'a,'b> Foo`.\n     pub fn flatten_late_bound_regions<T>(&self, bound2_value: &Binder<Binder<T>>)\n                                          -> Binder<T>\n         where T: TypeFoldable<'tcx>\n     {\n         let bound0_value = bound2_value.skip_binder().skip_binder();\n-        let value = ty_fold::fold_regions(self, bound0_value, |region, current_depth| {\n+        let value = ty_fold::fold_regions(self, bound0_value, &mut false,\n+                                          |region, current_depth| {\n             match region {\n                 ty::ReLateBound(debruijn, br) if debruijn.depth >= current_depth => {\n                     // should be true if no escaping regions from bound2_value\n@@ -6933,9 +6877,9 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn no_late_bound_regions<T>(&self, value: &Binder<T>) -> Option<T>\n-        where T : TypeFoldable<'tcx>\n+        where T : TypeFoldable<'tcx> + RegionEscape\n     {\n-        if self.binds_late_bound_regions(value) {\n+        if value.0.has_escaping_regions() {\n             None\n         } else {\n             Some(value.0.clone())\n@@ -7095,6 +7039,19 @@ impl<'tcx> RegionEscape for Substs<'tcx> {\n     }\n }\n \n+impl<T:RegionEscape> RegionEscape for Vec<T> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.iter().any(|t| t.has_regions_escaping_depth(depth))\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for FnSig<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.inputs.has_regions_escaping_depth(depth) ||\n+            self.output.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n impl<'tcx,T:RegionEscape> RegionEscape for VecPerParamSpace<T> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.iter_enumerated().any(|(space, _, t)| {\n@@ -7167,6 +7124,15 @@ impl<'tcx,T:RegionEscape> RegionEscape for Binder<T> {\n     }\n }\n \n+impl<'tcx> RegionEscape for FnOutput<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        match *self {\n+            FnConverging(t) => t.has_regions_escaping_depth(depth),\n+            FnDiverging => false\n+        }\n+    }\n+}\n+\n impl<'tcx> RegionEscape for EquatePredicate<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)"}, {"sha": "284d26b3cd6d773331005b21799490dc0b5b7403", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -44,7 +44,7 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n \n ///////////////////////////////////////////////////////////////////////////\n // Two generic traits\n@@ -783,38 +783,51 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n \n pub struct RegionFolder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n+    skipped_regions: &'a mut bool,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::Region, u32) -> ty::Region + 'a),\n }\n \n impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n-    pub fn new<F>(tcx: &'a ty::ctxt<'tcx>, fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n+    pub fn new<F>(tcx: &'a ty::ctxt<'tcx>,\n+                  skipped_regions: &'a mut bool,\n+                  fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n         where F : FnMut(ty::Region, u32) -> ty::Region\n     {\n         RegionFolder {\n             tcx: tcx,\n+            skipped_regions: skipped_regions,\n             current_depth: 1,\n             fld_r: fld_r,\n         }\n     }\n }\n \n-pub fn collect_regions<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> Vec<ty::Region>\n+/// Collects the free and escaping regions in `value` into `region_set`. Returns\n+/// whether any late-bound regions were skipped\n+pub fn collect_regions<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n+                               value: &T,\n+                               region_set: &mut FnvHashSet<ty::Region>) -> bool\n     where T : TypeFoldable<'tcx>\n {\n-    let mut vec = Vec::new();\n-    fold_regions(tcx, value, |r, _| { vec.push(r); r });\n-    vec\n+    let mut have_bound_regions = false;\n+    fold_regions(tcx, value, &mut have_bound_regions,\n+                 |r, d| { region_set.insert(r.from_depth(d)); r });\n+    have_bound_regions\n }\n \n+/// Folds the escaping and free regions in `value` using `f`, and\n+/// sets `skipped_regions` to true if any late-bound region was found\n+/// and skipped.\n pub fn fold_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n                               value: &T,\n+                              skipped_regions: &mut bool,\n                               mut f: F)\n                               -> T\n     where F : FnMut(ty::Region, u32) -> ty::Region,\n           T : TypeFoldable<'tcx>,\n {\n-    value.fold_with(&mut RegionFolder::new(tcx, &mut f))\n+    value.fold_with(&mut RegionFolder::new(tcx, skipped_regions, &mut f))\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n@@ -834,6 +847,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n             ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n                 debug!(\"RegionFolder.fold_region({:?}) skipped bound region (current depth={})\",\n                        r, self.current_depth);\n+                *self.skipped_regions = true;\n                 r\n             }\n             _ => {\n@@ -989,7 +1003,7 @@ pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"shift_regions(value={:?}, amount={})\",\n            value, amount);\n \n-    value.fold_with(&mut RegionFolder::new(tcx, &mut |region, _current_depth| {\n+    value.fold_with(&mut RegionFolder::new(tcx, &mut false, &mut |region, _current_depth| {\n         shift_region(region, amount)\n     }))\n }"}, {"sha": "3e9a402f9499c15666a731ff5ab58ea7069f8f6e", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n //! An iterator over the type substructure.\n+//! WARNING: this does not keep track of the region depth.\n \n use middle::ty::{self, Ty};\n use std::iter::Iterator;"}, {"sha": "588e4cea5048b599c7615139b761f3c2711211ba", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 13, "deletions": 46, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -199,7 +199,6 @@ pub struct CachedEarlyExit {\n \n pub trait Cleanup<'tcx> {\n     fn must_unwind(&self) -> bool;\n-    fn clean_on_unwind(&self) -> bool;\n     fn is_lifetime_end(&self) -> bool;\n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n@@ -389,7 +388,6 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         if !self.type_needs_drop(ty) { return; }\n         let drop = box DropValue {\n             is_immediate: false,\n-            must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n             fill_on_drop: false,\n@@ -415,7 +413,6 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         let drop = box DropValue {\n             is_immediate: false,\n-            must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n             fill_on_drop: true,\n@@ -447,7 +444,6 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         let drop = box DropValue {\n             is_immediate: false,\n-            must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n             fill_on_drop: false,\n@@ -473,7 +469,6 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         if !self.type_needs_drop(ty) { return; }\n         let drop = box DropValue {\n             is_immediate: true,\n-            must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n             fill_on_drop: false,\n@@ -780,29 +775,19 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         //\n         // At this point, `popped_scopes` is empty, and so the final block\n         // that we return to the user is `Cleanup(AST 24)`.\n-        while !popped_scopes.is_empty() {\n-            let mut scope = popped_scopes.pop().unwrap();\n-\n-            if scope.cleanups.iter().any(|c| cleanup_is_suitable_for(&**c, label))\n-            {\n-                let name = scope.block_name(\"clean\");\n-                debug!(\"generating cleanups for {}\", name);\n-                let bcx_in = self.new_block(label.is_unwind(),\n-                                            &name[..],\n-                                            None);\n-                let mut bcx_out = bcx_in;\n-                for cleanup in scope.cleanups.iter().rev() {\n-                    if cleanup_is_suitable_for(&**cleanup, label) {\n-                        bcx_out = cleanup.trans(bcx_out,\n-                                                scope.debug_loc);\n-                    }\n-                }\n-                build::Br(bcx_out, prev_llbb, DebugLoc::None);\n-                prev_llbb = bcx_in.llbb;\n-            } else {\n-                debug!(\"no suitable cleanups in {}\",\n-                       scope.block_name(\"clean\"));\n+        while let Some(mut scope) = popped_scopes.pop() {\n+            let name = scope.block_name(\"clean\");\n+            debug!(\"generating cleanups for {}\", name);\n+            let bcx_in = self.new_block(label.is_unwind(),\n+                                        &name[..],\n+                                        None);\n+            let mut bcx_out = bcx_in;\n+            for cleanup in scope.cleanups.iter().rev() {\n+                bcx_out = cleanup.trans(bcx_out,\n+                                        scope.debug_loc);\n             }\n+            build::Br(bcx_out, prev_llbb, DebugLoc::None);\n+            prev_llbb = bcx_in.llbb;\n \n             scope.add_cached_early_exit(label, prev_llbb);\n             self.push_scope(scope);\n@@ -1031,7 +1016,6 @@ impl EarlyExitLabel {\n #[derive(Copy, Clone)]\n pub struct DropValue<'tcx> {\n     is_immediate: bool,\n-    must_unwind: bool,\n     val: ValueRef,\n     ty: Ty<'tcx>,\n     fill_on_drop: bool,\n@@ -1040,11 +1024,7 @@ pub struct DropValue<'tcx> {\n \n impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n     fn must_unwind(&self) -> bool {\n-        self.must_unwind\n-    }\n-\n-    fn clean_on_unwind(&self) -> bool {\n-        self.must_unwind\n+        true\n     }\n \n     fn is_lifetime_end(&self) -> bool {\n@@ -1090,10 +1070,6 @@ impl<'tcx> Cleanup<'tcx> for FreeValue<'tcx> {\n         true\n     }\n \n-    fn clean_on_unwind(&self) -> bool {\n-        true\n-    }\n-\n     fn is_lifetime_end(&self) -> bool {\n         false\n     }\n@@ -1123,10 +1099,6 @@ impl<'tcx> Cleanup<'tcx> for LifetimeEnd {\n         false\n     }\n \n-    fn clean_on_unwind(&self) -> bool {\n-        true\n-    }\n-\n     fn is_lifetime_end(&self) -> bool {\n         true\n     }\n@@ -1165,11 +1137,6 @@ pub fn var_scope(tcx: &ty::ctxt,\n     r\n }\n \n-fn cleanup_is_suitable_for(c: &Cleanup,\n-                           label: EarlyExitLabel) -> bool {\n-    !label.is_unwind() || c.clean_on_unwind()\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // These traits just exist to put the methods into this file.\n "}, {"sha": "9c2aea1e67adfda878defeefcd57fe62a184df98", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 44, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -25,7 +25,7 @@ use middle::lang_items::LangItem;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Typer;\n use middle::region;\n-use middle::subst::{self, Subst, Substs};\n+use middle::subst::{self, Substs};\n use trans::base;\n use trans::build;\n use trans::cleanup;\n@@ -54,8 +54,6 @@ use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n-use util::common::memoized;\n-use util::nodemap::FnvHashSet;\n \n pub use trans::context::CrateContext;\n \n@@ -136,47 +134,6 @@ pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-// Some things don't need cleanups during unwinding because the\n-// thread can free them all at once later. Currently only things\n-// that only contain scalars and shared boxes can avoid unwind\n-// cleanups.\n-pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    return memoized(ccx.needs_unwind_cleanup_cache(), ty, |ty| {\n-        type_needs_unwind_cleanup_(ccx.tcx(), ty, &mut FnvHashSet())\n-    });\n-\n-    fn type_needs_unwind_cleanup_<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                        ty: Ty<'tcx>,\n-                                        tycache: &mut FnvHashSet<Ty<'tcx>>)\n-                                        -> bool\n-    {\n-        // Prevent infinite recursion\n-        if !tycache.insert(ty) {\n-            return false;\n-        }\n-\n-        let mut needs_unwind_cleanup = false;\n-        ty.maybe_walk(|ty| {\n-            needs_unwind_cleanup |= match ty.sty {\n-                ty::TyBool | ty::TyInt(_) | ty::TyUint(_) |\n-                ty::TyFloat(_) | ty::TyTuple(_) | ty::TyRawPtr(_) => false,\n-\n-                ty::TyEnum(did, substs) =>\n-                    tcx.enum_variants(did).iter().any(|v|\n-                        v.args.iter().any(|&aty| {\n-                            let t = aty.subst(tcx, substs);\n-                            type_needs_unwind_cleanup_(tcx, t, tycache)\n-                        })\n-                    ),\n-\n-                _ => true\n-            };\n-            !needs_unwind_cleanup\n-        });\n-        needs_unwind_cleanup\n-    }\n-}\n-\n /// If `type_needs_drop` returns true, then `ty` is definitely\n /// non-copy and *might* have a destructor attached; if it returns\n /// false, then `ty` definitely has no destructor (i.e. no drop glue)."}, {"sha": "00b7f420614052ad4aba92b1422506554358d100", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 108, "deletions": 99, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -59,7 +59,8 @@ use middle::traits;\n use middle::ty::{self, RegionEscape, Ty, ToPredicate, HasTypeFlags};\n use middle::ty_fold;\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope, ExplicitRscope,\n-             ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n+             ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope,\n+             ElisionFailureInfo, ElidedLifetime};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::FnvHashSet;\n \n@@ -124,14 +125,14 @@ pub trait AstConv<'tcx> {\n                                         item_name: ast::Name)\n                                         -> Ty<'tcx>\n     {\n-        if self.tcx().binds_late_bound_regions(&poly_trait_ref) {\n+        if let Some(trait_ref) = self.tcx().no_late_bound_regions(&poly_trait_ref) {\n+            self.projected_ty(span, trait_ref, item_name)\n+        } else {\n+            // no late-bound regions, we can just ignore the binder\n             span_err!(self.tcx().sess, span, E0212,\n                 \"cannot extract an associated type from a higher-ranked trait bound \\\n                  in this context\");\n             self.tcx().types.err\n-        } else {\n-            // no late-bound regions, we can just ignore the binder\n-            self.projected_ty(span, poly_trait_ref.0.clone(), item_name)\n         }\n     }\n \n@@ -186,6 +187,58 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n     r\n }\n \n+fn report_elision_failure(\n+    tcx: &ty::ctxt,\n+    default_span: Span,\n+    params: Vec<ElisionFailureInfo>)\n+{\n+    let mut m = String::new();\n+    let len = params.len();\n+    for (i, info) in params.into_iter().enumerate() {\n+        let ElisionFailureInfo {\n+            name, lifetime_count: n, have_bound_regions\n+        } = info;\n+\n+        let help_name = if name.is_empty() {\n+            format!(\"argument {}\", i + 1)\n+        } else {\n+            format!(\"`{}`\", name)\n+        };\n+\n+        m.push_str(&(if n == 1 {\n+            help_name\n+        } else {\n+            format!(\"one of {}'s {} elided {}lifetimes\", help_name, n,\n+                    if have_bound_regions { \"free \" } else { \"\" } )\n+        })[..]);\n+\n+        if len == 2 && i == 0 {\n+            m.push_str(\" or \");\n+        } else if i + 2 == len {\n+            m.push_str(\", or \");\n+        } else if i + 1 != len {\n+            m.push_str(\", \");\n+        }\n+    }\n+    if len == 1 {\n+        fileline_help!(tcx.sess, default_span,\n+                       \"this function's return type contains a borrowed value, but \\\n+                        the signature does not say which {} it is borrowed from\",\n+                       m);\n+    } else if len == 0 {\n+        fileline_help!(tcx.sess, default_span,\n+                       \"this function's return type contains a borrowed value, but \\\n+                        there is no value for it to be borrowed from\");\n+        fileline_help!(tcx.sess, default_span,\n+                       \"consider giving it a 'static lifetime\");\n+    } else {\n+        fileline_help!(tcx.sess, default_span,\n+                       \"this function's return type contains a borrowed value, but \\\n+                        the signature does not say whether it is borrowed from {}\",\n+                       m);\n+    }\n+}\n+\n pub fn opt_ast_region_to_region<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n@@ -197,61 +250,15 @@ pub fn opt_ast_region_to_region<'tcx>(\n             ast_region_to_region(this.tcx(), lifetime)\n         }\n \n-        None => {\n-            match rscope.anon_regions(default_span, 1) {\n-                Err(v) => {\n-                    debug!(\"optional region in illegal location\");\n-                    span_err!(this.tcx().sess, default_span, E0106,\n-                        \"missing lifetime specifier\");\n-                    match v {\n-                        Some(v) => {\n-                            let mut m = String::new();\n-                            let len = v.len();\n-                            for (i, (name, n)) in v.into_iter().enumerate() {\n-                                let help_name = if name.is_empty() {\n-                                    format!(\"argument {}\", i + 1)\n-                                } else {\n-                                    format!(\"`{}`\", name)\n-                                };\n-\n-                                m.push_str(&(if n == 1 {\n-                                    help_name\n-                                } else {\n-                                    format!(\"one of {}'s {} elided lifetimes\", help_name, n)\n-                                })[..]);\n-\n-                                if len == 2 && i == 0 {\n-                                    m.push_str(\" or \");\n-                                } else if i + 2 == len {\n-                                    m.push_str(\", or \");\n-                                } else if i + 1 != len {\n-                                    m.push_str(\", \");\n-                                }\n-                            }\n-                            if len == 1 {\n-                                fileline_help!(this.tcx().sess, default_span,\n-                                    \"this function's return type contains a borrowed value, but \\\n-                                     the signature does not say which {} it is borrowed from\",\n-                                    m);\n-                            } else if len == 0 {\n-                                fileline_help!(this.tcx().sess, default_span,\n-                                    \"this function's return type contains a borrowed value, but \\\n-                                     there is no value for it to be borrowed from\");\n-                                fileline_help!(this.tcx().sess, default_span,\n-                                    \"consider giving it a 'static lifetime\");\n-                            } else {\n-                                fileline_help!(this.tcx().sess, default_span,\n-                                    \"this function's return type contains a borrowed value, but \\\n-                                     the signature does not say whether it is borrowed from {}\",\n-                                    m);\n-                            }\n-                        }\n-                        None => {},\n-                    }\n-                    ty::ReStatic\n+        None => match rscope.anon_regions(default_span, 1) {\n+            Ok(rs) => rs[0],\n+            Err(params) => {\n+                span_err!(this.tcx().sess, default_span, E0106,\n+                          \"missing lifetime specifier\");\n+                if let Some(params) = params {\n+                    report_elision_failure(this.tcx(), default_span, params);\n                 }\n-\n-                Ok(rs) => rs[0],\n+                ty::ReStatic\n             }\n         }\n     };\n@@ -505,48 +512,54 @@ fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n /// Returns the appropriate lifetime to use for any output lifetimes\n /// (if one exists) and a vector of the (pattern, number of lifetimes)\n /// corresponding to each input type/pattern.\n-fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n-                              -> (Option<ty::Region>, Vec<(String, usize)>)\n+fn find_implied_output_region<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                    input_tys: &[Ty<'tcx>],\n+                                    input_pats: Vec<String>) -> ElidedLifetime\n {\n-    let mut lifetimes_for_params: Vec<(String, usize)> = Vec::new();\n+    let mut lifetimes_for_params = Vec::new();\n     let mut possible_implied_output_region = None;\n \n     for (input_type, input_pat) in input_tys.iter().zip(input_pats) {\n-        let mut accumulator = Vec::new();\n-        input_type.accumulate_lifetimes_in_type(&mut accumulator);\n+        let mut regions = FnvHashSet();\n+        let have_bound_regions = ty_fold::collect_regions(tcx,\n+                                                          input_type,\n+                                                          &mut regions);\n+\n+        debug!(\"find_implied_output_regions: collected {:?} from {:?} \\\n+                have_bound_regions={:?}\", &regions, input_type, have_bound_regions);\n \n-        if accumulator.len() == 1 {\n+        if regions.len() == 1 {\n             // there's a chance that the unique lifetime of this\n             // iteration will be the appropriate lifetime for output\n             // parameters, so lets store it.\n-            possible_implied_output_region = Some(accumulator[0])\n+            possible_implied_output_region = regions.iter().cloned().next();\n         }\n \n-        lifetimes_for_params.push((input_pat, accumulator.len()));\n+        lifetimes_for_params.push(ElisionFailureInfo {\n+            name: input_pat,\n+            lifetime_count: regions.len(),\n+            have_bound_regions: have_bound_regions\n+        });\n     }\n \n-    let implied_output_region =\n-        if lifetimes_for_params.iter().map(|&(_, n)| n).sum::<usize>() == 1 {\n-            assert!(possible_implied_output_region.is_some());\n-            possible_implied_output_region\n-        } else {\n-            None\n-        };\n-    (implied_output_region, lifetimes_for_params)\n+    if lifetimes_for_params.iter().map(|e| e.lifetime_count).sum::<usize>() == 1 {\n+        Ok(possible_implied_output_region.unwrap())\n+    } else {\n+        Err(Some(lifetimes_for_params))\n+    }\n }\n \n fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n-                                          implied_output_region: Option<ty::Region>,\n-                                          param_lifetimes: Vec<(String, usize)>,\n+                                          elided_lifetime: ElidedLifetime,\n                                           ty: &ast::Ty)\n                                           -> Ty<'tcx>\n {\n-    match implied_output_region {\n-        Some(implied_output_region) => {\n+    match elided_lifetime {\n+        Ok(implied_output_region) => {\n             let rb = ElidableRscope::new(implied_output_region);\n             ast_ty_to_ty(this, &rb, ty)\n         }\n-        None => {\n+        Err(param_lifetimes) => {\n             // All regions must be explicitly specified in the output\n             // if the lifetime elision rules do not apply. This saves\n             // the user from potentially-confusing errors.\n@@ -576,17 +589,15 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n                    .collect::<Vec<Ty<'tcx>>>();\n \n     let input_params: Vec<_> = repeat(String::new()).take(inputs.len()).collect();\n-    let (implied_output_region,\n-         params_lifetimes) = find_implied_output_region(&*inputs, input_params);\n+    let implied_output_region = find_implied_output_region(this.tcx(), &inputs, input_params);\n \n     let input_ty = this.tcx().mk_tup(inputs);\n \n     let (output, output_span) = match data.output {\n         Some(ref output_ty) => {\n             (convert_ty_with_lifetime_elision(this,\n                                               implied_output_region,\n-                                              params_lifetimes,\n-                                              &**output_ty),\n+                                              &output_ty),\n              output_ty.span)\n         }\n         None => {\n@@ -1705,7 +1716,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     // here), if self is by-reference, then the implied output region is the\n     // region of the self parameter.\n     let mut explicit_self_category_result = None;\n-    let (self_ty, mut implied_output_region) = match opt_self_info {\n+    let (self_ty, implied_output_region) = match opt_self_info {\n         None => (None, None),\n         Some(self_info) => {\n             // This type comes from an impl or trait; no late-bound\n@@ -1756,19 +1767,18 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     // Second, if there was exactly one lifetime (either a substitution or a\n     // reference) in the arguments, then any anonymous regions in the output\n     // have that lifetime.\n-    let lifetimes_for_params = if implied_output_region.is_none() {\n-        let input_tys = if self_ty.is_some() {\n-            // Skip the first argument if `self` is present.\n-            &self_and_input_tys[1..]\n-        } else {\n-            &self_and_input_tys[..]\n-        };\n+    let implied_output_region = match implied_output_region {\n+        Some(r) => Ok(r),\n+        None => {\n+            let input_tys = if self_ty.is_some() {\n+                // Skip the first argument if `self` is present.\n+                &self_and_input_tys[1..]\n+            } else {\n+                &self_and_input_tys[..]\n+            };\n \n-        let (ior, lfp) = find_implied_output_region(input_tys, input_pats);\n-        implied_output_region = ior;\n-        lfp\n-    } else {\n-        vec![]\n+            find_implied_output_region(this.tcx(), input_tys, input_pats)\n+        }\n     };\n \n     let output_ty = match decl.output {\n@@ -1777,8 +1787,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n         ast::Return(ref output) =>\n             ty::FnConverging(convert_ty_with_lifetime_elision(this,\n                                                               implied_output_region,\n-                                                              lifetimes_for_params,\n-                                                              &**output)),\n+                                                              &output)),\n         ast::DefaultReturn(..) => ty::FnConverging(this.tcx().mk_nil()),\n         ast::NoReturn(..) => ty::FnDiverging\n     };"}, {"sha": "2db1598db4bee02fb758a85e544e21163f6230e5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -97,7 +97,7 @@ use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasTypeFlags, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::{MethodCall, MethodCallee};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n-use rscope::RegionScope;\n+use rscope::{ElisionFailureInfo, RegionScope};\n use session::Session;\n use {CrateCtxt, lookup_full_def, require_same_types};\n use TypeAndSubsts;\n@@ -1796,7 +1796,7 @@ impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n     }\n \n     fn anon_regions(&self, span: Span, count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n         Ok((0..count).map(|_| {\n             self.infcx().next_region_var(infer::MiscVariable(span))\n         }).collect())"}, {"sha": "7909908079fb38ca1938887dc0cffc643605870e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -1860,6 +1860,29 @@ fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     result\n }\n \n+fn convert_default_type_parameter<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                            path: &P<ast::Ty>,\n+                                            space: ParamSpace,\n+                                            index: u32)\n+                                            -> Ty<'tcx>\n+{\n+    let ty = ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, &path);\n+\n+    for leaf_ty in ty.walk() {\n+        if let ty::TyParam(p) = leaf_ty.sty {\n+            if p.space == space && p.idx >= index {\n+                span_err!(ccx.tcx.sess, path.span, E0128,\n+                          \"type parameters with a default cannot use \\\n+                           forward declared identifiers\");\n+\n+                return ccx.tcx.types.err\n+            }\n+        }\n+    }\n+\n+    ty\n+}\n+\n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                              ast_generics: &ast::Generics,\n                                              space: ParamSpace,\n@@ -1874,25 +1897,9 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         None => { }\n     }\n \n-    let default = match param.default {\n-        None => None,\n-        Some(ref path) => {\n-            let ty = ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, &**path);\n-            let cur_idx = index;\n-\n-            for leaf_ty in ty.walk() {\n-                if let ty::TyParam(p) = leaf_ty.sty {\n-                    if p.idx > cur_idx {\n-                        span_err!(tcx.sess, path.span, E0128,\n-                                  \"type parameters with a default cannot use \\\n-                                   forward declared identifiers\");\n-                    }\n-                }\n-            }\n-\n-            Some(ty)\n-        }\n-    };\n+    let default = param.default.as_ref().map(\n+        |def| convert_default_type_parameter(ccx, def, space, index)\n+    );\n \n     let object_lifetime_default =\n         compute_object_lifetime_default(ccx, param.id,\n@@ -2241,7 +2248,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n          * before we really have a `ParameterEnvironment` to check.\n          */\n \n-        ty_fold::fold_regions(tcx, value, |region, _| {\n+        ty_fold::fold_regions(tcx, value, &mut false, |region, _| {\n             match region {\n                 ty::ReEarlyBound(data) => {\n                     let def_id = local_def(data.param_id);"}, {"sha": "b416026ba01340d7bc5f71b32b2e5b5c9c61a270", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -16,6 +16,15 @@ use std::cell::Cell;\n use std::iter::repeat;\n use syntax::codemap::Span;\n \n+#[derive(Clone)]\n+pub struct ElisionFailureInfo {\n+    pub name: String,\n+    pub lifetime_count: usize,\n+    pub have_bound_regions: bool\n+}\n+\n+pub type ElidedLifetime = Result<ty::Region, Option<Vec<ElisionFailureInfo>>>;\n+\n /// Defines strategies for handling regions that are omitted.  For\n /// example, if one writes the type `&Foo`, then the lifetime of\n /// this reference has been omitted. When converting this\n@@ -30,7 +39,7 @@ pub trait RegionScope {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>;\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>;\n \n     /// If an object omits any explicit lifetime bound, and none can\n     /// be derived from the object traits, what should we use? If\n@@ -51,16 +60,16 @@ impl RegionScope for ExplicitRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n         Err(None)\n     }\n }\n \n // Same as `ExplicitRscope`, but provides some extra information for diagnostics\n-pub struct UnelidableRscope(Vec<(String, usize)>);\n+pub struct UnelidableRscope(Option<Vec<ElisionFailureInfo>>);\n \n impl UnelidableRscope {\n-    pub fn new(v: Vec<(String, usize)>) -> UnelidableRscope {\n+    pub fn new(v: Option<Vec<ElisionFailureInfo>>) -> UnelidableRscope {\n         UnelidableRscope(v)\n     }\n }\n@@ -73,9 +82,9 @@ impl RegionScope for UnelidableRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n         let UnelidableRscope(ref v) = *self;\n-        Err(Some(v.clone()))\n+        Err(v.clone())\n     }\n }\n \n@@ -104,7 +113,7 @@ impl RegionScope for ElidableRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n     {\n         Ok(repeat(self.default).take(count).collect())\n     }\n@@ -141,7 +150,7 @@ impl RegionScope for BindingRscope {\n     fn anon_regions(&self,\n                     _: Span,\n                     count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n     {\n         Ok((0..count).map(|_| self.next_region()).collect())\n     }\n@@ -177,7 +186,7 @@ impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n     {\n         self.base_scope.anon_regions(span, count)\n     }\n@@ -204,7 +213,7 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n     {\n         match self.base_scope.anon_regions(span, count) {\n             Ok(mut v) => {"}, {"sha": "e6f3a2bdd33ad127a14960d350de8bba749b62af", "filename": "src/test/compile-fail/issue-18183.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Ftest%2Fcompile-fail%2Fissue-18183.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Ftest%2Fcompile-fail%2Fissue-18183.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18183.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Foo<Bar=Bar>; //~ ERROR E0128\n+pub struct Baz(Foo);\n+fn main() {}"}, {"sha": "edb9ab47fc611c0a656d560846b2c556a4927fb3", "filename": "src/test/compile-fail/issue-26638.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn parse_type(iter: Box<Iterator<Item=&str>+'static>) -> &str { iter.next() }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ HELP 2 elided lifetimes\n+\n+fn parse_type_2(iter: fn(&u8)->&u8) -> &str { iter() }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ HELP 0 elided free lifetimes\n+\n+fn main() {}"}, {"sha": "bdd3a80d74cf4a4da7409d6f7fb5e15df398956e", "filename": "src/test/run-pass/issue-26655.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Ftest%2Frun-pass%2Fissue-26655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf/src%2Ftest%2Frun-pass%2Fissue-26655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-26655.rs?ref=27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+\n+// Check that the destructors of simple enums are run on unwinding\n+\n+use std::sync::atomic::{Ordering, AtomicUsize};\n+use std::thread;\n+\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n+\n+enum WithDtor { Val }\n+impl Drop for WithDtor {\n+    fn drop(&mut self) {\n+        LOG.store(LOG.load(Ordering::SeqCst)+1,Ordering::SeqCst);\n+    }\n+}\n+\n+pub fn main() {\n+    thread::spawn(move|| {\n+        let _e: WithDtor = WithDtor::Val;\n+        panic!(\"fail\");\n+    }).join().unwrap_err();\n+\n+    assert_eq!(LOG.load(Ordering::SeqCst), 1);\n+}"}]}