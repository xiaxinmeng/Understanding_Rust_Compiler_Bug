{"sha": "07266362c6b29139dc09ecd4b963722690eaa31f", "node_id": "C_kwDOAAsO6NoAKDA3MjY2MzYyYzZiMjkxMzlkYzA5ZWNkNGI5NjM3MjI2OTBlYWEzMWY", "commit": {"author": {"name": "klensy", "email": "klensy@users.noreply.github.com", "date": "2023-04-29T11:17:37Z"}, "committer": {"name": "klensy", "email": "klensy@users.noreply.github.com", "date": "2023-04-30T10:24:10Z"}, "message": "Lrc -> Rc", "tree": {"sha": "942105ebd80e08fe85a3d8187360c447e18f73a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/942105ebd80e08fe85a3d8187360c447e18f73a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07266362c6b29139dc09ecd4b963722690eaa31f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07266362c6b29139dc09ecd4b963722690eaa31f", "html_url": "https://github.com/rust-lang/rust/commit/07266362c6b29139dc09ecd4b963722690eaa31f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07266362c6b29139dc09ecd4b963722690eaa31f/comments", "author": {"login": "klensy", "id": 1782831, "node_id": "MDQ6VXNlcjE3ODI4MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1782831?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klensy", "html_url": "https://github.com/klensy", "followers_url": "https://api.github.com/users/klensy/followers", "following_url": "https://api.github.com/users/klensy/following{/other_user}", "gists_url": "https://api.github.com/users/klensy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klensy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klensy/subscriptions", "organizations_url": "https://api.github.com/users/klensy/orgs", "repos_url": "https://api.github.com/users/klensy/repos", "events_url": "https://api.github.com/users/klensy/events{/privacy}", "received_events_url": "https://api.github.com/users/klensy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "klensy", "id": 1782831, "node_id": "MDQ6VXNlcjE3ODI4MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1782831?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klensy", "html_url": "https://github.com/klensy", "followers_url": "https://api.github.com/users/klensy/followers", "following_url": "https://api.github.com/users/klensy/following{/other_user}", "gists_url": "https://api.github.com/users/klensy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klensy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klensy/subscriptions", "organizations_url": "https://api.github.com/users/klensy/orgs", "repos_url": "https://api.github.com/users/klensy/repos", "events_url": "https://api.github.com/users/klensy/events{/privacy}", "received_events_url": "https://api.github.com/users/klensy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "597c6514d142886f807cfcfd04291b464bb43787", "url": "https://api.github.com/repos/rust-lang/rust/commits/597c6514d142886f807cfcfd04291b464bb43787", "html_url": "https://github.com/rust-lang/rust/commit/597c6514d142886f807cfcfd04291b464bb43787"}], "stats": {"total": 25, "additions": 13, "deletions": 12}, "files": [{"sha": "fe56bd54a3f17450209691fef5c5b28f81115832", "filename": "compiler/rustc_borrowck/src/region_infer/reverse_sccs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07266362c6b29139dc09ecd4b963722690eaa31f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07266362c6b29139dc09ecd4b963722690eaa31f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs?ref=07266362c6b29139dc09ecd4b963722690eaa31f", "patch": "@@ -41,7 +41,7 @@ impl ReverseSccGraph {\n impl RegionInferenceContext<'_> {\n     /// Compute the reverse SCC-based constraint graph (lazily).\n     pub(super) fn compute_reverse_scc_graph(&mut self) {\n-        if matches!(self.rev_scc_graph, Some(_)) {\n+        if self.rev_scc_graph.is_some() {\n             return;\n         }\n "}, {"sha": "1c222fb4a898c8761fee20a0769b78a09e4fe532", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/07266362c6b29139dc09ecd4b963722690eaa31f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07266362c6b29139dc09ecd4b963722690eaa31f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=07266362c6b29139dc09ecd4b963722690eaa31f", "patch": "@@ -88,6 +88,7 @@ use rustc_span::Span;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::fmt::Display;\n+use std::rc::Rc;\n \n /// A unit within a matcher that a `MatcherPos` can refer to. Similar to (and derived from)\n /// `mbe::TokenTree`, but designed specifically for fast and easy traversal during matching.\n@@ -257,10 +258,10 @@ struct MatcherPos {\n     /// against the relevant metavar by the black box parser. An element will be a `MatchedSeq` if\n     /// the corresponding metavar decl is within a sequence.\n     ///\n-    /// It is critical to performance that this is an `Lrc`, because it gets cloned frequently when\n+    /// It is critical to performance that this is an `Rc`, because it gets cloned frequently when\n     /// processing sequences. Mostly for sequence-ending possibilities that must be tried but end\n     /// up failing.\n-    matches: Lrc<Vec<NamedMatch>>,\n+    matches: Rc<Vec<NamedMatch>>,\n }\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -272,7 +273,7 @@ impl MatcherPos {\n     /// and both are hot enough to be always worth inlining.\n     #[inline(always)]\n     fn push_match(&mut self, metavar_idx: usize, seq_depth: usize, m: NamedMatch) {\n-        let matches = Lrc::make_mut(&mut self.matches);\n+        let matches = Rc::make_mut(&mut self.matches);\n         match seq_depth {\n             0 => {\n                 // We are not within a sequence. Just append `m`.\n@@ -427,7 +428,7 @@ pub struct TtParser {\n \n     /// Pre-allocate an empty match array, so it can be cloned cheaply for macros with many rules\n     /// that have no metavars.\n-    empty_matches: Lrc<Vec<NamedMatch>>,\n+    empty_matches: Rc<Vec<NamedMatch>>,\n }\n \n impl TtParser {\n@@ -437,7 +438,7 @@ impl TtParser {\n             cur_mps: vec![],\n             next_mps: vec![],\n             bb_mps: vec![],\n-            empty_matches: Lrc::new(vec![]),\n+            empty_matches: Rc::new(vec![]),\n         }\n     }\n \n@@ -507,7 +508,7 @@ impl TtParser {\n                         // Try zero matches of this sequence, by skipping over it.\n                         self.cur_mps.push(MatcherPos {\n                             idx: idx_first_after,\n-                            matches: Lrc::clone(&mp.matches),\n+                            matches: Rc::clone(&mp.matches),\n                         });\n                     }\n \n@@ -521,7 +522,7 @@ impl TtParser {\n                     // processed next time around the loop.\n                     let ending_mp = MatcherPos {\n                         idx: mp.idx + 1, // +1 skips the Kleene op\n-                        matches: Lrc::clone(&mp.matches),\n+                        matches: Rc::clone(&mp.matches),\n                     };\n                     self.cur_mps.push(ending_mp);\n \n@@ -537,7 +538,7 @@ impl TtParser {\n                     // will fail quietly when it is processed next time around the loop.\n                     let ending_mp = MatcherPos {\n                         idx: mp.idx + 2, // +2 skips the separator and the Kleene op\n-                        matches: Lrc::clone(&mp.matches),\n+                        matches: Rc::clone(&mp.matches),\n                     };\n                     self.cur_mps.push(ending_mp);\n \n@@ -587,9 +588,9 @@ impl TtParser {\n         if *token == token::Eof {\n             Some(match eof_mps {\n                 EofMatcherPositions::One(mut eof_mp) => {\n-                    // Need to take ownership of the matches from within the `Lrc`.\n-                    Lrc::make_mut(&mut eof_mp.matches);\n-                    let matches = Lrc::try_unwrap(eof_mp.matches).unwrap().into_iter();\n+                    // Need to take ownership of the matches from within the `Rc`.\n+                    Rc::make_mut(&mut eof_mp.matches);\n+                    let matches = Rc::try_unwrap(eof_mp.matches).unwrap().into_iter();\n                     self.nameize(matcher, matches)\n                 }\n                 EofMatcherPositions::Multiple => {"}]}