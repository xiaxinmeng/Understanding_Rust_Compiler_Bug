{"sha": "206fe8e1c37d55d0bf3a82baaa23eb5fb148880b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNmZlOGUxYzM3ZDU1ZDBiZjNhODJiYWFhMjNlYjVmYjE0ODg4MGI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-04T10:16:36Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-04T12:13:29Z"}, "message": "flatten rustc_lexer::character_properties module\n\nOn the call site, `rustc_lexer::is_whitespace` reads much better than\n`character_properties::is_whitespace`.", "tree": {"sha": "8c28c6c20f95b14866a5ae725781555030cf7670", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c28c6c20f95b14866a5ae725781555030cf7670"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b", "html_url": "https://github.com/rust-lang/rust/commit/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0c186c34f67c7eb3b392755091dd3a17f5acbdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0c186c34f67c7eb3b392755091dd3a17f5acbdf", "html_url": "https://github.com/rust-lang/rust/commit/a0c186c34f67c7eb3b392755091dd3a17f5acbdf"}], "stats": {"total": 168, "additions": 82, "deletions": 86}, "files": [{"sha": "f9c1be20b8bc132aed7ac28364713e714427a797", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=206fe8e1c37d55d0bf3a82baaa23eb5fb148880b", "patch": "@@ -23,7 +23,6 @@ use std::string;\n use std::iter;\n \n use syntax_pos::{InnerSpan, Symbol};\n-use rustc_lexer::character_properties::{is_id_start, is_id_continue};\n \n #[derive(Copy, Clone)]\n struct InnerOffset(usize);\n@@ -602,7 +601,7 @@ impl<'a> Parser<'a> {\n     /// Rust identifier, except that it can't start with `_` character.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.peek() {\n-            Some(&(pos, c)) if c != '_' && is_id_start(c) => {\n+            Some(&(pos, c)) if c != '_' && rustc_lexer::is_id_start(c) => {\n                 self.cur.next();\n                 pos\n             }\n@@ -611,7 +610,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n         while let Some(&(pos, c)) = self.cur.peek() {\n-            if is_id_continue(c) {\n+            if rustc_lexer::is_id_continue(c) {\n                 self.cur.next();\n             } else {\n                 return &self.input[start..pos];"}, {"sha": "30a5175d8cdb092d59dc19e16080f48e15df19f9", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 70, "deletions": 65, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=206fe8e1c37d55d0bf3a82baaa23eb5fb148880b", "patch": "@@ -102,6 +102,62 @@ pub fn tokenize(mut input: &str) -> impl Iterator<Item = Token> + '_ {\n     })\n }\n \n+// See [UAX #31](http://unicode.org/reports/tr31) for definitions of these\n+// classes.\n+\n+/// True if `c` is considered a whitespace according to Rust language definition.\n+pub fn is_whitespace(c: char) -> bool {\n+    // This is Pattern_White_Space.\n+    //\n+    // Note that this set is stable (ie, it doesn't change with different\n+    // Unicode versions), so it's ok to just hard-code the values.\n+\n+    match c {\n+        // Usual ASCII suspects\n+        | '\\u{0009}' // \\t\n+        | '\\u{000A}' // \\n\n+        | '\\u{000B}' // vertical tab\n+        | '\\u{000C}' // form feed\n+        | '\\u{000D}' // \\r\n+        | '\\u{0020}' // space\n+\n+        // NEXT LINE from latin1\n+        | '\\u{0085}'\n+\n+        // Bidi markers\n+        | '\\u{200E}' // LEFT-TO-RIGHT MARK\n+        | '\\u{200F}' // RIGHT-TO-LEFT MARK\n+\n+        // Dedicated whitespace characters from Unicode\n+        | '\\u{2028}' // LINE SEPARATOR\n+        | '\\u{2029}' // PARAGRAPH SEPARATOR\n+            => true,\n+        _ => false,\n+    }\n+}\n+\n+/// True if `c` is valid as a first character of an identifier.\n+pub fn is_id_start(c: char) -> bool {\n+    // This is XID_Start OR '_' (which formally is not a XID_Start).\n+    // We also add fast-path for ascii idents\n+    ('a' <= c && c <= 'z')\n+        || ('A' <= c && c <= 'Z')\n+        || c == '_'\n+        || (c > '\\x7f' && unicode_xid::UnicodeXID::is_xid_start(c))\n+}\n+\n+/// True if `c` is valid as a non-first character of an identifier.\n+pub fn is_id_continue(c: char) -> bool {\n+    // This is exactly XID_Continue.\n+    // We also add fast-path for ascii idents\n+    ('a' <= c && c <= 'z')\n+        || ('A' <= c && c <= 'Z')\n+        || ('0' <= c && c <= '9')\n+        || c == '_'\n+        || (c > '\\x7f' && unicode_xid::UnicodeXID::is_xid_continue(c))\n+}\n+\n+\n impl Cursor<'_> {\n     fn advance_token(&mut self) -> Token {\n         let first_char = self.bump().unwrap();\n@@ -111,9 +167,9 @@ impl Cursor<'_> {\n                 '*' => self.block_comment(),\n                 _ => Slash,\n             },\n-            c if character_properties::is_whitespace(c) => self.whitespace(),\n+            c if is_whitespace(c) => self.whitespace(),\n             'r' => match (self.nth_char(0), self.nth_char(1)) {\n-                ('#', c1) if character_properties::is_id_start(c1) => self.raw_ident(),\n+                ('#', c1) if is_id_start(c1) => self.raw_ident(),\n                 ('#', _) | ('\"', _) => {\n                     let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n                     let suffix_start = self.len_consumed();\n@@ -158,7 +214,7 @@ impl Cursor<'_> {\n                 }\n                 _ => self.ident(),\n             },\n-            c if character_properties::is_id_start(c) => self.ident(),\n+            c if is_id_start(c) => self.ident(),\n             c @ '0'..='9' => {\n                 let literal_kind = self.number(c);\n                 let suffix_start = self.len_consumed();\n@@ -246,8 +302,8 @@ impl Cursor<'_> {\n     }\n \n     fn whitespace(&mut self) -> TokenKind {\n-        debug_assert!(character_properties::is_whitespace(self.prev()));\n-        while character_properties::is_whitespace(self.nth_char(0)) {\n+        debug_assert!(is_whitespace(self.prev()));\n+        while is_whitespace(self.nth_char(0)) {\n             self.bump();\n         }\n         Whitespace\n@@ -257,19 +313,19 @@ impl Cursor<'_> {\n         debug_assert!(\n             self.prev() == 'r'\n                 && self.nth_char(0) == '#'\n-                && character_properties::is_id_start(self.nth_char(1))\n+                && is_id_start(self.nth_char(1))\n         );\n         self.bump();\n         self.bump();\n-        while character_properties::is_id_continue(self.nth_char(0)) {\n+        while is_id_continue(self.nth_char(0)) {\n             self.bump();\n         }\n         RawIdent\n     }\n \n     fn ident(&mut self) -> TokenKind {\n-        debug_assert!(character_properties::is_id_start(self.prev()));\n-        while character_properties::is_id_continue(self.nth_char(0)) {\n+        debug_assert!(is_id_start(self.prev()));\n+        while is_id_continue(self.nth_char(0)) {\n             self.bump();\n         }\n         Ident\n@@ -314,7 +370,7 @@ impl Cursor<'_> {\n             // integer literal followed by field/method access or a range pattern\n             // (`0..2` and `12.foo()`)\n             '.' if self.nth_char(1) != '.'\n-                && !character_properties::is_id_start(self.nth_char(1)) =>\n+                && !is_id_start(self.nth_char(1)) =>\n             {\n                 // might have stuff after the ., and if it does, it needs to start\n                 // with a number\n@@ -344,15 +400,15 @@ impl Cursor<'_> {\n     fn lifetime_or_char(&mut self) -> TokenKind {\n         debug_assert!(self.prev() == '\\'');\n         let mut starts_with_number = false;\n-        if (character_properties::is_id_start(self.nth_char(0))\n+        if (is_id_start(self.nth_char(0))\n             || self.nth_char(0).is_digit(10) && {\n                 starts_with_number = true;\n                 true\n             })\n             && self.nth_char(1) != '\\''\n         {\n             self.bump();\n-            while character_properties::is_id_continue(self.nth_char(0)) {\n+            while is_id_continue(self.nth_char(0)) {\n                 self.bump();\n             }\n \n@@ -494,64 +550,13 @@ impl Cursor<'_> {\n     }\n \n     fn eat_literal_suffix(&mut self) {\n-        if !character_properties::is_id_start(self.nth_char(0)) {\n+        if !is_id_start(self.nth_char(0)) {\n             return;\n         }\n         self.bump();\n \n-        while character_properties::is_id_continue(self.nth_char(0)) {\n+        while is_id_continue(self.nth_char(0)) {\n             self.bump();\n         }\n     }\n }\n-\n-pub mod character_properties {\n-    // See [UAX #31](http://unicode.org/reports/tr31) for definitions of these\n-    // classes.\n-\n-    // This is Pattern_White_Space.\n-    //\n-    // Note that this set is stable (ie, it doesn't change with different\n-    // Unicode versions), so it's ok to just hard-code the values.\n-    pub fn is_whitespace(c: char) -> bool {\n-        match c {\n-            // Usual ASCII suspects\n-            | '\\u{0009}' // \\t\n-            | '\\u{000A}' // \\n\n-            | '\\u{000B}' // vertical tab\n-            | '\\u{000C}' // form feed\n-            | '\\u{000D}' // \\r\n-            | '\\u{0020}' // space\n-\n-            // NEXT LINE from latin1\n-            | '\\u{0085}'\n-\n-            // Bidi markers\n-            | '\\u{200E}' // LEFT-TO-RIGHT MARK\n-            | '\\u{200F}' // RIGHT-TO-LEFT MARK\n-\n-            // Dedicated whitespace characters from Unicode\n-            | '\\u{2028}' // LINE SEPARATOR\n-            | '\\u{2029}' // PARAGRAPH SEPARATOR\n-              => true,\n-            _ => false,\n-        }\n-    }\n-\n-    // This is XID_Start OR '_' (which formally is not a XID_Start).\n-    pub fn is_id_start(c: char) -> bool {\n-        ('a' <= c && c <= 'z')\n-            || ('A' <= c && c <= 'Z')\n-            || c == '_'\n-            || (c > '\\x7f' && unicode_xid::UnicodeXID::is_xid_start(c))\n-    }\n-\n-    // This is XID_Continue.\n-    pub fn is_id_continue(c: char) -> bool {\n-        ('a' <= c && c <= 'z')\n-            || ('A' <= c && c <= 'Z')\n-            || ('0' <= c && c <= '9')\n-            || c == '_'\n-            || (c > '\\x7f' && unicode_xid::UnicodeXID::is_xid_continue(c))\n-    }\n-}"}, {"sha": "0d13db2f5a413a9d0b9084bff7d0727e4ebabebd", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=206fe8e1c37d55d0bf3a82baaa23eb5fb148880b", "patch": "@@ -1,7 +1,6 @@\n use rustc::mir::*;\n use rustc::ty;\n use rustc_errors::{DiagnosticBuilder,Applicability};\n-use rustc_lexer::character_properties::is_whitespace;\n use syntax_pos::Span;\n \n use crate::borrow_check::MirBorrowckCtxt;\n@@ -525,7 +524,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         let suggestion;\n                         let to_remove;\n                         if pat_snippet.starts_with(\"mut\")\n-                            && pat_snippet[\"mut\".len()..].starts_with(is_whitespace)\n+                            && pat_snippet[\"mut\".len()..].starts_with(rustc_lexer::is_whitespace)\n                         {\n                             suggestion = pat_snippet[\"mut\".len()..].trim_start();\n                             to_remove = \"&mut\";"}, {"sha": "8f2ce80aafa22de5ec997a495a963933c8464e4f", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=206fe8e1c37d55d0bf3a82baaa23eb5fb148880b", "patch": "@@ -1,4 +1,3 @@\n-use rustc_lexer::character_properties::is_whitespace;\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Body};\n@@ -715,7 +714,7 @@ fn annotate_struct_field(\n fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<String> {\n     let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).ok()?;\n     if hi_src.starts_with(\"ref\")\n-        && hi_src[\"ref\".len()..].starts_with(is_whitespace)\n+        && hi_src[\"ref\".len()..].starts_with(rustc_lexer::is_whitespace)\n     {\n         let replacement = format!(\"ref mut{}\", &hi_src[\"ref\".len()..]);\n         Some(replacement)"}, {"sha": "000d2843adce396917c80f7b4f7f3efd66c92f36", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=206fe8e1c37d55d0bf3a82baaa23eb5fb148880b", "patch": "@@ -4,7 +4,6 @@ use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::session::{self, config, DiagnosticOutput};\n use rustc::util::common::ErrorReported;\n-use rustc_lexer::character_properties::{is_id_start, is_id_continue};\n use syntax::ast;\n use syntax::with_globals;\n use syntax::source_map::SourceMap;\n@@ -764,8 +763,8 @@ impl Tester for Collector {\n             // We use these headings as test names, so it's good if\n             // they're valid identifiers.\n             let name = name.chars().enumerate().map(|(i, c)| {\n-                    if (i == 0 && is_id_start(c)) ||\n-                        (i != 0 && is_id_continue(c)) {\n+                    if (i == 0 && rustc_lexer::is_id_start(c)) ||\n+                        (i != 0 && rustc_lexer::is_id_continue(c)) {\n                         c\n                     } else {\n                         '_'"}, {"sha": "544ec789d80a9d62d7ed9a74465adfb4c67a3008", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=206fe8e1c37d55d0bf3a82baaa23eb5fb148880b", "patch": "@@ -6,7 +6,6 @@ use crate::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint}\n \n use errors::{Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n-use rustc_lexer::character_properties::{is_id_start, is_id_continue};\n use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n use syntax_pos::symbol::{kw, sym, Symbol};\n \n@@ -323,7 +322,7 @@ impl Ident {\n     fn is_valid(string: &str) -> bool {\n         let mut chars = string.chars();\n         if let Some(start) = chars.next() {\n-            is_id_start(start) && chars.all(is_id_continue)\n+            rustc_lexer::is_id_start(start) && chars.all(rustc_lexer::is_id_continue)\n         } else {\n             false\n         }"}, {"sha": "9b90b31f2d2a2e37542e39ec35af04ef3354c996", "filename": "src/libsyntax/tests.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibsyntax%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206fe8e1c37d55d0bf3a82baaa23eb5fb148880b/src%2Flibsyntax%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftests.rs?ref=206fe8e1c37d55d0bf3a82baaa23eb5fb148880b", "patch": "@@ -63,7 +63,7 @@ crate fn matches_codepattern(a : &str, b : &str) -> bool {\n             (None, None) => return true,\n             (None, _) => return false,\n             (Some(&a), None) => {\n-                if is_pattern_whitespace(a) {\n+                if rustc_lexer::is_whitespace(a) {\n                     break // trailing whitespace check is out of loop for borrowck\n                 } else {\n                     return false\n@@ -72,11 +72,11 @@ crate fn matches_codepattern(a : &str, b : &str) -> bool {\n             (Some(&a), Some(&b)) => (a, b)\n         };\n \n-        if is_pattern_whitespace(a) && is_pattern_whitespace(b) {\n+        if rustc_lexer::is_whitespace(a) && rustc_lexer::is_whitespace(b) {\n             // skip whitespace for a and b\n             scan_for_non_ws_or_end(&mut a_iter);\n             scan_for_non_ws_or_end(&mut b_iter);\n-        } else if is_pattern_whitespace(a) {\n+        } else if rustc_lexer::is_whitespace(a) {\n             // skip whitespace for a\n             scan_for_non_ws_or_end(&mut a_iter);\n         } else if a == b {\n@@ -88,20 +88,16 @@ crate fn matches_codepattern(a : &str, b : &str) -> bool {\n     }\n \n     // check if a has *only* trailing whitespace\n-    a_iter.all(is_pattern_whitespace)\n+    a_iter.all(rustc_lexer::is_whitespace)\n }\n \n /// Advances the given peekable `Iterator` until it reaches a non-whitespace character\n fn scan_for_non_ws_or_end<I: Iterator<Item = char>>(iter: &mut Peekable<I>) {\n-    while iter.peek().copied().map(|c| is_pattern_whitespace(c)) == Some(true) {\n+    while iter.peek().copied().map(|c| rustc_lexer::is_whitespace(c)) == Some(true) {\n         iter.next();\n     }\n }\n \n-fn is_pattern_whitespace(c: char) -> bool {\n-    rustc_lexer::character_properties::is_whitespace(c)\n-}\n-\n /// Identify a position in the text by the Nth occurrence of a string.\n struct Position {\n     string: &'static str,"}]}