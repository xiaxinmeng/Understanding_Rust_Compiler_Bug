{"sha": "2626f3d3d5c3007745176aa0fe22781b9ec2bb06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MjZmM2QzZDVjMzAwNzc0NTE3NmFhMGZlMjI3ODFiOWVjMmJiMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-26T01:54:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-26T01:54:53Z"}, "message": "Auto merge of #66522 - tmiasko:sanitize-flags, r=alexcrichton\n\nAdd support for sanitizer recover and tracking origins of uninitialized memory\n\n* Add support for sanitizer recovery `-Zsanitizer-recover=...` (equivalent to `-fsanitize-recover` in clang).\n* Add support for tracking origins of uninitialized memory in MemorySanitizer `-Zsanitizer-memory-track-origins` (equivalent to `-fsanitize-memory-track-origins` in clang).", "tree": {"sha": "e793260388f0fa9a15bc39e7b80d55252096ae77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e793260388f0fa9a15bc39e7b80d55252096ae77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2626f3d3d5c3007745176aa0fe22781b9ec2bb06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2626f3d3d5c3007745176aa0fe22781b9ec2bb06", "html_url": "https://github.com/rust-lang/rust/commit/2626f3d3d5c3007745176aa0fe22781b9ec2bb06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "483a83b6e648d9e6cb21af75dba289a9aef150b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/483a83b6e648d9e6cb21af75dba289a9aef150b1", "html_url": "https://github.com/rust-lang/rust/commit/483a83b6e648d9e6cb21af75dba289a9aef150b1"}, {"sha": "bf121a33c4f9c3361e29545c6448e603952e6944", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf121a33c4f9c3361e29545c6448e603952e6944", "html_url": "https://github.com/rust-lang/rust/commit/bf121a33c4f9c3361e29545c6448e603952e6944"}], "stats": {"total": 247, "additions": 215, "deletions": 32}, "files": [{"sha": "5d01025c5b508a6b7a3c4ab9d7297cebafb9d74b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2626f3d3d5c3007745176aa0fe22781b9ec2bb06", "patch": "@@ -40,14 +40,27 @@ pub struct Config {\n     pub usize_ty: UintTy,\n }\n \n-#[derive(Clone, Hash, Debug)]\n+#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Sanitizer {\n     Address,\n     Leak,\n     Memory,\n     Thread,\n }\n \n+impl FromStr for Sanitizer {\n+    type Err = ();\n+    fn from_str(s: &str) -> Result<Sanitizer, ()> {\n+        match s {\n+            \"address\" => Ok(Sanitizer::Address),\n+            \"leak\" => Ok(Sanitizer::Leak),\n+            \"memory\" => Ok(Sanitizer::Memory),\n+            \"thread\" => Ok(Sanitizer::Thread),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Hash)]\n pub enum OptLevel {\n     No,         // -O0\n@@ -816,6 +829,9 @@ macro_rules! options {\n             Some(\"one of: `full`, `partial`, or `off`\");\n         pub const parse_sanitizer: Option<&str> =\n             Some(\"one of: `address`, `leak`, `memory` or `thread`\");\n+        pub const parse_sanitizer_list: Option<&str> =\n+            Some(\"comma separated list of sanitizers\");\n+        pub const parse_sanitizer_memory_track_origins: Option<&str> = None;\n         pub const parse_linker_flavor: Option<&str> =\n             Some(::rustc_target::spec::LinkerFlavor::one_of());\n         pub const parse_optimization_fuel: Option<&str> =\n@@ -1010,15 +1026,46 @@ macro_rules! options {\n             true\n         }\n \n-        fn parse_sanitizer(slote: &mut Option<Sanitizer>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"address\") => *slote = Some(Sanitizer::Address),\n-                Some(\"leak\") => *slote = Some(Sanitizer::Leak),\n-                Some(\"memory\") => *slote = Some(Sanitizer::Memory),\n-                Some(\"thread\") => *slote = Some(Sanitizer::Thread),\n-                _ => return false,\n+        fn parse_sanitizer(slot: &mut Option<Sanitizer>, v: Option<&str>) -> bool {\n+            if let Some(Ok(s)) =  v.map(str::parse) {\n+                *slot = Some(s);\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+\n+        fn parse_sanitizer_list(slot: &mut Vec<Sanitizer>, v: Option<&str>) -> bool {\n+            if let Some(v) = v {\n+                for s in v.split(',').map(str::parse) {\n+                    if let Ok(s) = s {\n+                        if !slot.contains(&s) {\n+                            slot.push(s);\n+                        }\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+\n+        fn parse_sanitizer_memory_track_origins(slot: &mut usize, v: Option<&str>) -> bool {\n+            match v.map(|s| s.parse()) {\n+                None => {\n+                    *slot = 2;\n+                    true\n+                }\n+                Some(Ok(i)) if i <= 2 => {\n+                    *slot = i;\n+                    true\n+                }\n+                _ => {\n+                    false\n+                }\n             }\n-            true\n         }\n \n         fn parse_linker_flavor(slote: &mut Option<LinkerFlavor>, v: Option<&str>) -> bool {\n@@ -1376,6 +1423,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"pass `-install_name @rpath/...` to the macOS linker\"),\n     sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],\n                                     \"use a sanitizer\"),\n+    sanitizer_recover: Vec<Sanitizer> = (vec![], parse_sanitizer_list, [TRACKED],\n+        \"Enable recovery for selected sanitizers\"),\n+    sanitizer_memory_track_origins: usize = (0, parse_sanitizer_memory_track_origins, [TRACKED],\n+        \"Enable origins tracking in MemorySanitizer\"),\n     fuel: Option<(String, u64)> = (None, parse_optimization_fuel, [TRACKED],\n         \"set the optimization fuel quota for a crate\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n@@ -2881,6 +2932,7 @@ mod dep_tracking {\n         Option<cstore::NativeLibraryKind>\n     ));\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, u64));\n+    impl_dep_tracking_hash_for_sortable_vec_of!(Sanitizer);\n \n     impl<T1, T2> DepTrackingHash for (T1, T2)\n     where"}, {"sha": "6cc7b0b4b1e42d77ecb3e69c4c296c432e2189eb", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=2626f3d3d5c3007745176aa0fe22781b9ec2bb06", "patch": "@@ -13,7 +13,7 @@ use crate::LlvmCodegenBackend;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig, run_assembler};\n use rustc_codegen_ssa::traits::*;\n-use rustc::session::config::{self, OutputType, Passes, Lto, SwitchWithOptPath};\n+use rustc::session::config::{self, OutputType, Passes, Lto, Sanitizer, SwitchWithOptPath};\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_codegen_ssa::{RLIB_BYTECODE_EXTENSION, ModuleCodegen, CompiledModule};\n@@ -29,7 +29,7 @@ use std::path::{Path, PathBuf};\n use std::str;\n use std::sync::Arc;\n use std::slice;\n-use libc::{c_uint, c_void, c_char, size_t};\n+use libc::{c_int, c_uint, c_void, c_char, size_t};\n \n pub const RELOC_MODEL_ARGS : [(&str, llvm::RelocMode); 7] = [\n     (\"pic\", llvm::RelocMode::PIC),\n@@ -323,7 +323,7 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n-    if config.opt_level.is_some() {\n+    if let Some(opt_level) = config.opt_level {\n         // Create the two optimizing pass managers. These mirror what clang\n         // does, and are by populated by LLVM's default PassManagerBuilder.\n         // Each manager has a different set of passes, but they also share\n@@ -363,6 +363,8 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                 }\n             }\n \n+            add_sanitizer_passes(config, &mut extra_passes);\n+\n             for pass_name in &cgcx.plugin_passes {\n                 if let Some(pass) = find_pass(pass_name) {\n                     extra_passes.push(pass);\n@@ -384,8 +386,7 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             if !config.no_prepopulate_passes {\n                 llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n                 llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-                let opt_level = config.opt_level.map(|x| to_llvm_opt_settings(x).0)\n-                    .unwrap_or(llvm::CodeGenOptLevel::None);\n+                let opt_level = to_llvm_opt_settings(opt_level).0;\n                 let prepare_for_thin_lto = cgcx.lto == Lto::Thin || cgcx.lto == Lto::ThinLocal ||\n                     (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n                 with_llvm_pmb(llmod, &config, opt_level, prepare_for_thin_lto, &mut |b| {\n@@ -449,6 +450,31 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     Ok(())\n }\n \n+unsafe fn add_sanitizer_passes(config: &ModuleConfig,\n+                               passes: &mut Vec<&'static mut llvm::Pass>) {\n+\n+    let sanitizer = match &config.sanitizer {\n+        None => return,\n+        Some(s) => s,\n+    };\n+\n+    let recover = config.sanitizer_recover.contains(sanitizer);\n+    match sanitizer {\n+        Sanitizer::Address => {\n+            passes.push(llvm::LLVMRustCreateAddressSanitizerFunctionPass(recover));\n+            passes.push(llvm::LLVMRustCreateModuleAddressSanitizerPass(recover));\n+        }\n+        Sanitizer::Memory => {\n+            let track_origins = config.sanitizer_memory_track_origins as c_int;\n+            passes.push(llvm::LLVMRustCreateMemorySanitizerPass(track_origins, recover));\n+        }\n+        Sanitizer::Thread => {\n+            passes.push(llvm::LLVMRustCreateThreadSanitizerPass());\n+        }\n+        Sanitizer::Leak => {}\n+    }\n+}\n+\n pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                   diag_handler: &Handler,\n                   module: ModuleCodegen<ModuleLlvm>,"}, {"sha": "241ca695e5fc3b7e8db8150de268470477c046f0", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=2626f3d3d5c3007745176aa0fe22781b9ec2bb06", "patch": "@@ -1670,6 +1670,11 @@ extern \"C\" {\n \n     pub fn LLVMRustPassKind(Pass: &Pass) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;\n+    pub fn LLVMRustCreateAddressSanitizerFunctionPass(Recover: bool) -> &'static mut Pass;\n+    pub fn LLVMRustCreateModuleAddressSanitizerPass(Recover: bool) -> &'static mut Pass;\n+    pub fn LLVMRustCreateMemorySanitizerPass(TrackOrigins: c_int,\n+                                             Recover: bool) -> &'static mut Pass;\n+    pub fn LLVMRustCreateThreadSanitizerPass() -> &'static mut Pass;\n     pub fn LLVMRustAddPass(PM: &PassManager<'_>, Pass: &'static mut Pass);\n     pub fn LLVMRustAddLastExtensionPasses(PMB: &PassManagerBuilder,\n                                           Passes: *const &'static mut Pass,"}, {"sha": "9d3e57449f899e5a11813194e686020b1c50eabd", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=2626f3d3d5c3007745176aa0fe22781b9ec2bb06", "patch": "@@ -59,6 +59,10 @@ pub struct ModuleConfig {\n     pub pgo_gen: SwitchWithOptPath,\n     pub pgo_use: Option<PathBuf>,\n \n+    pub sanitizer: Option<Sanitizer>,\n+    pub sanitizer_recover: Vec<Sanitizer>,\n+    pub sanitizer_memory_track_origins: usize,\n+\n     // Flags indicating which outputs to produce.\n     pub emit_pre_lto_bc: bool,\n     pub emit_no_opt_bc: bool,\n@@ -97,6 +101,10 @@ impl ModuleConfig {\n             pgo_gen: SwitchWithOptPath::Disabled,\n             pgo_use: None,\n \n+            sanitizer: None,\n+            sanitizer_recover: Default::default(),\n+            sanitizer_memory_track_origins: 0,\n+\n             emit_no_opt_bc: false,\n             emit_pre_lto_bc: false,\n             emit_bc: false,\n@@ -345,29 +353,16 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let mut metadata_config = ModuleConfig::new(vec![]);\n     let mut allocator_config = ModuleConfig::new(vec![]);\n \n-    if let Some(ref sanitizer) = sess.opts.debugging_opts.sanitizer {\n-        match *sanitizer {\n-            Sanitizer::Address => {\n-                modules_config.passes.push(\"asan\".to_owned());\n-                modules_config.passes.push(\"asan-module\".to_owned());\n-            }\n-            Sanitizer::Memory => {\n-                modules_config.passes.push(\"msan\".to_owned())\n-            }\n-            Sanitizer::Thread => {\n-                modules_config.passes.push(\"tsan\".to_owned())\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     if sess.opts.debugging_opts.profile {\n         modules_config.passes.push(\"insert-gcov-profiling\".to_owned())\n     }\n \n     modules_config.pgo_gen = sess.opts.cg.profile_generate.clone();\n     modules_config.pgo_use = sess.opts.cg.profile_use.clone();\n-\n+    modules_config.sanitizer = sess.opts.debugging_opts.sanitizer.clone();\n+    modules_config.sanitizer_recover = sess.opts.debugging_opts.sanitizer_recover.clone();\n+    modules_config.sanitizer_memory_track_origins =\n+        sess.opts.debugging_opts.sanitizer_memory_track_origins;\n     modules_config.opt_level = Some(sess.opts.optimize);\n     modules_config.opt_size = Some(sess.opts.optimize);\n "}, {"sha": "062a8265cc6b728fa38494d25e3139d5ff91c875", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=2626f3d3d5c3007745176aa0fe22781b9ec2bb06", "patch": "@@ -20,9 +20,17 @@\n #include \"llvm/Transforms/IPO/FunctionImport.h\"\n #include \"llvm/Transforms/Utils/FunctionImportUtils.h\"\n #include \"llvm/LTO/LTO.h\"\n-\n #include \"llvm-c/Transforms/PassManagerBuilder.h\"\n \n+#include \"llvm/Transforms/Instrumentation.h\"\n+#if LLVM_VERSION_GE(9, 0)\n+#include \"llvm/Transforms/Instrumentation/AddressSanitizer.h\"\n+#endif\n+#if LLVM_VERSION_GE(8, 0)\n+#include \"llvm/Transforms/Instrumentation/ThreadSanitizer.h\"\n+#include \"llvm/Transforms/Instrumentation/MemorySanitizer.h\"\n+#endif\n+\n using namespace llvm;\n using namespace llvm::legacy;\n \n@@ -76,6 +84,41 @@ extern \"C\" LLVMPassRef LLVMRustFindAndCreatePass(const char *PassName) {\n   return nullptr;\n }\n \n+extern \"C\" LLVMPassRef LLVMRustCreateAddressSanitizerFunctionPass(bool Recover) {\n+  const bool CompileKernel = false;\n+\n+  return wrap(createAddressSanitizerFunctionPass(CompileKernel, Recover));\n+}\n+\n+extern \"C\" LLVMPassRef LLVMRustCreateModuleAddressSanitizerPass(bool Recover) {\n+  const bool CompileKernel = false;\n+\n+#if LLVM_VERSION_GE(9, 0)\n+  return wrap(createModuleAddressSanitizerLegacyPassPass(CompileKernel, Recover));\n+#else\n+  return wrap(createAddressSanitizerModulePass(CompileKernel, Recover));\n+#endif\n+}\n+\n+extern \"C\" LLVMPassRef LLVMRustCreateMemorySanitizerPass(int TrackOrigins, bool Recover) {\n+#if LLVM_VERSION_GE(8, 0)\n+  const bool CompileKernel = false;\n+\n+  return wrap(createMemorySanitizerLegacyPassPass(\n+      MemorySanitizerOptions{TrackOrigins, Recover, CompileKernel}));\n+#else\n+  return wrap(createMemorySanitizerPass(TrackOrigins, Recover));\n+#endif\n+}\n+\n+extern \"C\" LLVMPassRef LLVMRustCreateThreadSanitizerPass() {\n+#if LLVM_VERSION_GE(8, 0)\n+  return wrap(createThreadSanitizerLegacyPassPass());\n+#else\n+  return wrap(createThreadSanitizerPass());\n+#endif\n+}\n+\n extern \"C\" LLVMRustPassKind LLVMRustPassKind(LLVMPassRef RustPass) {\n   assert(RustPass);\n   Pass *Pass = unwrap(RustPass);"}, {"sha": "fd8be0bced796372ad2dc55b65c43e8a00fea4a5", "filename": "src/test/codegen/sanitizer-memory-track-orgins.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs?ref=2626f3d3d5c3007745176aa0fe22781b9ec2bb06", "patch": "@@ -0,0 +1,28 @@\n+// Verifies that MemorySanitizer track-origins level can be controlled\n+// with -Zsanitizer-memory-track-origins option.\n+//\n+// needs-sanitizer-support\n+// only-linux\n+// only-x86_64\n+// revisions:MSAN-0 MSAN-1 MSAN-2\n+//\n+//[MSAN-0] compile-flags: -Zsanitizer=memory\n+//[MSAN-1] compile-flags: -Zsanitizer=memory -Zsanitizer-memory-track-origins=1\n+//[MSAN-2] compile-flags: -Zsanitizer=memory -Zsanitizer-memory-track-origins\n+\n+#![crate_type=\"lib\"]\n+\n+// MSAN-0-NOT: @__msan_track_origins\n+// MSAN-1:     @__msan_track_origins = weak_odr local_unnamed_addr constant i32 1\n+// MSAN-2:     @__msan_track_origins = weak_odr local_unnamed_addr constant i32 2\n+//\n+// MSAN-0-LABEL: define void @copy(\n+// MSAN-1-LABEL: define void @copy(\n+// MSAN-2-LABEL: define void @copy(\n+#[no_mangle]\n+pub fn copy(dst: &mut i32, src: &i32) {\n+    // MSAN-0-NOT: call i32 @__msan_chain_origin(\n+    // MSAN-1-NOT: call i32 @__msan_chain_origin(\n+    // MSAN-2:     call i32 @__msan_chain_origin(\n+    *dst = *src;\n+}"}, {"sha": "a292332667b54260d8148a312fd0d6494a0cc7c2", "filename": "src/test/codegen/sanitizer-recover.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2626f3d3d5c3007745176aa0fe22781b9ec2bb06/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs?ref=2626f3d3d5c3007745176aa0fe22781b9ec2bb06", "patch": "@@ -0,0 +1,34 @@\n+// Verifies that AddressSanitizer and MemorySanitizer\n+// recovery mode can be enabled with -Zsanitizer-recover.\n+//\n+// needs-sanitizer-support\n+// only-linux\n+// only-x86_64\n+// revisions:ASAN ASAN-RECOVER MSAN MSAN-RECOVER\n+//\n+//[ASAN]         compile-flags: -Zsanitizer=address\n+//[ASAN-RECOVER] compile-flags: -Zsanitizer=address -Zsanitizer-recover=address\n+//[MSAN]         compile-flags: -Zsanitizer=memory\n+//[MSAN-RECOVER] compile-flags: -Zsanitizer=memory  -Zsanitizer-recover=memory\n+\n+#![crate_type=\"lib\"]\n+\n+// ASAN-LABEL:         define i32 @penguin(\n+// ASAN-RECOVER-LABEL: define i32 @penguin(\n+// MSAN-LABEL:         define i32 @penguin(\n+// MSAN-RECOVER-LABEL: define i32 @penguin(\n+#[no_mangle]\n+pub fn penguin(p: &mut i32) -> i32 {\n+    // ASAN:             call void @__asan_report_load4(i64 %0)\n+    // ASAN:             unreachable\n+    //\n+    // ASAN-RECOVER:     call void @__asan_report_load4_noabort(\n+    // ASAN-RECOVER-NOT: unreachable\n+    //\n+    // MSAN:             call void @__msan_warning_noreturn()\n+    // MSAN:             unreachable\n+    //\n+    // MSAN-RECOVER:     call void @__msan_warning()\n+    // MSAN-RECOVER-NOT: unreachable\n+    *p\n+}"}]}