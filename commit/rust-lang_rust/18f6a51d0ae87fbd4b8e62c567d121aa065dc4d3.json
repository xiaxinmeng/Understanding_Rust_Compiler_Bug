{"sha": "18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZjZhNTFkMGFlODdmYmQ0YjhlNjJjNTY3ZDEyMWFhMDY1ZGM0ZDM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-04-30T15:49:48Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-05-15T03:10:46Z"}, "message": "rustc: rename ast::self_ty and related fields to explicit_self", "tree": {"sha": "9b9f81aae4161723d2a619171ff8c75345ca9f40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b9f81aae4161723d2a619171ff8c75345ca9f40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "html_url": "https://github.com/rust-lang/rust/commit/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70e02cf4457e4c354c74da3c2121f1e373ad7f63", "url": "https://api.github.com/repos/rust-lang/rust/commits/70e02cf4457e4c354c74da3c2121f1e373ad7f63", "html_url": "https://github.com/rust-lang/rust/commit/70e02cf4457e4c354c74da3c2121f1e373ad7f63"}], "stats": {"total": 368, "additions": 184, "deletions": 184}, "files": [{"sha": "9426cd6041d918ee76e0c0d1b98fba8e8417bba4", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -100,7 +100,7 @@ pub static tag_mod_impl_trait: uint = 0x47u;\n   different tags.\n  */\n pub static tag_item_impl_method: uint = 0x48u;\n-pub static tag_item_trait_method_self_ty: uint = 0x4b;\n+pub static tag_item_trait_method_explicit_self: uint = 0x4b;\n pub static tag_item_trait_method_self_ty_region: uint = 0x4c;\n \n "}, {"sha": "e4c676e286f4c08b13335a62f24a972f002f3459", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -135,11 +135,12 @@ pub fn get_method(tcx: ty::ctxt,\n     decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_method_name_and_self_ty(cstore: @mut cstore::CStore,\n-                                   def: ast::def_id) -> (ast::ident, ast::self_ty_)\n+pub fn get_method_name_and_explicit_self(cstore: @mut cstore::CStore,\n+                                         def: ast::def_id)\n+                                     -> (ast::ident, ast::explicit_self_)\n {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_method_name_and_self_ty(cstore.intr, cdata, def.node)\n+    decoder::get_method_name_and_explicit_self(cstore.intr, cdata, def.node)\n }\n \n pub fn get_trait_method_def_ids(cstore: @mut cstore::CStore,"}, {"sha": "7febe9b24f8b12e8ae87d7a5f2489db37f617fd1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -670,7 +670,7 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     return infos;\n }\n \n-fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n+fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n     fn get_mutability(ch: u8) -> ast::mutability {\n         match ch as char {\n             'i' => { ast::m_imm }\n@@ -682,11 +682,11 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n         }\n     }\n \n-    let self_type_doc = reader::get_doc(item, tag_item_trait_method_self_ty);\n-    let string = reader::doc_as_str(self_type_doc);\n+    let explicit_self_doc = reader::get_doc(item, tag_item_trait_method_explicit_self);\n+    let string = reader::doc_as_str(explicit_self_doc);\n \n-    let self_ty_kind = string[0];\n-    match self_ty_kind as char {\n+    let explicit_self_kind = string[0];\n+    match explicit_self_kind as char {\n         's' => { return ast::sty_static; }\n         'v' => { return ast::sty_value; }\n         '@' => { return ast::sty_box(get_mutability(string[1])); }\n@@ -696,7 +696,7 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n             return ast::sty_region(None, get_mutability(string[1]));\n         }\n         _ => {\n-            fail!(\"unknown self type code: `%c`\", self_ty_kind as char);\n+            fail!(\"unknown self type code: `%c`\", explicit_self_kind as char);\n         }\n     }\n }\n@@ -707,12 +707,12 @@ fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n     for reader::tagged_docs(item, tag_item_impl_method) |doc| {\n         let m_did = reader::with_doc_data(doc, |d| parse_def_id(d));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n-        let self_ty = get_self_ty(mth_item);\n+        let explicit_self = get_explicit_self(mth_item);\n         rslt.push(@resolve::MethodInfo {\n                     did: translate_def_id(cdata, m_did),\n                     n_tps: item_ty_param_count(mth_item) - base_tps,\n                     ident: item_name(intr, mth_item),\n-                    self_type: self_ty});\n+                    explicit_self: explicit_self});\n     }\n     rslt\n }\n@@ -748,15 +748,15 @@ pub fn get_impls_for_mod(intr: @ident_interner,\n     @result\n }\n \n-pub fn get_method_name_and_self_ty(\n+pub fn get_method_name_and_explicit_self(\n     intr: @ident_interner,\n     cdata: cmd,\n-    id: ast::node_id) -> (ast::ident, ast::self_ty_)\n+    id: ast::node_id) -> (ast::ident, ast::explicit_self_)\n {\n     let method_doc = lookup_item(id, cdata.data);\n     let name = item_name(intr, method_doc);\n-    let self_ty = get_self_ty(method_doc);\n-    (name, self_ty)\n+    let explicit_self = get_explicit_self(method_doc);\n+    (name, explicit_self)\n }\n \n pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n@@ -770,7 +770,7 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let transformed_self_ty = doc_transformed_self_ty(method_doc, tcx, cdata);\n     let fty = doc_method_fty(method_doc, tcx, cdata);\n     let vis = item_visibility(method_doc);\n-    let self_ty = get_self_ty(method_doc);\n+    let explicit_self = get_explicit_self(method_doc);\n     ty::method {\n         ident: name,\n         generics: ty::Generics {\n@@ -779,7 +779,7 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n         },\n         transformed_self_ty: transformed_self_ty,\n         fty: fty,\n-        self_ty: self_ty,\n+        explicit_self: explicit_self,\n         vis: vis,\n         def_id: def_id\n     }\n@@ -823,7 +823,7 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n         };\n \n         let transformed_self_ty = doc_transformed_self_ty(mth, tcx, cdata);\n-        let self_ty = get_self_ty(mth);\n+        let explicit_self = get_explicit_self(mth);\n         let ty_method = ty::method {\n             ident: name,\n             generics: ty::Generics {\n@@ -832,7 +832,7 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n             },\n             transformed_self_ty: transformed_self_ty,\n             fty: fty,\n-            self_ty: self_ty,\n+            explicit_self: explicit_self,\n             vis: ast::public,\n             def_id: did\n         };"}, {"sha": "a9acf5d50157e47fb49784775b5d1395e5022097", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -389,7 +389,7 @@ fn encode_reexported_static_methods(ecx: @EncodeContext,\n                 Some(&ast_map::node_item(_, path)) => {\n                     if mod_path != *path {\n                         for methods.each |&m| {\n-                            if m.self_ty  == ast::sty_static {\n+                            if m.explicit_self == ast::sty_static {\n                                 encode_reexported_static_method(ecx,\n                                                                 ebml_w,\n                                                                 exp, m);\n@@ -486,11 +486,11 @@ fn encode_visibility(ebml_w: &mut writer::Encoder, visibility: visibility) {\n     ebml_w.end_tag();\n }\n \n-fn encode_self_type(ebml_w: &mut writer::Encoder, self_type: ast::self_ty_) {\n-    ebml_w.start_tag(tag_item_trait_method_self_ty);\n+fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::explicit_self_) {\n+    ebml_w.start_tag(tag_item_trait_method_explicit_self);\n \n     // Encode the base self type.\n-    match self_type {\n+    match explicit_self {\n         sty_static => {\n             ebml_w.writer.write(&[ 's' as u8 ]);\n         }\n@@ -634,7 +634,7 @@ fn encode_method_ty_fields(ecx: @EncodeContext,\n     encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n     encode_method_fty(ecx, ebml_w, &method_ty.fty);\n     encode_visibility(ebml_w, method_ty.vis);\n-    encode_self_type(ebml_w, method_ty.self_ty);\n+    encode_explicit_self(ebml_w, method_ty.explicit_self);\n }\n \n fn encode_info_for_method(ecx: @EncodeContext,\n@@ -655,7 +655,7 @@ fn encode_info_for_method(ecx: @EncodeContext,\n     let method_ty: @ty::method = ty::method(ecx.tcx, method_def_id);\n     encode_method_ty_fields(ecx, ebml_w, method_ty);\n \n-    match m.self_ty.node {\n+    match m.explicit_self.node {\n         ast::sty_static => {\n             encode_family(ebml_w, purity_static_method_family(m.purity));\n         }\n@@ -962,7 +962,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n             trait_path.push(ast_map::path_name(item.ident));\n             encode_path(ecx, ebml_w, trait_path, ast_map::path_name(method_ty.ident));\n \n-            match method_ty.self_ty {\n+            match method_ty.explicit_self {\n                 sty_static => {\n                     encode_family(ebml_w,\n                                   purity_static_method_family(\n@@ -991,7 +991,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n                     // This is obviously a bogus assert but I don't think this\n                     // ever worked before anyhow...near as I can tell, before\n                     // we would emit two items.\n-                    if method_ty.self_ty == sty_static {\n+                    if method_ty.explicit_self == sty_static {\n                         tcx.sess.span_unimpl(\n                             item.span,\n                             fmt!(\"Method %s is both provided and static\","}, {"sha": "2996c4c8476dc8c0596ad7f3d842d379cef16800", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -552,8 +552,8 @@ impl read_method_map_entry_helper for reader::Decoder {\n                 explicit_self: this.read_struct_field(\"explicit_self\",\n                                                       2,\n                                                       |this| {\n-                    let self_type: ast::self_ty_ = Decodable::decode(this);\n-                    self_type\n+                    let explicit_self: ast::explicit_self_ = Decodable::decode(this);\n+                    explicit_self\n                 }),\n                 origin: this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: method_origin ="}, {"sha": "9995de24e8db29d37265a074eadb4d5d7f253719", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -381,7 +381,7 @@ fn visit_fn(fk: &visit::fn_kind,\n     // Add `this`, whether explicit or implicit.\n     match *fk {\n         fk_method(_, _, method) => {\n-            match method.self_ty.node {\n+            match method.explicit_self.node {\n                 sty_value | sty_region(*) | sty_box(_) | sty_uniq(_) => {\n                     fn_maps.add_variable(Arg(method.self_id,\n                                              special_idents::self_));"}, {"sha": "91f565bcae6259d8f93e6e8e3ae2ed2e1d28166b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -10,7 +10,7 @@\n \n use driver::session::Session;\n use metadata::csearch::{each_path, get_trait_method_def_ids};\n-use metadata::csearch::get_method_name_and_self_ty;\n+use metadata::csearch::get_method_name_and_explicit_self;\n use metadata::csearch::get_static_methods_if_impl;\n use metadata::csearch::get_type_name_if_impl;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n@@ -28,7 +28,7 @@ use syntax::ast::{def_const, def_foreign_mod, def_fn, def_id, def_label};\n use syntax::ast::{def_local, def_mod, def_prim_ty, def_region, def_self};\n use syntax::ast::{def_self_ty, def_static_method, def_struct, def_ty};\n use syntax::ast::{def_ty_param, def_typaram_binder, def_trait};\n-use syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n+use syntax::ast::{def_upvar, def_use, def_variant, explicit_self_, expr, expr_assign_op};\n use syntax::ast::{expr_binary, expr_break, expr_field};\n use syntax::ast::{expr_fn_block, expr_index, expr_method_call, expr_path};\n use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n@@ -45,7 +45,7 @@ use syntax::ast::{local, local_crate, lt, method, mul};\n use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n use syntax::ast::{Path, pat_lit, pat_range, pat_struct};\n use syntax::ast::{prim_ty, private, provided};\n-use syntax::ast::{public, required, rem, self_ty_, shl, shr, stmt_decl};\n+use syntax::ast::{public, required, rem, shl, shr, stmt_decl};\n use syntax::ast::{struct_field, struct_variant_kind};\n use syntax::ast::{sty_static, subtract, trait_ref, tuple_variant_kind, Ty};\n use syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n@@ -96,7 +96,7 @@ pub struct MethodInfo {\n     did: def_id,\n     n_tps: uint,\n     ident: ident,\n-    self_type: self_ty_\n+    explicit_self: explicit_self_\n }\n \n pub struct Impl {\n@@ -1203,7 +1203,7 @@ pub impl Resolver {\n                 // Bail out early if there are no static methods.\n                 let mut has_static_methods = false;\n                 for methods.each |method| {\n-                    match method.self_ty.node {\n+                    match method.explicit_self.node {\n                         sty_static => has_static_methods = true,\n                         _ => {}\n                     }\n@@ -1236,7 +1236,7 @@ pub impl Resolver {\n \n                         // For each static method...\n                         for methods.each |method| {\n-                            match method.self_ty.node {\n+                            match method.explicit_self.node {\n                                 sty_static => {\n                                     // Add the static method to the\n                                     // module.\n@@ -1274,7 +1274,7 @@ pub impl Resolver {\n                 let mut has_static_methods = false;\n                 for (*methods).each |method| {\n                     let ty_m = trait_method_to_ty_method(method);\n-                    match ty_m.self_ty.node {\n+                    match ty_m.explicit_self.node {\n                         sty_static => {\n                             has_static_methods = true;\n                             break;\n@@ -1306,7 +1306,7 @@ pub impl Resolver {\n                     let ident = ty_m.ident;\n                     // Add it to the trait info if not static,\n                     // add it as a name in the trait module otherwise.\n-                    match ty_m.self_ty.node {\n+                    match ty_m.explicit_self.node {\n                         sty_static => {\n                             let def = def_static_method(\n                                 local_def(ty_m.id),\n@@ -1612,17 +1612,17 @@ pub impl Resolver {\n                                                             def_id);\n               let mut interned_method_names = HashSet::new();\n               for method_def_ids.each |&method_def_id| {\n-                  let (method_name, self_ty) =\n-                      get_method_name_and_self_ty(self.session.cstore,\n-                                                  method_def_id);\n+                  let (method_name, explicit_self) =\n+                      get_method_name_and_explicit_self(self.session.cstore,\n+                                                        method_def_id);\n \n                   debug!(\"(building reduced graph for \\\n                           external crate) ... adding \\\n                           trait method '%s'\",\n                          *self.session.str_of(method_name));\n \n                   // Add it to the trait info if not static.\n-                  if self_ty != sty_static {\n+                  if explicit_self != sty_static {\n                       interned_method_names.insert(method_name);\n                   }\n               }\n@@ -3774,7 +3774,7 @@ pub impl Resolver {\n                               outer_type_parameter_count,\n                               rib_kind);\n         // we only have self ty if it is a non static method\n-        let self_binding = match method.self_ty.node {\n+        let self_binding = match method.explicit_self.node {\n           sty_static => { NoSelfBinding }\n           _ => { HasSelfBinding(method.self_id, false) }\n         };"}, {"sha": "773de1577f703eca9c97ef30eb7a14dd706e801d", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -11,7 +11,7 @@\n use driver::session;\n use driver::session::Session;\n use metadata::csearch::{each_path, get_trait_method_def_ids};\n-use metadata::csearch::get_method_name_and_self_ty;\n+use metadata::csearch::get_method_name_and_explicit_self;\n use metadata::csearch::get_static_methods_if_impl;\n use metadata::csearch::get_type_name_if_impl;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n@@ -46,7 +46,7 @@ use syntax::ast::{local, local_crate, lt, method, mul};\n use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n use syntax::ast::{Path, pat_lit, pat_range, pat_struct};\n use syntax::ast::{prim_ty, private, provided};\n-use syntax::ast::{public, required, rem, self_ty_, shl, shr, stmt_decl};\n+use syntax::ast::{public, required, rem, explicit_self_, shl, shr, stmt_decl};\n use syntax::ast::{struct_field, struct_variant_kind};\n use syntax::ast::{sty_static, subtract, trait_ref, tuple_variant_kind, Ty};\n use syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n@@ -97,7 +97,7 @@ pub struct MethodInfo {\n     did: def_id,\n     n_tps: uint,\n     ident: ident,\n-    self_type: self_ty_\n+    explicit_self: explicit_self_\n }\n \n pub struct Impl {\n@@ -1219,7 +1219,7 @@ pub impl Resolver {\n                 // Bail out early if there are no static methods.\n                 let mut has_static_methods = false;\n                 for methods.each |method| {\n-                    match method.self_ty.node {\n+                    match method.explicit_self.node {\n                         sty_static => has_static_methods = true,\n                         _ => {}\n                     }\n@@ -1252,7 +1252,7 @@ pub impl Resolver {\n \n                         // For each static method...\n                         for methods.each |method| {\n-                            match method.self_ty.node {\n+                            match method.explicit_self.node {\n                                 sty_static => {\n                                     // Add the static method to the\n                                     // module.\n@@ -1290,7 +1290,7 @@ pub impl Resolver {\n                 let mut has_static_methods = false;\n                 for (*methods).each |method| {\n                     let ty_m = trait_method_to_ty_method(method);\n-                    match ty_m.self_ty.node {\n+                    match ty_m.explicit_self.node {\n                         sty_static => {\n                             has_static_methods = true;\n                             break;\n@@ -1322,7 +1322,7 @@ pub impl Resolver {\n                     let ident = ty_m.ident;\n                     // Add it to the trait info if not static,\n                     // add it as a name in the trait module otherwise.\n-                    match ty_m.self_ty.node {\n+                    match ty_m.explicit_self.node {\n                         sty_static => {\n                             let def = def_static_method(\n                                 local_def(ty_m.id),\n@@ -1628,17 +1628,17 @@ pub impl Resolver {\n                                                             def_id);\n               let mut interned_method_names = HashSet::new();\n               for method_def_ids.each |&method_def_id| {\n-                  let (method_name, self_ty) =\n-                      get_method_name_and_self_ty(self.session.cstore,\n-                                                  method_def_id);\n+                  let (method_name, explicit_self) =\n+                      get_method_name_and_explicit_self(self.session.cstore,\n+                                                        method_def_id);\n \n                   debug!(\"(building reduced graph for \\\n                           external crate) ... adding \\\n                           trait method '%s'\",\n                          *self.session.str_of(method_name));\n \n                   // Add it to the trait info if not static.\n-                  if self_ty != sty_static {\n+                  if explicit_self != sty_static {\n                       interned_method_names.insert(method_name);\n                   }\n               }\n@@ -3800,7 +3800,7 @@ pub impl Resolver {\n                               outer_type_parameter_count,\n                               rib_kind);\n         // we only have self ty if it is a non static method\n-        let self_binding = match method.self_ty.node {\n+        let self_binding = match method.explicit_self.node {\n           sty_static => { NoSelfBinding }\n           _ => { HasSelfBinding(method.self_id, false) }\n         };"}, {"sha": "10e019b2a376c332e7a2aba8e49cc238cdc6af90", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -99,14 +99,14 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n               let path = vec::append(\n                   ty::item_path(ccx.tcx, impl_did),\n                   ~[path_name(mth.ident)]);\n-              let self_kind = match mth.self_ty.node {\n+              let self_kind = match mth.explicit_self.node {\n                   ast::sty_static => no_self,\n                   _ => {\n                       let self_ty = ty::node_id_to_type(ccx.tcx,\n                                                         mth.self_id);\n                       debug!(\"calling inline trans_fn with self_ty %s\",\n                              ty_to_str(ccx.tcx, self_ty));\n-                      match mth.self_ty.node {\n+                      match mth.explicit_self.node {\n                           ast::sty_value => impl_owned_self(self_ty),\n                           _ => impl_self(self_ty),\n                       }"}, {"sha": "bdbb45bf2755a7be2dc725e0ac2681afc8168fa9", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -103,7 +103,7 @@ pub fn trans_method(ccx: @CrateContext,\n                     llfn: ValueRef,\n                     impl_id: ast::def_id) {\n     // figure out how self is being passed\n-    let self_arg = match method.self_ty.node {\n+    let self_arg = match method.explicit_self.node {\n       ast::sty_static => {\n         no_self\n       }\n@@ -123,7 +123,7 @@ pub fn trans_method(ccx: @CrateContext,\n         debug!(\"calling trans_fn with base_self_ty %s, self_ty %s\",\n                base_self_ty.repr(ccx.tcx),\n                self_ty.repr(ccx.tcx));\n-        match method.self_ty.node {\n+        match method.explicit_self.node {\n           ast::sty_value => {\n             impl_owned_self(self_ty)\n           }\n@@ -590,7 +590,7 @@ pub fn trans_trait_callee(bcx: block,\n                           n_method: uint,\n                           self_expr: @ast::expr,\n                           store: ty::TraitStore,\n-                          explicit_self: ast::self_ty_)\n+                          explicit_self: ast::explicit_self_)\n                        -> Callee {\n     //!\n     //\n@@ -627,7 +627,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n                                      n_method: uint,\n                                      llpair: ValueRef,\n                                      store: ty::TraitStore,\n-                                     explicit_self: ast::self_ty_)\n+                                     explicit_self: ast::explicit_self_)\n                                   -> Callee {\n     //!\n     //"}, {"sha": "7f6e828474f8aa3ab800acd48d2a86680d8a02b8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -58,7 +58,7 @@ pub struct method {\n     generics: ty::Generics,\n     transformed_self_ty: Option<ty::t>,\n     fty: BareFnTy,\n-    self_ty: ast::self_ty_,\n+    explicit_self: ast::explicit_self_,\n     vis: ast::visibility,\n     def_id: ast::def_id\n }"}, {"sha": "de6064b0a313bb016bf56aedf28aac1dc319fecd", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -542,7 +542,7 @@ pub fn bound_lifetimes<AC:AstConv>(\n \n struct SelfInfo {\n     untransformed_self_ty: ty::t,\n-    self_transform: ast::self_ty\n+    explicit_self: ast::explicit_self\n }\n \n pub fn ty_of_method<AC:AstConv,RS:region_scope + Copy + 'static>(\n@@ -551,12 +551,12 @@ pub fn ty_of_method<AC:AstConv,RS:region_scope + Copy + 'static>(\n     purity: ast::purity,\n     lifetimes: &OptVec<ast::Lifetime>,\n     untransformed_self_ty: ty::t,\n-    self_transform: ast::self_ty,\n+    explicit_self: ast::explicit_self,\n     decl: &ast::fn_decl) -> (Option<ty::t>, ty::BareFnTy)\n {\n     let self_info = SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n-        self_transform: self_transform\n+        explicit_self: explicit_self\n     };\n     let (a, b) = ty_of_method_or_bare_fn(\n         this, rscope, purity, AbiSet::Rust(), lifetimes, Some(&self_info), decl);\n@@ -617,15 +617,15 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n         rscope: &RS,\n         self_info: &SelfInfo) -> Option<ty::t>\n     {\n-        match self_info.self_transform.node {\n+        match self_info.explicit_self.node {\n             ast::sty_static => None,\n             ast::sty_value => {\n                 Some(self_info.untransformed_self_ty)\n             }\n             ast::sty_region(lifetime, mutability) => {\n                 let region =\n                     ast_region_to_region(this, rscope,\n-                                         self_info.self_transform.span,\n+                                         self_info.explicit_self.span,\n                                          lifetime);\n                 Some(ty::mk_rptr(this.tcx(), region,\n                                  ty::mt {ty: self_info.untransformed_self_ty,"}, {"sha": "2266273c3a9634edef9bac575d73b3740443f1d1", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -381,7 +381,7 @@ pub impl<'self> LookupContext<'self> {\n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n             let pos = {\n                 match trait_methods.position(|m| {\n-                    m.self_ty != ast::sty_static &&\n+                    m.explicit_self != ast::sty_static &&\n                         m.ident == self.m_name })\n                 {\n                     Some(pos) => pos,\n@@ -948,11 +948,11 @@ pub impl<'self> LookupContext<'self> {\n         self.enforce_drop_trait_limitations(candidate);\n \n         // static methods should never have gotten this far:\n-        assert!(candidate.method_ty.self_ty != sty_static);\n+        assert!(candidate.method_ty.explicit_self != sty_static);\n \n         let transformed_self_ty = match candidate.origin {\n             method_trait(*) => {\n-                match candidate.method_ty.self_ty {\n+                match candidate.method_ty.explicit_self {\n                     sty_region(*) => {\n                         // FIXME(#5762) again, preserving existing\n                         // behavior here which (for &self) desires\n@@ -1033,7 +1033,7 @@ pub impl<'self> LookupContext<'self> {\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n         debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n \n-        let self_mode = get_mode_from_self_type(candidate.method_ty.self_ty);\n+        let self_mode = get_mode_from_explicit_self(candidate.method_ty.explicit_self);\n \n         // before we only checked whether self_ty could be a subtype\n         // of rcvr_ty; now we actually make it so (this may cause\n@@ -1055,7 +1055,7 @@ pub impl<'self> LookupContext<'self> {\n         method_map_entry {\n             self_ty: candidate.rcvr_ty,\n             self_mode: self_mode,\n-            explicit_self: candidate.method_ty.self_ty,\n+            explicit_self: candidate.method_ty.explicit_self,\n             origin: candidate.origin,\n         }\n     }\n@@ -1126,7 +1126,7 @@ pub impl<'self> LookupContext<'self> {\n         // on an @Trait object here and so forth\n         match candidate.origin {\n             method_trait(*) => {\n-                match candidate.method_ty.self_ty {\n+                match candidate.method_ty.explicit_self {\n                     sty_static | sty_value => {\n                         return false;\n                     }\n@@ -1144,7 +1144,7 @@ pub impl<'self> LookupContext<'self> {\n             _ => {}\n         }\n \n-        return match candidate.method_ty.self_ty {\n+        return match candidate.method_ty.explicit_self {\n             sty_static => {\n                 false\n             }\n@@ -1301,8 +1301,8 @@ pub impl<'self> LookupContext<'self> {\n     }\n }\n \n-pub fn get_mode_from_self_type(self_type: ast::self_ty_) -> SelfMode {\n-    match self_type {\n+pub fn get_mode_from_explicit_self(explicit_self: ast::explicit_self_) -> SelfMode {\n+    match explicit_self {\n         sty_value => ty::ByCopy,\n         _ => ty::ByRef,\n     }"}, {"sha": "942f73b4555880a8a16c4d11686949215200dc10", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -527,7 +527,7 @@ pub fn check_method(ccx: @mut CrateCtxt,\n     let opt_self_info = method_ty.transformed_self_ty.map(|&ty| {\n         SelfInfo {self_ty: ty,\n                   self_id: method.self_id,\n-                  span: method.self_ty.span}\n+                  span: method.explicit_self.span}\n     });\n \n     check_bare_fn("}, {"sha": "d331bedde12b9e728e533fbb857a0fccf82fff74", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -156,7 +156,7 @@ pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n         did: local_def(ast_method.id),\n         n_tps: ast_method.generics.ty_params.len(),\n         ident: ast_method.ident,\n-        self_type: ast_method.self_ty.node\n+        explicit_self: ast_method.explicit_self.node\n     }\n }\n \n@@ -383,7 +383,7 @@ pub impl CoherenceChecker {\n                         did: new_did,\n                         n_tps: trait_method.generics.type_param_defs.len(),\n                         ident: trait_method.ident,\n-                        self_type: trait_method.self_ty\n+                        explicit_self: trait_method.explicit_self\n                     },\n                     trait_method_def_id: trait_method.def_id\n                 };\n@@ -975,7 +975,7 @@ pub impl CoherenceChecker {\n                         did: new_did,\n                         n_tps: trait_method_info.ty.generics.type_param_defs.len(),\n                         ident: trait_method_info.ty.ident,\n-                        self_type: trait_method_info.ty.self_ty\n+                        explicit_self: trait_method_info.ty.explicit_self\n                     },\n                     trait_method_def_id: trait_method_info.def_id\n                 };\n@@ -1126,7 +1126,7 @@ fn subst_receiver_types_in_method_ty(\n         // method types *can* appear in the generic bounds or the fty\n         generics: method.generics.subst(tcx, &combined_substs),\n         fty: method.fty.subst(tcx, &combined_substs),\n-        self_ty: method.self_ty,\n+        explicit_self: method.explicit_self,\n         vis: method.vis,\n         def_id: new_def_id\n     }"}, {"sha": "927867cbfb94bafed920d06366e9900fb933c19c", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -52,7 +52,7 @@ use syntax::ast_map;\n use syntax::ast_util::{local_def, split_trait_methods};\n use syntax::codemap::span;\n use syntax::codemap;\n-use syntax::print::pprust::{path_to_str, self_ty_to_str};\n+use syntax::print::pprust::{path_to_str, explicit_self_to_str};\n use syntax::visit;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n@@ -234,19 +234,19 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                     &ast::required(ref m) => {\n                         ty_method_of_trait_method(\n                             ccx, trait_id, region_paramd, generics,\n-                            &m.id, &m.ident, &m.self_ty,\n+                            &m.id, &m.ident, &m.explicit_self,\n                             &m.generics, &m.purity, &m.decl)\n                     }\n \n                     &ast::provided(ref m) => {\n                         ty_method_of_trait_method(\n                             ccx, trait_id, region_paramd, generics,\n-                            &m.id, &m.ident, &m.self_ty,\n+                            &m.id, &m.ident, &m.explicit_self,\n                             &m.generics, &m.purity, &m.decl)\n                     }\n                 };\n \n-                if ty_method.self_ty == ast::sty_static {\n+                if ty_method.explicit_self == ast::sty_static {\n                     make_static_method_ty(ccx, trait_id, ty_method,\n                                           &trait_ty_generics);\n                 }\n@@ -376,23 +376,23 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                  trait_generics: &ast::Generics,\n                                  m_id: &ast::node_id,\n                                  m_ident: &ast::ident,\n-                                 m_self_ty: &ast::self_ty,\n+                                 m_explicit_self: &ast::explicit_self,\n                                  m_generics: &ast::Generics,\n                                  m_purity: &ast::purity,\n                                  m_decl: &ast::fn_decl) -> ty::method\n     {\n         let trait_self_ty = ty::mk_self(this.tcx, local_def(trait_id));\n-        let rscope = MethodRscope::new(m_self_ty.node, trait_rp, trait_generics);\n+        let rscope = MethodRscope::new(m_explicit_self.node, trait_rp, trait_generics);\n         let (transformed_self_ty, fty) =\n             astconv::ty_of_method(this, &rscope, *m_purity, &m_generics.lifetimes,\n-                                  trait_self_ty, *m_self_ty, m_decl);\n+                                  trait_self_ty, *m_explicit_self, m_decl);\n         let num_trait_type_params = trait_generics.ty_params.len();\n         ty::method {\n             ident: *m_ident,\n             generics: ty_generics(this, None, m_generics, num_trait_type_params),\n             transformed_self_ty: transformed_self_ty,\n             fty: fty,\n-            self_ty: m_self_ty.node,\n+            explicit_self: m_explicit_self.node,\n             // assume public, because this is only invoked on trait methods\n             vis: ast::public,\n             def_id: local_def(*m_id)\n@@ -459,15 +459,15 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // that the error messages you get out of this code are a bit more\n     // inscrutable, particularly for cases where one method has no\n     // self.\n-    match (&trait_m.self_ty, &impl_m.self_ty) {\n+    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n         (&ast::sty_static, &ast::sty_static) => {}\n         (&ast::sty_static, _) => {\n             tcx.sess.span_err(\n                 cm.span,\n                 fmt!(\"method `%s` has a `%s` declaration in the impl, \\\n                       but not in the trait\",\n                      *tcx.sess.str_of(trait_m.ident),\n-                     self_ty_to_str(impl_m.self_ty, tcx.sess.intr())));\n+                     explicit_self_to_str(impl_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n         (_, &ast::sty_static) => {\n@@ -476,7 +476,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                 fmt!(\"method `%s` has a `%s` declaration in the trait, \\\n                       but not in the impl\",\n                      *tcx.sess.str_of(trait_m.ident),\n-                     self_ty_to_str(trait_m.self_ty, tcx.sess.intr())));\n+                     explicit_self_to_str(trait_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n         _ => {\n@@ -778,14 +778,14 @@ pub fn convert_methods(ccx: &CrateCtxt,\n                     rcvr_visibility: ast::visibility,\n                     method_generics: &ast::Generics) -> ty::method\n     {\n-        let rscope = MethodRscope::new(m.self_ty.node,\n+        let rscope = MethodRscope::new(m.explicit_self.node,\n                                        rp,\n                                        rcvr_generics);\n         let (transformed_self_ty, fty) =\n             astconv::ty_of_method(ccx, &rscope, m.purity,\n                                   &method_generics.lifetimes,\n                                   untransformed_rcvr_ty,\n-                                  m.self_ty, &m.decl);\n+                                  m.explicit_self, &m.decl);\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n@@ -799,7 +799,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n             generics: ty_generics(ccx, None, &m.generics, num_rcvr_type_params),\n             transformed_self_ty: transformed_self_ty,\n             fty: fty,\n-            self_ty: m.self_ty.node,\n+            explicit_self: m.explicit_self.node,\n             vis: method_vis,\n             def_id: local_def(m.id)\n         }"}, {"sha": "95c8f242b49e148a57104b70384bd835be75d094", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -124,7 +124,7 @@ pub struct method_map_entry {\n     self_mode: ty::SelfMode,\n \n     // the type of explicit self on the method\n-    explicit_self: ast::self_ty_,\n+    explicit_self: ast::explicit_self_,\n \n     // method details being invoked\n     origin: method_origin,"}, {"sha": "7c37784b09db9ff7922192f2b9e57a13bd4e447d", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -142,22 +142,22 @@ impl RegionParameterization {\n }\n \n pub struct MethodRscope {\n-    self_ty: ast::self_ty_,\n+    explicit_self: ast::explicit_self_,\n     variance: Option<ty::region_variance>,\n     region_param_names: RegionParamNames,\n }\n \n impl MethodRscope {\n     // `generics` here refers to the generics of the outer item (impl or\n     // trait).\n-    pub fn new(self_ty: ast::self_ty_,\n+    pub fn new(explicit_self: ast::explicit_self_,\n                variance: Option<ty::region_variance>,\n                rcvr_generics: &ast::Generics)\n             -> MethodRscope {\n         let region_param_names =\n             RegionParamNames::from_generics(rcvr_generics);\n         MethodRscope {\n-            self_ty: self_ty,\n+            explicit_self: explicit_self,\n             variance: variance,\n             region_param_names: region_param_names\n         }"}, {"sha": "027dff368a07818007a029cf78aeab361d2ff4e5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -636,12 +636,12 @@ impl Repr for ty::Generics {\n impl Repr for ty::method {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         fmt!(\"method {ident: %s, generics: %s, transformed_self_ty: %s, \\\n-              fty: %s, self_ty: %s, vis: %s, def_id: %s}\",\n+              fty: %s, explicit_self: %s, vis: %s, def_id: %s}\",\n              self.ident.repr(tcx),\n              self.generics.repr(tcx),\n              self.transformed_self_ty.repr(tcx),\n              self.fty.repr(tcx),\n-             self.self_ty.repr(tcx),\n+             self.explicit_self.repr(tcx),\n              self.vis.repr(tcx),\n              self.def_id.repr(tcx))\n     }\n@@ -653,7 +653,7 @@ impl Repr for ast::ident {\n     }\n }\n \n-impl Repr for ast::self_ty_ {\n+impl Repr for ast::explicit_self_ {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         fmt!(\"%?\", *self)\n     }"}, {"sha": "18fdf958aa962938a069713b95cfa22c1d5a5c56", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -187,7 +187,7 @@ fn get_method_sig(\n                                     &ty_m.decl,\n                                     ty_m.purity,\n                                     ty_m.ident,\n-                                    Some(ty_m.self_ty.node),\n+                                    Some(ty_m.explicit_self.node),\n                                     &ty_m.generics,\n                                     extract::interner()\n                                 ))\n@@ -197,7 +197,7 @@ fn get_method_sig(\n                                     &m.decl,\n                                     m.purity,\n                                     m.ident,\n-                                    Some(m.self_ty.node),\n+                                    Some(m.explicit_self.node),\n                                     &m.generics,\n                                     extract::interner()\n                                 ))\n@@ -218,7 +218,7 @@ fn get_method_sig(\n                             &method.decl,\n                             method.purity,\n                             method.ident,\n-                            Some(method.self_ty.node),\n+                            Some(method.explicit_self.node),\n                             &method.generics,\n                             extract::interner()\n                         ))"}, {"sha": "b508ae48c366ad069b37d94912fda028b2d108a9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -767,7 +767,7 @@ pub struct ty_method {\n     purity: purity,\n     decl: fn_decl,\n     generics: Generics,\n-    self_ty: self_ty,\n+    explicit_self: explicit_self,\n     id: node_id,\n     span: span,\n }\n@@ -1064,7 +1064,7 @@ impl to_bytes::IterBytes for ret_style {\n #[auto_encode]\n #[auto_decode]\n #[deriving(Eq)]\n-pub enum self_ty_ {\n+pub enum explicit_self_ {\n     sty_static,                                // no self\n     sty_value,                                 // `self`\n     sty_region(Option<@Lifetime>, mutability), // `&'lt self`\n@@ -1073,7 +1073,7 @@ pub enum self_ty_ {\n }\n \n #[cfg(stage0)]\n-impl to_bytes::IterBytes for self_ty_ {\n+impl to_bytes::IterBytes for explicit_self_ {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n             sty_static => 0u8.iter_bytes(lsb0, f),\n@@ -1086,7 +1086,7 @@ impl to_bytes::IterBytes for self_ty_ {\n }\n \n #[cfg(not(stage0))]\n-impl to_bytes::IterBytes for self_ty_ {\n+impl to_bytes::IterBytes for explicit_self_ {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n             sty_static => 0u8.iter_bytes(lsb0, f),\n@@ -1098,7 +1098,7 @@ impl to_bytes::IterBytes for self_ty_ {\n     }\n }\n \n-pub type self_ty = spanned<self_ty_>;\n+pub type explicit_self = spanned<explicit_self_>;\n \n #[auto_encode]\n #[auto_decode]\n@@ -1107,7 +1107,7 @@ pub struct method {\n     ident: ident,\n     attrs: ~[attribute],\n     generics: Generics,\n-    self_ty: self_ty,\n+    explicit_self: explicit_self,\n     purity: purity,\n     decl: fn_decl,\n     body: blk,"}, {"sha": "a98e3002dcfbbe5e476c81dbed16e614afabd4ad", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -272,7 +272,7 @@ pub fn trait_method_to_ty_method(method: &trait_method) -> ty_method {\n                 purity: m.purity,\n                 decl: copy m.decl,\n                 generics: copy m.generics,\n-                self_ty: m.self_ty,\n+                explicit_self: m.explicit_self,\n                 id: m.id,\n                 span: m.span,\n             }"}, {"sha": "fa9d69c6e99108394823fbb0dd93e335cef59a50", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -713,7 +713,7 @@ fn mk_ser_method(\n         ident: cx.ident_of(\"encode\"),\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n-        self_ty: codemap::spanned {\n+        explicit_self: codemap::spanned {\n             node: ast::sty_region(None, ast::m_imm),\n             span: span\n         },\n@@ -772,7 +772,7 @@ fn mk_deser_method(\n         ident: cx.ident_of(\"decode\"),\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n-        self_ty: codemap::spanned { node: ast::sty_static, span: span },\n+        explicit_self: codemap::spanned { node: ast::sty_static, span: span },\n         purity: ast::impure_fn,\n         decl: deser_decl,\n         body: deser_body,"}, {"sha": "1a45107c267387b503ad270f93f98141af8e333a", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_clone(cx: @ext_ctxt,\n             MethodDef {\n                 name: ~\"clone\",\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[],\n                 ret_ty: Self,\n                 const_nonmatching: false,"}, {"sha": "7fc2fdc7963587a8af6b49744cd43e347780bd65", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -34,7 +34,7 @@ pub fn expand_deriving_eq(cx: @ext_ctxt,\n             MethodDef {\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n                 ret_ty: Literal(Path::new(~[~\"bool\"])),\n                 const_nonmatching: true,"}, {"sha": "5445aef4491be2954e1bd3b9213811fd7335f5db", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -24,7 +24,7 @@ pub fn expand_deriving_ord(cx: @ext_ctxt,\n             MethodDef {\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n                 ret_ty: Literal(Path::new(~[~\"bool\"])),\n                 const_nonmatching: false,"}, {"sha": "4541569b829ac10995d5a952d7ea3b8b22482db6", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -33,7 +33,7 @@ pub fn expand_deriving_totaleq(cx: @ext_ctxt,\n             MethodDef {\n                 name: ~\"equals\",\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n                 ret_ty: Literal(Path::new(~[~\"bool\"])),\n                 const_nonmatching: true,"}, {"sha": "8f156e6a9e315afe11ae547022eb614d3715853f", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -27,7 +27,7 @@ pub fn expand_deriving_totalord(cx: @ext_ctxt,\n             MethodDef {\n                 name: ~\"cmp\",\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n                 ret_ty: Literal(Path::new(~[~\"core\", ~\"cmp\", ~\"Ordering\"])),\n                 const_nonmatching: false,"}, {"sha": "3be65ecd8db9cc53f88cf70f063f66d8e391dcbe", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -119,13 +119,13 @@ fn create_decode_method(\n     let body_block = build::mk_simple_block(cx, span, expr);\n \n     // Create the method.\n-    let self_ty = spanned { node: sty_static, span: span };\n+    let explicit_self = spanned { node: sty_static, span: span };\n     let method_ident = cx.ident_of(\"decode\");\n     @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n+        explicit_self: explicit_self,\n         purity: impure_fn,\n         decl: fn_decl,\n         body: body_block,"}, {"sha": "2078ec9d45cf483ba3a5b7ebc72c64c8f891d444", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -111,13 +111,13 @@ fn create_encode_method(\n     let body_block = build::mk_block_(cx, span, statements);\n \n     // Create the method.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n+    let explicit_self = spanned { node: sty_region(None, m_imm), span: span };\n     let method_ident = cx.ident_of(\"encode\");\n     @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n+        explicit_self: explicit_self,\n         purity: impure_fn,\n         decl: fn_decl,\n         body: body_block,"}, {"sha": "fc14e3c3f732b83d5ef1f03405a00877b2038a95", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -216,7 +216,7 @@ pub struct MethodDef<'self> {\n     /// Whether there is a self argument (outer Option) i.e. whether\n     /// this is a static function, and whether it is a pointer (inner\n     /// Option)\n-    self_ty: Option<Option<PtrTy>>,\n+    explicit_self: Option<Option<PtrTy>>,\n \n     /// Arguments other than the self argument\n     args: ~[Ty],\n@@ -321,7 +321,7 @@ impl<'self> TraitDef<'self> {\n                          type_ident: ident,\n                          generics: &Generics) -> @ast::item {\n         let methods = do self.methods.map |method_def| {\n-            let (self_ty, self_args, nonself_args, tys) =\n+            let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, span, type_ident, generics);\n \n             let body = if method_def.is_static() {\n@@ -339,7 +339,7 @@ impl<'self> TraitDef<'self> {\n \n             method_def.create_method(cx, span,\n                                      type_ident, generics,\n-                                     self_ty, tys,\n+                                     explicit_self, tys,\n                                      body)\n         };\n \n@@ -352,7 +352,7 @@ impl<'self> TraitDef<'self> {\n                        type_ident: ident,\n                        generics: &Generics) -> @ast::item {\n         let methods = do self.methods.map |method_def| {\n-            let (self_ty, self_args, nonself_args, tys) =\n+            let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, span, type_ident, generics);\n \n             let body = if method_def.is_static() {\n@@ -370,7 +370,7 @@ impl<'self> TraitDef<'self> {\n \n             method_def.create_method(cx, span,\n                                      type_ident, generics,\n-                                     self_ty, tys,\n+                                     explicit_self, tys,\n                                      body)\n         };\n \n@@ -404,28 +404,27 @@ impl<'self> MethodDef<'self> {\n     }\n \n     fn is_static(&self) -> bool {\n-        self.self_ty.is_none()\n+        self.explicit_self.is_none()\n     }\n \n     fn split_self_nonself_args(&self, cx: @ext_ctxt, span: span,\n                              type_ident: ident, generics: &Generics)\n-        -> (ast::self_ty, ~[@expr], ~[@expr], ~[(ident, @ast::Ty)]) {\n+        -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, @ast::Ty)]) {\n \n         let mut self_args = ~[], nonself_args = ~[], arg_tys = ~[];\n-        let mut ast_self_ty = respan(span, ast::sty_static);\n         let mut nonstatic = false;\n \n-        match self.self_ty {\n+        let ast_explicit_self = match self.explicit_self {\n             Some(ref self_ptr) => {\n-                let (self_expr, self_ty) = ty::get_explicit_self(cx, span,\n-                                                                 self_ptr);\n+                let (self_expr, explicit_self) = ty::get_explicit_self(cx, span, self_ptr);\n \n-                ast_self_ty = self_ty;\n                 self_args.push(self_expr);\n                 nonstatic = true;\n+\n+                explicit_self\n             }\n-            _ => {}\n-        }\n+            None => respan(span, ast::sty_static),\n+        };\n \n         for self.args.eachi |i, ty| {\n             let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n@@ -449,13 +448,13 @@ impl<'self> MethodDef<'self> {\n             }\n         }\n \n-        (ast_self_ty, self_args, nonself_args, arg_tys)\n+        (ast_explicit_self, self_args, nonself_args, arg_tys)\n     }\n \n     fn create_method(&self, cx: @ext_ctxt, span: span,\n                      type_ident: ident,\n                      generics: &Generics,\n-                     self_ty: ast::self_ty,\n+                     explicit_self: ast::explicit_self,\n                      arg_types: ~[(ident, @ast::Ty)],\n                      body: @expr) -> @ast::method {\n         // create the generics that aren't for Self\n@@ -477,7 +476,7 @@ impl<'self> MethodDef<'self> {\n             ident: method_ident,\n             attrs: ~[],\n             generics: fn_generics,\n-            self_ty: self_ty,\n+            explicit_self: explicit_self,\n             purity: ast::impure_fn,\n             decl: fn_decl,\n             body: body_block,"}, {"sha": "27e3a54add540c65bca27e3b3319046d3ae9873c", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -26,7 +26,7 @@ pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n             MethodDef {\n                 name: ~\"iter_bytes\",\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[\n                     Literal(Path::new(~[~\"bool\"])),\n                     Literal(Path::new(~[~\"core\", ~\"to_bytes\", ~\"Cb\"]))"}, {"sha": "2d91fcd346ae5090bf3b72c0573f387f6c85f44b", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -32,7 +32,7 @@ pub fn expand_deriving_rand(cx: @ext_ctxt,\n                     bounds: ~[(~\"R\",\n                                ~[ Path::new(~[~\"core\", ~\"rand\", ~\"Rng\"]) ])]\n                 },\n-                self_ty: None,\n+                explicit_self: None,\n                 args: ~[\n                     Ptr(~Literal(Path::new_local(~\"R\")),\n                         Borrowed(None, ast::m_mutbl))"}, {"sha": "13cb09e970df6046580e970d9ae1b74288ed6fa7", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -27,7 +27,7 @@ pub fn expand_deriving_to_str(cx: @ext_ctxt,\n             MethodDef {\n                 name: ~\"to_str\",\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[],\n                 ret_ty: Ptr(~Literal(Path::new_local(~\"str\")), Owned),\n                 const_nonmatching: false,"}, {"sha": "8fd372e47928633f5fd230fd31d3fde32cc3e23e", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -217,7 +217,7 @@ pub impl LifetimeBounds {\n \n \n pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: &Option<PtrTy>)\n-    -> (@expr, ast::self_ty) {\n+    -> (@expr, ast::explicit_self) {\n     let self_path = build::make_self(cx, span);\n     match *self_ptr {\n         None => {"}, {"sha": "f6dbbbf420d8e676d1f60ef3dca50cf36d8e51f9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -323,7 +323,7 @@ fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n         ident: fld.fold_ident(m.ident),\n         attrs: /* FIXME (#2543) */ copy m.attrs,\n         generics: fold_generics(&m.generics, fld),\n-        self_ty: m.self_ty,\n+        explicit_self: m.explicit_self,\n         purity: m.purity,\n         decl: fold_fn_decl(&m.decl, fld),\n         body: fld.fold_block(&m.body),"}, {"sha": "b1fa47f69178f23db8bec361bb799a82d9e4b64e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -19,7 +19,7 @@ use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n use ast::{blk_check_mode, box};\n use ast::{crate, crate_cfg, decl, decl_item};\n-use ast::{decl_local, default_blk, deref, div, enum_def};\n+use ast::{decl_local, default_blk, deref, div, enum_def, explicit_self};\n use ast::{expr, expr_, expr_addr_of, expr_match, expr_again};\n use ast::{expr_assign, expr_assign_op, expr_binary, expr_block};\n use ast::{expr_break, expr_call, expr_cast, expr_copy, expr_do_body};\n@@ -43,7 +43,7 @@ use ast::{named_field, neg, node_id, noreturn, not, pat, pat_box, pat_enum};\n use ast::{pat_ident, pat_lit, pat_range, pat_region, pat_struct};\n use ast::{pat_tup, pat_uniq, pat_wild, private};\n use ast::{rem, required};\n-use ast::{ret_style, return_val, self_ty, shl, shr, stmt, stmt_decl};\n+use ast::{ret_style, return_val, shl, shr, stmt, stmt_decl};\n use ast::{stmt_expr, stmt_semi, stmt_mac, struct_def, struct_field};\n use ast::{struct_variant_kind, subtract};\n use ast::{sty_box, sty_region, sty_static, sty_uniq, sty_value};\n@@ -504,7 +504,7 @@ pub impl Parser {\n \n             let generics = p.parse_generics();\n \n-            let (self_ty, d) = do self.parse_fn_decl_with_self() |p| {\n+            let (explicit_self, d) = do self.parse_fn_decl_with_self() |p| {\n                 // This is somewhat dubious; We don't want to allow argument\n                 // names to be left off if there is a definition...\n                 either::Left(p.parse_arg_general(false))\n@@ -526,7 +526,7 @@ pub impl Parser {\n                     purity: pur,\n                     decl: d,\n                     generics: generics,\n-                    self_ty: self_ty,\n+                    explicit_self: explicit_self,\n                     id: p.get_id(),\n                     span: mk_sp(lo, hi)\n                 })\n@@ -540,7 +540,7 @@ pub impl Parser {\n                     ident: ident,\n                     attrs: attrs,\n                     generics: generics,\n-                    self_ty: self_ty,\n+                    explicit_self: explicit_self,\n                     purity: pur,\n                     decl: d,\n                     body: body,\n@@ -3002,11 +3002,11 @@ pub impl Parser {\n         &self,\n         parse_arg_fn:\n         &fn(&Parser) -> arg_or_capture_item\n-    ) -> (self_ty, fn_decl) {\n-        fn maybe_parse_self_ty(\n-            cnstr: &fn(v: mutability) -> ast::self_ty_,\n+    ) -> (explicit_self, fn_decl) {\n+        fn maybe_parse_explicit_self(\n+            cnstr: &fn(v: mutability) -> ast::explicit_self_,\n             p: &Parser\n-        ) -> ast::self_ty_ {\n+        ) -> ast::explicit_self_ {\n             // We need to make sure it isn't a mode or a type\n             if p.token_is_keyword(&~\"self\", &p.look_ahead(1)) ||\n                 ((p.token_is_keyword(&~\"const\", &p.look_ahead(1)) ||\n@@ -3022,7 +3022,7 @@ pub impl Parser {\n             }\n         }\n \n-        fn maybe_parse_borrowed_self_ty(this: &Parser) -> ast::self_ty_ {\n+        fn maybe_parse_borrowed_explicit_self(this: &Parser) -> ast::explicit_self_ {\n             // The following things are possible to see here:\n             //\n             //     fn(&self)\n@@ -3066,15 +3066,15 @@ pub impl Parser {\n         // A bit of complexity and lookahead is needed here in order to to be\n         // backwards compatible.\n         let lo = self.span.lo;\n-        let self_ty = match *self.token {\n+        let explicit_self = match *self.token {\n           token::BINOP(token::AND) => {\n-            maybe_parse_borrowed_self_ty(self)\n+            maybe_parse_borrowed_explicit_self(self)\n           }\n           token::AT => {\n-            maybe_parse_self_ty(sty_box, self)\n+            maybe_parse_explicit_self(sty_box, self)\n           }\n           token::TILDE => {\n-            maybe_parse_self_ty(sty_uniq, self)\n+            maybe_parse_explicit_self(sty_uniq, self)\n           }\n           token::IDENT(*) if self.is_self_ident() => {\n             self.bump();\n@@ -3087,7 +3087,7 @@ pub impl Parser {\n \n         // If we parsed a self type, expect a comma before the argument list.\n         let args_or_capture_items;\n-        if self_ty != sty_static {\n+        if explicit_self != sty_static {\n             match *self.token {\n                 token::COMMA => {\n                     self.bump();\n@@ -3132,7 +3132,7 @@ pub impl Parser {\n             cf: ret_style\n         };\n \n-        (spanned(lo, hi, self_ty), fn_decl)\n+        (spanned(lo, hi, explicit_self), fn_decl)\n     }\n \n     // parse the |arg, arg| header on a lambda\n@@ -3199,7 +3199,7 @@ pub impl Parser {\n         let pur = self.parse_fn_purity();\n         let ident = self.parse_ident();\n         let generics = self.parse_generics();\n-        let (self_ty, decl) = do self.parse_fn_decl_with_self() |p| {\n+        let (explicit_self, decl) = do self.parse_fn_decl_with_self() |p| {\n             p.parse_arg()\n         };\n \n@@ -3210,7 +3210,7 @@ pub impl Parser {\n             ident: ident,\n             attrs: attrs,\n             generics: generics,\n-            self_ty: self_ty,\n+            explicit_self: explicit_self,\n             purity: pur,\n             decl: decl,\n             body: body,"}, {"sha": "49a30d153dc1f9f8db17ff8534eb7257808604ba", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=18f6a51d0ae87fbd4b8e62c567d121aa065dc4d3", "patch": "@@ -181,12 +181,12 @@ pub fn path_to_str(p: @ast::Path, intr: @ident_interner) -> ~str {\n }\n \n pub fn fun_to_str(decl: &ast::fn_decl, purity: ast::purity, name: ast::ident,\n-                  opt_self_ty: Option<ast::self_ty_>,\n+                  opt_explicit_self: Option<ast::explicit_self_>,\n                   generics: &ast::Generics, intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n         print_fn(s, decl, Some(purity), AbiSet::Rust(),\n-                 name, generics, opt_self_ty, ast::inherited);\n+                 name, generics, opt_explicit_self, ast::inherited);\n         end(s); // Close the head box\n         end(s); // Close the outer box\n         eof(s.s);\n@@ -797,7 +797,7 @@ pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     print_outer_attributes(s, m.attrs);\n     print_ty_fn(s, None, None, None, m.purity, ast::Many,\n                 &m.decl, Some(m.ident), Some(&m.generics),\n-                Some(/*bad*/ copy m.self_ty.node));\n+                Some(/*bad*/ copy m.explicit_self.node));\n     word(s.s, ~\";\");\n }\n \n@@ -813,7 +813,7 @@ pub fn print_method(s: @ps, meth: @ast::method) {\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n     print_fn(s, &meth.decl, Some(meth.purity), AbiSet::Rust(),\n-             meth.ident, &meth.generics, Some(meth.self_ty.node),\n+             meth.ident, &meth.generics, Some(meth.explicit_self.node),\n              meth.vis);\n     word(s.s, ~\" \");\n     print_block_with_attrs(s, &meth.body, meth.attrs);\n@@ -1626,13 +1626,13 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n     (s.ann.post)(ann_node);\n }\n \n-pub fn self_ty_to_str(self_ty: ast::self_ty_, intr: @ident_interner) -> ~str {\n-    to_str(self_ty, |a, b| { print_self_ty(a, b); () }, intr)\n+pub fn explicit_self_to_str(explicit_self: ast::explicit_self_, intr: @ident_interner) -> ~str {\n+    to_str(explicit_self, |a, b| { print_explicit_self(a, b); () }, intr)\n }\n \n // Returns whether it printed anything\n-pub fn print_self_ty(s: @ps, self_ty: ast::self_ty_) -> bool {\n-    match self_ty {\n+pub fn print_explicit_self(s: @ps, explicit_self: ast::explicit_self_) -> bool {\n+    match explicit_self {\n         ast::sty_static => { return false; }\n         ast::sty_value => { word(s.s, ~\"self\"); }\n         ast::sty_region(lt, m) => {\n@@ -1657,24 +1657,24 @@ pub fn print_fn(s: @ps,\n                 abis: AbiSet,\n                 name: ast::ident,\n                 generics: &ast::Generics,\n-                opt_self_ty: Option<ast::self_ty_>,\n+                opt_explicit_self: Option<ast::explicit_self_>,\n                 vis: ast::visibility) {\n     head(s, ~\"\");\n-    print_fn_header_info(s, opt_self_ty, purity, abis, ast::Many, None, vis);\n+    print_fn_header_info(s, opt_explicit_self, purity, abis, ast::Many, None, vis);\n     nbsp(s);\n     print_ident(s, name);\n     print_generics(s, generics);\n-    print_fn_args_and_ret(s, decl, opt_self_ty);\n+    print_fn_args_and_ret(s, decl, opt_explicit_self);\n }\n \n pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n-                 opt_self_ty: Option<ast::self_ty_>) {\n+                 opt_explicit_self: Option<ast::explicit_self_>) {\n     // It is unfortunate to duplicate the commasep logic, but we we want the\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n-    for opt_self_ty.each |self_ty| {\n-        first = !print_self_ty(s, *self_ty);\n+    for opt_explicit_self.each |explicit_self| {\n+        first = !print_explicit_self(s, *explicit_self);\n     }\n \n     for decl.inputs.each |arg| {\n@@ -1686,9 +1686,9 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n }\n \n pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n-                             opt_self_ty: Option<ast::self_ty_>) {\n+                             opt_explicit_self: Option<ast::explicit_self_>) {\n     popen(s);\n-    print_fn_args(s, decl, opt_self_ty);\n+    print_fn_args(s, decl, opt_explicit_self);\n     pclose(s);\n \n     maybe_print_comment(s, decl.output.span.lo);\n@@ -1900,7 +1900,7 @@ pub fn print_ty_fn(s: @ps,\n                    decl: &ast::fn_decl,\n                    id: Option<ast::ident>,\n                    generics: Option<&ast::Generics>,\n-                   opt_self_ty: Option<ast::self_ty_>) {\n+                   opt_explicit_self: Option<ast::explicit_self_>) {\n     ibox(s, indent_unit);\n \n     // Duplicates the logic in `print_fn_header_info()`.  This is because that\n@@ -1920,8 +1920,8 @@ pub fn print_ty_fn(s: @ps,\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n-    for opt_self_ty.each |self_ty| {\n-        first = !print_self_ty(s, *self_ty);\n+    for opt_explicit_self.each |explicit_self| {\n+        first = !print_explicit_self(s, *explicit_self);\n     }\n     for decl.inputs.each |arg| {\n         if first { first = false; } else { word_space(s, ~\",\"); }\n@@ -2163,7 +2163,7 @@ pub fn print_opt_sigil(s: @ps, opt_sigil: Option<ast::Sigil>) {\n }\n \n pub fn print_fn_header_info(s: @ps,\n-                            _opt_sty: Option<ast::self_ty_>,\n+                            _opt_explicit_self: Option<ast::explicit_self_>,\n                             opt_purity: Option<ast::purity>,\n                             abis: AbiSet,\n                             onceness: ast::Onceness,"}]}