{"sha": "1a26d2364f9da1667ca0098d3cc4a213d131f481", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMjZkMjM2NGY5ZGExNjY3Y2EwMDk4ZDNjYzRhMjEzZDEzMWY0ODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-15T08:14:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-15T08:14:10Z"}, "message": "Auto merge of #33607 - jonas-schievink:prettier-mir, r=eddyb\n\nSome simple improvements to MIR pretty printing\n\nIn short, this PR changes the MIR printer so that it:\n\n* places an empty line between the MIR for each item\n* does *not* write an empty line before the first BB when there are no\n  var decls\n* aligns the \"// Scope\" comments 50 chars in (makes the output more\n  readable)\n* prints the scope comments as \"// scope N at ...\" instead of \"//\n  Scope(N) at ...\"\n* prints a prettier scope tree:\n * no more unbalanced delimiters!\n * no more \"Parent\" entry (these convey no useful information)\n * drop the \"Scope()\" and just print scope IDs\n * no braces when the scope is empty\n\nIn action: https://gist.github.com/jonas-schievink/1c11226cbb112892a9470ce0f9870b65", "tree": {"sha": "2b3314160aaced7d8bc0c7bbb7ed34cd3016e1dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b3314160aaced7d8bc0c7bbb7ed34cd3016e1dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a26d2364f9da1667ca0098d3cc4a213d131f481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a26d2364f9da1667ca0098d3cc4a213d131f481", "html_url": "https://github.com/rust-lang/rust/commit/1a26d2364f9da1667ca0098d3cc4a213d131f481", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a26d2364f9da1667ca0098d3cc4a213d131f481/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "088d4178522d4e9464c6beac70b14724670ee735", "url": "https://api.github.com/repos/rust-lang/rust/commits/088d4178522d4e9464c6beac70b14724670ee735", "html_url": "https://github.com/rust-lang/rust/commit/088d4178522d4e9464c6beac70b14724670ee735"}, {"sha": "2c7e398935fe10aa2adea453ca0a2251b3c387e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c7e398935fe10aa2adea453ca0a2251b3c387e8", "html_url": "https://github.com/rust-lang/rust/commit/2c7e398935fe10aa2adea453ca0a2251b3c387e8"}], "stats": {"total": 110, "additions": 84, "deletions": 26}, "files": [{"sha": "fb29cbd5fa8a24651eccd3786848b621b41fdfb5", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 84, "deletions": 26, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/1a26d2364f9da1667ca0098d3cc4a213d131f481/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a26d2364f9da1667ca0098d3cc4a213d131f481/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=1a26d2364f9da1667ca0098d3cc4a213d131f481", "patch": "@@ -21,6 +21,8 @@ use syntax::ast::NodeId;\n use syntax::codemap::Span;\n \n const INDENT: &'static str = \"    \";\n+/// Alignment for lining up comments following MIR statements\n+const ALIGN: usize = 40;\n \n /// If the session is properly configured, dumps a human-readable\n /// representation of the mir into:\n@@ -79,11 +81,20 @@ pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                          -> io::Result<()>\n     where I: Iterator<Item=(&'a NodeId, &'a Mir<'tcx>)>, 'tcx: 'a\n {\n+    let mut first = true;\n     for (&id, mir) in iter {\n+        if first {\n+            first = false;\n+        } else {\n+            // Put empty lines between all items\n+            writeln!(w, \"\")?;\n+        }\n+\n         let src = MirSource::from_node(tcx, id);\n         write_mir_fn(tcx, src, mir, w, None)?;\n \n         for (i, mir) in mir.promoted.iter().enumerate() {\n+            writeln!(w, \"\")?;\n             write_mir_fn(tcx, MirSource::Promoted(id, i), mir, w, None)?;\n         }\n     }\n@@ -131,7 +142,10 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   .or_insert(vec![])\n                   .push(ScopeId::new(index));\n     }\n-    write_scope_tree(tcx, mir, auxiliary, &scope_tree, w, None, 1)?;\n+\n+    writeln!(w, \"{}scope tree:\", INDENT)?;\n+    write_scope_tree(tcx, mir, auxiliary, &scope_tree, w, None, 1, false)?;\n+    writeln!(w, \"\")?;\n \n     writeln!(w, \"}}\")?;\n     Ok(())\n@@ -147,7 +161,7 @@ fn write_basic_block(tcx: TyCtxt,\n     let data = mir.basic_block_data(block);\n \n     // Basic block label at the top.\n-    writeln!(w, \"\\n{}{:?}: {{\", INDENT, block)?;\n+    writeln!(w, \"{}{:?}: {{\", INDENT, block)?;\n \n     // List of statements in the middle.\n     let mut current_location = Location { block: block, statement_index: 0 };\n@@ -165,25 +179,27 @@ fn write_basic_block(tcx: TyCtxt,\n             }\n         }\n \n-        writeln!(w, \"{0}{0}{1:?}; // {2}\",\n-                 INDENT,\n-                 statement,\n+        let indented_mir = format!(\"{0}{0}{1:?};\", INDENT, statement);\n+        writeln!(w, \"{0:1$} // {2}\",\n+                 indented_mir,\n+                 ALIGN,\n                  comment(tcx, statement.scope, statement.span))?;\n \n         current_location.statement_index += 1;\n     }\n \n     // Terminator at the bottom.\n-    writeln!(w, \"{0}{0}{1:?}; // {2}\",\n-             INDENT,\n-             data.terminator().kind,\n+    let indented_terminator = format!(\"{0}{0}{1:?};\", INDENT, data.terminator().kind);\n+    writeln!(w, \"{0:1$} // {2}\",\n+             indented_terminator,\n+             ALIGN,\n              comment(tcx, data.terminator().scope, data.terminator().span))?;\n \n-    writeln!(w, \"{}}}\", INDENT)\n+    writeln!(w, \"{}}}\\n\", INDENT)\n }\n \n fn comment(tcx: TyCtxt, scope: ScopeId, span: Span) -> String {\n-    format!(\"Scope({}) at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n+    format!(\"scope {} at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n }\n \n fn write_scope_tree(tcx: TyCtxt,\n@@ -192,28 +208,58 @@ fn write_scope_tree(tcx: TyCtxt,\n                     scope_tree: &FnvHashMap<Option<ScopeId>, Vec<ScopeId>>,\n                     w: &mut Write,\n                     parent: Option<ScopeId>,\n-                    depth: usize)\n+                    depth: usize,\n+                    same_line: bool)\n                     -> io::Result<()> {\n-    for &child in scope_tree.get(&parent).unwrap_or(&vec![]) {\n-        let indent = depth * INDENT.len();\n+    let indent = if same_line {\n+        0\n+    } else {\n+        depth * INDENT.len()\n+    };\n+\n+    let children = match scope_tree.get(&parent) {\n+        Some(childs) => childs,\n+        None => return Ok(()),\n+    };\n+\n+    for (index, &child) in children.iter().enumerate() {\n+        if index == 0 && same_line {\n+            // We know we're going to output a scope, so prefix it with a space to separate it from\n+            // the previous scopes on this line\n+            write!(w, \" \")?;\n+        }\n+\n         let data = &mir.scopes[child];\n         assert_eq!(data.parent_scope, parent);\n-        writeln!(w, \"{0:1$}Scope({2}) {{\", \"\", indent, child.index())?;\n+        write!(w, \"{0:1$}{2}\", \"\", indent, child.index())?;\n \n         let indent = indent + INDENT.len();\n-        if let Some(parent) = parent {\n-            writeln!(w, \"{0:1$}Parent: Scope({2})\", \"\", indent, parent.index())?;\n-        }\n \n         if let Some(auxiliary) = auxiliary {\n             let extent = auxiliary[child].extent;\n             let data = tcx.region_maps.code_extent_data(extent);\n             writeln!(w, \"{0:1$}Extent: {2:?}\", \"\", indent, data)?;\n         }\n \n-        write_scope_tree(tcx, mir, auxiliary, scope_tree, w,\n-                         Some(child), depth + 1)?;\n+        let child_count = scope_tree.get(&Some(child)).map(Vec::len).unwrap_or(0);\n+        if child_count < 2 {\n+            // Skip the braces when there's no or only a single subscope\n+            write_scope_tree(tcx, mir, auxiliary, scope_tree, w,\n+                             Some(child), depth, true)?;\n+        } else {\n+            // 2 or more child scopes? Put them in braces and on new lines.\n+            writeln!(w, \" {{\")?;\n+            write_scope_tree(tcx, mir, auxiliary, scope_tree, w,\n+                             Some(child), depth + 1, false)?;\n+\n+            write!(w, \"\\n{0:1$}}}\", \"\", depth * INDENT.len())?;\n+        }\n+\n+        if !same_line && index + 1 < children.len() {\n+            writeln!(w, \"\")?;\n+        }\n     }\n+\n     Ok(())\n }\n \n@@ -261,13 +307,20 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // User variable types (including the user's name in a comment).\n     for (i, var) in mir.var_decls.iter().enumerate() {\n-        write!(w, \"{}let \", INDENT)?;\n-        if var.mutability == Mutability::Mut {\n-            write!(w, \"mut \")?;\n-        }\n-        writeln!(w, \"{:?}: {}; // {} in {}\",\n-                 Lvalue::Var(i as u32),\n-                 var.ty,\n+        let mut_str = if var.mutability == Mutability::Mut {\n+            \"mut \"\n+        } else {\n+            \"\"\n+        };\n+\n+        let indented_var = format!(\"{}let {}{:?}: {};\",\n+                                   INDENT,\n+                                   mut_str,\n+                                   Lvalue::Var(i as u32),\n+                                   var.ty);\n+        writeln!(w, \"{0:1$} // \\\"{2}\\\" in {3}\",\n+                 indented_var,\n+                 ALIGN,\n                  var.name,\n                  comment(tcx, var.scope, var.span))?;\n     }\n@@ -277,5 +330,10 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         writeln!(w, \"{}let mut {:?}: {};\", INDENT, Lvalue::Temp(i as u32), temp.ty)?;\n     }\n \n+    // Wrote any declaration? Add an empty line before the first block is printed.\n+    if !mir.var_decls.is_empty() || !mir.temp_decls.is_empty() {\n+        writeln!(w, \"\")?;\n+    }\n+\n     Ok(())\n }"}]}