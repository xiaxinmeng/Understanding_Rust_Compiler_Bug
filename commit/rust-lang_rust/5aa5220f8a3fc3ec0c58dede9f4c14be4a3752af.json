{"sha": "5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYTUyMjBmOGEzZmMzZWMwYzU4ZGVkZTlmNGMxNGJlNGEzNzUyYWY=", "commit": {"author": {"name": "Haitao Li", "email": "lihaitao@gmail.com", "date": "2012-04-07T17:59:37Z"}, "committer": {"name": "Haitao Li", "email": "lihaitao@gmail.com", "date": "2012-04-07T18:00:58Z"}, "message": "Encode crate dependencies' hash and version data", "tree": {"sha": "9da57dea28427cf266ddc04da6a1c08b7c452637", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9da57dea28427cf266ddc04da6a1c08b7c452637"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af", "html_url": "https://github.com/rust-lang/rust/commit/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af/comments", "author": {"login": "lht", "id": 19508, "node_id": "MDQ6VXNlcjE5NTA4", "avatar_url": "https://avatars.githubusercontent.com/u/19508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lht", "html_url": "https://github.com/lht", "followers_url": "https://api.github.com/users/lht/followers", "following_url": "https://api.github.com/users/lht/following{/other_user}", "gists_url": "https://api.github.com/users/lht/gists{/gist_id}", "starred_url": "https://api.github.com/users/lht/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lht/subscriptions", "organizations_url": "https://api.github.com/users/lht/orgs", "repos_url": "https://api.github.com/users/lht/repos", "events_url": "https://api.github.com/users/lht/events{/privacy}", "received_events_url": "https://api.github.com/users/lht/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lht", "id": 19508, "node_id": "MDQ6VXNlcjE5NTA4", "avatar_url": "https://avatars.githubusercontent.com/u/19508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lht", "html_url": "https://github.com/lht", "followers_url": "https://api.github.com/users/lht/followers", "following_url": "https://api.github.com/users/lht/following{/other_user}", "gists_url": "https://api.github.com/users/lht/gists{/gist_id}", "starred_url": "https://api.github.com/users/lht/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lht/subscriptions", "organizations_url": "https://api.github.com/users/lht/orgs", "repos_url": "https://api.github.com/users/lht/repos", "events_url": "https://api.github.com/users/lht/events{/privacy}", "received_events_url": "https://api.github.com/users/lht/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5300662b4e06f4cde219427bbcc2313eca0a5c51", "url": "https://api.github.com/repos/rust-lang/rust/commits/5300662b4e06f4cde219427bbcc2313eca0a5c51", "html_url": "https://github.com/rust-lang/rust/commit/5300662b4e06f4cde219427bbcc2313eca0a5c51"}], "stats": {"total": 83, "additions": 57, "deletions": 26}, "files": [{"sha": "b74d1149d76d6580f49ef2c69186662debb6f92d", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af", "patch": "@@ -64,6 +64,10 @@ const tag_crate_hash: uint = 0x28u;\n \n const tag_parent_item: uint = 0x29u;\n \n+const tag_crate_dep_name: uint = 0x2au;\n+const tag_crate_dep_hash: uint = 0x2bu;\n+const tag_crate_dep_vers: uint = 0x2cu;\n+\n const tag_mod_impl: uint = 0x30u;\n \n const tag_item_method: uint = 0x31u;"}, {"sha": "370d09e00173dc06cfd937ce813820cbcc0d7f9a", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af", "patch": "@@ -88,9 +88,7 @@ fn get_crate_hash(cstore: cstore, cnum: ast::crate_num) -> str {\n \n fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> str {\n     let cdata = get_crate_data(cstore, cnum);\n-    let attrs = decoder::get_crate_attributes(cdata.data);\n-    ret option::get(attr::meta_item_value_from_list(\n-        attr::find_linkage_metas(attrs), \"vers\"));\n+    ret decoder::get_crate_vers(cdata.data);\n }\n \n fn set_crate_data(cstore: cstore, cnum: ast::crate_num,"}, {"sha": "015f9d27258da7789246d9700a38d2a48901f226", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af", "patch": "@@ -33,6 +33,7 @@ export list_crate_metadata;\n export crate_dep;\n export get_crate_deps;\n export get_crate_hash;\n+export get_crate_vers;\n export get_impls_for_mod;\n export get_iface_methods;\n export get_crate_module_paths;\n@@ -579,16 +580,22 @@ fn get_crate_attributes(data: @[u8]) -> [ast::attribute] {\n     ret get_attributes(ebml::doc(data));\n }\n \n-type crate_dep = {cnum: ast::crate_num, ident: str};\n+type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n+                  vers: str, hash: str};\n \n fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n     let mut deps: [crate_dep] = [];\n     let cratedoc = ebml::doc(data);\n     let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n+    fn docstr(doc: ebml::doc, tag_: uint) -> str {\n+        str::from_bytes(ebml::doc_data(ebml::get_doc(doc, tag_)))\n+    }\n     ebml::tagged_docs(depsdoc, tag_crate_dep) {|depdoc|\n-        let depname = str::from_bytes(ebml::doc_data(depdoc));\n-        deps += [{cnum: crate_num, ident: depname}];\n+        deps += [{cnum: crate_num,\n+                  name: docstr(depdoc, tag_crate_dep_name),\n+                  vers: docstr(depdoc, tag_crate_dep_vers),\n+                  hash: docstr(depdoc, tag_crate_dep_hash)}];\n         crate_num += 1;\n     };\n     ret deps;\n@@ -598,7 +605,8 @@ fn list_crate_deps(data: @[u8], out: io::writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n     for get_crate_deps(data).each {|dep|\n-        out.write_str(#fmt[\"%d %s\\n\", dep.cnum, dep.ident]);\n+        out.write_str(#fmt[\"%d %s-%s-%s\\n\",\n+                           dep.cnum, dep.name, dep.hash, dep.vers]);\n     }\n \n     out.write_str(\"\\n\");\n@@ -610,6 +618,15 @@ fn get_crate_hash(data: @[u8]) -> str {\n     ret str::from_bytes(ebml::doc_data(hashdoc));\n }\n \n+fn get_crate_vers(data: @[u8]) -> str {\n+    let attrs = decoder::get_crate_attributes(data);\n+    ret alt attr::meta_item_value_from_list(\n+        attr::find_linkage_metas(attrs), \"vers\") {\n+      some(ver) { ver }\n+      none { \"0.0\" }\n+    };\n+}\n+\n fn list_crate_items(bytes: @[u8], md: ebml::doc, out: io::writer) {\n     out.write_str(\"=Items=\\n\");\n     let items = ebml::get_doc(md, tag_items);"}, {"sha": "197f8be6f02c385573973b1144d7615cd011b873", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=5aa5220f8a3fc3ec0c58dede9f4c14be4a3752af", "patch": "@@ -907,47 +907,59 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> [attribute] {\n \n fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n \n-    fn get_ordered_names(cstore: cstore::cstore) -> [str] {\n+    fn get_ordered_deps(cstore: cstore::cstore) -> [decoder::crate_dep] {\n         type hashkv = @{key: crate_num, val: cstore::crate_metadata};\n-        type numname = {crate: crate_num, ident: str};\n+        type numdep = decoder::crate_dep;\n \n-        // Pull the cnums and names out of cstore\n-        let mut pairs: [mut numname] = [mut];\n+        // Pull the cnums and name,vers,hash out of cstore\n+        let mut deps: [mut numdep] = [mut];\n         cstore::iter_crate_data(cstore) {|key, val|\n-            pairs += [mut {crate: key, ident: val.name}];\n+            let dep = {cnum: key, name: val.name,\n+                       vers: decoder::get_crate_vers(val.data),\n+                       hash:  decoder::get_crate_hash(val.data)};\n+            deps += [mut dep];\n         };\n \n         // Sort by cnum\n-        fn lteq(kv1: numname, kv2: numname) -> bool { kv1.crate <= kv2.crate }\n-        std::sort::quick_sort(lteq, pairs);\n+        fn lteq(kv1: numdep, kv2: numdep) -> bool { kv1.cnum <= kv2.cnum }\n+        std::sort::quick_sort(lteq, deps);\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n-        for pairs.each {|n|\n-            assert (n.crate == expected_cnum);\n+        for deps.each {|n|\n+            assert (n.cnum == expected_cnum);\n             expected_cnum += 1;\n         }\n \n-        // Return just the names\n-        fn name(kv: numname) -> str { kv.ident }\n         // mut -> immutable hack for vec::map\n-        let immpairs = vec::slice(pairs, 0u, vec::len(pairs));\n-        ret vec::map(immpairs, name);\n+        ret vec::slice(deps, 0u, vec::len(deps));\n     }\n \n-    // We're just going to write a list of crate names, with the assumption\n-    // that they are numbered 1 to n.\n+    // We're just going to write a list of crate 'name-hash-version's, with\n+    // the assumption that they are numbered 1 to n.\n     // FIXME: This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ebml_w.start_tag(tag_crate_deps);\n-    for get_ordered_names(cstore).each {|cname|\n-        ebml_w.start_tag(tag_crate_dep);\n-        ebml_w.writer.write(str::bytes(cname));\n-        ebml_w.end_tag();\n+    for get_ordered_deps(cstore).each {|dep|\n+        encode_crate_dep(ebml_w, dep);\n     }\n     ebml_w.end_tag();\n }\n \n+fn encode_crate_dep(ebml_w: ebml::writer, dep: decoder::crate_dep) {\n+    ebml_w.start_tag(tag_crate_dep);\n+    ebml_w.start_tag(tag_crate_dep_name);\n+    ebml_w.writer.write(str::bytes(dep.name));\n+    ebml_w.end_tag();\n+    ebml_w.start_tag(tag_crate_dep_vers);\n+    ebml_w.writer.write(str::bytes(dep.vers));\n+    ebml_w.end_tag();\n+    ebml_w.start_tag(tag_crate_dep_hash);\n+    ebml_w.writer.write(str::bytes(dep.hash));\n+    ebml_w.end_tag();\n+    ebml_w.end_tag();\n+}\n+\n fn encode_hash(ebml_w: ebml::writer, hash: str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::bytes(hash));"}]}