{"sha": "5d9dd7cf33dc252b3b914125a2025435783df096", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkOWRkN2NmMzNkYzI1MmIzYjkxNDEyNWEyMDI1NDM1NzgzZGYwOTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-12-22T22:17:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-06T02:05:51Z"}, "message": "Refactor overlap checker so that it walks the HIR instead of poking into\nrandom tables. The old code was weird anyway because it would\npotentially walk traits from other crates etc. The new code fits\nseamlessly with the dependency tracking.", "tree": {"sha": "6215faf9fe3c50ff22fc7b961a7d1bb7145009b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6215faf9fe3c50ff22fc7b961a7d1bb7145009b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d9dd7cf33dc252b3b914125a2025435783df096", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9dd7cf33dc252b3b914125a2025435783df096", "html_url": "https://github.com/rust-lang/rust/commit/5d9dd7cf33dc252b3b914125a2025435783df096", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d9dd7cf33dc252b3b914125a2025435783df096/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75c4f395acc22f7dc3fddda7cf7a09a3400870b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/75c4f395acc22f7dc3fddda7cf7a09a3400870b3", "html_url": "https://github.com/rust-lang/rust/commit/75c4f395acc22f7dc3fddda7cf7a09a3400870b3"}], "stats": {"total": 61, "additions": 35, "deletions": 26}, "files": [{"sha": "71c6fc1fd08ec7ad516dfc946d423f2595dc7172", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5d9dd7cf33dc252b3b914125a2025435783df096/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9dd7cf33dc252b3b914125a2025435783df096/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=5d9dd7cf33dc252b3b914125a2025435783df096", "patch": "@@ -18,53 +18,53 @@ use middle::ty;\n use middle::infer;\n use syntax::ast;\n use syntax::codemap::Span;\n+use rustc::dep_graph::DepNode;\n use rustc_front::hir;\n use rustc_front::intravisit;\n-use util::nodemap::DefIdMap;\n+use util::nodemap::{DefIdMap, DefIdSet};\n \n pub fn check(tcx: &ty::ctxt) {\n-    let mut overlap = OverlapChecker { tcx: tcx, default_impls: DefIdMap() };\n-    overlap.check_for_overlapping_impls();\n+    let mut overlap = OverlapChecker { tcx: tcx,\n+                                       traits_checked: DefIdSet(),\n+                                       default_impls: DefIdMap() };\n \n     // this secondary walk specifically checks for some other cases,\n     // like defaulted traits, for which additional overlap rules exist\n-    tcx.map.krate().visit_all_items(&mut overlap);\n+    tcx.visit_all_items_in_krate(DepNode::CoherenceOverlapCheckSpecial, &mut overlap);\n }\n \n struct OverlapChecker<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n \n+    // The set of traits where we have checked for overlap.  This is\n+    // used to avoid checking the same trait twice.\n+    //\n+    // NB. It's ok to skip tracking this set because we fully\n+    // encapsulate it, and we always create a task\n+    // (`CoherenceOverlapCheck`) corresponding to each entry.\n+    traits_checked: DefIdSet,\n+\n     // maps from a trait def-id to an impl id\n     default_impls: DefIdMap<ast::NodeId>,\n }\n \n impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n-    fn check_for_overlapping_impls(&self) {\n-        debug!(\"check_for_overlapping_impls\");\n-\n-        // Collect this into a vector to avoid holding the\n-        // refcell-lock during the\n-        // check_for_overlapping_impls_of_trait() check, since that\n-        // check can populate this table further with impls from other\n-        // crates.\n-        let trait_defs: Vec<_> = self.tcx.trait_defs.borrow().values().cloned().collect();\n-\n-        for trait_def in trait_defs {\n-            self.tcx.populate_implementations_for_trait_if_necessary(trait_def.trait_ref.def_id);\n-            self.check_for_overlapping_impls_of_trait(trait_def);\n+    fn check_for_overlapping_impls_of_trait(&mut self, trait_def_id: DefId) {\n+        debug!(\"check_for_overlapping_impls_of_trait(trait_def_id={:?})\",\n+               trait_def_id);\n+\n+        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n+        if !self.traits_checked.insert(trait_def_id) {\n+            return;\n         }\n-    }\n \n-    fn check_for_overlapping_impls_of_trait(&self,\n-                                            trait_def: &'tcx ty::TraitDef<'tcx>)\n-    {\n-        debug!(\"check_for_overlapping_impls_of_trait(trait_def={:?})\",\n-               trait_def);\n+        let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n+        self.tcx.populate_implementations_for_trait_if_necessary(\n+            trait_def.trait_ref.def_id);\n \n         // We should already know all impls of this trait, so these\n         // borrows are safe.\n-        let blanket_impls = trait_def.blanket_impls.borrow();\n-        let nonblanket_impls = trait_def.nonblanket_impls.borrow();\n+        let (blanket_impls, nonblanket_impls) = trait_def.borrow_impl_lists(self.tcx);\n \n         // Conflicts can only occur between a blanket impl and another impl,\n         // or between 2 non-blanket impls of the same kind.\n@@ -175,12 +175,20 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemDefaultImpl(_, _) => {\n+            hir::ItemTrait(..) => {\n+                let trait_def_id = self.tcx.map.local_def_id(item.id);\n+                self.check_for_overlapping_impls_of_trait(trait_def_id);\n+            }\n+\n+            hir::ItemDefaultImpl(..) => {\n                 // look for another default impl; note that due to the\n                 // general orphan/coherence rules, it must always be\n                 // in this crate.\n                 let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n+\n+                self.check_for_overlapping_impls_of_trait(trait_ref.def_id);\n+\n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n                 match prev_default_impl {\n                     Some(prev_id) => {\n@@ -195,6 +203,7 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n+                self.check_for_overlapping_impls_of_trait(trait_def_id);\n                 match trait_ref.self_ty().sty {\n                     ty::TyTrait(ref data) => {\n                         // This is something like impl Trait1 for Trait2. Illegal"}]}