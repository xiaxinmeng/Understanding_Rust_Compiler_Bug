{"sha": "7a2f4468892a9bf694b844f1fa1032779320c7e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMmY0NDY4ODkyYTliZjY5NGI4NDRmMWZhMTAzMjc3OTMyMGM3ZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-09T16:19:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-09T16:19:21Z"}, "message": "Auto merge of #83894 - nikic:newpm, r=nagisa\n\nImprove support for NewPM\n\nThis adds various missing bits of support for NewPM and allows us to successfully run stage 2 tests with NewPM enabled.\n\nThis does not yet enable NewPM by default, as there are still known issue on LLVM 12 (such as a weak fat LTO pipeline). The plan is to make the switch after we update to LLVM 13.", "tree": {"sha": "424cb36ea9020f0ddd58207c2117607670595a12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/424cb36ea9020f0ddd58207c2117607670595a12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a2f4468892a9bf694b844f1fa1032779320c7e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a2f4468892a9bf694b844f1fa1032779320c7e5", "html_url": "https://github.com/rust-lang/rust/commit/7a2f4468892a9bf694b844f1fa1032779320c7e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a2f4468892a9bf694b844f1fa1032779320c7e5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bba8710616e5e4722215c0d6b27abaedca03ebad", "url": "https://api.github.com/repos/rust-lang/rust/commits/bba8710616e5e4722215c0d6b27abaedca03ebad", "html_url": "https://github.com/rust-lang/rust/commit/bba8710616e5e4722215c0d6b27abaedca03ebad"}, {"sha": "1b928ff8f8b069f45fde420dabf34d9c53b9cb3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b928ff8f8b069f45fde420dabf34d9c53b9cb3a", "html_url": "https://github.com/rust-lang/rust/commit/1b928ff8f8b069f45fde420dabf34d9c53b9cb3a"}], "stats": {"total": 194, "additions": 113, "deletions": 81}, "files": [{"sha": "f612785e5a416c582321e4efa0b7c1aec41e91b6", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -568,10 +568,11 @@ fn thin_lto(\n \n pub(crate) fn run_pass_manager(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n     thin: bool,\n-) {\n+) -> Result<(), FatalError> {\n     let _timer = cgcx.prof.extra_verbose_generic_activity(\"LLVM_lto_optimize\", &module.name[..]);\n \n     // Now we have one massive module inside of llmod. Time to run the\n@@ -584,15 +585,16 @@ pub(crate) fn run_pass_manager(\n         if write::should_use_new_llvm_pass_manager(config) {\n             let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n             let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n-            // See comment below for why this is necessary.\n-            let opt_level = if let config::OptLevel::No = opt_level {\n-                config::OptLevel::Less\n-            } else {\n-                opt_level\n-            };\n-            write::optimize_with_new_llvm_pass_manager(cgcx, module, config, opt_level, opt_stage);\n+            write::optimize_with_new_llvm_pass_manager(\n+                cgcx,\n+                diag_handler,\n+                module,\n+                config,\n+                opt_level,\n+                opt_stage,\n+            )?;\n             debug!(\"lto done\");\n-            return;\n+            return Ok(());\n         }\n \n         let pm = llvm::LLVMCreatePassManager();\n@@ -603,26 +605,10 @@ pub(crate) fn run_pass_manager(\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        // When optimizing for LTO we don't actually pass in `-O0`, but we force\n-        // it to always happen at least with `-O1`.\n-        //\n-        // With ThinLTO we mess around a lot with symbol visibility in a way\n-        // that will actually cause linking failures if we optimize at O0 which\n-        // notable is lacking in dead code elimination. To ensure we at least\n-        // get some optimizations and correctly link we forcibly switch to `-O1`\n-        // to get dead code elimination.\n-        //\n-        // Note that in general this shouldn't matter too much as you typically\n-        // only turn on ThinLTO when you're compiling with optimizations\n-        // otherwise.\n         let opt_level = config\n             .opt_level\n             .map(|x| to_llvm_opt_settings(x).0)\n             .unwrap_or(llvm::CodeGenOptLevel::None);\n-        let opt_level = match opt_level {\n-            llvm::CodeGenOptLevel::None => llvm::CodeGenOptLevel::Less,\n-            level => level,\n-        };\n         with_llvm_pmb(module.module_llvm.llmod(), config, opt_level, false, &mut |b| {\n             if thin {\n                 llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm);\n@@ -650,6 +636,7 @@ pub(crate) fn run_pass_manager(\n         llvm::LLVMDisposePassManager(pm);\n     }\n     debug!(\"lto done\");\n+    Ok(())\n }\n \n pub struct ModuleBuffer(&'static mut llvm::ModuleBuffer);\n@@ -872,7 +859,7 @@ pub unsafe fn optimize_thin_module(\n         {\n             info!(\"running thin lto passes over {}\", module.name);\n             let config = cgcx.config(module.kind);\n-            run_pass_manager(cgcx, &module, config, true);\n+            run_pass_manager(cgcx, &diag_handler, &module, config, true)?;\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-pm\");\n         }\n     }"}, {"sha": "4219797c5cdd0b007bb485025108cf292133bb61", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -410,16 +410,17 @@ fn get_pgo_use_path(config: &ModuleConfig) -> Option<CString> {\n \n pub(crate) fn should_use_new_llvm_pass_manager(config: &ModuleConfig) -> bool {\n     // The new pass manager is disabled by default.\n-    config.new_llvm_pass_manager\n+    config.new_llvm_pass_manager.unwrap_or(false)\n }\n \n pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n     opt_level: config::OptLevel,\n     opt_stage: llvm::OptStage,\n-) {\n+) -> Result<(), FatalError> {\n     let unroll_loops =\n         opt_level != config::OptLevel::Size && opt_level != config::OptLevel::SizeMin;\n     let using_thin_buffers = opt_stage == llvm::OptStage::PreLinkThinLTO || config.bitcode_needed();\n@@ -449,13 +450,12 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n         std::ptr::null_mut()\n     };\n \n+    let extra_passes = config.passes.join(\",\");\n+\n     // FIXME: NewPM doesn't provide a facility to pass custom InlineParams.\n     // We would have to add upstream support for this first, before we can support\n     // config.inline_threshold and our more aggressive default thresholds.\n-    // FIXME: NewPM uses an different and more explicit way to textually represent\n-    // pass pipelines. It would probably make sense to expose this, but it would\n-    // require a different format than the current -C passes.\n-    llvm::LLVMRustOptimizeWithNewPassManager(\n+    let result = llvm::LLVMRustOptimizeWithNewPassManager(\n         module.module_llvm.llmod(),\n         &*module.module_llvm.tm,\n         to_pass_builder_opt_level(opt_level),\n@@ -472,10 +472,15 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n         sanitizer_options.as_ref(),\n         pgo_gen_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n         pgo_use_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n+        config.instrument_coverage,\n+        config.instrument_gcov,\n         llvm_selfprofiler,\n         selfprofile_before_pass_callback,\n         selfprofile_after_pass_callback,\n+        extra_passes.as_ptr().cast(),\n+        extra_passes.len(),\n     );\n+    result.into_result().map_err(|()| llvm_err(diag_handler, \"failed to run LLVM passes\"))\n }\n \n // Unsafe due to LLVM calls.\n@@ -484,7 +489,7 @@ pub(crate) unsafe fn optimize(\n     diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n-) {\n+) -> Result<(), FatalError> {\n     let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_optimize\", &module.name[..]);\n \n     let llmod = module.module_llvm.llmod();\n@@ -509,8 +514,14 @@ pub(crate) unsafe fn optimize(\n                 _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n                 _ => llvm::OptStage::PreLinkNoLTO,\n             };\n-            optimize_with_new_llvm_pass_manager(cgcx, module, config, opt_level, opt_stage);\n-            return;\n+            return optimize_with_new_llvm_pass_manager(\n+                cgcx,\n+                diag_handler,\n+                module,\n+                config,\n+                opt_level,\n+                opt_stage,\n+            );\n         }\n \n         if cgcx.prof.llvm_recording_enabled() {\n@@ -545,15 +556,6 @@ pub(crate) unsafe fn optimize(\n                     llvm::LLVMRustAddPass(fpm, find_pass(\"lint\").unwrap());\n                     continue;\n                 }\n-                if pass_name == \"insert-gcov-profiling\" || pass_name == \"instrprof\" {\n-                    // Instrumentation must be inserted before optimization,\n-                    // otherwise LLVM may optimize some functions away which\n-                    // breaks llvm-cov.\n-                    //\n-                    // This mirrors what Clang does in lib/CodeGen/BackendUtil.cpp.\n-                    llvm::LLVMRustAddPass(mpm, find_pass(pass_name).unwrap());\n-                    continue;\n-                }\n \n                 if let Some(pass) = find_pass(pass_name) {\n                     extra_passes.push(pass);\n@@ -566,6 +568,18 @@ pub(crate) unsafe fn optimize(\n                 }\n             }\n \n+            // Instrumentation must be inserted before optimization,\n+            // otherwise LLVM may optimize some functions away which\n+            // breaks llvm-cov.\n+            //\n+            // This mirrors what Clang does in lib/CodeGen/BackendUtil.cpp.\n+            if config.instrument_gcov {\n+                llvm::LLVMRustAddPass(mpm, find_pass(\"insert-gcov-profiling\").unwrap());\n+            }\n+            if config.instrument_coverage {\n+                llvm::LLVMRustAddPass(mpm, find_pass(\"instrprof\").unwrap());\n+            }\n+\n             add_sanitizer_passes(config, &mut extra_passes);\n \n             // Some options cause LLVM bitcode to be emitted, which uses ThinLTOBuffers, so we need\n@@ -642,6 +656,7 @@ pub(crate) unsafe fn optimize(\n         llvm::LLVMDisposePassManager(fpm);\n         llvm::LLVMDisposePassManager(mpm);\n     }\n+    Ok(())\n }\n \n unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static mut llvm::Pass>) {"}, {"sha": "bc35aa72965681b9a7bab3532cdd50813049bb67", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -162,7 +162,7 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n         module: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n     ) -> Result<(), FatalError> {\n-        Ok(back::write::optimize(cgcx, diag_handler, module, config))\n+        back::write::optimize(cgcx, diag_handler, module, config)\n     }\n     unsafe fn optimize_thin(\n         cgcx: &CodegenContext<Self>,\n@@ -189,8 +189,9 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n         module: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n         thin: bool,\n-    ) {\n-        back::lto::run_pass_manager(cgcx, module, config, thin)\n+    ) -> Result<(), FatalError> {\n+        let diag_handler = cgcx.create_diag_handler();\n+        back::lto::run_pass_manager(cgcx, &diag_handler, module, config, thin)\n     }\n }\n "}, {"sha": "32fdde9b42e5f0c3abc69eb506e5209b97211758", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -2203,10 +2203,14 @@ extern \"C\" {\n         SanitizerOptions: Option<&SanitizerOptions>,\n         PGOGenPath: *const c_char,\n         PGOUsePath: *const c_char,\n+        InstrumentCoverage: bool,\n+        InstrumentGCOV: bool,\n         llvm_selfprofiler: *mut c_void,\n         begin_callback: SelfProfileBeforePassCallback,\n         end_callback: SelfProfileAfterPassCallback,\n-    );\n+        ExtraPasses: *const c_char,\n+        ExtraPassesLen: size_t,\n+    ) -> LLVMRustResult;\n     pub fn LLVMRustPrintModule(\n         M: &'a Module,\n         Output: *const c_char,"}, {"sha": "d6ae689f254b1508b2f48d7ce75b5378ce43838f", "filename": "compiler/rustc_codegen_ssa/src/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -72,7 +72,7 @@ impl<B: WriteBackendMethods> LtoModuleCodegen<B> {\n                 let module = module.take().unwrap();\n                 {\n                     let config = cgcx.config(module.kind);\n-                    B::run_lto_pass_manager(cgcx, &module, config, false);\n+                    B::run_lto_pass_manager(cgcx, &module, config, false)?;\n                 }\n                 Ok(module)\n             }"}, {"sha": "0dfb007a2473e31a6fc135add423bcc8475f9282", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -84,6 +84,8 @@ pub struct ModuleConfig {\n \n     pub pgo_gen: SwitchWithOptPath,\n     pub pgo_use: Option<PathBuf>,\n+    pub instrument_coverage: bool,\n+    pub instrument_gcov: bool,\n \n     pub sanitizer: SanitizerSet,\n     pub sanitizer_recover: SanitizerSet,\n@@ -108,7 +110,7 @@ pub struct ModuleConfig {\n     pub vectorize_slp: bool,\n     pub merge_functions: bool,\n     pub inline_threshold: Option<u32>,\n-    pub new_llvm_pass_manager: bool,\n+    pub new_llvm_pass_manager: Option<bool>,\n     pub emit_lifetime_markers: bool,\n }\n \n@@ -165,25 +167,7 @@ impl ModuleConfig {\n         };\n \n         ModuleConfig {\n-            passes: if_regular!(\n-                {\n-                    let mut passes = sess.opts.cg.passes.clone();\n-                    // compiler_builtins overrides the codegen-units settings,\n-                    // which is incompatible with -Zprofile which requires that\n-                    // only a single codegen unit is used per crate.\n-                    if sess.opts.debugging_opts.profile && !is_compiler_builtins {\n-                        passes.push(\"insert-gcov-profiling\".to_owned());\n-                    }\n-\n-                    // The rustc option `-Zinstrument_coverage` injects intrinsic calls to\n-                    // `llvm.instrprof.increment()`, which requires the LLVM `instrprof` pass.\n-                    if sess.instrument_coverage() {\n-                        passes.push(\"instrprof\".to_owned());\n-                    }\n-                    passes\n-                },\n-                vec![]\n-            ),\n+            passes: if_regular!(sess.opts.cg.passes.clone(), vec![]),\n \n             opt_level: opt_level_and_size,\n             opt_size: opt_level_and_size,\n@@ -193,6 +177,14 @@ impl ModuleConfig {\n                 SwitchWithOptPath::Disabled\n             ),\n             pgo_use: if_regular!(sess.opts.cg.profile_use.clone(), None),\n+            instrument_coverage: if_regular!(sess.instrument_coverage(), false),\n+            instrument_gcov: if_regular!(\n+                // compiler_builtins overrides the codegen-units settings,\n+                // which is incompatible with -Zprofile which requires that\n+                // only a single codegen unit is used per crate.\n+                sess.opts.debugging_opts.profile && !is_compiler_builtins,\n+                false\n+            ),\n \n             sanitizer: if_regular!(sess.opts.debugging_opts.sanitizer, SanitizerSet::empty()),\n             sanitizer_recover: if_regular!("}, {"sha": "93fbee2b49bb57a84c9921982cf00e5543e6e15a", "filename": "compiler/rustc_codegen_ssa/src/traits/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -58,7 +58,7 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n         llmod: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n         thin: bool,\n-    );\n+    ) -> Result<(), FatalError>;\n }\n \n pub trait ThinBufferMethods: Send + Sync {"}, {"sha": "fd13cb3d59acd203b48255f5f09ca60c4ffc574e", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -709,7 +709,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(mir_emit_retag, true);\n     tracked!(mir_opt_level, Some(4));\n     tracked!(mutable_noalias, Some(true));\n-    tracked!(new_llvm_pass_manager, true);\n+    tracked!(new_llvm_pass_manager, Some(true));\n     tracked!(no_codegen, true);\n     tracked!(no_generate_arange_section, true);\n     tracked!(no_link, true);"}, {"sha": "99ce13a6ed59c8b95ba939a84a904f4fe9adc639", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -32,6 +32,8 @@\n #include \"llvm/Transforms/Instrumentation.h\"\n #include \"llvm/Transforms/Instrumentation/AddressSanitizer.h\"\n #include \"llvm/Support/TimeProfiler.h\"\n+#include \"llvm/Transforms/Instrumentation/GCOVProfiler.h\"\n+#include \"llvm/Transforms/Instrumentation/InstrProfiling.h\"\n #include \"llvm/Transforms/Instrumentation/ThreadSanitizer.h\"\n #include \"llvm/Transforms/Instrumentation/MemorySanitizer.h\"\n #include \"llvm/Transforms/Instrumentation/HWAddressSanitizer.h\"\n@@ -734,7 +736,7 @@ struct LLVMRustSanitizerOptions {\n   bool SanitizeHWAddressRecover;\n };\n \n-extern \"C\" void\n+extern \"C\" LLVMRustResult\n LLVMRustOptimizeWithNewPassManager(\n     LLVMModuleRef ModuleRef,\n     LLVMTargetMachineRef TMRef,\n@@ -745,9 +747,11 @@ LLVMRustOptimizeWithNewPassManager(\n     bool DisableSimplifyLibCalls, bool EmitLifetimeMarkers,\n     LLVMRustSanitizerOptions *SanitizerOptions,\n     const char *PGOGenPath, const char *PGOUsePath,\n+    bool InstrumentCoverage, bool InstrumentGCOV,\n     void* LlvmSelfProfiler,\n     LLVMRustSelfProfileBeforePassCallback BeforePassCallback,\n-    LLVMRustSelfProfileAfterPassCallback AfterPassCallback) {\n+    LLVMRustSelfProfileAfterPassCallback AfterPassCallback,\n+    const char *ExtraPasses, size_t ExtraPassesLen) {\n   Module *TheModule = unwrap(ModuleRef);\n   TargetMachine *TM = unwrap(TMRef);\n   PassBuilder::OptimizationLevel OptLevel = fromRust(OptLevelRust);\n@@ -834,6 +838,23 @@ LLVMRustOptimizeWithNewPassManager(\n     );\n   }\n \n+  if (InstrumentGCOV) {\n+    PipelineStartEPCallbacks.push_back(\n+      [](ModulePassManager &MPM, PassBuilder::OptimizationLevel Level) {\n+        MPM.addPass(GCOVProfilerPass(GCOVOptions::getDefault()));\n+      }\n+    );\n+  }\n+\n+  if (InstrumentCoverage) {\n+    PipelineStartEPCallbacks.push_back(\n+      [](ModulePassManager &MPM, PassBuilder::OptimizationLevel Level) {\n+        InstrProfOptions Options;\n+        MPM.addPass(InstrProfiling(Options, false));\n+      }\n+    );\n+  }\n+\n   if (SanitizerOptions) {\n     if (SanitizerOptions->SanitizeMemory) {\n       MemorySanitizerOptions Options(\n@@ -1042,6 +1063,14 @@ LLVMRustOptimizeWithNewPassManager(\n     }\n   }\n \n+  if (ExtraPassesLen) {\n+    if (auto Err = PB.parsePassPipeline(MPM, StringRef(ExtraPasses, ExtraPassesLen))) {\n+      std::string ErrMsg = toString(std::move(Err));\n+      LLVMRustSetLastError(ErrMsg.c_str());\n+      return LLVMRustResult::Failure;\n+    }\n+  }\n+\n   if (NeedThinLTOBufferPasses) {\n     MPM.addPass(CanonicalizeAliasesPass());\n     MPM.addPass(NameAnonGlobalPass());\n@@ -1052,6 +1081,7 @@ LLVMRustOptimizeWithNewPassManager(\n     UpgradeCallsToIntrinsic(&*I++); // must be post-increment, as we remove\n \n   MPM.run(*TheModule, MAM);\n+  return LLVMRustResult::Success;\n }\n \n // Callback to demangle function name"}, {"sha": "da6e2af276053eb1c68ce532c25eb4dc8d4203ac", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -1112,7 +1112,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"MIR optimization level (0-4; default: 1 in non optimized builds and 2 in optimized builds)\"),\n     mutable_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"emit noalias metadata for mutable references (default: yes for LLVM >= 12, otherwise no)\"),\n-    new_llvm_pass_manager: bool = (false, parse_bool, [TRACKED],\n+    new_llvm_pass_manager: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"use new LLVM pass manager (default: no)\"),\n     nll_facts: bool = (false, parse_bool, [UNTRACKED],\n         \"dump facts from NLL analysis into side files (default: no)\"),"}, {"sha": "c78cf18a07f19faa3e51f15220bca39f47d437e0", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -1 +1 @@\n-Subproject commit b61c24f3521303d442fa86fe691bc8e6acc15103\n+Subproject commit c78cf18a07f19faa3e51f15220bca39f47d437e0"}, {"sha": "b976c3a13bd5927f37ab09a2d72c5dd5a5176b7c", "filename": "src/test/ui/backtrace-debuginfo.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/src%2Ftest%2Fui%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/src%2Ftest%2Fui%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbacktrace-debuginfo.rs?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -6,16 +6,11 @@\n // Unfortunately, LLVM has no \"disable\" option for this, so we have to set\n // \"enable\" to 0 instead.\n \n-// compile-flags:-g -Cllvm-args=-enable-tail-merge=0 -Cllvm-args=-opt-bisect-limit=0\n+// compile-flags:-g -Copt-level=0 -Cllvm-args=-enable-tail-merge=0\n // compile-flags:-Cforce-frame-pointers=yes\n // ignore-pretty issue #37195\n // ignore-emscripten spawning processes is not supported\n // ignore-sgx no processes\n-// normalize-stderr-test \".*\\n\" -> \"\"\n-\n-// Note that above `-opt-bisect-limit=0` is used to basically disable\n-// optimizations. It creates tons of output on stderr, hence we normalize\n-// that away entirely.\n \n use std::env;\n "}, {"sha": "ca3c6230af04a57d8bc66eaf440b136ac48cc40d", "filename": "src/test/ui/invalid/invalid-llvm-passes.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/src%2Ftest%2Fui%2Finvalid%2Finvalid-llvm-passes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/src%2Ftest%2Fui%2Finvalid%2Finvalid-llvm-passes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-llvm-passes.rs?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -0,0 +1,4 @@\n+// build-fail\n+// compile-flags: -Cpasses=unknown-pass -Z new-llvm-pass-manager=yes\n+\n+fn main() {}"}, {"sha": "ae1f85e41e410768295a2fdf4e19af289a9dbf47", "filename": "src/test/ui/invalid/invalid-llvm-passes.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a2f4468892a9bf694b844f1fa1032779320c7e5/src%2Ftest%2Fui%2Finvalid%2Finvalid-llvm-passes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a2f4468892a9bf694b844f1fa1032779320c7e5/src%2Ftest%2Fui%2Finvalid%2Finvalid-llvm-passes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-llvm-passes.stderr?ref=7a2f4468892a9bf694b844f1fa1032779320c7e5", "patch": "@@ -0,0 +1,4 @@\n+error: failed to run LLVM passes: unknown pass name 'unknown-pass'\n+\n+error: aborting due to previous error\n+"}]}