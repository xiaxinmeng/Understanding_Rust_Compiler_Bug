{"sha": "c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ZjA5ODBkMmVhNDNkM2FiN2UwY2YxNGZlZTgxZGU4ZGY1Yzg2N2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-08T21:16:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-08T21:16:41Z"}, "message": "auto merge of #13990 : nikomatsakis/rust/issue-5527-cleanup-writeback, r=pcwalton\n\nAs part of #5527 I had to make some changes here and I just couldn't take it anymore. Refactor the writeback code. Should be functionally equivalent to the old stuff.\r\n\r\nr? @pcwalton", "tree": {"sha": "e8cf5f8503eb07fc84ae22a40bc2f33fdadf2266", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8cf5f8503eb07fc84ae22a40bc2f33fdadf2266"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a", "html_url": "https://github.com/rust-lang/rust/commit/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8781b36fc0e4518ebc732a874f57cf9bfdcaed3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8781b36fc0e4518ebc732a874f57cf9bfdcaed3", "html_url": "https://github.com/rust-lang/rust/commit/d8781b36fc0e4518ebc732a874f57cf9bfdcaed3"}, {"sha": "683d6646cec22312ed643711eb8d909f96561fde", "url": "https://api.github.com/repos/rust-lang/rust/commits/683d6646cec22312ed643711eb8d909f96561fde", "html_url": "https://github.com/rust-lang/rust/commit/683d6646cec22312ed643711eb8d909f96561fde"}], "stats": {"total": 714, "additions": 416, "deletions": 298}, "files": [{"sha": "86291a7d6cb3e6a98d9743182d35442ee9573725", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a", "patch": "@@ -71,6 +71,10 @@ pub trait TypeFolder {\n     fn fold_trait_store(&mut self, s: ty::TraitStore) -> ty::TraitStore {\n         super_fold_trait_store(self, s)\n     }\n+\n+    fn fold_autoref(&mut self, ar: &ty::AutoRef) -> ty::AutoRef {\n+        super_fold_autoref(self, ar)\n+    }\n }\n \n pub fn fold_opt_ty<T:TypeFolder>(this: &mut T,\n@@ -200,6 +204,19 @@ pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n     }\n }\n \n+pub fn super_fold_autoref<T:TypeFolder>(this: &mut T,\n+                                        autoref: &ty::AutoRef)\n+                                        -> ty::AutoRef\n+{\n+    match *autoref {\n+        ty::AutoPtr(r, m) => ty::AutoPtr(this.fold_region(r), m),\n+        ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(this.fold_region(r), m),\n+        ty::AutoBorrowVecRef(r, m) => ty::AutoBorrowVecRef(this.fold_region(r), m),\n+        ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n+        ty::AutoBorrowObj(r, m) => ty::AutoBorrowObj(this.fold_region(r), m),\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n "}, {"sha": "bf5874e133661f7b0a0aaddb3a0dc715d7b92043", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a", "patch": "@@ -221,6 +221,10 @@ enum IsBinopAssignment{\n \n #[deriving(Clone)]\n pub struct FnCtxt<'a> {\n+    // This flag is set to true if, during the writeback phase, we encounter\n+    // a type error in this function.\n+    writeback_errors: Cell<bool>,\n+\n     // Number of errors that had been reported when we started\n     // checking this function. On exit, if we find that *more* errors\n     // have been reported, we will skip regionck and other work that\n@@ -280,6 +284,7 @@ fn blank_fn_ctxt<'a>(ccx: &'a CrateCtxt<'a>,\n                      region_bnd: ast::NodeId)\n                      -> FnCtxt<'a> {\n     FnCtxt {\n+        writeback_errors: Cell::new(false),\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n         ps: RefCell::new(FnStyleState::function(ast::NormalFn, 0)),\n@@ -469,6 +474,7 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n     let fcx = FnCtxt {\n+        writeback_errors: Cell::new(false),\n         err_count_on_creation: err_count_on_creation,\n         ret_ty: ret_ty,\n         ps: RefCell::new(FnStyleState::function(fn_style, id)),\n@@ -1198,11 +1204,10 @@ impl<'a> FnCtxt<'a> {\n \n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n-                              f: |&ty::substs| -> bool)\n-                              -> bool {\n+                              f: |&ty::substs|) {\n         match self.inh.node_type_substs.borrow().find(&id) {\n-            Some(s) => f(s),\n-            None => true\n+            Some(s) => { f(s) }\n+            None => { }\n         }\n     }\n "}, {"sha": "f2d6171cc639265465f6ef6efc15d72c29585efd", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a", "patch": "@@ -644,7 +644,6 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                     insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n                 }\n             }\n-            true\n         });\n       }\n "}, {"sha": "77429118a2c457cced57ab82c64f8aa3e0f10033", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 390, "deletions": 292, "changes": 682, "blob_url": "https://github.com/rust-lang/rust/blob/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a", "patch": "@@ -15,16 +15,16 @@\n \n use middle::pat_util;\n use middle::ty;\n+use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::{MethodCall, MethodCallee};\n-use middle::typeck::{vtable_res, vtable_static, vtable_param};\n+use middle::typeck::{vtable_origin, vtable_static, vtable_param};\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n-use util::ppaux;\n use util::ppaux::Repr;\n \n use syntax::ast;\n@@ -33,357 +33,455 @@ use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-fn resolve_type_vars_in_type(fcx: &FnCtxt, sp: Span, typ: ty::t)\n-                          -> Option<ty::t> {\n-    if !ty::type_needs_infer(typ) { return Some(typ); }\n-    match resolve_type(fcx.infcx(), typ, resolve_all | force_all) {\n-        Ok(new_type) => return Some(new_type),\n-        Err(e) => {\n-            if !fcx.ccx.tcx.sess.has_errors() {\n-                fcx.ccx.tcx.sess.span_err(\n-                    sp,\n-                    format!(\"cannot determine a type \\\n-                          for this expression: {}\",\n-                         infer::fixup_err_to_str(e)))\n-            }\n-            return None;\n+///////////////////////////////////////////////////////////////////////////\n+// Entry point functions\n+\n+pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) {\n+    assert_eq!(fcx.writeback_errors.get(), false);\n+    let mut wbcx = WritebackCx::new(fcx);\n+    wbcx.visit_expr(e, ());\n+    wbcx.visit_upvar_borrow_map();\n+}\n+\n+pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n+                               decl: &ast::FnDecl,\n+                               blk: &ast::Block) {\n+    assert_eq!(fcx.writeback_errors.get(), false);\n+    let mut wbcx = WritebackCx::new(fcx);\n+    wbcx.visit_block(blk, ());\n+    for arg in decl.inputs.iter() {\n+        wbcx.visit_pat(arg.pat, ());\n+\n+        // Privacy needs the type for the whole pattern, not just each binding\n+        if !pat_util::pat_is_binding(&fcx.tcx().def_map, arg.pat) {\n+            wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n+                               arg.pat.id);\n         }\n     }\n+    wbcx.visit_upvar_borrow_map();\n }\n \n-fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, method_call: MethodCall) {\n-    let fcx = wbcx.fcx;\n-    let tcx = fcx.ccx.tcx;\n-\n-    // Resolve any method map entry\n-    match fcx.inh.method_map.borrow_mut().pop(&method_call) {\n-        Some(method) => {\n-            debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n-                   method_call, method.repr(tcx));\n-            let new_method = MethodCallee {\n-                origin: method.origin,\n-                ty: match resolve_type_vars_in_type(fcx, sp, method.ty) {\n-                    Some(t) => t,\n-                    None => {\n-                        wbcx.success = false;\n-                        return;\n-                    }\n-                },\n-                substs: ty::substs {\n-                    tps: method.substs.tps.move_iter().map(|subst| {\n-                        match resolve_type_vars_in_type(fcx, sp, subst) {\n-                            Some(t) => t,\n-                            None => { wbcx.success = false; ty::mk_err() }\n-                        }\n-                    }).collect(),\n-                    regions: ty::ErasedRegions,\n-                    self_ty: None\n-                }\n-            };\n-            tcx.method_map.borrow_mut().insert(method_call, new_method);\n-        }\n-        None => {}\n+///////////////////////////////////////////////////////////////////////////\n+// The Writerback context. This visitor walks the AST, checking the\n+// fn-specific tables to find references to types or regions. It\n+// resolves those regions to remove inference variables and writes the\n+// final result back into the master tables in the tcx. Here and\n+// there, it applies a few ad-hoc checks that were not convenient to\n+// do elsewhere.\n+\n+struct WritebackCx<'cx> {\n+    fcx: &'cx FnCtxt<'cx>,\n+}\n+\n+impl<'cx> WritebackCx<'cx> {\n+    fn new(fcx: &'cx FnCtxt) -> WritebackCx<'cx> {\n+        WritebackCx { fcx: fcx }\n+    }\n+\n+    fn tcx(&self) -> &'cx ty::ctxt {\n+        self.fcx.tcx()\n     }\n }\n \n-fn resolve_vtable_map_entry(fcx: &FnCtxt, sp: Span, vtable_key: MethodCall) {\n-    // Resolve any vtable map entry\n-    match fcx.inh.vtable_map.borrow_mut().pop(&vtable_key) {\n-        Some(origins) => {\n-            let r_origins = resolve_origins(fcx, sp, origins);\n-            debug!(\"writeback::resolve_vtable_map_entry(vtable_key={}, vtables={:?})\",\n-                    vtable_key, r_origins.repr(fcx.tcx()));\n-            fcx.tcx().vtable_map.borrow_mut().insert(vtable_key, r_origins);\n+///////////////////////////////////////////////////////////////////////////\n+// Impl of Visitor for Resolver\n+//\n+// This is the master code which walks the AST. It delegates most of\n+// the heavy lifting to the generic visit and resolve functions\n+// below. In general, a function is made into a `visitor` if it must\n+// traffic in node-ids or update tables in the type context etc.\n+\n+impl<'cx> Visitor<()> for WritebackCx<'cx> {\n+    fn visit_item(&mut self, _: &ast::Item, _: ()) {\n+        // Ignore items\n+    }\n+\n+    fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) {\n+        if self.fcx.writeback_errors.get() {\n+            return;\n         }\n-        None => {}\n+\n+        self.visit_node_id(ResolvingExpr(s.span), ty::stmt_node_id(s));\n+        visit::walk_stmt(self, s, ());\n     }\n \n-    fn resolve_origins(fcx: &FnCtxt, sp: Span,\n-                       vtbls: vtable_res) -> vtable_res {\n-        vtbls.move_iter().map(|os| os.move_iter().map(|origin| {\n-            match origin {\n-                vtable_static(def_id, tys, origins) => {\n-                    let r_tys = tys.move_iter().map(|t| {\n-                        match resolve_type_vars_in_type(fcx, sp, t) {\n-                            Some(t1) => t1,\n-                            None => ty::mk_err()\n-                        }\n-                    }).collect();\n-                    let r_origins = resolve_origins(fcx, sp, origins);\n-                    vtable_static(def_id, r_tys, r_origins)\n+    fn visit_expr(&mut self, e:&ast::Expr, _: ()) {\n+        if self.fcx.writeback_errors.get() {\n+            return;\n+        }\n+\n+        self.visit_node_id(ResolvingExpr(e.span), e.id);\n+        self.visit_method_map_entry(ResolvingExpr(e.span),\n+                                    MethodCall::expr(e.id));\n+        self.visit_vtable_map_entry(ResolvingExpr(e.span),\n+                                    MethodCall::expr(e.id));\n+\n+        match e.node {\n+            ast::ExprFnBlock(ref decl, _) | ast::ExprProc(ref decl, _) => {\n+                for input in decl.inputs.iter() {\n+                    let _ = self.visit_node_id(ResolvingExpr(e.span),\n+                                               input.id);\n                 }\n-                vtable_param(n, b) => vtable_param(n, b)\n             }\n-        }).collect()).collect()\n+            _ => {}\n+        }\n+\n+        visit::walk_expr(self, e, ());\n     }\n-}\n \n-fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n-    let fcx = wbcx.fcx;\n-    let tcx = fcx.ccx.tcx;\n-\n-    // Resolve any borrowings for the node with id `id`\n-    let resolved_adj = match fcx.inh.adjustments.borrow_mut().pop(&id) {\n-        None => None,\n-\n-        Some(adjustment) => {\n-            Some(match adjustment {\n-                ty::AutoAddEnv(store) => {\n-                    let r = match store {\n-                        ty::RegionTraitStore(r, _) => r,\n-                        ty::UniqTraitStore => ty::ReStatic\n-                    };\n-                    match resolve_region(fcx.infcx(),\n-                                         r,\n-                                         resolve_all | force_all) {\n-                        Err(e) => {\n-                            // This should not, I think, happen:\n-                            tcx.sess.span_err(\n-                                sp,\n-                                format!(\"cannot resolve bound for closure: \\\n-                                         {}\",\n-                                        infer::fixup_err_to_str(e)));\n-                            wbcx.success = false;\n-                            return;\n-                        }\n-                        Ok(r1) => {\n-                            // FIXME(eddyb) #2190 Allow only statically resolved\n-                            // bare functions to coerce to a closure to avoid\n-                            // constructing (slower) indirect call wrappers.\n-                            match tcx.def_map.borrow().find(&id) {\n-                                Some(&ast::DefFn(..)) |\n-                                Some(&ast::DefStaticMethod(..)) |\n-                                Some(&ast::DefVariant(..)) |\n-                                Some(&ast::DefStruct(_)) => {}\n-                                _ => tcx.sess.span_err(sp,\n-                                        \"cannot coerce non-statically resolved bare fn\")\n-                            }\n+    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n+        if self.fcx.writeback_errors.get() {\n+            return;\n+        }\n \n-                            ty::AutoAddEnv(match store {\n-                                ty::RegionTraitStore(..) => {\n-                                    ty::RegionTraitStore(r1, ast::MutMutable)\n-                                }\n-                                ty::UniqTraitStore => ty::UniqTraitStore\n-                            })\n-                        }\n-                    }\n-                }\n+        self.visit_node_id(ResolvingExpr(b.span), b.id);\n+        visit::walk_block(self, b, ());\n+    }\n \n-                ty::AutoDerefRef(adj) => {\n-                    for autoderef in range(0, adj.autoderefs) {\n-                        let method_call = MethodCall::autoderef(id, autoderef as u32);\n-                        resolve_method_map_entry(wbcx, sp, method_call);\n-                        resolve_vtable_map_entry(wbcx.fcx, sp, method_call);\n-                    }\n+    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n+        if self.fcx.writeback_errors.get() {\n+            return;\n+        }\n \n-                    ty::AutoDerefRef(ty::AutoDerefRef {\n-                        autoderefs: adj.autoderefs,\n-                        autoref: adj.autoref.map(|r| r.map_region(|r| {\n-                            match resolve_region(fcx.infcx(), r,\n-                                                resolve_all | force_all) {\n-                                Ok(r1) => r1,\n-                                Err(e) => {\n-                                    // This should not, I think, happen.\n-                                    tcx.sess.span_err(\n-                                        sp,\n-                                        format!(\"cannot resolve scope of borrow: \\\n-                                                {}\",\n-                                                infer::fixup_err_to_str(e)));\n-                                    r\n-                                }\n-                            }\n-                        })),\n-                    })\n-                }\n+        self.visit_node_id(ResolvingPattern(p.span), p.id);\n+\n+        debug!(\"Type for pattern binding {} (id {}) resolved to {}\",\n+               pat_to_str(p),\n+               p.id,\n+               ty::node_id_to_type(self.tcx(), p.id).repr(self.tcx()));\n+\n+        visit::walk_pat(self, p, ());\n+    }\n \n-                adjustment => adjustment\n-            })\n+    fn visit_local(&mut self, l: &ast::Local, _: ()) {\n+        if self.fcx.writeback_errors.get() {\n+            return;\n         }\n-    };\n \n-    debug!(\"Adjustments for node {}: {:?}\",\n-           id, resolved_adj);\n-    match resolved_adj {\n-        Some(adj) => {\n-            tcx.adjustments.borrow_mut().insert(id, adj);\n+        let var_ty = self.fcx.local_ty(l.span, l.id);\n+        let var_ty = var_ty.resolve(self.fcx, ResolvingLocal(l.span));\n+        write_ty_to_tcx(self.tcx(), l.id, var_ty);\n+        visit::walk_local(self, l, ());\n+    }\n+\n+    fn visit_ty(&mut self, _t: &ast::Ty, _: ()) {\n+        // ignore\n+    }\n+}\n+\n+impl<'cx> WritebackCx<'cx> {\n+    fn visit_upvar_borrow_map(&self) {\n+        if self.fcx.writeback_errors.get() {\n+            return;\n+        }\n+\n+        for (upvar_id, upvar_borrow) in self.fcx.inh.upvar_borrow_map.borrow().iter() {\n+            let r = upvar_borrow.region;\n+            let r = r.resolve(self.fcx, ResolvingUpvar(*upvar_id));\n+            let new_upvar_borrow = ty::UpvarBorrow { kind: upvar_borrow.kind,\n+                                                     region: r };\n+            debug!(\"Upvar borrow for {} resolved to {}\",\n+                   upvar_id.repr(self.tcx()),\n+                   new_upvar_borrow.repr(self.tcx()));\n+            self.fcx.tcx().upvar_borrow_map.borrow_mut().insert(\n+                *upvar_id, new_upvar_borrow);\n         }\n-        None => {}\n     }\n \n-    // Resolve the type of the node with id `id`\n-    let n_ty = fcx.node_ty(id);\n-    match resolve_type_vars_in_type(fcx, sp, n_ty) {\n-      None => {\n-        wbcx.success = false;\n-      }\n-\n-      Some(t) => {\n-        debug!(\"resolve_type_vars_for_node(id={}, n_ty={}, t={})\",\n-               id, ppaux::ty_to_str(tcx, n_ty), ppaux::ty_to_str(tcx, t));\n-        write_ty_to_tcx(tcx, id, t);\n-        fcx.opt_node_ty_substs(id, |substs| {\n-          let mut new_tps = Vec::new();\n-          for subst in substs.tps.iter() {\n-              match resolve_type_vars_in_type(fcx, sp, *subst) {\n-                Some(t) => new_tps.push(t),\n-                None => { wbcx.success = false; break }\n-              }\n-          }\n-          write_substs_to_tcx(tcx, id, new_tps);\n-          wbcx.success\n+    fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) {\n+        // Resolve any borrowings for the node with id `id`\n+        self.visit_adjustments(reason, id);\n+\n+        // Resolve the type of the node with id `id`\n+        let n_ty = self.fcx.node_ty(id);\n+        let n_ty = n_ty.resolve(self.fcx, reason);\n+        write_ty_to_tcx(self.tcx(), id, n_ty);\n+        debug!(\"Node {} has type {}\", id, n_ty.repr(self.tcx()));\n+\n+        // Resolve any substitutions\n+        self.fcx.opt_node_ty_substs(id, |node_substs| {\n+            let mut new_tps = Vec::new();\n+            for subst in node_substs.tps.iter() {\n+                new_tps.push(subst.resolve(self.fcx, reason));\n+            }\n+            write_substs_to_tcx(self.tcx(), id, new_tps);\n         });\n-      }\n     }\n-}\n \n-struct WbCtxt<'a> {\n-    fcx: &'a FnCtxt<'a>,\n+    fn visit_adjustments(&self, reason: ResolveReason, id: ast::NodeId) {\n+        match self.fcx.inh.adjustments.borrow_mut().pop(&id) {\n+            None => {\n+                debug!(\"No adjustments for node {}\", id);\n+            }\n \n-    // As soon as we hit an error we have to stop resolving\n-    // the entire function.\n-    success: bool,\n-}\n+            Some(adjustment) => {\n+                let resolved_adjustment = match adjustment {\n+                    ty::AutoAddEnv(store) => {\n+                        // FIXME(eddyb) #2190 Allow only statically resolved\n+                        // bare functions to coerce to a closure to avoid\n+                        // constructing (slower) indirect call wrappers.\n+                        match self.tcx().def_map.borrow().find(&id) {\n+                            Some(&ast::DefFn(..)) |\n+                            Some(&ast::DefStaticMethod(..)) |\n+                            Some(&ast::DefVariant(..)) |\n+                            Some(&ast::DefStruct(_)) => {\n+                            }\n+                            _ => {\n+                                self.tcx().sess.span_err(\n+                                    reason.span(self.fcx),\n+                                    \"cannot coerce non-statically resolved bare fn\")\n+                            }\n+                        }\n \n-fn visit_stmt(s: &ast::Stmt, wbcx: &mut WbCtxt) {\n-    if !wbcx.success { return; }\n-    resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n-    visit::walk_stmt(wbcx, s, ());\n-}\n+                        ty::AutoAddEnv(store.resolve(self.fcx, reason))\n+                    }\n+\n+                    ty::AutoDerefRef(adj) => {\n+                        for autoderef in range(0, adj.autoderefs) {\n+                            let method_call = MethodCall::autoderef(id, autoderef as u32);\n+                            self.visit_method_map_entry(reason, method_call);\n+                            self.visit_vtable_map_entry(reason, method_call);\n+                        }\n \n-fn visit_expr(e: &ast::Expr, wbcx: &mut WbCtxt) {\n-    if !wbcx.success {\n-        return;\n+                        ty::AutoDerefRef(ty::AutoDerefRef {\n+                            autoderefs: adj.autoderefs,\n+                            autoref: adj.autoref.resolve(self.fcx, reason),\n+                        })\n+                    }\n+\n+                    adjustment => adjustment\n+                };\n+                debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n+                self.tcx().adjustments.borrow_mut().insert(\n+                    id, resolved_adjustment);\n+            }\n+        }\n     }\n \n-    resolve_type_vars_for_node(wbcx, e.span, e.id);\n-    resolve_method_map_entry(wbcx, e.span, MethodCall::expr(e.id));\n-    resolve_vtable_map_entry(wbcx.fcx, e.span, MethodCall::expr(e.id));\n+    fn visit_method_map_entry(&self,\n+                              reason: ResolveReason,\n+                              method_call: MethodCall) {\n+        // Resolve any method map entry\n+        match self.fcx.inh.method_map.borrow_mut().pop(&method_call) {\n+            Some(method) => {\n+                debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={})\",\n+                       method_call,\n+                       method.repr(self.tcx()));\n+                let mut new_method = MethodCallee {\n+                    origin: method.origin,\n+                    ty: method.ty.resolve(self.fcx, reason),\n+                    substs: method.substs.resolve(self.fcx, reason),\n+                };\n+\n+                // Wack. For some reason I don't quite know, we always\n+                // hard-code the self-ty and regions to these\n+                // values. Changing this causes downstream errors I\n+                // don't feel like investigating right now (in\n+                // particular, self_ty is set to mk_err in some cases,\n+                // probably for invocations on objects, and this\n+                // causes encoding failures). -nmatsakis\n+                new_method.substs.self_ty = None;\n+                new_method.substs.regions = ty::ErasedRegions;\n+\n+                self.tcx().method_map.borrow_mut().insert(\n+                    method_call,\n+                    new_method);\n+            }\n+            None => {}\n+        }\n+    }\n \n-    match e.node {\n-        ast::ExprFnBlock(ref decl, _) | ast::ExprProc(ref decl, _) => {\n-            for input in decl.inputs.iter() {\n-                let _ = resolve_type_vars_for_node(wbcx, e.span, input.id);\n+    fn visit_vtable_map_entry(&self,\n+                              reason: ResolveReason,\n+                              vtable_key: MethodCall) {\n+        // Resolve any vtable map entry\n+        match self.fcx.inh.vtable_map.borrow_mut().pop(&vtable_key) {\n+            Some(origins) => {\n+                let r_origins = origins.resolve(self.fcx, reason);\n+                debug!(\"writeback::resolve_vtable_map_entry(\\\n+                        vtable_key={}, vtables={:?})\",\n+                       vtable_key, r_origins.repr(self.tcx()));\n+                self.tcx().vtable_map.borrow_mut().insert(vtable_key, r_origins);\n             }\n+            None => {}\n         }\n-        _ => {}\n     }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Resolution reason.\n \n-    visit::walk_expr(wbcx, e, ());\n+enum ResolveReason {\n+    ResolvingExpr(Span),\n+    ResolvingLocal(Span),\n+    ResolvingPattern(Span),\n+    ResolvingUpvar(ty::UpvarId)\n }\n \n-fn visit_block(b: &ast::Block, wbcx: &mut WbCtxt) {\n-    if !wbcx.success {\n-        return;\n+impl ResolveReason {\n+    fn span(&self, fcx: &FnCtxt) -> Span {\n+        match *self {\n+            ResolvingExpr(s) => s,\n+            ResolvingLocal(s) => s,\n+            ResolvingPattern(s) => s,\n+            ResolvingUpvar(upvar_id) => {\n+                ty::expr_span(fcx.tcx(), upvar_id.closure_expr_id)\n+            }\n+        }\n     }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Convenience methods for resolving different kinds of things.\n \n-    resolve_type_vars_for_node(wbcx, b.span, b.id);\n-    visit::walk_block(wbcx, b, ());\n+trait Resolve {\n+    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> Self;\n }\n \n-fn visit_pat(p: &ast::Pat, wbcx: &mut WbCtxt) {\n-    if !wbcx.success {\n-        return;\n+impl<T:Resolve> Resolve for Option<T> {\n+    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> Option<T> {\n+        self.as_ref().map(|t| t.resolve(fcx, reason))\n     }\n+}\n \n-    resolve_type_vars_for_node(wbcx, p.span, p.id);\n-    debug!(\"Type for pattern binding {} (id {}) resolved to {}\",\n-           pat_to_str(p), p.id,\n-           wbcx.fcx.infcx().ty_to_str(\n-               ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n-                                   p.id)));\n-    visit::walk_pat(wbcx, p, ());\n+impl<T:Resolve> Resolve for Vec<T> {\n+    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> Vec<T> {\n+        self.iter().map(|t| t.resolve(fcx, reason)).collect()\n+    }\n }\n \n-fn visit_local(l: &ast::Local, wbcx: &mut WbCtxt) {\n-    if !wbcx.success { return; }\n-    let var_ty = wbcx.fcx.local_ty(l.span, l.id);\n-    match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n-        Ok(lty) => {\n-            debug!(\"Type for local {} (id {}) resolved to {}\",\n-                   pat_to_str(l.pat),\n-                   l.id,\n-                   wbcx.fcx.infcx().ty_to_str(lty));\n-            write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.id, lty);\n-        }\n-        Err(e) => {\n-            wbcx.fcx.ccx.tcx.sess.span_err(\n-                l.span,\n-                format!(\"cannot determine a type \\\n-                      for this local variable: {}\",\n-                     infer::fixup_err_to_str(e)));\n-            wbcx.success = false;\n-        }\n+impl Resolve for ty::TraitStore {\n+    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> ty::TraitStore {\n+        Resolver::new(fcx, reason).fold_trait_store(*self)\n     }\n-    visit::walk_local(wbcx, l, ());\n }\n-fn visit_item(_item: &ast::Item, _wbcx: &mut WbCtxt) {\n-    // Ignore items\n+\n+impl Resolve for ty::t {\n+    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> ty::t {\n+        Resolver::new(fcx, reason).fold_ty(*self)\n+    }\n }\n \n-impl<'a> Visitor<()> for WbCtxt<'a> {\n-    fn visit_item(&mut self, i: &ast::Item, _: ()) { visit_item(i, self); }\n-    fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) { visit_stmt(s, self); }\n-    fn visit_expr(&mut self, ex:&ast::Expr, _: ()) { visit_expr(ex, self); }\n-    fn visit_block(&mut self, b: &ast::Block, _: ()) { visit_block(b, self); }\n-    fn visit_pat(&mut self, p: &ast::Pat, _: ()) { visit_pat(p, self); }\n-    fn visit_local(&mut self, l: &ast::Local, _: ()) { visit_local(l, self); }\n-    // FIXME(#10894) should continue recursing\n-    fn visit_ty(&mut self, _t: &ast::Ty, _: ()) {}\n+impl Resolve for ty::Region {\n+    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> ty::Region {\n+        Resolver::new(fcx, reason).fold_region(*self)\n+    }\n }\n \n-fn resolve_upvar_borrow_map(wbcx: &mut WbCtxt) {\n-    if !wbcx.success {\n-        return;\n+impl Resolve for ty::substs {\n+    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> ty::substs {\n+        Resolver::new(fcx, reason).fold_substs(self)\n     }\n+}\n \n-    let fcx = wbcx.fcx;\n-    let tcx = fcx.tcx();\n-    for (upvar_id, upvar_borrow) in fcx.inh.upvar_borrow_map.borrow().iter() {\n-        let r = upvar_borrow.region;\n-        match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n-            Ok(r) => {\n-                let new_upvar_borrow = ty::UpvarBorrow {\n-                    kind: upvar_borrow.kind,\n-                    region: r\n-                };\n-                debug!(\"Upvar borrow for {} resolved to {}\",\n-                       upvar_id.repr(tcx), new_upvar_borrow.repr(tcx));\n-                tcx.upvar_borrow_map.borrow_mut().insert(*upvar_id,\n-                                                         new_upvar_borrow);\n+impl Resolve for ty::AutoRef {\n+    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> ty::AutoRef {\n+        Resolver::new(fcx, reason).fold_autoref(self)\n+    }\n+}\n+\n+impl Resolve for vtable_origin {\n+    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> vtable_origin {\n+        match *self {\n+            vtable_static(def_id, ref tys, ref origins) => {\n+                let r_tys = tys.resolve(fcx, reason);\n+                let r_origins = origins.resolve(fcx, reason);\n+                vtable_static(def_id, r_tys, r_origins)\n             }\n-            Err(e) => {\n-                let span = ty::expr_span(tcx, upvar_id.closure_expr_id);\n-                fcx.ccx.tcx.sess.span_err(\n-                    span, format!(\"cannot resolve lifetime for \\\n-                                  captured variable `{}`: {}\",\n-                                  ty::local_var_name_str(tcx, upvar_id.var_id).get().to_str(),\n-                                  infer::fixup_err_to_str(e)));\n-                wbcx.success = false;\n+            vtable_param(n, b) => {\n+                vtable_param(n, b)\n             }\n-        };\n+        }\n     }\n }\n \n-pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) -> bool {\n-    let mut wbcx = WbCtxt { fcx: fcx, success: true };\n-    let wbcx = &mut wbcx;\n-    wbcx.visit_expr(e, ());\n-    resolve_upvar_borrow_map(wbcx);\n-    return wbcx.success;\n+///////////////////////////////////////////////////////////////////////////\n+// The Resolver. This is the type folding engine that detects\n+// unresolved types and so forth.\n+\n+struct Resolver<'cx> {\n+    fcx: &'cx FnCtxt<'cx>,\n+    reason: ResolveReason,\n }\n \n-pub fn resolve_type_vars_in_fn(fcx: &FnCtxt, decl: &ast::FnDecl,\n-                               blk: &ast::Block) -> bool {\n-    let mut wbcx = WbCtxt { fcx: fcx, success: true };\n-    let wbcx = &mut wbcx;\n-    wbcx.visit_block(blk, ());\n-    for arg in decl.inputs.iter() {\n-        wbcx.visit_pat(arg.pat, ());\n-        // Privacy needs the type for the whole pattern, not just each binding\n-        if !pat_util::pat_is_binding(&fcx.tcx().def_map, arg.pat) {\n-            resolve_type_vars_for_node(wbcx, arg.pat.span, arg.pat.id);\n+impl<'cx> Resolver<'cx> {\n+    fn new(fcx: &'cx FnCtxt<'cx>,\n+           reason: ResolveReason)\n+           -> Resolver<'cx>\n+    {\n+        Resolver { fcx: fcx, reason: reason }\n+    }\n+\n+    fn report_error(&self, e: infer::fixup_err) {\n+        self.fcx.writeback_errors.set(true);\n+        if !self.tcx().sess.has_errors() {\n+            match self.reason {\n+                ResolvingExpr(span) => {\n+                    self.tcx().sess.span_err(\n+                        span,\n+                        format!(\"cannot determine a type for \\\n+                                 this expression: {}\",\n+                                infer::fixup_err_to_str(e)))\n+                }\n+\n+                ResolvingLocal(span) => {\n+                    self.tcx().sess.span_err(\n+                        span,\n+                        format!(\"cannot determine a type for \\\n+                                 this local variable: {}\",\n+                                infer::fixup_err_to_str(e)))\n+                }\n+\n+                ResolvingPattern(span) => {\n+                    self.tcx().sess.span_err(\n+                        span,\n+                        format!(\"cannot determine a type for \\\n+                                 this pattern binding: {}\",\n+                                infer::fixup_err_to_str(e)))\n+                }\n+\n+                ResolvingUpvar(upvar_id) => {\n+                    let span = self.reason.span(self.fcx);\n+                    self.tcx().sess.span_err(\n+                        span,\n+                        format!(\"cannot resolve lifetime for \\\n+                                 captured variable `{}`: {}\",\n+                                ty::local_var_name_str(\n+                                    self.tcx(),\n+                                    upvar_id.var_id).get().to_str(),\n+                                infer::fixup_err_to_str(e)));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'cx> TypeFolder for Resolver<'cx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        self.fcx.tcx()\n+    }\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        if !ty::type_needs_infer(t) {\n+            return t;\n+        }\n+\n+        match resolve_type(self.fcx.infcx(), t, resolve_all | force_all) {\n+            Ok(t) => t,\n+            Err(e) => {\n+                self.report_error(e);\n+                ty::mk_err()\n+            }\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        match resolve_region(self.fcx.infcx(), r, resolve_all | force_all) {\n+            Ok(r) => r,\n+            Err(e) => {\n+                self.report_error(e);\n+                ty::ReStatic\n+            }\n         }\n     }\n-    resolve_upvar_borrow_map(wbcx);\n-    return wbcx.success;\n }"}, {"sha": "f7e5964fa2450da2db3f2d8bec82d5559479e474", "filename": "src/test/compile-fail/typeck_type_placeholder_mismatch.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_mismatch.rs?ref=c4f0980d2ea43d3ab7e0cf14fee81de8df5c867a", "patch": "@@ -26,5 +26,4 @@ fn test1() {\n fn test2() {\n     let x: Foo<_> = Bar::<uint>;\n     //~^ ERROR mismatched types: expected `Foo<<generic #0>>` but found `Bar<uint>`\n-    //~^^ ERROR cannot determine a type for this local variable: unconstrained type\n }"}]}