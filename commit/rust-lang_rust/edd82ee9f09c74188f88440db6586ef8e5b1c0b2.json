{"sha": "edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZDgyZWU5ZjA5Yzc0MTg4Zjg4NDQwZGI2NTg2ZWY4ZTViMWMwYjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-11T15:45:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-11T15:45:10Z"}, "message": "Auto merge of #42932 - bjorn3:no_llvm_try2, r=eddyb\n\nSupport compiling rustc without LLVM (try 2)\n\nNow doesn't change rustc_driver.\n\nSupersedes #42752", "tree": {"sha": "e971016388640a5700e21ec6c0b020c6cc700123", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e971016388640a5700e21ec6c0b020c6cc700123"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "html_url": "https://github.com/rust-lang/rust/commit/edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38bdbb7cf9bebcc4b6331644f52f9d6e52754782", "url": "https://api.github.com/repos/rust-lang/rust/commits/38bdbb7cf9bebcc4b6331644f52f9d6e52754782", "html_url": "https://github.com/rust-lang/rust/commit/38bdbb7cf9bebcc4b6331644f52f9d6e52754782"}, {"sha": "e5399961c69ac2a64bdbed8af8b34698c3039db0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5399961c69ac2a64bdbed8af8b34698c3039db0", "html_url": "https://github.com/rust-lang/rust/commit/e5399961c69ac2a64bdbed8af8b34698c3039db0"}], "stats": {"total": 570, "additions": 416, "deletions": 154}, "files": [{"sha": "c175198c227a54adc24d0fc04abd27072402d0ab", "filename": "src/Cargo.lock", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -65,6 +65,11 @@ name = \"ansi_term\"\n version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"ar\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"arena\"\n version = \"0.0.0\"\n@@ -1333,10 +1338,12 @@ dependencies = [\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n+ \"ar 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"arena 0.0.0\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -1354,6 +1361,7 @@ dependencies = [\n  \"rustc_resolve 0.0.0\",\n  \"rustc_save_analysis 0.0.0\",\n  \"rustc_trans 0.0.0\",\n+ \"rustc_trans_utils 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -1545,11 +1553,21 @@ dependencies = [\n  \"rustc_incremental 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n+ \"rustc_trans_utils 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_trans_utils\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_tsan\"\n version = \"0.0.0\"\n@@ -2141,6 +2159,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca972c2ea5f742bfce5687b9aef75506a764f61d37f8f649047846a9686ddb66\"\n \"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n \"checksum ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23ac7c30002a5accbf7e8987d0632fa6de155b7c3d39d0067317a391e00a2ef6\"\n+\"checksum ar 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b24e4eef8e3fa7e2ca75b157e6039cdf8d9d3a68213ddc19d0fd9d576b9717c9\"\n \"checksum atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d912da0db7fa85514874458ca3651fe2cddace8d0b0505571dbdcd41ab490159\"\n \"checksum backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72f9b4182546f4b04ebc4ab7f84948953a118bd6021a1b6a6c909e3e94f6be76\"\n \"checksum backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afccc5772ba333abccdf60d55200fa3406f8c59dcf54d5f7998c9107d3799c7c\""}, {"sha": "ec57bb069e0a4812719f88be8640239e3cf857e6", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -53,6 +53,7 @@ pub struct Config {\n     pub profiler: bool,\n \n     // llvm codegen options\n+    pub llvm_enabled: bool,\n     pub llvm_assertions: bool,\n     pub llvm_optimize: bool,\n     pub llvm_release_debuginfo: bool,\n@@ -192,6 +193,7 @@ struct Install {\n #[derive(Deserialize, Default)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Llvm {\n+    enabled: Option<bool>,\n     ccache: Option<StringOrBool>,\n     ninja: Option<bool>,\n     assertions: Option<bool>,\n@@ -265,6 +267,7 @@ struct TomlTarget {\n impl Config {\n     pub fn parse(build: &str, file: Option<PathBuf>) -> Config {\n         let mut config = Config::default();\n+        config.llvm_enabled = true;\n         config.llvm_optimize = true;\n         config.use_jemalloc = true;\n         config.backtrace = true;\n@@ -345,6 +348,7 @@ impl Config {\n                 Some(StringOrBool::Bool(false)) | None => {}\n             }\n             set(&mut config.ninja, llvm.ninja);\n+            set(&mut config.llvm_enabled, llvm.enabled);\n             set(&mut config.llvm_assertions, llvm.assertions);\n             set(&mut config.llvm_optimize, llvm.optimize);\n             set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);"}, {"sha": "19678dc77937568216a7fafa88302834669bca10", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -14,6 +14,10 @@\n # =============================================================================\n [llvm]\n \n+# Indicates whether rustc will support compilation with LLVM\n+# note: rustc does not compile without LLVM at the moment\n+#enabled = true\n+\n # Indicates whether the LLVM build is a Release or Debug build\n #optimize = true\n "}, {"sha": "a8485d1d152d18703837f735a7e778e8c62dd2f8", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -429,6 +429,9 @@ impl Build {\n         if self.config.use_jemalloc {\n             features.push_str(\" jemalloc\");\n         }\n+        if self.config.llvm_enabled {\n+            features.push_str(\" llvm\");\n+        }\n         features\n     }\n "}, {"sha": "59efbd5c4d20d8d9ce7f96d355cf746e20e13fec", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -56,6 +56,12 @@ impl Step for Llvm {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let target = self.target;\n+\n+        // If we're not compiling for LLVM bail out here.\n+        if !build.config.llvm_enabled {\n+            return;\n+        }\n+\n         // If we're using a custom LLVM bail out here, but we can only use a\n         // custom LLVM for the build triple.\n         if let Some(config) = build.config.target_config.get(&target) {"}, {"sha": "d6155f53485e3a8caca6b161bb38ac83e55ce1e8", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -12,6 +12,7 @@ crate-type = [\"dylib\"]\n arena = { path = \"../libarena\" }\n graphviz = { path = \"../libgraphviz\" }\n log = { version = \"0.3\", features = [\"release_max_level_info\"] }\n+owning_ref = \"0.3.3\"\n env_logger = { version = \"0.4\", default-features = false }\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n@@ -29,9 +30,15 @@ rustc_plugin = { path = \"../librustc_plugin\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n-rustc_trans = { path = \"../librustc_trans\" }\n+rustc_trans = { path = \"../librustc_trans\", optional = true }\n+rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+\n+ar = \"0.3.0\"\n+\n+[features]\n+llvm = [\"rustc_trans\"]"}, {"sha": "1c03b9f69f711bc24e67f947e9fef0b09c39ff3e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 73, "deletions": 27, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -18,7 +18,9 @@ use rustc::session::CompileIncomplete;\n use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n-use rustc::middle::{self, dependency_format, stability, reachable};\n+use rustc::middle::{self, stability, reachable};\n+#[cfg(feature=\"llvm\")]\n+use rustc::middle::dependency_format;\n use rustc::middle::privacy::AccessLevels;\n use rustc::mir::transform::{MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED, Passes};\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n@@ -31,7 +33,9 @@ use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n+#[cfg(feature=\"llvm\")]\n use rustc_trans::back::{link, write};\n+#[cfg(feature=\"llvm\")]\n use rustc_trans as trans;\n use rustc_typeck as typeck;\n use rustc_privacy;\n@@ -69,6 +73,11 @@ pub fn compile_input(sess: &Session,\n                      output: &Option<PathBuf>,\n                      addl_plugins: Option<Vec<String>>,\n                      control: &CompileController) -> CompileResult {\n+    #[cfg(feature=\"llvm\")]\n+    use rustc_trans::back::write::OngoingCrateTranslation;\n+    #[cfg(not(feature=\"llvm\"))]\n+    type OngoingCrateTranslation = ();\n+\n     macro_rules! controller_entry_point {\n         ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n             let state = &mut $make_state;\n@@ -88,7 +97,7 @@ pub fn compile_input(sess: &Session,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (outputs, trans) = {\n+    let (outputs, trans): (OutputFilenames, OngoingCrateTranslation) = {\n         let krate = match phase_1_parse_input(control, sess, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n@@ -113,7 +122,8 @@ pub fn compile_input(sess: &Session,\n         };\n \n         let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n-        let crate_name = link::find_crate_name(Some(sess), &krate.attrs, input);\n+        let crate_name =\n+            ::rustc_trans_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n         let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n             phase_2_configure_and_expand(\n                 sess, &cstore, krate, registry, &crate_name, addl_plugins, control.make_glob_map,\n@@ -206,6 +216,8 @@ pub fn compile_input(sess: &Session,\n                 println!(\"Pre-trans\");\n                 tcx.print_debug_stats();\n             }\n+\n+            #[cfg(feature=\"llvm\")]\n             let trans = phase_4_translate_to_llvm(tcx, analysis, incremental_hashes_map,\n                                                   &outputs);\n \n@@ -221,38 +233,59 @@ pub fn compile_input(sess: &Session,\n                 }\n             }\n \n+            #[cfg(not(feature=\"llvm\"))]\n+            {\n+                let _ = incremental_hashes_map;\n+                sess.err(&format!(\"LLVM is not supported by this rustc\"));\n+                sess.abort_if_errors();\n+                unreachable!();\n+            }\n+\n+            #[cfg(feature=\"llvm\")]\n             Ok((outputs, trans))\n         })??\n     };\n \n-    if sess.opts.debugging_opts.print_type_sizes {\n-        sess.code_stats.borrow().print_type_sizes();\n+    #[cfg(not(feature=\"llvm\"))]\n+    {\n+        let _ = outputs;\n+        let _ = trans;\n+        unreachable!();\n     }\n \n-    let (phase5_result, trans) = phase_5_run_llvm_passes(sess, trans);\n+    #[cfg(feature=\"llvm\")]\n+    {\n+        if sess.opts.debugging_opts.print_type_sizes {\n+            sess.code_stats.borrow().print_type_sizes();\n+        }\n \n-    controller_entry_point!(after_llvm,\n-                            sess,\n-                            CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n-                            phase5_result);\n-    phase5_result?;\n+        let (phase5_result, trans) = phase_5_run_llvm_passes(sess, trans);\n \n-    phase_6_link_output(sess, &trans, &outputs);\n+        controller_entry_point!(after_llvm,\n+                                sess,\n+                                CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n+                                phase5_result);\n+        phase5_result?;\n \n-    // Now that we won't touch anything in the incremental compilation directory\n-    // any more, we can finalize it (which involves renaming it)\n-    rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n+        phase_6_link_output(sess, &trans, &outputs);\n \n-    if sess.opts.debugging_opts.perf_stats {\n-        sess.print_perf_stats();\n-    }\n+        // Now that we won't touch anything in the incremental compilation directory\n+        // any more, we can finalize it (which involves renaming it)\n+        rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n \n-    controller_entry_point!(compilation_done,\n-                            sess,\n-                            CompileState::state_when_compilation_done(input, sess, outdir, output),\n-                            Ok(()));\n+        if sess.opts.debugging_opts.perf_stats {\n+            sess.print_perf_stats();\n+        }\n+\n+        controller_entry_point!(\n+            compilation_done,\n+            sess,\n+            CompileState::state_when_compilation_done(input, sess, outdir, output),\n+            Ok(())\n+        );\n \n-    Ok(())\n+        Ok(())\n+    }\n }\n \n fn keep_hygiene_data(sess: &Session) -> bool {\n@@ -360,6 +393,7 @@ pub struct CompileState<'a, 'tcx: 'a> {\n     pub resolutions: Option<&'a Resolutions>,\n     pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n+    #[cfg(feature=\"llvm\")]\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n@@ -386,6 +420,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n             resolutions: None,\n             analysis: None,\n             tcx: None,\n+            #[cfg(feature=\"llvm\")]\n             trans: None,\n         }\n     }\n@@ -474,7 +509,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n-\n+    #[cfg(feature=\"llvm\")]\n     fn state_after_llvm(input: &'a Input,\n                         session: &'tcx Session,\n                         out_dir: &'a Option<PathBuf>,\n@@ -488,6 +523,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n+    #[cfg(feature=\"llvm\")]\n     fn state_when_compilation_done(input: &'a Input,\n                                    session: &'tcx Session,\n                                    out_dir: &'a Option<PathBuf>,\n@@ -906,6 +942,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     mir::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n+    #[cfg(feature=\"llvm\")]\n     trans::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n@@ -918,6 +955,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n+    #[cfg(feature=\"llvm\")]\n     trans::provide(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n     traits::provide_extern(&mut extern_providers);\n@@ -1064,6 +1102,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n+#[cfg(feature=\"llvm\")]\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            analysis: ty::CrateAnalysis,\n                                            incremental_hashes_map: IncrementalHashesMap,\n@@ -1085,6 +1124,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n+#[cfg(feature=\"llvm\")]\n pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: write::OngoingCrateTranslation)\n                                -> (CompileResult, trans::CrateTranslation) {\n@@ -1103,6 +1143,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n \n /// Run the linker on any artifacts that resulted from the LLVM run.\n /// This should produce either a finished executable or library.\n+#[cfg(feature=\"llvm\")]\n pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n@@ -1124,7 +1165,12 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, crate_name: &str) {\n         match *output_type {\n             OutputType::Exe => {\n                 for output in sess.crate_types.borrow().iter() {\n-                    let p = link::filename_for_input(sess, *output, crate_name, outputs);\n+                    let p = ::rustc_trans_utils::link::filename_for_input(\n+                        sess,\n+                        *output,\n+                        crate_name,\n+                        outputs\n+                    );\n                     out_filenames.push(p);\n                 }\n             }\n@@ -1234,15 +1280,15 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n     if base.is_empty() {\n         base.extend(attr_types);\n         if base.is_empty() {\n-            base.push(link::default_output_for_target(session));\n+            base.push(::rustc_trans_utils::link::default_output_for_target(session));\n         }\n         base.sort();\n         base.dedup();\n     }\n \n     base.into_iter()\n         .filter(|crate_type| {\n-            let res = !link::invalid_output_for_target(session, *crate_type);\n+            let res = !::rustc_trans_utils::link::invalid_output_for_target(session, *crate_type);\n \n             if !res {\n                 session.warn(&format!(\"dropping unsupported crate type `{}` for target `{}`\","}, {"sha": "91ba7ed1958e7c85299cf4795b54fc30ddcc486b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 81, "deletions": 5, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -28,10 +28,15 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(set_stdio)]\n \n+#[cfg(not(feature=\"llvm\"))]\n+extern crate ar;\n+\n extern crate arena;\n extern crate getopts;\n extern crate graphviz;\n extern crate env_logger;\n+#[cfg(not(feature=\"llvm\"))]\n+extern crate owning_ref;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_allocator;\n@@ -49,7 +54,9 @@ extern crate rustc_metadata;\n extern crate rustc_mir;\n extern crate rustc_resolve;\n extern crate rustc_save_analysis;\n+#[cfg(feature=\"llvm\")]\n extern crate rustc_trans;\n+extern crate rustc_trans_utils;\n extern crate rustc_typeck;\n extern crate serialize;\n #[macro_use]\n@@ -64,7 +71,7 @@ use pretty::{PpMode, UserIdentifiedItem};\n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n-use rustc_trans::back::link;\n+#[cfg(feature=\"llvm\")]\n use rustc_trans::back::write::{RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n@@ -74,9 +81,13 @@ use rustc::session::config::nightly_options;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n+#[cfg(not(feature=\"llvm\"))]\n+use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n use rustc::util::common::{time, ErrorReported};\n+#[cfg(not(feature=\"llvm\"))]\n+use rustc_back::target::Target;\n \n use serialize::json::ToJson;\n \n@@ -89,6 +100,8 @@ use std::ffi::OsString;\n use std::io::{self, Read, Write};\n use std::iter::repeat;\n use std::path::PathBuf;\n+#[cfg(not(feature=\"llvm\"))]\n+use std::path::Path;\n use std::process::{self, Command, Stdio};\n use std::rc::Rc;\n use std::str;\n@@ -101,11 +114,15 @@ use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::{DUMMY_SP, MultiSpan};\n \n+#[cfg(not(feature=\"llvm\"))]\n+use owning_ref::{OwningRef, ErasedBoxRef};\n+\n #[cfg(test)]\n pub mod test;\n \n pub mod driver;\n pub mod pretty;\n+#[cfg(feature=\"llvm\")]\n pub mod target_features;\n mod derive_registrar;\n \n@@ -151,9 +168,49 @@ pub fn run<F>(run_compiler: F) -> isize\n     0\n }\n \n+#[cfg(not(feature=\"llvm\"))]\n+pub struct NoLLvmMetadataLoader;\n+\n+#[cfg(not(feature=\"llvm\"))]\n+pub use NoLLvmMetadataLoader as MetadataLoader;\n+#[cfg(feature=\"llvm\")]\n+pub use rustc_trans::LlvmMetadataLoader as MetadataLoader;\n+\n+#[cfg(not(feature=\"llvm\"))]\n+impl MetadataLoaderTrait for NoLLvmMetadataLoader {\n+    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n+        use std::fs::File;\n+        use std::io;\n+        use self::ar::Archive;\n+\n+        let file = File::open(filename).map_err(|e|format!(\"metadata file open err: {:?}\", e))?;\n+        let mut archive = Archive::new(file);\n+\n+        while let Some(entry_result) = archive.next_entry() {\n+            let mut entry = entry_result.map_err(|e|format!(\"metadata section read err: {:?}\", e))?;\n+            if entry.header().identifier() == \"rust.metadata.bin\" {\n+                let mut buf = Vec::new();\n+                io::copy(&mut entry, &mut buf).unwrap();\n+                let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n+                return Ok(buf.map_owner_box().erase_owner());\n+            }\n+        }\n+\n+        Err(\"Couldnt find metadata section\".to_string())\n+    }\n+\n+    fn get_dylib_metadata(&self,\n+                          _target: &Target,\n+                          _filename: &Path)\n+                          -> Result<ErasedBoxRef<[u8]>, String> {\n+        panic!(\"Dylib metadata loading not supported without LLVM\")\n+    }\n+}\n+\n // Parse args and run the compiler. This is the primary entry point for rustc.\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n+#[cfg_attr(not(feature=\"llvm\"), allow(unused_mut))]\n pub fn run_compiler<'a>(args: &[String],\n                         callbacks: &mut CompilerCalls<'a>,\n                         file_loader: Option<Box<FileLoader + 'static>>,\n@@ -175,6 +232,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n \n     if sopts.debugging_opts.debug_llvm {\n+        #[cfg(feature=\"llvm\")]\n         rustc_trans::enable_llvm_debug();\n     }\n \n@@ -197,17 +255,19 @@ pub fn run_compiler<'a>(args: &[String],\n     };\n \n     let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_codemap(\n         sopts, &dep_graph, input_file_path, descriptions, cstore.clone(), codemap, emitter_dest,\n     );\n+    #[cfg(feature=\"llvm\")]\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, cfg);\n+    #[cfg(feature=\"llvm\")]\n     target_features::add_configuration(&mut cfg, &sess);\n     sess.parse_sess.config = cfg;\n \n@@ -460,6 +520,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n         Compilation::Continue\n     }\n \n+    #[cfg_attr(not(feature=\"llvm\"), allow(unused_mut))]\n     fn no_input(&mut self,\n                 matches: &getopts::Matches,\n                 sopts: &config::Options,\n@@ -477,15 +538,17 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     return None;\n                 }\n                 let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-                let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+                let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n                 let mut sess = build_session(sopts.clone(),\n                     &dep_graph,\n                     None,\n                     descriptions.clone(),\n                     cstore.clone());\n+                #[cfg(feature=\"llvm\")]\n                 rustc_trans::init(&sess);\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n+                #[cfg(feature=\"llvm\")]\n                 target_features::add_configuration(&mut cfg, &sess);\n                 sess.parse_sess.config = cfg;\n                 let should_stop =\n@@ -678,14 +741,19 @@ impl RustcDefaultCalls {\n                     };\n                     let attrs = attrs.as_ref().unwrap();\n                     let t_outputs = driver::build_output_filenames(input, odir, ofile, attrs, sess);\n-                    let id = link::find_crate_name(Some(sess), attrs, input);\n+                    let id = rustc_trans_utils::link::find_crate_name(Some(sess), attrs, input);\n                     if *req == PrintRequest::CrateName {\n                         println!(\"{}\", id);\n                         continue;\n                     }\n                     let crate_types = driver::collect_crate_types(sess, attrs);\n                     for &style in &crate_types {\n-                        let fname = link::filename_for_input(sess, style, &id, &t_outputs);\n+                        let fname = rustc_trans_utils::link::filename_for_input(\n+                            sess,\n+                            style,\n+                            &id,\n+                            &t_outputs\n+                        );\n                         println!(\"{}\",\n                                  fname.file_name()\n                                       .unwrap()\n@@ -734,20 +802,25 @@ impl RustcDefaultCalls {\n                 }\n                 PrintRequest::RelocationModels => {\n                     println!(\"Available relocation models:\");\n+                    #[cfg(feature=\"llvm\")]\n                     for &(name, _) in RELOC_MODEL_ARGS.iter() {\n                         println!(\"    {}\", name);\n                     }\n                     println!(\"\");\n                 }\n                 PrintRequest::CodeModels => {\n                     println!(\"Available code models:\");\n+                    #[cfg(feature=\"llvm\")]\n                     for &(name, _) in CODE_GEN_MODEL_ARGS.iter(){\n                         println!(\"    {}\", name);\n                     }\n                     println!(\"\");\n                 }\n                 PrintRequest::TargetCPUs | PrintRequest::TargetFeatures => {\n+                    #[cfg(feature=\"llvm\")]\n                     rustc_trans::print(*req, sess);\n+                    #[cfg(not(feature=\"llvm\"))]\n+                    panic!(\"LLVM not supported by this rustc\")\n                 }\n             }\n         }\n@@ -786,6 +859,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"commit-date: {}\", unw(commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(release_str()));\n+        #[cfg(feature=\"llvm\")]\n         rustc_trans::print_version();\n     }\n }\n@@ -1083,6 +1157,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.contains(&\"passes=list\".to_string()) {\n+        #[cfg(feature=\"llvm\")]\n         rustc_trans::print_passes();\n         return None;\n     }\n@@ -1210,6 +1285,7 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     all_errors.extend_from_slice(&rustc_borrowck::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n+    #[cfg(feature=\"llvm\")]\n     all_errors.extend_from_slice(&rustc_trans::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);"}, {"sha": "7f65a8b97cd669b76297f14ea01d9681151982bd", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -14,6 +14,7 @@ use driver;\n use rustc::dep_graph::DepGraph;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n+#[cfg(feature=\"llvm\")]\n use rustc_trans;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n@@ -106,13 +107,14 @@ fn test_env<F>(source_string: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n     let sess = session::build_session_(options,\n                                        &dep_graph,\n                                        None,\n                                        diagnostic_handler,\n                                        Rc::new(CodeMap::new(FilePathMapping::empty())),\n                                        cstore.clone());\n+    #[cfg(feature=\"llvm\")]\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {"}, {"sha": "4a92a5798604af01b25330400c3873acc0b0a3ea", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -26,6 +26,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n+rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "a9bd8ea90109e24316c7b4a150802d389c36a95b", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 120, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+extern crate rustc_trans_utils;\n+\n use super::archive::{ArchiveBuilder, ArchiveConfig};\n use super::linker::Linker;\n use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n-use rustc::session::config::{self, NoDebugInfo, OutputFilenames, Input, OutputType};\n+use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType};\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc::middle::cstore::{self, LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n+use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n                             NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n use CrateTranslation;\n@@ -44,9 +46,7 @@ use std::process::Command;\n use std::str;\n use flate2::Compression;\n use flate2::write::DeflateEncoder;\n-use syntax::ast;\n use syntax::attr;\n-use syntax_pos::Span;\n \n /// The LLVM module name containing crate-metadata. This includes a `.` on\n /// purpose, so it cannot clash with the name of a user-defined module.\n@@ -88,55 +88,8 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: usize =\n pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n-\n-pub fn find_crate_name(sess: Option<&Session>,\n-                       attrs: &[ast::Attribute],\n-                       input: &Input) -> String {\n-    let validate = |s: String, span: Option<Span>| {\n-        cstore::validate_crate_name(sess, &s, span);\n-        s\n-    };\n-\n-    // Look in attributes 100% of the time to make sure the attribute is marked\n-    // as used. After doing this, however, we still prioritize a crate name from\n-    // the command line over one found in the #[crate_name] attribute. If we\n-    // find both we ensure that they're the same later on as well.\n-    let attr_crate_name = attrs.iter().find(|at| at.check_name(\"crate_name\"))\n-                               .and_then(|at| at.value_str().map(|s| (at, s)));\n-\n-    if let Some(sess) = sess {\n-        if let Some(ref s) = sess.opts.crate_name {\n-            if let Some((attr, name)) = attr_crate_name {\n-                if name != &**s {\n-                    let msg = format!(\"--crate-name and #[crate_name] are \\\n-                                       required to match, but `{}` != `{}`\",\n-                                      s, name);\n-                    sess.span_err(attr.span, &msg);\n-                }\n-            }\n-            return validate(s.clone(), None);\n-        }\n-    }\n-\n-    if let Some((attr, s)) = attr_crate_name {\n-        return validate(s.to_string(), Some(attr.span));\n-    }\n-    if let Input::File(ref path) = *input {\n-        if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n-            if s.starts_with(\"-\") {\n-                let msg = format!(\"crate names cannot start with a `-`, but \\\n-                                   `{}` has a leading hyphen\", s);\n-                if let Some(sess) = sess {\n-                    sess.err(&msg);\n-                }\n-            } else {\n-                return validate(s.replace(\"-\", \"_\"), None);\n-            }\n-        }\n-    }\n-\n-    \"rust_out\".to_string()\n-}\n+pub use self::rustc_trans_utils::link::{find_crate_name, filename_for_input,\n+                                        default_output_for_target, invalid_output_for_target};\n \n pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap) -> LinkMeta {\n     let krate_dep_node = &DepNode::new_no_params(DepKind::Krate);\n@@ -252,37 +205,6 @@ pub fn link_binary(sess: &Session,\n     out_filenames\n }\n \n-\n-/// Returns default crate type for target\n-///\n-/// Default crate type is used when crate type isn't provided neither\n-/// through cmd line arguments nor through crate attributes\n-///\n-/// It is CrateTypeExecutable for all platforms but iOS as there is no\n-/// way to run iOS binaries anyway without jailbreaking and\n-/// interaction with Rust code through static library is the only\n-/// option for now\n-pub fn default_output_for_target(sess: &Session) -> config::CrateType {\n-    if !sess.target.target.options.executables {\n-        config::CrateTypeStaticlib\n-    } else {\n-        config::CrateTypeExecutable\n-    }\n-}\n-\n-/// Checks if target supports crate_type as output\n-pub fn invalid_output_for_target(sess: &Session,\n-                                 crate_type: config::CrateType) -> bool {\n-    match (sess.target.target.options.dynamic_linking,\n-           sess.target.target.options.executables, crate_type) {\n-        (false, _, config::CrateTypeCdylib) |\n-        (false, _, config::CrateTypeProcMacro) |\n-        (false, _, config::CrateTypeDylib) => true,\n-        (_, false, config::CrateTypeExecutable) => true,\n-        _ => false\n-    }\n-}\n-\n fn is_writeable(p: &Path) -> bool {\n     match p.metadata() {\n         Err(..) => true,\n@@ -299,42 +221,6 @@ fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilen\n     out_filename\n }\n \n-pub fn filename_for_input(sess: &Session,\n-                          crate_type: config::CrateType,\n-                          crate_name: &str,\n-                          outputs: &OutputFilenames) -> PathBuf {\n-    let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n-\n-    match crate_type {\n-        config::CrateTypeRlib => {\n-            outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n-        }\n-        config::CrateTypeCdylib |\n-        config::CrateTypeProcMacro |\n-        config::CrateTypeDylib => {\n-            let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n-                                    &sess.target.target.options.dll_suffix);\n-            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n-                                                suffix))\n-        }\n-        config::CrateTypeStaticlib => {\n-            let (prefix, suffix) = (&sess.target.target.options.staticlib_prefix,\n-                                    &sess.target.target.options.staticlib_suffix);\n-            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n-                                                suffix))\n-        }\n-        config::CrateTypeExecutable => {\n-            let suffix = &sess.target.target.options.exe_suffix;\n-            let out_filename = outputs.path(OutputType::Exe);\n-            if suffix.is_empty() {\n-                out_filename.to_path_buf()\n-            } else {\n-                out_filename.with_extension(&suffix[1..])\n-            }\n-        }\n-    }\n-}\n-\n pub fn each_linked_rlib(sess: &Session,\n                         f: &mut FnMut(CrateNum, &Path)) -> Result<(), String> {\n     let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();"}, {"sha": "f026d4fcbc2806fbc43e5a7dc43958e6171818bb", "filename": "src/librustc_trans_utils/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_trans_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_trans_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2FCargo.toml?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -0,0 +1,15 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_trans_utils\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_trans_utils\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+test = false\n+\n+[dependencies]\n+rustc = { path = \"../librustc\" }\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "81e83076f8c0c9812f0059455aa36e08648811d5", "filename": "src/librustc_trans_utils/lib.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![crate_name = \"rustc_trans_utils\"]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![deny(warnings)]\n+\n+#![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![feature(const_fn)]\n+#![feature(custom_attribute)]\n+#![allow(unused_attributes)]\n+#![feature(i128_type)]\n+#![feature(quote)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(slice_patterns)]\n+#![feature(conservative_impl_trait)]\n+\n+extern crate rustc;\n+extern crate syntax;\n+extern crate syntax_pos;\n+\n+pub mod link;"}, {"sha": "29bb062d34cf6212833d8f8c66a79a3fdee53193", "filename": "src/librustc_trans_utils/link.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_trans_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Flibrustc_trans_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flink.rs?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::session::config::{self, /*NoDebugInfo,*/ OutputFilenames, Input, OutputType};\n+/*use rustc::session::filesearch;\n+use rustc::session::search_paths::PathKind;\n+*/use rustc::session::Session;\n+use rustc::middle::cstore;/*::{self, LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n+                            NativeLibraryKind};*/\n+/*use rustc::middle::dependency_format::Linkage;\n+use rustc::util::common::time;\n+use rustc::util::fs::fix_windows_verbatim_for_gcc;\n+use rustc::dep_graph::{DepKind, DepNode};\n+use rustc::hir::def_id::CrateNum;\n+use rustc::hir::svh::Svh;\n+use rustc_back::tempdir::TempDir;\n+use rustc_back::{PanicStrategy, RelroLevel};\n+use rustc_incremental::IncrementalHashesMap;*/\n+\n+/*use std::ascii;\n+use std::char;\n+use std::env;\n+use std::ffi::OsString;\n+use std::fs;\n+use std::io::{self, Read, Write};\n+use std::mem;\n+*/use std::path::PathBuf;/*{Path, PathBuf};\n+use std::process::Command;\n+use std::str;*/\n+use syntax::ast;\n+//use syntax::attr;\n+use syntax_pos::Span;\n+\n+pub fn find_crate_name(sess: Option<&Session>,\n+                       attrs: &[ast::Attribute],\n+                       input: &Input) -> String {\n+    let validate = |s: String, span: Option<Span>| {\n+        cstore::validate_crate_name(sess, &s, span);\n+        s\n+    };\n+\n+    // Look in attributes 100% of the time to make sure the attribute is marked\n+    // as used. After doing this, however, we still prioritize a crate name from\n+    // the command line over one found in the #[crate_name] attribute. If we\n+    // find both we ensure that they're the same later on as well.\n+    let attr_crate_name = attrs.iter().find(|at| at.check_name(\"crate_name\"))\n+                               .and_then(|at| at.value_str().map(|s| (at, s)));\n+\n+    if let Some(sess) = sess {\n+        if let Some(ref s) = sess.opts.crate_name {\n+            if let Some((attr, name)) = attr_crate_name {\n+                if name != &**s {\n+                    let msg = format!(\"--crate-name and #[crate_name] are \\\n+                                       required to match, but `{}` != `{}`\",\n+                                      s, name);\n+                    sess.span_err(attr.span, &msg);\n+                }\n+            }\n+            return validate(s.clone(), None);\n+        }\n+    }\n+\n+    if let Some((attr, s)) = attr_crate_name {\n+        return validate(s.to_string(), Some(attr.span));\n+    }\n+    if let Input::File(ref path) = *input {\n+        if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n+            if s.starts_with(\"-\") {\n+                let msg = format!(\"crate names cannot start with a `-`, but \\\n+                                   `{}` has a leading hyphen\", s);\n+                if let Some(sess) = sess {\n+                    sess.err(&msg);\n+                }\n+            } else {\n+                return validate(s.replace(\"-\", \"_\"), None);\n+            }\n+        }\n+    }\n+\n+    \"rust_out\".to_string()\n+}\n+\n+pub fn filename_for_input(sess: &Session,\n+                          crate_type: config::CrateType,\n+                          crate_name: &str,\n+                          outputs: &OutputFilenames) -> PathBuf {\n+    let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n+\n+    match crate_type {\n+        config::CrateTypeRlib => {\n+            outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n+        }\n+        config::CrateTypeCdylib |\n+        config::CrateTypeProcMacro |\n+        config::CrateTypeDylib => {\n+            let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n+                                    &sess.target.target.options.dll_suffix);\n+            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n+                                                suffix))\n+        }\n+        config::CrateTypeStaticlib => {\n+            let (prefix, suffix) = (&sess.target.target.options.staticlib_prefix,\n+                                    &sess.target.target.options.staticlib_suffix);\n+            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n+                                                suffix))\n+        }\n+        config::CrateTypeExecutable => {\n+            let suffix = &sess.target.target.options.exe_suffix;\n+            let out_filename = outputs.path(OutputType::Exe);\n+            if suffix.is_empty() {\n+                out_filename.to_path_buf()\n+            } else {\n+                out_filename.with_extension(&suffix[1..])\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns default crate type for target\n+///\n+/// Default crate type is used when crate type isn't provided neither\n+/// through cmd line arguments nor through crate attributes\n+///\n+/// It is CrateTypeExecutable for all platforms but iOS as there is no\n+/// way to run iOS binaries anyway without jailbreaking and\n+/// interaction with Rust code through static library is the only\n+/// option for now\n+pub fn default_output_for_target(sess: &Session) -> config::CrateType {\n+    if !sess.target.target.options.executables {\n+        config::CrateTypeStaticlib\n+    } else {\n+        config::CrateTypeExecutable\n+    }\n+}\n+\n+/// Checks if target supports crate_type as output\n+pub fn invalid_output_for_target(sess: &Session,\n+                                 crate_type: config::CrateType) -> bool {\n+    match (sess.target.target.options.dynamic_linking,\n+           sess.target.target.options.executables, crate_type) {\n+        (false, _, config::CrateTypeCdylib) |\n+        (false, _, config::CrateTypeProcMacro) |\n+        (false, _, config::CrateTypeDylib) => true,\n+        (_, false, config::CrateTypeExecutable) => true,\n+        _ => false\n+    }\n+}"}, {"sha": "d185c061d5bd9fb6656b7240de820824447d2137", "filename": "src/rustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/edd82ee9f09c74188f88440db6586ef8e5b1c0b2/src%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.toml?ref=edd82ee9f09c74188f88440db6586ef8e5b1c0b2", "patch": "@@ -15,3 +15,4 @@ rustc_driver = { path = \"../librustc_driver\" }\n \n [features]\n jemalloc = [\"rustc_back/jemalloc\"]\n+llvm = [\"rustc_driver/llvm\"]"}]}