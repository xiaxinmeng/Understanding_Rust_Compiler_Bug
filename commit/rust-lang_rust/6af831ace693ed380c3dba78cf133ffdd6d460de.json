{"sha": "6af831ace693ed380c3dba78cf133ffdd6d460de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZjgzMWFjZTY5M2VkMzgwYzNkYmE3OGNmMTMzZmZkZDZkNDYwZGU=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2021-01-14T01:37:50Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2021-01-14T01:38:02Z"}, "message": "Add tracing instrumentation to method typeck\n\nI was recently digging into how this code works, and this\ninstrumentation was helpful.", "tree": {"sha": "0eba08989fc1b47a7613ea5a1942a75fcaf45539", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0eba08989fc1b47a7613ea5a1942a75fcaf45539"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6af831ace693ed380c3dba78cf133ffdd6d460de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6af831ace693ed380c3dba78cf133ffdd6d460de", "html_url": "https://github.com/rust-lang/rust/commit/6af831ace693ed380c3dba78cf133ffdd6d460de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6af831ace693ed380c3dba78cf133ffdd6d460de/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "html_url": "https://github.com/rust-lang/rust/commit/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae"}], "stats": {"total": 14, "additions": 12, "deletions": 2}, "files": [{"sha": "76ab7304d5d54d32db7059e4f3e371445005a80e", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6af831ace693ed380c3dba78cf133ffdd6d460de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af831ace693ed380c3dba78cf133ffdd6d460de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6af831ace693ed380c3dba78cf133ffdd6d460de", "patch": "@@ -31,6 +31,7 @@ impl<'a, 'tcx> Deref for ConfirmContext<'a, 'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n pub struct ConfirmResult<'tcx> {\n     pub callee: MethodCallee<'tcx>,\n     pub illegal_sized_bound: Option<Span>,"}, {"sha": "4ea1888ad2eb87d048838a6ab1d41e0a085e99d2", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6af831ace693ed380c3dba78cf133ffdd6d460de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af831ace693ed380c3dba78cf133ffdd6d460de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=6af831ace693ed380c3dba78cf133ffdd6d460de", "patch": "@@ -102,6 +102,7 @@ pub enum CandidateSource {\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn method_exists(\n         &self,\n         method_name: Ident,\n@@ -129,6 +130,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Adds a suggestion to call the given method to the provided diagnostic.\n+    #[instrument(level = \"debug\", skip(self, err, call_expr))]\n     crate fn suggest_method_call(\n         &self,\n         err: &mut DiagnosticBuilder<'a>,\n@@ -177,6 +179,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// * `span`:                  the span for the method call\n     /// * `call_expr`:             the complete method call: (`foo.bar::<T1,...Tn>(...)`)\n     /// * `self_expr`:             the self expression (`foo`)\n+    #[instrument(level = \"debug\", skip(self, call_expr, self_expr))]\n     pub fn lookup_method(\n         &self,\n         self_ty: Ty<'tcx>,\n@@ -204,6 +207,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let result =\n             self.confirm_method(span, self_expr, call_expr, self_ty, pick.clone(), segment);\n+        debug!(\"result = {:?}\", result);\n \n         if let Some(span) = result.illegal_sized_bound {\n             let mut needs_mut = false;\n@@ -256,6 +260,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Ok(result.callee)\n     }\n \n+    #[instrument(level = \"debug\", skip(self, call_expr))]\n     pub fn lookup_probe(\n         &self,\n         span: Span,\n@@ -286,6 +291,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // FIXME(#18741): it seems likely that we can consolidate some of this\n     // code with the other method-lookup code. In particular, the second half\n     // of this method is basically the same as confirmation.\n+    #[instrument(level = \"debug\", skip(self, span, opt_input_types))]\n     pub fn lookup_method_in_trait(\n         &self,\n         span: Span,\n@@ -409,6 +415,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Some(InferOk { obligations, value: callee })\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn resolve_ufcs(\n         &self,\n         span: Span,"}, {"sha": "ccf13030ac18d014c1c58c9c5f17535cebd1c60d", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6af831ace693ed380c3dba78cf133ffdd6d460de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af831ace693ed380c3dba78cf133ffdd6d460de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=6af831ace693ed380c3dba78cf133ffdd6d460de", "patch": "@@ -48,7 +48,7 @@ pub use self::PickKind::*;\n \n /// Boolean flag used to indicate if this search is for a suggestion\n /// or not. If true, we can allow ambiguity and so forth.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n pub struct IsSuggestion(pub bool);\n \n struct ProbeContext<'a, 'tcx> {\n@@ -219,6 +219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// would result in an error (basically, the same criteria we\n     /// would use to decide if a method is a plausible fit for\n     /// ambiguity purposes).\n+    #[instrument(level = \"debug\", skip(self, scope_expr_id))]\n     pub fn probe_for_return_type(\n         &self,\n         span: Span,\n@@ -264,6 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n+    #[instrument(level = \"debug\", skip(self, scope_expr_id))]\n     pub fn probe_for_name(\n         &self,\n         span: Span,\n@@ -770,7 +772,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // will be reported by `object_safety.rs` if the method refers to the\n         // `Self` type anywhere other than the receiver. Here, we use a\n         // substitution that replaces `Self` with the object type itself. Hence,\n-        // a `&self` method will wind up with an argument type like `&Trait`.\n+        // a `&self` method will wind up with an argument type like `&dyn Trait`.\n         let trait_ref = principal.with_self_ty(self.tcx, self_ty);\n         self.elaborate_bounds(iter::once(trait_ref), |this, new_trait_ref, item| {\n             let new_trait_ref = this.erase_late_bound_regions(new_trait_ref);"}]}