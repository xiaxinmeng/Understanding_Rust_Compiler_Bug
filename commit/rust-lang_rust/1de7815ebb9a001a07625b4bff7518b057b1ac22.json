{"sha": "1de7815ebb9a001a07625b4bff7518b057b1ac22", "node_id": "C_kwDOAAsO6NoAKDFkZTc4MTVlYmI5YTAwMWEwNzYyNWI0YmZmNzUxOGIwNTdiMWFjMjI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-11T15:02:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-11T15:02:45Z"}, "message": "Rollup merge of #91617 - nnethercote:improve-List-readability, r=lcnr\n\nImprove the readability of `List<T>`.\n\nThis commit does the following.\n- Expands on some of the things already mentioned in comments.\n- Describes the uniqueness assumption, which is critical but wasn't\n  mentioned at all.\n- Rewrites `empty()` into a clearer form, as provided by Daniel\n  Henry-Mantilla on Zulip.\n- Reorders things slightly so that more important things\n  are higher up, and incidental things are lower down, which makes\n  reading the code easier.\n\nr? ````@lcnr````", "tree": {"sha": "4ac4912b5b8024fcd22f756a7a9fcf9c7b851084", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ac4912b5b8024fcd22f756a7a9fcf9c7b851084"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1de7815ebb9a001a07625b4bff7518b057b1ac22", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhtL2WCRBK7hj4Ov3rIwAAHxwIAA97+zV9gJkXra/WPhBT4/DR\nyajqu+ITHzXW5KdkHDzNWHqgFckP9O0GeG1NQuuqTxOQR4Y+Z2NYMsUraewKXImi\nZm6KEa5Cub7hDJgY1SQasFnvvN6eRojOY5dVf1tezandz4FNUU1AkAhRXfdZIt+e\n0yoCmnIdPhsZIzI/Hf63LArliBA2LSbDYLFuUXV81JPk8l6Bb3xbSwvnfe7BD7UE\nGCjS0INQlnwdQF6GF0KE+szXXu3R4Rfh9VAzHiZzb1yWdJxmM5kOv9NdjQPGt2Sv\nSKLb7LMRiMGpNFeGVI+c7G33vIs9cVENCSMAJceaMzGUH1zUU7k8eazflzOjtQY=\n=mkAG\n-----END PGP SIGNATURE-----\n", "payload": "tree 4ac4912b5b8024fcd22f756a7a9fcf9c7b851084\nparent b9a37ad0d995c71518629b032f8e816e1efa8bca\nparent 769a70726963647c2be6b5a470547bf74088bcbe\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1639234965 +0100\ncommitter GitHub <noreply@github.com> 1639234965 +0100\n\nRollup merge of #91617 - nnethercote:improve-List-readability, r=lcnr\n\nImprove the readability of `List<T>`.\n\nThis commit does the following.\n- Expands on some of the things already mentioned in comments.\n- Describes the uniqueness assumption, which is critical but wasn't\n  mentioned at all.\n- Rewrites `empty()` into a clearer form, as provided by Daniel\n  Henry-Mantilla on Zulip.\n- Reorders things slightly so that more important things\n  are higher up, and incidental things are lower down, which makes\n  reading the code easier.\n\nr? ````@lcnr````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1de7815ebb9a001a07625b4bff7518b057b1ac22", "html_url": "https://github.com/rust-lang/rust/commit/1de7815ebb9a001a07625b4bff7518b057b1ac22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1de7815ebb9a001a07625b4bff7518b057b1ac22/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9a37ad0d995c71518629b032f8e816e1efa8bca", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9a37ad0d995c71518629b032f8e816e1efa8bca", "html_url": "https://github.com/rust-lang/rust/commit/b9a37ad0d995c71518629b032f8e816e1efa8bca"}, {"sha": "769a70726963647c2be6b5a470547bf74088bcbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/769a70726963647c2be6b5a470547bf74088bcbe", "html_url": "https://github.com/rust-lang/rust/commit/769a70726963647c2be6b5a470547bf74088bcbe"}], "stats": {"total": 140, "additions": 89, "deletions": 51}, "files": [{"sha": "adba7d131592ec81b11a1b4096499445edd57824", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 89, "deletions": 51, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/1de7815ebb9a001a07625b4bff7518b057b1ac22/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de7815ebb9a001a07625b4bff7518b057b1ac22/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=1de7815ebb9a001a07625b4bff7518b057b1ac22", "patch": "@@ -1,7 +1,5 @@\n use crate::arena::Arena;\n-\n use rustc_serialize::{Encodable, Encoder};\n-\n use std::alloc::Layout;\n use std::cmp::Ordering;\n use std::fmt;\n@@ -12,49 +10,69 @@ use std::ops::Deref;\n use std::ptr;\n use std::slice;\n \n-extern \"C\" {\n-    /// A dummy type used to force `List` to be unsized while not requiring references to it be wide\n-    /// pointers.\n-    type OpaqueListContents;\n-}\n-\n-/// A wrapper for slices with the additional invariant\n-/// that the slice is interned and no other slice with\n-/// the same contents can exist in the same context.\n-/// This means we can use pointer for both\n-/// equality comparisons and hashing.\n-///\n-/// Unlike slices, the types contained in `List` are expected to be `Copy`\n-/// and iterating over a `List` returns `T` instead of a reference.\n-///\n-/// Note: `Slice` was already taken by the `Ty`.\n+/// `List<T>` is a bit like `&[T]`, but with some critical differences.\n+/// - IMPORTANT: Every `List<T>` is *required* to have unique contents. The\n+///   type's correctness relies on this, *but it does not enforce it*.\n+///   Therefore, any code that creates a `List<T>` must ensure uniqueness\n+///   itself. In practice this is achieved by interning.\n+/// - The length is stored within the `List<T>`, so `&List<Ty>` is a thin\n+///   pointer.\n+/// - Because of this, you cannot get a `List<T>` that is a sub-list of another\n+///   `List<T>`. You can get a sub-slice `&[T]`, however.\n+/// - `List<T>` can be used with `CopyTaggedPtr`, which is useful within\n+///   structs whose size must be minimized.\n+/// - Because of the uniqueness assumption, we can use the address of a\n+///   `List<T>` for faster equality comparisons and hashing.\n+/// - `T` must be `Copy`. This lets `List<T>` be stored in a dropless arena and\n+///   iterators return a `T` rather than a `&T`.\n+/// - `T` must not be zero-sized.\n #[repr(C)]\n pub struct List<T> {\n     len: usize,\n+\n+    /// Although this claims to be a zero-length array, in practice `len`\n+    /// elements are actually present.\n     data: [T; 0],\n+\n     opaque: OpaqueListContents,\n }\n \n-unsafe impl<'a, T: 'a> rustc_data_structures::tagged_ptr::Pointer for &'a List<T> {\n-    const BITS: usize = std::mem::align_of::<usize>().trailing_zeros() as usize;\n-    #[inline]\n-    fn into_usize(self) -> usize {\n-        self as *const List<T> as usize\n-    }\n-    #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        &*(ptr as *const List<T>)\n-    }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        // Self: Copy so this is fine\n-        let ptr = Self::from_usize(ptr);\n-        f(&ptr)\n-    }\n+extern \"C\" {\n+    /// A dummy type used to force `List` to be unsized while not requiring\n+    /// references to it be wide pointers.\n+    type OpaqueListContents;\n }\n \n-unsafe impl<T: Sync> Sync for List<T> {}\n+impl<T> List<T> {\n+    /// Returns a reference to the (unique, static) empty list.\n+    #[inline(always)]\n+    pub fn empty<'a>() -> &'a List<T> {\n+        #[repr(align(64))]\n+        struct MaxAlign;\n+\n+        assert!(mem::align_of::<T>() <= mem::align_of::<MaxAlign>());\n+\n+        #[repr(C)]\n+        struct InOrder<T, U>(T, U);\n+\n+        // The empty slice is static and contains a single `0` usize (for the\n+        // length) that is 64-byte aligned, thus featuring the necessary\n+        // trailing padding for elements with up to 64-byte alignment.\n+        static EMPTY_SLICE: InOrder<usize, MaxAlign> = InOrder(0, MaxAlign);\n+        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n+    }\n+}\n \n impl<T: Copy> List<T> {\n+    /// Allocates a list from `arena` and copies the contents of `slice` into it.\n+    ///\n+    /// WARNING: the contents *must be unique*, such that no list with these\n+    /// contents has been previously created. If not, operations such as `eq`\n+    /// and `hash` might give incorrect results.\n+    ///\n+    /// Panics if `T` is `Drop`, or `T` is zero-sized, or the slice is empty\n+    /// (because the empty list exists statically, and is available via\n+    /// `empty()`).\n     #[inline]\n     pub(super) fn from_arena<'tcx>(arena: &'tcx Arena<'tcx>, slice: &[T]) -> &'tcx List<T> {\n         assert!(!mem::needs_drop::<T>());\n@@ -73,7 +91,7 @@ impl<T: Copy> List<T> {\n                 .cast::<T>()\n                 .copy_from_nonoverlapping(slice.as_ptr(), slice.len());\n \n-            &mut *mem\n+            &*mem\n         }\n     }\n \n@@ -107,11 +125,24 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for &List<T> {\n     }\n }\n \n+impl<T: PartialEq> PartialEq for List<T> {\n+    #[inline]\n+    fn eq(&self, other: &List<T>) -> bool {\n+        // Pointer equality implies list equality (due to the unique contents\n+        // assumption).\n+        ptr::eq(self, other)\n+    }\n+}\n+\n+impl<T: Eq> Eq for List<T> {}\n+\n impl<T> Ord for List<T>\n where\n     T: Ord,\n {\n     fn cmp(&self, other: &List<T>) -> Ordering {\n+        // Pointer equality implies list equality (due to the unique contents\n+        // assumption), but the contents must be compared otherwise.\n         if self == other { Ordering::Equal } else { <[T] as Ord>::cmp(&**self, &**other) }\n     }\n }\n@@ -121,6 +152,8 @@ where\n     T: PartialOrd,\n {\n     fn partial_cmp(&self, other: &List<T>) -> Option<Ordering> {\n+        // Pointer equality implies list equality (due to the unique contents\n+        // assumption), but the contents must be compared otherwise.\n         if self == other {\n             Some(Ordering::Equal)\n         } else {\n@@ -129,17 +162,11 @@ where\n     }\n }\n \n-impl<T: PartialEq> PartialEq for List<T> {\n-    #[inline]\n-    fn eq(&self, other: &List<T>) -> bool {\n-        ptr::eq(self, other)\n-    }\n-}\n-impl<T: Eq> Eq for List<T> {}\n-\n impl<T> Hash for List<T> {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n+        // Pointer hashing is sufficient (due to the unique contents\n+        // assumption).\n         (self as *const List<T>).hash(s)\n     }\n }\n@@ -168,13 +195,24 @@ impl<'a, T: Copy> IntoIterator for &'a List<T> {\n     }\n }\n \n-impl<T> List<T> {\n-    #[inline(always)]\n-    pub fn empty<'a>() -> &'a List<T> {\n-        #[repr(align(64), C)]\n-        struct EmptySlice([u8; 64]);\n-        static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n-        assert!(mem::align_of::<T>() <= 64);\n-        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n+unsafe impl<T: Sync> Sync for List<T> {}\n+\n+unsafe impl<'a, T: 'a> rustc_data_structures::tagged_ptr::Pointer for &'a List<T> {\n+    const BITS: usize = std::mem::align_of::<usize>().trailing_zeros() as usize;\n+\n+    #[inline]\n+    fn into_usize(self) -> usize {\n+        self as *const List<T> as usize\n+    }\n+\n+    #[inline]\n+    unsafe fn from_usize(ptr: usize) -> &'a List<T> {\n+        &*(ptr as *const List<T>)\n+    }\n+\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        // `Self` is `&'a List<T>` which impls `Copy`, so this is fine.\n+        let ptr = Self::from_usize(ptr);\n+        f(&ptr)\n     }\n }"}]}