{"sha": "5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNjFhOGRjMzRjM2UyZmM2ZDdmMDJjYjI4OGMzNTBmMDIzM2Y5NDQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-15T07:57:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-15T07:57:20Z"}, "message": "Rollup merge of #71824 - ecstatic-morse:const-check-post-drop-elab, r=oli-obk\n\nCheck for live drops in constants after drop elaboration\n\nResolves #66753.\n\nThis PR splits the MIR \"optimization\" pass series in two and introduces a query\u2013`mir_drops_elaborated_and_const_checked`\u2013that holds the result of the `post_borrowck_cleanup` analyses and checks for live drops. This query is invoked in `rustc_interface` for all items requiring const-checking, which means we now do `post_borrowck_cleanup` for items even if they are unused in the crate.\n\nAs a result, we are now more precise about when drops are live. This is because drop elaboration can e.g. eliminate drops of a local when all its fields are moved from. This does not mean we are doing value-based analysis on move paths, however; Storing a `Some(CustomDropImpl)` into a field of a local will still set the qualifs for that entire local.\n\nr? @oli-obk", "tree": {"sha": "964b60e75d4aae01cea79fb0ee20b72c93585f8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/964b60e75d4aae01cea79fb0ee20b72c93585f8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe5ynhCRBK7hj4Ov3rIwAAdHIIAG22YwzUmLEBZGlHkhVWuvZk\nOqc/4aPRjb0p7okKBXKNUKhmUtPet2xRZ4um666QdyTolQ2ky+SWMWFTu+wChOpv\nuZcMKRMIjvBBSJZ4iRIXorE9vLJ6nlGqMaHG5vnNNR/GOE78nn9PMZqAng7IRMRR\niymdXv76zZNfkVPa9RZU/ZUKkYHhH+XRyX/bygZIW7/svd5e/WItu/S7ASdUvBUG\nY/pJqyfka9ujq3h6mrc5Y7IWDG2z2gk9xjYIa6pvKl6sVTB8z+17ntRd/ivqZN74\noBCWgfIuPUd1qgb+Chty3DkVOEhPAJzV3kaOSFaPBUH3MNOJt3bCHVuPwxFyM5U=\n=bwBX\n-----END PGP SIGNATURE-----\n", "payload": "tree 964b60e75d4aae01cea79fb0ee20b72c93585f8f\nparent 4fb54ed484e2239a3e9eff3be17df00d2a162be3\nparent 2dcf7dbb8635a8fc3e972eac8204a83d616e1f50\nauthor Ralf Jung <post@ralfj.de> 1592207840 +0200\ncommitter GitHub <noreply@github.com> 1592207840 +0200\n\nRollup merge of #71824 - ecstatic-morse:const-check-post-drop-elab, r=oli-obk\n\nCheck for live drops in constants after drop elaboration\n\nResolves #66753.\n\nThis PR splits the MIR \"optimization\" pass series in two and introduces a query\u2013`mir_drops_elaborated_and_const_checked`\u2013that holds the result of the `post_borrowck_cleanup` analyses and checks for live drops. This query is invoked in `rustc_interface` for all items requiring const-checking, which means we now do `post_borrowck_cleanup` for items even if they are unused in the crate.\n\nAs a result, we are now more precise about when drops are live. This is because drop elaboration can e.g. eliminate drops of a local when all its fields are moved from. This does not mean we are doing value-based analysis on move paths, however; Storing a `Some(CustomDropImpl)` into a field of a local will still set the qualifs for that entire local.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "html_url": "https://github.com/rust-lang/rust/commit/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fb54ed484e2239a3e9eff3be17df00d2a162be3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fb54ed484e2239a3e9eff3be17df00d2a162be3", "html_url": "https://github.com/rust-lang/rust/commit/4fb54ed484e2239a3e9eff3be17df00d2a162be3"}, {"sha": "2dcf7dbb8635a8fc3e972eac8204a83d616e1f50", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dcf7dbb8635a8fc3e972eac8204a83d616e1f50", "html_url": "https://github.com/rust-lang/rust/commit/2dcf7dbb8635a8fc3e972eac8204a83d616e1f50"}], "stats": {"total": 315, "additions": 264, "deletions": 51}, "files": [{"sha": "0dcc3b62b4b2f66258b154a8b443989abef6bb49", "filename": "src/librustc_error_codes/error_codes/E0493.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -1,5 +1,4 @@\n-A type with a `Drop` implementation was destructured when trying to initialize\n-a static item.\n+A value with a custom `Drop` implementation may be dropped during const-eval.\n \n Erroneous code example:\n \n@@ -16,13 +15,14 @@ struct Foo {\n     field1: DropType,\n }\n \n-static FOO: Foo = Foo { ..Foo { field1: DropType::A } }; // error!\n+static FOO: Foo = Foo { field1: (DropType::A, DropType::A).1 }; // error!\n ```\n \n The problem here is that if the given type or one of its fields implements the\n-`Drop` trait, this `Drop` implementation cannot be called during the static\n-type initialization which might cause a memory leak. To prevent this issue,\n-you need to instantiate all the static type's fields by hand.\n+`Drop` trait, this `Drop` implementation cannot be called within a const\n+context since it may run arbitrary, non-const-checked code. To prevent this\n+issue, ensure all values with custom a custom `Drop` implementation escape the\n+initializer.\n \n ```\n enum DropType {"}, {"sha": "d186f35a12b5a1f9566ea39b2aa4e05a532af4d0", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -577,6 +577,9 @@ declare_features! (\n     /// Allows `extern \"avr-interrupt\" fn()` and `extern \"avr-non-blocking-interrupt\" fn()`.\n     (active, abi_avr_interrupt, \"1.45.0\", Some(69664), None),\n \n+    /// Be more precise when looking for live drops in a const context.\n+    (active, const_precise_live_drops, \"1.46.0\", Some(73255), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "1ed9bc3f1f509d0ac20144cf5cb5246a7ee282d3", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -847,7 +847,11 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n \n     sess.time(\"MIR_effect_checking\", || {\n         for def_id in tcx.body_owners() {\n-            mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n+            mir::transform::check_unsafety::check_unsafety(tcx, def_id);\n+\n+            if tcx.hir().body_const_context(def_id).is_some() {\n+                tcx.ensure().mir_drops_elaborated_and_const_checked(def_id);\n+            }\n         }\n     });\n "}, {"sha": "21f5d9e7dd4c6b678467edff5b37a07f03f459ee", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -76,7 +76,8 @@ pub enum MirPhase {\n     Build = 0,\n     Const = 1,\n     Validated = 2,\n-    Optimized = 3,\n+    DropElab = 3,\n+    Optimized = 4,\n }\n \n impl MirPhase {"}, {"sha": "d758b7737c3b962db6da13210b4ed89f00b21403", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -190,6 +190,12 @@ rustc_queries! {\n             no_hash\n         }\n \n+        query mir_drops_elaborated_and_const_checked(key: LocalDefId) -> Steal<mir::Body<'tcx>> {\n+            storage(ArenaCacheSelector<'tcx>)\n+            no_hash\n+            desc { |tcx| \"elaborating drops for `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        }\n+\n         query mir_validated(key: LocalDefId) ->\n             (\n                 Steal<mir::Body<'tcx>>,"}, {"sha": "e4aa88e3c20a7d611c218c4a74e94cb05b21a891", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::ty::{self, TyCtxt};\n pub use self::qualifs::Qualif;\n \n mod ops;\n+pub mod post_drop_elaboration;\n pub mod qualifs;\n mod resolver;\n pub mod validation;"}, {"sha": "d5059c98c9511053c4c14f9eb44f19ae421a3d7d", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -10,6 +10,22 @@ use rustc_span::{Span, Symbol};\n \n use super::ConstCx;\n \n+/// Emits an error if `op` is not allowed in the given const context.\n+pub fn non_const<O: NonConstOp>(ccx: &ConstCx<'_, '_>, op: O, span: Span) {\n+    debug!(\"illegal_op: op={:?}\", op);\n+\n+    if op.is_allowed_in_item(ccx) {\n+        return;\n+    }\n+\n+    if ccx.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+        ccx.tcx.sess.miri_unleashed_feature(span, O::feature_gate());\n+        return;\n+    }\n+\n+    op.emit_error(ccx, span);\n+}\n+\n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n     /// Returns the `Symbol` corresponding to the feature gate that would enable this operation,"}, {"sha": "226e0e2049ebd62a47818d324586309529c68650", "filename": "src/librustc_mir/transform/check_consts/post_drop_elaboration.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -0,0 +1,119 @@\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::mir::visit::Visitor;\n+use rustc_middle::mir::{self, BasicBlock, Location};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::Span;\n+\n+use super::ops;\n+use super::qualifs::{NeedsDrop, Qualif};\n+use super::validation::Qualifs;\n+use super::ConstCx;\n+\n+/// Returns `true` if we should use the more precise live drop checker that runs after drop\n+/// elaboration.\n+pub fn checking_enabled(tcx: TyCtxt<'tcx>) -> bool {\n+    tcx.features().const_precise_live_drops\n+}\n+\n+/// Look for live drops in a const context.\n+///\n+/// This is separate from the rest of the const checking logic because it must run after drop\n+/// elaboration.\n+pub fn check_live_drops(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &mir::Body<'tcx>) {\n+    let const_kind = tcx.hir().body_const_context(def_id);\n+    if const_kind.is_none() {\n+        return;\n+    }\n+\n+    if !checking_enabled(tcx) {\n+        return;\n+    }\n+\n+    let ccx = ConstCx {\n+        body,\n+        tcx,\n+        def_id: def_id.to_def_id(),\n+        const_kind,\n+        param_env: tcx.param_env(def_id),\n+    };\n+\n+    let mut visitor = CheckLiveDrops { ccx: &ccx, qualifs: Qualifs::default() };\n+\n+    visitor.visit_body(body);\n+}\n+\n+struct CheckLiveDrops<'mir, 'tcx> {\n+    ccx: &'mir ConstCx<'mir, 'tcx>,\n+    qualifs: Qualifs<'mir, 'tcx>,\n+}\n+\n+// So we can access `body` and `tcx`.\n+impl std::ops::Deref for CheckLiveDrops<'mir, 'tcx> {\n+    type Target = ConstCx<'mir, 'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.ccx\n+    }\n+}\n+\n+impl CheckLiveDrops<'mir, 'tcx> {\n+    fn check_live_drop(&self, span: Span) {\n+        ops::non_const(self.ccx, ops::LiveDrop, span);\n+    }\n+}\n+\n+impl Visitor<'tcx> for CheckLiveDrops<'mir, 'tcx> {\n+    fn visit_basic_block_data(&mut self, bb: BasicBlock, block: &mir::BasicBlockData<'tcx>) {\n+        trace!(\"visit_basic_block_data: bb={:?} is_cleanup={:?}\", bb, block.is_cleanup);\n+\n+        // Ignore drop terminators in cleanup blocks.\n+        if block.is_cleanup {\n+            return;\n+        }\n+\n+        self.super_basic_block_data(bb, block);\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n+        trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n+\n+        match &terminator.kind {\n+            mir::TerminatorKind::Drop { location: dropped_place, .. } => {\n+                let dropped_ty = dropped_place.ty(self.body, self.tcx).ty;\n+                if !NeedsDrop::in_any_value_of_ty(self.ccx, dropped_ty) {\n+                    return;\n+                }\n+\n+                if dropped_place.is_indirect() {\n+                    self.check_live_drop(terminator.source_info.span);\n+                    return;\n+                }\n+\n+                if self.qualifs.needs_drop(self.ccx, dropped_place.local, location) {\n+                    // Use the span where the dropped local was declared for the error.\n+                    let span = self.body.local_decls[dropped_place.local].source_info.span;\n+                    self.check_live_drop(span);\n+                }\n+            }\n+\n+            mir::TerminatorKind::DropAndReplace { .. } => span_bug!(\n+                terminator.source_info.span,\n+                \"`DropAndReplace` should be removed by drop elaboration\",\n+            ),\n+\n+            mir::TerminatorKind::Abort\n+            | mir::TerminatorKind::Call { .. }\n+            | mir::TerminatorKind::Assert { .. }\n+            | mir::TerminatorKind::FalseEdge { .. }\n+            | mir::TerminatorKind::FalseUnwind { .. }\n+            | mir::TerminatorKind::GeneratorDrop\n+            | mir::TerminatorKind::Goto { .. }\n+            | mir::TerminatorKind::InlineAsm { .. }\n+            | mir::TerminatorKind::Resume\n+            | mir::TerminatorKind::Return\n+            | mir::TerminatorKind::SwitchInt { .. }\n+            | mir::TerminatorKind::Unreachable\n+            | mir::TerminatorKind::Yield { .. } => {}\n+        }\n+    }\n+}"}, {"sha": "428a74bcdcbfba54599dbdf49723e40906ad5160", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -40,7 +40,7 @@ pub struct Qualifs<'mir, 'tcx> {\n }\n \n impl Qualifs<'mir, 'tcx> {\n-    fn indirectly_mutable(\n+    pub fn indirectly_mutable(\n         &mut self,\n         ccx: &'mir ConstCx<'mir, 'tcx>,\n         local: Local,\n@@ -68,7 +68,7 @@ impl Qualifs<'mir, 'tcx> {\n     /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary\n-    fn needs_drop(\n+    pub fn needs_drop(\n         &mut self,\n         ccx: &'mir ConstCx<'mir, 'tcx>,\n         local: Local,\n@@ -95,7 +95,7 @@ impl Qualifs<'mir, 'tcx> {\n     /// Returns `true` if `local` is `HasMutInterior` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary.\n-    fn has_mut_interior(\n+    pub fn has_mut_interior(\n         &mut self,\n         ccx: &'mir ConstCx<'mir, 'tcx>,\n         local: Local,\n@@ -232,30 +232,15 @@ impl Validator<'mir, 'tcx> {\n         self.qualifs.in_return_place(self.ccx)\n     }\n \n-    /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n-    /// context.\n-    pub fn check_op_spanned<O>(&mut self, op: O, span: Span)\n-    where\n-        O: NonConstOp,\n-    {\n-        debug!(\"check_op: op={:?}\", op);\n-\n-        if op.is_allowed_in_item(self) {\n-            return;\n-        }\n-\n-        if self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-            self.tcx.sess.miri_unleashed_feature(span, O::feature_gate());\n-            return;\n-        }\n-\n-        op.emit_error(self, span);\n-    }\n-\n     /// Emits an error if an expression cannot be evaluated in the current context.\n     pub fn check_op(&mut self, op: impl NonConstOp) {\n-        let span = self.span;\n-        self.check_op_spanned(op, span)\n+        ops::non_const(self.ccx, op, self.span);\n+    }\n+\n+    /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n+    /// context.\n+    pub fn check_op_spanned(&mut self, op: impl NonConstOp, span: Span) {\n+        ops::non_const(self.ccx, op, span);\n     }\n \n     fn check_static(&mut self, def_id: DefId, span: Span) {\n@@ -577,6 +562,12 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             // projections that cannot be `NeedsDrop`.\n             TerminatorKind::Drop { location: dropped_place, .. }\n             | TerminatorKind::DropAndReplace { location: dropped_place, .. } => {\n+                // If we are checking live drops after drop-elaboration, don't emit duplicate\n+                // errors here.\n+                if super::post_drop_elaboration::checking_enabled(self.tcx) {\n+                    return;\n+                }\n+\n                 let mut err_span = self.span;\n \n                 // Check to see if the type of this place can ever have a drop impl. If not, this"}, {"sha": "4240b528a6124c2be08d34ddcbb8ad0b55466b19", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -49,6 +49,7 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n         mir_const,\n         mir_const_qualif,\n         mir_validated,\n+        mir_drops_elaborated_and_const_checked,\n         optimized_mir,\n         is_mir_available,\n         promoted_mir,\n@@ -294,12 +295,31 @@ fn mir_validated(\n     (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n }\n \n-fn run_optimization_passes<'tcx>(\n+fn mir_drops_elaborated_and_const_checked<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+) -> Steal<Body<'tcx>> {\n+    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n+    // execute before we can steal.\n+    tcx.ensure().mir_borrowck(def_id);\n+\n+    let (body, _) = tcx.mir_validated(def_id);\n+    let mut body = body.steal();\n+\n+    run_post_borrowck_cleanup_passes(tcx, &mut body, def_id, None);\n+    check_consts::post_drop_elaboration::check_live_drops(tcx, def_id, &body);\n+    tcx.alloc_steal_mir(body)\n+}\n+\n+/// After this series of passes, no lifetime analysis based on borrowing can be done.\n+fn run_post_borrowck_cleanup_passes<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n     def_id: LocalDefId,\n     promoted: Option<Promoted>,\n ) {\n+    debug!(\"post_borrowck_cleanup({:?})\", def_id);\n+\n     let post_borrowck_cleanup: &[&dyn MirPass<'tcx>] = &[\n         // Remove all things only needed by analysis\n         &no_landing_pads::NoLandingPads::new(tcx),\n@@ -318,9 +338,24 @@ fn run_optimization_passes<'tcx>(\n         // but before optimizations begin.\n         &add_retag::AddRetag,\n         &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n-        // No lifetime analysis based on borrowing can be done from here on out.\n     ];\n \n+    run_passes(\n+        tcx,\n+        body,\n+        InstanceDef::Item(def_id.to_def_id()),\n+        promoted,\n+        MirPhase::DropElab,\n+        &[post_borrowck_cleanup],\n+    );\n+}\n+\n+fn run_optimization_passes<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    def_id: LocalDefId,\n+    promoted: Option<Promoted>,\n+) {\n     let optimizations: &[&dyn MirPass<'tcx>] = &[\n         &unreachable_prop::UnreachablePropagation,\n         &uninhabited_enum_branching::UninhabitedEnumBranching,\n@@ -368,14 +403,14 @@ fn run_optimization_passes<'tcx>(\n \n     let mir_opt_level = tcx.sess.opts.debugging_opts.mir_opt_level;\n \n+    #[rustfmt::skip]\n     run_passes(\n         tcx,\n         body,\n         InstanceDef::Item(def_id.to_def_id()),\n         promoted,\n         MirPhase::Optimized,\n         &[\n-            post_borrowck_cleanup,\n             if mir_opt_level > 0 { optimizations } else { no_optimizations },\n             pre_codegen_cleanup,\n         ],\n@@ -393,12 +428,7 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n \n     let def_id = def_id.expect_local();\n \n-    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n-    // execute before we can steal.\n-    tcx.ensure().mir_borrowck(def_id);\n-\n-    let (body, _) = tcx.mir_validated(def_id);\n-    let mut body = body.steal();\n+    let mut body = tcx.mir_drops_elaborated_and_const_checked(def_id).steal();\n     run_optimization_passes(tcx, &mut body, def_id, None);\n \n     debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");\n@@ -418,6 +448,7 @@ fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> IndexVec<Promoted, Body<'_>>\n     let mut promoted = promoted.steal();\n \n     for (p, mut body) in promoted.iter_enumerated_mut() {\n+        run_post_borrowck_cleanup_passes(tcx, &mut body, def_id, Some(p));\n         run_optimization_passes(tcx, &mut body, def_id, Some(p));\n     }\n "}, {"sha": "fdeb58b7b7a313608229ffa056b15e8caec96a81", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -227,6 +227,7 @@ symbols! {\n         const_loop,\n         const_mut_refs,\n         const_panic,\n+        const_precise_live_drops,\n         const_raw_ptr_deref,\n         const_raw_ptr_to_usize_cast,\n         const_transmute,"}, {"sha": "b4b6be8a1e5f0c9ff37c94d45897f0259939ca7b", "filename": "src/test/ui/consts/control-flow/drop-fail.precise.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.precise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.precise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.precise.stderr?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -0,0 +1,15 @@\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/drop-fail.rs:10:9\n+   |\n+LL |     let x = Some(Vec::new());\n+   |         ^ constants cannot evaluate destructors\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/drop-fail.rs:41:9\n+   |\n+LL |     let mut tmp = None;\n+   |         ^^^^^^^ constants cannot evaluate destructors\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0493`."}, {"sha": "7bd36726cead54238f57dc37ab308bc80765242b", "filename": "src/test/ui/consts/control-flow/drop-fail.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -1,11 +1,14 @@\n+// revisions: stock precise\n+\n #![feature(const_if_match)]\n #![feature(const_loop)]\n+#![cfg_attr(precise, feature(const_precise_live_drops))]\n \n-// `x` is *not* always moved into the final value may be dropped inside the initializer.\n+// `x` is *not* always moved into the final value and may be dropped inside the initializer.\n const _: Option<Vec<i32>> = {\n     let y: Option<Vec<i32>> = None;\n     let x = Some(Vec::new());\n-    //~^ ERROR destructors cannot be evaluated at compile-time\n+    //[stock,precise]~^ ERROR destructors cannot be evaluated at compile-time\n \n     if true {\n         x\n@@ -18,15 +21,15 @@ const _: Option<Vec<i32>> = {\n // existing analysis.\n const _: Vec<i32> = {\n     let vec_tuple = (Vec::new(),);\n-    //~^ ERROR destructors cannot be evaluated at compile-time\n+    //[stock]~^ ERROR destructors cannot be evaluated at compile-time\n \n     vec_tuple.0\n };\n \n // This applies to single-field enum variants as well.\n const _: Vec<i32> = {\n     let x: Result<_, Vec<i32>> = Ok(Vec::new());\n-    //~^ ERROR destructors cannot be evaluated at compile-time\n+    //[stock]~^ ERROR destructors cannot be evaluated at compile-time\n \n     match x {\n         Ok(x) | Err(x) => x,\n@@ -36,7 +39,7 @@ const _: Vec<i32> = {\n const _: Option<Vec<i32>> = {\n     let mut some = Some(Vec::new());\n     let mut tmp = None;\n-    //~^ ERROR destructors cannot be evaluated at compile-time\n+    //[stock,precise]~^ ERROR destructors cannot be evaluated at compile-time\n \n     let mut i = 0;\n     while i < 10 {", "previous_filename": "src/test/ui/consts/control-flow/drop-failure.rs"}, {"sha": "77cded5c438b5896b0bf4636bce6747da3b8a0bf", "filename": "src/test/ui/consts/control-flow/drop-fail.stock.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.stock.stderr?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -1,23 +1,23 @@\n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/drop-failure.rs:7:9\n+  --> $DIR/drop-fail.rs:10:9\n    |\n LL |     let x = Some(Vec::new());\n    |         ^ constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/drop-failure.rs:20:9\n+  --> $DIR/drop-fail.rs:23:9\n    |\n LL |     let vec_tuple = (Vec::new(),);\n    |         ^^^^^^^^^ constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/drop-failure.rs:28:9\n+  --> $DIR/drop-fail.rs:31:9\n    |\n LL |     let x: Result<_, Vec<i32>> = Ok(Vec::new());\n    |         ^ constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/drop-failure.rs:38:9\n+  --> $DIR/drop-fail.rs:41:9\n    |\n LL |     let mut tmp = None;\n    |         ^^^^^^^ constants cannot evaluate destructors", "previous_filename": "src/test/ui/consts/control-flow/drop-failure.stderr"}, {"sha": "b0afd76c4e6ef9aae0eb15661543d014c5eda31d", "filename": "src/test/ui/consts/control-flow/drop-pass.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-pass.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -1,7 +1,9 @@\n // run-pass\n+// revisions: stock precise\n \n #![feature(const_if_match)]\n #![feature(const_loop)]\n+#![cfg_attr(precise, feature(const_precise_live_drops))]\n \n // `x` is always moved into the final value and is not dropped inside the initializer.\n const _: Option<Vec<i32>> = {", "previous_filename": "src/test/ui/consts/control-flow/drop-success.rs"}, {"sha": "95df76d9905546bf81f703cfdc61871c3cb960cc", "filename": "src/test/ui/consts/control-flow/drop-precise.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-precise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c61a8dc34c3e2fc6d7f02cb288c350f0233f944/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-precise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-precise.rs?ref=5c61a8dc34c3e2fc6d7f02cb288c350f0233f944", "patch": "@@ -0,0 +1,20 @@\n+// run-pass\n+// gate-test-const_precise_live_drops\n+\n+#![feature(const_if_match)]\n+#![feature(const_loop)]\n+#![feature(const_precise_live_drops)]\n+\n+const _: Vec<i32> = {\n+    let vec_tuple = (Vec::new(),);\n+    vec_tuple.0\n+};\n+\n+const _: Vec<i32> = {\n+    let x: Result<_, Vec<i32>> = Ok(Vec::new());\n+    match x {\n+        Ok(x) | Err(x) => x,\n+    }\n+};\n+\n+fn main() {}"}]}