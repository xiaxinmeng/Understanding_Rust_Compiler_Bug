{"sha": "71f749a683731421c31591ea09f2623ef498c47a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZjc0OWE2ODM3MzE0MjFjMzE1OTFlYTA5ZjI2MjNlZjQ5OGM0N2E=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-01-18T21:32:20Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-19T16:51:57Z"}, "message": "Introduce a QueryEngine trait object.", "tree": {"sha": "000759817e011caf97988f9a981caa6582a6401a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/000759817e011caf97988f9a981caa6582a6401a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71f749a683731421c31591ea09f2623ef498c47a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71f749a683731421c31591ea09f2623ef498c47a", "html_url": "https://github.com/rust-lang/rust/commit/71f749a683731421c31591ea09f2623ef498c47a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71f749a683731421c31591ea09f2623ef498c47a/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23f9d10ea7f63e075f607c41d83f1411405b5a9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/23f9d10ea7f63e075f607c41d83f1411405b5a9c", "html_url": "https://github.com/rust-lang/rust/commit/23f9d10ea7f63e075f607c41d83f1411405b5a9c"}], "stats": {"total": 146, "additions": 92, "deletions": 54}, "files": [{"sha": "6c1e09b9bf944f1b80c0f294332d56162c1a5467", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71f749a683731421c31591ea09f2623ef498c47a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f749a683731421c31591ea09f2623ef498c47a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=71f749a683731421c31591ea09f2623ef498c47a", "patch": "@@ -14,7 +14,7 @@ use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::traits;\n-use crate::ty::query::{self, OnDiskCache, Queries, TyCtxtAt};\n+use crate::ty::query::{self, OnDiskCache, TyCtxtAt};\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n use crate::ty::TyKind::*;\n use crate::ty::{\n@@ -968,7 +968,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// This is `None` if we are not incremental compilation mode\n     pub(crate) on_disk_cache: Option<OnDiskCache<'tcx>>,\n \n-    pub queries: &'tcx query::Queries<'tcx>,\n+    pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n     pub query_caches: query::QueryCaches<'tcx>,\n \n     maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n@@ -1115,7 +1115,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         definitions: &'tcx Definitions,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<query::OnDiskCache<'tcx>>,\n-        queries: &'tcx Queries<'tcx>,\n+        queries: &'tcx dyn query::QueryEngine<'tcx>,\n         crate_name: &str,\n         output_filenames: &OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {"}, {"sha": "0abd5676557caf76e07303aefafba8810d2c9839", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/71f749a683731421c31591ea09f2623ef498c47a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f749a683731421c31591ea09f2623ef498c47a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=71f749a683731421c31591ea09f2623ef498c47a", "patch": "@@ -37,7 +37,7 @@ use rustc_data_structures::stable_hasher::StableVec;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::ErrorReported;\n+use rustc_errors::{Diagnostic, ErrorReported, Handler, Level};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n@@ -122,8 +122,7 @@ impl TyCtxt<'tcx> {\n     }\n \n     pub fn try_mark_green(self, dep_node: &dep_graph::DepNode) -> bool {\n-        let qcx = QueryCtxt { tcx: self, queries: self.queries };\n-        self.dep_graph.try_mark_green(qcx, dep_node).is_some()\n+        self.queries.try_mark_green(self, dep_node)\n     }\n }\n \n@@ -240,6 +239,40 @@ macro_rules! define_callbacks {\n         impl Clone for Providers {\n             fn clone(&self) -> Self { *self }\n         }\n+\n+        pub trait QueryEngine<'tcx>: rustc_data_structures::sync::Sync {\n+            #[cfg(parallel_compiler)]\n+            unsafe fn deadlock(&'tcx self, tcx: TyCtxt<'tcx>, registry: &rustc_rayon_core::Registry);\n+\n+            fn encode_query_results(\n+                &'tcx self,\n+                tcx: TyCtxt<'tcx>,\n+                encoder: &mut on_disk_cache::CacheEncoder<'a, 'tcx, opaque::FileEncoder>,\n+                query_result_index: &mut on_disk_cache::EncodedQueryResultIndex,\n+            ) -> opaque::FileEncodeResult;\n+\n+            fn exec_cache_promotions(&'tcx self, tcx: TyCtxt<'tcx>);\n+\n+            fn try_mark_green(&'tcx self, tcx: TyCtxt<'tcx>, dep_node: &dep_graph::DepNode) -> bool;\n+\n+            fn try_print_query_stack(\n+                &'tcx self,\n+                tcx: TyCtxt<'tcx>,\n+                query: Option<QueryJobId<dep_graph::DepKind>>,\n+                handler: &Handler,\n+                num_frames: Option<usize>,\n+            ) -> usize;\n+\n+            $($(#[$attr])*\n+            fn $name(\n+                &'tcx self,\n+                tcx: TyCtxt<$tcx>,\n+                span: Span,\n+                key: query_keys::$name<$tcx>,\n+                lookup: QueryLookup,\n+                mode: QueryMode,\n+            ) -> Option<query_stored::$name<$tcx>>;)*\n+        }\n     };\n }\n "}, {"sha": "79900fc76368fffac3e9436b3f16a7fab135cf03", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/71f749a683731421c31591ea09f2623ef498c47a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f749a683731421c31591ea09f2623ef498c47a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=71f749a683731421c31591ea09f2623ef498c47a", "patch": "@@ -2,8 +2,8 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{self, DepKind, DepNode, DepNodeExt, DepNodeIndex, SerializedDepNodeIndex};\n-use crate::ty::query::{on_disk_cache, queries, Queries, Query};\n+use crate::dep_graph::{DepKind, DepNode, DepNodeExt, DepNodeIndex, SerializedDepNodeIndex};\n+use crate::ty::query::{on_disk_cache, queries, Query};\n use crate::ty::tls::{self, ImplicitCtxt};\n use crate::ty::{self, TyCtxt};\n use rustc_query_system::dep_graph::HasDepContext;\n@@ -13,7 +13,7 @@ use rustc_query_system::query::{QueryContext, QueryDescription};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, Handler, Level};\n+use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder};\n use rustc_serialize::opaque;\n use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n@@ -266,49 +266,6 @@ impl<'tcx> QueryCtxt<'tcx> {\n     }\n }\n \n-impl<'tcx> Queries<'tcx> {\n-    pub fn try_print_query_stack(\n-        &'tcx self,\n-        tcx: TyCtxt<'tcx>,\n-        query: Option<QueryJobId<dep_graph::DepKind>>,\n-        handler: &Handler,\n-        num_frames: Option<usize>,\n-    ) -> usize {\n-        let query_map = self.try_collect_active_jobs();\n-\n-        let mut current_query = query;\n-        let mut i = 0;\n-\n-        while let Some(query) = current_query {\n-            if Some(i) == num_frames {\n-                break;\n-            }\n-            let query_info = if let Some(info) = query_map.as_ref().and_then(|map| map.get(&query))\n-            {\n-                info\n-            } else {\n-                break;\n-            };\n-            let mut diag = Diagnostic::new(\n-                Level::FailureNote,\n-                &format!(\n-                    \"#{} [{}] {}\",\n-                    i,\n-                    query_info.info.query.name(),\n-                    query_info.info.query.describe(QueryCtxt { tcx, queries: self })\n-                ),\n-            );\n-            diag.span = tcx.sess.source_map().guess_head_span(query_info.info.span).into();\n-            handler.force_print_diagnostic(diag);\n-\n-            current_query = query_info.job.parent;\n-            i += 1;\n-        }\n-\n-        i\n-    }\n-}\n-\n /// This struct stores metadata about each Query.\n ///\n /// Information is retrieved by indexing the `QUERIES` array using the integer value\n@@ -689,14 +646,16 @@ macro_rules! define_queries_struct {\n \n                 Some(jobs)\n             }\n+        }\n \n+        impl QueryEngine<'tcx> for Queries<'tcx> {\n             #[cfg(parallel_compiler)]\n-            pub unsafe fn deadlock(&'tcx self, tcx: TyCtxt<'tcx>, registry: &rustc_rayon_core::Registry) {\n+            unsafe fn deadlock(&'tcx self, tcx: TyCtxt<'tcx>, registry: &rustc_rayon_core::Registry) {\n                 let tcx = QueryCtxt { tcx, queries: self };\n                 rustc_query_system::query::deadlock(tcx, registry)\n             }\n \n-            pub(crate) fn encode_query_results(\n+            fn encode_query_results(\n                 &'tcx self,\n                 tcx: TyCtxt<'tcx>,\n                 encoder: &mut on_disk_cache::CacheEncoder<'a, 'tcx, opaque::FileEncoder>,\n@@ -711,6 +670,52 @@ macro_rules! define_queries_struct {\n                 tcx.dep_graph.exec_cache_promotions(tcx)\n             }\n \n+            fn try_mark_green(&'tcx self, tcx: TyCtxt<'tcx>, dep_node: &dep_graph::DepNode) -> bool {\n+                let qcx = QueryCtxt { tcx, queries: self };\n+                tcx.dep_graph.try_mark_green(qcx, dep_node).is_some()\n+            }\n+\n+            fn try_print_query_stack(\n+                &'tcx self,\n+                tcx: TyCtxt<'tcx>,\n+                query: Option<QueryJobId<dep_graph::DepKind>>,\n+                handler: &Handler,\n+                num_frames: Option<usize>,\n+            ) -> usize {\n+                let query_map = self.try_collect_active_jobs();\n+\n+                let mut current_query = query;\n+                let mut i = 0;\n+\n+                while let Some(query) = current_query {\n+                    if Some(i) == num_frames {\n+                        break;\n+                    }\n+                    let query_info = if let Some(info) = query_map.as_ref().and_then(|map| map.get(&query))\n+                    {\n+                        info\n+                    } else {\n+                        break;\n+                    };\n+                    let mut diag = Diagnostic::new(\n+                        Level::FailureNote,\n+                        &format!(\n+                            \"#{} [{}] {}\",\n+                            i,\n+                            query_info.info.query.name(),\n+                            query_info.info.query.describe(QueryCtxt { tcx, queries: self })\n+                        ),\n+                    );\n+                    diag.span = tcx.sess.source_map().guess_head_span(query_info.info.span).into();\n+                    handler.force_print_diagnostic(diag);\n+\n+                    current_query = query_info.job.parent;\n+                    i += 1;\n+                }\n+\n+                i\n+            }\n+\n             $($(#[$attr])*\n             #[inline(always)]\n             fn $name("}]}