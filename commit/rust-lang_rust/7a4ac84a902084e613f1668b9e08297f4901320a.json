{"sha": "7a4ac84a902084e613f1668b9e08297f4901320a", "node_id": "C_kwDOAAsO6NoAKDdhNGFjODRhOTAyMDg0ZTYxM2YxNjY4YjllMDgyOTdmNDkwMTMyMGE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-05-10T14:32:12Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-05-13T10:09:11Z"}, "message": "For non-defining opaque type usage errors, don't try to also prove all trait bounds", "tree": {"sha": "b6b90c44424f743291e5aa04b6617f8708a73dd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6b90c44424f743291e5aa04b6617f8708a73dd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a4ac84a902084e613f1668b9e08297f4901320a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4ac84a902084e613f1668b9e08297f4901320a", "html_url": "https://github.com/rust-lang/rust/commit/7a4ac84a902084e613f1668b9e08297f4901320a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a4ac84a902084e613f1668b9e08297f4901320a/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "253408b4090bc15b88bb5faecaf1e9765be80587", "url": "https://api.github.com/repos/rust-lang/rust/commits/253408b4090bc15b88bb5faecaf1e9765be80587", "html_url": "https://github.com/rust-lang/rust/commit/253408b4090bc15b88bb5faecaf1e9765be80587"}], "stats": {"total": 398, "additions": 108, "deletions": 290}, "files": [{"sha": "810737587912b6e1795e33ce87b97110d2146f9d", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 106, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/7a4ac84a902084e613f1668b9e08297f4901320a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4ac84a902084e613f1668b9e08297f4901320a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=7a4ac84a902084e613f1668b9e08297f4901320a", "patch": "@@ -1,11 +1,8 @@\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::DefId;\n use rustc_hir::OpaqueTyOrigin;\n use rustc_infer::infer::InferCtxt;\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, TyCtxt, TypeFoldable};\n-use rustc_span::Span;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n use super::RegionInferenceContext;\n@@ -107,21 +104,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             let opaque_type_key =\n                 OpaqueTypeKey { def_id: opaque_type_key.def_id, substs: universal_substs };\n-            let remapped_type = infcx.infer_opaque_definition_from_instantiation(\n+            let ty = infcx.infer_opaque_definition_from_instantiation(\n                 opaque_type_key,\n                 universal_concrete_type,\n                 origin,\n             );\n-            let ty = if check_opaque_type_parameter_valid(\n-                infcx.tcx,\n-                opaque_type_key,\n-                origin,\n-                concrete_type.span,\n-            ) {\n-                remapped_type\n-            } else {\n-                infcx.tcx.ty_error()\n-            };\n             // Sometimes two opaque types are the same only after we remap the generic parameters\n             // back to the opaque type definition. E.g. we may have `OpaqueType<X, Y>` mapped to `(X, Y)`\n             // and `OpaqueType<Y, X>` mapped to `(Y, X)`, and those are the same, but we only know that\n@@ -184,95 +171,3 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n }\n-\n-fn check_opaque_type_parameter_valid(\n-    tcx: TyCtxt<'_>,\n-    opaque_type_key: OpaqueTypeKey<'_>,\n-    origin: OpaqueTyOrigin,\n-    span: Span,\n-) -> bool {\n-    match origin {\n-        // No need to check return position impl trait (RPIT)\n-        // because for type and const parameters they are correct\n-        // by construction: we convert\n-        //\n-        // fn foo<P0..Pn>() -> impl Trait\n-        //\n-        // into\n-        //\n-        // type Foo<P0...Pn>\n-        // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n-        //\n-        // For lifetime parameters we convert\n-        //\n-        // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n-        //\n-        // into\n-        //\n-        // type foo::<'p0..'pn>::Foo<'q0..'qm>\n-        // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n-        //\n-        // which would error here on all of the `'static` args.\n-        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n-        // Check these\n-        OpaqueTyOrigin::TyAlias => {}\n-    }\n-    let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n-    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-    for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n-        let arg_is_param = match arg.unpack() {\n-            GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n-            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n-                tcx.sess\n-                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n-                        \"cannot use static lifetime; use a bound lifetime \\\n-                                    instead or remove the lifetime parameter from the \\\n-                                    opaque type\",\n-                    )\n-                    .emit();\n-                return false;\n-            }\n-            GenericArgKind::Lifetime(lt) => {\n-                matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n-            }\n-            GenericArgKind::Const(ct) => matches!(ct.val(), ty::ConstKind::Param(_)),\n-        };\n-\n-        if arg_is_param {\n-            seen_params.entry(arg).or_default().push(i);\n-        } else {\n-            // Prevent `fn foo() -> Foo<u32>` from being defining.\n-            let opaque_param = opaque_generics.param_at(i, tcx);\n-            tcx.sess\n-                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(\n-                    tcx.def_span(opaque_param.def_id),\n-                    &format!(\n-                        \"used non-generic {} `{}` for generic parameter\",\n-                        opaque_param.kind.descr(),\n-                        arg,\n-                    ),\n-                )\n-                .emit();\n-            return false;\n-        }\n-    }\n-\n-    for (_, indices) in seen_params {\n-        if indices.len() > 1 {\n-            let descr = opaque_generics.param_at(indices[0], tcx).kind.descr();\n-            let spans: Vec<_> = indices\n-                .into_iter()\n-                .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n-                .collect();\n-            tcx.sess\n-                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(spans, &format!(\"{} used multiple times\", descr))\n-                .emit();\n-            return false;\n-        }\n-    }\n-    true\n-}"}, {"sha": "238c6d9999075780d2fc29ba567f68514570b43d", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7a4ac84a902084e613f1668b9e08297f4901320a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4ac84a902084e613f1668b9e08297f4901320a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=7a4ac84a902084e613f1668b9e08297f4901320a", "patch": "@@ -82,6 +82,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         ));\n         debug!(?definition_ty);\n \n+        if !check_opaque_type_parameter_valid(\n+            self.tcx,\n+            opaque_type_key,\n+            origin,\n+            instantiated_ty.span,\n+        ) {\n+            return self.tcx.ty_error();\n+        }\n+\n         // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n         // on stable and we'd break that.\n         if let OpaqueTyOrigin::TyAlias = origin {\n@@ -148,6 +157,98 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n }\n \n+fn check_opaque_type_parameter_valid(\n+    tcx: TyCtxt<'_>,\n+    opaque_type_key: OpaqueTypeKey<'_>,\n+    origin: OpaqueTyOrigin,\n+    span: Span,\n+) -> bool {\n+    match origin {\n+        // No need to check return position impl trait (RPIT)\n+        // because for type and const parameters they are correct\n+        // by construction: we convert\n+        //\n+        // fn foo<P0..Pn>() -> impl Trait\n+        //\n+        // into\n+        //\n+        // type Foo<P0...Pn>\n+        // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n+        //\n+        // For lifetime parameters we convert\n+        //\n+        // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+        //\n+        // into\n+        //\n+        // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+        // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+        //\n+        // which would error here on all of the `'static` args.\n+        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n+        // Check these\n+        OpaqueTyOrigin::TyAlias => {}\n+    }\n+    let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n+    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+    for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n+        let arg_is_param = match arg.unpack() {\n+            GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n+            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n+                tcx.sess\n+                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                    .span_label(\n+                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n+                        \"cannot use static lifetime; use a bound lifetime \\\n+                                    instead or remove the lifetime parameter from the \\\n+                                    opaque type\",\n+                    )\n+                    .emit();\n+                return false;\n+            }\n+            GenericArgKind::Lifetime(lt) => {\n+                matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n+            }\n+            GenericArgKind::Const(ct) => matches!(ct.val(), ty::ConstKind::Param(_)),\n+        };\n+\n+        if arg_is_param {\n+            seen_params.entry(arg).or_default().push(i);\n+        } else {\n+            // Prevent `fn foo() -> Foo<u32>` from being defining.\n+            let opaque_param = opaque_generics.param_at(i, tcx);\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(\n+                    tcx.def_span(opaque_param.def_id),\n+                    &format!(\n+                        \"used non-generic {} `{}` for generic parameter\",\n+                        opaque_param.kind.descr(),\n+                        arg,\n+                    ),\n+                )\n+                .emit();\n+            return false;\n+        }\n+    }\n+\n+    for (_, indices) in seen_params {\n+        if indices.len() > 1 {\n+            let descr = opaque_generics.param_at(indices[0], tcx).kind.descr();\n+            let spans: Vec<_> = indices\n+                .into_iter()\n+                .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n+                .collect();\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(spans, &format!(\"{} used multiple times\", descr))\n+                .emit();\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n struct ReverseMapper<'tcx> {\n     tcx: TyCtxt<'tcx>,\n "}, {"sha": "093c1c231861f1893fb4c0e68d35a21546575ddc", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs?ref=7a4ac84a902084e613f1668b9e08297f4901320a", "patch": "@@ -15,7 +15,6 @@ type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n     t\n     //~^ ERROR non-defining opaque type use in defining scope\n-    //~| ERROR `U` doesn't implement `Debug`\n }\n \n fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {"}, {"sha": "b2edcc5526a4abf329785fae9802006c1e3c3a76", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr?ref=7a4ac84a902084e613f1668b9e08297f4901320a", "patch": "@@ -1,14 +1,3 @@\n-error[E0277]: `U` doesn't implement `Debug`\n-  --> $DIR/generic_duplicate_param_use.rs:16:5\n-   |\n-LL |     t\n-   |     ^ `U` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n-   |\n-help: consider restricting type parameter `U`\n-   |\n-LL | type TwoTys<T, U: std::fmt::Debug> = impl Debug;\n-   |                 +++++++++++++++++\n-\n error: non-defining opaque type use in defining scope\n   --> $DIR/generic_duplicate_param_use.rs:16:5\n    |\n@@ -22,7 +11,7 @@ LL | type TwoTys<T, U> = impl Debug;\n    |             ^  ^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:22:5\n+  --> $DIR/generic_duplicate_param_use.rs:21:5\n    |\n LL |     t\n    |     ^\n@@ -34,7 +23,7 @@ LL | type TwoLifetimes<'a, 'b> = impl Debug;\n    |                   ^^  ^^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:27:5\n+  --> $DIR/generic_duplicate_param_use.rs:26:5\n    |\n LL |     t\n    |     ^\n@@ -45,6 +34,5 @@ note: constant used multiple times\n LL | type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n    |                ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "4fc7679311a2e55b031dd0cf0c460c979476212b", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=7a4ac84a902084e613f1668b9e08297f4901320a", "patch": "@@ -19,14 +19,6 @@ where\n     fn iter_bits(self, n: u8) -> Self::BitsIter {\n         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n         //~^ ERROR non-defining opaque type use in defining scope\n-        //~| ERROR type mismatch resolving\n-        //~| ERROR type mismatch resolving `<T as TryInto<u8>>::Error == E`\n-        //~| ERROR no implementation for `T >> T`\n-        //~| ERROR no implementation for `T & T`\n-        //~| ERROR the trait bound `T: From<u8>`\n-        //~| ERROR the trait bound `T: Copy` is not satisfied\n-        //~| ERROR `E` doesn't implement `Debug`\n-        //~| ERROR the trait bound `u8: From<T>` is not satisfied\n     }\n }\n "}, {"sha": "bbc93657be32f27501c851460adbfb0554ee0826", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.stderr", "status": "modified", "additions": 1, "deletions": 132, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr?ref=7a4ac84a902084e613f1668b9e08297f4901320a", "patch": "@@ -1,132 +1,3 @@\n-error[E0271]: type mismatch resolving `<[closure@$DIR/issue-60564.rs:20:28: 20:100] as FnOnce<(u8,)>>::Output == I`\n-  --> $DIR/issue-60564.rs:20:9\n-   |\n-LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n-   |                         - this type parameter\n-...\n-LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found type parameter `I`\n-   |\n-   = note:        expected type `u8`\n-           found type parameter `I`\n-   = note: required because of the requirements on the impl of `Iterator` for `Map<Rev<std::ops::Range<u8>>, [closure@$DIR/issue-60564.rs:20:28: 20:100]>`\n-\n-error[E0271]: type mismatch resolving `<T as TryInto<u8>>::Error == E`\n-  --> $DIR/issue-60564.rs:20:9\n-   |\n-LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n-   |                      - this type parameter\n-...\n-LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `E`, found enum `Infallible`\n-   |\n-   = note: expected type parameter `E`\n-                        found enum `Infallible`\n-note: required by a bound in `<T as IterBits>`\n-  --> $DIR/issue-60564.rs:15:37\n-   |\n-LL |         + std::convert::TryInto<u8, Error = E>,\n-   |                                     ^^^^^^^^^ required by this bound in `<T as IterBits>`\n-\n-error[E0277]: no implementation for `T >> T`\n-  --> $DIR/issue-60564.rs:20:9\n-   |\n-LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `T >> T`\n-   |\n-note: required by a bound in `<T as IterBits>`\n-  --> $DIR/issue-60564.rs:12:8\n-   |\n-LL |     T: std::ops::Shr<Output = T>\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `<T as IterBits>`\n-help: consider restricting type parameter `T`\n-   |\n-LL | type IterBitsIter<T: std::ops::Shr, E, I> = impl std::iter::Iterator<Item = I>;\n-   |                    +++++++++++++++\n-\n-error[E0277]: no implementation for `T & T`\n-  --> $DIR/issue-60564.rs:20:9\n-   |\n-LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `T & T`\n-   |\n-note: required by a bound in `<T as IterBits>`\n-  --> $DIR/issue-60564.rs:13:11\n-   |\n-LL |         + std::ops::BitAnd<T, Output = T>\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `<T as IterBits>`\n-help: consider restricting type parameter `T`\n-   |\n-LL | type IterBitsIter<T: std::ops::BitAnd, E, I> = impl std::iter::Iterator<Item = I>;\n-   |                    ++++++++++++++++++\n-\n-error[E0277]: the trait bound `T: From<u8>` is not satisfied\n-  --> $DIR/issue-60564.rs:20:9\n-   |\n-LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `From<u8>` is not implemented for `T`\n-   |\n-note: required by a bound in `<T as IterBits>`\n-  --> $DIR/issue-60564.rs:14:11\n-   |\n-LL |         + std::convert::From<u8>\n-   |           ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `<T as IterBits>`\n-help: consider restricting type parameter `T`\n-   |\n-LL | type IterBitsIter<T: std::convert::From<u8>, E, I> = impl std::iter::Iterator<Item = I>;\n-   |                    ++++++++++++++++++++++++\n-\n-error[E0277]: the trait bound `T: Copy` is not satisfied\n-  --> $DIR/issue-60564.rs:20:9\n-   |\n-LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `T`\n-   |\n-note: required by a bound in `<T as IterBits>`\n-  --> $DIR/issue-60564.rs:10:9\n-   |\n-LL | impl<T: Copy, E> IterBits for T\n-   |         ^^^^ required by this bound in `<T as IterBits>`\n-help: consider restricting type parameter `T`\n-   |\n-LL | type IterBitsIter<T: std::marker::Copy, E, I> = impl std::iter::Iterator<Item = I>;\n-   |                    +++++++++++++++++++\n-\n-error[E0277]: `E` doesn't implement `Debug`\n-  --> $DIR/issue-60564.rs:20:9\n-   |\n-LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `E` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n-   |\n-note: required by a bound in `<T as IterBits>`\n-  --> $DIR/issue-60564.rs:16:8\n-   |\n-LL |     E: std::fmt::Debug,\n-   |        ^^^^^^^^^^^^^^^ required by this bound in `<T as IterBits>`\n-help: consider restricting type parameter `E`\n-   |\n-LL | type IterBitsIter<T, E: std::fmt::Debug, I> = impl std::iter::Iterator<Item = I>;\n-   |                       +++++++++++++++++\n-\n-error[E0277]: the trait bound `u8: From<T>` is not satisfied\n-  --> $DIR/issue-60564.rs:20:9\n-   |\n-LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `From<T>` is not implemented for `u8`\n-   |\n-   = note: required because of the requirements on the impl of `Into<u8>` for `T`\n-   = note: required because of the requirements on the impl of `TryFrom<T>` for `u8`\n-   = note: required because of the requirements on the impl of `TryInto<u8>` for `T`\n-note: required by a bound in `<T as IterBits>`\n-  --> $DIR/issue-60564.rs:15:11\n-   |\n-LL |         + std::convert::TryInto<u8, Error = E>,\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `<T as IterBits>`\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n-   |\n-LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I> where u8: From<T>;\n-   |                                                                 +++++++++++++++++\n-\n error: non-defining opaque type use in defining scope\n   --> $DIR/issue-60564.rs:20:9\n    |\n@@ -139,7 +10,5 @@ note: used non-generic type `u8` for generic parameter\n LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n    |                         ^\n \n-error: aborting due to 9 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0271, E0277.\n-For more information about an error, try `rustc --explain E0271`."}, {"sha": "b50462bf237bb9509f9d090097ef9675af48b8b8", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs?ref=7a4ac84a902084e613f1668b9e08297f4901320a", "patch": "@@ -8,7 +8,6 @@ type Alias<'a, U> = impl Trait<U>;\n \n fn f<'a>() -> Alias<'a, ()> {}\n //~^ ERROR non-defining opaque type use in defining scope\n-//~| ERROR the trait bound `(): Trait<U>` is not satisfied\n \n fn main() {}\n "}, {"sha": "8059621b61a096bc84ed17714d7130d44e864d72", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr?ref=7a4ac84a902084e613f1668b9e08297f4901320a", "patch": "@@ -1,14 +1,3 @@\n-error[E0277]: the trait bound `(): Trait<U>` is not satisfied\n-  --> $DIR/issue-68368-non-defining-use.rs:9:29\n-   |\n-LL | fn f<'a>() -> Alias<'a, ()> {}\n-   |                             ^^ the trait `Trait<U>` is not implemented for `()`\n-   |\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n-   |\n-LL | type Alias<'a, U> = impl Trait<U> where (): Trait<U>;\n-   |                                   ++++++++++++++++++\n-\n error: non-defining opaque type use in defining scope\n   --> $DIR/issue-68368-non-defining-use.rs:9:29\n    |\n@@ -21,6 +10,5 @@ note: used non-generic type `()` for generic parameter\n LL | type Alias<'a, U> = impl Trait<U>;\n    |                ^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "428454bc04844d836b75c3a7fbde6796a1e84b53", "filename": "src/test/ui/type-alias-impl-trait/issue-69136-inner-lifetime-resolve-error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs?ref=7a4ac84a902084e613f1668b9e08297f4901320a", "patch": "@@ -19,6 +19,5 @@ type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n \n fn my_fun() -> Return<()> {}\n //~^ ERROR non-defining opaque type use in defining scope\n-//~| ERROR non-defining opaque type use in defining scope\n \n fn main() {}"}, {"sha": "7b50c8af26e5fe98d74a704b12ff57060e2f612b", "filename": "src/test/ui/type-alias-impl-trait/issue-69136-inner-lifetime-resolve-error.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a4ac84a902084e613f1668b9e08297f4901320a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr?ref=7a4ac84a902084e613f1668b9e08297f4901320a", "patch": "@@ -26,18 +26,6 @@ note: used non-generic type `()` for generic parameter\n LL | type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n    |             ^\n \n-error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-69136-inner-lifetime-resolve-error.rs:20:27\n-   |\n-LL | fn my_fun() -> Return<()> {}\n-   |                           ^^\n-   |\n-note: used non-generic type `()` for generic parameter\n-  --> $DIR/issue-69136-inner-lifetime-resolve-error.rs:17:13\n-   |\n-LL | type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n-   |             ^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0261`."}]}