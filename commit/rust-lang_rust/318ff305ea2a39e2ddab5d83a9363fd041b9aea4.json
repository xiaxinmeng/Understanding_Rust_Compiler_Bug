{"sha": "318ff305ea2a39e2ddab5d83a9363fd041b9aea4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxOGZmMzA1ZWEyYTM5ZTJkZGFiNWQ4M2E5MzYzZmQwNDFiOWFlYTQ=", "commit": {"author": {"name": "BO41", "email": "botbob@disroot.org", "date": "2019-10-05T10:23:10Z"}, "committer": {"name": "BO41", "email": "botbob@disroot.org", "date": "2019-10-05T10:23:10Z"}, "message": "Fix typo on `now()` comments", "tree": {"sha": "cb9f0c08b719dd1eb18bc50c99485311ac502a2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb9f0c08b719dd1eb18bc50c99485311ac502a2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/318ff305ea2a39e2ddab5d83a9363fd041b9aea4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/318ff305ea2a39e2ddab5d83a9363fd041b9aea4", "html_url": "https://github.com/rust-lang/rust/commit/318ff305ea2a39e2ddab5d83a9363fd041b9aea4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/318ff305ea2a39e2ddab5d83a9363fd041b9aea4/comments", "author": null, "committer": null, "parents": [{"sha": "7870050796e5904a0fc85ecbe6fa6dde1cfe0c91", "url": "https://api.github.com/repos/rust-lang/rust/commits/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91", "html_url": "https://github.com/rust-lang/rust/commit/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91"}], "stats": {"total": 51, "additions": 23, "deletions": 28}, "files": [{"sha": "e1ae01b602a8db8d97e1620837b79af23a485d04", "filename": "src/libstd/time.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/318ff305ea2a39e2ddab5d83a9363fd041b9aea4/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318ff305ea2a39e2ddab5d83a9363fd041b9aea4/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=318ff305ea2a39e2ddab5d83a9363fd041b9aea4", "patch": "@@ -15,10 +15,10 @@\n use crate::cmp;\n use crate::error::Error;\n use crate::fmt;\n-use crate::ops::{Add, Sub, AddAssign, SubAssign};\n+use crate::ops::{Add, AddAssign, Sub, SubAssign};\n use crate::sys::time;\n-use crate::sys_common::FromInner;\n use crate::sys_common::mutex::Mutex;\n+use crate::sys_common::FromInner;\n \n #[stable(feature = \"time\", since = \"1.3.0\")]\n pub use core::time::Duration;\n@@ -216,17 +216,17 @@ impl Instant {\n         // * https://bugzilla.mozilla.org/show_bug.cgi?id=1487778 - a similar\n         //   Firefox bug\n         //\n-        // It simply seems that this it just happens so that a lot in the wild\n-        // we're seeing panics across various platforms where consecutive calls\n+        // It seems that this just happens a lot in the wild.\n+        // We're seeing panics across various platforms where consecutive calls\n         // to `Instant::now`, such as via the `elapsed` function, are panicking\n         // as they're going backwards. Placed here is a last-ditch effort to try\n         // to fix things up. We keep a global \"latest now\" instance which is\n         // returned instead of what the OS says if the OS goes backwards.\n         //\n-        // To hopefully mitigate the impact of this though a few platforms are\n+        // To hopefully mitigate the impact of this, a few platforms are\n         // whitelisted as \"these at least haven't gone backwards yet\".\n         if time::Instant::actually_monotonic() {\n-            return Instant(os_now)\n+            return Instant(os_now);\n         }\n \n         static LOCK: Mutex = Mutex::new();\n@@ -353,8 +353,7 @@ impl Add<Duration> for Instant {\n     ///\n     /// [`checked_add`]: ../../std/time/struct.Instant.html#method.checked_add\n     fn add(self, other: Duration) -> Instant {\n-        self.checked_add(other)\n-            .expect(\"overflow when adding duration to instant\")\n+        self.checked_add(other).expect(\"overflow when adding duration to instant\")\n     }\n }\n \n@@ -370,8 +369,7 @@ impl Sub<Duration> for Instant {\n     type Output = Instant;\n \n     fn sub(self, other: Duration) -> Instant {\n-        self.checked_sub(other)\n-            .expect(\"overflow when subtracting duration from instant\")\n+        self.checked_sub(other).expect(\"overflow when subtracting duration from instant\")\n     }\n }\n \n@@ -464,8 +462,7 @@ impl SystemTime {\n     /// println!(\"{:?}\", difference);\n     /// ```\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n-    pub fn duration_since(&self, earlier: SystemTime)\n-                          -> Result<Duration, SystemTimeError> {\n+    pub fn duration_since(&self, earlier: SystemTime) -> Result<Duration, SystemTimeError> {\n         self.0.sub_time(&earlier.0).map_err(SystemTimeError)\n     }\n \n@@ -532,8 +529,7 @@ impl Add<Duration> for SystemTime {\n     ///\n     /// [`checked_add`]: ../../std/time/struct.SystemTime.html#method.checked_add\n     fn add(self, dur: Duration) -> SystemTime {\n-        self.checked_add(dur)\n-            .expect(\"overflow when adding duration to instant\")\n+        self.checked_add(dur).expect(\"overflow when adding duration to instant\")\n     }\n }\n \n@@ -549,8 +545,7 @@ impl Sub<Duration> for SystemTime {\n     type Output = SystemTime;\n \n     fn sub(self, dur: Duration) -> SystemTime {\n-        self.checked_sub(dur)\n-            .expect(\"overflow when subtracting duration from instant\")\n+        self.checked_sub(dur).expect(\"overflow when subtracting duration from instant\")\n     }\n }\n \n@@ -626,7 +621,9 @@ impl SystemTimeError {\n \n #[stable(feature = \"time2\", since = \"1.8.0\")]\n impl Error for SystemTimeError {\n-    fn description(&self) -> &str { \"other time was not earlier than self\" }\n+    fn description(&self) -> &str {\n+        \"other time was not earlier than self\"\n+    }\n }\n \n #[stable(feature = \"time2\", since = \"1.8.0\")]\n@@ -644,17 +641,16 @@ impl FromInner<time::SystemTime> for SystemTime {\n \n #[cfg(test)]\n mod tests {\n-    use super::{Instant, SystemTime, Duration, UNIX_EPOCH};\n+    use super::{Duration, Instant, SystemTime, UNIX_EPOCH};\n \n     macro_rules! assert_almost_eq {\n-        ($a:expr, $b:expr) => ({\n+        ($a:expr, $b:expr) => {{\n             let (a, b) = ($a, $b);\n             if a != b {\n-                let (a, b) = if a > b {(a, b)} else {(b, a)};\n-                assert!(a - Duration::new(0, 1000) <= b,\n-                        \"{:?} is not almost equal to {:?}\", a, b);\n+                let (a, b) = if a > b { (a, b) } else { (b, a) };\n+                assert!(a - Duration::new(0, 1000) <= b, \"{:?} is not almost equal to {:?}\", a, b);\n             }\n-        })\n+        }};\n     }\n \n     #[test]\n@@ -729,7 +725,7 @@ mod tests {\n     fn instant_saturating_duration_since_nopanic() {\n         let a = Instant::now();\n         let ret = (a - Duration::new(1, 0)).saturating_duration_since(a);\n-        assert_eq!(ret, Duration::new(0,0));\n+        assert_eq!(ret, Duration::new(0, 0));\n     }\n \n     #[test]\n@@ -755,15 +751,14 @@ mod tests {\n \n         let second = Duration::new(1, 0);\n         assert_almost_eq!(a.duration_since(a - second).unwrap(), second);\n-        assert_almost_eq!(a.duration_since(a + second).unwrap_err()\n-                           .duration(), second);\n+        assert_almost_eq!(a.duration_since(a + second).unwrap_err().duration(), second);\n \n         assert_almost_eq!(a - second + second, a);\n         assert_almost_eq!(a.checked_sub(second).unwrap().checked_add(second).unwrap(), a);\n \n         let one_second_from_epoch = UNIX_EPOCH + Duration::new(1, 0);\n-        let one_second_from_epoch2 = UNIX_EPOCH + Duration::new(0, 500_000_000)\n-            + Duration::new(0, 500_000_000);\n+        let one_second_from_epoch2 =\n+            UNIX_EPOCH + Duration::new(0, 500_000_000) + Duration::new(0, 500_000_000);\n         assert_eq!(one_second_from_epoch, one_second_from_epoch2);\n \n         // checked_add_duration will not panic on overflow"}]}