{"sha": "cf04603dca6c37366fb010a36dd05047f7b70b1e", "node_id": "C_kwDOAAsO6NoAKGNmMDQ2MDNkY2E2YzM3MzY2ZmIwMTBhMzZkZDA1MDQ3ZjdiNzBiMWU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-27T17:48:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-27T17:48:47Z"}, "message": "Rollup merge of #104265 - faern:move-ipaddr-to-core, r=joshtriplett\n\nMove IpAddr, SocketAddr and V4+V6 related types to `core`\n\nImplements RFC https://github.com/rust-lang/rfcs/pull/2832. The RFC has completed FCP with disposition merge, but is not yet merged.\n\nMoves IP types to `core` as specified in the RFC.\n\nThe full list of moved types is: `IpAddr`, `Ipv4Addr`, `Ipv6Addr`, `SocketAddr`, `SocketAddrV4`, `SocketAddrV6`, `Ipv6MulticastScope` and `AddrParseError`.\n\nDoing this move was one of the main driving arguments behind #78802.", "tree": {"sha": "9777a714795c748b98ee1f03e82b4f43d4876d86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9777a714795c748b98ee1f03e82b4f43d4876d86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf04603dca6c37366fb010a36dd05047f7b70b1e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj/Oz/CRBK7hj4Ov3rIwAA3QQIAHqBHDbAgU2XVM+GmHkectwh\nMgtgW930lHf4rWqpNJzgad5mjBuhSP5UGfNmE5cIViucllPEbx+tZdELZBl43+Vh\nvsVd0egoPW4W65taiOpal9BrcsbkJwTp61XB7R1ZyfvMNHegyCNel7As+p0Yc8Yo\nfC0T1e3WfYxYhcFDZCr8vMkdgv585o3mnkq+v38k5DJNXkz7LF5HRe7f162YgcRy\ncuYkCSEt+a7wl/t4k/IPBYz/BJwOTIexzWNHvoPKWsAcORbx4iHHDv41QCzCOQgs\np+tETFTx6PHSPZ8JGPtEAuAwTnI/Z6aYAkmJt+qJkt5AobBxHyrJSwpScR/Rvco=\n=Rxam\n-----END PGP SIGNATURE-----\n", "payload": "tree 9777a714795c748b98ee1f03e82b4f43d4876d86\nparent 7d782b7ff4d57170e110211565209ecc5bbb3907\nparent 1291216ac986ccc1432bf0bf2db9545e5251dd24\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1677520127 +0100\ncommitter GitHub <noreply@github.com> 1677520127 +0100\n\nRollup merge of #104265 - faern:move-ipaddr-to-core, r=joshtriplett\n\nMove IpAddr, SocketAddr and V4+V6 related types to `core`\n\nImplements RFC https://github.com/rust-lang/rfcs/pull/2832. The RFC has completed FCP with disposition merge, but is not yet merged.\n\nMoves IP types to `core` as specified in the RFC.\n\nThe full list of moved types is: `IpAddr`, `Ipv4Addr`, `Ipv6Addr`, `SocketAddr`, `SocketAddrV4`, `SocketAddrV6`, `Ipv6MulticastScope` and `AddrParseError`.\n\nDoing this move was one of the main driving arguments behind #78802.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf04603dca6c37366fb010a36dd05047f7b70b1e", "html_url": "https://github.com/rust-lang/rust/commit/cf04603dca6c37366fb010a36dd05047f7b70b1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf04603dca6c37366fb010a36dd05047f7b70b1e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d782b7ff4d57170e110211565209ecc5bbb3907", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d782b7ff4d57170e110211565209ecc5bbb3907", "html_url": "https://github.com/rust-lang/rust/commit/7d782b7ff4d57170e110211565209ecc5bbb3907"}, {"sha": "1291216ac986ccc1432bf0bf2db9545e5251dd24", "url": "https://api.github.com/repos/rust-lang/rust/commits/1291216ac986ccc1432bf0bf2db9545e5251dd24", "html_url": "https://github.com/rust-lang/rust/commit/1291216ac986ccc1432bf0bf2db9545e5251dd24"}], "stats": {"total": 7865, "additions": 4080, "deletions": 3785}, "files": [{"sha": "0c57ed1034a6a35b936a7e18bcb5a09c5ab736ed", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -124,6 +124,8 @@\n #![feature(const_inherent_unchecked_arith)]\n #![feature(const_int_unchecked_arith)]\n #![feature(const_intrinsic_forget)]\n+#![feature(const_ipv4)]\n+#![feature(const_ipv6)]\n #![feature(const_likely)]\n #![feature(const_maybe_uninit_uninit_array)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n@@ -179,6 +181,7 @@\n #![feature(const_slice_index)]\n #![feature(const_is_char_boundary)]\n #![feature(const_cstr_methods)]\n+#![feature(ip)]\n #![feature(is_ascii_octdigit)]\n //\n // Language features:\n@@ -349,6 +352,7 @@ pub mod cell;\n pub mod char;\n pub mod ffi;\n pub mod iter;\n+pub mod net;\n pub mod option;\n pub mod panic;\n pub mod panicking;"}, {"sha": "7aadf06e92fc6a5b80c04ea34f4256ee07295cee", "filename": "library/core/src/net/display_buffer.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Fnet%2Fdisplay_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Fnet%2Fdisplay_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fdisplay_buffer.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "previous_filename": "library/std/src/net/display_buffer.rs"}, {"sha": "954d88d548e82cbb2eee1faea25d33918825d447", "filename": "library/core/src/net/ip_addr.rs", "status": "added", "additions": 2070, "deletions": 0, "changes": 2070, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Fnet%2Fip_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Fnet%2Fip_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fip_addr.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -0,0 +1,2070 @@\n+use crate::cmp::Ordering;\n+use crate::fmt::{self, Write};\n+use crate::mem::transmute;\n+\n+use super::display_buffer::DisplayBuffer;\n+\n+/// An IP address, either IPv4 or IPv6.\n+///\n+/// This enum can contain either an [`Ipv4Addr`] or an [`Ipv6Addr`], see their\n+/// respective documentation for more details.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+///\n+/// let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n+/// let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+///\n+/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost_v4));\n+/// assert_eq!(\"::1\".parse(), Ok(localhost_v6));\n+///\n+/// assert_eq!(localhost_v4.is_ipv6(), false);\n+/// assert_eq!(localhost_v4.is_ipv4(), true);\n+/// ```\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"IpAddr\")]\n+#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]\n+pub enum IpAddr {\n+    /// An IPv4 address.\n+    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+    V4(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv4Addr),\n+    /// An IPv6 address.\n+    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+    V6(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv6Addr),\n+}\n+\n+/// An IPv4 address.\n+///\n+/// IPv4 addresses are defined as 32-bit integers in [IETF RFC 791].\n+/// They are usually represented as four octets.\n+///\n+/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n+///\n+/// [IETF RFC 791]: https://tools.ietf.org/html/rfc791\n+///\n+/// # Textual representation\n+///\n+/// `Ipv4Addr` provides a [`FromStr`] implementation. The four octets are in decimal\n+/// notation, divided by `.` (this is called \"dot-decimal notation\").\n+/// Notably, octal numbers (which are indicated with a leading `0`) and hexadecimal numbers (which\n+/// are indicated with a leading `0x`) are not allowed per [IETF RFC 6943].\n+///\n+/// [IETF RFC 6943]: https://tools.ietf.org/html/rfc6943#section-3.1.1\n+/// [`FromStr`]: crate::str::FromStr\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::Ipv4Addr;\n+///\n+/// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n+/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost));\n+/// assert_eq!(localhost.is_loopback(), true);\n+/// assert!(\"012.004.002.000\".parse::<Ipv4Addr>().is_err()); // all octets are in octal\n+/// assert!(\"0000000.0.0.0\".parse::<Ipv4Addr>().is_err()); // first octet is a zero in octal\n+/// assert!(\"0xcb.0x0.0x71.0x00\".parse::<Ipv4Addr>().is_err()); // all octets are in hex\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Ipv4Addr {\n+    octets: [u8; 4],\n+}\n+\n+/// An IPv6 address.\n+///\n+/// IPv6 addresses are defined as 128-bit integers in [IETF RFC 4291].\n+/// They are usually represented as eight 16-bit segments.\n+///\n+/// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+///\n+/// # Embedding IPv4 Addresses\n+///\n+/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n+///\n+/// To assist in the transition from IPv4 to IPv6 two types of IPv6 addresses that embed an IPv4 address were defined:\n+/// IPv4-compatible and IPv4-mapped addresses. Of these IPv4-compatible addresses have been officially deprecated.\n+///\n+/// Both types of addresses are not assigned any special meaning by this implementation,\n+/// other than what the relevant standards prescribe. This means that an address like `::ffff:127.0.0.1`,\n+/// while representing an IPv4 loopback address, is not itself an IPv6 loopback address; only `::1` is.\n+/// To handle these so called \"IPv4-in-IPv6\" addresses, they have to first be converted to their canonical IPv4 address.\n+///\n+/// ### IPv4-Compatible IPv6 Addresses\n+///\n+/// IPv4-compatible IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.1], and have been officially deprecated.\n+/// The RFC describes the format of an \"IPv4-Compatible IPv6 address\" as follows:\n+///\n+/// ```text\n+/// |                80 bits               | 16 |      32 bits        |\n+/// +--------------------------------------+--------------------------+\n+/// |0000..............................0000|0000|    IPv4 address     |\n+/// +--------------------------------------+----+---------------------+\n+/// ```\n+/// So `::a.b.c.d` would be an IPv4-compatible IPv6 address representing the IPv4 address `a.b.c.d`.\n+///\n+/// To convert from an IPv4 address to an IPv4-compatible IPv6 address, use [`Ipv4Addr::to_ipv6_compatible`].\n+/// Use [`Ipv6Addr::to_ipv4`] to convert an IPv4-compatible IPv6 address to the canonical IPv4 address.\n+///\n+/// [IETF RFC 4291 Section 2.5.5.1]: https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.1\n+///\n+/// ### IPv4-Mapped IPv6 Addresses\n+///\n+/// IPv4-mapped IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.2].\n+/// The RFC describes the format of an \"IPv4-Mapped IPv6 address\" as follows:\n+///\n+/// ```text\n+/// |                80 bits               | 16 |      32 bits        |\n+/// +--------------------------------------+--------------------------+\n+/// |0000..............................0000|FFFF|    IPv4 address     |\n+/// +--------------------------------------+----+---------------------+\n+/// ```\n+/// So `::ffff:a.b.c.d` would be an IPv4-mapped IPv6 address representing the IPv4 address `a.b.c.d`.\n+///\n+/// To convert from an IPv4 address to an IPv4-mapped IPv6 address, use [`Ipv4Addr::to_ipv6_mapped`].\n+/// Use [`Ipv6Addr::to_ipv4`] to convert an IPv4-mapped IPv6 address to the canonical IPv4 address.\n+/// Note that this will also convert the IPv6 loopback address `::1` to `0.0.0.1`. Use\n+/// [`Ipv6Addr::to_ipv4_mapped`] to avoid this.\n+///\n+/// [IETF RFC 4291 Section 2.5.5.2]: https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2\n+///\n+/// # Textual representation\n+///\n+/// `Ipv6Addr` provides a [`FromStr`] implementation. There are many ways to represent\n+/// an IPv6 address in text, but in general, each segments is written in hexadecimal\n+/// notation, and segments are separated by `:`. For more information, see\n+/// [IETF RFC 5952].\n+///\n+/// [`FromStr`]: crate::str::FromStr\n+/// [IETF RFC 5952]: https://tools.ietf.org/html/rfc5952\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::Ipv6Addr;\n+///\n+/// let localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n+/// assert_eq!(\"::1\".parse(), Ok(localhost));\n+/// assert_eq!(localhost.is_loopback(), true);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Ipv6Addr {\n+    octets: [u8; 16],\n+}\n+\n+/// Scope of an [IPv6 multicast address] as defined in [IETF RFC 7346 section 2].\n+///\n+/// # Stability Guarantees\n+///\n+/// Not all possible values for a multicast scope have been assigned.\n+/// Future RFCs may introduce new scopes, which will be added as variants to this enum;\n+/// because of this the enum is marked as `#[non_exhaustive]`.\n+///\n+/// # Examples\n+/// ```\n+/// #![feature(ip)]\n+///\n+/// use std::net::Ipv6Addr;\n+/// use std::net::Ipv6MulticastScope::*;\n+///\n+/// // An IPv6 multicast address with global scope (`ff0e::`).\n+/// let address = Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0);\n+///\n+/// // Will print \"Global scope\".\n+/// match address.multicast_scope() {\n+///     Some(InterfaceLocal) => println!(\"Interface-Local scope\"),\n+///     Some(LinkLocal) => println!(\"Link-Local scope\"),\n+///     Some(RealmLocal) => println!(\"Realm-Local scope\"),\n+///     Some(AdminLocal) => println!(\"Admin-Local scope\"),\n+///     Some(SiteLocal) => println!(\"Site-Local scope\"),\n+///     Some(OrganizationLocal) => println!(\"Organization-Local scope\"),\n+///     Some(Global) => println!(\"Global scope\"),\n+///     Some(_) => println!(\"Unknown scope\"),\n+///     None => println!(\"Not a multicast address!\")\n+/// }\n+///\n+/// ```\n+///\n+/// [IPv6 multicast address]: Ipv6Addr\n+/// [IETF RFC 7346 section 2]: https://tools.ietf.org/html/rfc7346#section-2\n+#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n+#[unstable(feature = \"ip\", issue = \"27709\")]\n+#[non_exhaustive]\n+pub enum Ipv6MulticastScope {\n+    /// Interface-Local scope.\n+    InterfaceLocal,\n+    /// Link-Local scope.\n+    LinkLocal,\n+    /// Realm-Local scope.\n+    RealmLocal,\n+    /// Admin-Local scope.\n+    AdminLocal,\n+    /// Site-Local scope.\n+    SiteLocal,\n+    /// Organization-Local scope.\n+    OrganizationLocal,\n+    /// Global scope.\n+    Global,\n+}\n+\n+impl IpAddr {\n+    /// Returns [`true`] for the special 'unspecified' address.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_unspecified()`] and\n+    /// [`Ipv6Addr::is_unspecified()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)).is_unspecified(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)).is_unspecified(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unspecified(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_unspecified(),\n+            IpAddr::V6(ip) => ip.is_unspecified(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if this is a loopback address.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_loopback()`] and\n+    /// [`Ipv6Addr::is_loopback()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).is_loopback(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1)).is_loopback(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_loopback(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_loopback(),\n+            IpAddr::V6(ip) => ip.is_loopback(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if the address appears to be globally routable.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_global()`] and\n+    /// [`Ipv6Addr::is_global()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_global(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_global(),\n+            IpAddr::V6(ip) => ip.is_global(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if this is a multicast address.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_multicast()`] and\n+    /// [`Ipv6Addr::is_multicast()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(224, 254, 0, 0)).is_multicast(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0)).is_multicast(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_multicast(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_multicast(),\n+            IpAddr::V6(ip) => ip.is_multicast(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if this address is in a range designated for documentation.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_documentation()`] and\n+    /// [`Ipv6Addr::is_documentation()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_documentation(), true);\n+    /// assert_eq!(\n+    ///     IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_documentation(),\n+    ///     true\n+    /// );\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_documentation(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_documentation(),\n+            IpAddr::V6(ip) => ip.is_documentation(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if this address is in a range designated for benchmarking.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_benchmarking()`] and\n+    /// [`Ipv6Addr::is_benchmarking()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(198, 19, 255, 255)).is_benchmarking(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0x2, 0, 0, 0, 0, 0, 0)).is_benchmarking(), true);\n+    /// ```\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_benchmarking(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_benchmarking(),\n+            IpAddr::V6(ip) => ip.is_benchmarking(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if this address is an [`IPv4` address], and [`false`]\n+    /// otherwise.\n+    ///\n+    /// [`IPv4` address]: IpAddr::V4\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_ipv4(&self) -> bool {\n+        matches!(self, IpAddr::V4(_))\n+    }\n+\n+    /// Returns [`true`] if this address is an [`IPv6` address], and [`false`]\n+    /// otherwise.\n+    ///\n+    /// [`IPv6` address]: IpAddr::V6\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_ipv6(&self) -> bool {\n+        matches!(self, IpAddr::V6(_))\n+    }\n+\n+    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped IPv6 addresses, otherwise it\n+    /// return `self` as-is.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).to_canonical().is_loopback(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1)).is_loopback(), false);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1)).to_canonical().is_loopback(), true);\n+    /// ```\n+    #[inline]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    pub const fn to_canonical(&self) -> IpAddr {\n+        match self {\n+            &v4 @ IpAddr::V4(_) => v4,\n+            IpAddr::V6(v6) => v6.to_canonical(),\n+        }\n+    }\n+}\n+\n+impl Ipv4Addr {\n+    /// Creates a new IPv4 address from four eight-bit octets.\n+    ///\n+    /// The result will represent the IP address `a`.`b`.`c`.`d`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n+        Ipv4Addr { octets: [a, b, c, d] }\n+    }\n+\n+    /// An IPv4 address with the address pointing to localhost: `127.0.0.1`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::LOCALHOST;\n+    /// assert_eq!(addr, Ipv4Addr::new(127, 0, 0, 1));\n+    /// ```\n+    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n+    pub const LOCALHOST: Self = Ipv4Addr::new(127, 0, 0, 1);\n+\n+    /// An IPv4 address representing an unspecified address: `0.0.0.0`\n+    ///\n+    /// This corresponds to the constant `INADDR_ANY` in other languages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::UNSPECIFIED;\n+    /// assert_eq!(addr, Ipv4Addr::new(0, 0, 0, 0));\n+    /// ```\n+    #[doc(alias = \"INADDR_ANY\")]\n+    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n+    pub const UNSPECIFIED: Self = Ipv4Addr::new(0, 0, 0, 0);\n+\n+    /// An IPv4 address representing the broadcast address: `255.255.255.255`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::BROADCAST;\n+    /// assert_eq!(addr, Ipv4Addr::new(255, 255, 255, 255));\n+    /// ```\n+    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n+    pub const BROADCAST: Self = Ipv4Addr::new(255, 255, 255, 255);\n+\n+    /// Returns the four eight-bit integers that make up this address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n+    /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn octets(&self) -> [u8; 4] {\n+        self.octets\n+    }\n+\n+    /// Returns [`true`] for the special 'unspecified' address (`0.0.0.0`).\n+    ///\n+    /// This property is defined in _UNIX Network Programming, Second Edition_,\n+    /// W. Richard Stevens, p. 891; see also [ip7].\n+    ///\n+    /// [ip7]: https://man7.org/linux/man-pages/man7/ip.7.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_unspecified(), true);\n+    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_unspecified(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n+    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unspecified(&self) -> bool {\n+        u32::from_be_bytes(self.octets) == 0\n+    }\n+\n+    /// Returns [`true`] if this is a loopback address (`127.0.0.0/8`).\n+    ///\n+    /// This property is defined by [IETF RFC 1122].\n+    ///\n+    /// [IETF RFC 1122]: https://tools.ietf.org/html/rfc1122\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n+    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_loopback(&self) -> bool {\n+        self.octets()[0] == 127\n+    }\n+\n+    /// Returns [`true`] if this is a private address.\n+    ///\n+    /// The private address ranges are defined in [IETF RFC 1918] and include:\n+    ///\n+    ///  - `10.0.0.0/8`\n+    ///  - `172.16.0.0/12`\n+    ///  - `192.168.0.0/16`\n+    ///\n+    /// [IETF RFC 1918]: https://tools.ietf.org/html/rfc1918\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(10, 0, 0, 1).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(10, 10, 10, 10).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 10).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 29, 45, 14).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 32, 0, 2).is_private(), false);\n+    /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_private(&self) -> bool {\n+        match self.octets() {\n+            [10, ..] => true,\n+            [172, b, ..] if b >= 16 && b <= 31 => true,\n+            [192, 168, ..] => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns [`true`] if the address is link-local (`169.254.0.0/16`).\n+    ///\n+    /// This property is defined by [IETF RFC 3927].\n+    ///\n+    /// [IETF RFC 3927]: https://tools.ietf.org/html/rfc3927\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 0, 0).is_link_local(), true);\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n+    /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_link_local(&self) -> bool {\n+        matches!(self.octets(), [169, 254, ..])\n+    }\n+\n+    /// Returns [`true`] if the address appears to be globally reachable\n+    /// as specified by the [IANA IPv4 Special-Purpose Address Registry].\n+    /// Whether or not an address is practically reachable will depend on your network configuration.\n+    ///\n+    /// Most IPv4 addresses are globally reachable;\n+    /// unless they are specifically defined as *not* globally reachable.\n+    ///\n+    /// Non-exhaustive list of notable addresses that are not globally reachable:\n+    ///\n+    /// - The [unspecified address] ([`is_unspecified`](Ipv4Addr::is_unspecified))\n+    /// - Addresses reserved for private use ([`is_private`](Ipv4Addr::is_private))\n+    /// - Addresses in the shared address space ([`is_shared`](Ipv4Addr::is_shared))\n+    /// - Loopback addresses ([`is_loopback`](Ipv4Addr::is_loopback))\n+    /// - Link-local addresses ([`is_link_local`](Ipv4Addr::is_link_local))\n+    /// - Addresses reserved for documentation ([`is_documentation`](Ipv4Addr::is_documentation))\n+    /// - Addresses reserved for benchmarking ([`is_benchmarking`](Ipv4Addr::is_benchmarking))\n+    /// - Reserved addresses ([`is_reserved`](Ipv4Addr::is_reserved))\n+    /// - The [broadcast address] ([`is_broadcast`](Ipv4Addr::is_broadcast))\n+    ///\n+    /// For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv4 Special-Purpose Address Registry].\n+    ///\n+    /// [IANA IPv4 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\n+    /// [unspecified address]: Ipv4Addr::UNSPECIFIED\n+    /// [broadcast address]: Ipv4Addr::BROADCAST\n+\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// // Most IPv4 addresses are globally reachable:\n+    /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n+    ///\n+    /// // However some addresses have been assigned a special meaning\n+    /// // that makes them not globally reachable. Some examples are:\n+    ///\n+    /// // The unspecified address (`0.0.0.0`)\n+    /// assert_eq!(Ipv4Addr::UNSPECIFIED.is_global(), false);\n+    ///\n+    /// // Addresses reserved for private use (`10.0.0.0/8`, `172.16.0.0/12`, 192.168.0.0/16)\n+    /// assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n+    ///\n+    /// // Addresses in the shared address space (`100.64.0.0/10`)\n+    /// assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n+    ///\n+    /// // The loopback addresses (`127.0.0.0/8`)\n+    /// assert_eq!(Ipv4Addr::LOCALHOST.is_global(), false);\n+    ///\n+    /// // Link-local addresses (`169.254.0.0/16`)\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n+    ///\n+    /// // Addresses reserved for documentation (`192.0.2.0/24`, `198.51.100.0/24`, `203.0.113.0/24`)\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n+    ///\n+    /// // Addresses reserved for benchmarking (`198.18.0.0/15`)\n+    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n+    ///\n+    /// // Reserved addresses (`240.0.0.0/4`)\n+    /// assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n+    ///\n+    /// // The broadcast address (`255.255.255.255`)\n+    /// assert_eq!(Ipv4Addr::BROADCAST.is_global(), false);\n+    ///\n+    /// // For a complete overview see the IANA IPv4 Special-Purpose Address Registry.\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_global(&self) -> bool {\n+        !(self.octets()[0] == 0 // \"This network\"\n+            || self.is_private()\n+            || self.is_shared()\n+            || self.is_loopback()\n+            || self.is_link_local()\n+            // addresses reserved for future protocols (`192.0.0.0/24`)\n+            ||(self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0)\n+            || self.is_documentation()\n+            || self.is_benchmarking()\n+            || self.is_reserved()\n+            || self.is_broadcast())\n+    }\n+\n+    /// Returns [`true`] if this address is part of the Shared Address Space defined in\n+    /// [IETF RFC 6598] (`100.64.0.0/10`).\n+    ///\n+    /// [IETF RFC 6598]: https://tools.ietf.org/html/rfc6598\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(100, 64, 0, 0).is_shared(), true);\n+    /// assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n+    /// assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_shared(&self) -> bool {\n+        self.octets()[0] == 100 && (self.octets()[1] & 0b1100_0000 == 0b0100_0000)\n+    }\n+\n+    /// Returns [`true`] if this address part of the `198.18.0.0/15` range, which is reserved for\n+    /// network devices benchmarking. This range is defined in [IETF RFC 2544] as `192.18.0.0`\n+    /// through `198.19.255.255` but [errata 423] corrects it to `198.18.0.0/15`.\n+    ///\n+    /// [IETF RFC 2544]: https://tools.ietf.org/html/rfc2544\n+    /// [errata 423]: https://www.rfc-editor.org/errata/eid423\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(198, 17, 255, 255).is_benchmarking(), false);\n+    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_benchmarking(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_benchmarking(&self) -> bool {\n+        self.octets()[0] == 198 && (self.octets()[1] & 0xfe) == 18\n+    }\n+\n+    /// Returns [`true`] if this address is reserved by IANA for future use. [IETF RFC 1112]\n+    /// defines the block of reserved addresses as `240.0.0.0/4`. This range normally includes the\n+    /// broadcast address `255.255.255.255`, but this implementation explicitly excludes it, since\n+    /// it is obviously not reserved for future use.\n+    ///\n+    /// [IETF RFC 1112]: https://tools.ietf.org/html/rfc1112\n+    ///\n+    /// # Warning\n+    ///\n+    /// As IANA assigns new addresses, this method will be\n+    /// updated. This may result in non-reserved addresses being\n+    /// treated as reserved in code that relies on an outdated version\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(240, 0, 0, 0).is_reserved(), true);\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 254).is_reserved(), true);\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(239, 255, 255, 255).is_reserved(), false);\n+    /// // The broadcast address is not considered as reserved for future use by this implementation\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_reserved(&self) -> bool {\n+        self.octets()[0] & 240 == 240 && !self.is_broadcast()\n+    }\n+\n+    /// Returns [`true`] if this is a multicast address (`224.0.0.0/4`).\n+    ///\n+    /// Multicast addresses have a most significant octet between `224` and `239`,\n+    /// and is defined by [IETF RFC 5771].\n+    ///\n+    /// [IETF RFC 5771]: https://tools.ietf.org/html/rfc5771\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(224, 254, 0, 0).is_multicast(), true);\n+    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_multicast(&self) -> bool {\n+        self.octets()[0] >= 224 && self.octets()[0] <= 239\n+    }\n+\n+    /// Returns [`true`] if this is a broadcast address (`255.255.255.255`).\n+    ///\n+    /// A broadcast address has all octets set to `255` as defined in [IETF RFC 919].\n+    ///\n+    /// [IETF RFC 919]: https://tools.ietf.org/html/rfc919\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n+    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_broadcast(&self) -> bool {\n+        u32::from_be_bytes(self.octets()) == u32::from_be_bytes(Self::BROADCAST.octets())\n+    }\n+\n+    /// Returns [`true`] if this address is in a range designated for documentation.\n+    ///\n+    /// This is defined in [IETF RFC 5737]:\n+    ///\n+    /// - `192.0.2.0/24` (TEST-NET-1)\n+    /// - `198.51.100.0/24` (TEST-NET-2)\n+    /// - `203.0.113.0/24` (TEST-NET-3)\n+    ///\n+    /// [IETF RFC 5737]: https://tools.ietf.org/html/rfc5737\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_documentation(&self) -> bool {\n+        matches!(self.octets(), [192, 0, 2, _] | [198, 51, 100, _] | [203, 0, 113, _])\n+    }\n+\n+    /// Converts this address to an [IPv4-compatible] [`IPv6` address].\n+    ///\n+    /// `a.b.c.d` becomes `::a.b.c.d`\n+    ///\n+    /// Note that IPv4-compatible addresses have been officially deprecated.\n+    /// If you don't explicitly need an IPv4-compatible address for legacy reasons, consider using `to_ipv6_mapped` instead.\n+    ///\n+    /// [IPv4-compatible]: Ipv6Addr#ipv4-compatible-ipv6-addresses\n+    /// [`IPv6` address]: Ipv6Addr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(\n+    ///     Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n+    ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x2ff)\n+    /// );\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[inline]\n+    pub const fn to_ipv6_compatible(&self) -> Ipv6Addr {\n+        let [a, b, c, d] = self.octets();\n+        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d] }\n+    }\n+\n+    /// Converts this address to an [IPv4-mapped] [`IPv6` address].\n+    ///\n+    /// `a.b.c.d` becomes `::ffff:a.b.c.d`\n+    ///\n+    /// [IPv4-mapped]: Ipv6Addr#ipv4-mapped-ipv6-addresses\n+    /// [`IPv6` address]: Ipv6Addr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n+    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x2ff));\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[inline]\n+    pub const fn to_ipv6_mapped(&self) -> Ipv6Addr {\n+        let [a, b, c, d] = self.octets();\n+        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d] }\n+    }\n+}\n+\n+#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+impl fmt::Display for IpAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            IpAddr::V4(ip) => ip.fmt(fmt),\n+            IpAddr::V6(ip) => ip.fmt(fmt),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+impl fmt::Debug for IpAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<Ipv4Addr> for IpAddr {\n+    /// Copies this address to a new `IpAddr::V4`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr};\n+    ///\n+    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n+    ///\n+    /// assert_eq!(\n+    ///     IpAddr::V4(addr),\n+    ///     IpAddr::from(addr)\n+    /// )\n+    /// ```\n+    #[inline]\n+    fn from(ipv4: Ipv4Addr) -> IpAddr {\n+        IpAddr::V4(ipv4)\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<Ipv6Addr> for IpAddr {\n+    /// Copies this address to a new `IpAddr::V6`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv6Addr};\n+    ///\n+    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n+    ///\n+    /// assert_eq!(\n+    ///     IpAddr::V6(addr),\n+    ///     IpAddr::from(addr)\n+    /// );\n+    /// ```\n+    #[inline]\n+    fn from(ipv6: Ipv6Addr) -> IpAddr {\n+        IpAddr::V6(ipv6)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for Ipv4Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let octets = self.octets();\n+\n+        // If there are no alignment requirements, write the IP address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n+        if fmt.precision().is_none() && fmt.width().is_none() {\n+            write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n+        } else {\n+            const LONGEST_IPV4_ADDR: &str = \"255.255.255.255\";\n+\n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV4_ADDR.len() }>::new();\n+            // Buffer is long enough for the longest possible IPv4 address, so this should never fail.\n+            write!(buf, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n+\n+            fmt.pad(buf.as_str())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Ipv4Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialEq<Ipv4Addr> for IpAddr {\n+    #[inline]\n+    fn eq(&self, other: &Ipv4Addr) -> bool {\n+        match self {\n+            IpAddr::V4(v4) => v4 == other,\n+            IpAddr::V6(_) => false,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialEq<IpAddr> for Ipv4Addr {\n+    #[inline]\n+    fn eq(&self, other: &IpAddr) -> bool {\n+        match other {\n+            IpAddr::V4(v4) => self == v4,\n+            IpAddr::V6(_) => false,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialOrd for Ipv4Addr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialOrd<Ipv4Addr> for IpAddr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n+        match self {\n+            IpAddr::V4(v4) => v4.partial_cmp(other),\n+            IpAddr::V6(_) => Some(Ordering::Greater),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialOrd<IpAddr> for Ipv4Addr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n+        match other {\n+            IpAddr::V4(v4) => self.partial_cmp(v4),\n+            IpAddr::V6(_) => Some(Ordering::Less),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Ord for Ipv4Addr {\n+    #[inline]\n+    fn cmp(&self, other: &Ipv4Addr) -> Ordering {\n+        self.octets.cmp(&other.octets)\n+    }\n+}\n+\n+#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n+impl From<Ipv4Addr> for u32 {\n+    /// Converts an `Ipv4Addr` into a host byte order `u32`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::new(0x12, 0x34, 0x56, 0x78);\n+    /// assert_eq!(0x12345678, u32::from(addr));\n+    /// ```\n+    #[inline]\n+    fn from(ip: Ipv4Addr) -> u32 {\n+        u32::from_be_bytes(ip.octets)\n+    }\n+}\n+\n+#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n+impl From<u32> for Ipv4Addr {\n+    /// Converts a host byte order `u32` into an `Ipv4Addr`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::from(0x12345678);\n+    /// assert_eq!(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78), addr);\n+    /// ```\n+    #[inline]\n+    fn from(ip: u32) -> Ipv4Addr {\n+        Ipv4Addr { octets: ip.to_be_bytes() }\n+    }\n+}\n+\n+#[stable(feature = \"from_slice_v4\", since = \"1.9.0\")]\n+impl From<[u8; 4]> for Ipv4Addr {\n+    /// Creates an `Ipv4Addr` from a four element byte array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::from([13u8, 12u8, 11u8, 10u8]);\n+    /// assert_eq!(Ipv4Addr::new(13, 12, 11, 10), addr);\n+    /// ```\n+    #[inline]\n+    fn from(octets: [u8; 4]) -> Ipv4Addr {\n+        Ipv4Addr { octets }\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n+impl From<[u8; 4]> for IpAddr {\n+    /// Creates an `IpAddr::V4` from a four element byte array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr};\n+    ///\n+    /// let addr = IpAddr::from([13u8, 12u8, 11u8, 10u8]);\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(13, 12, 11, 10)), addr);\n+    /// ```\n+    #[inline]\n+    fn from(octets: [u8; 4]) -> IpAddr {\n+        IpAddr::V4(Ipv4Addr::from(octets))\n+    }\n+}\n+\n+impl Ipv6Addr {\n+    /// Creates a new IPv6 address from eight 16-bit segments.\n+    ///\n+    /// The result will represent the IP address `a:b:c:d:e:f:g:h`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {\n+        let addr16 = [\n+            a.to_be(),\n+            b.to_be(),\n+            c.to_be(),\n+            d.to_be(),\n+            e.to_be(),\n+            f.to_be(),\n+            g.to_be(),\n+            h.to_be(),\n+        ];\n+        Ipv6Addr {\n+            // All elements in `addr16` are big endian.\n+            // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n+            octets: unsafe { transmute::<_, [u8; 16]>(addr16) },\n+        }\n+    }\n+\n+    /// An IPv6 address representing localhost: `::1`.\n+    ///\n+    /// This corresponds to constant `IN6ADDR_LOOPBACK_INIT` or `in6addr_loopback` in other\n+    /// languages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::LOCALHOST;\n+    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+    /// ```\n+    #[doc(alias = \"IN6ADDR_LOOPBACK_INIT\")]\n+    #[doc(alias = \"in6addr_loopback\")]\n+    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n+    pub const LOCALHOST: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n+\n+    /// An IPv6 address representing the unspecified address: `::`\n+    ///\n+    /// This corresponds to constant `IN6ADDR_ANY_INIT` or `in6addr_any` in other languages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::UNSPECIFIED;\n+    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n+    /// ```\n+    #[doc(alias = \"IN6ADDR_ANY_INIT\")]\n+    #[doc(alias = \"in6addr_any\")]\n+    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n+    pub const UNSPECIFIED: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0);\n+\n+    /// Returns the eight 16-bit segments that make up this address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n+    ///            [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn segments(&self) -> [u16; 8] {\n+        // All elements in `self.octets` must be big endian.\n+        // SAFETY: `[u8; 16]` is always safe to transmute to `[u16; 8]`.\n+        let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.octets) };\n+        // We want native endian u16\n+        [\n+            u16::from_be(a),\n+            u16::from_be(b),\n+            u16::from_be(c),\n+            u16::from_be(d),\n+            u16::from_be(e),\n+            u16::from_be(f),\n+            u16::from_be(g),\n+            u16::from_be(h),\n+        ]\n+    }\n+\n+    /// Returns [`true`] for the special 'unspecified' address (`::`).\n+    ///\n+    /// This property is defined in [IETF RFC 4291].\n+    ///\n+    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unspecified(&self) -> bool {\n+        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::UNSPECIFIED.octets())\n+    }\n+\n+    /// Returns [`true`] if this is the [loopback address] (`::1`),\n+    /// as defined in [IETF RFC 4291 section 2.5.3].\n+    ///\n+    /// Contrary to IPv4, in IPv6 there is only one loopback address.\n+    ///\n+    /// [loopback address]: Ipv6Addr::LOCALHOST\n+    /// [IETF RFC 4291 section 2.5.3]: https://tools.ietf.org/html/rfc4291#section-2.5.3\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_loopback(&self) -> bool {\n+        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::LOCALHOST.octets())\n+    }\n+\n+    /// Returns [`true`] if the address appears to be globally reachable\n+    /// as specified by the [IANA IPv6 Special-Purpose Address Registry].\n+    /// Whether or not an address is practically reachable will depend on your network configuration.\n+    ///\n+    /// Most IPv6 addresses are globally reachable;\n+    /// unless they are specifically defined as *not* globally reachable.\n+    ///\n+    /// Non-exhaustive list of notable addresses that are not globally reachable:\n+    /// - The [unspecified address] ([`is_unspecified`](Ipv6Addr::is_unspecified))\n+    /// - The [loopback address] ([`is_loopback`](Ipv6Addr::is_loopback))\n+    /// - IPv4-mapped addresses\n+    /// - Addresses reserved for benchmarking\n+    /// - Addresses reserved for documentation ([`is_documentation`](Ipv6Addr::is_documentation))\n+    /// - Unique local addresses ([`is_unique_local`](Ipv6Addr::is_unique_local))\n+    /// - Unicast addresses with link-local scope ([`is_unicast_link_local`](Ipv6Addr::is_unicast_link_local))\n+    ///\n+    /// For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv6 Special-Purpose Address Registry].\n+    ///\n+    /// Note that an address having global scope is not the same as being globally reachable,\n+    /// and there is no direct relation between the two concepts: There exist addresses with global scope\n+    /// that are not globally reachable (for example unique local addresses),\n+    /// and addresses that are globally reachable without having global scope\n+    /// (multicast addresses with non-global scope).\n+    ///\n+    /// [IANA IPv6 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml\n+    /// [unspecified address]: Ipv6Addr::UNSPECIFIED\n+    /// [loopback address]: Ipv6Addr::LOCALHOST\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// // Most IPv6 addresses are globally reachable:\n+    /// assert_eq!(Ipv6Addr::new(0x26, 0, 0x1c9, 0, 0, 0xafc8, 0x10, 0x1).is_global(), true);\n+    ///\n+    /// // However some addresses have been assigned a special meaning\n+    /// // that makes them not globally reachable. Some examples are:\n+    ///\n+    /// // The unspecified address (`::`)\n+    /// assert_eq!(Ipv6Addr::UNSPECIFIED.is_global(), false);\n+    ///\n+    /// // The loopback address (`::1`)\n+    /// assert_eq!(Ipv6Addr::LOCALHOST.is_global(), false);\n+    ///\n+    /// // IPv4-mapped addresses (`::ffff:0:0/96`)\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), false);\n+    ///\n+    /// // Addresses reserved for benchmarking (`2001:2::/48`)\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 2, 0, 0, 0, 0, 0, 1,).is_global(), false);\n+    ///\n+    /// // Addresses reserved for documentation (`2001:db8::/32`)\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1).is_global(), false);\n+    ///\n+    /// // Unique local addresses (`fc00::/7`)\n+    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n+    ///\n+    /// // Unicast addresses with link-local scope (`fe80::/10`)\n+    /// assert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n+    ///\n+    /// // For a complete overview see the IANA IPv6 Special-Purpose Address Registry.\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_global(&self) -> bool {\n+        !(self.is_unspecified()\n+            || self.is_loopback()\n+            // IPv4-mapped Address (`::ffff:0:0/96`)\n+            || matches!(self.segments(), [0, 0, 0, 0, 0, 0xffff, _, _])\n+            // IPv4-IPv6 Translat. (`64:ff9b:1::/48`)\n+            || matches!(self.segments(), [0x64, 0xff9b, 1, _, _, _, _, _])\n+            // Discard-Only Address Block (`100::/64`)\n+            || matches!(self.segments(), [0x100, 0, 0, 0, _, _, _, _])\n+            // IETF Protocol Assignments (`2001::/23`)\n+            || (matches!(self.segments(), [0x2001, b, _, _, _, _, _, _] if b < 0x200)\n+                && !(\n+                    // Port Control Protocol Anycast (`2001:1::1`)\n+                    u128::from_be_bytes(self.octets()) == 0x2001_0001_0000_0000_0000_0000_0000_0001\n+                    // Traversal Using Relays around NAT Anycast (`2001:1::2`)\n+                    || u128::from_be_bytes(self.octets()) == 0x2001_0001_0000_0000_0000_0000_0000_0002\n+                    // AMT (`2001:3::/32`)\n+                    || matches!(self.segments(), [0x2001, 3, _, _, _, _, _, _])\n+                    // AS112-v6 (`2001:4:112::/48`)\n+                    || matches!(self.segments(), [0x2001, 4, 0x112, _, _, _, _, _])\n+                    // ORCHIDv2 (`2001:20::/28`)\n+                    || matches!(self.segments(), [0x2001, b, _, _, _, _, _, _] if b >= 0x20 && b <= 0x2F)\n+                ))\n+            || self.is_documentation()\n+            || self.is_unique_local()\n+            || self.is_unicast_link_local())\n+    }\n+\n+    /// Returns [`true`] if this is a unique local address (`fc00::/7`).\n+    ///\n+    /// This property is defined in [IETF RFC 4193].\n+    ///\n+    /// [IETF RFC 4193]: https://tools.ietf.org/html/rfc4193\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(), false);\n+    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unique_local(&self) -> bool {\n+        (self.segments()[0] & 0xfe00) == 0xfc00\n+    }\n+\n+    /// Returns [`true`] if this is a unicast address, as defined by [IETF RFC 4291].\n+    /// Any address that is not a [multicast address] (`ff00::/8`) is unicast.\n+    ///\n+    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [multicast address]: Ipv6Addr::is_multicast\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// // The unspecified and loopback addresses are unicast.\n+    /// assert_eq!(Ipv6Addr::UNSPECIFIED.is_unicast(), true);\n+    /// assert_eq!(Ipv6Addr::LOCALHOST.is_unicast(), true);\n+    ///\n+    /// // Any address that is not a multicast address (`ff00::/8`) is unicast.\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast(), true);\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_unicast(), false);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unicast(&self) -> bool {\n+        !self.is_multicast()\n+    }\n+\n+    /// Returns `true` if the address is a unicast address with link-local scope,\n+    /// as defined in [RFC 4291].\n+    ///\n+    /// A unicast address has link-local scope if it has the prefix `fe80::/10`, as per [RFC 4291 section 2.4].\n+    /// Note that this encompasses more addresses than those defined in [RFC 4291 section 2.5.6],\n+    /// which describes \"Link-Local IPv6 Unicast Addresses\" as having the following stricter format:\n+    ///\n+    /// ```text\n+    /// | 10 bits  |         54 bits         |          64 bits           |\n+    /// +----------+-------------------------+----------------------------+\n+    /// |1111111010|           0             |       interface ID         |\n+    /// +----------+-------------------------+----------------------------+\n+    /// ```\n+    /// So while currently the only addresses with link-local scope an application will encounter are all in `fe80::/64`,\n+    /// this might change in the future with the publication of new standards. More addresses in `fe80::/10` could be allocated,\n+    /// and those addresses will have link-local scope.\n+    ///\n+    /// Also note that while [RFC 4291 section 2.5.3] mentions about the [loopback address] (`::1`) that \"it is treated as having Link-Local scope\",\n+    /// this does not mean that the loopback address actually has link-local scope and this method will return `false` on it.\n+    ///\n+    /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [RFC 4291 section 2.4]: https://tools.ietf.org/html/rfc4291#section-2.4\n+    /// [RFC 4291 section 2.5.3]: https://tools.ietf.org/html/rfc4291#section-2.5.3\n+    /// [RFC 4291 section 2.5.6]: https://tools.ietf.org/html/rfc4291#section-2.5.6\n+    /// [loopback address]: Ipv6Addr::LOCALHOST\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// // The loopback address (`::1`) does not actually have link-local scope.\n+    /// assert_eq!(Ipv6Addr::LOCALHOST.is_unicast_link_local(), false);\n+    ///\n+    /// // Only addresses in `fe80::/10` have link-local scope.\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), false);\n+    /// assert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n+    ///\n+    /// // Addresses outside the stricter `fe80::/64` also have link-local scope.\n+    /// assert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0).is_unicast_link_local(), true);\n+    /// assert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unicast_link_local(&self) -> bool {\n+        (self.segments()[0] & 0xffc0) == 0xfe80\n+    }\n+\n+    /// Returns [`true`] if this is an address reserved for documentation\n+    /// (`2001:db8::/32`).\n+    ///\n+    /// This property is defined in [IETF RFC 3849].\n+    ///\n+    /// [IETF RFC 3849]: https://tools.ietf.org/html/rfc3849\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(), false);\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_documentation(&self) -> bool {\n+        (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n+    }\n+\n+    /// Returns [`true`] if this is an address reserved for benchmarking (`2001:2::/48`).\n+    ///\n+    /// This property is defined in [IETF RFC 5180], where it is mistakenly specified as covering the range `2001:0200::/48`.\n+    /// This is corrected in [IETF RFC Errata 1752] to `2001:0002::/48`.\n+    ///\n+    /// [IETF RFC 5180]: https://tools.ietf.org/html/rfc5180\n+    /// [IETF RFC Errata 1752]: https://www.rfc-editor.org/errata_search.php?eid=1752\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc613, 0x0).is_benchmarking(), false);\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0x2, 0, 0, 0, 0, 0, 0).is_benchmarking(), true);\n+    /// ```\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_benchmarking(&self) -> bool {\n+        (self.segments()[0] == 0x2001) && (self.segments()[1] == 0x2) && (self.segments()[2] == 0)\n+    }\n+\n+    /// Returns [`true`] if the address is a globally routable unicast address.\n+    ///\n+    /// The following return false:\n+    ///\n+    /// - the loopback address\n+    /// - the link-local addresses\n+    /// - unique local addresses\n+    /// - the unspecified address\n+    /// - the address range reserved for documentation\n+    ///\n+    /// This method returns [`true`] for site-local addresses as per [RFC 4291 section 2.5.7]\n+    ///\n+    /// ```no_rust\n+    /// The special behavior of [the site-local unicast] prefix defined in [RFC3513] must no longer\n+    /// be supported in new implementations (i.e., new implementations must treat this prefix as\n+    /// Global Unicast).\n+    /// ```\n+    ///\n+    /// [RFC 4291 section 2.5.7]: https://tools.ietf.org/html/rfc4291#section-2.5.7\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unicast_global(&self) -> bool {\n+        self.is_unicast()\n+            && !self.is_loopback()\n+            && !self.is_unicast_link_local()\n+            && !self.is_unique_local()\n+            && !self.is_unspecified()\n+            && !self.is_documentation()\n+            && !self.is_benchmarking()\n+    }\n+\n+    /// Returns the address's multicast scope if the address is multicast.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{Ipv6Addr, Ipv6MulticastScope};\n+    ///\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n+    ///     Some(Ipv6MulticastScope::Global)\n+    /// );\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n+        if self.is_multicast() {\n+            match self.segments()[0] & 0x000f {\n+                1 => Some(Ipv6MulticastScope::InterfaceLocal),\n+                2 => Some(Ipv6MulticastScope::LinkLocal),\n+                3 => Some(Ipv6MulticastScope::RealmLocal),\n+                4 => Some(Ipv6MulticastScope::AdminLocal),\n+                5 => Some(Ipv6MulticastScope::SiteLocal),\n+                8 => Some(Ipv6MulticastScope::OrganizationLocal),\n+                14 => Some(Ipv6MulticastScope::Global),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns [`true`] if this is a multicast address (`ff00::/8`).\n+    ///\n+    /// This property is defined by [IETF RFC 4291].\n+    ///\n+    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_multicast(&self) -> bool {\n+        (self.segments()[0] & 0xff00) == 0xff00\n+    }\n+\n+    /// Converts this address to an [`IPv4` address] if it's an [IPv4-mapped] address,\n+    /// as defined in [IETF RFC 4291 section 2.5.5.2], otherwise returns [`None`].\n+    ///\n+    /// `::ffff:a.b.c.d` becomes `a.b.c.d`.\n+    /// All addresses *not* starting with `::ffff` will return `None`.\n+    ///\n+    /// [`IPv4` address]: Ipv4Addr\n+    /// [IPv4-mapped]: Ipv6Addr\n+    /// [IETF RFC 4291 section 2.5.5.2]: https://tools.ietf.org/html/rfc4291#section-2.5.5.2\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4_mapped(), None);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4_mapped(),\n+    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4_mapped(), None);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[stable(feature = \"ipv6_to_ipv4_mapped\", since = \"1.63.0\")]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[inline]\n+    pub const fn to_ipv4_mapped(&self) -> Option<Ipv4Addr> {\n+        match self.octets() {\n+            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, a, b, c, d] => {\n+                Some(Ipv4Addr::new(a, b, c, d))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// Converts this address to an [`IPv4` address] if it is either\n+    /// an [IPv4-compatible] address as defined in [IETF RFC 4291 section 2.5.5.1],\n+    /// or an [IPv4-mapped] address as defined in [IETF RFC 4291 section 2.5.5.2],\n+    /// otherwise returns [`None`].\n+    ///\n+    /// Note that this will return an [`IPv4` address] for the IPv6 loopback address `::1`. Use\n+    /// [`Ipv6Addr::to_ipv4_mapped`] to avoid this.\n+    ///\n+    /// `::a.b.c.d` and `::ffff:a.b.c.d` become `a.b.c.d`. `::1` becomes `0.0.0.1`.\n+    /// All addresses *not* starting with either all zeroes or `::ffff` will return `None`.\n+    ///\n+    /// [`IPv4` address]: Ipv4Addr\n+    /// [IPv4-compatible]: Ipv6Addr#ipv4-compatible-ipv6-addresses\n+    /// [IPv4-mapped]: Ipv6Addr#ipv4-mapped-ipv6-addresses\n+    /// [IETF RFC 4291 section 2.5.5.1]: https://tools.ietf.org/html/rfc4291#section-2.5.5.1\n+    /// [IETF RFC 4291 section 2.5.5.2]: https://tools.ietf.org/html/rfc4291#section-2.5.5.2\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4(), None);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4(),\n+    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n+    ///            Some(Ipv4Addr::new(0, 0, 0, 1)));\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[inline]\n+    pub const fn to_ipv4(&self) -> Option<Ipv4Addr> {\n+        if let [0, 0, 0, 0, 0, 0 | 0xffff, ab, cd] = self.segments() {\n+            let [a, b] = ab.to_be_bytes();\n+            let [c, d] = cd.to_be_bytes();\n+            Some(Ipv4Addr::new(a, b, c, d))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped addresses, otherwise it\n+    /// returns self wrapped in an `IpAddr::V6`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1).is_loopback(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1).to_canonical().is_loopback(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[inline]\n+    pub const fn to_canonical(&self) -> IpAddr {\n+        if let Some(mapped) = self.to_ipv4_mapped() {\n+            return IpAddr::V4(mapped);\n+        }\n+        IpAddr::V6(*self)\n+    }\n+\n+    /// Returns the sixteen eight-bit integers the IPv6 address consists of.\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).octets(),\n+    ///            [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n+    #[stable(feature = \"ipv6_to_octets\", since = \"1.12.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn octets(&self) -> [u8; 16] {\n+        self.octets\n+    }\n+}\n+\n+/// Write an Ipv6Addr, conforming to the canonical style described by\n+/// [RFC 5952](https://tools.ietf.org/html/rfc5952).\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for Ipv6Addr {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // If there are no alignment requirements, write the IP address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n+        if f.precision().is_none() && f.width().is_none() {\n+            let segments = self.segments();\n+\n+            // Special case for :: and ::1; otherwise they get written with the\n+            // IPv4 formatter\n+            if self.is_unspecified() {\n+                f.write_str(\"::\")\n+            } else if self.is_loopback() {\n+                f.write_str(\"::1\")\n+            } else if let Some(ipv4) = self.to_ipv4() {\n+                match segments[5] {\n+                    // IPv4 Compatible address\n+                    0 => write!(f, \"::{}\", ipv4),\n+                    // IPv4 Mapped address\n+                    0xffff => write!(f, \"::ffff:{}\", ipv4),\n+                    _ => unreachable!(),\n+                }\n+            } else {\n+                #[derive(Copy, Clone, Default)]\n+                struct Span {\n+                    start: usize,\n+                    len: usize,\n+                }\n+\n+                // Find the inner 0 span\n+                let zeroes = {\n+                    let mut longest = Span::default();\n+                    let mut current = Span::default();\n+\n+                    for (i, &segment) in segments.iter().enumerate() {\n+                        if segment == 0 {\n+                            if current.len == 0 {\n+                                current.start = i;\n+                            }\n+\n+                            current.len += 1;\n+\n+                            if current.len > longest.len {\n+                                longest = current;\n+                            }\n+                        } else {\n+                            current = Span::default();\n+                        }\n+                    }\n+\n+                    longest\n+                };\n+\n+                /// Write a colon-separated part of the address\n+                #[inline]\n+                fn fmt_subslice(f: &mut fmt::Formatter<'_>, chunk: &[u16]) -> fmt::Result {\n+                    if let Some((first, tail)) = chunk.split_first() {\n+                        write!(f, \"{:x}\", first)?;\n+                        for segment in tail {\n+                            f.write_char(':')?;\n+                            write!(f, \"{:x}\", segment)?;\n+                        }\n+                    }\n+                    Ok(())\n+                }\n+\n+                if zeroes.len > 1 {\n+                    fmt_subslice(f, &segments[..zeroes.start])?;\n+                    f.write_str(\"::\")?;\n+                    fmt_subslice(f, &segments[zeroes.start + zeroes.len..])\n+                } else {\n+                    fmt_subslice(f, &segments)\n+                }\n+            }\n+        } else {\n+            const LONGEST_IPV6_ADDR: &str = \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\";\n+\n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_ADDR.len() }>::new();\n+            // Buffer is long enough for the longest possible IPv6 address, so this should never fail.\n+            write!(buf, \"{}\", self).unwrap();\n+\n+            f.pad(buf.as_str())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Ipv6Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialEq<IpAddr> for Ipv6Addr {\n+    #[inline]\n+    fn eq(&self, other: &IpAddr) -> bool {\n+        match other {\n+            IpAddr::V4(_) => false,\n+            IpAddr::V6(v6) => self == v6,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialEq<Ipv6Addr> for IpAddr {\n+    #[inline]\n+    fn eq(&self, other: &Ipv6Addr) -> bool {\n+        match self {\n+            IpAddr::V4(_) => false,\n+            IpAddr::V6(v6) => v6 == other,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialOrd for Ipv6Addr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialOrd<Ipv6Addr> for IpAddr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n+        match self {\n+            IpAddr::V4(_) => Some(Ordering::Less),\n+            IpAddr::V6(v6) => v6.partial_cmp(other),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialOrd<IpAddr> for Ipv6Addr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n+        match other {\n+            IpAddr::V4(_) => Some(Ordering::Greater),\n+            IpAddr::V6(v6) => self.partial_cmp(v6),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Ord for Ipv6Addr {\n+    #[inline]\n+    fn cmp(&self, other: &Ipv6Addr) -> Ordering {\n+        self.segments().cmp(&other.segments())\n+    }\n+}\n+\n+#[stable(feature = \"i128\", since = \"1.26.0\")]\n+impl From<Ipv6Addr> for u128 {\n+    /// Convert an `Ipv6Addr` into a host byte order `u128`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::new(\n+    ///     0x1020, 0x3040, 0x5060, 0x7080,\n+    ///     0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n+    /// );\n+    /// assert_eq!(0x102030405060708090A0B0C0D0E0F00D_u128, u128::from(addr));\n+    /// ```\n+    #[inline]\n+    fn from(ip: Ipv6Addr) -> u128 {\n+        u128::from_be_bytes(ip.octets)\n+    }\n+}\n+#[stable(feature = \"i128\", since = \"1.26.0\")]\n+impl From<u128> for Ipv6Addr {\n+    /// Convert a host byte order `u128` into an `Ipv6Addr`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::from(0x102030405060708090A0B0C0D0E0F00D_u128);\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(\n+    ///         0x1020, 0x3040, 0x5060, 0x7080,\n+    ///         0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n+    ///     ),\n+    ///     addr);\n+    /// ```\n+    #[inline]\n+    fn from(ip: u128) -> Ipv6Addr {\n+        Ipv6Addr::from(ip.to_be_bytes())\n+    }\n+}\n+\n+#[stable(feature = \"ipv6_from_octets\", since = \"1.9.0\")]\n+impl From<[u8; 16]> for Ipv6Addr {\n+    /// Creates an `Ipv6Addr` from a sixteen element byte array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::from([\n+    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n+    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n+    /// ]);\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(\n+    ///         0x1918, 0x1716,\n+    ///         0x1514, 0x1312,\n+    ///         0x1110, 0x0f0e,\n+    ///         0x0d0c, 0x0b0a\n+    ///     ),\n+    ///     addr\n+    /// );\n+    /// ```\n+    #[inline]\n+    fn from(octets: [u8; 16]) -> Ipv6Addr {\n+        Ipv6Addr { octets }\n+    }\n+}\n+\n+#[stable(feature = \"ipv6_from_segments\", since = \"1.16.0\")]\n+impl From<[u16; 8]> for Ipv6Addr {\n+    /// Creates an `Ipv6Addr` from an eight element 16-bit array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::from([\n+    ///     525u16, 524u16, 523u16, 522u16,\n+    ///     521u16, 520u16, 519u16, 518u16,\n+    /// ]);\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(\n+    ///         0x20d, 0x20c,\n+    ///         0x20b, 0x20a,\n+    ///         0x209, 0x208,\n+    ///         0x207, 0x206\n+    ///     ),\n+    ///     addr\n+    /// );\n+    /// ```\n+    #[inline]\n+    fn from(segments: [u16; 8]) -> Ipv6Addr {\n+        let [a, b, c, d, e, f, g, h] = segments;\n+        Ipv6Addr::new(a, b, c, d, e, f, g, h)\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n+impl From<[u8; 16]> for IpAddr {\n+    /// Creates an `IpAddr::V6` from a sixteen element byte array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv6Addr};\n+    ///\n+    /// let addr = IpAddr::from([\n+    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n+    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n+    /// ]);\n+    /// assert_eq!(\n+    ///     IpAddr::V6(Ipv6Addr::new(\n+    ///         0x1918, 0x1716,\n+    ///         0x1514, 0x1312,\n+    ///         0x1110, 0x0f0e,\n+    ///         0x0d0c, 0x0b0a\n+    ///     )),\n+    ///     addr\n+    /// );\n+    /// ```\n+    #[inline]\n+    fn from(octets: [u8; 16]) -> IpAddr {\n+        IpAddr::V6(Ipv6Addr::from(octets))\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n+impl From<[u16; 8]> for IpAddr {\n+    /// Creates an `IpAddr::V6` from an eight element 16-bit array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv6Addr};\n+    ///\n+    /// let addr = IpAddr::from([\n+    ///     525u16, 524u16, 523u16, 522u16,\n+    ///     521u16, 520u16, 519u16, 518u16,\n+    /// ]);\n+    /// assert_eq!(\n+    ///     IpAddr::V6(Ipv6Addr::new(\n+    ///         0x20d, 0x20c,\n+    ///         0x20b, 0x20a,\n+    ///         0x209, 0x208,\n+    ///         0x207, 0x206\n+    ///     )),\n+    ///     addr\n+    /// );\n+    /// ```\n+    #[inline]\n+    fn from(segments: [u16; 8]) -> IpAddr {\n+        IpAddr::V6(Ipv6Addr::from(segments))\n+    }\n+}"}, {"sha": "31f5f5d3c223b14b04705b954048e97a6608b818", "filename": "library/core/src/net/mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fmod.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -0,0 +1,24 @@\n+//! Networking primitives for IP communication.\n+//!\n+//! This module provides types for IP and socket addresses.\n+//!\n+//! # Organization\n+//!\n+//! * [`IpAddr`] represents IP addresses of either IPv4 or IPv6; [`Ipv4Addr`] and\n+//!   [`Ipv6Addr`] are respectively IPv4 and IPv6 addresses\n+//! * [`SocketAddr`] represents socket addresses of either IPv4 or IPv6; [`SocketAddrV4`]\n+//!   and [`SocketAddrV6`] are respectively IPv4 and IPv6 socket addresses\n+\n+#![unstable(feature = \"ip_in_core\", issue = \"108443\")]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::ip_addr::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::parser::AddrParseError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::socket_addr::{SocketAddr, SocketAddrV4, SocketAddrV6};\n+\n+mod display_buffer;\n+mod ip_addr;\n+mod parser;\n+mod socket_addr;"}, {"sha": "a08d2792d0456ed6a2dcd8dddf6cddbf46ea9a19", "filename": "library/core/src/net/parser.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fparser.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -3,9 +3,7 @@\n //! This module is \"publicly exported\" through the `FromStr` implementations\n //! below.\n \n-#[cfg(test)]\n-mod tests;\n-\n+use crate::convert::TryInto;\n use crate::error::Error;\n use crate::fmt;\n use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};", "previous_filename": "library/std/src/net/parser.rs"}, {"sha": "0d25ab1d5e1a4f34325665ce16765c7207d21716", "filename": "library/core/src/net/socket_addr.rs", "status": "added", "additions": 664, "deletions": 0, "changes": 664, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Fnet%2Fsocket_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Fsrc%2Fnet%2Fsocket_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fsocket_addr.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -0,0 +1,664 @@\n+use crate::cmp::Ordering;\n+use crate::fmt::{self, Write};\n+use crate::hash;\n+use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+\n+use super::display_buffer::DisplayBuffer;\n+\n+/// An internet socket address, either IPv4 or IPv6.\n+///\n+/// Internet socket addresses consist of an [IP address], a 16-bit port number, as well\n+/// as possibly some version-dependent additional information. See [`SocketAddrV4`]'s and\n+/// [`SocketAddrV6`]'s respective documentation for more details.\n+///\n+/// The size of a `SocketAddr` instance may vary depending on the target operating\n+/// system.\n+///\n+/// [IP address]: IpAddr\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+///\n+/// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+///\n+/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n+/// assert_eq!(socket.port(), 8080);\n+/// assert_eq!(socket.is_ipv4(), true);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum SocketAddr {\n+    /// An IPv4 socket address.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    V4(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV4),\n+    /// An IPv6 socket address.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    V6(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV6),\n+}\n+\n+/// An IPv4 socket address.\n+///\n+/// IPv4 socket addresses consist of an [`IPv4` address] and a 16-bit port number, as\n+/// stated in [IETF RFC 793].\n+///\n+/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n+///\n+/// The size of a `SocketAddrV4` struct may vary depending on the target operating\n+/// system. Do not assume that this type has the same memory layout as the underlying\n+/// system representation.\n+///\n+/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n+/// [`IPv4` address]: Ipv4Addr\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::{Ipv4Addr, SocketAddrV4};\n+///\n+/// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+///\n+/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n+/// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n+/// assert_eq!(socket.port(), 8080);\n+/// ```\n+#[derive(Copy, Clone, Eq, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SocketAddrV4 {\n+    ip: Ipv4Addr,\n+    port: u16,\n+}\n+\n+/// An IPv6 socket address.\n+///\n+/// IPv6 socket addresses consist of an [`IPv6` address], a 16-bit port number, as well\n+/// as fields containing the traffic class, the flow label, and a scope identifier\n+/// (see [IETF RFC 2553, Section 3.3] for more details).\n+///\n+/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n+///\n+/// The size of a `SocketAddrV6` struct may vary depending on the target operating\n+/// system. Do not assume that this type has the same memory layout as the underlying\n+/// system representation.\n+///\n+/// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n+/// [`IPv6` address]: Ipv6Addr\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::{Ipv6Addr, SocketAddrV6};\n+///\n+/// let socket = SocketAddrV6::new(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+///\n+/// assert_eq!(\"[2001:db8::1]:8080\".parse(), Ok(socket));\n+/// assert_eq!(socket.ip(), &Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1));\n+/// assert_eq!(socket.port(), 8080);\n+/// ```\n+#[derive(Copy, Clone, Eq, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SocketAddrV6 {\n+    ip: Ipv6Addr,\n+    port: u16,\n+    flowinfo: u32,\n+    scope_id: u32,\n+}\n+\n+impl SocketAddr {\n+    /// Creates a new socket address from an [IP address] and a port number.\n+    ///\n+    /// [IP address]: IpAddr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n+    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+    #[must_use]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn new(ip: IpAddr, port: u16) -> SocketAddr {\n+        match ip {\n+            IpAddr::V4(a) => SocketAddr::V4(SocketAddrV4::new(a, port)),\n+            IpAddr::V6(a) => SocketAddr::V6(SocketAddrV6::new(a, port, 0, 0)),\n+        }\n+    }\n+\n+    /// Returns the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn ip(&self) -> IpAddr {\n+        match *self {\n+            SocketAddr::V4(ref a) => IpAddr::V4(*a.ip()),\n+            SocketAddr::V6(ref a) => IpAddr::V6(*a.ip()),\n+        }\n+    }\n+\n+    /// Changes the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// socket.set_ip(IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_ip(&mut self, new_ip: IpAddr) {\n+        // `match (*self, new_ip)` would have us mutate a copy of self only to throw it away.\n+        match (self, new_ip) {\n+            (&mut SocketAddr::V4(ref mut a), IpAddr::V4(new_ip)) => a.set_ip(new_ip),\n+            (&mut SocketAddr::V6(ref mut a), IpAddr::V6(new_ip)) => a.set_ip(new_ip),\n+            (self_, new_ip) => *self_ = Self::new(new_ip, self_.port()),\n+        }\n+    }\n+\n+    /// Returns the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn port(&self) -> u16 {\n+        match *self {\n+            SocketAddr::V4(ref a) => a.port(),\n+            SocketAddr::V6(ref a) => a.port(),\n+        }\n+    }\n+\n+    /// Changes the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// socket.set_port(1025);\n+    /// assert_eq!(socket.port(), 1025);\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_port(&mut self, new_port: u16) {\n+        match *self {\n+            SocketAddr::V4(ref mut a) => a.set_port(new_port),\n+            SocketAddr::V6(ref mut a) => a.set_port(new_port),\n+        }\n+    }\n+\n+    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n+    /// [`IPv4` address], and [`false`] otherwise.\n+    ///\n+    /// [IP address]: IpAddr\n+    /// [`IPv4` address]: IpAddr::V4\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.is_ipv4(), true);\n+    /// assert_eq!(socket.is_ipv6(), false);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn is_ipv4(&self) -> bool {\n+        matches!(*self, SocketAddr::V4(_))\n+    }\n+\n+    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n+    /// [`IPv6` address], and [`false`] otherwise.\n+    ///\n+    /// [IP address]: IpAddr\n+    /// [`IPv6` address]: IpAddr::V6\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n+    /// assert_eq!(socket.is_ipv4(), false);\n+    /// assert_eq!(socket.is_ipv6(), true);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn is_ipv6(&self) -> bool {\n+        matches!(*self, SocketAddr::V6(_))\n+    }\n+}\n+\n+impl SocketAddrV4 {\n+    /// Creates a new socket address from an [`IPv4` address] and a port number.\n+    ///\n+    /// [`IPv4` address]: Ipv4Addr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV4, Ipv4Addr};\n+    ///\n+    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {\n+        SocketAddrV4 { ip, port }\n+    }\n+\n+    /// Returns the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV4, Ipv4Addr};\n+    ///\n+    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    /// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn ip(&self) -> &Ipv4Addr {\n+        &self.ip\n+    }\n+\n+    /// Changes the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV4, Ipv4Addr};\n+    ///\n+    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    /// socket.set_ip(Ipv4Addr::new(192, 168, 0, 1));\n+    /// assert_eq!(socket.ip(), &Ipv4Addr::new(192, 168, 0, 1));\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_ip(&mut self, new_ip: Ipv4Addr) {\n+        self.ip = new_ip;\n+    }\n+\n+    /// Returns the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV4, Ipv4Addr};\n+    ///\n+    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn port(&self) -> u16 {\n+        self.port\n+    }\n+\n+    /// Changes the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV4, Ipv4Addr};\n+    ///\n+    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    /// socket.set_port(4242);\n+    /// assert_eq!(socket.port(), 4242);\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_port(&mut self, new_port: u16) {\n+        self.port = new_port;\n+    }\n+}\n+\n+impl SocketAddrV6 {\n+    /// Creates a new socket address from an [`IPv6` address], a 16-bit port number,\n+    /// and the `flowinfo` and `scope_id` fields.\n+    ///\n+    /// For more information on the meaning and layout of the `flowinfo` and `scope_id`\n+    /// parameters, see [IETF RFC 2553, Section 3.3].\n+    ///\n+    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n+    /// [`IPv6` address]: Ipv6Addr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6 {\n+        SocketAddrV6 { ip, port, flowinfo, scope_id }\n+    }\n+\n+    /// Returns the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    /// assert_eq!(socket.ip(), &Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn ip(&self) -> &Ipv6Addr {\n+        &self.ip\n+    }\n+\n+    /// Changes the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    /// socket.set_ip(Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n+    /// assert_eq!(socket.ip(), &Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_ip(&mut self, new_ip: Ipv6Addr) {\n+        self.ip = new_ip;\n+    }\n+\n+    /// Returns the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn port(&self) -> u16 {\n+        self.port\n+    }\n+\n+    /// Changes the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    /// socket.set_port(4242);\n+    /// assert_eq!(socket.port(), 4242);\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_port(&mut self, new_port: u16) {\n+        self.port = new_port;\n+    }\n+\n+    /// Returns the flow information associated with this address.\n+    ///\n+    /// This information corresponds to the `sin6_flowinfo` field in C's `netinet/in.h`,\n+    /// as specified in [IETF RFC 2553, Section 3.3].\n+    /// It combines information about the flow label and the traffic class as specified\n+    /// in [IETF RFC 2460], respectively [Section 6] and [Section 7].\n+    ///\n+    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n+    /// [IETF RFC 2460]: https://tools.ietf.org/html/rfc2460\n+    /// [Section 6]: https://tools.ietf.org/html/rfc2460#section-6\n+    /// [Section 7]: https://tools.ietf.org/html/rfc2460#section-7\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n+    /// assert_eq!(socket.flowinfo(), 10);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn flowinfo(&self) -> u32 {\n+        self.flowinfo\n+    }\n+\n+    /// Changes the flow information associated with this socket address.\n+    ///\n+    /// See [`SocketAddrV6::flowinfo`]'s documentation for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n+    /// socket.set_flowinfo(56);\n+    /// assert_eq!(socket.flowinfo(), 56);\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_flowinfo(&mut self, new_flowinfo: u32) {\n+        self.flowinfo = new_flowinfo;\n+    }\n+\n+    /// Returns the scope ID associated with this address.\n+    ///\n+    /// This information corresponds to the `sin6_scope_id` field in C's `netinet/in.h`,\n+    /// as specified in [IETF RFC 2553, Section 3.3].\n+    ///\n+    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n+    /// assert_eq!(socket.scope_id(), 78);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn scope_id(&self) -> u32 {\n+        self.scope_id\n+    }\n+\n+    /// Changes the scope ID associated with this socket address.\n+    ///\n+    /// See [`SocketAddrV6::scope_id`]'s documentation for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n+    /// socket.set_scope_id(42);\n+    /// assert_eq!(socket.scope_id(), 42);\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_scope_id(&mut self, new_scope_id: u32) {\n+        self.scope_id = new_scope_id;\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<SocketAddrV4> for SocketAddr {\n+    /// Converts a [`SocketAddrV4`] into a [`SocketAddr::V4`].\n+    fn from(sock4: SocketAddrV4) -> SocketAddr {\n+        SocketAddr::V4(sock4)\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<SocketAddrV6> for SocketAddr {\n+    /// Converts a [`SocketAddrV6`] into a [`SocketAddr::V6`].\n+    fn from(sock6: SocketAddrV6) -> SocketAddr {\n+        SocketAddr::V6(sock6)\n+    }\n+}\n+\n+#[stable(feature = \"addr_from_into_ip\", since = \"1.17.0\")]\n+impl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr {\n+    /// Converts a tuple struct (Into<[`IpAddr`]>, `u16`) into a [`SocketAddr`].\n+    ///\n+    /// This conversion creates a [`SocketAddr::V4`] for an [`IpAddr::V4`]\n+    /// and creates a [`SocketAddr::V6`] for an [`IpAddr::V6`].\n+    ///\n+    /// `u16` is treated as port of the newly created [`SocketAddr`].\n+    fn from(pieces: (I, u16)) -> SocketAddr {\n+        SocketAddr::new(pieces.0.into(), pieces.1)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for SocketAddr {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            SocketAddr::V4(ref a) => a.fmt(f),\n+            SocketAddr::V6(ref a) => a.fmt(f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for SocketAddrV4 {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // If there are no alignment requirements, write the socket address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n+        if f.precision().is_none() && f.width().is_none() {\n+            write!(f, \"{}:{}\", self.ip(), self.port())\n+        } else {\n+            const LONGEST_IPV4_SOCKET_ADDR: &str = \"255.255.255.255:65536\";\n+\n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV4_SOCKET_ADDR.len() }>::new();\n+            // Buffer is long enough for the longest possible IPv4 socket address, so this should never fail.\n+            write!(buf, \"{}:{}\", self.ip(), self.port()).unwrap();\n+\n+            f.pad(buf.as_str())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for SocketAddrV4 {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for SocketAddrV6 {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // If there are no alignment requirements, write the socket address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n+        if f.precision().is_none() && f.width().is_none() {\n+            match self.scope_id() {\n+                0 => write!(f, \"[{}]:{}\", self.ip(), self.port()),\n+                scope_id => write!(f, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n+            }\n+        } else {\n+            const LONGEST_IPV6_SOCKET_ADDR: &str =\n+                \"[ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff%4294967296]:65536\";\n+\n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_SOCKET_ADDR.len() }>::new();\n+            match self.scope_id() {\n+                0 => write!(buf, \"[{}]:{}\", self.ip(), self.port()),\n+                scope_id => write!(buf, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n+            }\n+            // Buffer is long enough for the longest possible IPv6 socket address, so this should never fail.\n+            .unwrap();\n+\n+            f.pad(buf.as_str())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for SocketAddrV6 {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n+impl PartialOrd for SocketAddrV4 {\n+    fn partial_cmp(&self, other: &SocketAddrV4) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n+impl PartialOrd for SocketAddrV6 {\n+    fn partial_cmp(&self, other: &SocketAddrV6) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n+impl Ord for SocketAddrV4 {\n+    fn cmp(&self, other: &SocketAddrV4) -> Ordering {\n+        self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n+    }\n+}\n+\n+#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n+impl Ord for SocketAddrV6 {\n+    fn cmp(&self, other: &SocketAddrV6) -> Ordering {\n+        self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl hash::Hash for SocketAddrV4 {\n+    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n+        (self.port, self.ip).hash(s)\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl hash::Hash for SocketAddrV6 {\n+    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n+        (self.port, &self.ip, self.flowinfo, self.scope_id).hash(s)\n+    }\n+}"}, {"sha": "3947a64e5c6ffe710d07790564bb997a91fd5fb5", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -66,6 +66,7 @@\n #![feature(try_trait_v2)]\n #![feature(slice_internals)]\n #![feature(slice_partition_dedup)]\n+#![feature(ip)]\n #![feature(iter_advance_by)]\n #![feature(iter_array_chunks)]\n #![feature(iter_collect_into)]\n@@ -77,6 +78,9 @@\n #![feature(iter_repeat_n)]\n #![feature(iterator_try_collect)]\n #![feature(iterator_try_reduce)]\n+#![feature(const_ip)]\n+#![feature(const_ipv4)]\n+#![feature(const_ipv6)]\n #![feature(const_mut_refs)]\n #![feature(const_pin)]\n #![feature(const_waker)]\n@@ -135,6 +139,7 @@ mod lazy;\n mod macros;\n mod manually_drop;\n mod mem;\n+mod net;\n mod nonzero;\n mod num;\n mod ops;"}, {"sha": "5a6ac08c08815968d1d95c20024e28de46bf1575", "filename": "library/core/tests/net/ip_addr.rs", "status": "added", "additions": 1035, "deletions": 0, "changes": 1035, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Ftests%2Fnet%2Fip_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Ftests%2Fnet%2Fip_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnet%2Fip_addr.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -0,0 +1,1035 @@\n+use super::{sa4, sa6};\n+use core::net::{\n+    IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope, SocketAddr, SocketAddrV4, SocketAddrV6,\n+};\n+use core::str::FromStr;\n+\n+#[test]\n+fn test_from_str_ipv4() {\n+    assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n+    assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n+    assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n+\n+    // out of range\n+    let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+    // too short\n+    let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n+    assert_eq!(None, none);\n+    // too long\n+    let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n+    assert_eq!(None, none);\n+    // no number between dots\n+    let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n+    assert_eq!(None, none);\n+    // octal\n+    let none: Option<Ipv4Addr> = \"255.0.0.01\".parse().ok();\n+    assert_eq!(None, none);\n+    // octal zero\n+    let none: Option<Ipv4Addr> = \"255.0.0.00\".parse().ok();\n+    assert_eq!(None, none);\n+    let none: Option<Ipv4Addr> = \"255.0.00.0\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn test_from_str_ipv6() {\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n+\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n+\n+    assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)), \"2a02:6b8::11:11\".parse());\n+\n+    // too long group\n+    let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n+    assert_eq!(None, none);\n+    // too short\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n+    assert_eq!(None, none);\n+    // too long\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n+    assert_eq!(None, none);\n+    // triple colon\n+    let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n+    assert_eq!(None, none);\n+    // two double colons\n+    let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n+    assert_eq!(None, none);\n+    // `::` indicating zero groups of zeros\n+    let none: Option<Ipv6Addr> = \"1:2:3:4::5:6:7:8\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn test_from_str_ipv4_in_ipv6() {\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)), \"::192.0.2.33\".parse());\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)), \"::FFFF:192.0.2.33\".parse());\n+    assert_eq!(\n+        Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n+        \"64:ff9b::192.0.2.33\".parse()\n+    );\n+    assert_eq!(\n+        Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n+        \"2001:db8:122:c000:2:2100:192.0.2.33\".parse()\n+    );\n+\n+    // colon after v4\n+    let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n+    assert_eq!(None, none);\n+    // not enough groups\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:127.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+    // too many groups\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:127.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn test_from_str_socket_addr() {\n+    assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n+    assert_eq!(Ok(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n+    assert_eq!(\n+        Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n+        \"[2a02:6b8:0:1::1]:53\".parse()\n+    );\n+    assert_eq!(\n+        Ok(SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53, 0, 0)),\n+        \"[2a02:6b8:0:1::1]:53\".parse()\n+    );\n+    assert_eq!(Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)), \"[::127.0.0.1]:22\".parse());\n+    assert_eq!(\n+        Ok(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22, 0, 0)),\n+        \"[::127.0.0.1]:22\".parse()\n+    );\n+\n+    // without port\n+    let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+    // without port\n+    let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n+    assert_eq!(None, none);\n+    // wrong brackets around v4\n+    let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n+    assert_eq!(None, none);\n+    // port out of range\n+    let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn ipv4_addr_to_string() {\n+    assert_eq!(Ipv4Addr::new(127, 0, 0, 1).to_string(), \"127.0.0.1\");\n+    // Short address\n+    assert_eq!(Ipv4Addr::new(1, 1, 1, 1).to_string(), \"1.1.1.1\");\n+    // Long address\n+    assert_eq!(Ipv4Addr::new(127, 127, 127, 127).to_string(), \"127.127.127.127\");\n+\n+    // Test padding\n+    assert_eq!(format!(\"{:16}\", Ipv4Addr::new(1, 1, 1, 1)), \"1.1.1.1         \");\n+    assert_eq!(format!(\"{:>16}\", Ipv4Addr::new(1, 1, 1, 1)), \"         1.1.1.1\");\n+}\n+\n+#[test]\n+fn ipv6_addr_to_string() {\n+    // ipv4-mapped address\n+    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n+    assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n+\n+    // ipv4-compatible address\n+    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n+    assert_eq!(a1.to_string(), \"::192.0.2.128\");\n+\n+    // v6 address with no zero segments\n+    assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(), \"8:9:a:b:c:d:e:f\");\n+\n+    // longest possible IPv6 length\n+    assert_eq!(\n+        Ipv6Addr::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888).to_string(),\n+        \"1111:2222:3333:4444:5555:6666:7777:8888\"\n+    );\n+    // padding\n+    assert_eq!(format!(\"{:20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"1:2:3:4:5:6:7:8     \");\n+    assert_eq!(format!(\"{:>20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"     1:2:3:4:5:6:7:8\");\n+\n+    // reduce a single run of zeros\n+    assert_eq!(\n+        \"ae::ffff:102:304\",\n+        Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string()\n+    );\n+\n+    // don't reduce just a single zero segment\n+    assert_eq!(\"1:2:3:4:5:6:0:8\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n+\n+    // 'any' address\n+    assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+    // loopback address\n+    assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n+\n+    // ends in zeros\n+    assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+    // two runs of zeros, second one is longer\n+    assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n+\n+    // two runs of zeros, equal length\n+    assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n+\n+    // don't prefix `0x` to each segment in `dbg!`.\n+    assert_eq!(\"1::4:5:0:0:8\", &format!(\"{:#?}\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8)));\n+}\n+\n+#[test]\n+fn ipv4_to_ipv6() {\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n+        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped()\n+    );\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n+        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible()\n+    );\n+}\n+\n+#[test]\n+fn ipv6_to_ipv4_mapped() {\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4_mapped(),\n+        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n+    );\n+    assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4_mapped(), None);\n+}\n+\n+#[test]\n+fn ipv6_to_ipv4() {\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n+        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n+    );\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n+        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n+    );\n+    assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(), None);\n+}\n+\n+#[test]\n+fn ip_properties() {\n+    macro_rules! ip {\n+        ($s:expr) => {\n+            IpAddr::from_str($s).unwrap()\n+        };\n+    }\n+\n+    macro_rules! check {\n+        ($s:expr) => {\n+            check!($s, 0);\n+        };\n+\n+        ($s:expr, $mask:expr) => {{\n+            let unspec: u8 = 1 << 0;\n+            let loopback: u8 = 1 << 1;\n+            let global: u8 = 1 << 2;\n+            let multicast: u8 = 1 << 3;\n+            let doc: u8 = 1 << 4;\n+            let benchmarking: u8 = 1 << 5;\n+\n+            if ($mask & unspec) == unspec {\n+                assert!(ip!($s).is_unspecified());\n+            } else {\n+                assert!(!ip!($s).is_unspecified());\n+            }\n+\n+            if ($mask & loopback) == loopback {\n+                assert!(ip!($s).is_loopback());\n+            } else {\n+                assert!(!ip!($s).is_loopback());\n+            }\n+\n+            if ($mask & global) == global {\n+                assert!(ip!($s).is_global());\n+            } else {\n+                assert!(!ip!($s).is_global());\n+            }\n+\n+            if ($mask & multicast) == multicast {\n+                assert!(ip!($s).is_multicast());\n+            } else {\n+                assert!(!ip!($s).is_multicast());\n+            }\n+\n+            if ($mask & doc) == doc {\n+                assert!(ip!($s).is_documentation());\n+            } else {\n+                assert!(!ip!($s).is_documentation());\n+            }\n+\n+            if ($mask & benchmarking) == benchmarking {\n+                assert!(ip!($s).is_benchmarking());\n+            } else {\n+                assert!(!ip!($s).is_benchmarking());\n+            }\n+        }};\n+    }\n+\n+    let unspec: u8 = 1 << 0;\n+    let loopback: u8 = 1 << 1;\n+    let global: u8 = 1 << 2;\n+    let multicast: u8 = 1 << 3;\n+    let doc: u8 = 1 << 4;\n+    let benchmarking: u8 = 1 << 5;\n+\n+    check!(\"0.0.0.0\", unspec);\n+    check!(\"0.0.0.1\");\n+    check!(\"0.1.0.0\");\n+    check!(\"10.9.8.7\");\n+    check!(\"127.1.2.3\", loopback);\n+    check!(\"172.31.254.253\");\n+    check!(\"169.254.253.242\");\n+    check!(\"192.0.2.183\", doc);\n+    check!(\"192.1.2.183\", global);\n+    check!(\"192.168.254.253\");\n+    check!(\"198.51.100.0\", doc);\n+    check!(\"203.0.113.0\", doc);\n+    check!(\"203.2.113.0\", global);\n+    check!(\"224.0.0.0\", global | multicast);\n+    check!(\"239.255.255.255\", global | multicast);\n+    check!(\"255.255.255.255\");\n+    // make sure benchmarking addresses are not global\n+    check!(\"198.18.0.0\", benchmarking);\n+    check!(\"198.18.54.2\", benchmarking);\n+    check!(\"198.19.255.255\", benchmarking);\n+    // make sure addresses reserved for protocol assignment are not global\n+    check!(\"192.0.0.0\");\n+    check!(\"192.0.0.255\");\n+    check!(\"192.0.0.100\");\n+    // make sure reserved addresses are not global\n+    check!(\"240.0.0.0\");\n+    check!(\"251.54.1.76\");\n+    check!(\"254.255.255.255\");\n+    // make sure shared addresses are not global\n+    check!(\"100.64.0.0\");\n+    check!(\"100.127.255.255\");\n+    check!(\"100.100.100.0\");\n+\n+    check!(\"::\", unspec);\n+    check!(\"::1\", loopback);\n+    check!(\"::0.0.0.2\", global);\n+    check!(\"1::\", global);\n+    check!(\"fc00::\");\n+    check!(\"fdff:ffff::\");\n+    check!(\"fe80:ffff::\");\n+    check!(\"febf:ffff::\");\n+    check!(\"fec0::\", global);\n+    check!(\"ff01::\", global | multicast);\n+    check!(\"ff02::\", global | multicast);\n+    check!(\"ff03::\", global | multicast);\n+    check!(\"ff04::\", global | multicast);\n+    check!(\"ff05::\", global | multicast);\n+    check!(\"ff08::\", global | multicast);\n+    check!(\"ff0e::\", global | multicast);\n+    check!(\"2001:db8:85a3::8a2e:370:7334\", doc);\n+    check!(\"2001:2::ac32:23ff:21\", benchmarking);\n+    check!(\"102:304:506:708:90a:b0c:d0e:f10\", global);\n+}\n+\n+#[test]\n+fn ipv4_properties() {\n+    macro_rules! ip {\n+        ($s:expr) => {\n+            Ipv4Addr::from_str($s).unwrap()\n+        };\n+    }\n+\n+    macro_rules! check {\n+        ($s:expr) => {\n+            check!($s, 0);\n+        };\n+\n+        ($s:expr, $mask:expr) => {{\n+            let unspec: u16 = 1 << 0;\n+            let loopback: u16 = 1 << 1;\n+            let private: u16 = 1 << 2;\n+            let link_local: u16 = 1 << 3;\n+            let global: u16 = 1 << 4;\n+            let multicast: u16 = 1 << 5;\n+            let broadcast: u16 = 1 << 6;\n+            let documentation: u16 = 1 << 7;\n+            let benchmarking: u16 = 1 << 8;\n+            let reserved: u16 = 1 << 10;\n+            let shared: u16 = 1 << 11;\n+\n+            if ($mask & unspec) == unspec {\n+                assert!(ip!($s).is_unspecified());\n+            } else {\n+                assert!(!ip!($s).is_unspecified());\n+            }\n+\n+            if ($mask & loopback) == loopback {\n+                assert!(ip!($s).is_loopback());\n+            } else {\n+                assert!(!ip!($s).is_loopback());\n+            }\n+\n+            if ($mask & private) == private {\n+                assert!(ip!($s).is_private());\n+            } else {\n+                assert!(!ip!($s).is_private());\n+            }\n+\n+            if ($mask & link_local) == link_local {\n+                assert!(ip!($s).is_link_local());\n+            } else {\n+                assert!(!ip!($s).is_link_local());\n+            }\n+\n+            if ($mask & global) == global {\n+                assert!(ip!($s).is_global());\n+            } else {\n+                assert!(!ip!($s).is_global());\n+            }\n+\n+            if ($mask & multicast) == multicast {\n+                assert!(ip!($s).is_multicast());\n+            } else {\n+                assert!(!ip!($s).is_multicast());\n+            }\n+\n+            if ($mask & broadcast) == broadcast {\n+                assert!(ip!($s).is_broadcast());\n+            } else {\n+                assert!(!ip!($s).is_broadcast());\n+            }\n+\n+            if ($mask & documentation) == documentation {\n+                assert!(ip!($s).is_documentation());\n+            } else {\n+                assert!(!ip!($s).is_documentation());\n+            }\n+\n+            if ($mask & benchmarking) == benchmarking {\n+                assert!(ip!($s).is_benchmarking());\n+            } else {\n+                assert!(!ip!($s).is_benchmarking());\n+            }\n+\n+            if ($mask & reserved) == reserved {\n+                assert!(ip!($s).is_reserved());\n+            } else {\n+                assert!(!ip!($s).is_reserved());\n+            }\n+\n+            if ($mask & shared) == shared {\n+                assert!(ip!($s).is_shared());\n+            } else {\n+                assert!(!ip!($s).is_shared());\n+            }\n+        }};\n+    }\n+\n+    let unspec: u16 = 1 << 0;\n+    let loopback: u16 = 1 << 1;\n+    let private: u16 = 1 << 2;\n+    let link_local: u16 = 1 << 3;\n+    let global: u16 = 1 << 4;\n+    let multicast: u16 = 1 << 5;\n+    let broadcast: u16 = 1 << 6;\n+    let documentation: u16 = 1 << 7;\n+    let benchmarking: u16 = 1 << 8;\n+    let reserved: u16 = 1 << 10;\n+    let shared: u16 = 1 << 11;\n+\n+    check!(\"0.0.0.0\", unspec);\n+    check!(\"0.0.0.1\");\n+    check!(\"0.1.0.0\");\n+    check!(\"10.9.8.7\", private);\n+    check!(\"127.1.2.3\", loopback);\n+    check!(\"172.31.254.253\", private);\n+    check!(\"169.254.253.242\", link_local);\n+    check!(\"192.0.2.183\", documentation);\n+    check!(\"192.1.2.183\", global);\n+    check!(\"192.168.254.253\", private);\n+    check!(\"198.51.100.0\", documentation);\n+    check!(\"203.0.113.0\", documentation);\n+    check!(\"203.2.113.0\", global);\n+    check!(\"224.0.0.0\", global | multicast);\n+    check!(\"239.255.255.255\", global | multicast);\n+    check!(\"255.255.255.255\", broadcast);\n+    check!(\"198.18.0.0\", benchmarking);\n+    check!(\"198.18.54.2\", benchmarking);\n+    check!(\"198.19.255.255\", benchmarking);\n+    check!(\"192.0.0.0\");\n+    check!(\"192.0.0.255\");\n+    check!(\"192.0.0.100\");\n+    check!(\"240.0.0.0\", reserved);\n+    check!(\"251.54.1.76\", reserved);\n+    check!(\"254.255.255.255\", reserved);\n+    check!(\"100.64.0.0\", shared);\n+    check!(\"100.127.255.255\", shared);\n+    check!(\"100.100.100.0\", shared);\n+}\n+\n+#[test]\n+fn ipv6_properties() {\n+    macro_rules! ip {\n+        ($s:expr) => {\n+            Ipv6Addr::from_str($s).unwrap()\n+        };\n+    }\n+\n+    macro_rules! check {\n+        ($s:expr, &[$($octet:expr),*], $mask:expr) => {\n+            assert_eq!($s, ip!($s).to_string());\n+            let octets = &[$($octet),*];\n+            assert_eq!(&ip!($s).octets(), octets);\n+            assert_eq!(Ipv6Addr::from(*octets), ip!($s));\n+\n+            let unspecified: u32 = 1 << 0;\n+            let loopback: u32 = 1 << 1;\n+            let unique_local: u32 = 1 << 2;\n+            let global: u32 = 1 << 3;\n+            let unicast_link_local: u32 = 1 << 4;\n+            let unicast_global: u32 = 1 << 7;\n+            let documentation: u32 = 1 << 8;\n+            let benchmarking: u32 = 1 << 16;\n+            let multicast_interface_local: u32 = 1 << 9;\n+            let multicast_link_local: u32 = 1 << 10;\n+            let multicast_realm_local: u32 = 1 << 11;\n+            let multicast_admin_local: u32 = 1 << 12;\n+            let multicast_site_local: u32 = 1 << 13;\n+            let multicast_organization_local: u32 = 1 << 14;\n+            let multicast_global: u32 = 1 << 15;\n+            let multicast: u32 = multicast_interface_local\n+                | multicast_admin_local\n+                | multicast_global\n+                | multicast_link_local\n+                | multicast_realm_local\n+                | multicast_site_local\n+                | multicast_organization_local;\n+\n+            if ($mask & unspecified) == unspecified {\n+                assert!(ip!($s).is_unspecified());\n+            } else {\n+                assert!(!ip!($s).is_unspecified());\n+            }\n+            if ($mask & loopback) == loopback {\n+                assert!(ip!($s).is_loopback());\n+            } else {\n+                assert!(!ip!($s).is_loopback());\n+            }\n+            if ($mask & unique_local) == unique_local {\n+                assert!(ip!($s).is_unique_local());\n+            } else {\n+                assert!(!ip!($s).is_unique_local());\n+            }\n+            if ($mask & global) == global {\n+                assert!(ip!($s).is_global());\n+            } else {\n+                assert!(!ip!($s).is_global());\n+            }\n+            if ($mask & unicast_link_local) == unicast_link_local {\n+                assert!(ip!($s).is_unicast_link_local());\n+            } else {\n+                assert!(!ip!($s).is_unicast_link_local());\n+            }\n+            if ($mask & unicast_global) == unicast_global {\n+                assert!(ip!($s).is_unicast_global());\n+            } else {\n+                assert!(!ip!($s).is_unicast_global());\n+            }\n+            if ($mask & documentation) == documentation {\n+                assert!(ip!($s).is_documentation());\n+            } else {\n+                assert!(!ip!($s).is_documentation());\n+            }\n+            if ($mask & benchmarking) == benchmarking {\n+                assert!(ip!($s).is_benchmarking());\n+            } else {\n+                assert!(!ip!($s).is_benchmarking());\n+            }\n+            if ($mask & multicast) != 0 {\n+                assert!(ip!($s).multicast_scope().is_some());\n+                assert!(ip!($s).is_multicast());\n+            } else {\n+                assert!(ip!($s).multicast_scope().is_none());\n+                assert!(!ip!($s).is_multicast());\n+            }\n+            if ($mask & multicast_interface_local) == multicast_interface_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::InterfaceLocal);\n+            }\n+            if ($mask & multicast_link_local) == multicast_link_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::LinkLocal);\n+            }\n+            if ($mask & multicast_realm_local) == multicast_realm_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::RealmLocal);\n+            }\n+            if ($mask & multicast_admin_local) == multicast_admin_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::AdminLocal);\n+            }\n+            if ($mask & multicast_site_local) == multicast_site_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::SiteLocal);\n+            }\n+            if ($mask & multicast_organization_local) == multicast_organization_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::OrganizationLocal);\n+            }\n+            if ($mask & multicast_global) == multicast_global {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::Global);\n+            }\n+        }\n+    }\n+\n+    let unspecified: u32 = 1 << 0;\n+    let loopback: u32 = 1 << 1;\n+    let unique_local: u32 = 1 << 2;\n+    let global: u32 = 1 << 3;\n+    let unicast_link_local: u32 = 1 << 4;\n+    let unicast_global: u32 = 1 << 7;\n+    let documentation: u32 = 1 << 8;\n+    let benchmarking: u32 = 1 << 16;\n+    let multicast_interface_local: u32 = 1 << 9;\n+    let multicast_link_local: u32 = 1 << 10;\n+    let multicast_realm_local: u32 = 1 << 11;\n+    let multicast_admin_local: u32 = 1 << 12;\n+    let multicast_site_local: u32 = 1 << 13;\n+    let multicast_organization_local: u32 = 1 << 14;\n+    let multicast_global: u32 = 1 << 15;\n+\n+    check!(\"::\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unspecified);\n+\n+    check!(\"::1\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], loopback);\n+\n+    check!(\"::0.0.0.2\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], global | unicast_global);\n+\n+    check!(\"1::\", &[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], global | unicast_global);\n+\n+    check!(\n+        \"::ffff:127.0.0.1\",\n+        &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0x7f, 0, 0, 1],\n+        unicast_global\n+    );\n+\n+    check!(\n+        \"64:ff9b:1::\",\n+        &[0, 0x64, 0xff, 0x9b, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_global\n+    );\n+\n+    check!(\"100::\", &[0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n+\n+    check!(\"2001::\", &[0x20, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n+\n+    check!(\n+        \"2001:1::1\",\n+        &[0x20, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:1::2\",\n+        &[0x20, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:3::\",\n+        &[0x20, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:4:112::\",\n+        &[0x20, 1, 0, 4, 1, 0x12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:20::\",\n+        &[0x20, 1, 0, 0x20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n+    check!(\"2001:30::\", &[0x20, 1, 0, 0x30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n+\n+    check!(\n+        \"2001:200::\",\n+        &[0x20, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n+    check!(\"fc00::\", &[0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unique_local);\n+\n+    check!(\n+        \"fdff:ffff::\",\n+        &[0xfd, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unique_local\n+    );\n+\n+    check!(\n+        \"fe80:ffff::\",\n+        &[0xfe, 0x80, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_link_local\n+    );\n+\n+    check!(\"fe80::\", &[0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_link_local);\n+\n+    check!(\n+        \"febf:ffff::\",\n+        &[0xfe, 0xbf, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_link_local\n+    );\n+\n+    check!(\"febf::\", &[0xfe, 0xbf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_link_local);\n+\n+    check!(\n+        \"febf:ffff:ffff:ffff:ffff:ffff:ffff:ffff\",\n+        &[\n+            0xfe, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff\n+        ],\n+        unicast_link_local\n+    );\n+\n+    check!(\n+        \"fe80::ffff:ffff:ffff:ffff\",\n+        &[\n+            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff\n+        ],\n+        unicast_link_local\n+    );\n+\n+    check!(\n+        \"fe80:0:0:1::\",\n+        &[0xfe, 0x80, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_link_local\n+    );\n+\n+    check!(\n+        \"fec0::\",\n+        &[0xfe, 0xc0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_global | global\n+    );\n+\n+    check!(\n+        \"ff01::\",\n+        &[0xff, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_interface_local | global\n+    );\n+\n+    check!(\n+        \"ff02::\",\n+        &[0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_link_local | global\n+    );\n+\n+    check!(\n+        \"ff03::\",\n+        &[0xff, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_realm_local | global\n+    );\n+\n+    check!(\n+        \"ff04::\",\n+        &[0xff, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_admin_local | global\n+    );\n+\n+    check!(\n+        \"ff05::\",\n+        &[0xff, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_site_local | global\n+    );\n+\n+    check!(\n+        \"ff08::\",\n+        &[0xff, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_organization_local | global\n+    );\n+\n+    check!(\n+        \"ff0e::\",\n+        &[0xff, 0xe, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_global | global\n+    );\n+\n+    check!(\n+        \"2001:db8:85a3::8a2e:370:7334\",\n+        &[0x20, 1, 0xd, 0xb8, 0x85, 0xa3, 0, 0, 0, 0, 0x8a, 0x2e, 3, 0x70, 0x73, 0x34],\n+        documentation\n+    );\n+\n+    check!(\n+        \"2001:2::ac32:23ff:21\",\n+        &[0x20, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0xac, 0x32, 0x23, 0xff, 0, 0x21],\n+        benchmarking\n+    );\n+\n+    check!(\n+        \"102:304:506:708:90a:b0c:d0e:f10\",\n+        &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n+        global | unicast_global\n+    );\n+}\n+\n+#[test]\n+fn test_ipv4_to_int() {\n+    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n+    assert_eq!(u32::from(a), 0x11223344);\n+}\n+\n+#[test]\n+fn test_int_to_ipv4() {\n+    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n+    assert_eq!(Ipv4Addr::from(0x11223344), a);\n+}\n+\n+#[test]\n+fn test_ipv6_to_int() {\n+    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n+    assert_eq!(u128::from(a), 0x112233445566778899aabbccddeeff11u128);\n+}\n+\n+#[test]\n+fn test_int_to_ipv6() {\n+    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n+    assert_eq!(Ipv6Addr::from(0x112233445566778899aabbccddeeff11u128), a);\n+}\n+\n+#[test]\n+fn ipv4_from_constructors() {\n+    assert_eq!(Ipv4Addr::LOCALHOST, Ipv4Addr::new(127, 0, 0, 1));\n+    assert!(Ipv4Addr::LOCALHOST.is_loopback());\n+    assert_eq!(Ipv4Addr::UNSPECIFIED, Ipv4Addr::new(0, 0, 0, 0));\n+    assert!(Ipv4Addr::UNSPECIFIED.is_unspecified());\n+    assert_eq!(Ipv4Addr::BROADCAST, Ipv4Addr::new(255, 255, 255, 255));\n+    assert!(Ipv4Addr::BROADCAST.is_broadcast());\n+}\n+\n+#[test]\n+fn ipv6_from_constructors() {\n+    assert_eq!(Ipv6Addr::LOCALHOST, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+    assert!(Ipv6Addr::LOCALHOST.is_loopback());\n+    assert_eq!(Ipv6Addr::UNSPECIFIED, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n+    assert!(Ipv6Addr::UNSPECIFIED.is_unspecified());\n+}\n+\n+#[test]\n+fn ipv4_from_octets() {\n+    assert_eq!(Ipv4Addr::from([127, 0, 0, 1]), Ipv4Addr::new(127, 0, 0, 1))\n+}\n+\n+#[test]\n+fn ipv6_from_segments() {\n+    let from_u16s =\n+        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n+    let new = Ipv6Addr::new(0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff);\n+    assert_eq!(new, from_u16s);\n+}\n+\n+#[test]\n+fn ipv6_from_octets() {\n+    let from_u16s =\n+        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n+    let from_u8s = Ipv6Addr::from([\n+        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,\n+        0xff,\n+    ]);\n+    assert_eq!(from_u16s, from_u8s);\n+}\n+\n+#[test]\n+fn cmp() {\n+    let v41 = Ipv4Addr::new(100, 64, 3, 3);\n+    let v42 = Ipv4Addr::new(192, 0, 2, 2);\n+    let v61 = \"2001:db8:f00::1002\".parse::<Ipv6Addr>().unwrap();\n+    let v62 = \"2001:db8:f00::2001\".parse::<Ipv6Addr>().unwrap();\n+    assert!(v41 < v42);\n+    assert!(v61 < v62);\n+\n+    assert_eq!(v41, IpAddr::V4(v41));\n+    assert_eq!(v61, IpAddr::V6(v61));\n+    assert!(v41 != IpAddr::V4(v42));\n+    assert!(v61 != IpAddr::V6(v62));\n+\n+    assert!(v41 < IpAddr::V4(v42));\n+    assert!(v61 < IpAddr::V6(v62));\n+    assert!(IpAddr::V4(v41) < v42);\n+    assert!(IpAddr::V6(v61) < v62);\n+\n+    assert!(v41 < IpAddr::V6(v61));\n+    assert!(IpAddr::V4(v41) < v61);\n+}\n+\n+#[test]\n+fn is_v4() {\n+    let ip = IpAddr::V4(Ipv4Addr::new(100, 64, 3, 3));\n+    assert!(ip.is_ipv4());\n+    assert!(!ip.is_ipv6());\n+}\n+\n+#[test]\n+fn is_v6() {\n+    let ip = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678));\n+    assert!(!ip.is_ipv4());\n+    assert!(ip.is_ipv6());\n+}\n+\n+#[test]\n+fn ipv4_const() {\n+    // test that the methods of `Ipv4Addr` are usable in a const context\n+\n+    const IP_ADDRESS: Ipv4Addr = Ipv4Addr::new(127, 0, 0, 1);\n+    assert_eq!(IP_ADDRESS, Ipv4Addr::LOCALHOST);\n+\n+    const OCTETS: [u8; 4] = IP_ADDRESS.octets();\n+    assert_eq!(OCTETS, [127, 0, 0, 1]);\n+\n+    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n+    assert!(!IS_UNSPECIFIED);\n+\n+    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n+    assert!(IS_LOOPBACK);\n+\n+    const IS_PRIVATE: bool = IP_ADDRESS.is_private();\n+    assert!(!IS_PRIVATE);\n+\n+    const IS_LINK_LOCAL: bool = IP_ADDRESS.is_link_local();\n+    assert!(!IS_LINK_LOCAL);\n+\n+    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n+    assert!(!IS_GLOBAL);\n+\n+    const IS_SHARED: bool = IP_ADDRESS.is_shared();\n+    assert!(!IS_SHARED);\n+\n+    const IS_BENCHMARKING: bool = IP_ADDRESS.is_benchmarking();\n+    assert!(!IS_BENCHMARKING);\n+\n+    const IS_RESERVED: bool = IP_ADDRESS.is_reserved();\n+    assert!(!IS_RESERVED);\n+\n+    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n+    assert!(!IS_MULTICAST);\n+\n+    const IS_BROADCAST: bool = IP_ADDRESS.is_broadcast();\n+    assert!(!IS_BROADCAST);\n+\n+    const IS_DOCUMENTATION: bool = IP_ADDRESS.is_documentation();\n+    assert!(!IS_DOCUMENTATION);\n+\n+    const IP_V6_COMPATIBLE: Ipv6Addr = IP_ADDRESS.to_ipv6_compatible();\n+    assert_eq!(\n+        IP_V6_COMPATIBLE,\n+        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 1])\n+    );\n+\n+    const IP_V6_MAPPED: Ipv6Addr = IP_ADDRESS.to_ipv6_mapped();\n+    assert_eq!(\n+        IP_V6_MAPPED,\n+        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 127, 0, 0, 1])\n+    );\n+}\n+\n+#[test]\n+fn ipv6_const() {\n+    // test that the methods of `Ipv6Addr` are usable in a const context\n+\n+    const IP_ADDRESS: Ipv6Addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n+    assert_eq!(IP_ADDRESS, Ipv6Addr::LOCALHOST);\n+\n+    const SEGMENTS: [u16; 8] = IP_ADDRESS.segments();\n+    assert_eq!(SEGMENTS, [0, 0, 0, 0, 0, 0, 0, 1]);\n+\n+    const OCTETS: [u8; 16] = IP_ADDRESS.octets();\n+    assert_eq!(OCTETS, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);\n+\n+    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n+    assert!(!IS_UNSPECIFIED);\n+\n+    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n+    assert!(IS_LOOPBACK);\n+\n+    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n+    assert!(!IS_GLOBAL);\n+\n+    const IS_UNIQUE_LOCAL: bool = IP_ADDRESS.is_unique_local();\n+    assert!(!IS_UNIQUE_LOCAL);\n+\n+    const IS_UNICAST_LINK_LOCAL: bool = IP_ADDRESS.is_unicast_link_local();\n+    assert!(!IS_UNICAST_LINK_LOCAL);\n+\n+    const IS_DOCUMENTATION: bool = IP_ADDRESS.is_documentation();\n+    assert!(!IS_DOCUMENTATION);\n+\n+    const IS_BENCHMARKING: bool = IP_ADDRESS.is_benchmarking();\n+    assert!(!IS_BENCHMARKING);\n+\n+    const IS_UNICAST_GLOBAL: bool = IP_ADDRESS.is_unicast_global();\n+    assert!(!IS_UNICAST_GLOBAL);\n+\n+    const MULTICAST_SCOPE: Option<Ipv6MulticastScope> = IP_ADDRESS.multicast_scope();\n+    assert_eq!(MULTICAST_SCOPE, None);\n+\n+    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n+    assert!(!IS_MULTICAST);\n+\n+    const IP_V4: Option<Ipv4Addr> = IP_ADDRESS.to_ipv4();\n+    assert_eq!(IP_V4.unwrap(), Ipv4Addr::new(0, 0, 0, 1));\n+}\n+\n+#[test]\n+fn ip_const() {\n+    // test that the methods of `IpAddr` are usable in a const context\n+\n+    const IP_ADDRESS: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST);\n+\n+    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n+    assert!(!IS_UNSPECIFIED);\n+\n+    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n+    assert!(IS_LOOPBACK);\n+\n+    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n+    assert!(!IS_GLOBAL);\n+\n+    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n+    assert!(!IS_MULTICAST);\n+\n+    const IS_IP_V4: bool = IP_ADDRESS.is_ipv4();\n+    assert!(IS_IP_V4);\n+\n+    const IS_IP_V6: bool = IP_ADDRESS.is_ipv6();\n+    assert!(!IS_IP_V6);\n+}\n+\n+#[test]\n+fn structural_match() {\n+    // test that all IP types can be structurally matched upon\n+\n+    const IPV4: Ipv4Addr = Ipv4Addr::LOCALHOST;\n+    match IPV4 {\n+        Ipv4Addr::LOCALHOST => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const IPV6: Ipv6Addr = Ipv6Addr::LOCALHOST;\n+    match IPV6 {\n+        Ipv6Addr::LOCALHOST => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const IP: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST);\n+    match IP {\n+        IpAddr::V4(Ipv4Addr::LOCALHOST) => {}\n+        _ => unreachable!(),\n+    }\n+}"}, {"sha": "8f17bbe5548ac86be7ae49f76b29afaaf2950ce0", "filename": "library/core/tests/net/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Ftests%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Ftests%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnet%2Fmod.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -0,0 +1,13 @@\n+use core::net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n+\n+mod ip_addr;\n+mod parser;\n+mod socket_addr;\n+\n+pub fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr {\n+    SocketAddr::V4(SocketAddrV4::new(a, p))\n+}\n+\n+pub fn sa6(a: Ipv6Addr, p: u16) -> SocketAddr {\n+    SocketAddr::V6(SocketAddrV6::new(a, p, 0, 0))\n+}"}, {"sha": "36b87d7c1f5e00392761ee385cb2d137025d83e7", "filename": "library/core/tests/net/parser.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Ftests%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Ftests%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnet%2Fparser.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -1,6 +1,6 @@\n // FIXME: These tests are all excellent candidates for AFL fuzz testing\n-use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n-use crate::str::FromStr;\n+use core::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n+use core::str::FromStr;\n \n const PORT: u16 = 8080;\n const SCOPE_ID: u32 = 1337;", "previous_filename": "library/std/src/net/parser/tests.rs"}, {"sha": "68c7cd94d322faa2c03836df7e1cf2860ae87082", "filename": "library/core/tests/net/socket_addr.rs", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Ftests%2Fnet%2Fsocket_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fcore%2Ftests%2Fnet%2Fsocket_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnet%2Fsocket_addr.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -0,0 +1,233 @@\n+use core::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n+\n+#[test]\n+fn ipv4_socket_addr_to_string() {\n+    // Shortest possible IPv4 length.\n+    assert_eq!(SocketAddrV4::new(Ipv4Addr::new(0, 0, 0, 0), 0).to_string(), \"0.0.0.0:0\");\n+\n+    // Longest possible IPv4 length.\n+    assert_eq!(\n+        SocketAddrV4::new(Ipv4Addr::new(255, 255, 255, 255), u16::MAX).to_string(),\n+        \"255.255.255.255:65535\"\n+    );\n+\n+    // Test padding.\n+    assert_eq!(\n+        &format!(\"{:16}\", SocketAddrV4::new(Ipv4Addr::new(1, 1, 1, 1), 53)),\n+        \"1.1.1.1:53      \"\n+    );\n+    assert_eq!(\n+        &format!(\"{:>16}\", SocketAddrV4::new(Ipv4Addr::new(1, 1, 1, 1), 53)),\n+        \"      1.1.1.1:53\"\n+    );\n+}\n+\n+#[test]\n+fn ipv6_socket_addr_to_string() {\n+    // IPv4-mapped address.\n+    assert_eq!(\n+        SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280), 8080, 0, 0)\n+            .to_string(),\n+        \"[::ffff:192.0.2.128]:8080\"\n+    );\n+\n+    // IPv4-compatible address.\n+    assert_eq!(\n+        SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280), 8080, 0, 0).to_string(),\n+        \"[::192.0.2.128]:8080\"\n+    );\n+\n+    // IPv6 address with no zero segments.\n+    assert_eq!(\n+        SocketAddrV6::new(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15), 80, 0, 0).to_string(),\n+        \"[8:9:a:b:c:d:e:f]:80\"\n+    );\n+\n+    // Shortest possible IPv6 length.\n+    assert_eq!(SocketAddrV6::new(Ipv6Addr::UNSPECIFIED, 0, 0, 0).to_string(), \"[::]:0\");\n+\n+    // Longest possible IPv6 length.\n+    assert_eq!(\n+        SocketAddrV6::new(\n+            Ipv6Addr::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888),\n+            u16::MAX,\n+            u32::MAX,\n+            u32::MAX,\n+        )\n+        .to_string(),\n+        \"[1111:2222:3333:4444:5555:6666:7777:8888%4294967295]:65535\"\n+    );\n+\n+    // Test padding.\n+    assert_eq!(\n+        &format!(\"{:22}\", SocketAddrV6::new(Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8), 9, 0, 0)),\n+        \"[1:2:3:4:5:6:7:8]:9   \"\n+    );\n+    assert_eq!(\n+        &format!(\"{:>22}\", SocketAddrV6::new(Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8), 9, 0, 0)),\n+        \"   [1:2:3:4:5:6:7:8]:9\"\n+    );\n+}\n+\n+#[test]\n+fn set_ip() {\n+    fn ip4(low: u8) -> Ipv4Addr {\n+        Ipv4Addr::new(77, 88, 21, low)\n+    }\n+    fn ip6(low: u16) -> Ipv6Addr {\n+        Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, low)\n+    }\n+\n+    let mut v4 = SocketAddrV4::new(ip4(11), 80);\n+    assert_eq!(v4.ip(), &ip4(11));\n+    v4.set_ip(ip4(12));\n+    assert_eq!(v4.ip(), &ip4(12));\n+\n+    let mut addr = SocketAddr::V4(v4);\n+    assert_eq!(addr.ip(), IpAddr::V4(ip4(12)));\n+    addr.set_ip(IpAddr::V4(ip4(13)));\n+    assert_eq!(addr.ip(), IpAddr::V4(ip4(13)));\n+    addr.set_ip(IpAddr::V6(ip6(14)));\n+    assert_eq!(addr.ip(), IpAddr::V6(ip6(14)));\n+\n+    let mut v6 = SocketAddrV6::new(ip6(1), 80, 0, 0);\n+    assert_eq!(v6.ip(), &ip6(1));\n+    v6.set_ip(ip6(2));\n+    assert_eq!(v6.ip(), &ip6(2));\n+\n+    let mut addr = SocketAddr::V6(v6);\n+    assert_eq!(addr.ip(), IpAddr::V6(ip6(2)));\n+    addr.set_ip(IpAddr::V6(ip6(3)));\n+    assert_eq!(addr.ip(), IpAddr::V6(ip6(3)));\n+    addr.set_ip(IpAddr::V4(ip4(4)));\n+    assert_eq!(addr.ip(), IpAddr::V4(ip4(4)));\n+}\n+\n+#[test]\n+fn set_port() {\n+    let mut v4 = SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80);\n+    assert_eq!(v4.port(), 80);\n+    v4.set_port(443);\n+    assert_eq!(v4.port(), 443);\n+\n+    let mut addr = SocketAddr::V4(v4);\n+    assert_eq!(addr.port(), 443);\n+    addr.set_port(8080);\n+    assert_eq!(addr.port(), 8080);\n+\n+    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 0, 0);\n+    assert_eq!(v6.port(), 80);\n+    v6.set_port(443);\n+    assert_eq!(v6.port(), 443);\n+\n+    let mut addr = SocketAddr::V6(v6);\n+    assert_eq!(addr.port(), 443);\n+    addr.set_port(8080);\n+    assert_eq!(addr.port(), 8080);\n+}\n+\n+#[test]\n+fn set_flowinfo() {\n+    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 10, 0);\n+    assert_eq!(v6.flowinfo(), 10);\n+    v6.set_flowinfo(20);\n+    assert_eq!(v6.flowinfo(), 20);\n+}\n+\n+#[test]\n+fn set_scope_id() {\n+    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 0, 10);\n+    assert_eq!(v6.scope_id(), 10);\n+    v6.set_scope_id(20);\n+    assert_eq!(v6.scope_id(), 20);\n+}\n+\n+#[test]\n+fn is_v4() {\n+    let v4 = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80));\n+    assert!(v4.is_ipv4());\n+    assert!(!v4.is_ipv6());\n+}\n+\n+#[test]\n+fn is_v6() {\n+    let v6 = SocketAddr::V6(SocketAddrV6::new(\n+        Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1),\n+        80,\n+        10,\n+        0,\n+    ));\n+    assert!(!v6.is_ipv4());\n+    assert!(v6.is_ipv6());\n+}\n+\n+#[test]\n+fn socket_v4_to_str() {\n+    let socket = SocketAddrV4::new(Ipv4Addr::new(192, 168, 0, 1), 8080);\n+\n+    assert_eq!(format!(\"{socket}\"), \"192.168.0.1:8080\");\n+    assert_eq!(format!(\"{socket:<20}\"), \"192.168.0.1:8080    \");\n+    assert_eq!(format!(\"{socket:>20}\"), \"    192.168.0.1:8080\");\n+    assert_eq!(format!(\"{socket:^20}\"), \"  192.168.0.1:8080  \");\n+    assert_eq!(format!(\"{socket:.10}\"), \"192.168.0.\");\n+}\n+\n+#[test]\n+fn socket_v6_to_str() {\n+    let mut socket = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53, 0, 0);\n+\n+    assert_eq!(format!(\"{socket}\"), \"[2a02:6b8:0:1::1]:53\");\n+    assert_eq!(format!(\"{socket:<24}\"), \"[2a02:6b8:0:1::1]:53    \");\n+    assert_eq!(format!(\"{socket:>24}\"), \"    [2a02:6b8:0:1::1]:53\");\n+    assert_eq!(format!(\"{socket:^24}\"), \"  [2a02:6b8:0:1::1]:53  \");\n+    assert_eq!(format!(\"{socket:.15}\"), \"[2a02:6b8:0:1::\");\n+\n+    socket.set_scope_id(5);\n+\n+    assert_eq!(format!(\"{socket}\"), \"[2a02:6b8:0:1::1%5]:53\");\n+    assert_eq!(format!(\"{socket:<24}\"), \"[2a02:6b8:0:1::1%5]:53  \");\n+    assert_eq!(format!(\"{socket:>24}\"), \"  [2a02:6b8:0:1::1%5]:53\");\n+    assert_eq!(format!(\"{socket:^24}\"), \" [2a02:6b8:0:1::1%5]:53 \");\n+    assert_eq!(format!(\"{socket:.18}\"), \"[2a02:6b8:0:1::1%5\");\n+}\n+\n+#[test]\n+fn compare() {\n+    let v4_1 = \"224.120.45.1:23456\".parse::<SocketAddrV4>().unwrap();\n+    let v4_2 = \"224.210.103.5:12345\".parse::<SocketAddrV4>().unwrap();\n+    let v4_3 = \"224.210.103.5:23456\".parse::<SocketAddrV4>().unwrap();\n+    let v6_1 = \"[2001:db8:f00::1002]:23456\".parse::<SocketAddrV6>().unwrap();\n+    let v6_2 = \"[2001:db8:f00::2001]:12345\".parse::<SocketAddrV6>().unwrap();\n+    let v6_3 = \"[2001:db8:f00::2001]:23456\".parse::<SocketAddrV6>().unwrap();\n+\n+    // equality\n+    assert_eq!(v4_1, v4_1);\n+    assert_eq!(v6_1, v6_1);\n+    assert_eq!(SocketAddr::V4(v4_1), SocketAddr::V4(v4_1));\n+    assert_eq!(SocketAddr::V6(v6_1), SocketAddr::V6(v6_1));\n+    assert!(v4_1 != v4_2);\n+    assert!(v6_1 != v6_2);\n+\n+    // compare different addresses\n+    assert!(v4_1 < v4_2);\n+    assert!(v6_1 < v6_2);\n+    assert!(v4_2 > v4_1);\n+    assert!(v6_2 > v6_1);\n+\n+    // compare the same address with different ports\n+    assert!(v4_2 < v4_3);\n+    assert!(v6_2 < v6_3);\n+    assert!(v4_3 > v4_2);\n+    assert!(v6_3 > v6_2);\n+\n+    // compare different addresses with the same port\n+    assert!(v4_1 < v4_3);\n+    assert!(v6_1 < v6_3);\n+    assert!(v4_3 > v4_1);\n+    assert!(v6_3 > v6_1);\n+\n+    // compare with an inferred right-hand side\n+    assert_eq!(v4_1, \"224.120.45.1:23456\".parse().unwrap());\n+    assert_eq!(v6_1, \"[2001:db8:f00::1002]:23456\".parse().unwrap());\n+    assert_eq!(SocketAddr::V4(v4_1), \"224.120.45.1:23456\".parse().unwrap());\n+}"}, {"sha": "d160de6df2ba7cd8ebe141168d66c9fde49e8baa", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -287,6 +287,8 @@\n #![feature(float_next_up_down)]\n #![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n+#![feature(ip)]\n+#![feature(ip_in_core)]\n #![feature(is_some_and)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_write_slice)]"}, {"sha": "e167fbd1b9cf89b2931120e8bacaed226ef854f7", "filename": "library/std/src/net/ip_addr.rs", "status": "modified", "additions": 7, "deletions": 2068, "changes": 2075, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -2,2101 +2,40 @@\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n \n-use crate::cmp::Ordering;\n-use crate::fmt::{self, Write};\n-use crate::mem::transmute;\n use crate::sys::net::netc as c;\n use crate::sys_common::{FromInner, IntoInner};\n \n-use super::display_buffer::DisplayBuffer;\n-\n-/// An IP address, either IPv4 or IPv6.\n-///\n-/// This enum can contain either an [`Ipv4Addr`] or an [`Ipv6Addr`], see their\n-/// respective documentation for more details.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-///\n-/// let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n-/// let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n-///\n-/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost_v4));\n-/// assert_eq!(\"::1\".parse(), Ok(localhost_v6));\n-///\n-/// assert_eq!(localhost_v4.is_ipv6(), false);\n-/// assert_eq!(localhost_v4.is_ipv4(), true);\n-/// ```\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"IpAddr\")]\n #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-#[derive(Copy, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]\n-pub enum IpAddr {\n-    /// An IPv4 address.\n-    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-    V4(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv4Addr),\n-    /// An IPv6 address.\n-    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-    V6(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv6Addr),\n-}\n+pub use core::net::IpAddr;\n \n-/// An IPv4 address.\n-///\n-/// IPv4 addresses are defined as 32-bit integers in [IETF RFC 791].\n-/// They are usually represented as four octets.\n-///\n-/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n-///\n-/// [IETF RFC 791]: https://tools.ietf.org/html/rfc791\n-///\n-/// # Textual representation\n-///\n-/// `Ipv4Addr` provides a [`FromStr`] implementation. The four octets are in decimal\n-/// notation, divided by `.` (this is called \"dot-decimal notation\").\n-/// Notably, octal numbers (which are indicated with a leading `0`) and hexadecimal numbers (which\n-/// are indicated with a leading `0x`) are not allowed per [IETF RFC 6943].\n-///\n-/// [IETF RFC 6943]: https://tools.ietf.org/html/rfc6943#section-3.1.1\n-/// [`FromStr`]: crate::str::FromStr\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::Ipv4Addr;\n-///\n-/// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n-/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost));\n-/// assert_eq!(localhost.is_loopback(), true);\n-/// assert!(\"012.004.002.000\".parse::<Ipv4Addr>().is_err()); // all octets are in octal\n-/// assert!(\"0000000.0.0.0\".parse::<Ipv4Addr>().is_err()); // first octet is a zero in octal\n-/// assert!(\"0xcb.0x0.0x71.0x00\".parse::<Ipv4Addr>().is_err()); // all octets are in hex\n-/// ```\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Ipv4Addr {\n-    octets: [u8; 4],\n-}\n+pub use core::net::{Ipv4Addr, Ipv6Addr};\n \n-/// An IPv6 address.\n-///\n-/// IPv6 addresses are defined as 128-bit integers in [IETF RFC 4291].\n-/// They are usually represented as eight 16-bit segments.\n-///\n-/// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n-///\n-/// # Embedding IPv4 Addresses\n-///\n-/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n-///\n-/// To assist in the transition from IPv4 to IPv6 two types of IPv6 addresses that embed an IPv4 address were defined:\n-/// IPv4-compatible and IPv4-mapped addresses. Of these IPv4-compatible addresses have been officially deprecated.\n-///\n-/// Both types of addresses are not assigned any special meaning by this implementation,\n-/// other than what the relevant standards prescribe. This means that an address like `::ffff:127.0.0.1`,\n-/// while representing an IPv4 loopback address, is not itself an IPv6 loopback address; only `::1` is.\n-/// To handle these so called \"IPv4-in-IPv6\" addresses, they have to first be converted to their canonical IPv4 address.\n-///\n-/// ### IPv4-Compatible IPv6 Addresses\n-///\n-/// IPv4-compatible IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.1], and have been officially deprecated.\n-/// The RFC describes the format of an \"IPv4-Compatible IPv6 address\" as follows:\n-///\n-/// ```text\n-/// |                80 bits               | 16 |      32 bits        |\n-/// +--------------------------------------+--------------------------+\n-/// |0000..............................0000|0000|    IPv4 address     |\n-/// +--------------------------------------+----+---------------------+\n-/// ```\n-/// So `::a.b.c.d` would be an IPv4-compatible IPv6 address representing the IPv4 address `a.b.c.d`.\n-///\n-/// To convert from an IPv4 address to an IPv4-compatible IPv6 address, use [`Ipv4Addr::to_ipv6_compatible`].\n-/// Use [`Ipv6Addr::to_ipv4`] to convert an IPv4-compatible IPv6 address to the canonical IPv4 address.\n-///\n-/// [IETF RFC 4291 Section 2.5.5.1]: https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.1\n-///\n-/// ### IPv4-Mapped IPv6 Addresses\n-///\n-/// IPv4-mapped IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.2].\n-/// The RFC describes the format of an \"IPv4-Mapped IPv6 address\" as follows:\n-///\n-/// ```text\n-/// |                80 bits               | 16 |      32 bits        |\n-/// +--------------------------------------+--------------------------+\n-/// |0000..............................0000|FFFF|    IPv4 address     |\n-/// +--------------------------------------+----+---------------------+\n-/// ```\n-/// So `::ffff:a.b.c.d` would be an IPv4-mapped IPv6 address representing the IPv4 address `a.b.c.d`.\n-///\n-/// To convert from an IPv4 address to an IPv4-mapped IPv6 address, use [`Ipv4Addr::to_ipv6_mapped`].\n-/// Use [`Ipv6Addr::to_ipv4`] to convert an IPv4-mapped IPv6 address to the canonical IPv4 address.\n-/// Note that this will also convert the IPv6 loopback address `::1` to `0.0.0.1`. Use\n-/// [`Ipv6Addr::to_ipv4_mapped`] to avoid this.\n-///\n-/// [IETF RFC 4291 Section 2.5.5.2]: https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2\n-///\n-/// # Textual representation\n-///\n-/// `Ipv6Addr` provides a [`FromStr`] implementation. There are many ways to represent\n-/// an IPv6 address in text, but in general, each segments is written in hexadecimal\n-/// notation, and segments are separated by `:`. For more information, see\n-/// [IETF RFC 5952].\n-///\n-/// [`FromStr`]: crate::str::FromStr\n-/// [IETF RFC 5952]: https://tools.ietf.org/html/rfc5952\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::Ipv6Addr;\n-///\n-/// let localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n-/// assert_eq!(\"::1\".parse(), Ok(localhost));\n-/// assert_eq!(localhost.is_loopback(), true);\n-/// ```\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Ipv6Addr {\n-    octets: [u8; 16],\n-}\n-\n-/// Scope of an [IPv6 multicast address] as defined in [IETF RFC 7346 section 2].\n-///\n-/// # Stability Guarantees\n-///\n-/// Not all possible values for a multicast scope have been assigned.\n-/// Future RFCs may introduce new scopes, which will be added as variants to this enum;\n-/// because of this the enum is marked as `#[non_exhaustive]`.\n-///\n-/// # Examples\n-/// ```\n-/// #![feature(ip)]\n-///\n-/// use std::net::Ipv6Addr;\n-/// use std::net::Ipv6MulticastScope::*;\n-///\n-/// // An IPv6 multicast address with global scope (`ff0e::`).\n-/// let address = Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0);\n-///\n-/// // Will print \"Global scope\".\n-/// match address.multicast_scope() {\n-///     Some(InterfaceLocal) => println!(\"Interface-Local scope\"),\n-///     Some(LinkLocal) => println!(\"Link-Local scope\"),\n-///     Some(RealmLocal) => println!(\"Realm-Local scope\"),\n-///     Some(AdminLocal) => println!(\"Admin-Local scope\"),\n-///     Some(SiteLocal) => println!(\"Site-Local scope\"),\n-///     Some(OrganizationLocal) => println!(\"Organization-Local scope\"),\n-///     Some(Global) => println!(\"Global scope\"),\n-///     Some(_) => println!(\"Unknown scope\"),\n-///     None => println!(\"Not a multicast address!\")\n-/// }\n-///\n-/// ```\n-///\n-/// [IPv6 multicast address]: Ipv6Addr\n-/// [IETF RFC 7346 section 2]: https://tools.ietf.org/html/rfc7346#section-2\n-#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n #[unstable(feature = \"ip\", issue = \"27709\")]\n-#[non_exhaustive]\n-pub enum Ipv6MulticastScope {\n-    /// Interface-Local scope.\n-    InterfaceLocal,\n-    /// Link-Local scope.\n-    LinkLocal,\n-    /// Realm-Local scope.\n-    RealmLocal,\n-    /// Admin-Local scope.\n-    AdminLocal,\n-    /// Site-Local scope.\n-    SiteLocal,\n-    /// Organization-Local scope.\n-    OrganizationLocal,\n-    /// Global scope.\n-    Global,\n-}\n-\n-impl IpAddr {\n-    /// Returns [`true`] for the special 'unspecified' address.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_unspecified()`] and\n-    /// [`Ipv6Addr::is_unspecified()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)).is_unspecified(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)).is_unspecified(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unspecified(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_unspecified(),\n-            IpAddr::V6(ip) => ip.is_unspecified(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if this is a loopback address.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_loopback()`] and\n-    /// [`Ipv6Addr::is_loopback()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).is_loopback(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1)).is_loopback(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_loopback(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_loopback(),\n-            IpAddr::V6(ip) => ip.is_loopback(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if the address appears to be globally routable.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_global()`] and\n-    /// [`Ipv6Addr::is_global()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_global(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_global(),\n-            IpAddr::V6(ip) => ip.is_global(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if this is a multicast address.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_multicast()`] and\n-    /// [`Ipv6Addr::is_multicast()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(224, 254, 0, 0)).is_multicast(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0)).is_multicast(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_multicast(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_multicast(),\n-            IpAddr::V6(ip) => ip.is_multicast(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if this address is in a range designated for documentation.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_documentation()`] and\n-    /// [`Ipv6Addr::is_documentation()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_documentation(), true);\n-    /// assert_eq!(\n-    ///     IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_documentation(),\n-    ///     true\n-    /// );\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_documentation(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_documentation(),\n-            IpAddr::V6(ip) => ip.is_documentation(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if this address is in a range designated for benchmarking.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_benchmarking()`] and\n-    /// [`Ipv6Addr::is_benchmarking()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(198, 19, 255, 255)).is_benchmarking(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0x2, 0, 0, 0, 0, 0, 0)).is_benchmarking(), true);\n-    /// ```\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_benchmarking(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_benchmarking(),\n-            IpAddr::V6(ip) => ip.is_benchmarking(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if this address is an [`IPv4` address], and [`false`]\n-    /// otherwise.\n-    ///\n-    /// [`IPv4` address]: IpAddr::V4\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_ipv4(&self) -> bool {\n-        matches!(self, IpAddr::V4(_))\n-    }\n-\n-    /// Returns [`true`] if this address is an [`IPv6` address], and [`false`]\n-    /// otherwise.\n-    ///\n-    /// [`IPv6` address]: IpAddr::V6\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_ipv6(&self) -> bool {\n-        matches!(self, IpAddr::V6(_))\n-    }\n-\n-    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped IPv6 addresses, otherwise it\n-    /// return `self` as-is.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).to_canonical().is_loopback(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1)).is_loopback(), false);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1)).to_canonical().is_loopback(), true);\n-    /// ```\n-    #[inline]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    pub const fn to_canonical(&self) -> IpAddr {\n-        match self {\n-            &v4 @ IpAddr::V4(_) => v4,\n-            IpAddr::V6(v6) => v6.to_canonical(),\n-        }\n-    }\n-}\n-\n-impl Ipv4Addr {\n-    /// Creates a new IPv4 address from four eight-bit octets.\n-    ///\n-    /// The result will represent the IP address `a`.`b`.`c`.`d`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n-        Ipv4Addr { octets: [a, b, c, d] }\n-    }\n-\n-    /// An IPv4 address with the address pointing to localhost: `127.0.0.1`\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::LOCALHOST;\n-    /// assert_eq!(addr, Ipv4Addr::new(127, 0, 0, 1));\n-    /// ```\n-    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n-    pub const LOCALHOST: Self = Ipv4Addr::new(127, 0, 0, 1);\n-\n-    /// An IPv4 address representing an unspecified address: `0.0.0.0`\n-    ///\n-    /// This corresponds to the constant `INADDR_ANY` in other languages.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::UNSPECIFIED;\n-    /// assert_eq!(addr, Ipv4Addr::new(0, 0, 0, 0));\n-    /// ```\n-    #[doc(alias = \"INADDR_ANY\")]\n-    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n-    pub const UNSPECIFIED: Self = Ipv4Addr::new(0, 0, 0, 0);\n-\n-    /// An IPv4 address representing the broadcast address: `255.255.255.255`\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::BROADCAST;\n-    /// assert_eq!(addr, Ipv4Addr::new(255, 255, 255, 255));\n-    /// ```\n-    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n-    pub const BROADCAST: Self = Ipv4Addr::new(255, 255, 255, 255);\n-\n-    /// Returns the four eight-bit integers that make up this address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n-    /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn octets(&self) -> [u8; 4] {\n-        self.octets\n-    }\n-\n-    /// Returns [`true`] for the special 'unspecified' address (`0.0.0.0`).\n-    ///\n-    /// This property is defined in _UNIX Network Programming, Second Edition_,\n-    /// W. Richard Stevens, p. 891; see also [ip7].\n-    ///\n-    /// [ip7]: https://man7.org/linux/man-pages/man7/ip.7.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_unspecified(), true);\n-    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_unspecified(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n-    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unspecified(&self) -> bool {\n-        u32::from_be_bytes(self.octets) == 0\n-    }\n-\n-    /// Returns [`true`] if this is a loopback address (`127.0.0.0/8`).\n-    ///\n-    /// This property is defined by [IETF RFC 1122].\n-    ///\n-    /// [IETF RFC 1122]: https://tools.ietf.org/html/rfc1122\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n-    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_loopback(&self) -> bool {\n-        self.octets()[0] == 127\n-    }\n-\n-    /// Returns [`true`] if this is a private address.\n-    ///\n-    /// The private address ranges are defined in [IETF RFC 1918] and include:\n-    ///\n-    ///  - `10.0.0.0/8`\n-    ///  - `172.16.0.0/12`\n-    ///  - `192.168.0.0/16`\n-    ///\n-    /// [IETF RFC 1918]: https://tools.ietf.org/html/rfc1918\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(10, 0, 0, 1).is_private(), true);\n-    /// assert_eq!(Ipv4Addr::new(10, 10, 10, 10).is_private(), true);\n-    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 10).is_private(), true);\n-    /// assert_eq!(Ipv4Addr::new(172, 29, 45, 14).is_private(), true);\n-    /// assert_eq!(Ipv4Addr::new(172, 32, 0, 2).is_private(), false);\n-    /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n-    /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_private(&self) -> bool {\n-        match self.octets() {\n-            [10, ..] => true,\n-            [172, b, ..] if b >= 16 && b <= 31 => true,\n-            [192, 168, ..] => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Returns [`true`] if the address is link-local (`169.254.0.0/16`).\n-    ///\n-    /// This property is defined by [IETF RFC 3927].\n-    ///\n-    /// [IETF RFC 3927]: https://tools.ietf.org/html/rfc3927\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(169, 254, 0, 0).is_link_local(), true);\n-    /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n-    /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_link_local(&self) -> bool {\n-        matches!(self.octets(), [169, 254, ..])\n-    }\n-\n-    /// Returns [`true`] if the address appears to be globally reachable\n-    /// as specified by the [IANA IPv4 Special-Purpose Address Registry].\n-    /// Whether or not an address is practically reachable will depend on your network configuration.\n-    ///\n-    /// Most IPv4 addresses are globally reachable;\n-    /// unless they are specifically defined as *not* globally reachable.\n-    ///\n-    /// Non-exhaustive list of notable addresses that are not globally reachable:\n-    ///\n-    /// - The [unspecified address] ([`is_unspecified`](Ipv4Addr::is_unspecified))\n-    /// - Addresses reserved for private use ([`is_private`](Ipv4Addr::is_private))\n-    /// - Addresses in the shared address space ([`is_shared`](Ipv4Addr::is_shared))\n-    /// - Loopback addresses ([`is_loopback`](Ipv4Addr::is_loopback))\n-    /// - Link-local addresses ([`is_link_local`](Ipv4Addr::is_link_local))\n-    /// - Addresses reserved for documentation ([`is_documentation`](Ipv4Addr::is_documentation))\n-    /// - Addresses reserved for benchmarking ([`is_benchmarking`](Ipv4Addr::is_benchmarking))\n-    /// - Reserved addresses ([`is_reserved`](Ipv4Addr::is_reserved))\n-    /// - The [broadcast address] ([`is_broadcast`](Ipv4Addr::is_broadcast))\n-    ///\n-    /// For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv4 Special-Purpose Address Registry].\n-    ///\n-    /// [IANA IPv4 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\n-    /// [unspecified address]: Ipv4Addr::UNSPECIFIED\n-    /// [broadcast address]: Ipv4Addr::BROADCAST\n-\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// // Most IPv4 addresses are globally reachable:\n-    /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n-    ///\n-    /// // However some addresses have been assigned a special meaning\n-    /// // that makes them not globally reachable. Some examples are:\n-    ///\n-    /// // The unspecified address (`0.0.0.0`)\n-    /// assert_eq!(Ipv4Addr::UNSPECIFIED.is_global(), false);\n-    ///\n-    /// // Addresses reserved for private use (`10.0.0.0/8`, `172.16.0.0/12`, 192.168.0.0/16)\n-    /// assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n-    /// assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n-    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n-    ///\n-    /// // Addresses in the shared address space (`100.64.0.0/10`)\n-    /// assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n-    ///\n-    /// // The loopback addresses (`127.0.0.0/8`)\n-    /// assert_eq!(Ipv4Addr::LOCALHOST.is_global(), false);\n-    ///\n-    /// // Link-local addresses (`169.254.0.0/16`)\n-    /// assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n-    ///\n-    /// // Addresses reserved for documentation (`192.0.2.0/24`, `198.51.100.0/24`, `203.0.113.0/24`)\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n-    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n-    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n-    ///\n-    /// // Addresses reserved for benchmarking (`198.18.0.0/15`)\n-    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n-    ///\n-    /// // Reserved addresses (`240.0.0.0/4`)\n-    /// assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n-    ///\n-    /// // The broadcast address (`255.255.255.255`)\n-    /// assert_eq!(Ipv4Addr::BROADCAST.is_global(), false);\n-    ///\n-    /// // For a complete overview see the IANA IPv4 Special-Purpose Address Registry.\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_global(&self) -> bool {\n-        !(self.octets()[0] == 0 // \"This network\"\n-            || self.is_private()\n-            || self.is_shared()\n-            || self.is_loopback()\n-            || self.is_link_local()\n-            // addresses reserved for future protocols (`192.0.0.0/24`)\n-            ||(self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0)\n-            || self.is_documentation()\n-            || self.is_benchmarking()\n-            || self.is_reserved()\n-            || self.is_broadcast())\n-    }\n-\n-    /// Returns [`true`] if this address is part of the Shared Address Space defined in\n-    /// [IETF RFC 6598] (`100.64.0.0/10`).\n-    ///\n-    /// [IETF RFC 6598]: https://tools.ietf.org/html/rfc6598\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(100, 64, 0, 0).is_shared(), true);\n-    /// assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n-    /// assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_shared(&self) -> bool {\n-        self.octets()[0] == 100 && (self.octets()[1] & 0b1100_0000 == 0b0100_0000)\n-    }\n-\n-    /// Returns [`true`] if this address part of the `198.18.0.0/15` range, which is reserved for\n-    /// network devices benchmarking. This range is defined in [IETF RFC 2544] as `192.18.0.0`\n-    /// through `198.19.255.255` but [errata 423] corrects it to `198.18.0.0/15`.\n-    ///\n-    /// [IETF RFC 2544]: https://tools.ietf.org/html/rfc2544\n-    /// [errata 423]: https://www.rfc-editor.org/errata/eid423\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(198, 17, 255, 255).is_benchmarking(), false);\n-    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_benchmarking(), true);\n-    /// assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n-    /// assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_benchmarking(&self) -> bool {\n-        self.octets()[0] == 198 && (self.octets()[1] & 0xfe) == 18\n-    }\n-\n-    /// Returns [`true`] if this address is reserved by IANA for future use. [IETF RFC 1112]\n-    /// defines the block of reserved addresses as `240.0.0.0/4`. This range normally includes the\n-    /// broadcast address `255.255.255.255`, but this implementation explicitly excludes it, since\n-    /// it is obviously not reserved for future use.\n-    ///\n-    /// [IETF RFC 1112]: https://tools.ietf.org/html/rfc1112\n-    ///\n-    /// # Warning\n-    ///\n-    /// As IANA assigns new addresses, this method will be\n-    /// updated. This may result in non-reserved addresses being\n-    /// treated as reserved in code that relies on an outdated version\n-    /// of this method.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(240, 0, 0, 0).is_reserved(), true);\n-    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 254).is_reserved(), true);\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(239, 255, 255, 255).is_reserved(), false);\n-    /// // The broadcast address is not considered as reserved for future use by this implementation\n-    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_reserved(&self) -> bool {\n-        self.octets()[0] & 240 == 240 && !self.is_broadcast()\n-    }\n-\n-    /// Returns [`true`] if this is a multicast address (`224.0.0.0/4`).\n-    ///\n-    /// Multicast addresses have a most significant octet between `224` and `239`,\n-    /// and is defined by [IETF RFC 5771].\n-    ///\n-    /// [IETF RFC 5771]: https://tools.ietf.org/html/rfc5771\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(224, 254, 0, 0).is_multicast(), true);\n-    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n-    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_multicast(&self) -> bool {\n-        self.octets()[0] >= 224 && self.octets()[0] <= 239\n-    }\n-\n-    /// Returns [`true`] if this is a broadcast address (`255.255.255.255`).\n-    ///\n-    /// A broadcast address has all octets set to `255` as defined in [IETF RFC 919].\n-    ///\n-    /// [IETF RFC 919]: https://tools.ietf.org/html/rfc919\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n-    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_broadcast(&self) -> bool {\n-        u32::from_be_bytes(self.octets()) == u32::from_be_bytes(Self::BROADCAST.octets())\n-    }\n-\n-    /// Returns [`true`] if this address is in a range designated for documentation.\n-    ///\n-    /// This is defined in [IETF RFC 5737]:\n-    ///\n-    /// - `192.0.2.0/24` (TEST-NET-1)\n-    /// - `198.51.100.0/24` (TEST-NET-2)\n-    /// - `203.0.113.0/24` (TEST-NET-3)\n-    ///\n-    /// [IETF RFC 5737]: https://tools.ietf.org/html/rfc5737\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_documentation(), true);\n-    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_documentation(), true);\n-    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n-    /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_documentation(&self) -> bool {\n-        matches!(self.octets(), [192, 0, 2, _] | [198, 51, 100, _] | [203, 0, 113, _])\n-    }\n-\n-    /// Converts this address to an [IPv4-compatible] [`IPv6` address].\n-    ///\n-    /// `a.b.c.d` becomes `::a.b.c.d`\n-    ///\n-    /// Note that IPv4-compatible addresses have been officially deprecated.\n-    /// If you don't explicitly need an IPv4-compatible address for legacy reasons, consider using `to_ipv6_mapped` instead.\n-    ///\n-    /// [IPv4-compatible]: Ipv6Addr#ipv4-compatible-ipv6-addresses\n-    /// [`IPv6` address]: Ipv6Addr\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(\n-    ///     Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n-    ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x2ff)\n-    /// );\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[inline]\n-    pub const fn to_ipv6_compatible(&self) -> Ipv6Addr {\n-        let [a, b, c, d] = self.octets();\n-        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d] }\n-    }\n-\n-    /// Converts this address to an [IPv4-mapped] [`IPv6` address].\n-    ///\n-    /// `a.b.c.d` becomes `::ffff:a.b.c.d`\n-    ///\n-    /// [IPv4-mapped]: Ipv6Addr#ipv4-mapped-ipv6-addresses\n-    /// [`IPv6` address]: Ipv6Addr\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n-    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x2ff));\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[inline]\n-    pub const fn to_ipv6_mapped(&self) -> Ipv6Addr {\n-        let [a, b, c, d] = self.octets();\n-        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d] }\n-    }\n-}\n-\n-#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-impl fmt::Display for IpAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            IpAddr::V4(ip) => ip.fmt(fmt),\n-            IpAddr::V6(ip) => ip.fmt(fmt),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-impl fmt::Debug for IpAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n-impl From<Ipv4Addr> for IpAddr {\n-    /// Copies this address to a new `IpAddr::V4`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr};\n-    ///\n-    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n-    ///\n-    /// assert_eq!(\n-    ///     IpAddr::V4(addr),\n-    ///     IpAddr::from(addr)\n-    /// )\n-    /// ```\n-    #[inline]\n-    fn from(ipv4: Ipv4Addr) -> IpAddr {\n-        IpAddr::V4(ipv4)\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n-impl From<Ipv6Addr> for IpAddr {\n-    /// Copies this address to a new `IpAddr::V6`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv6Addr};\n-    ///\n-    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n-    ///\n-    /// assert_eq!(\n-    ///     IpAddr::V6(addr),\n-    ///     IpAddr::from(addr)\n-    /// );\n-    /// ```\n-    #[inline]\n-    fn from(ipv6: Ipv6Addr) -> IpAddr {\n-        IpAddr::V6(ipv6)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for Ipv4Addr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let octets = self.octets();\n-\n-        // If there are no alignment requirements, write the IP address directly to `f`.\n-        // Otherwise, write it to a local buffer and then use `f.pad`.\n-        if fmt.precision().is_none() && fmt.width().is_none() {\n-            write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n-        } else {\n-            const LONGEST_IPV4_ADDR: &str = \"255.255.255.255\";\n-\n-            let mut buf = DisplayBuffer::<{ LONGEST_IPV4_ADDR.len() }>::new();\n-            // Buffer is long enough for the longest possible IPv4 address, so this should never fail.\n-            write!(buf, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n-\n-            fmt.pad(buf.as_str())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Ipv4Addr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialEq<Ipv4Addr> for IpAddr {\n-    #[inline]\n-    fn eq(&self, other: &Ipv4Addr) -> bool {\n-        match self {\n-            IpAddr::V4(v4) => v4 == other,\n-            IpAddr::V6(_) => false,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialEq<IpAddr> for Ipv4Addr {\n-    #[inline]\n-    fn eq(&self, other: &IpAddr) -> bool {\n-        match other {\n-            IpAddr::V4(v4) => self == v4,\n-            IpAddr::V6(_) => false,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for Ipv4Addr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialOrd<Ipv4Addr> for IpAddr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n-        match self {\n-            IpAddr::V4(v4) => v4.partial_cmp(other),\n-            IpAddr::V6(_) => Some(Ordering::Greater),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialOrd<IpAddr> for Ipv4Addr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n-        match other {\n-            IpAddr::V4(v4) => self.partial_cmp(v4),\n-            IpAddr::V6(_) => Some(Ordering::Less),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for Ipv4Addr {\n-    #[inline]\n-    fn cmp(&self, other: &Ipv4Addr) -> Ordering {\n-        self.octets.cmp(&other.octets)\n-    }\n-}\n+pub use core::net::Ipv6MulticastScope;\n \n impl IntoInner<c::in_addr> for Ipv4Addr {\n     #[inline]\n     fn into_inner(self) -> c::in_addr {\n         // `s_addr` is stored as BE on all machines and the array is in BE order.\n         // So the native endian conversion method is used so that it's never swapped.\n-        c::in_addr { s_addr: u32::from_ne_bytes(self.octets) }\n+        c::in_addr { s_addr: u32::from_ne_bytes(self.octets()) }\n     }\n }\n impl FromInner<c::in_addr> for Ipv4Addr {\n     fn from_inner(addr: c::in_addr) -> Ipv4Addr {\n-        Ipv4Addr { octets: addr.s_addr.to_ne_bytes() }\n-    }\n-}\n-\n-#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n-impl From<Ipv4Addr> for u32 {\n-    /// Converts an `Ipv4Addr` into a host byte order `u32`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::new(0x12, 0x34, 0x56, 0x78);\n-    /// assert_eq!(0x12345678, u32::from(addr));\n-    /// ```\n-    #[inline]\n-    fn from(ip: Ipv4Addr) -> u32 {\n-        u32::from_be_bytes(ip.octets)\n-    }\n-}\n-\n-#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n-impl From<u32> for Ipv4Addr {\n-    /// Converts a host byte order `u32` into an `Ipv4Addr`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::from(0x12345678);\n-    /// assert_eq!(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78), addr);\n-    /// ```\n-    #[inline]\n-    fn from(ip: u32) -> Ipv4Addr {\n-        Ipv4Addr { octets: ip.to_be_bytes() }\n-    }\n-}\n-\n-#[stable(feature = \"from_slice_v4\", since = \"1.9.0\")]\n-impl From<[u8; 4]> for Ipv4Addr {\n-    /// Creates an `Ipv4Addr` from a four element byte array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::from([13u8, 12u8, 11u8, 10u8]);\n-    /// assert_eq!(Ipv4Addr::new(13, 12, 11, 10), addr);\n-    /// ```\n-    #[inline]\n-    fn from(octets: [u8; 4]) -> Ipv4Addr {\n-        Ipv4Addr { octets }\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n-impl From<[u8; 4]> for IpAddr {\n-    /// Creates an `IpAddr::V4` from a four element byte array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr};\n-    ///\n-    /// let addr = IpAddr::from([13u8, 12u8, 11u8, 10u8]);\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(13, 12, 11, 10)), addr);\n-    /// ```\n-    #[inline]\n-    fn from(octets: [u8; 4]) -> IpAddr {\n-        IpAddr::V4(Ipv4Addr::from(octets))\n-    }\n-}\n-\n-impl Ipv6Addr {\n-    /// Creates a new IPv6 address from eight 16-bit segments.\n-    ///\n-    /// The result will represent the IP address `a:b:c:d:e:f:g:h`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {\n-        let addr16 = [\n-            a.to_be(),\n-            b.to_be(),\n-            c.to_be(),\n-            d.to_be(),\n-            e.to_be(),\n-            f.to_be(),\n-            g.to_be(),\n-            h.to_be(),\n-        ];\n-        Ipv6Addr {\n-            // All elements in `addr16` are big endian.\n-            // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n-            octets: unsafe { transmute::<_, [u8; 16]>(addr16) },\n-        }\n-    }\n-\n-    /// An IPv6 address representing localhost: `::1`.\n-    ///\n-    /// This corresponds to constant `IN6ADDR_LOOPBACK_INIT` or `in6addr_loopback` in other\n-    /// languages.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::LOCALHOST;\n-    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n-    /// ```\n-    #[doc(alias = \"IN6ADDR_LOOPBACK_INIT\")]\n-    #[doc(alias = \"in6addr_loopback\")]\n-    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n-    pub const LOCALHOST: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n-\n-    /// An IPv6 address representing the unspecified address: `::`\n-    ///\n-    /// This corresponds to constant `IN6ADDR_ANY_INIT` or `in6addr_any` in other languages.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::UNSPECIFIED;\n-    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n-    /// ```\n-    #[doc(alias = \"IN6ADDR_ANY_INIT\")]\n-    #[doc(alias = \"in6addr_any\")]\n-    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n-    pub const UNSPECIFIED: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0);\n-\n-    /// Returns the eight 16-bit segments that make up this address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n-    ///            [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn segments(&self) -> [u16; 8] {\n-        // All elements in `self.octets` must be big endian.\n-        // SAFETY: `[u8; 16]` is always safe to transmute to `[u16; 8]`.\n-        let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.octets) };\n-        // We want native endian u16\n-        [\n-            u16::from_be(a),\n-            u16::from_be(b),\n-            u16::from_be(c),\n-            u16::from_be(d),\n-            u16::from_be(e),\n-            u16::from_be(f),\n-            u16::from_be(g),\n-            u16::from_be(h),\n-        ]\n-    }\n-\n-    /// Returns [`true`] for the special 'unspecified' address (`::`).\n-    ///\n-    /// This property is defined in [IETF RFC 4291].\n-    ///\n-    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unspecified(&self) -> bool {\n-        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::UNSPECIFIED.octets())\n-    }\n-\n-    /// Returns [`true`] if this is the [loopback address] (`::1`),\n-    /// as defined in [IETF RFC 4291 section 2.5.3].\n-    ///\n-    /// Contrary to IPv4, in IPv6 there is only one loopback address.\n-    ///\n-    /// [loopback address]: Ipv6Addr::LOCALHOST\n-    /// [IETF RFC 4291 section 2.5.3]: https://tools.ietf.org/html/rfc4291#section-2.5.3\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_loopback(&self) -> bool {\n-        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::LOCALHOST.octets())\n-    }\n-\n-    /// Returns [`true`] if the address appears to be globally reachable\n-    /// as specified by the [IANA IPv6 Special-Purpose Address Registry].\n-    /// Whether or not an address is practically reachable will depend on your network configuration.\n-    ///\n-    /// Most IPv6 addresses are globally reachable;\n-    /// unless they are specifically defined as *not* globally reachable.\n-    ///\n-    /// Non-exhaustive list of notable addresses that are not globally reachable:\n-    /// - The [unspecified address] ([`is_unspecified`](Ipv6Addr::is_unspecified))\n-    /// - The [loopback address] ([`is_loopback`](Ipv6Addr::is_loopback))\n-    /// - IPv4-mapped addresses\n-    /// - Addresses reserved for benchmarking\n-    /// - Addresses reserved for documentation ([`is_documentation`](Ipv6Addr::is_documentation))\n-    /// - Unique local addresses ([`is_unique_local`](Ipv6Addr::is_unique_local))\n-    /// - Unicast addresses with link-local scope ([`is_unicast_link_local`](Ipv6Addr::is_unicast_link_local))\n-    ///\n-    /// For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv6 Special-Purpose Address Registry].\n-    ///\n-    /// Note that an address having global scope is not the same as being globally reachable,\n-    /// and there is no direct relation between the two concepts: There exist addresses with global scope\n-    /// that are not globally reachable (for example unique local addresses),\n-    /// and addresses that are globally reachable without having global scope\n-    /// (multicast addresses with non-global scope).\n-    ///\n-    /// [IANA IPv6 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml\n-    /// [unspecified address]: Ipv6Addr::UNSPECIFIED\n-    /// [loopback address]: Ipv6Addr::LOCALHOST\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// // Most IPv6 addresses are globally reachable:\n-    /// assert_eq!(Ipv6Addr::new(0x26, 0, 0x1c9, 0, 0, 0xafc8, 0x10, 0x1).is_global(), true);\n-    ///\n-    /// // However some addresses have been assigned a special meaning\n-    /// // that makes them not globally reachable. Some examples are:\n-    ///\n-    /// // The unspecified address (`::`)\n-    /// assert_eq!(Ipv6Addr::UNSPECIFIED.is_global(), false);\n-    ///\n-    /// // The loopback address (`::1`)\n-    /// assert_eq!(Ipv6Addr::LOCALHOST.is_global(), false);\n-    ///\n-    /// // IPv4-mapped addresses (`::ffff:0:0/96`)\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), false);\n-    ///\n-    /// // Addresses reserved for benchmarking (`2001:2::/48`)\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 2, 0, 0, 0, 0, 0, 1,).is_global(), false);\n-    ///\n-    /// // Addresses reserved for documentation (`2001:db8::/32`)\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1).is_global(), false);\n-    ///\n-    /// // Unique local addresses (`fc00::/7`)\n-    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n-    ///\n-    /// // Unicast addresses with link-local scope (`fe80::/10`)\n-    /// assert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n-    ///\n-    /// // For a complete overview see the IANA IPv6 Special-Purpose Address Registry.\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_global(&self) -> bool {\n-        !(self.is_unspecified()\n-            || self.is_loopback()\n-            // IPv4-mapped Address (`::ffff:0:0/96`)\n-            || matches!(self.segments(), [0, 0, 0, 0, 0, 0xffff, _, _])\n-            // IPv4-IPv6 Translat. (`64:ff9b:1::/48`)\n-            || matches!(self.segments(), [0x64, 0xff9b, 1, _, _, _, _, _])\n-            // Discard-Only Address Block (`100::/64`)\n-            || matches!(self.segments(), [0x100, 0, 0, 0, _, _, _, _])\n-            // IETF Protocol Assignments (`2001::/23`)\n-            || (matches!(self.segments(), [0x2001, b, _, _, _, _, _, _] if b < 0x200)\n-                && !(\n-                    // Port Control Protocol Anycast (`2001:1::1`)\n-                    u128::from_be_bytes(self.octets()) == 0x2001_0001_0000_0000_0000_0000_0000_0001\n-                    // Traversal Using Relays around NAT Anycast (`2001:1::2`)\n-                    || u128::from_be_bytes(self.octets()) == 0x2001_0001_0000_0000_0000_0000_0000_0002\n-                    // AMT (`2001:3::/32`)\n-                    || matches!(self.segments(), [0x2001, 3, _, _, _, _, _, _])\n-                    // AS112-v6 (`2001:4:112::/48`)\n-                    || matches!(self.segments(), [0x2001, 4, 0x112, _, _, _, _, _])\n-                    // ORCHIDv2 (`2001:20::/28`)\n-                    || matches!(self.segments(), [0x2001, b, _, _, _, _, _, _] if b >= 0x20 && b <= 0x2F)\n-                ))\n-            || self.is_documentation()\n-            || self.is_unique_local()\n-            || self.is_unicast_link_local())\n-    }\n-\n-    /// Returns [`true`] if this is a unique local address (`fc00::/7`).\n-    ///\n-    /// This property is defined in [IETF RFC 4193].\n-    ///\n-    /// [IETF RFC 4193]: https://tools.ietf.org/html/rfc4193\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(), false);\n-    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unique_local(&self) -> bool {\n-        (self.segments()[0] & 0xfe00) == 0xfc00\n-    }\n-\n-    /// Returns [`true`] if this is a unicast address, as defined by [IETF RFC 4291].\n-    /// Any address that is not a [multicast address] (`ff00::/8`) is unicast.\n-    ///\n-    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n-    /// [multicast address]: Ipv6Addr::is_multicast\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// // The unspecified and loopback addresses are unicast.\n-    /// assert_eq!(Ipv6Addr::UNSPECIFIED.is_unicast(), true);\n-    /// assert_eq!(Ipv6Addr::LOCALHOST.is_unicast(), true);\n-    ///\n-    /// // Any address that is not a multicast address (`ff00::/8`) is unicast.\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast(), true);\n-    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_unicast(), false);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unicast(&self) -> bool {\n-        !self.is_multicast()\n-    }\n-\n-    /// Returns `true` if the address is a unicast address with link-local scope,\n-    /// as defined in [RFC 4291].\n-    ///\n-    /// A unicast address has link-local scope if it has the prefix `fe80::/10`, as per [RFC 4291 section 2.4].\n-    /// Note that this encompasses more addresses than those defined in [RFC 4291 section 2.5.6],\n-    /// which describes \"Link-Local IPv6 Unicast Addresses\" as having the following stricter format:\n-    ///\n-    /// ```text\n-    /// | 10 bits  |         54 bits         |          64 bits           |\n-    /// +----------+-------------------------+----------------------------+\n-    /// |1111111010|           0             |       interface ID         |\n-    /// +----------+-------------------------+----------------------------+\n-    /// ```\n-    /// So while currently the only addresses with link-local scope an application will encounter are all in `fe80::/64`,\n-    /// this might change in the future with the publication of new standards. More addresses in `fe80::/10` could be allocated,\n-    /// and those addresses will have link-local scope.\n-    ///\n-    /// Also note that while [RFC 4291 section 2.5.3] mentions about the [loopback address] (`::1`) that \"it is treated as having Link-Local scope\",\n-    /// this does not mean that the loopback address actually has link-local scope and this method will return `false` on it.\n-    ///\n-    /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n-    /// [RFC 4291 section 2.4]: https://tools.ietf.org/html/rfc4291#section-2.4\n-    /// [RFC 4291 section 2.5.3]: https://tools.ietf.org/html/rfc4291#section-2.5.3\n-    /// [RFC 4291 section 2.5.6]: https://tools.ietf.org/html/rfc4291#section-2.5.6\n-    /// [loopback address]: Ipv6Addr::LOCALHOST\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// // The loopback address (`::1`) does not actually have link-local scope.\n-    /// assert_eq!(Ipv6Addr::LOCALHOST.is_unicast_link_local(), false);\n-    ///\n-    /// // Only addresses in `fe80::/10` have link-local scope.\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), false);\n-    /// assert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n-    ///\n-    /// // Addresses outside the stricter `fe80::/64` also have link-local scope.\n-    /// assert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0).is_unicast_link_local(), true);\n-    /// assert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unicast_link_local(&self) -> bool {\n-        (self.segments()[0] & 0xffc0) == 0xfe80\n-    }\n-\n-    /// Returns [`true`] if this is an address reserved for documentation\n-    /// (`2001:db8::/32`).\n-    ///\n-    /// This property is defined in [IETF RFC 3849].\n-    ///\n-    /// [IETF RFC 3849]: https://tools.ietf.org/html/rfc3849\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(), false);\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_documentation(&self) -> bool {\n-        (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n-    }\n-\n-    /// Returns [`true`] if this is an address reserved for benchmarking (`2001:2::/48`).\n-    ///\n-    /// This property is defined in [IETF RFC 5180], where it is mistakenly specified as covering the range `2001:0200::/48`.\n-    /// This is corrected in [IETF RFC Errata 1752] to `2001:0002::/48`.\n-    ///\n-    /// [IETF RFC 5180]: https://tools.ietf.org/html/rfc5180\n-    /// [IETF RFC Errata 1752]: https://www.rfc-editor.org/errata_search.php?eid=1752\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc613, 0x0).is_benchmarking(), false);\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0x2, 0, 0, 0, 0, 0, 0).is_benchmarking(), true);\n-    /// ```\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_benchmarking(&self) -> bool {\n-        (self.segments()[0] == 0x2001) && (self.segments()[1] == 0x2) && (self.segments()[2] == 0)\n-    }\n-\n-    /// Returns [`true`] if the address is a globally routable unicast address.\n-    ///\n-    /// The following return false:\n-    ///\n-    /// - the loopback address\n-    /// - the link-local addresses\n-    /// - unique local addresses\n-    /// - the unspecified address\n-    /// - the address range reserved for documentation\n-    ///\n-    /// This method returns [`true`] for site-local addresses as per [RFC 4291 section 2.5.7]\n-    ///\n-    /// ```no_rust\n-    /// The special behavior of [the site-local unicast] prefix defined in [RFC3513] must no longer\n-    /// be supported in new implementations (i.e., new implementations must treat this prefix as\n-    /// Global Unicast).\n-    /// ```\n-    ///\n-    /// [RFC 4291 section 2.5.7]: https://tools.ietf.org/html/rfc4291#section-2.5.7\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unicast_global(&self) -> bool {\n-        self.is_unicast()\n-            && !self.is_loopback()\n-            && !self.is_unicast_link_local()\n-            && !self.is_unique_local()\n-            && !self.is_unspecified()\n-            && !self.is_documentation()\n-            && !self.is_benchmarking()\n-    }\n-\n-    /// Returns the address's multicast scope if the address is multicast.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::{Ipv6Addr, Ipv6MulticastScope};\n-    ///\n-    /// assert_eq!(\n-    ///     Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n-    ///     Some(Ipv6MulticastScope::Global)\n-    /// );\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n-        if self.is_multicast() {\n-            match self.segments()[0] & 0x000f {\n-                1 => Some(Ipv6MulticastScope::InterfaceLocal),\n-                2 => Some(Ipv6MulticastScope::LinkLocal),\n-                3 => Some(Ipv6MulticastScope::RealmLocal),\n-                4 => Some(Ipv6MulticastScope::AdminLocal),\n-                5 => Some(Ipv6MulticastScope::SiteLocal),\n-                8 => Some(Ipv6MulticastScope::OrganizationLocal),\n-                14 => Some(Ipv6MulticastScope::Global),\n-                _ => None,\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns [`true`] if this is a multicast address (`ff00::/8`).\n-    ///\n-    /// This property is defined by [IETF RFC 4291].\n-    ///\n-    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_multicast(&self) -> bool {\n-        (self.segments()[0] & 0xff00) == 0xff00\n-    }\n-\n-    /// Converts this address to an [`IPv4` address] if it's an [IPv4-mapped] address,\n-    /// as defined in [IETF RFC 4291 section 2.5.5.2], otherwise returns [`None`].\n-    ///\n-    /// `::ffff:a.b.c.d` becomes `a.b.c.d`.\n-    /// All addresses *not* starting with `::ffff` will return `None`.\n-    ///\n-    /// [`IPv4` address]: Ipv4Addr\n-    /// [IPv4-mapped]: Ipv6Addr\n-    /// [IETF RFC 4291 section 2.5.5.2]: https://tools.ietf.org/html/rfc4291#section-2.5.5.2\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4_mapped(), None);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4_mapped(),\n-    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4_mapped(), None);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[stable(feature = \"ipv6_to_ipv4_mapped\", since = \"1.63.0\")]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[inline]\n-    pub const fn to_ipv4_mapped(&self) -> Option<Ipv4Addr> {\n-        match self.octets() {\n-            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, a, b, c, d] => {\n-                Some(Ipv4Addr::new(a, b, c, d))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    /// Converts this address to an [`IPv4` address] if it is either\n-    /// an [IPv4-compatible] address as defined in [IETF RFC 4291 section 2.5.5.1],\n-    /// or an [IPv4-mapped] address as defined in [IETF RFC 4291 section 2.5.5.2],\n-    /// otherwise returns [`None`].\n-    ///\n-    /// Note that this will return an [`IPv4` address] for the IPv6 loopback address `::1`. Use\n-    /// [`Ipv6Addr::to_ipv4_mapped`] to avoid this.\n-    ///\n-    /// `::a.b.c.d` and `::ffff:a.b.c.d` become `a.b.c.d`. `::1` becomes `0.0.0.1`.\n-    /// All addresses *not* starting with either all zeroes or `::ffff` will return `None`.\n-    ///\n-    /// [`IPv4` address]: Ipv4Addr\n-    /// [IPv4-compatible]: Ipv6Addr#ipv4-compatible-ipv6-addresses\n-    /// [IPv4-mapped]: Ipv6Addr#ipv4-mapped-ipv6-addresses\n-    /// [IETF RFC 4291 section 2.5.5.1]: https://tools.ietf.org/html/rfc4291#section-2.5.5.1\n-    /// [IETF RFC 4291 section 2.5.5.2]: https://tools.ietf.org/html/rfc4291#section-2.5.5.2\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4(), None);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4(),\n-    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n-    ///            Some(Ipv4Addr::new(0, 0, 0, 1)));\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[inline]\n-    pub const fn to_ipv4(&self) -> Option<Ipv4Addr> {\n-        if let [0, 0, 0, 0, 0, 0 | 0xffff, ab, cd] = self.segments() {\n-            let [a, b] = ab.to_be_bytes();\n-            let [c, d] = cd.to_be_bytes();\n-            Some(Ipv4Addr::new(a, b, c, d))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped addresses, otherwise it\n-    /// returns self wrapped in an `IpAddr::V6`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1).is_loopback(), false);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1).to_canonical().is_loopback(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[inline]\n-    pub const fn to_canonical(&self) -> IpAddr {\n-        if let Some(mapped) = self.to_ipv4_mapped() {\n-            return IpAddr::V4(mapped);\n-        }\n-        IpAddr::V6(*self)\n-    }\n-\n-    /// Returns the sixteen eight-bit integers the IPv6 address consists of.\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).octets(),\n-    ///            [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n-    #[stable(feature = \"ipv6_to_octets\", since = \"1.12.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn octets(&self) -> [u8; 16] {\n-        self.octets\n-    }\n-}\n-\n-/// Write an Ipv6Addr, conforming to the canonical style described by\n-/// [RFC 5952](https://tools.ietf.org/html/rfc5952).\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for Ipv6Addr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // If there are no alignment requirements, write the IP address directly to `f`.\n-        // Otherwise, write it to a local buffer and then use `f.pad`.\n-        if f.precision().is_none() && f.width().is_none() {\n-            let segments = self.segments();\n-\n-            // Special case for :: and ::1; otherwise they get written with the\n-            // IPv4 formatter\n-            if self.is_unspecified() {\n-                f.write_str(\"::\")\n-            } else if self.is_loopback() {\n-                f.write_str(\"::1\")\n-            } else if let Some(ipv4) = self.to_ipv4() {\n-                match segments[5] {\n-                    // IPv4 Compatible address\n-                    0 => write!(f, \"::{}\", ipv4),\n-                    // IPv4 Mapped address\n-                    0xffff => write!(f, \"::ffff:{}\", ipv4),\n-                    _ => unreachable!(),\n-                }\n-            } else {\n-                #[derive(Copy, Clone, Default)]\n-                struct Span {\n-                    start: usize,\n-                    len: usize,\n-                }\n-\n-                // Find the inner 0 span\n-                let zeroes = {\n-                    let mut longest = Span::default();\n-                    let mut current = Span::default();\n-\n-                    for (i, &segment) in segments.iter().enumerate() {\n-                        if segment == 0 {\n-                            if current.len == 0 {\n-                                current.start = i;\n-                            }\n-\n-                            current.len += 1;\n-\n-                            if current.len > longest.len {\n-                                longest = current;\n-                            }\n-                        } else {\n-                            current = Span::default();\n-                        }\n-                    }\n-\n-                    longest\n-                };\n-\n-                /// Write a colon-separated part of the address\n-                #[inline]\n-                fn fmt_subslice(f: &mut fmt::Formatter<'_>, chunk: &[u16]) -> fmt::Result {\n-                    if let Some((first, tail)) = chunk.split_first() {\n-                        write!(f, \"{:x}\", first)?;\n-                        for segment in tail {\n-                            f.write_char(':')?;\n-                            write!(f, \"{:x}\", segment)?;\n-                        }\n-                    }\n-                    Ok(())\n-                }\n-\n-                if zeroes.len > 1 {\n-                    fmt_subslice(f, &segments[..zeroes.start])?;\n-                    f.write_str(\"::\")?;\n-                    fmt_subslice(f, &segments[zeroes.start + zeroes.len..])\n-                } else {\n-                    fmt_subslice(f, &segments)\n-                }\n-            }\n-        } else {\n-            const LONGEST_IPV6_ADDR: &str = \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\";\n-\n-            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_ADDR.len() }>::new();\n-            // Buffer is long enough for the longest possible IPv6 address, so this should never fail.\n-            write!(buf, \"{}\", self).unwrap();\n-\n-            f.pad(buf.as_str())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Ipv6Addr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialEq<IpAddr> for Ipv6Addr {\n-    #[inline]\n-    fn eq(&self, other: &IpAddr) -> bool {\n-        match other {\n-            IpAddr::V4(_) => false,\n-            IpAddr::V6(v6) => self == v6,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialEq<Ipv6Addr> for IpAddr {\n-    #[inline]\n-    fn eq(&self, other: &Ipv6Addr) -> bool {\n-        match self {\n-            IpAddr::V4(_) => false,\n-            IpAddr::V6(v6) => v6 == other,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for Ipv6Addr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialOrd<Ipv6Addr> for IpAddr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n-        match self {\n-            IpAddr::V4(_) => Some(Ordering::Less),\n-            IpAddr::V6(v6) => v6.partial_cmp(other),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialOrd<IpAddr> for Ipv6Addr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n-        match other {\n-            IpAddr::V4(_) => Some(Ordering::Greater),\n-            IpAddr::V6(v6) => self.partial_cmp(v6),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for Ipv6Addr {\n-    #[inline]\n-    fn cmp(&self, other: &Ipv6Addr) -> Ordering {\n-        self.segments().cmp(&other.segments())\n+        Ipv4Addr::from(addr.s_addr.to_ne_bytes())\n     }\n }\n \n impl IntoInner<c::in6_addr> for Ipv6Addr {\n     fn into_inner(self) -> c::in6_addr {\n-        c::in6_addr { s6_addr: self.octets }\n+        c::in6_addr { s6_addr: self.octets() }\n     }\n }\n impl FromInner<c::in6_addr> for Ipv6Addr {\n     #[inline]\n     fn from_inner(addr: c::in6_addr) -> Ipv6Addr {\n-        Ipv6Addr { octets: addr.s6_addr }\n-    }\n-}\n-\n-#[stable(feature = \"i128\", since = \"1.26.0\")]\n-impl From<Ipv6Addr> for u128 {\n-    /// Convert an `Ipv6Addr` into a host byte order `u128`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::new(\n-    ///     0x1020, 0x3040, 0x5060, 0x7080,\n-    ///     0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n-    /// );\n-    /// assert_eq!(0x102030405060708090A0B0C0D0E0F00D_u128, u128::from(addr));\n-    /// ```\n-    #[inline]\n-    fn from(ip: Ipv6Addr) -> u128 {\n-        u128::from_be_bytes(ip.octets)\n-    }\n-}\n-#[stable(feature = \"i128\", since = \"1.26.0\")]\n-impl From<u128> for Ipv6Addr {\n-    /// Convert a host byte order `u128` into an `Ipv6Addr`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::from(0x102030405060708090A0B0C0D0E0F00D_u128);\n-    /// assert_eq!(\n-    ///     Ipv6Addr::new(\n-    ///         0x1020, 0x3040, 0x5060, 0x7080,\n-    ///         0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n-    ///     ),\n-    ///     addr);\n-    /// ```\n-    #[inline]\n-    fn from(ip: u128) -> Ipv6Addr {\n-        Ipv6Addr::from(ip.to_be_bytes())\n-    }\n-}\n-\n-#[stable(feature = \"ipv6_from_octets\", since = \"1.9.0\")]\n-impl From<[u8; 16]> for Ipv6Addr {\n-    /// Creates an `Ipv6Addr` from a sixteen element byte array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::from([\n-    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n-    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n-    /// ]);\n-    /// assert_eq!(\n-    ///     Ipv6Addr::new(\n-    ///         0x1918, 0x1716,\n-    ///         0x1514, 0x1312,\n-    ///         0x1110, 0x0f0e,\n-    ///         0x0d0c, 0x0b0a\n-    ///     ),\n-    ///     addr\n-    /// );\n-    /// ```\n-    #[inline]\n-    fn from(octets: [u8; 16]) -> Ipv6Addr {\n-        Ipv6Addr { octets }\n-    }\n-}\n-\n-#[stable(feature = \"ipv6_from_segments\", since = \"1.16.0\")]\n-impl From<[u16; 8]> for Ipv6Addr {\n-    /// Creates an `Ipv6Addr` from an eight element 16-bit array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::from([\n-    ///     525u16, 524u16, 523u16, 522u16,\n-    ///     521u16, 520u16, 519u16, 518u16,\n-    /// ]);\n-    /// assert_eq!(\n-    ///     Ipv6Addr::new(\n-    ///         0x20d, 0x20c,\n-    ///         0x20b, 0x20a,\n-    ///         0x209, 0x208,\n-    ///         0x207, 0x206\n-    ///     ),\n-    ///     addr\n-    /// );\n-    /// ```\n-    #[inline]\n-    fn from(segments: [u16; 8]) -> Ipv6Addr {\n-        let [a, b, c, d, e, f, g, h] = segments;\n-        Ipv6Addr::new(a, b, c, d, e, f, g, h)\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n-impl From<[u8; 16]> for IpAddr {\n-    /// Creates an `IpAddr::V6` from a sixteen element byte array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv6Addr};\n-    ///\n-    /// let addr = IpAddr::from([\n-    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n-    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n-    /// ]);\n-    /// assert_eq!(\n-    ///     IpAddr::V6(Ipv6Addr::new(\n-    ///         0x1918, 0x1716,\n-    ///         0x1514, 0x1312,\n-    ///         0x1110, 0x0f0e,\n-    ///         0x0d0c, 0x0b0a\n-    ///     )),\n-    ///     addr\n-    /// );\n-    /// ```\n-    #[inline]\n-    fn from(octets: [u8; 16]) -> IpAddr {\n-        IpAddr::V6(Ipv6Addr::from(octets))\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n-impl From<[u16; 8]> for IpAddr {\n-    /// Creates an `IpAddr::V6` from an eight element 16-bit array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv6Addr};\n-    ///\n-    /// let addr = IpAddr::from([\n-    ///     525u16, 524u16, 523u16, 522u16,\n-    ///     521u16, 520u16, 519u16, 518u16,\n-    /// ]);\n-    /// assert_eq!(\n-    ///     IpAddr::V6(Ipv6Addr::new(\n-    ///         0x20d, 0x20c,\n-    ///         0x20b, 0x20a,\n-    ///         0x209, 0x208,\n-    ///         0x207, 0x206\n-    ///     )),\n-    ///     addr\n-    /// );\n-    /// ```\n-    #[inline]\n-    fn from(segments: [u16; 8]) -> IpAddr {\n-        IpAddr::V6(Ipv6Addr::from(segments))\n+        Ipv6Addr::from(addr.s6_addr)\n     }\n }"}, {"sha": "ab99c0c2fcc160cf57817ee3c93c023ff94e4d55", "filename": "library/std/src/net/ip_addr/tests.rs", "status": "modified", "additions": 2, "deletions": 1033, "changes": 1035, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -1,1039 +1,8 @@\n-use crate::net::test::{sa4, sa6, tsa};\n-use crate::net::*;\n-use crate::str::FromStr;\n-\n-#[test]\n-fn test_from_str_ipv4() {\n-    assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n-    assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n-    assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n-\n-    // out of range\n-    let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n-    assert_eq!(None, none);\n-    // too short\n-    let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n-    assert_eq!(None, none);\n-    // too long\n-    let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n-    assert_eq!(None, none);\n-    // no number between dots\n-    let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n-    assert_eq!(None, none);\n-    // octal\n-    let none: Option<Ipv4Addr> = \"255.0.0.01\".parse().ok();\n-    assert_eq!(None, none);\n-    // octal zero\n-    let none: Option<Ipv4Addr> = \"255.0.0.00\".parse().ok();\n-    assert_eq!(None, none);\n-    let none: Option<Ipv4Addr> = \"255.0.00.0\".parse().ok();\n-    assert_eq!(None, none);\n-}\n-\n-#[test]\n-fn test_from_str_ipv6() {\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n-\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n-\n-    assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)), \"2a02:6b8::11:11\".parse());\n-\n-    // too long group\n-    let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n-    assert_eq!(None, none);\n-    // too short\n-    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n-    assert_eq!(None, none);\n-    // too long\n-    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n-    assert_eq!(None, none);\n-    // triple colon\n-    let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n-    assert_eq!(None, none);\n-    // two double colons\n-    let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n-    assert_eq!(None, none);\n-    // `::` indicating zero groups of zeros\n-    let none: Option<Ipv6Addr> = \"1:2:3:4::5:6:7:8\".parse().ok();\n-    assert_eq!(None, none);\n-}\n-\n-#[test]\n-fn test_from_str_ipv4_in_ipv6() {\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)), \"::192.0.2.33\".parse());\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)), \"::FFFF:192.0.2.33\".parse());\n-    assert_eq!(\n-        Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n-        \"64:ff9b::192.0.2.33\".parse()\n-    );\n-    assert_eq!(\n-        Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n-        \"2001:db8:122:c000:2:2100:192.0.2.33\".parse()\n-    );\n-\n-    // colon after v4\n-    let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n-    assert_eq!(None, none);\n-    // not enough groups\n-    let none: Option<Ipv6Addr> = \"1:2:3:4:5:127.0.0.1\".parse().ok();\n-    assert_eq!(None, none);\n-    // too many groups\n-    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:127.0.0.1\".parse().ok();\n-    assert_eq!(None, none);\n-}\n-\n-#[test]\n-fn test_from_str_socket_addr() {\n-    assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n-    assert_eq!(Ok(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n-    assert_eq!(\n-        Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n-        \"[2a02:6b8:0:1::1]:53\".parse()\n-    );\n-    assert_eq!(\n-        Ok(SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53, 0, 0)),\n-        \"[2a02:6b8:0:1::1]:53\".parse()\n-    );\n-    assert_eq!(Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)), \"[::127.0.0.1]:22\".parse());\n-    assert_eq!(\n-        Ok(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22, 0, 0)),\n-        \"[::127.0.0.1]:22\".parse()\n-    );\n-\n-    // without port\n-    let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n-    assert_eq!(None, none);\n-    // without port\n-    let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n-    assert_eq!(None, none);\n-    // wrong brackets around v4\n-    let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n-    assert_eq!(None, none);\n-    // port out of range\n-    let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n-    assert_eq!(None, none);\n-}\n-\n-#[test]\n-fn ipv4_addr_to_string() {\n-    assert_eq!(Ipv4Addr::new(127, 0, 0, 1).to_string(), \"127.0.0.1\");\n-    // Short address\n-    assert_eq!(Ipv4Addr::new(1, 1, 1, 1).to_string(), \"1.1.1.1\");\n-    // Long address\n-    assert_eq!(Ipv4Addr::new(127, 127, 127, 127).to_string(), \"127.127.127.127\");\n-\n-    // Test padding\n-    assert_eq!(format!(\"{:16}\", Ipv4Addr::new(1, 1, 1, 1)), \"1.1.1.1         \");\n-    assert_eq!(format!(\"{:>16}\", Ipv4Addr::new(1, 1, 1, 1)), \"         1.1.1.1\");\n-}\n-\n-#[test]\n-fn ipv6_addr_to_string() {\n-    // ipv4-mapped address\n-    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-    assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n-\n-    // ipv4-compatible address\n-    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n-    assert_eq!(a1.to_string(), \"::192.0.2.128\");\n-\n-    // v6 address with no zero segments\n-    assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(), \"8:9:a:b:c:d:e:f\");\n-\n-    // longest possible IPv6 length\n-    assert_eq!(\n-        Ipv6Addr::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888).to_string(),\n-        \"1111:2222:3333:4444:5555:6666:7777:8888\"\n-    );\n-    // padding\n-    assert_eq!(format!(\"{:20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"1:2:3:4:5:6:7:8     \");\n-    assert_eq!(format!(\"{:>20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"     1:2:3:4:5:6:7:8\");\n-\n-    // reduce a single run of zeros\n-    assert_eq!(\n-        \"ae::ffff:102:304\",\n-        Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string()\n-    );\n-\n-    // don't reduce just a single zero segment\n-    assert_eq!(\"1:2:3:4:5:6:0:8\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n-\n-    // 'any' address\n-    assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n-\n-    // loopback address\n-    assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n-\n-    // ends in zeros\n-    assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n-\n-    // two runs of zeros, second one is longer\n-    assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n-\n-    // two runs of zeros, equal length\n-    assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n-\n-    // don't prefix `0x` to each segment in `dbg!`.\n-    assert_eq!(\"1::4:5:0:0:8\", &format!(\"{:#?}\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8)));\n-}\n-\n-#[test]\n-fn ipv4_to_ipv6() {\n-    assert_eq!(\n-        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n-        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped()\n-    );\n-    assert_eq!(\n-        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n-        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible()\n-    );\n-}\n-\n-#[test]\n-fn ipv6_to_ipv4_mapped() {\n-    assert_eq!(\n-        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4_mapped(),\n-        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n-    );\n-    assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4_mapped(), None);\n-}\n-\n-#[test]\n-fn ipv6_to_ipv4() {\n-    assert_eq!(\n-        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n-        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n-    );\n-    assert_eq!(\n-        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n-        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n-    );\n-    assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(), None);\n-}\n-\n-#[test]\n-fn ip_properties() {\n-    macro_rules! ip {\n-        ($s:expr) => {\n-            IpAddr::from_str($s).unwrap()\n-        };\n-    }\n-\n-    macro_rules! check {\n-        ($s:expr) => {\n-            check!($s, 0);\n-        };\n-\n-        ($s:expr, $mask:expr) => {{\n-            let unspec: u8 = 1 << 0;\n-            let loopback: u8 = 1 << 1;\n-            let global: u8 = 1 << 2;\n-            let multicast: u8 = 1 << 3;\n-            let doc: u8 = 1 << 4;\n-            let benchmarking: u8 = 1 << 5;\n-\n-            if ($mask & unspec) == unspec {\n-                assert!(ip!($s).is_unspecified());\n-            } else {\n-                assert!(!ip!($s).is_unspecified());\n-            }\n-\n-            if ($mask & loopback) == loopback {\n-                assert!(ip!($s).is_loopback());\n-            } else {\n-                assert!(!ip!($s).is_loopback());\n-            }\n-\n-            if ($mask & global) == global {\n-                assert!(ip!($s).is_global());\n-            } else {\n-                assert!(!ip!($s).is_global());\n-            }\n-\n-            if ($mask & multicast) == multicast {\n-                assert!(ip!($s).is_multicast());\n-            } else {\n-                assert!(!ip!($s).is_multicast());\n-            }\n-\n-            if ($mask & doc) == doc {\n-                assert!(ip!($s).is_documentation());\n-            } else {\n-                assert!(!ip!($s).is_documentation());\n-            }\n-\n-            if ($mask & benchmarking) == benchmarking {\n-                assert!(ip!($s).is_benchmarking());\n-            } else {\n-                assert!(!ip!($s).is_benchmarking());\n-            }\n-        }};\n-    }\n-\n-    let unspec: u8 = 1 << 0;\n-    let loopback: u8 = 1 << 1;\n-    let global: u8 = 1 << 2;\n-    let multicast: u8 = 1 << 3;\n-    let doc: u8 = 1 << 4;\n-    let benchmarking: u8 = 1 << 5;\n-\n-    check!(\"0.0.0.0\", unspec);\n-    check!(\"0.0.0.1\");\n-    check!(\"0.1.0.0\");\n-    check!(\"10.9.8.7\");\n-    check!(\"127.1.2.3\", loopback);\n-    check!(\"172.31.254.253\");\n-    check!(\"169.254.253.242\");\n-    check!(\"192.0.2.183\", doc);\n-    check!(\"192.1.2.183\", global);\n-    check!(\"192.168.254.253\");\n-    check!(\"198.51.100.0\", doc);\n-    check!(\"203.0.113.0\", doc);\n-    check!(\"203.2.113.0\", global);\n-    check!(\"224.0.0.0\", global | multicast);\n-    check!(\"239.255.255.255\", global | multicast);\n-    check!(\"255.255.255.255\");\n-    // make sure benchmarking addresses are not global\n-    check!(\"198.18.0.0\", benchmarking);\n-    check!(\"198.18.54.2\", benchmarking);\n-    check!(\"198.19.255.255\", benchmarking);\n-    // make sure addresses reserved for protocol assignment are not global\n-    check!(\"192.0.0.0\");\n-    check!(\"192.0.0.255\");\n-    check!(\"192.0.0.100\");\n-    // make sure reserved addresses are not global\n-    check!(\"240.0.0.0\");\n-    check!(\"251.54.1.76\");\n-    check!(\"254.255.255.255\");\n-    // make sure shared addresses are not global\n-    check!(\"100.64.0.0\");\n-    check!(\"100.127.255.255\");\n-    check!(\"100.100.100.0\");\n-\n-    check!(\"::\", unspec);\n-    check!(\"::1\", loopback);\n-    check!(\"::0.0.0.2\", global);\n-    check!(\"1::\", global);\n-    check!(\"fc00::\");\n-    check!(\"fdff:ffff::\");\n-    check!(\"fe80:ffff::\");\n-    check!(\"febf:ffff::\");\n-    check!(\"fec0::\", global);\n-    check!(\"ff01::\", global | multicast);\n-    check!(\"ff02::\", global | multicast);\n-    check!(\"ff03::\", global | multicast);\n-    check!(\"ff04::\", global | multicast);\n-    check!(\"ff05::\", global | multicast);\n-    check!(\"ff08::\", global | multicast);\n-    check!(\"ff0e::\", global | multicast);\n-    check!(\"2001:db8:85a3::8a2e:370:7334\", doc);\n-    check!(\"2001:2::ac32:23ff:21\", benchmarking);\n-    check!(\"102:304:506:708:90a:b0c:d0e:f10\", global);\n-}\n-\n-#[test]\n-fn ipv4_properties() {\n-    macro_rules! ip {\n-        ($s:expr) => {\n-            Ipv4Addr::from_str($s).unwrap()\n-        };\n-    }\n-\n-    macro_rules! check {\n-        ($s:expr) => {\n-            check!($s, 0);\n-        };\n-\n-        ($s:expr, $mask:expr) => {{\n-            let unspec: u16 = 1 << 0;\n-            let loopback: u16 = 1 << 1;\n-            let private: u16 = 1 << 2;\n-            let link_local: u16 = 1 << 3;\n-            let global: u16 = 1 << 4;\n-            let multicast: u16 = 1 << 5;\n-            let broadcast: u16 = 1 << 6;\n-            let documentation: u16 = 1 << 7;\n-            let benchmarking: u16 = 1 << 8;\n-            let reserved: u16 = 1 << 10;\n-            let shared: u16 = 1 << 11;\n-\n-            if ($mask & unspec) == unspec {\n-                assert!(ip!($s).is_unspecified());\n-            } else {\n-                assert!(!ip!($s).is_unspecified());\n-            }\n-\n-            if ($mask & loopback) == loopback {\n-                assert!(ip!($s).is_loopback());\n-            } else {\n-                assert!(!ip!($s).is_loopback());\n-            }\n-\n-            if ($mask & private) == private {\n-                assert!(ip!($s).is_private());\n-            } else {\n-                assert!(!ip!($s).is_private());\n-            }\n-\n-            if ($mask & link_local) == link_local {\n-                assert!(ip!($s).is_link_local());\n-            } else {\n-                assert!(!ip!($s).is_link_local());\n-            }\n-\n-            if ($mask & global) == global {\n-                assert!(ip!($s).is_global());\n-            } else {\n-                assert!(!ip!($s).is_global());\n-            }\n-\n-            if ($mask & multicast) == multicast {\n-                assert!(ip!($s).is_multicast());\n-            } else {\n-                assert!(!ip!($s).is_multicast());\n-            }\n-\n-            if ($mask & broadcast) == broadcast {\n-                assert!(ip!($s).is_broadcast());\n-            } else {\n-                assert!(!ip!($s).is_broadcast());\n-            }\n-\n-            if ($mask & documentation) == documentation {\n-                assert!(ip!($s).is_documentation());\n-            } else {\n-                assert!(!ip!($s).is_documentation());\n-            }\n-\n-            if ($mask & benchmarking) == benchmarking {\n-                assert!(ip!($s).is_benchmarking());\n-            } else {\n-                assert!(!ip!($s).is_benchmarking());\n-            }\n-\n-            if ($mask & reserved) == reserved {\n-                assert!(ip!($s).is_reserved());\n-            } else {\n-                assert!(!ip!($s).is_reserved());\n-            }\n-\n-            if ($mask & shared) == shared {\n-                assert!(ip!($s).is_shared());\n-            } else {\n-                assert!(!ip!($s).is_shared());\n-            }\n-        }};\n-    }\n-\n-    let unspec: u16 = 1 << 0;\n-    let loopback: u16 = 1 << 1;\n-    let private: u16 = 1 << 2;\n-    let link_local: u16 = 1 << 3;\n-    let global: u16 = 1 << 4;\n-    let multicast: u16 = 1 << 5;\n-    let broadcast: u16 = 1 << 6;\n-    let documentation: u16 = 1 << 7;\n-    let benchmarking: u16 = 1 << 8;\n-    let reserved: u16 = 1 << 10;\n-    let shared: u16 = 1 << 11;\n-\n-    check!(\"0.0.0.0\", unspec);\n-    check!(\"0.0.0.1\");\n-    check!(\"0.1.0.0\");\n-    check!(\"10.9.8.7\", private);\n-    check!(\"127.1.2.3\", loopback);\n-    check!(\"172.31.254.253\", private);\n-    check!(\"169.254.253.242\", link_local);\n-    check!(\"192.0.2.183\", documentation);\n-    check!(\"192.1.2.183\", global);\n-    check!(\"192.168.254.253\", private);\n-    check!(\"198.51.100.0\", documentation);\n-    check!(\"203.0.113.0\", documentation);\n-    check!(\"203.2.113.0\", global);\n-    check!(\"224.0.0.0\", global | multicast);\n-    check!(\"239.255.255.255\", global | multicast);\n-    check!(\"255.255.255.255\", broadcast);\n-    check!(\"198.18.0.0\", benchmarking);\n-    check!(\"198.18.54.2\", benchmarking);\n-    check!(\"198.19.255.255\", benchmarking);\n-    check!(\"192.0.0.0\");\n-    check!(\"192.0.0.255\");\n-    check!(\"192.0.0.100\");\n-    check!(\"240.0.0.0\", reserved);\n-    check!(\"251.54.1.76\", reserved);\n-    check!(\"254.255.255.255\", reserved);\n-    check!(\"100.64.0.0\", shared);\n-    check!(\"100.127.255.255\", shared);\n-    check!(\"100.100.100.0\", shared);\n-}\n-\n-#[test]\n-fn ipv6_properties() {\n-    macro_rules! ip {\n-        ($s:expr) => {\n-            Ipv6Addr::from_str($s).unwrap()\n-        };\n-    }\n-\n-    macro_rules! check {\n-        ($s:expr, &[$($octet:expr),*], $mask:expr) => {\n-            assert_eq!($s, ip!($s).to_string());\n-            let octets = &[$($octet),*];\n-            assert_eq!(&ip!($s).octets(), octets);\n-            assert_eq!(Ipv6Addr::from(*octets), ip!($s));\n-\n-            let unspecified: u32 = 1 << 0;\n-            let loopback: u32 = 1 << 1;\n-            let unique_local: u32 = 1 << 2;\n-            let global: u32 = 1 << 3;\n-            let unicast_link_local: u32 = 1 << 4;\n-            let unicast_global: u32 = 1 << 7;\n-            let documentation: u32 = 1 << 8;\n-            let benchmarking: u32 = 1 << 16;\n-            let multicast_interface_local: u32 = 1 << 9;\n-            let multicast_link_local: u32 = 1 << 10;\n-            let multicast_realm_local: u32 = 1 << 11;\n-            let multicast_admin_local: u32 = 1 << 12;\n-            let multicast_site_local: u32 = 1 << 13;\n-            let multicast_organization_local: u32 = 1 << 14;\n-            let multicast_global: u32 = 1 << 15;\n-            let multicast: u32 = multicast_interface_local\n-                | multicast_admin_local\n-                | multicast_global\n-                | multicast_link_local\n-                | multicast_realm_local\n-                | multicast_site_local\n-                | multicast_organization_local;\n-\n-            if ($mask & unspecified) == unspecified {\n-                assert!(ip!($s).is_unspecified());\n-            } else {\n-                assert!(!ip!($s).is_unspecified());\n-            }\n-            if ($mask & loopback) == loopback {\n-                assert!(ip!($s).is_loopback());\n-            } else {\n-                assert!(!ip!($s).is_loopback());\n-            }\n-            if ($mask & unique_local) == unique_local {\n-                assert!(ip!($s).is_unique_local());\n-            } else {\n-                assert!(!ip!($s).is_unique_local());\n-            }\n-            if ($mask & global) == global {\n-                assert!(ip!($s).is_global());\n-            } else {\n-                assert!(!ip!($s).is_global());\n-            }\n-            if ($mask & unicast_link_local) == unicast_link_local {\n-                assert!(ip!($s).is_unicast_link_local());\n-            } else {\n-                assert!(!ip!($s).is_unicast_link_local());\n-            }\n-            if ($mask & unicast_global) == unicast_global {\n-                assert!(ip!($s).is_unicast_global());\n-            } else {\n-                assert!(!ip!($s).is_unicast_global());\n-            }\n-            if ($mask & documentation) == documentation {\n-                assert!(ip!($s).is_documentation());\n-            } else {\n-                assert!(!ip!($s).is_documentation());\n-            }\n-            if ($mask & benchmarking) == benchmarking {\n-                assert!(ip!($s).is_benchmarking());\n-            } else {\n-                assert!(!ip!($s).is_benchmarking());\n-            }\n-            if ($mask & multicast) != 0 {\n-                assert!(ip!($s).multicast_scope().is_some());\n-                assert!(ip!($s).is_multicast());\n-            } else {\n-                assert!(ip!($s).multicast_scope().is_none());\n-                assert!(!ip!($s).is_multicast());\n-            }\n-            if ($mask & multicast_interface_local) == multicast_interface_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::InterfaceLocal);\n-            }\n-            if ($mask & multicast_link_local) == multicast_link_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::LinkLocal);\n-            }\n-            if ($mask & multicast_realm_local) == multicast_realm_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::RealmLocal);\n-            }\n-            if ($mask & multicast_admin_local) == multicast_admin_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::AdminLocal);\n-            }\n-            if ($mask & multicast_site_local) == multicast_site_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::SiteLocal);\n-            }\n-            if ($mask & multicast_organization_local) == multicast_organization_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::OrganizationLocal);\n-            }\n-            if ($mask & multicast_global) == multicast_global {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::Global);\n-            }\n-        }\n-    }\n-\n-    let unspecified: u32 = 1 << 0;\n-    let loopback: u32 = 1 << 1;\n-    let unique_local: u32 = 1 << 2;\n-    let global: u32 = 1 << 3;\n-    let unicast_link_local: u32 = 1 << 4;\n-    let unicast_global: u32 = 1 << 7;\n-    let documentation: u32 = 1 << 8;\n-    let benchmarking: u32 = 1 << 16;\n-    let multicast_interface_local: u32 = 1 << 9;\n-    let multicast_link_local: u32 = 1 << 10;\n-    let multicast_realm_local: u32 = 1 << 11;\n-    let multicast_admin_local: u32 = 1 << 12;\n-    let multicast_site_local: u32 = 1 << 13;\n-    let multicast_organization_local: u32 = 1 << 14;\n-    let multicast_global: u32 = 1 << 15;\n-\n-    check!(\"::\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unspecified);\n-\n-    check!(\"::1\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], loopback);\n-\n-    check!(\"::0.0.0.2\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], global | unicast_global);\n-\n-    check!(\"1::\", &[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], global | unicast_global);\n-\n-    check!(\n-        \"::ffff:127.0.0.1\",\n-        &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0x7f, 0, 0, 1],\n-        unicast_global\n-    );\n-\n-    check!(\n-        \"64:ff9b:1::\",\n-        &[0, 0x64, 0xff, 0x9b, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unicast_global\n-    );\n-\n-    check!(\"100::\", &[0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n-\n-    check!(\"2001::\", &[0x20, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n-\n-    check!(\n-        \"2001:1::1\",\n-        &[0x20, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n-        global | unicast_global\n-    );\n-\n-    check!(\n-        \"2001:1::2\",\n-        &[0x20, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n-        global | unicast_global\n-    );\n-\n-    check!(\n-        \"2001:3::\",\n-        &[0x20, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        global | unicast_global\n-    );\n-\n-    check!(\n-        \"2001:4:112::\",\n-        &[0x20, 1, 0, 4, 1, 0x12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        global | unicast_global\n-    );\n-\n-    check!(\n-        \"2001:20::\",\n-        &[0x20, 1, 0, 0x20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        global | unicast_global\n-    );\n-\n-    check!(\"2001:30::\", &[0x20, 1, 0, 0x30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n-\n-    check!(\n-        \"2001:200::\",\n-        &[0x20, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        global | unicast_global\n-    );\n-\n-    check!(\"fc00::\", &[0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unique_local);\n-\n-    check!(\n-        \"fdff:ffff::\",\n-        &[0xfd, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unique_local\n-    );\n-\n-    check!(\n-        \"fe80:ffff::\",\n-        &[0xfe, 0x80, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unicast_link_local\n-    );\n-\n-    check!(\"fe80::\", &[0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_link_local);\n-\n-    check!(\n-        \"febf:ffff::\",\n-        &[0xfe, 0xbf, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unicast_link_local\n-    );\n-\n-    check!(\"febf::\", &[0xfe, 0xbf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_link_local);\n-\n-    check!(\n-        \"febf:ffff:ffff:ffff:ffff:ffff:ffff:ffff\",\n-        &[\n-            0xfe, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n-            0xff, 0xff\n-        ],\n-        unicast_link_local\n-    );\n-\n-    check!(\n-        \"fe80::ffff:ffff:ffff:ffff\",\n-        &[\n-            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n-            0xff, 0xff\n-        ],\n-        unicast_link_local\n-    );\n-\n-    check!(\n-        \"fe80:0:0:1::\",\n-        &[0xfe, 0x80, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unicast_link_local\n-    );\n-\n-    check!(\n-        \"fec0::\",\n-        &[0xfe, 0xc0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unicast_global | global\n-    );\n-\n-    check!(\n-        \"ff01::\",\n-        &[0xff, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_interface_local | global\n-    );\n-\n-    check!(\n-        \"ff02::\",\n-        &[0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_link_local | global\n-    );\n-\n-    check!(\n-        \"ff03::\",\n-        &[0xff, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_realm_local | global\n-    );\n-\n-    check!(\n-        \"ff04::\",\n-        &[0xff, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_admin_local | global\n-    );\n-\n-    check!(\n-        \"ff05::\",\n-        &[0xff, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_site_local | global\n-    );\n-\n-    check!(\n-        \"ff08::\",\n-        &[0xff, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_organization_local | global\n-    );\n-\n-    check!(\n-        \"ff0e::\",\n-        &[0xff, 0xe, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_global | global\n-    );\n-\n-    check!(\n-        \"2001:db8:85a3::8a2e:370:7334\",\n-        &[0x20, 1, 0xd, 0xb8, 0x85, 0xa3, 0, 0, 0, 0, 0x8a, 0x2e, 3, 0x70, 0x73, 0x34],\n-        documentation\n-    );\n-\n-    check!(\n-        \"2001:2::ac32:23ff:21\",\n-        &[0x20, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0xac, 0x32, 0x23, 0xff, 0, 0x21],\n-        benchmarking\n-    );\n-\n-    check!(\n-        \"102:304:506:708:90a:b0c:d0e:f10\",\n-        &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n-        global | unicast_global\n-    );\n-}\n+use crate::net::test::{sa4, tsa};\n+use crate::net::Ipv4Addr;\n \n #[test]\n fn to_socket_addr_socketaddr() {\n     let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 12345);\n     assert_eq!(Ok(vec![a]), tsa(a));\n }\n-\n-#[test]\n-fn test_ipv4_to_int() {\n-    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n-    assert_eq!(u32::from(a), 0x11223344);\n-}\n-\n-#[test]\n-fn test_int_to_ipv4() {\n-    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n-    assert_eq!(Ipv4Addr::from(0x11223344), a);\n-}\n-\n-#[test]\n-fn test_ipv6_to_int() {\n-    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n-    assert_eq!(u128::from(a), 0x112233445566778899aabbccddeeff11u128);\n-}\n-\n-#[test]\n-fn test_int_to_ipv6() {\n-    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n-    assert_eq!(Ipv6Addr::from(0x112233445566778899aabbccddeeff11u128), a);\n-}\n-\n-#[test]\n-fn ipv4_from_constructors() {\n-    assert_eq!(Ipv4Addr::LOCALHOST, Ipv4Addr::new(127, 0, 0, 1));\n-    assert!(Ipv4Addr::LOCALHOST.is_loopback());\n-    assert_eq!(Ipv4Addr::UNSPECIFIED, Ipv4Addr::new(0, 0, 0, 0));\n-    assert!(Ipv4Addr::UNSPECIFIED.is_unspecified());\n-    assert_eq!(Ipv4Addr::BROADCAST, Ipv4Addr::new(255, 255, 255, 255));\n-    assert!(Ipv4Addr::BROADCAST.is_broadcast());\n-}\n-\n-#[test]\n-fn ipv6_from_constructors() {\n-    assert_eq!(Ipv6Addr::LOCALHOST, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n-    assert!(Ipv6Addr::LOCALHOST.is_loopback());\n-    assert_eq!(Ipv6Addr::UNSPECIFIED, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n-    assert!(Ipv6Addr::UNSPECIFIED.is_unspecified());\n-}\n-\n-#[test]\n-fn ipv4_from_octets() {\n-    assert_eq!(Ipv4Addr::from([127, 0, 0, 1]), Ipv4Addr::new(127, 0, 0, 1))\n-}\n-\n-#[test]\n-fn ipv6_from_segments() {\n-    let from_u16s =\n-        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n-    let new = Ipv6Addr::new(0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff);\n-    assert_eq!(new, from_u16s);\n-}\n-\n-#[test]\n-fn ipv6_from_octets() {\n-    let from_u16s =\n-        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n-    let from_u8s = Ipv6Addr::from([\n-        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,\n-        0xff,\n-    ]);\n-    assert_eq!(from_u16s, from_u8s);\n-}\n-\n-#[test]\n-fn cmp() {\n-    let v41 = Ipv4Addr::new(100, 64, 3, 3);\n-    let v42 = Ipv4Addr::new(192, 0, 2, 2);\n-    let v61 = \"2001:db8:f00::1002\".parse::<Ipv6Addr>().unwrap();\n-    let v62 = \"2001:db8:f00::2001\".parse::<Ipv6Addr>().unwrap();\n-    assert!(v41 < v42);\n-    assert!(v61 < v62);\n-\n-    assert_eq!(v41, IpAddr::V4(v41));\n-    assert_eq!(v61, IpAddr::V6(v61));\n-    assert!(v41 != IpAddr::V4(v42));\n-    assert!(v61 != IpAddr::V6(v62));\n-\n-    assert!(v41 < IpAddr::V4(v42));\n-    assert!(v61 < IpAddr::V6(v62));\n-    assert!(IpAddr::V4(v41) < v42);\n-    assert!(IpAddr::V6(v61) < v62);\n-\n-    assert!(v41 < IpAddr::V6(v61));\n-    assert!(IpAddr::V4(v41) < v61);\n-}\n-\n-#[test]\n-fn is_v4() {\n-    let ip = IpAddr::V4(Ipv4Addr::new(100, 64, 3, 3));\n-    assert!(ip.is_ipv4());\n-    assert!(!ip.is_ipv6());\n-}\n-\n-#[test]\n-fn is_v6() {\n-    let ip = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678));\n-    assert!(!ip.is_ipv4());\n-    assert!(ip.is_ipv6());\n-}\n-\n-#[test]\n-fn ipv4_const() {\n-    // test that the methods of `Ipv4Addr` are usable in a const context\n-\n-    const IP_ADDRESS: Ipv4Addr = Ipv4Addr::new(127, 0, 0, 1);\n-    assert_eq!(IP_ADDRESS, Ipv4Addr::LOCALHOST);\n-\n-    const OCTETS: [u8; 4] = IP_ADDRESS.octets();\n-    assert_eq!(OCTETS, [127, 0, 0, 1]);\n-\n-    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n-    assert!(!IS_UNSPECIFIED);\n-\n-    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n-    assert!(IS_LOOPBACK);\n-\n-    const IS_PRIVATE: bool = IP_ADDRESS.is_private();\n-    assert!(!IS_PRIVATE);\n-\n-    const IS_LINK_LOCAL: bool = IP_ADDRESS.is_link_local();\n-    assert!(!IS_LINK_LOCAL);\n-\n-    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n-    assert!(!IS_GLOBAL);\n-\n-    const IS_SHARED: bool = IP_ADDRESS.is_shared();\n-    assert!(!IS_SHARED);\n-\n-    const IS_BENCHMARKING: bool = IP_ADDRESS.is_benchmarking();\n-    assert!(!IS_BENCHMARKING);\n-\n-    const IS_RESERVED: bool = IP_ADDRESS.is_reserved();\n-    assert!(!IS_RESERVED);\n-\n-    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n-    assert!(!IS_MULTICAST);\n-\n-    const IS_BROADCAST: bool = IP_ADDRESS.is_broadcast();\n-    assert!(!IS_BROADCAST);\n-\n-    const IS_DOCUMENTATION: bool = IP_ADDRESS.is_documentation();\n-    assert!(!IS_DOCUMENTATION);\n-\n-    const IP_V6_COMPATIBLE: Ipv6Addr = IP_ADDRESS.to_ipv6_compatible();\n-    assert_eq!(\n-        IP_V6_COMPATIBLE,\n-        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 1])\n-    );\n-\n-    const IP_V6_MAPPED: Ipv6Addr = IP_ADDRESS.to_ipv6_mapped();\n-    assert_eq!(\n-        IP_V6_MAPPED,\n-        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 127, 0, 0, 1])\n-    );\n-}\n-\n-#[test]\n-fn ipv6_const() {\n-    // test that the methods of `Ipv6Addr` are usable in a const context\n-\n-    const IP_ADDRESS: Ipv6Addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n-    assert_eq!(IP_ADDRESS, Ipv6Addr::LOCALHOST);\n-\n-    const SEGMENTS: [u16; 8] = IP_ADDRESS.segments();\n-    assert_eq!(SEGMENTS, [0, 0, 0, 0, 0, 0, 0, 1]);\n-\n-    const OCTETS: [u8; 16] = IP_ADDRESS.octets();\n-    assert_eq!(OCTETS, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);\n-\n-    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n-    assert!(!IS_UNSPECIFIED);\n-\n-    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n-    assert!(IS_LOOPBACK);\n-\n-    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n-    assert!(!IS_GLOBAL);\n-\n-    const IS_UNIQUE_LOCAL: bool = IP_ADDRESS.is_unique_local();\n-    assert!(!IS_UNIQUE_LOCAL);\n-\n-    const IS_UNICAST_LINK_LOCAL: bool = IP_ADDRESS.is_unicast_link_local();\n-    assert!(!IS_UNICAST_LINK_LOCAL);\n-\n-    const IS_DOCUMENTATION: bool = IP_ADDRESS.is_documentation();\n-    assert!(!IS_DOCUMENTATION);\n-\n-    const IS_BENCHMARKING: bool = IP_ADDRESS.is_benchmarking();\n-    assert!(!IS_BENCHMARKING);\n-\n-    const IS_UNICAST_GLOBAL: bool = IP_ADDRESS.is_unicast_global();\n-    assert!(!IS_UNICAST_GLOBAL);\n-\n-    const MULTICAST_SCOPE: Option<Ipv6MulticastScope> = IP_ADDRESS.multicast_scope();\n-    assert_eq!(MULTICAST_SCOPE, None);\n-\n-    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n-    assert!(!IS_MULTICAST);\n-\n-    const IP_V4: Option<Ipv4Addr> = IP_ADDRESS.to_ipv4();\n-    assert_eq!(IP_V4.unwrap(), Ipv4Addr::new(0, 0, 0, 1));\n-}\n-\n-#[test]\n-fn ip_const() {\n-    // test that the methods of `IpAddr` are usable in a const context\n-\n-    const IP_ADDRESS: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST);\n-\n-    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n-    assert!(!IS_UNSPECIFIED);\n-\n-    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n-    assert!(IS_LOOPBACK);\n-\n-    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n-    assert!(!IS_GLOBAL);\n-\n-    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n-    assert!(!IS_MULTICAST);\n-\n-    const IS_IP_V4: bool = IP_ADDRESS.is_ipv4();\n-    assert!(IS_IP_V4);\n-\n-    const IS_IP_V6: bool = IP_ADDRESS.is_ipv6();\n-    assert!(!IS_IP_V6);\n-}\n-\n-#[test]\n-fn structural_match() {\n-    // test that all IP types can be structurally matched upon\n-\n-    const IPV4: Ipv4Addr = Ipv4Addr::LOCALHOST;\n-    match IPV4 {\n-        Ipv4Addr::LOCALHOST => {}\n-        _ => unreachable!(),\n-    }\n-\n-    const IPV6: Ipv6Addr = Ipv6Addr::LOCALHOST;\n-    match IPV6 {\n-        Ipv6Addr::LOCALHOST => {}\n-        _ => unreachable!(),\n-    }\n-\n-    const IP: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST);\n-    match IP {\n-        IpAddr::V4(Ipv4Addr::LOCALHOST) => {}\n-        _ => unreachable!(),\n-    }\n-}"}, {"sha": "bcab15db35b5ca291c6205b9cff3f0c151c2a2c2", "filename": "library/std/src/net/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -26,19 +26,17 @@ use crate::io::{self, ErrorKind};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::ip_addr::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::parser::AddrParseError;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::socket_addr::{SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n #[unstable(feature = \"tcplistener_into_incoming\", issue = \"88339\")]\n pub use self::tcp::IntoIncoming;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::tcp::{Incoming, TcpListener, TcpStream};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::udp::UdpSocket;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::net::AddrParseError;\n \n-mod display_buffer;\n mod ip_addr;\n-mod parser;\n mod socket_addr;\n mod tcp;\n #[cfg(test)]"}, {"sha": "421fed9077c5bbdb21bb1c6d20c2d6340b76c949", "filename": "library/std/src/net/socket_addr.rs", "status": "modified", "additions": 15, "deletions": 674, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr.rs?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -1,9 +1,7 @@\n+// Tests for this module\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n \n-use crate::cmp::Ordering;\n-use crate::fmt::{self, Write};\n-use crate::hash;\n use crate::io;\n use crate::iter;\n use crate::mem;\n@@ -15,542 +13,32 @@ use crate::sys_common::net::LookupHost;\n use crate::sys_common::{FromInner, IntoInner};\n use crate::vec;\n \n-use super::display_buffer::DisplayBuffer;\n-\n-/// An internet socket address, either IPv4 or IPv6.\n-///\n-/// Internet socket addresses consist of an [IP address], a 16-bit port number, as well\n-/// as possibly some version-dependent additional information. See [`SocketAddrV4`]'s and\n-/// [`SocketAddrV6`]'s respective documentation for more details.\n-///\n-/// The size of a `SocketAddr` instance may vary depending on the target operating\n-/// system.\n-///\n-/// [IP address]: IpAddr\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-///\n-/// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-///\n-/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n-/// assert_eq!(socket.port(), 8080);\n-/// assert_eq!(socket.is_ipv4(), true);\n-/// ```\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum SocketAddr {\n-    /// An IPv4 socket address.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    V4(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV4),\n-    /// An IPv6 socket address.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    V6(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV6),\n-}\n-\n-/// An IPv4 socket address.\n-///\n-/// IPv4 socket addresses consist of an [`IPv4` address] and a 16-bit port number, as\n-/// stated in [IETF RFC 793].\n-///\n-/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n-///\n-/// The size of a `SocketAddrV4` struct may vary depending on the target operating\n-/// system. Do not assume that this type has the same memory layout as the underlying\n-/// system representation.\n-///\n-/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n-/// [`IPv4` address]: Ipv4Addr\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::{Ipv4Addr, SocketAddrV4};\n-///\n-/// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-///\n-/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n-/// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n-/// assert_eq!(socket.port(), 8080);\n-/// ```\n-#[derive(Copy, Clone, Eq, PartialEq)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SocketAddrV4 {\n-    ip: Ipv4Addr,\n-    port: u16,\n-}\n-\n-/// An IPv6 socket address.\n-///\n-/// IPv6 socket addresses consist of an [`IPv6` address], a 16-bit port number, as well\n-/// as fields containing the traffic class, the flow label, and a scope identifier\n-/// (see [IETF RFC 2553, Section 3.3] for more details).\n-///\n-/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n-///\n-/// The size of a `SocketAddrV6` struct may vary depending on the target operating\n-/// system. Do not assume that this type has the same memory layout as the underlying\n-/// system representation.\n-///\n-/// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n-/// [`IPv6` address]: Ipv6Addr\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::{Ipv6Addr, SocketAddrV6};\n-///\n-/// let socket = SocketAddrV6::new(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-///\n-/// assert_eq!(\"[2001:db8::1]:8080\".parse(), Ok(socket));\n-/// assert_eq!(socket.ip(), &Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1));\n-/// assert_eq!(socket.port(), 8080);\n-/// ```\n-#[derive(Copy, Clone, Eq, PartialEq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SocketAddrV6 {\n-    ip: Ipv6Addr,\n-    port: u16,\n-    flowinfo: u32,\n-    scope_id: u32,\n-}\n-\n-impl SocketAddr {\n-    /// Creates a new socket address from an [IP address] and a port number.\n-    ///\n-    /// [IP address]: IpAddr\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n-    /// assert_eq!(socket.port(), 8080);\n-    /// ```\n-    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-    #[must_use]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn new(ip: IpAddr, port: u16) -> SocketAddr {\n-        match ip {\n-            IpAddr::V4(a) => SocketAddr::V4(SocketAddrV4::new(a, port)),\n-            IpAddr::V6(a) => SocketAddr::V6(SocketAddrV6::new(a, port, 0, 0)),\n-        }\n-    }\n-\n-    /// Returns the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn ip(&self) -> IpAddr {\n-        match *self {\n-            SocketAddr::V4(ref a) => IpAddr::V4(*a.ip()),\n-            SocketAddr::V6(ref a) => IpAddr::V6(*a.ip()),\n-        }\n-    }\n-\n-    /// Changes the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// socket.set_ip(IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n-    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_ip(&mut self, new_ip: IpAddr) {\n-        // `match (*self, new_ip)` would have us mutate a copy of self only to throw it away.\n-        match (self, new_ip) {\n-            (&mut SocketAddr::V4(ref mut a), IpAddr::V4(new_ip)) => a.set_ip(new_ip),\n-            (&mut SocketAddr::V6(ref mut a), IpAddr::V6(new_ip)) => a.set_ip(new_ip),\n-            (self_, new_ip) => *self_ = Self::new(new_ip, self_.port()),\n-        }\n-    }\n-\n-    /// Returns the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// assert_eq!(socket.port(), 8080);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn port(&self) -> u16 {\n-        match *self {\n-            SocketAddr::V4(ref a) => a.port(),\n-            SocketAddr::V6(ref a) => a.port(),\n-        }\n-    }\n-\n-    /// Changes the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// socket.set_port(1025);\n-    /// assert_eq!(socket.port(), 1025);\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_port(&mut self, new_port: u16) {\n-        match *self {\n-            SocketAddr::V4(ref mut a) => a.set_port(new_port),\n-            SocketAddr::V6(ref mut a) => a.set_port(new_port),\n-        }\n-    }\n-\n-    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n-    /// [`IPv4` address], and [`false`] otherwise.\n-    ///\n-    /// [IP address]: IpAddr\n-    /// [`IPv4` address]: IpAddr::V4\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// assert_eq!(socket.is_ipv4(), true);\n-    /// assert_eq!(socket.is_ipv6(), false);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn is_ipv4(&self) -> bool {\n-        matches!(*self, SocketAddr::V4(_))\n-    }\n-\n-    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n-    /// [`IPv6` address], and [`false`] otherwise.\n-    ///\n-    /// [IP address]: IpAddr\n-    /// [`IPv6` address]: IpAddr::V6\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n-    ///\n-    /// let socket = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n-    /// assert_eq!(socket.is_ipv4(), false);\n-    /// assert_eq!(socket.is_ipv6(), true);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn is_ipv6(&self) -> bool {\n-        matches!(*self, SocketAddr::V6(_))\n-    }\n-}\n-\n-impl SocketAddrV4 {\n-    /// Creates a new socket address from an [`IPv4` address] and a port number.\n-    ///\n-    /// [`IPv4` address]: Ipv4Addr\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV4, Ipv4Addr};\n-    ///\n-    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {\n-        SocketAddrV4 { ip, port }\n-    }\n-\n-    /// Returns the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV4, Ipv4Addr};\n-    ///\n-    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-    /// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn ip(&self) -> &Ipv4Addr {\n-        &self.ip\n-    }\n-\n-    /// Changes the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV4, Ipv4Addr};\n-    ///\n-    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-    /// socket.set_ip(Ipv4Addr::new(192, 168, 0, 1));\n-    /// assert_eq!(socket.ip(), &Ipv4Addr::new(192, 168, 0, 1));\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_ip(&mut self, new_ip: Ipv4Addr) {\n-        self.ip = new_ip;\n-    }\n-\n-    /// Returns the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV4, Ipv4Addr};\n-    ///\n-    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-    /// assert_eq!(socket.port(), 8080);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn port(&self) -> u16 {\n-        self.port\n-    }\n-\n-    /// Changes the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV4, Ipv4Addr};\n-    ///\n-    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-    /// socket.set_port(4242);\n-    /// assert_eq!(socket.port(), 4242);\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_port(&mut self, new_port: u16) {\n-        self.port = new_port;\n-    }\n-}\n-\n-impl SocketAddrV6 {\n-    /// Creates a new socket address from an [`IPv6` address], a 16-bit port number,\n-    /// and the `flowinfo` and `scope_id` fields.\n-    ///\n-    /// For more information on the meaning and layout of the `flowinfo` and `scope_id`\n-    /// parameters, see [IETF RFC 2553, Section 3.3].\n-    ///\n-    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n-    /// [`IPv6` address]: Ipv6Addr\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6 {\n-        SocketAddrV6 { ip, port, flowinfo, scope_id }\n-    }\n-\n-    /// Returns the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-    /// assert_eq!(socket.ip(), &Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn ip(&self) -> &Ipv6Addr {\n-        &self.ip\n-    }\n-\n-    /// Changes the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-    /// socket.set_ip(Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n-    /// assert_eq!(socket.ip(), &Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_ip(&mut self, new_ip: Ipv6Addr) {\n-        self.ip = new_ip;\n-    }\n-\n-    /// Returns the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-    /// assert_eq!(socket.port(), 8080);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn port(&self) -> u16 {\n-        self.port\n-    }\n-\n-    /// Changes the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-    /// socket.set_port(4242);\n-    /// assert_eq!(socket.port(), 4242);\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_port(&mut self, new_port: u16) {\n-        self.port = new_port;\n-    }\n-\n-    /// Returns the flow information associated with this address.\n-    ///\n-    /// This information corresponds to the `sin6_flowinfo` field in C's `netinet/in.h`,\n-    /// as specified in [IETF RFC 2553, Section 3.3].\n-    /// It combines information about the flow label and the traffic class as specified\n-    /// in [IETF RFC 2460], respectively [Section 6] and [Section 7].\n-    ///\n-    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n-    /// [IETF RFC 2460]: https://tools.ietf.org/html/rfc2460\n-    /// [Section 6]: https://tools.ietf.org/html/rfc2460#section-6\n-    /// [Section 7]: https://tools.ietf.org/html/rfc2460#section-7\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n-    /// assert_eq!(socket.flowinfo(), 10);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn flowinfo(&self) -> u32 {\n-        self.flowinfo\n-    }\n-\n-    /// Changes the flow information associated with this socket address.\n-    ///\n-    /// See [`SocketAddrV6::flowinfo`]'s documentation for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n-    /// socket.set_flowinfo(56);\n-    /// assert_eq!(socket.flowinfo(), 56);\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_flowinfo(&mut self, new_flowinfo: u32) {\n-        self.flowinfo = new_flowinfo;\n-    }\n-\n-    /// Returns the scope ID associated with this address.\n-    ///\n-    /// This information corresponds to the `sin6_scope_id` field in C's `netinet/in.h`,\n-    /// as specified in [IETF RFC 2553, Section 3.3].\n-    ///\n-    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n-    /// assert_eq!(socket.scope_id(), 78);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn scope_id(&self) -> u32 {\n-        self.scope_id\n-    }\n-\n-    /// Changes the scope ID associated with this socket address.\n-    ///\n-    /// See [`SocketAddrV6::scope_id`]'s documentation for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n-    /// socket.set_scope_id(42);\n-    /// assert_eq!(socket.scope_id(), 42);\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_scope_id(&mut self, new_scope_id: u32) {\n-        self.scope_id = new_scope_id;\n-    }\n-}\n+pub use core::net::{SocketAddr, SocketAddrV4, SocketAddrV6};\n \n impl FromInner<c::sockaddr_in> for SocketAddrV4 {\n     fn from_inner(addr: c::sockaddr_in) -> SocketAddrV4 {\n-        SocketAddrV4 { ip: Ipv4Addr::from_inner(addr.sin_addr), port: u16::from_be(addr.sin_port) }\n+        SocketAddrV4::new(Ipv4Addr::from_inner(addr.sin_addr), u16::from_be(addr.sin_port))\n     }\n }\n \n impl FromInner<c::sockaddr_in6> for SocketAddrV6 {\n     fn from_inner(addr: c::sockaddr_in6) -> SocketAddrV6 {\n-        SocketAddrV6 {\n-            ip: Ipv6Addr::from_inner(addr.sin6_addr),\n-            port: u16::from_be(addr.sin6_port),\n-            flowinfo: addr.sin6_flowinfo,\n-            scope_id: addr.sin6_scope_id,\n-        }\n+        SocketAddrV6::new(\n+            Ipv6Addr::from_inner(addr.sin6_addr),\n+            u16::from_be(addr.sin6_port),\n+            addr.sin6_flowinfo,\n+            addr.sin6_scope_id,\n+        )\n     }\n }\n \n impl IntoInner<c::sockaddr_in> for SocketAddrV4 {\n     fn into_inner(self) -> c::sockaddr_in {\n         c::sockaddr_in {\n             sin_family: c::AF_INET as c::sa_family_t,\n-            sin_port: self.port.to_be(),\n-            sin_addr: self.ip.into_inner(),\n+            sin_port: self.port().to_be(),\n+            sin_addr: self.ip().into_inner(),\n             ..unsafe { mem::zeroed() }\n         }\n     }\n@@ -560,162 +48,15 @@ impl IntoInner<c::sockaddr_in6> for SocketAddrV6 {\n     fn into_inner(self) -> c::sockaddr_in6 {\n         c::sockaddr_in6 {\n             sin6_family: c::AF_INET6 as c::sa_family_t,\n-            sin6_port: self.port.to_be(),\n-            sin6_addr: self.ip.into_inner(),\n-            sin6_flowinfo: self.flowinfo,\n-            sin6_scope_id: self.scope_id,\n+            sin6_port: self.port().to_be(),\n+            sin6_addr: self.ip().into_inner(),\n+            sin6_flowinfo: self.flowinfo(),\n+            sin6_scope_id: self.scope_id(),\n             ..unsafe { mem::zeroed() }\n         }\n     }\n }\n \n-#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n-impl From<SocketAddrV4> for SocketAddr {\n-    /// Converts a [`SocketAddrV4`] into a [`SocketAddr::V4`].\n-    fn from(sock4: SocketAddrV4) -> SocketAddr {\n-        SocketAddr::V4(sock4)\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n-impl From<SocketAddrV6> for SocketAddr {\n-    /// Converts a [`SocketAddrV6`] into a [`SocketAddr::V6`].\n-    fn from(sock6: SocketAddrV6) -> SocketAddr {\n-        SocketAddr::V6(sock6)\n-    }\n-}\n-\n-#[stable(feature = \"addr_from_into_ip\", since = \"1.17.0\")]\n-impl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr {\n-    /// Converts a tuple struct (Into<[`IpAddr`]>, `u16`) into a [`SocketAddr`].\n-    ///\n-    /// This conversion creates a [`SocketAddr::V4`] for an [`IpAddr::V4`]\n-    /// and creates a [`SocketAddr::V6`] for an [`IpAddr::V6`].\n-    ///\n-    /// `u16` is treated as port of the newly created [`SocketAddr`].\n-    fn from(pieces: (I, u16)) -> SocketAddr {\n-        SocketAddr::new(pieces.0.into(), pieces.1)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for SocketAddr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            SocketAddr::V4(ref a) => a.fmt(f),\n-            SocketAddr::V6(ref a) => a.fmt(f),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for SocketAddrV4 {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // If there are no alignment requirements, write the socket address directly to `f`.\n-        // Otherwise, write it to a local buffer and then use `f.pad`.\n-        if f.precision().is_none() && f.width().is_none() {\n-            write!(f, \"{}:{}\", self.ip(), self.port())\n-        } else {\n-            const LONGEST_IPV4_SOCKET_ADDR: &str = \"255.255.255.255:65536\";\n-\n-            let mut buf = DisplayBuffer::<{ LONGEST_IPV4_SOCKET_ADDR.len() }>::new();\n-            // Buffer is long enough for the longest possible IPv4 socket address, so this should never fail.\n-            write!(buf, \"{}:{}\", self.ip(), self.port()).unwrap();\n-\n-            f.pad(buf.as_str())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for SocketAddrV4 {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for SocketAddrV6 {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // If there are no alignment requirements, write the socket address directly to `f`.\n-        // Otherwise, write it to a local buffer and then use `f.pad`.\n-        if f.precision().is_none() && f.width().is_none() {\n-            match self.scope_id() {\n-                0 => write!(f, \"[{}]:{}\", self.ip(), self.port()),\n-                scope_id => write!(f, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n-            }\n-        } else {\n-            const LONGEST_IPV6_SOCKET_ADDR: &str =\n-                \"[ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff%4294967296]:65536\";\n-\n-            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_SOCKET_ADDR.len() }>::new();\n-            match self.scope_id() {\n-                0 => write!(buf, \"[{}]:{}\", self.ip(), self.port()),\n-                scope_id => write!(buf, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n-            }\n-            // Buffer is long enough for the longest possible IPv6 socket address, so this should never fail.\n-            .unwrap();\n-\n-            f.pad(buf.as_str())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for SocketAddrV6 {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialOrd for SocketAddrV4 {\n-    fn partial_cmp(&self, other: &SocketAddrV4) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialOrd for SocketAddrV6 {\n-    fn partial_cmp(&self, other: &SocketAddrV6) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl Ord for SocketAddrV4 {\n-    fn cmp(&self, other: &SocketAddrV4) -> Ordering {\n-        self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n-    }\n-}\n-\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl Ord for SocketAddrV6 {\n-    fn cmp(&self, other: &SocketAddrV6) -> Ordering {\n-        self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for SocketAddrV4 {\n-    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        (self.port, self.ip).hash(s)\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for SocketAddrV6 {\n-    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        (self.port, &self.ip, self.flowinfo, self.scope_id).hash(s)\n-    }\n-}\n-\n /// A trait for objects which can be converted or resolved to one or more\n /// [`SocketAddr`] values.\n ///"}, {"sha": "d4fea05fe4bc1ee7fa0e2d0d74c8d5437a44d78c", "filename": "tests/ui/traits/issue-77982.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf04603dca6c37366fb010a36dd05047f7b70b1e/tests%2Fui%2Ftraits%2Fissue-77982.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf04603dca6c37366fb010a36dd05047f7b70b1e/tests%2Fui%2Ftraits%2Fissue-77982.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fissue-77982.stderr?ref=cf04603dca6c37366fb010a36dd05047f7b70b1e", "patch": "@@ -43,7 +43,7 @@ LL |     let ips: Vec<_> = (0..100_000).map(|_| u32::from(0u32.into())).collect(\n    |                                            |\n    |                                            required by a bound introduced by this call\n    |\n-   = note: multiple `impl`s satisfying `u32: From<_>` found in the following crates: `core`, `std`:\n+   = note: multiple `impl`s satisfying `u32: From<_>` found in the `core` crate:\n            - impl From<Ipv4Addr> for u32;\n            - impl From<NonZeroU32> for u32;\n            - impl From<bool> for u32;"}]}