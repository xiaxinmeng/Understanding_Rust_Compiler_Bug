{"sha": "962b2197a5d5796ee030a05f534ee0fde8ce07bb", "node_id": "C_kwDOAAsO6NoAKDk2MmIyMTk3YTVkNTc5NmVlMDMwYTA1ZjUzNGVlMGZkZThjZTA3YmI", "commit": {"author": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-11-20T18:46:36Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-12-03T18:41:40Z"}, "message": "Annotate `derive`d spans and move span suggestion code\n\n* Annotate `derive`d spans from the user's code with the appropciate context\n* Add `Span::can_be_used_for_suggestion` to query if the underlying span\n  at the users' code", "tree": {"sha": "b9cec8cf9bceb90e7ad55c5f669eee43a29da822", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9cec8cf9bceb90e7ad55c5f669eee43a29da822"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/962b2197a5d5796ee030a05f534ee0fde8ce07bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/962b2197a5d5796ee030a05f534ee0fde8ce07bb", "html_url": "https://github.com/rust-lang/rust/commit/962b2197a5d5796ee030a05f534ee0fde8ce07bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/962b2197a5d5796ee030a05f534ee0fde8ce07bb/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bee2b88c075a2f007a7d5762727a840477c0893", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bee2b88c075a2f007a7d5762727a840477c0893", "html_url": "https://github.com/rust-lang/rust/commit/8bee2b88c075a2f007a7d5762727a840477c0893"}], "stats": {"total": 202, "additions": 112, "deletions": 90}, "files": [{"sha": "1427a2aada3fc485d77d326b6c9ad25391dd9d74", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 74, "deletions": 61, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=962b2197a5d5796ee030a05f534ee0fde8ce07bb", "patch": "@@ -570,7 +570,8 @@ impl<'a> TraitDef<'a> {\n         let Generics { mut params, mut where_clause, .. } =\n             self.generics.to_generics(cx, self.span, type_ident, generics);\n         where_clause.span = generics.where_clause.span;\n-        let span = generics.span;\n+        let ctxt = self.span.ctxt();\n+        let span = generics.span.with_ctxt(ctxt);\n \n         // Create the generic parameters\n         params.extend(generics.params.iter().map(|param| match &param.kind {\n@@ -591,12 +592,12 @@ impl<'a> TraitDef<'a> {\n                         param.bounds.iter().cloned()\n                     ).collect();\n \n-                cx.typaram(param.ident.span, param.ident, vec![], bounds, None)\n+                cx.typaram(param.ident.span.with_ctxt(ctxt), param.ident, vec![], bounds, None)\n             }\n             GenericParamKind::Const { ty, kw_span, .. } => {\n                 let const_nodefault_kind = GenericParamKind::Const {\n                     ty: ty.clone(),\n-                    kw_span: *kw_span,\n+                    kw_span: kw_span.with_ctxt(ctxt),\n \n                     // We can't have default values inside impl block\n                     default: None,\n@@ -610,11 +611,25 @@ impl<'a> TraitDef<'a> {\n         // and similarly for where clauses\n         where_clause.predicates.extend(generics.where_clause.predicates.iter().map(|clause| {\n             match clause {\n-                ast::WherePredicate::BoundPredicate(_)\n-                | ast::WherePredicate::RegionPredicate(_) => clause.clone(),\n+                ast::WherePredicate::BoundPredicate(wb) => {\n+                    let span = wb.span.with_ctxt(ctxt);\n+                    ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                        span,\n+                        ..wb.clone()\n+                    })\n+                }\n+                ast::WherePredicate::RegionPredicate(wr) => {\n+                    let span = wr.span.with_ctxt(ctxt);\n+                    ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n+                        span,\n+                        ..wr.clone()\n+                    })\n+                }\n                 ast::WherePredicate::EqPredicate(we) => {\n+                    let span = we.span.with_ctxt(ctxt);\n                     ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                         id: ast::DUMMY_NODE_ID,\n+                        span,\n                         ..we.clone()\n                     })\n                 }\n@@ -678,13 +693,13 @@ impl<'a> TraitDef<'a> {\n             .iter()\n             .map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n-                    GenericArg::Lifetime(cx.lifetime(param.ident.span, param.ident))\n+                    GenericArg::Lifetime(cx.lifetime(param.ident.span.with_ctxt(ctxt), param.ident))\n                 }\n                 GenericParamKind::Type { .. } => {\n-                    GenericArg::Type(cx.ty_ident(param.ident.span, param.ident))\n+                    GenericArg::Type(cx.ty_ident(param.ident.span.with_ctxt(ctxt), param.ident))\n                 }\n                 GenericParamKind::Const { .. } => {\n-                    GenericArg::Const(cx.const_ident(param.ident.span, param.ident))\n+                    GenericArg::Const(cx.const_ident(param.ident.span.with_ctxt(ctxt), param.ident))\n                 }\n             })\n             .collect();\n@@ -832,16 +847,17 @@ impl<'a> MethodDef<'a> {\n         nonself_args: &[P<Expr>],\n         fields: &SubstructureFields<'_>,\n     ) -> P<Expr> {\n+        let span = trait_.span;\n         let substructure = Substructure {\n             type_ident,\n-            method_ident: Ident::new(self.name, trait_.span),\n+            method_ident: Ident::new(self.name, span),\n             self_args,\n             nonself_args,\n             fields,\n         };\n         let mut f = self.combine_substructure.borrow_mut();\n         let f: &mut CombineSubstructureFunc<'_> = &mut *f;\n-        f(cx, trait_.span, &substructure)\n+        f(cx, span, &substructure)\n     }\n \n     fn get_ret_ty(\n@@ -869,9 +885,10 @@ impl<'a> MethodDef<'a> {\n         let mut nonself_args = Vec::new();\n         let mut arg_tys = Vec::new();\n         let mut nonstatic = false;\n+        let span = trait_.span;\n \n         let ast_explicit_self = self.explicit_self.as_ref().map(|self_ptr| {\n-            let (self_expr, explicit_self) = ty::get_explicit_self(cx, trait_.span, self_ptr);\n+            let (self_expr, explicit_self) = ty::get_explicit_self(cx, span, self_ptr);\n \n             self_args.push(self_expr);\n             nonstatic = true;\n@@ -880,11 +897,11 @@ impl<'a> MethodDef<'a> {\n         });\n \n         for (ty, name) in self.args.iter() {\n-            let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = Ident::new(*name, trait_.span);\n+            let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n+            let ident = Ident::new(*name, span);\n             arg_tys.push((ident, ast_ty));\n \n-            let arg_expr = cx.expr_ident(trait_.span, ident);\n+            let arg_expr = cx.expr_ident(span, ident);\n \n             match *ty {\n                 // for static methods, just treat any Self\n@@ -893,7 +910,7 @@ impl<'a> MethodDef<'a> {\n                     self_args.push(arg_expr);\n                 }\n                 Ptr(ref ty, _) if matches!(**ty, Self_) && nonstatic => {\n-                    self_args.push(cx.expr_deref(trait_.span, arg_expr))\n+                    self_args.push(cx.expr_deref(span, arg_expr))\n                 }\n                 _ => {\n                     nonself_args.push(arg_expr);\n@@ -914,41 +931,41 @@ impl<'a> MethodDef<'a> {\n         arg_types: Vec<(Ident, P<ast::Ty>)>,\n         body: P<Expr>,\n     ) -> P<ast::AssocItem> {\n+        let span = trait_.span;\n         // Create the generics that aren't for `Self`.\n-        let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n+        let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n \n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n-                let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(trait_.span);\n+                let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(span);\n                 ast::Param::from_self(ast::AttrVec::default(), explicit_self, ident)\n             });\n-            let nonself_args =\n-                arg_types.into_iter().map(|(name, ty)| cx.param(trait_.span, name, ty));\n+            let nonself_args = arg_types.into_iter().map(|(name, ty)| cx.param(span, name, ty));\n             self_args.into_iter().chain(nonself_args).collect()\n         };\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n \n-        let method_ident = Ident::new(self.name, trait_.span);\n+        let method_ident = Ident::new(self.name, span);\n         let fn_decl = cx.fn_decl(args, ast::FnRetTy::Ty(ret_type));\n         let body_block = cx.block_expr(body);\n \n-        let unsafety = if self.is_unsafe { ast::Unsafe::Yes(trait_.span) } else { ast::Unsafe::No };\n+        let unsafety = if self.is_unsafe { ast::Unsafe::Yes(span) } else { ast::Unsafe::No };\n \n-        let trait_lo_sp = trait_.span.shrink_to_lo();\n+        let trait_lo_sp = span.shrink_to_lo();\n \n         let sig = ast::FnSig {\n             header: ast::FnHeader { unsafety, ext: ast::Extern::None, ..ast::FnHeader::default() },\n             decl: fn_decl,\n-            span: trait_.span,\n+            span,\n         };\n         let defaultness = ast::Defaultness::Final;\n \n         // Create the method.\n         P(ast::AssocItem {\n             id: ast::DUMMY_NODE_ID,\n             attrs: self.attributes.clone(),\n-            span: trait_.span,\n+            span,\n             vis: ast::Visibility {\n                 span: trait_lo_sp,\n                 kind: ast::VisibilityKind::Inherited,\n@@ -1011,11 +1028,11 @@ impl<'a> MethodDef<'a> {\n         nonself_args: &[P<Expr>],\n         use_temporaries: bool,\n     ) -> P<Expr> {\n-        let mut raw_fields = Vec::new(); // Vec<[fields of self],\n-        // [fields of next Self arg], [etc]>\n+        let mut raw_fields = Vec::new(); // Vec<[fields of self], [fields of next Self arg], [etc]>\n+        let span = trait_.span;\n         let mut patterns = Vec::new();\n         for i in 0..self_args.len() {\n-            let struct_path = cx.path(trait_.span, vec![type_ident]);\n+            let struct_path = cx.path(span, vec![type_ident]);\n             let (pat, ident_expr) = trait_.create_struct_pattern(\n                 cx,\n                 struct_path,\n@@ -1035,7 +1052,7 @@ impl<'a> MethodDef<'a> {\n             let mut other_fields: Vec<vec::IntoIter<_>> = raw_fields.collect();\n             first_field\n                 .map(|(span, opt_id, field, attrs)| FieldInfo {\n-                    span,\n+                    span: span.with_ctxt(trait_.span.ctxt()),\n                     name: opt_id,\n                     self_: field,\n                     other: other_fields\n@@ -1049,7 +1066,7 @@ impl<'a> MethodDef<'a> {\n                 })\n                 .collect()\n         } else {\n-            cx.span_bug(trait_.span, \"no `self` parameter for method in generic `derive`\")\n+            cx.span_bug(span, \"no `self` parameter for method in generic `derive`\")\n         };\n \n         // body of the inner most destructuring match\n@@ -1066,11 +1083,7 @@ impl<'a> MethodDef<'a> {\n         // structs. This is actually right-to-left, but it shouldn't\n         // matter.\n         for (arg_expr, pat) in iter::zip(self_args, patterns) {\n-            body = cx.expr_match(\n-                trait_.span,\n-                arg_expr.clone(),\n-                vec![cx.arm(trait_.span, pat.clone(), body)],\n-            )\n+            body = cx.expr_match(span, arg_expr.clone(), vec![cx.arm(span, pat.clone(), body)])\n         }\n \n         body\n@@ -1180,7 +1193,7 @@ impl<'a> MethodDef<'a> {\n         mut self_args: Vec<P<Expr>>,\n         nonself_args: &[P<Expr>],\n     ) -> P<Expr> {\n-        let sp = trait_.span;\n+        let span = trait_.span;\n         let variants = &enum_def.variants;\n \n         let self_arg_names = iter::once(\"__self\".to_string())\n@@ -1195,7 +1208,7 @@ impl<'a> MethodDef<'a> {\n \n         let self_arg_idents = self_arg_names\n             .iter()\n-            .map(|name| Ident::from_str_and_span(name, sp))\n+            .map(|name| Ident::from_str_and_span(name, span))\n             .collect::<Vec<Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n@@ -1205,7 +1218,7 @@ impl<'a> MethodDef<'a> {\n             .iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n-                Ident::from_str_and_span(&vi_suffix, trait_.span)\n+                Ident::from_str_and_span(&vi_suffix, span)\n             })\n             .collect::<Vec<Ident>>();\n \n@@ -1235,7 +1248,7 @@ impl<'a> MethodDef<'a> {\n                         self_arg_name,\n                         ast::Mutability::Not,\n                     );\n-                    (cx.pat(sp, PatKind::Ref(p, ast::Mutability::Not)), idents)\n+                    (cx.pat(span, PatKind::Ref(p, ast::Mutability::Not)), idents)\n                 };\n \n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n@@ -1254,7 +1267,7 @@ impl<'a> MethodDef<'a> {\n                 }\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n-                let single_pat = cx.pat_tuple(sp, subpats);\n+                let single_pat = cx.pat_tuple(span, subpats);\n \n                 // For the BodyK, we need to delegate to our caller,\n                 // passing it an EnumMatching to indicate which case\n@@ -1271,7 +1284,7 @@ impl<'a> MethodDef<'a> {\n                     .into_iter()\n                     .enumerate()\n                     // For each arg field of self, pull out its getter expr ...\n-                    .map(|(field_index, (sp, opt_ident, self_getter_expr, attrs))| {\n+                    .map(|(field_index, (span, opt_ident, self_getter_expr, attrs))| {\n                         // ... but FieldInfo also wants getter expr\n                         // for matching other arguments of Self type;\n                         // so walk across the *other* self_pats_idents\n@@ -1294,7 +1307,7 @@ impl<'a> MethodDef<'a> {\n                             .collect::<Vec<P<Expr>>>();\n \n                         FieldInfo {\n-                            span: sp,\n+                            span,\n                             name: opt_ident,\n                             self_: self_getter_expr,\n                             other: others,\n@@ -1317,7 +1330,7 @@ impl<'a> MethodDef<'a> {\n                     &substructure,\n                 );\n \n-                cx.arm(sp, single_pat, arm_expr)\n+                cx.arm(span, single_pat, arm_expr)\n             })\n             .collect();\n \n@@ -1340,12 +1353,12 @@ impl<'a> MethodDef<'a> {\n                 // Since we know that all the arguments will match if we reach\n                 // the match expression we add the unreachable intrinsics as the\n                 // result of the catch all which should help llvm in optimizing it\n-                Some(deriving::call_unreachable(cx, sp))\n+                Some(deriving::call_unreachable(cx, span))\n             }\n             _ => None,\n         };\n         if let Some(arm) = default {\n-            match_arms.push(cx.arm(sp, cx.pat_wild(sp), arm));\n+            match_arms.push(cx.arm(span, cx.pat_wild(span), arm));\n         }\n \n         // We will usually need the catch-all after matching the\n@@ -1379,23 +1392,23 @@ impl<'a> MethodDef<'a> {\n \n             // We also build an expression which checks whether all discriminants are equal\n             // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n-            let mut discriminant_test = cx.expr_bool(sp, true);\n+            let mut discriminant_test = cx.expr_bool(span, true);\n \n             let mut first_ident = None;\n             for (&ident, self_arg) in iter::zip(&vi_idents, &self_args) {\n-                let self_addr = cx.expr_addr_of(sp, self_arg.clone());\n+                let self_addr = cx.expr_addr_of(span, self_arg.clone());\n                 let variant_value =\n-                    deriving::call_intrinsic(cx, sp, sym::discriminant_value, vec![self_addr]);\n-                let let_stmt = cx.stmt_let(sp, false, ident, variant_value);\n+                    deriving::call_intrinsic(cx, span, sym::discriminant_value, vec![self_addr]);\n+                let let_stmt = cx.stmt_let(span, false, ident, variant_value);\n                 index_let_stmts.push(let_stmt);\n \n                 match first_ident {\n                     Some(first) => {\n-                        let first_expr = cx.expr_ident(sp, first);\n-                        let id = cx.expr_ident(sp, ident);\n-                        let test = cx.expr_binary(sp, BinOpKind::Eq, first_expr, id);\n+                        let first_expr = cx.expr_ident(span, first);\n+                        let id = cx.expr_ident(span, ident);\n+                        let test = cx.expr_binary(span, BinOpKind::Eq, first_expr, id);\n                         discriminant_test =\n-                            cx.expr_binary(sp, BinOpKind::And, discriminant_test, test)\n+                            cx.expr_binary(span, BinOpKind::And, discriminant_test, test)\n                     }\n                     None => {\n                         first_ident = Some(ident);\n@@ -1417,8 +1430,8 @@ impl<'a> MethodDef<'a> {\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            self_args.map_in_place(|self_arg| cx.expr_addr_of(sp, self_arg));\n-            let match_arg = cx.expr(sp, ast::ExprKind::Tup(self_args));\n+            self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n+            let match_arg = cx.expr(span, ast::ExprKind::Tup(self_args));\n \n             // Lastly we create an expression which branches on all discriminants being equal\n             //  if discriminant_test {\n@@ -1432,10 +1445,10 @@ impl<'a> MethodDef<'a> {\n             //  else {\n             //      <delegated expression referring to __self0_vi, et al.>\n             //  }\n-            let all_match = cx.expr_match(sp, match_arg, match_arms);\n-            let arm_expr = cx.expr_if(sp, discriminant_test, all_match, Some(arm_expr));\n+            let all_match = cx.expr_match(span, match_arg, match_arms);\n+            let arm_expr = cx.expr_if(span, discriminant_test, all_match, Some(arm_expr));\n             index_let_stmts.push(cx.stmt_expr(arm_expr));\n-            cx.expr_block(cx.block(sp, index_let_stmts))\n+            cx.expr_block(cx.block(span, index_let_stmts))\n         } else if variants.is_empty() {\n             // As an additional wrinkle, For a zero-variant enum A,\n             // currently the compiler\n@@ -1486,16 +1499,16 @@ impl<'a> MethodDef<'a> {\n             // derive Debug on such a type could here generate code\n             // that needs the feature gate enabled.)\n \n-            deriving::call_unreachable(cx, sp)\n+            deriving::call_unreachable(cx, span)\n         } else {\n             // Final wrinkle: the self_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            self_args.map_in_place(|self_arg| cx.expr_addr_of(sp, self_arg));\n-            let match_arg = cx.expr(sp, ast::ExprKind::Tup(self_args));\n-            cx.expr_match(sp, match_arg, match_arms)\n+            self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n+            let match_arg = cx.expr(span, ast::ExprKind::Tup(self_args));\n+            cx.expr_match(span, match_arg, match_arms)\n         }\n     }\n "}, {"sha": "c8f53ed2c5b433d5180a6c1016f613c42ba0ff8f", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=962b2197a5d5796ee030a05f534ee0fde8ce07bb", "patch": "@@ -17,7 +17,7 @@ use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable_Generic;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{def_id::LocalDefId, BytePos, ExpnKind, MacroKind, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{def_id::LocalDefId, BytePos, MultiSpan, Span, DUMMY_SP};\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use rustc_target::spec::abi::Abi;\n \n@@ -525,20 +525,21 @@ pub struct GenericParam<'hir> {\n }\n \n impl GenericParam<'hir> {\n-    pub fn bounds_span(&self) -> Option<Span> {\n-        self.bounds.iter().fold(None, |span, bound| {\n-            if let ExpnKind::Macro(MacroKind::Derive, _) =\n-                bound.span().ctxt().outer_expn_data().kind\n-            {\n-                // We ignore bounds that come from exclusively from a `#[derive(_)]`, because we\n-                // can't really point at them, and we sometimes use this method to get a span\n-                // appropriate for suggestions.\n-                span\n-            } else {\n-                let span = span.map(|s| s.to(bound.span())).unwrap_or_else(|| bound.span());\n-                Some(span)\n-            }\n-        })\n+    pub fn bounds_span_for_suggestions(&self) -> Option<Span> {\n+        self.bounds\n+            .iter()\n+            .fold(None, |span: Option<Span>, bound| {\n+                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n+                // as we use this method to get a span appropriate for suggestions.\n+                // FIXME: a more \"principled\" approach should be taken here.\n+                if !bound.span().can_be_used_for_suggestions() {\n+                    None\n+                } else {\n+                    let span = span.map(|s| s.to(bound.span())).unwrap_or_else(|| bound.span());\n+                    Some(span)\n+                }\n+            })\n+            .map(|sp| sp.shrink_to_hi())\n     }\n }\n "}, {"sha": "8803370251b38929f5acf2123573cb394db12f68", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=962b2197a5d5796ee030a05f534ee0fde8ce07bb", "patch": "@@ -270,7 +270,7 @@ pub fn suggest_constraining_type_param(\n         // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n         && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n     {\n-        if let Some(bounds_span) = param.bounds_span() {\n+        if let Some(span) = param.bounds_span_for_suggestions() {\n             // If user has provided some bounds, suggest restricting them:\n             //\n             //   fn foo<T: Foo>(t: T) { ... }\n@@ -284,7 +284,7 @@ pub fn suggest_constraining_type_param(\n             //          --\n             //          |\n             //          replace with: `T: Bar +`\n-            suggest_restrict(bounds_span.shrink_to_hi());\n+            suggest_restrict(span);\n         } else {\n             // If user hasn't provided any bounds, suggest adding a new one:\n             //"}, {"sha": "72ba3f7b980cbc464de015724d1e2d31d27e7db0", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=962b2197a5d5796ee030a05f534ee0fde8ce07bb", "patch": "@@ -1735,7 +1735,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         (generics.span, format!(\"<{}>\", ident))\n                     };\n                     // Do not suggest if this is coming from macro expansion.\n-                    if !span.from_expansion() {\n+                    if span.can_be_used_for_suggestions() {\n                         return Some((\n                             span.shrink_to_hi(),\n                             msg,\n@@ -1825,7 +1825,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         continue;\n                     }\n                     suggested_spans.push(span);\n-                    if !span.from_expansion() {\n+                    if span.can_be_used_for_suggestions() {\n                         err.span_suggestion(\n                             span,\n                             &format!(\"consider introducing lifetime `{}` here\", lifetime_ref),"}, {"sha": "98478cf5dec692ae393431fb4ed2a1b80ecdc19c", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=962b2197a5d5796ee030a05f534ee0fde8ce07bb", "patch": "@@ -551,6 +551,16 @@ impl Span {\n         matches!(self.ctxt().outer_expn_data().kind, ExpnKind::Macro(MacroKind::Derive, _))\n     }\n \n+    /// Gate suggestions that would not be appropriate in a context the user didn't write.\n+    pub fn can_be_used_for_suggestions(self) -> bool {\n+        !self.from_expansion()\n+        // FIXME: If this span comes from a `derive` macro but it points at code the user wrote,\n+        // the callsite span and the span will be pointing at different places. It also means that\n+        // we can safely provide suggestions on this span.\n+            || (matches!(self.ctxt().outer_expn_data().kind, ExpnKind::Macro(MacroKind::Derive, _))\n+                && self.parent_callsite().map(|p| (p.lo(), p.hi())) != Some((self.lo(), self.hi())))\n+    }\n+\n     #[inline]\n     pub fn with_root_ctxt(lo: BytePos, hi: BytePos) -> Span {\n         Span::new(lo, hi, SyntaxContext::root(), None)"}, {"sha": "4c09aa1183fb516e59e94594d9a1036b3e09f6ea", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=962b2197a5d5796ee030a05f534ee0fde8ce07bb", "patch": "@@ -262,16 +262,16 @@ fn suggest_restriction(\n             match generics\n                 .params\n                 .iter()\n-                .map(|p| p.bounds_span().unwrap_or(p.span))\n-                .filter(|&span| generics.span.contains(span) && span.desugaring_kind().is_none())\n+                .map(|p| p.bounds_span_for_suggestions().unwrap_or(p.span.shrink_to_hi()))\n+                .filter(|&span| generics.span.contains(span) && span.can_be_used_for_suggestions())\n                 .max_by_key(|span| span.hi())\n             {\n                 // `fn foo(t: impl Trait)`\n                 //        ^ suggest `<T: Trait>` here\n                 None => (generics.span, format!(\"<{}>\", type_param)),\n                 // `fn foo<A>(t: impl Trait)`\n                 //        ^^^ suggest `<A, T: Trait>` here\n-                Some(span) => (span.shrink_to_hi(), format!(\", {}\", type_param)),\n+                Some(span) => (span, format!(\", {}\", type_param)),\n             },\n             // `fn foo(t: impl Trait)`\n             //                       ^ suggest `where <T as Trait>::A: Bound`"}, {"sha": "4d86755b26cdb238dacef2abf775af4aef78d918", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962b2197a5d5796ee030a05f534ee0fde8ce07bb/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=962b2197a5d5796ee030a05f534ee0fde8ce07bb", "patch": "@@ -177,11 +177,9 @@ crate fn placeholder_type_error(\n         sugg.push((arg.span, (*type_name).to_string()));\n     } else {\n         let last = generics.iter().last().unwrap();\n-        sugg.push((\n-            // Account for bounds, we want `fn foo<T: E, K>(_: K)` not `fn foo<T, K: E>(_: K)`.\n-            last.bounds_span().unwrap_or(last.span).shrink_to_hi(),\n-            format!(\", {}\", type_name),\n-        ));\n+        // Account for bounds, we want `fn foo<T: E, K>(_: K)` not `fn foo<T, K: E>(_: K)`.\n+        let span = last.bounds_span_for_suggestions().unwrap_or(last.span.shrink_to_hi());\n+        sugg.push((span, format!(\", {}\", type_name)));\n     }\n \n     let mut err = bad_placeholder_type(tcx, placeholder_types, kind);"}, {"sha": "cdf1f0dfc536108e9f2fbd0df1b5d5876bbf82a1", "filename": "src/test/ui/issues/issue-38821.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962b2197a5d5796ee030a05f534ee0fde8ce07bb/src%2Ftest%2Fui%2Fissues%2Fissue-38821.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962b2197a5d5796ee030a05f534ee0fde8ce07bb/src%2Ftest%2Fui%2Fissues%2Fissue-38821.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38821.stderr?ref=962b2197a5d5796ee030a05f534ee0fde8ce07bb", "patch": "@@ -12,8 +12,8 @@ LL | impl<T: NotNull> IntoNullable for T {\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider further restricting the associated type\n    |\n-LL |     Expr: Expression<SqlType=<Col::SqlType as IntoNullable>::Nullable>, <Col as Expression>::SqlType: NotNull\n-   |                                                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     Expr: Expression<SqlType=<Col::SqlType as IntoNullable>::Nullable>, <Col as Expression>::SqlType: NotNull,\n+   |                                                                       +++++++++++++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}]}