{"sha": "c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NGQ2NzE2NzFhZWEyZTQ0ZWU3ZmM2ZWIwMGVlNzVmYzMwZWQ3Yjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-17T13:29:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-17T13:29:48Z"}, "message": "Auto merge of #23423 - nikomatsakis:issue-18737-trait-subtyping, r=nrc\n\nThis upcast coercion currently never requires vtable changes. It should be generalized. \r\n\r\nThis is a [breaking-change] -- if you have an impl on an object type like `impl SomeTrait`, then this will no longer be applicable to object types like `SomeTrait+Send`. In the standard library, this primarily affected `Any`, and this PR adds impls for `Any+Send` as to keep the API the same in practice. An alternate workaround is to use UFCS form or standalone fns. For more details, see <https://github.com/rust-lang/rust/issues/18737#issuecomment-78450798>.\r\n\r\nr? @nrc", "tree": {"sha": "058ec26f2e5ae48d415b7730c5f2d51df9b369a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/058ec26f2e5ae48d415b7730c5f2d51df9b369a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "html_url": "https://github.com/rust-lang/rust/commit/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31ba21228e0e539a665ce14ab3a176e30e57f822", "url": "https://api.github.com/repos/rust-lang/rust/commits/31ba21228e0e539a665ce14ab3a176e30e57f822", "html_url": "https://github.com/rust-lang/rust/commit/31ba21228e0e539a665ce14ab3a176e30e57f822"}, {"sha": "277b4f035aa7e42330aabbc243a8fcb5cf4cc8bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/277b4f035aa7e42330aabbc243a8fcb5cf4cc8bd", "html_url": "https://github.com/rust-lang/rust/commit/277b4f035aa7e42330aabbc243a8fcb5cf4cc8bd"}], "stats": {"total": 370, "additions": 248, "deletions": 122}, "files": [{"sha": "50935e6404da5873a728cdc3c0a6a57c018dfc33", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -241,7 +241,7 @@ pub trait BoxAny {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `Err(Self)` if it isn't.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn downcast<T: 'static>(self) -> Result<Box<T>, Self>;\n+    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -264,6 +264,15 @@ impl BoxAny for Box<Any> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl BoxAny for Box<Any+Send> {\n+    #[inline]\n+    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n+        <Box<Any>>::downcast(self)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display + ?Sized> fmt::Display for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "6d3fac4c68d3468fb22986c1469fbc22b96296dd", "filename": "src/libcore/any.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -71,6 +71,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use marker::Send;\n use mem::transmute;\n use option::Option::{self, Some, None};\n use raw::TraitObject;\n@@ -154,6 +155,31 @@ impl Any {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Any+Send {\n+    /// Forwards to the method defined on the type `Any`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is<T: 'static>(&self) -> bool {\n+        Any::is::<T>(self)\n+    }\n+\n+    /// Forwards to the method defined on the type `Any`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn downcast_ref<T: 'static>(&self) -> Option<&T> {\n+        Any::downcast_ref::<T>(self)\n+    }\n+\n+    /// Forwards to the method defined on the type `Any`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn downcast_mut<T: 'static>(&mut self) -> Option<&mut T> {\n+        Any::downcast_mut::<T>(self)\n+    }\n+}\n+\n+\n ///////////////////////////////////////////////////////////////////////////////\n // TypeID and its methods\n ///////////////////////////////////////////////////////////////////////////////"}, {"sha": "f705cc8ed99fe5b1f2d973d9b24b89b42a39a6c4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -1102,6 +1102,11 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                         this.emit_enum_variant_arg(1, |this| Ok(this.emit_ty(ecx, self_ty)))\n                     })\n                 }\n+                ty::UnsizeUpcast(target_ty) => {\n+                    this.emit_enum_variant(\"UnsizeUpcast\", 3, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_ty(ecx, target_ty)))\n+                    })\n+                }\n             }\n         });\n     }\n@@ -1707,7 +1712,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_unsize_kind<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                 -> ty::UnsizeKind<'tcx> {\n         self.read_enum(\"UnsizeKind\", |this| {\n-            let variants = &[\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\"];\n+            let variants = &[\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\", \"UnsizeUpcast\"];\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n@@ -1741,6 +1746,11 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                             this.read_enum_variant_arg(1, |this| Ok(this.read_ty(dcx))).unwrap();\n                         ty::UnsizeVtable(ty_trait, self_ty)\n                     }\n+                    3 => {\n+                        let target_ty =\n+                            this.read_enum_variant_arg(0, |this| Ok(this.read_ty(dcx))).unwrap();\n+                        ty::UnsizeUpcast(target_ty)\n+                    }\n                     _ => panic!(\"bad enum variant for ty::UnsizeKind\")\n                 })\n             })"}, {"sha": "c0d51f5675ca2e7b15b28cf8f1f46fed5c7dd5c7", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -857,36 +857,30 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     n: uint) {\n         debug!(\"walk_autoref expr={}\", expr.repr(self.tcx()));\n \n-        // Match for unique trait coercions first, since we don't need the\n-        // call to cat_expr_autoderefd.\n-        match *autoref {\n-            ty::AutoUnsizeUniq(ty::UnsizeVtable(..)) |\n-            ty::AutoUnsize(ty::UnsizeVtable(..)) => {\n-                assert!(n == 1, format!(\"Expected exactly 1 deref with Uniq \\\n-                                         AutoRefs, found: {}\", n));\n-                let cmt_unadjusted =\n-                    return_if_err!(self.mc.cat_expr_unadjusted(expr));\n-                self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n-                return;\n-            }\n-            _ => {}\n-        }\n-\n-        let cmt_derefd = return_if_err!(\n-            self.mc.cat_expr_autoderefd(expr, n));\n-        debug!(\"walk_adjustment: cmt_derefd={}\",\n-               cmt_derefd.repr(self.tcx()));\n-\n         match *autoref {\n             ty::AutoPtr(r, m, _) => {\n+                let cmt_derefd = return_if_err!(\n+                    self.mc.cat_expr_autoderefd(expr, n));\n+                debug!(\"walk_adjustment: cmt_derefd={}\",\n+                       cmt_derefd.repr(self.tcx()));\n+\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n                                      cmt_derefd,\n                                      r,\n                                      ty::BorrowKind::from_mutbl(m),\n                                      AutoRef);\n             }\n-            ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) | ty::AutoUnsafe(..) => {}\n+            ty::AutoUnsize(_) |\n+            ty::AutoUnsizeUniq(_) => {\n+                assert!(n == 1, format!(\"Expected exactly 1 deref with Uniq \\\n+                                         AutoRefs, found: {}\", n));\n+                let cmt_unadjusted =\n+                    return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+                self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n+            }\n+            ty::AutoUnsafe(..) => {\n+            }\n         }\n     }\n "}, {"sha": "438b61f918a1e3924750a7fc9680a91caed1a39d", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -314,9 +314,18 @@ pub trait Combine<'tcx> : Sized {\n     }\n \n     fn builtin_bounds(&self,\n-                      a: ty::BuiltinBounds,\n-                      b: ty::BuiltinBounds)\n-                      -> cres<'tcx, ty::BuiltinBounds>;\n+                      a: BuiltinBounds,\n+                      b: BuiltinBounds)\n+                      -> cres<'tcx, BuiltinBounds>\n+    {\n+        // Two sets of builtin bounds are only relatable if they are\n+        // precisely the same (but see the coercion code).\n+        if a != b {\n+            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n \n     fn trait_refs(&self,\n                   a: &ty::TraitRef<'tcx>,"}, {"sha": "2f9f8532b6c52caa1d0a65e5568481845fd95874", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use middle::infer::combine::*;\n@@ -73,23 +72,6 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         }\n     }\n \n-    fn builtin_bounds(&self,\n-                      a: BuiltinBounds,\n-                      b: BuiltinBounds)\n-                      -> cres<'tcx, BuiltinBounds>\n-    {\n-        // More bounds is a subtype of fewer bounds.\n-        //\n-        // e.g., fn:Copy() <: fn(), because the former is a function\n-        // that only closes over copyable things, but the latter is\n-        // any function at all.\n-        if a != b {\n-            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n-        } else {\n-            Ok(a)\n-        }\n-    }\n-\n     fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));"}, {"sha": "ba073999ed127ebc3d51ecd805be6bf559713c6e", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -14,7 +14,6 @@ use super::higher_ranked::HigherRankedRelations;\n use super::{cres};\n use super::Subtype;\n \n-use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n use syntax::ast::{MutImmutable, MutMutable, Unsafety};\n use util::ppaux::mt_to_string;\n@@ -94,15 +93,6 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         }\n     }\n \n-    fn builtin_bounds(&self,\n-                      a: ty::BuiltinBounds,\n-                      b: ty::BuiltinBounds)\n-                      -> cres<'tcx, ty::BuiltinBounds> {\n-        // More bounds is a subtype of fewer bounds, so\n-        // the GLB (mutual subtype) is the union.\n-        Ok(a.union(b))\n-    }\n-\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),"}, {"sha": "37eace0b15b6d4d9246e9f268b3956c1c3e55a99", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -14,7 +14,6 @@ use super::lattice::*;\n use super::{cres};\n use super::{Subtype};\n \n-use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n use syntax::ast::{MutMutable, MutImmutable, Unsafety};\n use util::ppaux::mt_to_string;\n@@ -89,15 +88,6 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         }\n     }\n \n-    fn builtin_bounds(&self,\n-                      a: ty::BuiltinBounds,\n-                      b: ty::BuiltinBounds)\n-                      -> cres<'tcx, ty::BuiltinBounds> {\n-        // More bounds is a subtype of fewer bounds, so\n-        // the LUB (mutual supertype) is the intersection.\n-        Ok(a.intersection(b))\n-    }\n-\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),"}, {"sha": "8ab063686d4bc20e27f27788645f7db3a34f1640", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -14,7 +14,6 @@ use super::higher_ranked::HigherRankedRelations;\n use super::{Subtype};\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n-use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use util::ppaux::{Repr};\n@@ -97,20 +96,6 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         })\n     }\n \n-    fn builtin_bounds(&self, a: BuiltinBounds, b: BuiltinBounds)\n-                      -> cres<'tcx, BuiltinBounds> {\n-        // More bounds is a subtype of fewer bounds.\n-        //\n-        // e.g., fn:Copy() <: fn(), because the former is a function\n-        // that only closes over copyable things, but the latter is\n-        // any function at all.\n-        if a.is_superset(&b) {\n-            Ok(a)\n-        } else {\n-            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n-        }\n-    }\n-\n     fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.tcx()), b.repr(self.tcx()));"}, {"sha": "8cc188e5df5b015fdc7258bc08037fdd80013750", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -292,7 +292,8 @@ pub enum UnsizeKind<'tcx> {\n     // An unsize coercion applied to the tail field of a struct.\n     // The uint is the index of the type parameter which is unsized.\n     UnsizeStruct(Box<UnsizeKind<'tcx>>, uint),\n-    UnsizeVtable(TyTrait<'tcx>, /* the self type of the trait */ Ty<'tcx>)\n+    UnsizeVtable(TyTrait<'tcx>, /* the self type of the trait */ Ty<'tcx>),\n+    UnsizeUpcast(Ty<'tcx>),\n }\n \n #[derive(Clone, Debug)]\n@@ -4631,6 +4632,9 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n         &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n             mk_trait(cx, principal.clone(), bounds.clone())\n         }\n+        &UnsizeUpcast(target_ty) => {\n+            target_ty\n+        }\n     }\n }\n \n@@ -6853,6 +6857,7 @@ impl<'tcx> Repr<'tcx> for UnsizeKind<'tcx> {\n             UnsizeLength(n) => format!(\"UnsizeLength({})\", n),\n             UnsizeStruct(ref k, n) => format!(\"UnsizeStruct({},{})\", k.repr(tcx), n),\n             UnsizeVtable(ref a, ref b) => format!(\"UnsizeVtable({},{})\", a.repr(tcx), b.repr(tcx)),\n+            UnsizeUpcast(ref a) => format!(\"UnsizeUpcast({})\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "f17ba78007bb2270eacd8b47a26ac605068b7a3c", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -480,6 +480,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::UnsizeKind<'tcx> {\n                     },\n                     self_ty.fold_with(folder))\n             }\n+            ty::UnsizeUpcast(t) => ty::UnsizeUpcast(t.fold_with(folder)),\n         }\n     }\n }"}, {"sha": "e9b0291704042406960bffd0993ec5cc32219a8e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -1214,17 +1214,17 @@ impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut res = Vec::new();\n \n-        let region_str = self.region_bound.user_string(tcx);\n+        let region_str = self.region_bound.repr(tcx);\n         if !region_str.is_empty() {\n             res.push(region_str);\n         }\n \n         for bound in &self.builtin_bounds {\n-            res.push(bound.user_string(tcx));\n+            res.push(bound.repr(tcx));\n         }\n \n         for projection_bound in &self.projection_bounds {\n-            res.push(projection_bound.user_string(tcx));\n+            res.push(projection_bound.repr(tcx));\n         }\n \n         res.connect(\"+\")"}, {"sha": "6ff230b7065da46e46b24a71db3127ea63e5df84", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -311,12 +311,16 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     llconst = addr_of(cx, llconst, \"autoref\", e.id);\n                 }\n                 Some(box ty::AutoUnsize(ref k)) => {\n-                    let info = expr::unsized_info(cx, k, e.id, ty, param_substs,\n-                        |t| ty::mk_imm_rptr(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), t));\n+                    let info =\n+                        expr::unsized_info(\n+                            cx, k, e.id, ty, param_substs,\n+                            |t| ty::mk_imm_rptr(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), t),\n+                            || const_get_elt(cx, llconst, &[abi::FAT_PTR_EXTRA as u32]));\n \n                     let unsized_ty = ty::unsize_ty(cx.tcx(), ty, k, e.span);\n                     let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n                     let base = ptrcast(llconst, ptr_ty);\n+\n                     let prev_const = cx.const_unsized().borrow_mut()\n                                        .insert(base, llconst);\n                     assert!(prev_const.is_none() || prev_const == Some(llconst));"}, {"sha": "da2b5a43b48cce3ebc2f917f0020ea9b83050327", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 70, "deletions": 21, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -287,18 +287,50 @@ pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n \n // Retrieve the information we are losing (making dynamic) in an unsizing\n // adjustment.\n+//\n // When making a dtor, we need to do different things depending on the\n // ownership of the object.. mk_ty is a function for turning `unadjusted_ty`\n // into a type to be destructed. If we want to end up with a Box pointer,\n // then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n // borrowed reference then it should be T -> &T.\n-pub fn unsized_info<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n-                                 kind: &ty::UnsizeKind<'tcx>,\n-                                 id: ast::NodeId,\n-                                 unadjusted_ty: Ty<'tcx>,\n-                                 param_substs: &'tcx subst::Substs<'tcx>,\n-                                 mk_ty: F) -> ValueRef where\n-    F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n+//\n+// The `unadjusted_val` argument is a bit funny. It is intended\n+// for use in an upcast, where the new vtable for an object will\n+// be drived from the old one. Hence it is a pointer to the fat\n+// pointer.\n+pub fn unsized_info_bcx<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                       kind: &ty::UnsizeKind<'tcx>,\n+                                       id: ast::NodeId,\n+                                       unadjusted_ty: Ty<'tcx>,\n+                                       unadjusted_val: ValueRef, // see above (*)\n+                                       param_substs: &'tcx subst::Substs<'tcx>,\n+                                       mk_ty: F)\n+                                       -> ValueRef\n+    where F: FnOnce(Ty<'tcx>) -> Ty<'tcx>\n+{\n+    unsized_info(\n+        bcx.ccx(),\n+        kind,\n+        id,\n+        unadjusted_ty,\n+        param_substs,\n+        mk_ty,\n+        || Load(bcx, GEPi(bcx, unadjusted_val, &[0, abi::FAT_PTR_EXTRA])))\n+}\n+\n+// Same as `unsize_info_bcx`, but does not require a bcx -- instead it\n+// takes an extra closure to compute the upcast vtable.\n+pub fn unsized_info<'ccx, 'tcx, MK_TY, MK_UPCAST_VTABLE>(\n+    ccx: &CrateContext<'ccx, 'tcx>,\n+    kind: &ty::UnsizeKind<'tcx>,\n+    id: ast::NodeId,\n+    unadjusted_ty: Ty<'tcx>,\n+    param_substs: &'tcx subst::Substs<'tcx>,\n+    mk_ty: MK_TY,\n+    mk_upcast_vtable: MK_UPCAST_VTABLE) // see notes above\n+    -> ValueRef\n+    where MK_TY: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n+          MK_UPCAST_VTABLE: FnOnce() -> ValueRef,\n {\n     // FIXME(#19596) workaround: `|t| t` causes monomorphization recursion\n     fn identity<T>(t: T) -> T { t }\n@@ -312,7 +344,8 @@ pub fn unsized_info<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n                 let ty_substs = substs.types.get_slice(subst::TypeSpace);\n                 // The dtor for a field treats it like a value, so mk_ty\n                 // should just be the identity function.\n-                unsized_info(ccx, k, id, ty_substs[tp_index], param_substs, identity)\n+                unsized_info(ccx, k, id, ty_substs[tp_index], param_substs,\n+                             identity, mk_upcast_vtable)\n             }\n             _ => ccx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n                                          unadjusted_ty.repr(ccx.tcx())))\n@@ -330,6 +363,12 @@ pub fn unsized_info<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n             consts::ptrcast(meth::get_vtable(ccx, box_ty, trait_ref, param_substs),\n                             Type::vtable_ptr(ccx))\n         }\n+        &ty::UnsizeUpcast(_) => {\n+            // For now, upcasts are limited to changes in marker\n+            // traits, and hence never actually require an actual\n+            // change to the vtable.\n+            mk_upcast_vtable()\n+        }\n     }\n }\n \n@@ -338,7 +377,8 @@ pub fn unsized_info<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  expr: &ast::Expr,\n                                  datum: Datum<'tcx, Expr>)\n-                                 -> DatumBlock<'blk, 'tcx, Expr> {\n+                                 -> DatumBlock<'blk, 'tcx, Expr>\n+{\n     let mut bcx = bcx;\n     let mut datum = datum;\n     let adjustment = match bcx.tcx().adjustments.borrow().get(&expr.id).cloned() {\n@@ -347,10 +387,10 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         Some(adj) => { adj }\n     };\n-    debug!(\"unadjusted datum for expr {}: {}, adjustment={}\",\n+    debug!(\"unadjusted datum for expr {}: {} adjustment={:?}\",\n            expr.repr(bcx.tcx()),\n            datum.to_string(bcx.ccx()),\n-           adjustment.repr(bcx.tcx()));\n+           adjustment);\n     match adjustment {\n         AdjustReifyFnPointer(_def_id) => {\n             // FIXME(#19925) once fn item types are\n@@ -434,7 +474,6 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 debug!(\"  AutoUnsize\");\n                 unpack_datum!(bcx, unsize_expr(bcx, expr, datum, k))\n             }\n-\n             &ty::AutoUnsizeUniq(ty::UnsizeLength(len)) => {\n                 debug!(\"  AutoUnsizeUniq(UnsizeLength)\");\n                 unpack_datum!(bcx, unsize_unique_vec(bcx, expr, datum, len))\n@@ -459,16 +498,27 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n         debug!(\"unsized_ty={}\", unsized_ty.repr(bcx.tcx()));\n \n-        let info = unsized_info(bcx.ccx(), k, expr.id, datum_ty, bcx.fcx.param_substs,\n-                                |t| ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), t));\n+        let info = unsized_info_bcx(bcx, k, expr.id, datum_ty, datum.val, bcx.fcx.param_substs,\n+                                    |t| ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), t));\n \n         // Arrange cleanup\n-        let lval = unpack_datum!(bcx,\n-                                 datum.to_lvalue_datum(bcx, \"into_fat_ptr\", expr.id));\n+        let lval = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"into_fat_ptr\", expr.id));\n+\n         // Compute the base pointer. This doesn't change the pointer value,\n         // but merely its type.\n         let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), unsized_ty).ptr_to();\n-        let base = PointerCast(bcx, lval.val, ptr_ty);\n+        let base = if !type_is_sized(bcx.tcx(), lval.ty) {\n+            // Normally, the source is a thin pointer and we are\n+            // adding extra info to make a fat pointer. The exception\n+            // is when we are upcasting an existing object fat pointer\n+            // to use a different vtable. In that case, we want to\n+            // load out the original data pointer so we can repackage\n+            // it.\n+            Load(bcx, get_dataptr(bcx, lval.val))\n+        } else {\n+            lval.val\n+        };\n+        let base = PointerCast(bcx, base, ptr_ty);\n \n         let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n         // HACK(eddyb) get around issues with lifetime intrinsics.\n@@ -540,8 +590,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let base = PointerCast(bcx, get_dataptr(bcx, scratch.val), llbox_ty.ptr_to());\n         bcx = datum.store_to(bcx, base);\n \n-        let info = unsized_info(bcx.ccx(), k, expr.id, unboxed_ty, bcx.fcx.param_substs,\n-                                |t| ty::mk_uniq(tcx, t));\n+        let info = unsized_info_bcx(bcx, k, expr.id, unboxed_ty, base, bcx.fcx.param_substs,\n+                                    |t| ty::mk_uniq(tcx, t));\n         Store(bcx, info, get_len(bcx, scratch.val));\n \n         DatumBlock::new(bcx, scratch.to_expr_datum())\n@@ -1373,8 +1423,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                     let def = tcx.def_map.borrow()[node_id].full_def();\n                     match def {\n                         def::DefVariant(enum_id, variant_id, _) => {\n-                            let variant_info = ty::enum_variant_with_id(\n-                                tcx, enum_id, variant_id);\n+                            let variant_info = ty::enum_variant_with_id(tcx, enum_id, variant_id);\n                             let fields = struct_fields(tcx, variant_id, substs);\n                             let fields = monomorphize::normalize_associated_type(tcx, &fields);\n                             op(variant_info.disr_val, &fields[..])"}, {"sha": "4e42ec61011ba2839720b4e3537c2616a96f9e86", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -334,15 +334,33 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     let ty = ty::mk_vec(tcx, t_a, None);\n                     Some((ty, ty::UnsizeLength(len)))\n                 }\n-                (&ty::ty_trait(..), &ty::ty_trait(..)) => {\n-                    None\n+                (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n+                    // For now, we only support upcasts from\n+                    // `Foo+Send` to `Foo` (really, any time there are\n+                    // fewer builtin bounds then before). These are\n+                    // convenient because they don't require any sort\n+                    // of change to the vtable at runtime.\n+                    if data_a.bounds.builtin_bounds != data_b.bounds.builtin_bounds &&\n+                        data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds)\n+                    {\n+                        let bounds_a1 = ty::ExistentialBounds {\n+                            region_bound: data_a.bounds.region_bound,\n+                            builtin_bounds: data_b.bounds.builtin_bounds,\n+                            projection_bounds: data_a.bounds.projection_bounds.clone(),\n+                        };\n+                        let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n+                        match self.fcx.infcx().try(|_| self.subtype(ty_a1, ty_b)) {\n+                            Ok(_) => Some((ty_b, ty::UnsizeUpcast(ty_b))),\n+                            Err(_) => None,\n+                        }\n+                    } else {\n+                        None\n+                    }\n                 }\n-                (_, &ty::ty_trait(box ty::TyTrait { ref principal, ref bounds })) => {\n-                    // FIXME what is the purpose of `ty`?\n-                    let ty = ty::mk_trait(tcx, principal.clone(), bounds.clone());\n-                    Some((ty, ty::UnsizeVtable(ty::TyTrait { principal: principal.clone(),\n-                                                             bounds: bounds.clone() },\n-                                               ty_a)))\n+                (_, &ty::ty_trait(ref data)) => {\n+                    Some((ty_b, ty::UnsizeVtable(ty::TyTrait { principal: data.principal.clone(),\n+                                                               bounds: data.bounds.clone() },\n+                                                 ty_a)))\n                 }\n                 (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n                   if did_a == did_b => {"}, {"sha": "6aefcf5a47cc6ed5417bd535b9add00974f4482b", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -176,13 +176,13 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             probe::AutoDeref(num) => {\n                 ty::AutoDerefRef {\n                     autoderefs: num,\n-                    autoref: None\n+                    autoref: None,\n                 }\n             }\n             probe::AutoUnsizeLength(autoderefs, len) => {\n                 ty::AutoDerefRef {\n                     autoderefs: autoderefs,\n-                    autoref: Some(ty::AutoUnsize(ty::UnsizeLength(len)))\n+                    autoref: Some(ty::AutoUnsize(ty::UnsizeLength(len))),\n                 }\n             }\n             probe::AutoRef(mutability, ref sub_adjustment) => {"}, {"sha": "bc581a6af4154c516b2279fb0079a5e02e412243", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -933,7 +933,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         return self.pick_method(step.self_ty).map(|r| self.adjust(r, adjustment.clone()));\n \n-        fn consider_reborrow(ty: Ty, d: uint) -> PickAdjustment {\n+        fn consider_reborrow<'tcx>(ty: Ty<'tcx>, d: uint) -> PickAdjustment {\n             // Insert a `&*` or `&mut *` if this is a reference type:\n             match ty.sty {\n                 ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n@@ -978,7 +978,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn adjust(&mut self,\n               result: PickResult<'tcx>,\n               adjustment: PickAdjustment)\n-              -> PickResult<'tcx> {\n+              -> PickResult<'tcx>\n+    {\n         match result {\n             Err(e) => Err(e),\n             Ok(mut pick) => {"}, {"sha": "31bee612b78d4912672221abdd8823d9adace9bf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -1592,6 +1592,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                       code: traits::ObjectCastObligation(self_ty) };\n                 self.register_region_obligation(self_ty, ty_trait.bounds.region_bound, cause);\n             }\n+            ty::UnsizeUpcast(_) => { }\n         }\n     }\n "}, {"sha": "32490e0dc7de2cc1201957dfd53ba08f7613d1df", "filename": "src/test/compile-fail/borrowck-consume-unsize-vec.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Ftest%2Fcompile-fail%2Fborrowck-consume-unsize-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Ftest%2Fcompile-fail%2Fborrowck-consume-unsize-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-consume-unsize-vec.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we report an error if an upcast box is moved twice.\n+\n+fn consume(_: Box<[i32]>) {\n+}\n+\n+fn foo(b: Box<[i32;5]>) {\n+    consume(b);\n+    consume(b); //~ ERROR use of moved value\n+}\n+\n+fn main() {\n+}"}, {"sha": "5bcafa675c7cb3093760b24b51f5a4e155829a8c", "filename": "src/test/compile-fail/borrowck-consume-upcast-box.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Ftest%2Fcompile-fail%2Fborrowck-consume-upcast-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Ftest%2Fcompile-fail%2Fborrowck-consume-upcast-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-consume-upcast-box.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we report an error if an upcast box is moved twice.\n+\n+trait Foo { fn dummy(&self); }\n+\n+fn consume(_: Box<Foo>) {\n+}\n+\n+fn foo(b: Box<Foo+Send>) {\n+    consume(b);\n+    consume(b); //~ ERROR use of moved value\n+}\n+\n+fn main() {\n+}"}, {"sha": "4ef07ecb4382f9ebc23b01482b96b9d2ab2cf233", "filename": "src/test/compile-fail/retslot-cast.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Ftest%2Fcompile-fail%2Fretslot-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9/src%2Ftest%2Fcompile-fail%2Fretslot-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fretslot-cast.rs?ref=c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "patch": "@@ -12,14 +12,20 @@\n #![allow(warnings)]\n \n pub fn fail(x: Option<& (Iterator+Send)>) -> Option<&Iterator> {\n-    // This call used to trigger an LLVM assertion because the return slot had type\n-    // \"Option<&Iterator>\"* instead of \"Option<&(Iterator+Send)>\"*\n-    inner(x)\n+    // This call used to trigger an LLVM assertion because the return\n+    // slot had type \"Option<&Iterator>\"* instead of\n+    // \"Option<&(Iterator+Send)>\"* -- but this now yields a\n+    // compilation error and I'm not sure how to create a comparable\n+    // test. To ensure that this PARTICULAR failure doesn't occur\n+    // again, though, I've left this test here, so if this ever starts\n+    // to compile again, we can adjust the test appropriately (clearly\n+    // it should never ICE...). -nmatsakis\n+    inner(x) //~ ERROR mismatched types\n }\n \n pub fn inner(x: Option<& (Iterator+Send)>) -> Option<&(Iterator+Send)> {\n     x\n }\n \n #[rustc_error]\n-fn main() {} //~ ERROR compilation successful\n+fn main() {}"}]}