{"sha": "9abc34ed9d34873066a186ac5551d5aad9e783b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhYmMzNGVkOWQzNDg3MzA2NmExODZhYzU1NTFkNWFhZDllNzgzYjY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-18T23:04:06Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-21T20:55:17Z"}, "message": "Track pointers to statics in MIR", "tree": {"sha": "15bd4c7bd6dba629cd16b586408b745d6fef5bdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15bd4c7bd6dba629cd16b586408b745d6fef5bdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9abc34ed9d34873066a186ac5551d5aad9e783b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9abc34ed9d34873066a186ac5551d5aad9e783b6", "html_url": "https://github.com/rust-lang/rust/commit/9abc34ed9d34873066a186ac5551d5aad9e783b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9abc34ed9d34873066a186ac5551d5aad9e783b6/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6d97dfd835b5d9a740249570e008eb94f1a9e85", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d97dfd835b5d9a740249570e008eb94f1a9e85", "html_url": "https://github.com/rust-lang/rust/commit/c6d97dfd835b5d9a740249570e008eb94f1a9e85"}], "stats": {"total": 658, "additions": 359, "deletions": 299}, "files": [{"sha": "2928a8ad9bcc52f82a3a1a31aaf88a5f1debe63d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 59, "deletions": 15, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -292,7 +292,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn temps_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n-            if self.local_decls[local].is_user_variable.is_some() {\n+            if self.local_decls[local].is_user_variable() {\n                 None\n             } else {\n                 Some(local)\n@@ -305,7 +305,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn vars_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n-            if self.local_decls[local].is_user_variable.is_some() {\n+            if self.local_decls[local].is_user_variable() {\n                 Some(local)\n             } else {\n                 None\n@@ -319,7 +319,7 @@ impl<'tcx> Body<'tcx> {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             let decl = &self.local_decls[local];\n-            if decl.is_user_variable.is_some() && decl.mutability == Mutability::Mut {\n+            if decl.is_user_variable() && decl.mutability == Mutability::Mut {\n                 Some(local)\n             } else {\n                 None\n@@ -333,7 +333,7 @@ impl<'tcx> Body<'tcx> {\n         (1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             let decl = &self.local_decls[local];\n-            if (decl.is_user_variable.is_some() || index < self.arg_count + 1)\n+            if (decl.is_user_variable() || index < self.arg_count + 1)\n                 && decl.mutability == Mutability::Mut\n             {\n                 Some(local)\n@@ -696,7 +696,8 @@ pub struct LocalDecl<'tcx> {\n     /// therefore it need not be visible across crates. pnkfelix\n     /// currently hypothesized we *need* to wrap this in a\n     /// `ClearCrossCrate` as long as it carries as `HirId`.\n-    pub is_user_variable: Option<ClearCrossCrate<BindingForm<'tcx>>>,\n+    // FIXME(matthewjasper) Don't store in this in `Body`\n+    pub local_info: LocalInfo<'tcx>,\n \n     /// `true` if this is an internal local.\n     ///\n@@ -721,6 +722,7 @@ pub struct LocalDecl<'tcx> {\n     /// then it is a temporary created for evaluation of some\n     /// subexpression of some block's tail expression (with no\n     /// intervening statement context).\n+    // FIXME(matthewjasper) Don't store in this in `Body`\n     pub is_block_tail: Option<BlockTailInfo>,\n \n     /// The type of this local.\n@@ -730,6 +732,7 @@ pub struct LocalDecl<'tcx> {\n     /// e.g., via `let x: T`, then we carry that type here. The MIR\n     /// borrow checker needs this information since it can affect\n     /// region inference.\n+    // FIXME(matthewjasper) Don't store in this in `Body`\n     pub user_ty: UserTypeProjections,\n \n     /// The name of the local, used in debuginfo and pretty-printing.\n@@ -824,6 +827,17 @@ pub struct LocalDecl<'tcx> {\n     pub visibility_scope: SourceScope,\n }\n \n+/// Extra information about a local that's used for diagnostics.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub enum LocalInfo<'tcx> {\n+    /// A user-defined local variable or function parameter\n+    User(ClearCrossCrate<BindingForm<'tcx>>),\n+    /// A temporary created that references the static with the given `DefId`.\n+    StaticRef { def_id: DefId, is_thread_local: bool },\n+    /// Any other temporary, the return place, or an anonymous function parameter.\n+    Other,\n+}\n+\n impl<'tcx> LocalDecl<'tcx> {\n     /// Returns `true` only if local is a binding that can itself be\n     /// made mutable via the addition of the `mut` keyword, namely\n@@ -832,15 +846,17 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// - `let x = ...`,\n     /// - or `match ... { C(x) => ... }`\n     pub fn can_be_made_mutable(&self) -> bool {\n-        match self.is_user_variable {\n-            Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+        match self.local_info {\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n                 opt_match_place: _,\n                 pat_span: _,\n             }))) => true,\n \n-            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm))) => true,\n+            LocalInfo::User(\n+                ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm)),\n+            ) => true,\n \n             _ => false,\n         }\n@@ -850,16 +866,26 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// `ref mut ident` binding. (Such bindings cannot be made into\n     /// mutable bindings, but the inverse does not necessarily hold).\n     pub fn is_nonref_binding(&self) -> bool {\n-        match self.is_user_variable {\n-            Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+        match self.local_info {\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n                 opt_match_place: _,\n                 pat_span: _,\n             }))) => true,\n \n-            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(_))) => true,\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(_))) => true,\n+\n+            _ => false,\n+        }\n+    }\n \n+    /// Returns `true` if this variable is a named variable or function\n+    /// parameter declared by the user.\n+    #[inline]\n+    pub fn is_user_variable(&self) -> bool {\n+        match self.local_info {\n+            LocalInfo::User(_) => true,\n             _ => false,\n         }\n     }\n@@ -868,8 +894,26 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// expression that is used to access said variable for the guard of the\n     /// match arm.\n     pub fn is_ref_for_guard(&self) -> bool {\n-        match self.is_user_variable {\n-            Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) => true,\n+        match self.local_info {\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns `Some` if this is a reference to a static item that is used to\n+    /// access that static\n+    pub fn is_ref_to_static(&self) -> bool {\n+        match self.local_info {\n+            LocalInfo::StaticRef { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns `Some` if this is a reference to a static item that is used to\n+    /// access that static\n+    pub fn is_ref_to_thread_local(&self) -> bool {\n+        match self.local_info {\n+            LocalInfo::StaticRef { is_thread_local, .. } => is_thread_local,\n             _ => false,\n         }\n     }\n@@ -918,7 +962,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal,\n-            is_user_variable: None,\n+            local_info: LocalInfo::Other,\n             is_block_tail: None,\n         }\n     }\n@@ -937,7 +981,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             internal: false,\n             is_block_tail: None,\n             name: None, // FIXME maybe we do want some name here?\n-            is_user_variable: None,\n+            local_info: LocalInfo::Other,\n         }\n     }\n }"}, {"sha": "fc0e77aab43a4d9a38cebb573df5d6ba3475679c", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -691,7 +691,7 @@ macro_rules! make_mir_visitor {\n                     source_info,\n                     visibility_scope,\n                     internal: _,\n-                    is_user_variable: _,\n+                    local_info: _,\n                     is_block_tail: _,\n                 } = local_decl;\n "}, {"sha": "943234319906a28ea54cf6391604ef7e0567eb5f", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -189,8 +189,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n         location: mir::Location,\n     ) {\n         if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n-            if borrowed_place.ignore_borrow(\n-                self.tcx, self.body, &self.locals_state_at_exit) {\n+            if borrowed_place.ignore_borrow(self.tcx, self.body, &self.locals_state_at_exit) {\n+                debug!(\"ignoring_borrow of {:?}\", borrowed_place);\n                 return;\n             }\n "}, {"sha": "3595312f3f41b41bfa13e92a5d8838a032c2a60f", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -3,8 +3,8 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::{AsyncGeneratorKind, GeneratorKind};\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n-    FakeReadCause, Local, LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef,\n-    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceBase,\n+    PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n@@ -744,6 +744,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 projection: root_place_projection,\n             }, borrow_span));\n \n+        if let PlaceBase::Local(local) = borrow.borrowed_place.base {\n+            if self.body.local_decls[local].is_ref_to_thread_local() {\n+                let err = self.report_thread_local_value_does_not_live_long_enough(\n+                    drop_span,\n+                    borrow_span,\n+                );\n+                err.buffer(&mut self.errors_buffer);\n+                return;\n+            }\n+        };\n+\n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n             self.classify_drop_access_kind(borrow.borrowed_place.as_ref())\n         {\n@@ -770,9 +781,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             explanation\n         );\n         let err = match (place_desc, explanation) {\n-            (Some(_), _) if self.is_place_thread_local(root_place) => {\n-                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n-            }\n             // If the outlives constraint comes from inside the closure,\n             // for example:\n             //\n@@ -1509,19 +1517,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // place being assigned later.\n         let (place_description, assigned_span) = match local_decl {\n             Some(LocalDecl {\n-                is_user_variable: Some(ClearCrossCrate::Clear),\n+                local_info: LocalInfo::User(ClearCrossCrate::Clear),\n                 ..\n             })\n             | Some(LocalDecl {\n-                is_user_variable:\n-                    Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                        opt_match_place: None,\n-                        ..\n-                    }))),\n+                local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                    opt_match_place: None,\n+                    ..\n+                }))),\n+                ..\n+            })\n+            | Some(LocalDecl {\n+                local_info: LocalInfo::StaticRef { .. },\n                 ..\n             })\n             | Some(LocalDecl {\n-                is_user_variable: None,\n+                local_info: LocalInfo::Other,\n                 ..\n             })\n             | None => (self.describe_place(place.as_ref()), assigned_span),"}, {"sha": "3835503b0ef35fdf8597ad6e40e2ca75ed22cbc9", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 26, "deletions": 52, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::def::Namespace;\n use rustc::hir::def_id::DefId;\n use rustc::hir::GeneratorKind;\n use rustc::mir::{\n-    AggregateKind, Constant, Field, Local, LocalKind, Location, Operand,\n+    AggregateKind, Constant, Field, Local, LocalInfo, LocalKind, Location, Operand,\n     Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind,\n     Static, StaticKind, Terminator, TerminatorKind,\n };\n@@ -12,7 +12,6 @@ use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n-use syntax::symbol::sym;\n \n use super::borrow_set::BorrowData;\n use super::MirBorrowckCtxt;\n@@ -178,6 +177,31 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } => {\n                 buf.push_str(&self.infcx.tcx.item_name(*def_id).to_string());\n             }\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref]\n+            } if self.body.local_decls[local].is_ref_for_guard() => {\n+                self.append_place_to_string(\n+                    PlaceRef {\n+                        base: &PlaceBase::Local(local),\n+                        projection: &[],\n+                    },\n+                    buf,\n+                    autoderef,\n+                    &including_downcast,\n+                )?;\n+            },\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref]\n+            } if self.body.local_decls[local].is_ref_to_static() => {\n+                let local_info = &self.body.local_decls[local].local_info;\n+                if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n+                    buf.push_str(&self.infcx.tcx.item_name(def_id).as_str());\n+                } else {\n+                    unreachable!();\n+                }\n+            },\n             PlaceRef {\n                 base,\n                 projection: [proj_base @ .., elem],\n@@ -208,32 +232,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 )?;\n                             } else {\n                                 match (proj_base, base) {\n-                                    ([], PlaceBase::Local(local)) => {\n-                                        if self.body.local_decls[*local].is_ref_for_guard() {\n-                                            self.append_place_to_string(\n-                                                PlaceRef {\n-                                                    base,\n-                                                    projection: proj_base,\n-                                                },\n-                                                buf,\n-                                                autoderef,\n-                                                &including_downcast,\n-                                            )?;\n-                                        } else {\n-                                            // FIXME deduplicate this and the _ => body below\n-                                            buf.push_str(&\"*\");\n-                                            self.append_place_to_string(\n-                                                PlaceRef {\n-                                                    base,\n-                                                    projection: proj_base,\n-                                                },\n-                                                buf,\n-                                                autoderef,\n-                                                &including_downcast,\n-                                            )?;\n-                                        }\n-                                    }\n-\n                                     _ => {\n                                         buf.push_str(&\"*\");\n                                         self.append_place_to_string(\n@@ -440,30 +438,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    /// Checks if a place is a thread-local static.\n-    pub fn is_place_thread_local(&self, place_ref: PlaceRef<'cx, 'tcx>) -> bool {\n-        if let PlaceRef {\n-            base: PlaceBase::Static(box Static {\n-                kind: StaticKind::Static,\n-                def_id,\n-                ..\n-            }),\n-            projection: [],\n-        } = place_ref {\n-            let attrs = self.infcx.tcx.get_attrs(*def_id);\n-            let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n-\n-            debug!(\n-                \"is_place_thread_local: attrs={:?} is_thread_local={:?}\",\n-                attrs, is_thread_local\n-            );\n-            is_thread_local\n-        } else {\n-            debug!(\"is_place_thread_local: no\");\n-            false\n-        }\n-    }\n-\n     /// Add a note that a type does not implement `Copy`\n     pub(super) fn note_type_does_not_implement_copy(\n         &self,"}, {"sha": "8e34eb6f413d8657c2f4d73fd72561c078b3130c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -308,7 +308,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // would have a chance of erroneously adding non-user-defined mutable vars\n     // to the set.\n     let temporary_used_locals: FxHashSet<Local> = mbcx.used_mut.iter()\n-        .filter(|&local| mbcx.body.local_decls[*local].is_user_variable.is_none())\n+        .filter(|&local| !mbcx.body.local_decls[*local].is_user_variable())\n         .cloned()\n         .collect();\n     // For the remaining unused locals that are marked as mutable, we avoid linting any that\n@@ -1287,7 +1287,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match *operand {\n             Operand::Move(ref place) | Operand::Copy(ref place) => {\n                 match place.as_local() {\n-                    Some(local) if self.body.local_decls[local].is_user_variable.is_none() => {\n+                    Some(local) if !self.body.local_decls[local].is_user_variable() => {\n                         if self.body.local_decls[local].ty.is_mutable_ptr() {\n                             // The variable will be marked as mutable by the borrow.\n                             return;\n@@ -1399,34 +1399,29 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n-        let root_place = self.prefixes(place.as_ref(), PrefixSet::All).last().unwrap();\n+        let deref = [ProjectionElem::Deref];\n+        let mut root_place = PlaceRef { base: &place.base, projection: &[] };\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n         // we'll have a memory leak) and assume that all statics have a destructor.\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n-        assert!(root_place.projection.is_empty());\n         let (might_be_alive, will_be_dropped) = match root_place.base {\n-            PlaceBase::Static(box Static {\n-                kind: StaticKind::Promoted(..),\n-                ..\n-            }) => {\n+            PlaceBase::Static(_) => {\n                 (true, false)\n             }\n-            PlaceBase::Static(box Static {\n-                kind: StaticKind::Static,\n-                ..\n-            }) => {\n-                // Thread-locals might be dropped after the function exits, but\n-                // \"true\" statics will never be.\n-                (true, self.is_place_thread_local(root_place))\n-            }\n-            PlaceBase::Local(_) => {\n-                // Locals are always dropped at function exit, and if they\n-                // have a destructor it would've been called already.\n-                (false, self.locals_are_invalidated_at_exit)\n+            PlaceBase::Local(local) => {\n+                if self.body.local_decls[*local].is_ref_to_thread_local() {\n+                    // Thread-locals might be dropped after the function exits\n+                    // We have to dereference the outer reference because\n+                    // borrows don't conflict behind shared references.\n+                    root_place.projection = &deref;\n+                    (true, true)\n+                } else {\n+                    (false, self.locals_are_invalidated_at_exit)\n+                }\n             }\n         };\n "}, {"sha": "b1f63d729ba9b027ce5fb0fe79d51e9f4c0b7a5e", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -104,13 +104,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         //\n                         // opt_match_place is None for let [mut] x = ... statements,\n                         // whether or not the right-hand side is a place expression\n-                        if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                            opt_match_place: Some((ref opt_match_place, match_span)),\n-                            binding_mode: _,\n-                            opt_ty_info: _,\n-                            pat_span: _,\n-                        }))) = local_decl.is_user_variable\n-                        {\n+                        if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                            VarBindingForm {\n+                                opt_match_place: Some((ref opt_match_place, match_span)),\n+                                binding_mode: _,\n+                                opt_ty_info: _,\n+                                pat_span: _,\n+                            },\n+                        ))) = local_decl.local_info {\n                             let stmt_source_info = self.body.source_info(location);\n                             self.append_binding_error(\n                                 grouped_errors,\n@@ -242,7 +243,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             (\n                 match kind {\n                     IllegalMoveOriginKind::Static => {\n-                        self.report_cannot_move_from_static(original_path, span)\n+                        unreachable!();\n                     }\n                     IllegalMoveOriginKind::BorrowedContent { target_place } => {\n                         self.report_cannot_move_from_borrowed_content(\n@@ -272,12 +273,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         place: &Place<'tcx>,\n         span: Span\n     ) -> DiagnosticBuilder<'a> {\n-        let description = if place.projection.is_empty() {\n+        let description = if place.projection.len() == 1 {\n             format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n         } else {\n             let base_static = PlaceRef {\n                 base: &place.base,\n-                projection: &place.projection[..1],\n+                projection: &[ProjectionElem::Deref],\n             };\n \n             format!(\n@@ -327,6 +328,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     \"variables bound in patterns cannot be moved from \\\n                      until after the end of the pattern guard\");\n                 return err;\n+            } else if decl.is_ref_to_static() {\n+                return self.report_cannot_move_from_static(move_place, span);\n             }\n         }\n \n@@ -508,12 +511,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut suggestions: Vec<(Span, &str, String)> = Vec::new();\n         for local in binds_to {\n             let bind_to = &self.body.local_decls[*local];\n-            if let Some(\n+            if let LocalInfo::User(\n                 ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                     pat_span,\n                     ..\n                 }))\n-            ) = bind_to.is_user_variable {\n+            ) = bind_to.local_info {\n                 if let Ok(pat_snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(pat_span)\n                 {\n                     if pat_snippet.starts_with('&') {"}, {"sha": "404684c07a09c6a45805e10ab3534fcdda8b8c14", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 53, "deletions": 71, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -1,9 +1,7 @@\n use rustc::hir;\n use rustc::hir::Node;\n-use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Body};\n-use rustc::mir::{\n-    Mutability, Place, PlaceRef, PlaceBase, ProjectionElem, Static, StaticKind\n-};\n+use rustc::mir::{self, Body, ClearCrossCrate, Local, LocalInfo, Location};\n+use rustc::mir::{Mutability, Place, PlaceRef, PlaceBase, ProjectionElem};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_index::vec::Idx;\n use syntax_pos::Span;\n@@ -76,6 +74,31 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref],\n+            } if self.body.local_decls[local].is_ref_for_guard() => {\n+                item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                reason = \", as it is immutable for the pattern guard\".to_string();\n+            }\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref],\n+            } if self.body.local_decls[local].is_ref_to_static() => {\n+                if access_place.projection.len() == 1 {\n+                    item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n+                    reason = String::new();\n+                } else {\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    let local_info = &self.body.local_decls[local].local_info;\n+                    if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n+                        let static_name = &self.infcx.tcx.item_name(def_id);\n+                        reason = format!(\", as `{}` is an immutable static item\", static_name);\n+                    } else {\n+                        bug!(\"is_ref_to_static return true, but not ref to static?\");\n+                    }\n+                }\n+            }\n             PlaceRef {\n                 base: _,\n                 projection: [proj_base @ .., ProjectionElem::Deref],\n@@ -101,15 +124,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         } else {\n                             \", as `Fn` closures cannot mutate their captured variables\".to_string()\n                         }\n-                } else if {\n-                    if let (PlaceBase::Local(local), []) = (&the_place_err.base, proj_base) {\n-                        self.body.local_decls[*local].is_ref_for_guard()\n-                    } else {\n-                        false\n-                    }\n-                } {\n-                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    reason = \", as it is immutable for the pattern guard\".to_string();\n                 } else {\n                     let source = self.borrowed_content_source(PlaceRef {\n                         base: the_place_err.base,\n@@ -133,37 +147,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef {\n-                base:\n-                    PlaceBase::Static(box Static {\n-                        kind: StaticKind::Promoted(..),\n-                        ..\n-                    }),\n-                projection: [],\n-            } => unreachable!(),\n-\n-            PlaceRef {\n-                base:\n-                    PlaceBase::Static(box Static {\n-                        kind: StaticKind::Static,\n-                        def_id,\n-                        ..\n-                    }),\n-                projection: [],\n-            } => {\n-                if let PlaceRef {\n-                    base: &PlaceBase::Static(_),\n-                    projection: &[],\n-                } = access_place.as_ref() {\n-                    item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n-                    reason = String::new();\n-                } else {\n-                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    let static_name = &self.infcx.tcx.item_name(*def_id);\n-                    reason = format!(\", as `{}` is an immutable static item\", static_name);\n-                }\n+                base: PlaceBase::Static(_),\n+                ..\n             }\n-\n-            PlaceRef {\n+            | PlaceRef {\n                 base: _,\n                 projection: [.., ProjectionElem::Index(_)],\n             }\n@@ -257,15 +244,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [],\n             } if {\n                 self.body.local_decls.get(*local).map(|local_decl| {\n-                    if let ClearCrossCrate::Set(\n+                    if let LocalInfo::User(ClearCrossCrate::Set(\n                         mir::BindingForm::ImplicitSelf(kind)\n-                    ) = local_decl.is_user_variable.as_ref().unwrap() {\n+                    )) = local_decl.local_info {\n                         // Check if the user variable is a `&mut self` and we can therefore\n                         // suggest removing the `&mut`.\n                         //\n                         // Deliberately fall into this case for all implicit self types,\n                         // so that we don't fall in to the next case with them.\n-                        *kind == mir::ImplicitSelfKind::MutRef\n+                        kind == mir::ImplicitSelfKind::MutRef\n                     } else if Some(kw::SelfLower) == local_decl.name {\n                         // Otherwise, check if the name is the self kewyord - in which case\n                         // we have an explicit self. Do the same thing in this case and check\n@@ -360,16 +347,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [ProjectionElem::Deref],\n-            } if {\n-                if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n-                    self.body.local_decls[*local].is_user_variable\n-                {\n-                    true\n-                } else {\n-                    false\n-                }\n-            } =>\n-            {\n+            } if self.body.local_decls[*local].is_ref_for_guard() => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.note(\n                     \"variables bound in patterns are immutable until the end of the pattern guard\",\n@@ -384,38 +362,42 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [ProjectionElem::Deref],\n-            } if self.body.local_decls[*local].is_user_variable.is_some() =>\n+            } if self.body.local_decls[*local].is_user_variable() =>\n             {\n                 let local_decl = &self.body.local_decls[*local];\n-                let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n-                    ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_)) => {\n+                let suggestion = match local_decl.local_info {\n+                    LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_))) => {\n                         Some(suggest_ampmut_self(self.infcx.tcx, local_decl))\n                     }\n \n-                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                        binding_mode: ty::BindingMode::BindByValue(_),\n-                        opt_ty_info,\n-                        ..\n-                    })) => Some(suggest_ampmut(\n+                    LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n+                        mir::VarBindingForm {\n+                            binding_mode: ty::BindingMode::BindByValue(_),\n+                            opt_ty_info,\n+                            ..\n+                        },\n+                    ))) => Some(suggest_ampmut(\n                         self.infcx.tcx,\n                         self.body,\n                         *local,\n                         local_decl,\n-                        *opt_ty_info,\n+                        opt_ty_info,\n                     )),\n \n-                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                        binding_mode: ty::BindingMode::BindByReference(_),\n-                        ..\n-                    })) => {\n+                    LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n+                        mir::VarBindingForm {\n+                            binding_mode: ty::BindingMode::BindByReference(_),\n+                            ..\n+                        },\n+                    ))) => {\n                         let pattern_span = local_decl.source_info.span;\n                         suggest_ref_mut(self.infcx.tcx, pattern_span)\n                             .map(|replacement| (pattern_span, replacement))\n                     }\n \n-                    ClearCrossCrate::Set(mir::BindingForm::RefForGuard) => unreachable!(),\n+                    LocalInfo::User(ClearCrossCrate::Clear) => bug!(\"saw cleared local state\"),\n \n-                    ClearCrossCrate::Clear => bug!(\"saw cleared local state\"),\n+                    _ => unreachable!(),\n                 };\n \n                 let (pointer_sigil, pointer_desc) = if local_decl.ty.is_region_ptr() {"}, {"sha": "99bcfa9bc25995a3babf96a08d11565e51b14463", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -1387,7 +1387,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     } else {\n                         ConstraintCategory::Return\n                     },\n-                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -1693,7 +1693,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             ConstraintCategory::Return\n                         }\n                     }\n-                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,"}, {"sha": "c62de2af55f449c5218f7df0cfdf04b0861bbebf", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Body, Place, PlaceBase, Mutability, Static, StaticKind};\n+use rustc::mir::{Body, Place, PlaceBase, Mutability};\n use rustc::ty::{self, TyCtxt};\n use crate::borrow_check::borrow_set::LocalsStateAtExit;\n \n@@ -25,7 +25,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n-        let ignore = match self.base {\n+        let local = match self.base {\n             // If a local variable is immutable, then we only need to track borrows to guard\n             // against two kinds of errors:\n             // * The variable being dropped while still borrowed (e.g., because the fn returns\n@@ -34,45 +34,56 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n             //\n             // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n             // so we don't have to worry about mutation while borrowed.\n-            PlaceBase::Local(index) => {\n+            PlaceBase::Local(local) => {\n                 match locals_state_at_exit {\n-                    LocalsStateAtExit::AllAreInvalidated => false,\n+                    LocalsStateAtExit::AllAreInvalidated => local,\n                     LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n-                        let ignore = !has_storage_dead_or_moved.contains(index) &&\n-                            body.local_decls[index].mutability == Mutability::Not;\n-                        debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n-                        ignore\n+                        let ignore = !has_storage_dead_or_moved.contains(local) &&\n+                            body.local_decls[local].mutability == Mutability::Not;\n+                        debug!(\"ignore_borrow: local {:?} => {:?}\", local, ignore);\n+                        if ignore {\n+                            return true;\n+                        } else {\n+                            local\n+                        }\n                     }\n                 }\n             }\n-            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) =>\n-                false,\n-            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n-                tcx.is_mutable_static(def_id)\n-            }\n+            PlaceBase::Static(_) => return true,\n         };\n \n         for (i, elem) in self.projection.iter().enumerate() {\n             let proj_base = &self.projection[..i];\n \n             if *elem == ProjectionElem::Deref {\n                 let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n-                if let ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Immutable) = ty.kind {\n-                    // For both derefs of raw pointers and `&T`\n-                    // references, the original path is `Copy` and\n-                    // therefore not significant.  In particular,\n-                    // there is nothing the user can do to the\n-                    // original path that would invalidate the\n-                    // newly created reference -- and if there\n-                    // were, then the user could have copied the\n-                    // original path into a new variable and\n-                    // borrowed *that* one, leaving the original\n-                    // path unborrowed.\n-                    return true;\n+                match ty.kind {\n+                    ty::Ref(_, _, hir::Mutability::Immutable) if i == 0 => {\n+                        // For references to thread-local statics, we do need\n+                        // to track the borrow.\n+                        if body.local_decls[local].is_ref_to_thread_local() {\n+                            continue;\n+                        }\n+                        return true;\n+                    }\n+                    ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Immutable) => {\n+                        // For both derefs of raw pointers and `&T`\n+                        // references, the original path is `Copy` and\n+                        // therefore not significant.  In particular,\n+                        // there is nothing the user can do to the\n+                        // original path that would invalidate the\n+                        // newly created reference -- and if there\n+                        // were, then the user could have copied the\n+                        // original path into a new variable and\n+                        // borrowed *that* one, leaving the original\n+                        // path unborrowed.\n+                        return true;\n+                    }\n+                    _ => {}\n                 }\n             }\n         }\n \n-        ignore\n+        false\n     }\n }"}, {"sha": "6db7ec65096ec1fc3777cad4ef50306a2ae2f117", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -45,6 +45,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     literal,\n                 }\n             },\n+            ExprKind::StaticRef { literal, .. } => {\n+                Constant {\n+                    span,\n+                    user_ty: None,\n+                    literal,\n+                }\n+            }\n             _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }\n     }"}, {"sha": "f66f1cb73666afdb428db5791c0e37cdb6da55d4", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -285,6 +285,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. }\n             | ExprKind::InlineAsm { .. }\n             | ExprKind::Yield { .. }\n             | ExprKind::Call { .. } => {"}, {"sha": "37eb0cc9d961e78a637d3d8d3a91e3f52fc2acdd", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -270,6 +270,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 resume.and(this.unit_rvalue())\n             }\n             ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. }\n             | ExprKind::Block { .. }\n             | ExprKind::Match { .. }\n             | ExprKind::NeverToAny { .. }"}, {"sha": "864b449c29c9e5ebe83d65d5b7f04dc58e702081", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -6,6 +6,7 @@ use crate::hair::*;\n use rustc::hir;\n use rustc::middle::region;\n use rustc::mir::*;\n+use syntax_pos::symbol::sym;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n@@ -63,6 +64,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if let Some(tail_info) = this.block_context.currently_in_block_tail() {\n                 local_decl = local_decl.block_tail(tail_info);\n             }\n+            if let ExprKind::StaticRef { def_id, .. } = expr.kind {\n+                let attrs = this.hir.tcx().get_attrs(def_id);\n+                let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n+                local_decl.local_info = LocalInfo::StaticRef {def_id, is_thread_local };\n+            }\n             this.local_decls.push(local_decl)\n         };\n         let temp_place = &Place::from(temp);"}, {"sha": "270a1a6447435361555bcf3deed948b2ae45e62a", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -65,7 +65,8 @@ impl Category {\n             | ExprKind::Yield { .. }\n             | ExprKind::InlineAsm { .. } => Some(Category::Rvalue(RvalueFunc::AsRvalue)),\n \n-            ExprKind::Literal { .. } => Some(Category::Constant),\n+            ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. } => Some(Category::Constant),\n \n             ExprKind::Loop { .. }\n             | ExprKind::Block { .. }"}, {"sha": "e991181189f412bc8c7fc2974f5013a2ffeae748", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         source_info,\n                         visibility_scope: source_info.scope,\n                         internal: true,\n-                        is_user_variable: None,\n+                        local_info: LocalInfo::Other,\n                         is_block_tail: None,\n                     });\n                     let ptr_temp = Place::from(ptr_temp);\n@@ -425,6 +425,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Tuple { .. }\n             | ExprKind::Closure { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. }\n             | ExprKind::Yield { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {\n                     // should be handled above"}, {"sha": "ada547aa39c9e70f5920072b162220bbfbc9fa08", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -458,10 +458,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for binding in &candidate.bindings {\n                 let local = self.var_local_id(binding.var_id, OutsideGuard);\n \n-                if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                     opt_match_place: Some((ref mut match_place, _)),\n                     ..\n-                }))) = self.local_decls[local].is_user_variable\n+                }))) = self.local_decls[local].local_info\n                 {\n                     *match_place = Some(initializer.clone());\n                 } else {\n@@ -1734,16 +1734,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             visibility_scope,\n             internal: false,\n             is_block_tail: None,\n-            is_user_variable: Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                binding_mode,\n-                // hypothetically, `visit_bindings` could try to unzip\n-                // an outermost hir::Ty as we descend, matching up\n-                // idents in pat; but complex w/ unclear UI payoff.\n-                // Instead, just abandon providing diagnostic info.\n-                opt_ty_info: None,\n-                opt_match_place,\n-                pat_span,\n-            }))),\n+            local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                VarBindingForm {\n+                    binding_mode,\n+                    // hypothetically, `visit_bindings` could try to unzip\n+                    // an outermost hir::Ty as we descend, matching up\n+                    // idents in pat; but complex w/ unclear UI payoff.\n+                    // Instead, just abandon providing diagnostic info.\n+                    opt_ty_info: None,\n+                    opt_match_place,\n+                    pat_span,\n+                },\n+            ))),\n         };\n         let for_arm_body = self.local_decls.push(local);\n         let locals = if has_guard.0 {\n@@ -1758,7 +1760,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 visibility_scope,\n                 internal: false,\n                 is_block_tail: None,\n-                is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n+                local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n             LocalsForNode::ForGuard {\n                 ref_for_guard,"}, {"sha": "6b458cc244c9e3195564c8cdd060c1206baf8964", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -820,7 +820,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 visibility_scope: source_info.scope,\n                 name,\n                 internal: false,\n-                is_user_variable: None,\n+                local_info: LocalInfo::Other,\n                 is_block_tail: None,\n             });\n         }\n@@ -855,17 +855,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     } => {\n                         self.local_decls[local].mutability = mutability;\n                         self.local_decls[local].source_info.scope = self.source_scope;\n-                        self.local_decls[local].is_user_variable =\n+                        self.local_decls[local].local_info =\n                             if let Some(kind) = self_binding {\n-                                Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(*kind)))\n+                                LocalInfo::User(ClearCrossCrate::Set(\n+                                    BindingForm::ImplicitSelf(*kind),\n+                                ))\n                             } else {\n                                 let binding_mode = ty::BindingMode::BindByValue(mutability.into());\n-                                Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                                    binding_mode,\n-                                    opt_ty_info,\n-                                    opt_match_place: Some((Some(place.clone()), span)),\n-                                    pat_span: span,\n-                                })))\n+                                LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                                    VarBindingForm {\n+                                        binding_mode,\n+                                        opt_ty_info,\n+                                        opt_match_place: Some((Some(place.clone()), span)),\n+                                        pat_span: span,\n+                                    },\n+                                )))\n                             };\n                         self.var_indices.insert(var, LocalsForNode::One(local));\n                     }"}, {"sha": "402e5aeacbf245acb264ef3b5f12522b37a19e70", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -209,7 +209,9 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n             // local must conflict. This is purely an optimization so we don't have to call\n             // `places_conflict` for every borrow.\n             if place.projection.is_empty() {\n-                trans.kill_all(other_borrows_of_local);\n+                if !self.body.local_decls[local].is_ref_to_static() {\n+                    trans.kill_all(other_borrows_of_local);\n+                }\n                 return;\n             }\n "}, {"sha": "f47c92cbd542dc39cbcf6ffe18319a9b30327ca4", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -264,6 +264,11 @@ pub enum ExprKind<'tcx> {\n         literal: &'tcx Const<'tcx>,\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n+    /// A literal containing the address of a `static`\n+    StaticRef {\n+        literal: &'tcx Const<'tcx>,\n+        def_id: DefId,\n+    },\n     InlineAsm {\n         asm: &'tcx hir::InlineAsmInner,\n         outputs: Vec<ExprRef<'tcx>>,"}, {"sha": "17f5e3d4e47a982a990117e2cb680e505da784da", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -152,7 +152,7 @@ fn temp_decl(mutability: Mutability, ty: Ty<'_>, span: Span) -> LocalDecl<'_> {\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other,\n         is_block_tail: None,\n     }\n }"}, {"sha": "bee37f69a5ec5640a6c8ab09637e310da058ac3e", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -1,6 +1,6 @@\n //! The `Visitor` responsible for actually checking a `mir::Body` for invalid operations.\n \n-use rustc::hir::HirId;\n+use rustc::hir::{HirId, def_id::DefId};\n use rustc::middle::lang_items;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;\n@@ -288,6 +288,15 @@ impl Validator<'a, 'mir, 'tcx> {\n         let span = self.span;\n         self.check_op_spanned(op, span)\n     }\n+\n+    fn check_static(&mut self, def_id: DefId, span: Span) -> CheckOpResult {\n+        let is_thread_local = self.tcx.has_attr(def_id, sym::thread_local);\n+        if is_thread_local {\n+            self.check_op_spanned(ops::ThreadLocalAccess, span)\n+        } else {\n+            self.check_op_spanned(ops::StaticAccess, span)\n+        }\n+    }\n }\n \n impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n@@ -422,12 +431,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         self.super_operand(op, location);\n         if let Operand::Constant(c) = op {\n             if let Some(def_id) = c.check_static_ptr(self.tcx) {\n-                let is_thread_local = self.tcx.has_attr(def_id, sym::thread_local);\n-                if is_thread_local {\n-                    self.check_op(ops::ThreadLocalAccess);\n-                } else {\n-                    self.check_op(ops::StaticAccess);\n-                }\n+                self.check_static(def_id, self.span);\n             }\n         }\n     }\n@@ -506,14 +510,24 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match elem {\n             ProjectionElem::Deref => {\n-                if context.is_mutating_use() {\n-                    self.check_op(ops::MutDeref);\n-                }\n-\n                 let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n+                    if proj_base.is_empty() {\n+                        if let (PlaceBase::Local(local), []) = (place_base, proj_base) {\n+                            let decl = &self.body.local_decls[*local];\n+                            if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n+                                let span = decl.source_info.span;\n+                                self.check_static(def_id, span);\n+                                return;\n+                            }\n+                        }\n+                    }\n                     self.check_op(ops::RawPtrDeref);\n                 }\n+\n+                if context.is_mutating_use() {\n+                    self.check_op(ops::MutDeref);\n+                }\n             }\n \n             ProjectionElem::ConstantIndex {..} |"}, {"sha": "b7cc4e9fcf66cb772cfe199f12c833343c358014", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -206,25 +206,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 // Locals are safe.\n             }\n             PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => {\n-                bug!(\"unsafety checking should happen before promotion\")\n+                bug!(\"unsafety checking should happen before promotion\");\n             }\n-            PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n-                if self.tcx.is_mutable_static(def_id) {\n-                    self.require_unsafe(\n-                        \"use of mutable static\",\n-                        \"mutable statics can be mutated by multiple threads: aliasing \\\n-                        violations or data races will cause undefined behavior\",\n-                        UnsafetyViolationKind::General,\n-                    );\n-                } else if self.tcx.is_foreign_item(def_id) {\n-                    self.require_unsafe(\n-                        \"use of extern static\",\n-                        \"extern statics are not controlled by the Rust type system: \\\n-                        invalid data, aliasing violations or data races will cause \\\n-                        undefined behavior\",\n-                        UnsafetyViolationKind::General,\n-                    );\n-                }\n+            PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n+                bug!(\"StaticKind::Static should not exist\");\n             }\n         }\n \n@@ -264,11 +249,31 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n             let old_source_info = self.source_info;\n             if let (PlaceBase::Local(local), []) = (&place.base, proj_base) {\n-                if self.body.local_decls[*local].internal {\n+                let decl = &self.body.local_decls[*local];\n+                if decl.internal {\n                     // Internal locals are used in the `move_val_init` desugaring.\n                     // We want to check unsafety against the source info of the\n                     // desugaring, rather than the source info of the RHS.\n                     self.source_info = self.body.local_decls[*local].source_info;\n+                } else if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n+                    if self.tcx.is_mutable_static(def_id) {\n+                        self.require_unsafe(\n+                            \"use of mutable static\",\n+                            \"mutable statics can be mutated by multiple threads: aliasing \\\n+                        violations or data races will cause undefined behavior\",\n+                            UnsafetyViolationKind::General,\n+                        );\n+                        return;\n+                    } else if self.tcx.is_foreign_item(def_id) {\n+                        self.require_unsafe(\n+                            \"use of extern static\",\n+                            \"extern statics are not controlled by the Rust type system: \\\n+                        invalid data, aliasing violations or data races will cause \\\n+                        undefined behavior\",\n+                            UnsafetyViolationKind::General,\n+                        );\n+                        return;\n+                    }\n                 }\n             }\n             let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;"}, {"sha": "524b6b087908ce4b7ac57ac5e5e0ba79cac3a6f8", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -432,7 +432,7 @@ fn replace_result_variable<'tcx>(\n         visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other\n     };\n     let new_ret_local = Local::new(body.local_decls.len());\n     body.local_decls.push(new_ret);\n@@ -967,7 +967,7 @@ fn create_generator_drop_shim<'tcx>(\n         visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other\n     };\n \n     make_generator_state_argument_indirect(tcx, def_id, &mut body);\n@@ -985,7 +985,7 @@ fn create_generator_drop_shim<'tcx>(\n         visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other\n     };\n     if tcx.sess.opts.debugging_opts.mir_emit_retag {\n         // Alias tracking must know we changed the type"}, {"sha": "86ecfbb4fbea59af92f71b2bb0bf1ca70ba89b5d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9abc34ed9d34873066a186ac5551d5aad9e783b6/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=9abc34ed9d34873066a186ac5551d5aad9e783b6", "patch": "@@ -512,34 +512,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 projection: [],\n             } => self.validate_local(*local),\n             PlaceRef {\n-                base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted { .. },\n-                    ..\n-                }),\n+                base: PlaceBase::Static(_),\n                 projection: [],\n             } => bug!(\"qualifying already promoted MIR\"),\n-            PlaceRef {\n-                base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Static,\n-                    def_id,\n-                    ..\n-                }),\n-                projection: [],\n-            } => {\n-                // Only allow statics (not consts) to refer to other statics.\n-                // FIXME(eddyb) does this matter at all for promotion?\n-                let is_static = self.const_kind.map_or(false, |k| k.is_static());\n-                if !is_static {\n-                    return Err(Unpromotable);\n-                }\n-\n-                let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n-                if is_thread_local {\n-                    return Err(Unpromotable);\n-                }\n-\n-                Ok(())\n-            }\n             PlaceRef {\n                 base: _,\n                 projection: [proj_base @ .., elem],\n@@ -584,7 +559,23 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n             // The qualifs for a constant (e.g. `HasMutInterior`) are checked in\n             // `validate_rvalue` upon access.\n-            Operand::Constant(_) => Ok(()),\n+            Operand::Constant(c) => {\n+                if let Some(def_id) = c.check_static_ptr(self.tcx) {\n+                    // Only allow statics (not consts) to refer to other statics.\n+                    // FIXME(eddyb) does this matter at all for promotion?\n+                    let is_static = self.const_kind.map_or(false, |k| k.is_static());\n+                    if !is_static {\n+                        return Err(Unpromotable);\n+                    }\n+\n+                    let is_thread_local = self.tcx.has_attr(def_id, sym::thread_local);\n+                    if is_thread_local {\n+                        return Err(Unpromotable);\n+                    }\n+                }\n+\n+                Ok(())\n+            },\n         }\n     }\n "}]}