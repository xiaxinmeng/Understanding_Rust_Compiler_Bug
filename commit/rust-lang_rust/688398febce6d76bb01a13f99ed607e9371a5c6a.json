{"sha": "688398febce6d76bb01a13f99ed607e9371a5c6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ODM5OGZlYmNlNmQ3NmJiMDFhMTNmOTllZDYwN2U5MzcxYTVjNmE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-02T23:33:34Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-02T23:33:34Z"}, "message": "feat: Implement `inline_method` assist", "tree": {"sha": "6e25539cce515341a735bc31617c6ab9fa6b6ef2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e25539cce515341a735bc31617c6ab9fa6b6ef2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/688398febce6d76bb01a13f99ed607e9371a5c6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/688398febce6d76bb01a13f99ed607e9371a5c6a", "html_url": "https://github.com/rust-lang/rust/commit/688398febce6d76bb01a13f99ed607e9371a5c6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/688398febce6d76bb01a13f99ed607e9371a5c6a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbdcb49d483bb305f9abc7bb23a1d096ccd0481b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbdcb49d483bb305f9abc7bb23a1d096ccd0481b", "html_url": "https://github.com/rust-lang/rust/commit/fbdcb49d483bb305f9abc7bb23a1d096ccd0481b"}], "stats": {"total": 372, "additions": 300, "deletions": 72}, "files": [{"sha": "4886b599be0404eba8fbe4f997bc1cdb72f89d1f", "filename": "crates/ide_assists/src/handlers/early_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=688398febce6d76bb01a13f99ed607e9371a5c6a", "patch": "@@ -127,7 +127,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n                         let happy_arm = {\n                             let pat = make::tuple_struct_pat(\n                                 path,\n-                                once(make::ident_pat(make::name(\"it\")).into()),\n+                                once(make::ext::simple_ident_pat(make::name(\"it\")).into()),\n                             );\n                             let expr = {\n                                 let path = make::ext::ident_path(\"it\");"}, {"sha": "14dea0989f8c67246426aba46af98b5215b990f6", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=688398febce6d76bb01a13f99ed607e9371a5c6a", "patch": "@@ -341,9 +341,9 @@ impl Param {\n         let var = self.var.name(ctx.db()).unwrap().to_string();\n         let var_name = make::name(&var);\n         let pat = match self.kind() {\n-            ParamKind::MutValue => make::ident_mut_pat(var_name),\n+            ParamKind::MutValue => make::ident_pat(false, true, var_name),\n             ParamKind::Value | ParamKind::SharedRef | ParamKind::MutRef => {\n-                make::ident_pat(var_name)\n+                make::ext::simple_ident_pat(var_name)\n             }\n         };\n \n@@ -1072,7 +1072,7 @@ impl FlowHandler {\n             }\n             FlowHandler::IfOption { action } => {\n                 let path = make::ext::ident_path(\"Some\");\n-                let value_pat = make::ident_pat(make::name(\"value\"));\n+                let value_pat = make::ext::simple_ident_pat(make::name(\"value\"));\n                 let pattern = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n                 let cond = make::condition(call_expr, Some(pattern.into()));\n                 let value = make::expr_path(make::ext::ident_path(\"value\"));\n@@ -1086,7 +1086,7 @@ impl FlowHandler {\n \n                 let some_arm = {\n                     let path = make::ext::ident_path(\"Some\");\n-                    let value_pat = make::ident_pat(make::name(some_name));\n+                    let value_pat = make::ext::simple_ident_pat(make::name(some_name));\n                     let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n                     let value = make::expr_path(make::ext::ident_path(some_name));\n                     make::match_arm(iter::once(pat.into()), None, value)\n@@ -1105,14 +1105,14 @@ impl FlowHandler {\n \n                 let ok_arm = {\n                     let path = make::ext::ident_path(\"Ok\");\n-                    let value_pat = make::ident_pat(make::name(ok_name));\n+                    let value_pat = make::ext::simple_ident_pat(make::name(ok_name));\n                     let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n                     let value = make::expr_path(make::ext::ident_path(ok_name));\n                     make::match_arm(iter::once(pat.into()), None, value)\n                 };\n                 let err_arm = {\n                     let path = make::ext::ident_path(\"Err\");\n-                    let value_pat = make::ident_pat(make::name(err_name));\n+                    let value_pat = make::ext::simple_ident_pat(make::name(err_name));\n                     let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n                     let value = make::expr_path(make::ext::ident_path(err_name));\n                     make::match_arm("}, {"sha": "c4bd5eaa7b70798c219e4525efebab6d42085f94", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=688398febce6d76bb01a13f99ed607e9371a5c6a", "patch": "@@ -262,8 +262,9 @@ fn build_pat(db: &RootDatabase, module: hir::Module, var: ExtendedVariant) -> Op\n                     make::tuple_struct_pat(path, pats).into()\n                 }\n                 ast::StructKind::Record(field_list) => {\n-                    let pats =\n-                        field_list.fields().map(|f| make::ident_pat(f.name().unwrap()).into());\n+                    let pats = field_list\n+                        .fields()\n+                        .map(|f| make::ext::simple_ident_pat(f.name().unwrap()).into());\n                     make::record_pat(path, pats).into()\n                 }\n                 ast::StructKind::Unit => make::path_pat(path),"}, {"sha": "60cf49988e17c62b73da3a620bd2b9f009194b1d", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=688398febce6d76bb01a13f99ed607e9371a5c6a", "patch": "@@ -256,10 +256,9 @@ fn fn_args(\n         });\n     }\n     deduplicate_arg_names(&mut arg_names);\n-    let params = arg_names\n-        .into_iter()\n-        .zip(arg_types)\n-        .map(|(name, ty)| make::param(make::ident_pat(make::name(&name)).into(), make::ty(&ty)));\n+    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| {\n+        make::param(make::ext::simple_ident_pat(make::name(&name)).into(), make::ty(&ty))\n+    });\n     Some((None, make::param_list(None, params)))\n }\n "}, {"sha": "b00569bf01e49094a99431e5294cbd55954e4ff4", "filename": "crates/ide_assists/src/handlers/inline_function.rs", "status": "modified", "additions": 267, "deletions": 46, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_function.rs?ref=688398febce6d76bb01a13f99ed607e9371a5c6a", "patch": "@@ -2,14 +2,64 @@ use ast::make;\n use hir::{HasSource, PathResolution};\n use syntax::{\n     ast::{self, edit::AstNodeEdit, ArgListOwner},\n-    AstNode,\n+    ted, AstNode,\n };\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n     AssistId, AssistKind,\n };\n \n+// Assist: inline_method\n+//\n+// Inlines a method body.\n+//\n+// ```\n+// struct Foo(u32);\n+// impl Foo {\n+//     fn add(self, a: u32) -> Self {\n+//         Foo(self.0 + a)\n+//     }\n+// }\n+// fn main() {\n+//     let x = Foo(3).add$0(2);\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Foo(u32);\n+// impl Foo {\n+//     fn add(self, a: u32) -> Self {\n+//         Foo(self.0 + a)\n+//     }\n+// }\n+// fn main() {\n+//     let x = {\n+//         let this = Foo(3);\n+//         let a = 2;\n+//         Foo(this.0 + a)\n+//     };\n+// }\n+// ```\n+pub(crate) fn inline_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let name_ref: ast::NameRef = ctx.find_node_at_offset()?;\n+    let call = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n+    let receiver = call.receiver()?;\n+    let function = ctx.sema.resolve_method_call(&call)?;\n+    let mut arguments = vec![receiver];\n+    arguments.extend(call.arg_list()?.args());\n+\n+    inline_(\n+        acc,\n+        ctx,\n+        \"inline_method\",\n+        &format!(\"Inline `{}`\", name_ref),\n+        function,\n+        arguments,\n+        ast::Expr::MethodCallExpr(call),\n+    )\n+}\n+\n // Assist: inline_function\n //\n // Inlines a function body.\n@@ -36,60 +86,95 @@ pub(crate) fn inline_function(acc: &mut Assists, ctx: &AssistContext) -> Option<\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let path = path_expr.path()?;\n \n-    let function = match ctx.sema.resolve_path(&path)? {\n-        PathResolution::Def(hir::ModuleDef::Function(f)) => f,\n+    let function = match dbg!(ctx.sema.resolve_path(&path)?) {\n+        PathResolution::Def(hir::ModuleDef::Function(f))\n+        | PathResolution::AssocItem(hir::AssocItem::Function(f)) => f,\n         _ => return None,\n     };\n+    inline_(\n+        acc,\n+        ctx,\n+        \"inline_function\",\n+        &format!(\"Inline `{}`\", path),\n+        function,\n+        call.arg_list()?.args().collect(),\n+        ast::Expr::CallExpr(call),\n+    )\n+}\n \n-    let function_source = function.source(ctx.db())?;\n-    let arguments: Vec<_> = call.arg_list()?.args().collect();\n-    let parameters = function_parameter_patterns(&function_source.value)?;\n+pub(crate) fn inline_(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+    assist_id: &'static str,\n+    label: &str,\n+    function: hir::Function,\n+    arg_list: Vec<ast::Expr>,\n+    expr: ast::Expr,\n+) -> Option<()> {\n+    let hir::InFile { value: function_source, .. } = function.source(ctx.db())?;\n+    let param_list = function_source.param_list()?;\n \n-    if arguments.len() != parameters.len() {\n+    let mut params = Vec::new();\n+    if let Some(self_param) = param_list.self_param() {\n+        // FIXME this should depend on the receiver as well as the self_param\n+        params.push(\n+            make::ident_pat(\n+                self_param.amp_token().is_some(),\n+                self_param.mut_token().is_some(),\n+                make::name(\"this\"),\n+            )\n+            .into(),\n+        );\n+    }\n+    for param in param_list.params() {\n+        params.push(param.pat()?);\n+    }\n+\n+    if arg_list.len() != params.len() {\n         // Can't inline the function because they've passed the wrong number of\n         // arguments to this function\n         cov_mark::hit!(inline_function_incorrect_number_of_arguments);\n         return None;\n     }\n \n-    let new_bindings = parameters.into_iter().zip(arguments);\n+    let new_bindings = params.into_iter().zip(arg_list);\n \n-    let body = function_source.value.body()?;\n+    let body = function_source.body()?;\n \n     acc.add(\n-        AssistId(\"inline_function\", AssistKind::RefactorInline),\n-        format!(\"Inline `{}`\", path),\n-        call.syntax().text_range(),\n+        AssistId(assist_id, AssistKind::RefactorInline),\n+        label,\n+        expr.syntax().text_range(),\n         |builder| {\n-            let mut statements: Vec<ast::Stmt> = Vec::new();\n+            // FIXME: emit type ascriptions when a coercion happens?\n+            let statements = new_bindings\n+                .map(|(pattern, value)| make::let_stmt(pattern, Some(value)).into())\n+                .chain(body.statements());\n \n-            for (pattern, value) in new_bindings {\n-                statements.push(make::let_stmt(pattern, Some(value)).into());\n-            }\n-\n-            statements.extend(body.statements());\n-\n-            let original_indentation = call.indent_level();\n-            let replacement = make::block_expr(statements, body.tail_expr())\n+            let original_indentation = expr.indent_level();\n+            let mut replacement = make::block_expr(statements, body.tail_expr())\n                 .reset_indent()\n                 .indent(original_indentation);\n \n-            builder.replace_ast(ast::Expr::CallExpr(call), ast::Expr::BlockExpr(replacement));\n+            if param_list.self_param().is_some() {\n+                replacement = replacement.clone_for_update();\n+                let this = make::name_ref(\"this\").syntax().clone_for_update();\n+                // FIXME dont look into descendant methods\n+                replacement\n+                    .syntax()\n+                    .descendants()\n+                    .filter_map(ast::NameRef::cast)\n+                    .filter(|n| n.self_token().is_some())\n+                    .collect::<Vec<_>>()\n+                    .into_iter()\n+                    .rev()\n+                    .for_each(|self_ref| ted::replace(self_ref.syntax(), &this));\n+            }\n+            builder.replace_ast(expr, ast::Expr::BlockExpr(replacement));\n         },\n     )\n }\n \n-fn function_parameter_patterns(value: &ast::Fn) -> Option<Vec<ast::Pat>> {\n-    let mut patterns = Vec::new();\n-\n-    for param in value.param_list()?.params() {\n-        let pattern = param.pat()?;\n-        patterns.push(pattern);\n-    }\n-\n-    Some(patterns)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -139,19 +224,6 @@ fn main() {\n         );\n     }\n \n-    #[test]\n-    fn method_inlining_isnt_supported() {\n-        check_assist_not_applicable(\n-            inline_function,\n-            r\"\n-struct Foo;\n-impl Foo { fn bar(&self) {} }\n-\n-fn main() { Foo.bar$0(); }\n-\",\n-        );\n-    }\n-\n     #[test]\n     fn not_applicable_when_incorrect_number_of_parameters_are_provided() {\n         cov_mark::check!(inline_function_incorrect_number_of_arguments);\n@@ -195,6 +267,155 @@ fn main() {\n         x * y\n     };\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn function_with_self_param() {\n+        check_assist(\n+            inline_function,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo::add$0(Foo(3), 2);\n+}\n+\"#,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = {\n+        let this = Foo(3);\n+        let a = 2;\n+        Foo(this.0 + a)\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_by_val() {\n+        check_assist(\n+            inline_method,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo(3).add$0(2);\n+}\n+\"#,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = {\n+        let this = Foo(3);\n+        let a = 2;\n+        Foo(this.0 + a)\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_by_ref() {\n+        check_assist(\n+            inline_method,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(&self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo(3).add$0(2);\n+}\n+\"#,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(&self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = {\n+        let ref this = Foo(3);\n+        let a = 2;\n+        Foo(this.0 + a)\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_by_ref_mut() {\n+        check_assist(\n+            inline_method,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn clear(&mut self) {\n+        self.0 = 0;\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo(3);\n+    foo.clear$0();\n+}\n+\"#,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn clear(&mut self) {\n+        self.0 = 0;\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo(3);\n+    {\n+        let ref mut this = foo;\n+        this.0 = 0;\n+    };\n+}\n \"#,\n         );\n     }"}, {"sha": "ccc8449775adfa5e8138e31a1dfd1713c6343b6b", "filename": "crates/ide_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=688398febce6d76bb01a13f99ed607e9371a5c6a", "patch": "@@ -52,7 +52,7 @@ pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext)\n         target,\n         |builder| {\n             let ok_path = make::ext::ident_path(happy_variant);\n-            let it = make::ident_pat(make::name(\"it\")).into();\n+            let it = make::ext::simple_ident_pat(make::name(\"it\")).into();\n             let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n             let bind_path = make::ext::ident_path(\"it\");"}, {"sha": "ac05491c6a8b1c0ac4a0da67a0abb97303dd635f", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=688398febce6d76bb01a13f99ed607e9371a5c6a", "patch": "@@ -156,6 +156,7 @@ mod handlers {\n             generate_setter::generate_setter,\n             infer_function_return_type::infer_function_return_type,\n             inline_function::inline_function,\n+            inline_function::inline_method,\n             inline_local_variable::inline_local_variable,\n             introduce_named_lifetime::introduce_named_lifetime,\n             invert_if::invert_if,"}, {"sha": "91f1d1cb7dbbc19631d2692ee12a93cddbb28b23", "filename": "crates/ide_db/src/ty_filter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_db%2Fsrc%2Fty_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fide_db%2Fsrc%2Fty_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fty_filter.rs?ref=688398febce6d76bb01a13f99ed607e9371a5c6a", "patch": "@@ -47,7 +47,7 @@ impl TryEnum {\n                 iter::once(make::wildcard_pat().into()),\n             )\n             .into(),\n-            TryEnum::Option => make::ident_pat(make::name(\"None\")).into(),\n+            TryEnum::Option => make::ext::simple_ident_pat(make::name(\"None\")).into(),\n         }\n     }\n "}, {"sha": "ea0f27756f3bb2e381f6c7f108418f5dac5df1ee", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688398febce6d76bb01a13f99ed607e9371a5c6a/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=688398febce6d76bb01a13f99ed607e9371a5c6a", "patch": "@@ -21,6 +21,13 @@ use crate::{ast, AstNode, SourceFile, SyntaxKind, SyntaxToken};\n pub mod ext {\n     use super::*;\n \n+    pub fn simple_ident_pat(name: ast::Name) -> ast::IdentPat {\n+        return from_text(&name.text());\n+\n+        fn from_text(text: &str) -> ast::IdentPat {\n+            ast_from_text(&format!(\"fn f({}: ())\", text))\n+        }\n+    }\n     pub fn ident_path(ident: &str) -> ast::Path {\n         path_unqualified(path_segment(name_ref(ident)))\n     }\n@@ -330,19 +337,18 @@ pub fn arg_list(args: impl IntoIterator<Item = ast::Expr>) -> ast::ArgList {\n     ast_from_text(&format!(\"fn main() {{ ()({}) }}\", args.into_iter().format(\", \")))\n }\n \n-pub fn ident_pat(name: ast::Name) -> ast::IdentPat {\n-    return from_text(&name.text());\n-\n-    fn from_text(text: &str) -> ast::IdentPat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+pub fn ident_pat(ref_: bool, mut_: bool, name: ast::Name) -> ast::IdentPat {\n+    use std::fmt::Write as _;\n+    let mut s = String::from(\"fn f(\");\n+    if ref_ {\n+        s.push_str(\"ref \");\n     }\n-}\n-pub fn ident_mut_pat(name: ast::Name) -> ast::IdentPat {\n-    return from_text(&name.text());\n-\n-    fn from_text(text: &str) -> ast::IdentPat {\n-        ast_from_text(&format!(\"fn f(mut {}: ())\", text))\n+    if mut_ {\n+        s.push_str(\"mut \");\n     }\n+    let _ = write!(s, \"{}\", name);\n+    s.push_str(\": ())\");\n+    ast_from_text(&s)\n }\n \n pub fn wildcard_pat() -> ast::WildcardPat {"}]}