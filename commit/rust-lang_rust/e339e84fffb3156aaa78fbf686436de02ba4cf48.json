{"sha": "e339e84fffb3156aaa78fbf686436de02ba4cf48", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMzllODRmZmZiMzE1NmFhYTc4ZmJmNjg2NDM2ZGUwMmJhNGNmNDg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-10T19:34:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-15T20:24:46Z"}, "message": "move `force_instantiate_unchecked` to be local to `nll_relate` code", "tree": {"sha": "5b616097f299c80f1be53f741fc5abcf5d87b701", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b616097f299c80f1be53f741fc5abcf5d87b701"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e339e84fffb3156aaa78fbf686436de02ba4cf48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e339e84fffb3156aaa78fbf686436de02ba4cf48", "html_url": "https://github.com/rust-lang/rust/commit/e339e84fffb3156aaa78fbf686436de02ba4cf48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e339e84fffb3156aaa78fbf686436de02ba4cf48/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7ed997d87a1769bd68a86412ae2a417e4d36b99", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7ed997d87a1769bd68a86412ae2a417e4d36b99", "html_url": "https://github.com/rust-lang/rust/commit/e7ed997d87a1769bd68a86412ae2a417e4d36b99"}], "stats": {"total": 120, "additions": 61, "deletions": 59}, "files": [{"sha": "fbd38ebd78cedcf8f33f60c04110d6650fa5a4e9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e339e84fffb3156aaa78fbf686436de02ba4cf48/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e339e84fffb3156aaa78fbf686436de02ba4cf48/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e339e84fffb3156aaa78fbf686436de02ba4cf48", "patch": "@@ -1231,65 +1231,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.inlined_shallow_resolve(typ)\n     }\n \n-    /// A hacky sort of method used by the NLL type-relating code:\n-    ///\n-    /// - `var` must be some unbound type variable.\n-    /// - `value` must be a suitable type to use as its value.\n-    ///\n-    /// `var` will then be equated with `value`. Note that this\n-    /// sidesteps a number of important checks, such as the \"occurs\n-    /// check\" that prevents cyclic types, so it is important not to\n-    /// use this method during regular type-check.\n-    fn force_instantiate_unchecked(&self, var: Ty<'tcx>, value: Ty<'tcx>) {\n-        match (&var.sty, &value.sty) {\n-            (&ty::Infer(ty::TyVar(vid)), _) => {\n-                let mut type_variables = self.type_variables.borrow_mut();\n-\n-                // In NLL, we don't have type inference variables\n-                // floating around, so we can do this rather imprecise\n-                // variant of the occurs-check.\n-                assert!(!value.has_infer_types());\n-\n-                type_variables.instantiate(vid, value);\n-            }\n-\n-            (&ty::Infer(ty::IntVar(vid)), &ty::Int(value)) => {\n-                let mut int_unification_table = self.int_unification_table.borrow_mut();\n-                int_unification_table\n-                    .unify_var_value(vid, Some(ty::IntVarValue::IntType(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n-                    });\n-            }\n-\n-            (&ty::Infer(ty::IntVar(vid)), &ty::Uint(value)) => {\n-                let mut int_unification_table = self.int_unification_table.borrow_mut();\n-                int_unification_table\n-                    .unify_var_value(vid, Some(ty::IntVarValue::UintType(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n-                    });\n-            }\n-\n-            (&ty::Infer(ty::FloatVar(vid)), &ty::Float(value)) => {\n-                let mut float_unification_table = self.float_unification_table.borrow_mut();\n-                float_unification_table\n-                    .unify_var_value(vid, Some(ty::FloatVarValue(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify float var `{:?}` with `{:?}`\", vid, value)\n-                    });\n-            }\n-\n-            _ => {\n-                bug!(\n-                    \"force_instantiate_unchecked invoked with bad combination: var={:?} value={:?}\",\n-                    var,\n-                    value,\n-                );\n-            }\n-        }\n-    }\n-\n     pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,"}, {"sha": "e003c1989e0963fdd709055e6e686f2aed8a83b5", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e339e84fffb3156aaa78fbf686436de02ba4cf48/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e339e84fffb3156aaa78fbf686436de02ba4cf48/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=e339e84fffb3156aaa78fbf686436de02ba4cf48", "patch": "@@ -673,3 +673,64 @@ where\n         Ok(ty::Binder::bind(result))\n     }\n }\n+\n+impl InferCtxt<'_, '_, 'tcx> {\n+    /// A hacky sort of method used by the NLL type-relating code:\n+    ///\n+    /// - `var` must be some unbound type variable.\n+    /// - `value` must be a suitable type to use as its value.\n+    ///\n+    /// `var` will then be equated with `value`. Note that this\n+    /// sidesteps a number of important checks, such as the \"occurs\n+    /// check\" that prevents cyclic types, so it is important not to\n+    /// use this method during regular type-check.\n+    fn force_instantiate_unchecked(&self, var: Ty<'tcx>, value: Ty<'tcx>) {\n+        match (&var.sty, &value.sty) {\n+            (&ty::Infer(ty::TyVar(vid)), _) => {\n+                let mut type_variables = self.type_variables.borrow_mut();\n+\n+                // In NLL, we don't have type inference variables\n+                // floating around, so we can do this rather imprecise\n+                // variant of the occurs-check.\n+                assert!(!value.has_infer_types());\n+\n+                type_variables.instantiate(vid, value);\n+            }\n+\n+            (&ty::Infer(ty::IntVar(vid)), &ty::Int(value)) => {\n+                let mut int_unification_table = self.int_unification_table.borrow_mut();\n+                int_unification_table\n+                    .unify_var_value(vid, Some(ty::IntVarValue::IntType(value)))\n+                    .unwrap_or_else(|_| {\n+                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n+                    });\n+            }\n+\n+            (&ty::Infer(ty::IntVar(vid)), &ty::Uint(value)) => {\n+                let mut int_unification_table = self.int_unification_table.borrow_mut();\n+                int_unification_table\n+                    .unify_var_value(vid, Some(ty::IntVarValue::UintType(value)))\n+                    .unwrap_or_else(|_| {\n+                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n+                    });\n+            }\n+\n+            (&ty::Infer(ty::FloatVar(vid)), &ty::Float(value)) => {\n+                let mut float_unification_table = self.float_unification_table.borrow_mut();\n+                float_unification_table\n+                    .unify_var_value(vid, Some(ty::FloatVarValue(value)))\n+                    .unwrap_or_else(|_| {\n+                        bug!(\"failed to unify float var `{:?}` with `{:?}`\", vid, value)\n+                    });\n+            }\n+\n+            _ => {\n+                bug!(\n+                    \"force_instantiate_unchecked invoked with bad combination: var={:?} value={:?}\",\n+                    var,\n+                    value,\n+                );\n+            }\n+        }\n+    }\n+}"}]}