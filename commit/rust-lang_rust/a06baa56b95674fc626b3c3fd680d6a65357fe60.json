{"sha": "a06baa56b95674fc626b3c3fd680d6a65357fe60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNmJhYTU2Yjk1Njc0ZmM2MjZiM2MzZmQ2ODBkNmE2NTM1N2ZlNjA=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-12-22T22:42:04Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-12-22T22:42:47Z"}, "message": "Format the world", "tree": {"sha": "cd9d867c2ca3cff5c1d6b3bd73377c44649fb075", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd9d867c2ca3cff5c1d6b3bd73377c44649fb075"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a06baa56b95674fc626b3c3fd680d6a65357fe60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a06baa56b95674fc626b3c3fd680d6a65357fe60", "html_url": "https://github.com/rust-lang/rust/commit/a06baa56b95674fc626b3c3fd680d6a65357fe60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a06baa56b95674fc626b3c3fd680d6a65357fe60/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eb7c58dbb7b32701af113bc58722d0d1fefb1eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb7c58dbb7b32701af113bc58722d0d1fefb1eb", "html_url": "https://github.com/rust-lang/rust/commit/8eb7c58dbb7b32701af113bc58722d0d1fefb1eb"}], "stats": {"total": 141024, "additions": 66321, "deletions": 74703}, "files": [{"sha": "cf77af44ff606b85776cc764c3b49220fae729a4", "filename": "src/bootstrap/bin/llvm-config-wrapper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -2,8 +2,8 @@\n // `src/bootstrap/native.rs` for why this is needed when compiling LLD.\n \n use std::env;\n-use std::process::{self, Stdio, Command};\n use std::io::{self, Write};\n+use std::process::{self, Command, Stdio};\n \n fn main() {\n     let real_llvm_config = env::var_os(\"LLVM_CONFIG_REAL\").unwrap();"}, {"sha": "b67486c9628cd6c60e90490fb0d58a4f3dd77cfc", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -7,7 +7,7 @@\n \n use std::env;\n \n-use bootstrap::{Config, Build};\n+use bootstrap::{Build, Config};\n \n fn main() {\n     let args = env::args().skip(1).collect::<Vec<_>>();"}, {"sha": "a34ec44566bc17e023d9c9c6f718f9beee3d53be", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -27,9 +27,7 @@ fn main() {\n \n     // Detect whether or not we're a build script depending on whether --target\n     // is passed (a bit janky...)\n-    let target = args.windows(2)\n-        .find(|w| &*w[0] == \"--target\")\n-        .and_then(|w| w[1].to_str());\n+    let target = args.windows(2).find(|w| &*w[0] == \"--target\").and_then(|w| w[1].to_str());\n     let version = args.iter().find(|w| &**w == \"-vV\");\n \n     let verbose = match env::var(\"RUSTC_VERBOSE\") {\n@@ -57,19 +55,16 @@ fn main() {\n     dylib_path.insert(0, PathBuf::from(&libdir));\n \n     let mut cmd = Command::new(rustc);\n-    cmd.args(&args)\n-        .env(bootstrap::util::dylib_path_var(),\n-             env::join_paths(&dylib_path).unwrap());\n+    cmd.args(&args).env(bootstrap::util::dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n     // Get the name of the crate we're compiling, if any.\n-    let crate_name = args.windows(2)\n-        .find(|args| args[0] == \"--crate-name\")\n-        .and_then(|args| args[1].to_str());\n+    let crate_name =\n+        args.windows(2).find(|args| args[0] == \"--crate-name\").and_then(|args| args[1].to_str());\n \n     if let Some(crate_name) = crate_name {\n         if let Some(target) = env::var_os(\"RUSTC_TIME\") {\n-            if target == \"all\" ||\n-                target.into_string().unwrap().split(\",\").any(|c| c.trim() == crate_name)\n+            if target == \"all\"\n+                || target.into_string().unwrap().split(\",\").any(|c| c.trim() == crate_name)\n             {\n                 cmd.arg(\"-Ztime\");\n             }\n@@ -101,15 +96,22 @@ fn main() {\n         // `compiler_builtins` are unconditionally compiled with panic=abort to\n         // workaround undefined references to `rust_eh_unwind_resume` generated\n         // otherwise, see issue https://github.com/rust-lang/rust/issues/43095.\n-        if crate_name == Some(\"panic_abort\") ||\n-           crate_name == Some(\"compiler_builtins\") && stage != \"0\" {\n+        if crate_name == Some(\"panic_abort\")\n+            || crate_name == Some(\"compiler_builtins\") && stage != \"0\"\n+        {\n             cmd.arg(\"-C\").arg(\"panic=abort\");\n         }\n \n         // Set various options from config.toml to configure how we're building\n         // code.\n         let debug_assertions = match env::var(\"RUSTC_DEBUG_ASSERTIONS\") {\n-            Ok(s) => if s == \"true\" { \"y\" } else { \"n\" },\n+            Ok(s) => {\n+                if s == \"true\" {\n+                    \"y\"\n+                } else {\n+                    \"n\"\n+                }\n+            }\n             Err(..) => \"n\",\n         };\n \n@@ -178,17 +180,17 @@ fn main() {\n     if env::var_os(\"RUSTC_PRINT_STEP_TIMINGS\").is_some() {\n         if let Some(crate_name) = crate_name {\n             let start = Instant::now();\n-            let status = cmd\n-                .status()\n-                .unwrap_or_else(|_| panic!(\"\\n\\n failed to run {:?}\", cmd));\n+            let status = cmd.status().unwrap_or_else(|_| panic!(\"\\n\\n failed to run {:?}\", cmd));\n             let dur = start.elapsed();\n \n             let is_test = args.iter().any(|a| a == \"--test\");\n-            eprintln!(\"[RUSTC-TIMING] {} test:{} {}.{:03}\",\n-                      crate_name,\n-                      is_test,\n-                      dur.as_secs(),\n-                      dur.subsec_nanos() / 1_000_000);\n+            eprintln!(\n+                \"[RUSTC-TIMING] {} test:{} {}.{:03}\",\n+                crate_name,\n+                is_test,\n+                dur.as_secs(),\n+                dur.subsec_nanos() / 1_000_000\n+            );\n \n             match status.code() {\n                 Some(i) => std::process::exit(i),"}, {"sha": "8c8b33a4e4e0a4222a9b966cfab4aa8496886ca0", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -3,9 +3,9 @@\n //! See comments in `src/bootstrap/rustc.rs` for more information.\n \n use std::env;\n-use std::process::Command;\n-use std::path::PathBuf;\n use std::ffi::OsString;\n+use std::path::PathBuf;\n+use std::process::Command;\n \n fn main() {\n     let args = env::args_os().skip(1).collect::<Vec<_>>();\n@@ -35,8 +35,7 @@ fn main() {\n         .arg(\"dox\")\n         .arg(\"--sysroot\")\n         .arg(&sysroot)\n-        .env(bootstrap::util::dylib_path_var(),\n-             env::join_paths(&dylib_path).unwrap());\n+        .env(bootstrap::util::dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n     // Force all crates compiled by this compiler to (a) be unstable and (b)\n     // allow the `rustc_private` feature to link to other unstable crates\n@@ -55,8 +54,7 @@ fn main() {\n     if let Some(version) = env::var_os(\"RUSTDOC_CRATE_VERSION\") {\n         // This \"unstable-options\" can be removed when `--crate-version` is stabilized\n         if !has_unstable {\n-            cmd.arg(\"-Z\")\n-               .arg(\"unstable-options\");\n+            cmd.arg(\"-Z\").arg(\"unstable-options\");\n         }\n         cmd.arg(\"--crate-version\").arg(version);\n         has_unstable = true;\n@@ -66,8 +64,7 @@ fn main() {\n     if let Some(_) = env::var_os(\"RUSTDOC_GENERATE_REDIRECT_PAGES\") {\n         // This \"unstable-options\" can be removed when `--generate-redirect-pages` is stabilized\n         if !has_unstable {\n-            cmd.arg(\"-Z\")\n-               .arg(\"unstable-options\");\n+            cmd.arg(\"-Z\").arg(\"unstable-options\");\n         }\n         cmd.arg(\"--generate-redirect-pages\");\n         has_unstable = true;\n@@ -77,8 +74,7 @@ fn main() {\n     if let Some(ref x) = env::var_os(\"RUSTDOC_RESOURCE_SUFFIX\") {\n         // This \"unstable-options\" can be removed when `--resource-suffix` is stabilized\n         if !has_unstable {\n-            cmd.arg(\"-Z\")\n-               .arg(\"unstable-options\");\n+            cmd.arg(\"-Z\").arg(\"unstable-options\");\n         }\n         cmd.arg(\"--resource-suffix\").arg(x);\n     }"}, {"sha": "554c2dd4d81eaa28b592e9edbea65afee8adef07", "filename": "src/bootstrap/bin/sccache-plus-cl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -8,12 +8,12 @@ fn main() {\n     env::set_var(\"CXX\", env::var_os(\"SCCACHE_CXX\").unwrap());\n     let mut cfg = cc::Build::new();\n     cfg.cargo_metadata(false)\n-       .out_dir(\"/\")\n-       .target(&target)\n-       .host(&target)\n-       .opt_level(0)\n-       .warnings(false)\n-       .debug(false);\n+        .out_dir(\"/\")\n+        .target(&target)\n+        .host(&target)\n+        .opt_level(0)\n+        .warnings(false)\n+        .debug(false);\n     let compiler = cfg.get_compiler();\n \n     // Invoke sccache with said compiler"}, {"sha": "a2dca66697d6d641b971ae43700ebdf70e03ee1b", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 43, "deletions": 85, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -24,7 +24,7 @@ use crate::native;\n use crate::test;\n use crate::tool;\n use crate::util::{self, add_lib_path, exe, libdir};\n-use crate::{Build, DocTests, Mode, GitRepo};\n+use crate::{Build, DocTests, GitRepo, Mode};\n \n pub use crate::Compiler;\n \n@@ -122,11 +122,7 @@ impl PathSet {\n \n     fn path(&self, builder: &Builder<'_>) -> PathBuf {\n         match self {\n-            PathSet::Set(set) => set\n-                .iter()\n-                .next()\n-                .unwrap_or(&builder.build.src)\n-                .to_path_buf(),\n+            PathSet::Set(set) => set.iter().next().unwrap_or(&builder.build.src).to_path_buf(),\n             PathSet::Suite(path) => PathBuf::from(path),\n         }\n     }\n@@ -180,10 +176,8 @@ impl StepDescription {\n     }\n \n     fn run(v: &[StepDescription], builder: &Builder<'_>, paths: &[PathBuf]) {\n-        let should_runs = v\n-            .iter()\n-            .map(|desc| (desc.should_run)(ShouldRun::new(builder)))\n-            .collect::<Vec<_>>();\n+        let should_runs =\n+            v.iter().map(|desc| (desc.should_run)(ShouldRun::new(builder))).collect::<Vec<_>>();\n \n         // sanity checks on rules\n         for (desc, should_run) in v.iter().zip(&should_runs) {\n@@ -280,8 +274,7 @@ impl<'a> ShouldRun<'a> {\n \n     // multiple aliases for the same job\n     pub fn paths(mut self, paths: &[&str]) -> Self {\n-        self.paths\n-            .insert(PathSet::Set(paths.iter().map(PathBuf::from).collect()));\n+        self.paths.insert(PathSet::Set(paths.iter().map(PathBuf::from).collect()));\n         self\n     }\n \n@@ -354,11 +347,9 @@ impl<'a> Builder<'a> {\n                 tool::Miri,\n                 native::Lld\n             ),\n-            Kind::Check | Kind::Clippy | Kind::Fix | Kind::Format => describe!(\n-                check::Std,\n-                check::Rustc,\n-                check::Rustdoc\n-            ),\n+            Kind::Check | Kind::Clippy | Kind::Fix | Kind::Format => {\n+                describe!(check::Std, check::Rustc, check::Rustdoc)\n+            }\n             Kind::Test => describe!(\n                 crate::toolstate::ToolStateCheck,\n                 test::Tidy,\n@@ -549,9 +540,7 @@ impl<'a> Builder<'a> {\n     /// obtained through this function, since it ensures that they are valid\n     /// (i.e., built and assembled).\n     pub fn compiler(&self, stage: u32, host: Interned<String>) -> Compiler {\n-        self.ensure(compile::Assemble {\n-            target_compiler: Compiler { stage, host },\n-        })\n+        self.ensure(compile::Assemble { target_compiler: Compiler { stage, host } })\n     }\n \n     /// Similar to `compiler`, except handles the full-bootstrap option to\n@@ -627,9 +616,10 @@ impl<'a> Builder<'a> {\n             self.rustc_snapshot_libdir()\n         } else {\n             match self.config.libdir_relative() {\n-                Some(relative_libdir) if compiler.stage >= 1\n-                    => self.sysroot(compiler).join(relative_libdir),\n-                _ => self.sysroot(compiler).join(libdir(&compiler.host))\n+                Some(relative_libdir) if compiler.stage >= 1 => {\n+                    self.sysroot(compiler).join(relative_libdir)\n+                }\n+                _ => self.sysroot(compiler).join(libdir(&compiler.host)),\n             }\n         }\n     }\n@@ -644,9 +634,8 @@ impl<'a> Builder<'a> {\n             libdir(&self.config.build).as_ref()\n         } else {\n             match self.config.libdir_relative() {\n-                Some(relative_libdir) if compiler.stage >= 1\n-                    => relative_libdir,\n-                _ => libdir(&compiler.host).as_ref()\n+                Some(relative_libdir) if compiler.stage >= 1 => relative_libdir,\n+                _ => libdir(&compiler.host).as_ref(),\n             }\n         }\n     }\n@@ -657,9 +646,8 @@ impl<'a> Builder<'a> {\n     /// For example this returns `lib` on Unix and Windows.\n     pub fn sysroot_libdir_relative(&self, compiler: Compiler) -> &Path {\n         match self.config.libdir_relative() {\n-            Some(relative_libdir) if compiler.stage >= 1\n-                => relative_libdir,\n-            _ => Path::new(\"lib\")\n+            Some(relative_libdir) if compiler.stage >= 1 => relative_libdir,\n+            _ => Path::new(\"lib\"),\n         }\n     }\n \n@@ -681,9 +669,7 @@ impl<'a> Builder<'a> {\n         if compiler.is_snapshot(self) {\n             self.initial_rustc.clone()\n         } else {\n-            self.sysroot(compiler)\n-                .join(\"bin\")\n-                .join(exe(\"rustc\", &compiler.host))\n+            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", &compiler.host))\n         }\n     }\n \n@@ -740,17 +726,10 @@ impl<'a> Builder<'a> {\n             self.clear_if_dirty(&my_out, &rustdoc);\n         }\n \n-        cargo\n-            .env(\"CARGO_TARGET_DIR\", out_dir)\n-            .arg(cmd)\n-            .arg(\"-Zconfig-profile\");\n+        cargo.env(\"CARGO_TARGET_DIR\", out_dir).arg(cmd).arg(\"-Zconfig-profile\");\n \n         let profile_var = |name: &str| {\n-            let profile = if self.config.rust_optimize {\n-                \"RELEASE\"\n-            } else {\n-                \"DEV\"\n-            };\n+            let profile = if self.config.rust_optimize { \"RELEASE\" } else { \"DEV\" };\n             format!(\"CARGO_PROFILE_{}_{}\", profile, name)\n         };\n \n@@ -762,8 +741,7 @@ impl<'a> Builder<'a> {\n         }\n \n         if cmd != \"install\" {\n-            cargo.arg(\"--target\")\n-                 .arg(target);\n+            cargo.arg(\"--target\").arg(target);\n         } else {\n             assert_eq!(target, compiler.host);\n         }\n@@ -801,14 +779,14 @@ impl<'a> Builder<'a> {\n         }\n \n         match mode {\n-            Mode::Std | Mode::ToolBootstrap | Mode::ToolStd => {},\n+            Mode::Std | Mode::ToolBootstrap | Mode::ToolStd => {}\n             Mode::Rustc | Mode::Codegen | Mode::ToolRustc => {\n                 // Build proc macros both for the host and the target\n                 if target != compiler.host && cmd != \"check\" {\n                     cargo.arg(\"-Zdual-proc-macros\");\n                     rustflags.arg(\"-Zdual-proc-macros\");\n                 }\n-            },\n+            }\n         }\n \n         // This tells Cargo (and in turn, rustc) to output more complete\n@@ -884,11 +862,7 @@ impl<'a> Builder<'a> {\n         assert!(!use_snapshot || stage == 0 || self.local_rebuild);\n \n         let maybe_sysroot = self.sysroot(compiler);\n-        let sysroot = if use_snapshot {\n-            self.rustc_snapshot_sysroot()\n-        } else {\n-            &maybe_sysroot\n-        };\n+        let sysroot = if use_snapshot { self.rustc_snapshot_sysroot() } else { &maybe_sysroot };\n         let libdir = self.rustc_libdir(compiler);\n \n         // Customize the compiler we're running. Specify the compiler to cargo\n@@ -902,10 +876,7 @@ impl<'a> Builder<'a> {\n             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n             .env(\"RUSTC_REAL\", self.rustc(compiler))\n             .env(\"RUSTC_STAGE\", stage.to_string())\n-            .env(\n-                \"RUSTC_DEBUG_ASSERTIONS\",\n-                self.config.rust_debug_assertions.to_string(),\n-            )\n+            .env(\"RUSTC_DEBUG_ASSERTIONS\", self.config.rust_debug_assertions.to_string())\n             .env(\"RUSTC_SYSROOT\", &sysroot)\n             .env(\"RUSTC_LIBDIR\", &libdir)\n             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n@@ -948,7 +919,6 @@ impl<'a> Builder<'a> {\n         // to change a flag in a binary?\n         if self.config.rust_rpath && util::use_host_linker(&target) {\n             let rpath = if target.contains(\"apple\") {\n-\n                 // Note that we need to take one extra step on macOS to also pass\n                 // `-Wl,-instal_name,@rpath/...` to get things to work right. To\n                 // do that we pass a weird flag to the compiler to get it to do\n@@ -980,8 +950,9 @@ impl<'a> Builder<'a> {\n         let debuginfo_level = match mode {\n             Mode::Rustc | Mode::Codegen => self.config.rust_debuginfo_level_rustc,\n             Mode::Std => self.config.rust_debuginfo_level_std,\n-            Mode::ToolBootstrap | Mode::ToolStd |\n-            Mode::ToolRustc => self.config.rust_debuginfo_level_tools,\n+            Mode::ToolBootstrap | Mode::ToolStd | Mode::ToolRustc => {\n+                self.config.rust_debuginfo_level_tools\n+            }\n         };\n         cargo.env(profile_var(\"DEBUG\"), debuginfo_level.to_string());\n \n@@ -1102,14 +1073,11 @@ impl<'a> Builder<'a> {\n             cargo.env(format!(\"CC_{}\", target), &cc);\n \n             let cflags = self.cflags(target, GitRepo::Rustc).join(\" \");\n-            cargo\n-                .env(format!(\"CFLAGS_{}\", target), cflags.clone());\n+            cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone());\n \n             if let Some(ar) = self.ar(target) {\n                 let ranlib = format!(\"{} s\", ar.display());\n-                cargo\n-                    .env(format!(\"AR_{}\", target), ar)\n-                    .env(format!(\"RANLIB_{}\", target), ranlib);\n+                cargo.env(format!(\"AR_{}\", target), ar).env(format!(\"RANLIB_{}\", target), ranlib);\n             }\n \n             if let Ok(cxx) = self.cxx(target) {\n@@ -1120,15 +1088,14 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        if mode == Mode::Std\n-            && self.config.extended\n-            && compiler.is_final_stage(self)\n-        {\n+        if mode == Mode::Std && self.config.extended && compiler.is_final_stage(self) {\n             rustflags.arg(\"-Zsave-analysis\");\n-            cargo.env(\"RUST_SAVE_ANALYSIS_CONFIG\",\n-                      \"{\\\"output_file\\\": null,\\\"full_docs\\\": false,\\\n+            cargo.env(\n+                \"RUST_SAVE_ANALYSIS_CONFIG\",\n+                \"{\\\"output_file\\\": null,\\\"full_docs\\\": false,\\\n                        \\\"pub_only\\\": true,\\\"reachable_only\\\": false,\\\n-                       \\\"distro_crate\\\": true,\\\"signatures\\\": false,\\\"borrow_data\\\": false}\");\n+                       \\\"distro_crate\\\": true,\\\"signatures\\\": false,\\\"borrow_data\\\": false}\",\n+            );\n         }\n \n         // For `cargo doc` invocations, make rustdoc print the Rust version into the docs\n@@ -1182,8 +1149,7 @@ impl<'a> Builder<'a> {\n         }\n \n         match (mode, self.config.rust_codegen_units_std, self.config.rust_codegen_units) {\n-            (Mode::Std, Some(n), _) |\n-            (_, _, Some(n)) => {\n+            (Mode::Std, Some(n), _) | (_, _, Some(n)) => {\n                 cargo.env(profile_var(\"CODEGEN_UNITS\"), n.to_string());\n             }\n             _ => {\n@@ -1217,10 +1183,7 @@ impl<'a> Builder<'a> {\n             rustflags.arg(\"-Cprefer-dynamic\");\n         }\n \n-        Cargo {\n-            command: cargo,\n-            rustflags,\n-        }\n+        Cargo { command: cargo, rustflags }\n     }\n \n     /// Ensure that a given step is built, returning its output. This will\n@@ -1231,10 +1194,7 @@ impl<'a> Builder<'a> {\n             let mut stack = self.stack.borrow_mut();\n             for stack_step in stack.iter() {\n                 // should skip\n-                if stack_step\n-                    .downcast_ref::<S>()\n-                    .map_or(true, |stack_step| *stack_step != step)\n-                {\n+                if stack_step.downcast_ref::<S>().map_or(true, |stack_step| *stack_step != step) {\n                     continue;\n                 }\n                 let mut out = String::new();\n@@ -1277,11 +1237,7 @@ impl<'a> Builder<'a> {\n             let cur_step = stack.pop().expect(\"step stack empty\");\n             assert_eq!(cur_step.downcast_ref(), Some(&step));\n         }\n-        self.verbose(&format!(\n-            \"{}< {:?}\",\n-            \"  \".repeat(self.stack.borrow().len()),\n-            step\n-        ));\n+        self.verbose(&format!(\"{}< {:?}\", \"  \".repeat(self.stack.borrow().len()), step));\n         self.cache.put(step, out.clone());\n         out\n     }\n@@ -1344,7 +1300,9 @@ impl Cargo {\n     }\n \n     pub fn args<I, S>(&mut self, args: I) -> &mut Cargo\n-        where I: IntoIterator<Item=S>, S: AsRef<OsStr>\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n     {\n         for arg in args {\n             self.arg(arg.as_ref());"}, {"sha": "5fefb972866a97a34ff71ef9eef29cf8cc47ba63", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 81, "deletions": 298, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -11,12 +11,10 @@ fn configure(host: &[&str], target: &[&str]) -> Config {\n     config.skip_only_host_steps = false;\n     config.dry_run = true;\n     // try to avoid spurious failures in dist where we create/delete each others file\n-    let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n-        &thread::current()\n-            .name()\n-            .unwrap_or(\"unknown\")\n-            .replace(\":\", \"-\"),\n-    );\n+    let dir = config\n+        .out\n+        .join(\"tmp-rustbuild-tests\")\n+        .join(&thread::current().name().unwrap_or(\"unknown\").replace(\":\", \"-\"));\n     t!(fs::create_dir_all(&dir));\n     config.out = dir;\n     config.build = INTERNER.intern_str(\"A\");\n@@ -46,26 +44,15 @@ fn dist_baseline() {\n \n     let a = INTERNER.intern_str(\"A\");\n \n-    assert_eq!(\n-        first(builder.cache.all::<dist::Docs>()),\n-        &[dist::Docs { host: a },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Mingw>()),\n-        &[dist::Mingw { host: a },]\n-    );\n+    assert_eq!(first(builder.cache.all::<dist::Docs>()), &[dist::Docs { host: a },]);\n+    assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[dist::Mingw { host: a },]);\n     assert_eq!(\n         first(builder.cache.all::<dist::Rustc>()),\n-        &[dist::Rustc {\n-            compiler: Compiler { host: a, stage: 2 }\n-        },]\n+        &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Std>()),\n-        &[dist::Std {\n-            compiler: Compiler { host: a, stage: 1 },\n-            target: a,\n-        },]\n+        &[dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },]\n     );\n     assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n }\n@@ -81,32 +68,21 @@ fn dist_with_targets() {\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n-        &[\n-            dist::Docs { host: a },\n-            dist::Docs { host: b },\n-        ]\n+        &[dist::Docs { host: a }, dist::Docs { host: b },]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Mingw>()),\n         &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Rustc>()),\n-        &[dist::Rustc {\n-            compiler: Compiler { host: a, stage: 2 }\n-        },]\n+        &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Std>()),\n         &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n+            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+            dist::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n         ]\n     );\n     assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n@@ -123,10 +99,7 @@ fn dist_with_hosts() {\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n-        &[\n-            dist::Docs { host: a },\n-            dist::Docs { host: b },\n-        ]\n+        &[dist::Docs { host: a }, dist::Docs { host: b },]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Mingw>()),\n@@ -135,25 +108,15 @@ fn dist_with_hosts() {\n     assert_eq!(\n         first(builder.cache.all::<dist::Rustc>()),\n         &[\n-            dist::Rustc {\n-                compiler: Compiler { host: a, stage: 2 }\n-            },\n-            dist::Rustc {\n-                compiler: Compiler { host: b, stage: 2 }\n-            },\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n         ]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Std>()),\n         &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n+            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n         ]\n     );\n     assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n@@ -172,23 +135,13 @@ fn dist_only_cross_host() {\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Rustc>()),\n-        &[\n-            dist::Rustc {\n-                compiler: Compiler { host: b, stage: 2 }\n-            },\n-        ]\n+        &[dist::Rustc { compiler: Compiler { host: b, stage: 2 } },]\n     );\n     assert_eq!(\n         first(builder.cache.all::<compile::Rustc>()),\n         &[\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n+            compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n+            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n         ]\n     );\n }\n@@ -205,46 +158,25 @@ fn dist_with_targets_and_hosts() {\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n-        &[\n-            dist::Docs { host: a },\n-            dist::Docs { host: b },\n-            dist::Docs { host: c },\n-        ]\n+        &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Mingw>()),\n-        &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-            dist::Mingw { host: c },\n-        ]\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Rustc>()),\n         &[\n-            dist::Rustc {\n-                compiler: Compiler { host: a, stage: 2 }\n-            },\n-            dist::Rustc {\n-                compiler: Compiler { host: b, stage: 2 }\n-            },\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n         ]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Std>()),\n         &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n+            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n         ]\n     );\n     assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n@@ -264,36 +196,19 @@ fn dist_with_target_flag() {\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n-        &[\n-            dist::Docs { host: a },\n-            dist::Docs { host: b },\n-            dist::Docs { host: c },\n-        ]\n+        &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Mingw>()),\n-        &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-            dist::Mingw { host: c },\n-        ]\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n     );\n     assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n     assert_eq!(\n         first(builder.cache.all::<dist::Std>()),\n         &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n+            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n         ]\n     );\n     assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n@@ -310,10 +225,7 @@ fn dist_with_same_targets_and_hosts() {\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n-        &[\n-            dist::Docs { host: a },\n-            dist::Docs { host: b },\n-        ]\n+        &[dist::Docs { host: a }, dist::Docs { host: b },]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Mingw>()),\n@@ -322,68 +234,35 @@ fn dist_with_same_targets_and_hosts() {\n     assert_eq!(\n         first(builder.cache.all::<dist::Rustc>()),\n         &[\n-            dist::Rustc {\n-                compiler: Compiler { host: a, stage: 2 }\n-            },\n-            dist::Rustc {\n-                compiler: Compiler { host: b, stage: 2 }\n-            },\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n         ]\n     );\n     assert_eq!(\n         first(builder.cache.all::<dist::Std>()),\n         &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n+            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n         ]\n     );\n     assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n     assert_eq!(\n         first(builder.cache.all::<compile::Std>()),\n         &[\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n+            compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n+            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n+            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n         ]\n     );\n     assert_eq!(\n         first(builder.cache.all::<compile::Assemble>()),\n         &[\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 0 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 1 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 2 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: b, stage: 2 },\n-            },\n+            compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n+            compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n+            compile::Assemble { target_compiler: Compiler { host: a, stage: 2 } },\n+            compile::Assemble { target_compiler: Compiler { host: b, stage: 2 } },\n         ]\n     );\n }\n@@ -401,76 +280,28 @@ fn build_default() {\n     assert_eq!(\n         first(builder.cache.all::<compile::Std>()),\n         &[\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: c,\n-            },\n+            compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n+            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n+            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: a },\n+            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: b },\n+            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n+            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: c },\n         ]\n     );\n     assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n     assert_eq!(\n         first(builder.cache.all::<compile::Rustc>()),\n         &[\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n+            compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n+            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n+            compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: a },\n+            compile::Rustc { compiler: Compiler { host: b, stage: 2 }, target: a },\n+            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: b },\n+            compile::Rustc { compiler: Compiler { host: b, stage: 2 }, target: b },\n         ]\n     );\n }\n@@ -490,76 +321,32 @@ fn build_with_target_flag() {\n     assert_eq!(\n         first(builder.cache.all::<compile::Std>()),\n         &[\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: c,\n-            },\n+            compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n+            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n+            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: a },\n+            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: b },\n+            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n+            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: c },\n         ]\n     );\n     assert_eq!(\n         first(builder.cache.all::<compile::Assemble>()),\n         &[\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 0 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 1 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 2 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: b, stage: 2 },\n-            },\n+            compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n+            compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n+            compile::Assemble { target_compiler: Compiler { host: a, stage: 2 } },\n+            compile::Assemble { target_compiler: Compiler { host: b, stage: 2 } },\n         ]\n     );\n     assert_eq!(\n         first(builder.cache.all::<compile::Rustc>()),\n         &[\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n+            compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n+            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n+            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n         ]\n     );\n }\n@@ -585,10 +372,8 @@ fn test_with_no_doc_stage0() {\n \n     let host = INTERNER.intern_str(\"A\");\n \n-    builder.run_step_descriptions(\n-        &[StepDescription::from::<test::Crate>()],\n-        &[\"src/libstd\".into()],\n-    );\n+    builder\n+        .run_step_descriptions(&[StepDescription::from::<test::Crate>()], &[\"src/libstd\".into()]);\n \n     // Ensure we don't build any compiler artifacts.\n     assert!(!builder.cache.contains::<compile::Rustc>());\n@@ -607,9 +392,7 @@ fn test_with_no_doc_stage0() {\n #[test]\n fn test_exclude() {\n     let mut config = configure(&[], &[]);\n-    config.exclude = vec![\n-        \"src/tools/tidy\".into(),\n-    ];\n+    config.exclude = vec![\"src/tools/tidy\".into()];\n     config.cmd = Subcommand::Test {\n         paths: Vec::new(),\n         test_args: Vec::new(),"}, {"sha": "0c16fae01bca788ac7f2f7ba407c8db159da87d2", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,6 +1,7 @@\n use std::any::{Any, TypeId};\n use std::borrow::Borrow;\n use std::cell::RefCell;\n+use std::cmp::{Ord, Ordering, PartialOrd};\n use std::collections::HashMap;\n use std::convert::AsRef;\n use std::ffi::OsStr;\n@@ -11,7 +12,6 @@ use std::mem;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::sync::Mutex;\n-use std::cmp::{PartialOrd, Ord, Ordering};\n \n use lazy_static::lazy_static;\n \n@@ -47,7 +47,7 @@ impl<T> Eq for Interned<T> {}\n \n impl PartialEq<str> for Interned<String> {\n     fn eq(&self, other: &str) -> bool {\n-       *self == other\n+        *self == other\n     }\n }\n impl<'a> PartialEq<&'a str> for Interned<String> {\n@@ -168,24 +168,21 @@ struct TyIntern<T: Clone + Eq> {\n \n impl<T: Hash + Clone + Eq> Default for TyIntern<T> {\n     fn default() -> Self {\n-        TyIntern {\n-            items: Vec::new(),\n-            set: Default::default(),\n-        }\n+        TyIntern { items: Vec::new(), set: Default::default() }\n     }\n }\n \n impl<T: Hash + Clone + Eq> TyIntern<T> {\n     fn intern_borrow<B>(&mut self, item: &B) -> Interned<T>\n     where\n-        B: Eq + Hash + ToOwned<Owned=T> + ?Sized,\n+        B: Eq + Hash + ToOwned<Owned = T> + ?Sized,\n         T: Borrow<B>,\n     {\n         if let Some(i) = self.set.get(&item) {\n             return *i;\n         }\n         let item = item.to_owned();\n-        let interned =  Interned(self.items.len(), PhantomData::<*const T>);\n+        let interned = Interned(self.items.len(), PhantomData::<*const T>);\n         self.set.insert(item.clone(), interned);\n         self.items.push(item);\n         interned\n@@ -195,7 +192,7 @@ impl<T: Hash + Clone + Eq> TyIntern<T> {\n         if let Some(i) = self.set.get(&item) {\n             return *i;\n         }\n-        let interned =  Interned(self.items.len(), PhantomData::<*const T>);\n+        let interned = Interned(self.items.len(), PhantomData::<*const T>);\n         self.set.insert(item.clone(), interned);\n         self.items.push(item);\n         interned\n@@ -235,10 +232,12 @@ lazy_static! {\n /// `get()` method.\n #[derive(Debug)]\n pub struct Cache(\n-    RefCell<HashMap<\n-        TypeId,\n-        Box<dyn Any>, // actually a HashMap<Step, Interned<Step::Output>>\n-    >>\n+    RefCell<\n+        HashMap<\n+            TypeId,\n+            Box<dyn Any>, // actually a HashMap<Step, Interned<Step::Output>>\n+        >,\n+    >,\n );\n \n impl Cache {\n@@ -249,21 +248,23 @@ impl Cache {\n     pub fn put<S: Step>(&self, step: S, value: S::Output) {\n         let mut cache = self.0.borrow_mut();\n         let type_id = TypeId::of::<S>();\n-        let stepcache = cache.entry(type_id)\n-                        .or_insert_with(|| Box::new(HashMap::<S, S::Output>::new()))\n-                        .downcast_mut::<HashMap<S, S::Output>>()\n-                        .expect(\"invalid type mapped\");\n+        let stepcache = cache\n+            .entry(type_id)\n+            .or_insert_with(|| Box::new(HashMap::<S, S::Output>::new()))\n+            .downcast_mut::<HashMap<S, S::Output>>()\n+            .expect(\"invalid type mapped\");\n         assert!(!stepcache.contains_key(&step), \"processing {:?} a second time\", step);\n         stepcache.insert(step, value);\n     }\n \n     pub fn get<S: Step>(&self, step: &S) -> Option<S::Output> {\n         let mut cache = self.0.borrow_mut();\n         let type_id = TypeId::of::<S>();\n-        let stepcache = cache.entry(type_id)\n-                        .or_insert_with(|| Box::new(HashMap::<S, S::Output>::new()))\n-                        .downcast_mut::<HashMap<S, S::Output>>()\n-                        .expect(\"invalid type mapped\");\n+        let stepcache = cache\n+            .entry(type_id)\n+            .or_insert_with(|| Box::new(HashMap::<S, S::Output>::new()))\n+            .downcast_mut::<HashMap<S, S::Output>>()\n+            .expect(\"invalid type mapped\");\n         stepcache.get(step).cloned()\n     }\n }\n@@ -273,7 +274,8 @@ impl Cache {\n     pub fn all<S: Ord + Copy + Step>(&mut self) -> Vec<(S, S::Output)> {\n         let cache = self.0.get_mut();\n         let type_id = TypeId::of::<S>();\n-        let mut v = cache.remove(&type_id)\n+        let mut v = cache\n+            .remove(&type_id)\n             .map(|b| b.downcast::<HashMap<S, S::Output>>().expect(\"correct type\"))\n             .map(|m| m.into_iter().collect::<Vec<_>>())\n             .unwrap_or_default();"}, {"sha": "a236edf971fcca2702e0e111688ad217f4d371a8", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -22,15 +22,15 @@\n //! everything.\n \n use std::collections::HashSet;\n-use std::{env, iter};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n+use std::{env, iter};\n \n use build_helper::output;\n \n-use crate::{Build, GitRepo};\n-use crate::config::Target;\n use crate::cache::Interned;\n+use crate::config::Target;\n+use crate::{Build, GitRepo};\n \n // The `cc` crate doesn't provide a way to obtain a path to the detected archiver,\n // so use some simplified logic here. First we respect the environment variable `AR`, then\n@@ -64,14 +64,25 @@ fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims\n     // and such as well as for being a linker for Rust code.\n-    let targets = build.targets.iter().chain(&build.hosts).cloned().chain(iter::once(build.build))\n-                               .collect::<HashSet<_>>();\n+    let targets = build\n+        .targets\n+        .iter()\n+        .chain(&build.hosts)\n+        .cloned()\n+        .chain(iter::once(build.build))\n+        .collect::<HashSet<_>>();\n     for target in targets.into_iter() {\n         let mut cfg = cc::Build::new();\n-        cfg.cargo_metadata(false).opt_level(2).warnings(false).debug(false)\n-           .target(&target).host(&build.build);\n+        cfg.cargo_metadata(false)\n+            .opt_level(2)\n+            .warnings(false)\n+            .debug(false)\n+            .target(&target)\n+            .host(&build.build);\n         match build.crt_static(target) {\n-            Some(a) => { cfg.static_crt(a); }\n+            Some(a) => {\n+                cfg.static_crt(a);\n+            }\n             None => {\n                 if target.contains(\"msvc\") {\n                     cfg.static_crt(true);\n@@ -102,8 +113,13 @@ pub fn find(build: &mut Build) {\n         // If we use llvm-libunwind, we will need a C++ compiler as well for all targets\n         // We'll need one anyways if the target triple is also a host triple\n         let mut cfg = cc::Build::new();\n-        cfg.cargo_metadata(false).opt_level(2).warnings(false).debug(false).cpp(true)\n-            .target(&target).host(&build.build);\n+        cfg.cargo_metadata(false)\n+            .opt_level(2)\n+            .warnings(false)\n+            .debug(false)\n+            .cpp(true)\n+            .target(&target)\n+            .host(&build.build);\n \n         let cxx_configured = if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);\n@@ -133,21 +149,24 @@ pub fn find(build: &mut Build) {\n     }\n }\n \n-fn set_compiler(cfg: &mut cc::Build,\n-                compiler: Language,\n-                target: Interned<String>,\n-                config: Option<&Target>,\n-                build: &Build) {\n+fn set_compiler(\n+    cfg: &mut cc::Build,\n+    compiler: Language,\n+    target: Interned<String>,\n+    config: Option<&Target>,\n+    build: &Build,\n+) {\n     match &*target {\n         // When compiling for android we may have the NDK configured in the\n         // config.toml in which case we look there. Otherwise the default\n         // compiler already takes into account the triple in question.\n         t if t.contains(\"android\") => {\n             if let Some(ndk) = config.and_then(|c| c.ndk.as_ref()) {\n-                let target = target.replace(\"armv7neon\", \"arm\")\n-                                   .replace(\"armv7\", \"arm\")\n-                                   .replace(\"thumbv7neon\", \"arm\")\n-                                   .replace(\"thumbv7\", \"arm\");\n+                let target = target\n+                    .replace(\"armv7neon\", \"arm\")\n+                    .replace(\"armv7\", \"arm\")\n+                    .replace(\"thumbv7neon\", \"arm\")\n+                    .replace(\"thumbv7\", \"arm\");\n                 let compiler = format!(\"{}-{}\", target, compiler.clang());\n                 cfg.compiler(ndk.join(\"bin\").join(compiler));\n             }\n@@ -159,7 +178,7 @@ fn set_compiler(cfg: &mut cc::Build,\n             let c = cfg.get_compiler();\n             let gnu_compiler = compiler.gcc();\n             if !c.path().ends_with(gnu_compiler) {\n-                return\n+                return;\n             }\n \n             let output = output(c.to_command().arg(\"--version\"));\n@@ -168,7 +187,7 @@ fn set_compiler(cfg: &mut cc::Build,\n                 None => return,\n             };\n             match output[i + 3..].chars().next().unwrap() {\n-                '0' ..= '6' => {}\n+                '0'..='6' => {}\n                 _ => return,\n             }\n             let alternative = format!(\"e{}\", gnu_compiler);"}, {"sha": "38810237ef93c206a299c92f0cf4b23c7917ecd0", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -29,31 +29,28 @@ impl GitInfo {\n     pub fn new(ignore_git: bool, dir: &Path) -> GitInfo {\n         // See if this even begins to look like a git dir\n         if ignore_git || !dir.join(\".git\").exists() {\n-            return GitInfo { inner: None }\n+            return GitInfo { inner: None };\n         }\n \n         // Make sure git commands work\n-        match Command::new(\"git\")\n-            .arg(\"rev-parse\")\n-            .current_dir(dir)\n-            .output()\n-        {\n+        match Command::new(\"git\").arg(\"rev-parse\").current_dir(dir).output() {\n             Ok(ref out) if out.status.success() => {}\n             _ => return GitInfo { inner: None },\n         }\n \n         // Ok, let's scrape some info\n-        let ver_date = output(Command::new(\"git\").current_dir(dir)\n-                                      .arg(\"log\").arg(\"-1\")\n-                                      .arg(\"--date=short\")\n-                                      .arg(\"--pretty=format:%cd\"));\n-        let ver_hash = output(Command::new(\"git\").current_dir(dir)\n-                                      .arg(\"rev-parse\").arg(\"HEAD\"));\n-        let short_ver_hash = output(Command::new(\"git\")\n-                                            .current_dir(dir)\n-                                            .arg(\"rev-parse\")\n-                                            .arg(\"--short=9\")\n-                                            .arg(\"HEAD\"));\n+        let ver_date = output(\n+            Command::new(\"git\")\n+                .current_dir(dir)\n+                .arg(\"log\")\n+                .arg(\"-1\")\n+                .arg(\"--date=short\")\n+                .arg(\"--pretty=format:%cd\"),\n+        );\n+        let ver_hash = output(Command::new(\"git\").current_dir(dir).arg(\"rev-parse\").arg(\"HEAD\"));\n+        let short_ver_hash = output(\n+            Command::new(\"git\").current_dir(dir).arg(\"rev-parse\").arg(\"--short=9\").arg(\"HEAD\"),\n+        );\n         GitInfo {\n             inner: Some(Info {\n                 commit_date: ver_date.trim().to_string(),"}, {"sha": "d4016f16fa9d3fe10b908fae38da240d47f40303", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,10 +1,10 @@\n //! Implementation of compiling the compiler and standard library, in \"check\"-based modes.\n \n-use crate::compile::{run_cargo, std_cargo, rustc_cargo, add_to_sysroot};\n-use crate::builder::{RunConfig, Builder, Kind, ShouldRun, Step};\n+use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n+use crate::cache::Interned;\n+use crate::compile::{add_to_sysroot, run_cargo, rustc_cargo, std_cargo};\n use crate::tool::{prepare_tool_cargo, SourceType};\n use crate::{Compiler, Mode};\n-use crate::cache::Interned;\n use std::path::PathBuf;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -15,7 +15,7 @@ pub struct Std {\n fn args(kind: Kind) -> Vec<String> {\n     match kind {\n         Kind::Clippy => vec![\"--\".to_owned(), \"--cap-lints\".to_owned(), \"warn\".to_owned()],\n-        _ => Vec::new()\n+        _ => Vec::new(),\n     }\n }\n \n@@ -24,7 +24,7 @@ fn cargo_subcommand(kind: Kind) -> &'static str {\n         Kind::Check => \"check\",\n         Kind::Clippy => \"clippy\",\n         Kind::Fix => \"fix\",\n-        _ => unreachable!()\n+        _ => unreachable!(),\n     }\n }\n \n@@ -37,9 +37,7 @@ impl Step for Std {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Std {\n-            target: run.target,\n-        });\n+        run.builder.ensure(Std { target: run.target });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n@@ -50,12 +48,14 @@ impl Step for Std {\n         std_cargo(builder, &compiler, target, &mut cargo);\n \n         builder.info(&format!(\"Checking std artifacts ({} -> {})\", &compiler.host, target));\n-        run_cargo(builder,\n-                  cargo,\n-                  args(builder.kind),\n-                  &libstd_stamp(builder, compiler, target),\n-                  vec![],\n-                  true);\n+        run_cargo(\n+            builder,\n+            cargo,\n+            args(builder.kind),\n+            &libstd_stamp(builder, compiler, target),\n+            vec![],\n+            true,\n+        );\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n         let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n@@ -78,9 +78,7 @@ impl Step for Rustc {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustc {\n-            target: run.target,\n-        });\n+        run.builder.ensure(Rustc { target: run.target });\n     }\n \n     /// Builds the compiler.\n@@ -94,17 +92,19 @@ impl Step for Rustc {\n \n         builder.ensure(Std { target });\n \n-        let mut cargo = builder.cargo(compiler, Mode::Rustc, target,\n-            cargo_subcommand(builder.kind));\n+        let mut cargo =\n+            builder.cargo(compiler, Mode::Rustc, target, cargo_subcommand(builder.kind));\n         rustc_cargo(builder, &mut cargo, target);\n \n         builder.info(&format!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target));\n-        run_cargo(builder,\n-                  cargo,\n-                  args(builder.kind),\n-                  &librustc_stamp(builder, compiler, target),\n-                  vec![],\n-                  true);\n+        run_cargo(\n+            builder,\n+            cargo,\n+            args(builder.kind),\n+            &librustc_stamp(builder, compiler, target),\n+            vec![],\n+            true,\n+        );\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n         let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n@@ -127,9 +127,7 @@ impl Step for Rustdoc {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustdoc {\n-            target: run.target,\n-        });\n+        run.builder.ensure(Rustdoc { target: run.target });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n@@ -138,22 +136,26 @@ impl Step for Rustdoc {\n \n         builder.ensure(Rustc { target });\n \n-        let cargo = prepare_tool_cargo(builder,\n-                                       compiler,\n-                                       Mode::ToolRustc,\n-                                       target,\n-                                       cargo_subcommand(builder.kind),\n-                                       \"src/tools/rustdoc\",\n-                                       SourceType::InTree,\n-                                       &[]);\n+        let cargo = prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolRustc,\n+            target,\n+            cargo_subcommand(builder.kind),\n+            \"src/tools/rustdoc\",\n+            SourceType::InTree,\n+            &[],\n+        );\n \n         println!(\"Checking rustdoc artifacts ({} -> {})\", &compiler.host, target);\n-        run_cargo(builder,\n-                  cargo,\n-                  args(builder.kind),\n-                  &rustdoc_stamp(builder, compiler, target),\n-                  vec![],\n-                  true);\n+        run_cargo(\n+            builder,\n+            cargo,\n+            args(builder.kind),\n+            &rustdoc_stamp(builder, compiler, target),\n+            vec![],\n+            true,\n+        );\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n         let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n@@ -188,6 +190,5 @@ pub fn rustdoc_stamp(\n     compiler: Compiler,\n     target: Interned<String>,\n ) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::ToolRustc, target)\n-        .join(\".rustdoc-check.stamp\")\n+    builder.cargo_out(compiler, Mode::ToolRustc, target).join(\".rustdoc-check.stamp\")\n }"}, {"sha": "b4e58c06fdea902e39a0ad2f5d838632af388be3", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -31,7 +31,7 @@ pub fn clean(build: &Build, all: bool) {\n             for entry in entries {\n                 let entry = t!(entry);\n                 if entry.file_name().to_str() == Some(\"llvm\") {\n-                    continue\n+                    continue;\n                 }\n                 let path = t!(entry.path().canonicalize());\n                 rm_rf(&path);\n@@ -47,7 +47,7 @@ fn rm_rf(path: &Path) {\n                 return;\n             }\n             panic!(\"failed to get metadata for file {}: {}\", path.display(), e);\n-        },\n+        }\n         Ok(metadata) => {\n             if metadata.file_type().is_file() || metadata.file_type().is_symlink() {\n                 do_op(path, \"remove file\", |p| fs::remove_file(p));\n@@ -58,20 +58,20 @@ fn rm_rf(path: &Path) {\n                 rm_rf(&t!(file).path());\n             }\n             do_op(path, \"remove dir\", |p| fs::remove_dir(p));\n-        },\n+        }\n     };\n }\n \n fn do_op<F>(path: &Path, desc: &str, mut f: F)\n-    where F: FnMut(&Path) -> io::Result<()>\n+where\n+    F: FnMut(&Path) -> io::Result<()>,\n {\n     match f(path) {\n         Ok(()) => {}\n         // On windows we can't remove a readonly file, and git will often clone files as readonly.\n         // As a result, we have some special logic to remove readonly files on windows.\n         // This is also the reason that we can't use things like fs::remove_dir_all().\n-        Err(ref e) if cfg!(windows) &&\n-                      e.kind() == ErrorKind::PermissionDenied => {\n+        Err(ref e) if cfg!(windows) && e.kind() == ErrorKind::PermissionDenied => {\n             let mut p = t!(path.symlink_metadata()).permissions();\n             p.set_readonly(false);\n             t!(fs::set_permissions(path, p));"}, {"sha": "2d60024a22ac4ec6cedf3518fd97c200605c40ee", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 132, "deletions": 140, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -9,25 +9,25 @@\n use std::borrow::Cow;\n use std::env;\n use std::fs;\n-use std::io::BufReader;\n use std::io::prelude::*;\n+use std::io::BufReader;\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Stdio, exit};\n+use std::process::{exit, Command, Stdio};\n use std::str;\n \n use build_helper::{output, t, up_to_date};\n use filetime::FileTime;\n use serde::Deserialize;\n use serde_json;\n \n-use crate::dist;\n use crate::builder::Cargo;\n-use crate::util::{exe, is_dylib};\n-use crate::{Compiler, Mode, GitRepo};\n+use crate::dist;\n use crate::native;\n+use crate::util::{exe, is_dylib};\n+use crate::{Compiler, GitRepo, Mode};\n \n-use crate::cache::{INTERNER, Interned};\n-use crate::builder::{Step, RunConfig, ShouldRun, Builder, Kind};\n+use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n+use crate::cache::{Interned, INTERNER};\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n@@ -61,22 +61,15 @@ impl Step for Std {\n \n         if builder.config.keep_stage.contains(&compiler.stage) {\n             builder.info(\"Warning: Using a potentially old libstd. This may not behave well.\");\n-            builder.ensure(StdLink {\n-                compiler,\n-                target_compiler: compiler,\n-                target,\n-            });\n+            builder.ensure(StdLink { compiler, target_compiler: compiler, target });\n             return;\n         }\n \n         let mut target_deps = builder.ensure(StartupObjects { compiler, target });\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n-            builder.ensure(Std {\n-                compiler: compiler_to_use,\n-                target,\n-            });\n+            builder.ensure(Std { compiler: compiler_to_use, target });\n             builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", compiler_to_use.host, target));\n \n             // Even if we're not building std this stage, the new sysroot must\n@@ -96,14 +89,18 @@ impl Step for Std {\n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n \n-        builder.info(&format!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target));\n-        run_cargo(builder,\n-                  cargo,\n-                  vec![],\n-                  &libstd_stamp(builder, compiler, target),\n-                  target_deps,\n-                  false);\n+        builder.info(&format!(\n+            \"Building stage{} std artifacts ({} -> {})\",\n+            compiler.stage, &compiler.host, target\n+        ));\n+        run_cargo(\n+            builder,\n+            cargo,\n+            vec![],\n+            &libstd_stamp(builder, compiler, target),\n+            target_deps,\n+            false,\n+        );\n \n         builder.ensure(StdLink {\n             compiler: builder.compiler(compiler.stage, builder.config.build),\n@@ -114,19 +111,18 @@ impl Step for Std {\n }\n \n /// Copies third party objects needed by various targets.\n-fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target: Interned<String>)\n-    -> Vec<PathBuf>\n-{\n+fn copy_third_party_objects(\n+    builder: &Builder<'_>,\n+    compiler: &Compiler,\n+    target: Interned<String>,\n+) -> Vec<PathBuf> {\n     let libdir = builder.sysroot_libdir(*compiler, target);\n \n     let mut target_deps = vec![];\n \n     let mut copy_and_stamp = |sourcedir: &Path, name: &str| {\n         let target = libdir.join(name);\n-        builder.copy(\n-            &sourcedir.join(name),\n-            &target,\n-        );\n+        builder.copy(&sourcedir.join(name), &target);\n         target_deps.push(target);\n     };\n \n@@ -162,10 +158,12 @@ fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target:\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(builder: &Builder<'_>,\n-                 compiler: &Compiler,\n-                 target: Interned<String>,\n-                 cargo: &mut Cargo) {\n+pub fn std_cargo(\n+    builder: &Builder<'_>,\n+    compiler: &Compiler,\n+    target: Interned<String>,\n+    cargo: &mut Cargo,\n+) {\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n@@ -216,14 +214,14 @@ pub fn std_cargo(builder: &Builder<'_>,\n             // missing\n             // We also only build the runtimes when --enable-sanitizers (or its\n             // config.toml equivalent) is used\n-            let llvm_config = builder.ensure(native::Llvm {\n-                target: builder.config.build,\n-            });\n+            let llvm_config = builder.ensure(native::Llvm { target: builder.config.build });\n             cargo.env(\"LLVM_CONFIG\", llvm_config);\n             cargo.env(\"RUSTC_BUILD_SANITIZERS\", \"1\");\n         }\n \n-        cargo.arg(\"--features\").arg(features)\n+        cargo\n+            .arg(\"--features\")\n+            .arg(features)\n             .arg(\"--manifest-path\")\n             .arg(builder.src.join(\"src/libtest/Cargo.toml\"));\n \n@@ -271,12 +269,10 @@ impl Step for StdLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        builder.info(&format!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n-                target_compiler.stage,\n-                compiler.stage,\n-                &compiler.host,\n-                target_compiler.host,\n-                target));\n+        builder.info(&format!(\n+            \"Copying stage{} std from stage{} ({} -> {} / {})\",\n+            target_compiler.stage, compiler.stage, &compiler.host, target_compiler.host, target\n+        ));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n         let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n         add_to_sysroot(builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n@@ -337,7 +333,7 @@ impl Step for StartupObjects {\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"windows-gnu\") {\n-            return vec![]\n+            return vec![];\n         }\n \n         let mut target_deps = vec![];\n@@ -352,12 +348,17 @@ impl Step for StartupObjects {\n             let dst_file = &dst_dir.join(file.to_string() + \".o\");\n             if !up_to_date(src_file, dst_file) {\n                 let mut cmd = Command::new(&builder.initial_rustc);\n-                builder.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n-                            .arg(\"--cfg\").arg(\"bootstrap\")\n-                            .arg(\"--target\").arg(target)\n-                            .arg(\"--emit=obj\")\n-                            .arg(\"-o\").arg(dst_file)\n-                            .arg(src_file));\n+                builder.run(\n+                    cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n+                        .arg(\"--cfg\")\n+                        .arg(\"bootstrap\")\n+                        .arg(\"--target\")\n+                        .arg(target)\n+                        .arg(\"--emit=obj\")\n+                        .arg(\"-o\")\n+                        .arg(dst_file)\n+                        .arg(src_file),\n+                );\n             }\n \n             let target = sysroot_dir.join(file.to_string() + \".o\");\n@@ -366,10 +367,7 @@ impl Step for StartupObjects {\n         }\n \n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n-            let src = compiler_file(builder,\n-                                    builder.cc(target),\n-                                    target,\n-                                    obj);\n+            let src = compiler_file(builder, builder.cc(target), target, obj);\n             let target = sysroot_dir.join(obj);\n             builder.copy(&src, &target);\n             target_deps.push(target);\n@@ -414,22 +412,15 @@ impl Step for Rustc {\n \n         if builder.config.keep_stage.contains(&compiler.stage) {\n             builder.info(\"Warning: Using a potentially old librustc. This may not behave well.\");\n-            builder.ensure(RustcLink {\n-                compiler,\n-                target_compiler: compiler,\n-                target,\n-            });\n+            builder.ensure(RustcLink { compiler, target_compiler: compiler, target });\n             return;\n         }\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n-            builder.ensure(Rustc {\n-                compiler: compiler_to_use,\n-                target,\n-            });\n-            builder.info(&format!(\"Uplifting stage1 rustc ({} -> {})\",\n-                builder.config.build, target));\n+            builder.ensure(Rustc { compiler: compiler_to_use, target });\n+            builder\n+                .info(&format!(\"Uplifting stage1 rustc ({} -> {})\", builder.config.build, target));\n             builder.ensure(RustcLink {\n                 compiler: compiler_to_use,\n                 target_compiler: compiler,\n@@ -447,14 +438,18 @@ impl Step for Rustc {\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"build\");\n         rustc_cargo(builder, &mut cargo, target);\n \n-        builder.info(&format!(\"Building stage{} compiler artifacts ({} -> {})\",\n-                 compiler.stage, &compiler.host, target));\n-        run_cargo(builder,\n-                  cargo,\n-                  vec![],\n-                  &librustc_stamp(builder, compiler, target),\n-                  vec![],\n-                  false);\n+        builder.info(&format!(\n+            \"Building stage{} compiler artifacts ({} -> {})\",\n+            compiler.stage, &compiler.host, target\n+        ));\n+        run_cargo(\n+            builder,\n+            cargo,\n+            vec![],\n+            &librustc_stamp(builder, compiler, target),\n+            vec![],\n+            false,\n+        );\n \n         // We used to build librustc_codegen_llvm as a separate step,\n         // which produced a dylib that the compiler would dlopen() at runtime.\n@@ -503,19 +498,22 @@ impl Step for Rustc {\n }\n \n pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Cargo, target: Interned<String>) {\n-    cargo.arg(\"--features\").arg(builder.rustc_features())\n-         .arg(\"--manifest-path\")\n-         .arg(builder.src.join(\"src/rustc/Cargo.toml\"));\n+    cargo\n+        .arg(\"--features\")\n+        .arg(builder.rustc_features())\n+        .arg(\"--manifest-path\")\n+        .arg(builder.src.join(\"src/rustc/Cargo.toml\"));\n     rustc_cargo_env(builder, cargo, target);\n }\n \n pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: Interned<String>) {\n     // Set some configuration variables picked up by build scripts and\n     // the compiler alike\n-    cargo.env(\"CFG_RELEASE\", builder.rust_release())\n-         .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n-         .env(\"CFG_VERSION\", builder.rust_version())\n-         .env(\"CFG_PREFIX\", builder.config.prefix.clone().unwrap_or_default());\n+    cargo\n+        .env(\"CFG_RELEASE\", builder.rust_release())\n+        .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n+        .env(\"CFG_VERSION\", builder.rust_version())\n+        .env(\"CFG_PREFIX\", builder.config.prefix.clone().unwrap_or_default());\n \n     let libdir_relative = builder.config.libdir_relative().unwrap_or(Path::new(\"lib\"));\n     cargo.env(\"CFG_LIBDIR_RELATIVE\", libdir_relative);\n@@ -561,14 +559,12 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: Interne\n         }\n         // Building with a static libstdc++ is only supported on linux right now,\n         // not for MSVC or macOS\n-        if builder.config.llvm_static_stdcpp &&\n-           !target.contains(\"freebsd\") &&\n-           !target.contains(\"msvc\") &&\n-           !target.contains(\"apple\") {\n-            let file = compiler_file(builder,\n-                                     builder.cxx(target).unwrap(),\n-                                     target,\n-                                     \"libstdc++.a\");\n+        if builder.config.llvm_static_stdcpp\n+            && !target.contains(\"freebsd\")\n+            && !target.contains(\"msvc\")\n+            && !target.contains(\"apple\")\n+        {\n+            let file = compiler_file(builder, builder.cxx(target).unwrap(), target, \"libstdc++.a\");\n             cargo.env(\"LLVM_STATIC_STDCPP\", file);\n         }\n         if builder.config.llvm_link_shared || builder.config.llvm_thin_lto {\n@@ -602,17 +598,15 @@ impl Step for RustcLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        builder.info(&format!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n-                 target_compiler.stage,\n-                 compiler.stage,\n-                 &compiler.host,\n-                 target_compiler.host,\n-                 target));\n+        builder.info(&format!(\n+            \"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n+            target_compiler.stage, compiler.stage, &compiler.host, target_compiler.host, target\n+        ));\n         add_to_sysroot(\n             builder,\n             &builder.sysroot_libdir(target_compiler, target),\n             &builder.sysroot_libdir(target_compiler, compiler.host),\n-            &librustc_stamp(builder, compiler, target)\n+            &librustc_stamp(builder, compiler, target),\n         );\n     }\n }\n@@ -706,8 +700,10 @@ impl Step for Assemble {\n         let target_compiler = self.target_compiler;\n \n         if target_compiler.stage == 0 {\n-            assert_eq!(builder.config.build, target_compiler.host,\n-                \"Cannot obtain compiler for non-native build triple at stage 0\");\n+            assert_eq!(\n+                builder.config.build, target_compiler.host,\n+                \"Cannot obtain compiler for non-native build triple at stage 0\"\n+            );\n             // The stage 0 compiler for the build triple is always pre-built.\n             return target_compiler;\n         }\n@@ -728,23 +724,17 @@ impl Step for Assemble {\n         //\n         // FIXME: It may be faster if we build just a stage 1 compiler and then\n         //        use that to bootstrap this compiler forward.\n-        let build_compiler =\n-            builder.compiler(target_compiler.stage - 1, builder.config.build);\n+        let build_compiler = builder.compiler(target_compiler.stage - 1, builder.config.build);\n \n         // Build the libraries for this compiler to link to (i.e., the libraries\n         // it uses at runtime). NOTE: Crates the target compiler compiles don't\n         // link to these. (FIXME: Is that correct? It seems to be correct most\n         // of the time but I think we do link to these for stage2/bin compilers\n         // when not performing a full bootstrap).\n-        builder.ensure(Rustc {\n-            compiler: build_compiler,\n-            target: target_compiler.host,\n-        });\n+        builder.ensure(Rustc { compiler: build_compiler, target: target_compiler.host });\n \n         let lld_install = if builder.config.lld_enabled {\n-            Some(builder.ensure(native::Lld {\n-                target: target_compiler.host,\n-            }))\n+            Some(builder.ensure(native::Lld { target: target_compiler.host }))\n         } else {\n             None\n         };\n@@ -801,7 +791,7 @@ pub fn add_to_sysroot(\n     builder: &Builder<'_>,\n     sysroot_dst: &Path,\n     sysroot_host_dst: &Path,\n-    stamp: &Path\n+    stamp: &Path,\n ) {\n     t!(fs::create_dir_all(&sysroot_dst));\n     t!(fs::create_dir_all(&sysroot_host_dst));\n@@ -814,14 +804,14 @@ pub fn add_to_sysroot(\n     }\n }\n \n-pub fn run_cargo(builder: &Builder<'_>,\n-                 cargo: Cargo,\n-                 tail_args: Vec<String>,\n-                 stamp: &Path,\n-                 additional_target_deps: Vec<PathBuf>,\n-                 is_check: bool)\n-    -> Vec<PathBuf>\n-{\n+pub fn run_cargo(\n+    builder: &Builder<'_>,\n+    cargo: Cargo,\n+    tail_args: Vec<String>,\n+    stamp: &Path,\n+    additional_target_deps: Vec<PathBuf>,\n+    is_check: bool,\n+) -> Vec<PathBuf> {\n     if builder.config.dry_run {\n         return Vec::new();\n     }\n@@ -831,9 +821,12 @@ pub fn run_cargo(builder: &Builder<'_>,\n     // `target_deps_dir` looks like $dir/$target/release/deps\n     let target_deps_dir = target_root_dir.join(\"deps\");\n     // `host_root_dir` looks like $dir/release\n-    let host_root_dir = target_root_dir.parent().unwrap() // chop off `release`\n-                                       .parent().unwrap() // chop off `$target`\n-                                       .join(target_root_dir.file_name().unwrap());\n+    let host_root_dir = target_root_dir\n+        .parent()\n+        .unwrap() // chop off `release`\n+        .parent()\n+        .unwrap() // chop off `$target`\n+        .join(target_root_dir.file_name().unwrap());\n \n     // Spawn Cargo slurping up its JSON output. We'll start building up the\n     // `deps` array of all files it generated along with a `toplevel` array of\n@@ -844,20 +837,19 @@ pub fn run_cargo(builder: &Builder<'_>,\n         let (filenames, crate_types) = match msg {\n             CargoMessage::CompilerArtifact {\n                 filenames,\n-                target: CargoTarget {\n-                    crate_types,\n-                },\n+                target: CargoTarget { crate_types },\n                 ..\n             } => (filenames, crate_types),\n             _ => return,\n         };\n         for filename in filenames {\n             // Skip files like executables\n-            if !filename.ends_with(\".rlib\") &&\n-               !filename.ends_with(\".lib\") &&\n-               !filename.ends_with(\".a\") &&\n-               !is_dylib(&filename) &&\n-               !(is_check && filename.ends_with(\".rmeta\")) {\n+            if !filename.ends_with(\".rlib\")\n+                && !filename.ends_with(\".lib\")\n+                && !filename.ends_with(\".a\")\n+                && !is_dylib(&filename)\n+                && !(is_check && filename.ends_with(\".rmeta\"))\n+            {\n                 continue;\n             }\n \n@@ -913,14 +905,13 @@ pub fn run_cargo(builder: &Builder<'_>,\n         .collect::<Vec<_>>();\n     for (prefix, extension, expected_len) in toplevel {\n         let candidates = contents.iter().filter(|&&(_, ref filename, ref meta)| {\n-            filename.starts_with(&prefix[..]) &&\n-                filename[prefix.len()..].starts_with(\"-\") &&\n-                filename.ends_with(&extension[..]) &&\n-                meta.len() == expected_len\n-        });\n-        let max = candidates.max_by_key(|&&(_, _, ref metadata)| {\n-            FileTime::from_last_modification_time(metadata)\n+            filename.starts_with(&prefix[..])\n+                && filename[prefix.len()..].starts_with(\"-\")\n+                && filename.ends_with(&extension[..])\n+                && meta.len() == expected_len\n         });\n+        let max = candidates\n+            .max_by_key(|&&(_, _, ref metadata)| FileTime::from_last_modification_time(metadata));\n         let path_to_add = match max {\n             Some(triple) => triple.0.to_str().unwrap(),\n             None => panic!(\"no output generated for {:?} {:?}\", prefix, extension),\n@@ -960,7 +951,7 @@ pub fn stream_cargo(\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n     let mut message_format = String::from(\"json-render-diagnostics\");\n-    if let Some(s) = &builder.config.rustc_error_format  {\n+    if let Some(s) = &builder.config.rustc_error_format {\n         message_format.push_str(\",json-diagnostic-\");\n         message_format.push_str(s);\n     }\n@@ -985,17 +976,18 @@ pub fn stream_cargo(\n         match serde_json::from_str::<CargoMessage<'_>>(&line) {\n             Ok(msg) => cb(msg),\n             // If this was informational, just print it out and continue\n-            Err(_) => println!(\"{}\", line)\n+            Err(_) => println!(\"{}\", line),\n         }\n     }\n \n     // Make sure Cargo actually succeeded after we read all of its stdout.\n     let status = t!(child.wait());\n     if !status.success() {\n-        eprintln!(\"command did not execute successfully: {:?}\\n\\\n+        eprintln!(\n+            \"command did not execute successfully: {:?}\\n\\\n                   expected success, got: {}\",\n-                 cargo,\n-                 status);\n+            cargo, status\n+        );\n     }\n     status.success()\n }"}, {"sha": "11bfc7a47cc48322a2aa7a4488660f9778ae8af7", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -3,20 +3,20 @@\n //! This module implements parsing `config.toml` configuration files to tweak\n //! how the build runs.\n \n+use std::cmp;\n use std::collections::{HashMap, HashSet};\n use std::env;\n use std::ffi::OsString;\n use std::fs;\n use std::path::{Path, PathBuf};\n use std::process;\n-use std::cmp;\n \n-use build_helper::t;\n-use toml;\n-use serde::Deserialize;\n-use crate::cache::{INTERNER, Interned};\n+use crate::cache::{Interned, INTERNER};\n use crate::flags::Flags;\n pub use crate::flags::Subcommand;\n+use build_helper::t;\n+use serde::Deserialize;\n+use toml;\n \n /// Global configuration for the entire build and/or bootstrap.\n ///\n@@ -420,17 +420,22 @@ impl Config {\n         let has_targets = !flags.target.is_empty();\n         config.skip_only_host_steps = !has_hosts && has_targets;\n \n-        let toml = file.map(|file| {\n-            let contents = t!(fs::read_to_string(&file));\n-            match toml::from_str(&contents) {\n-                Ok(table) => table,\n-                Err(err) => {\n-                    println!(\"failed to parse TOML configuration '{}': {}\",\n-                        file.display(), err);\n-                    process::exit(2);\n+        let toml = file\n+            .map(|file| {\n+                let contents = t!(fs::read_to_string(&file));\n+                match toml::from_str(&contents) {\n+                    Ok(table) => table,\n+                    Err(err) => {\n+                        println!(\n+                            \"failed to parse TOML configuration '{}': {}\",\n+                            file.display(),\n+                            err\n+                        );\n+                        process::exit(2);\n+                    }\n                 }\n-            }\n-        }).unwrap_or_else(|| TomlConfig::default());\n+            })\n+            .unwrap_or_else(|| TomlConfig::default());\n \n         let build = toml.build.clone().unwrap_or_default();\n         // set by bootstrap.py\n@@ -441,24 +446,15 @@ impl Config {\n                 config.hosts.push(host);\n             }\n         }\n-        for target in config.hosts.iter().cloned()\n-            .chain(build.target.iter().map(|s| INTERNER.intern_str(s)))\n+        for target in\n+            config.hosts.iter().cloned().chain(build.target.iter().map(|s| INTERNER.intern_str(s)))\n         {\n             if !config.targets.contains(&target) {\n                 config.targets.push(target);\n             }\n         }\n-        config.hosts = if !flags.host.is_empty() {\n-            flags.host\n-        } else {\n-            config.hosts\n-        };\n-        config.targets = if !flags.target.is_empty() {\n-            flags.target\n-        } else {\n-            config.targets\n-        };\n-\n+        config.hosts = if !flags.host.is_empty() { flags.host } else { config.hosts };\n+        config.targets = if !flags.target.is_empty() { flags.target } else { config.targets };\n \n         config.nodejs = build.nodejs.map(PathBuf::from);\n         config.gdb = build.gdb.map(PathBuf::from);\n@@ -507,9 +503,7 @@ impl Config {\n \n         if let Some(ref llvm) = toml.llvm {\n             match llvm.ccache {\n-                Some(StringOrBool::String(ref s)) => {\n-                    config.ccache = Some(s.to_string())\n-                }\n+                Some(StringOrBool::String(ref s)) => config.ccache = Some(s.to_string()),\n                 Some(StringOrBool::Bool(true)) => {\n                     config.ccache = Some(\"ccache\".to_string());\n                 }\n@@ -574,9 +568,8 @@ impl Config {\n             set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n \n             if let Some(ref backends) = rust.codegen_backends {\n-                config.rust_codegen_backends = backends.iter()\n-                    .map(|s| INTERNER.intern_str(s))\n-                    .collect();\n+                config.rust_codegen_backends =\n+                    backends.iter().map(|s| INTERNER.intern_str(s)).collect();\n             }\n \n             config.rust_codegen_units = rust.codegen_units.map(threads_from_config);\n@@ -634,9 +627,11 @@ impl Config {\n         config.rust_debug_assertions = debug_assertions.unwrap_or(default);\n \n         let with_defaults = |debuginfo_level_specific: Option<u32>| {\n-            debuginfo_level_specific\n-                .or(debuginfo_level)\n-                .unwrap_or(if debug == Some(true) { 2 } else { 0 })\n+            debuginfo_level_specific.or(debuginfo_level).unwrap_or(if debug == Some(true) {\n+                2\n+            } else {\n+                0\n+            })\n         };\n         config.rust_debuginfo_level_rustc = with_defaults(debuginfo_level_rustc);\n         config.rust_debuginfo_level_std = with_defaults(debuginfo_level_std);"}, {"sha": "e64d4c8637d5527c1b0c4142b7b789fd9042d7e9", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 563, "deletions": 447, "changes": 1010, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -11,18 +11,18 @@\n use std::env;\n use std::fs;\n use std::io::Write;\n-use std::path::{PathBuf, Path};\n+use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n \n use build_helper::{output, t};\n \n-use crate::{Compiler, Mode, LLVM_TOOLS};\n-use crate::channel;\n-use crate::util::{is_dylib, exe, timeit};\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use crate::cache::{Interned, INTERNER};\n+use crate::channel;\n use crate::compile;\n use crate::tool::{self, Tool};\n-use crate::cache::{INTERNER, Interned};\n+use crate::util::{exe, is_dylib, timeit};\n+use crate::{Compiler, Mode, LLVM_TOOLS};\n use time::{self, Timespec};\n \n pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n@@ -80,9 +80,7 @@ impl Step for Docs {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Docs {\n-            host: run.target,\n-        });\n+        run.builder.ensure(Docs { host: run.target });\n     }\n \n     /// Builds the `rust-docs` installer component.\n@@ -110,16 +108,19 @@ impl Step for Docs {\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust-Documentation\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=Rust-documentation-is-installed.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(format!(\"--package-name={}-{}\", name, host))\n-           .arg(\"--component-name=rust-docs\")\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-           .arg(\"--bulk-dirs=share/doc/rust/html\");\n+            .arg(\"--product-name=Rust-Documentation\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=Rust-documentation-is-installed.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(format!(\"--package-name={}-{}\", name, host))\n+            .arg(\"--component-name=rust-docs\")\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(\"--bulk-dirs=share/doc/rust/html\");\n         builder.run(&mut cmd);\n         builder.remove_dir(&image);\n \n@@ -141,9 +142,7 @@ impl Step for RustcDocs {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(RustcDocs {\n-            host: run.target,\n-        });\n+        run.builder.ensure(RustcDocs { host: run.target });\n     }\n \n     /// Builds the `rustc-docs` installer component.\n@@ -168,16 +167,19 @@ impl Step for RustcDocs {\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rustc-Documentation\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=Rustc-documentation-is-installed.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(format!(\"--package-name={}-{}\", name, host))\n-           .arg(\"--component-name=rustc-docs\")\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-           .arg(\"--bulk-dirs=share/doc/rust/html\");\n+            .arg(\"--product-name=Rustc-Documentation\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=Rustc-documentation-is-installed.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(format!(\"--package-name={}-{}\", name, host))\n+            .arg(\"--component-name=rustc-docs\")\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(\"--bulk-dirs=share/doc/rust/html\");\n \n         builder.info(&format!(\"Dist compiler docs ({})\", host));\n         let _time = timeit(builder);\n@@ -192,10 +194,7 @@ fn find_files(files: &[&str], path: &[PathBuf]) -> Vec<PathBuf> {\n     let mut found = Vec::with_capacity(files.len());\n \n     for file in files {\n-        let file_path =\n-            path.iter()\n-                .map(|dir| dir.join(file))\n-                .find(|p| p.exists());\n+        let file_path = path.iter().map(|dir| dir.join(file)).find(|p| p.exists());\n \n         if let Some(file_path) = file_path {\n             found.push(file_path);\n@@ -208,7 +207,10 @@ fn find_files(files: &[&str], path: &[PathBuf]) -> Vec<PathBuf> {\n }\n \n fn make_win_dist(\n-    rust_root: &Path, plat_root: &Path, target_triple: Interned<String>, builder: &Builder<'_>\n+    rust_root: &Path,\n+    plat_root: &Path,\n+    target_triple: Interned<String>,\n+    builder: &Builder<'_>,\n ) {\n     //Ask gcc where it keeps its stuff\n     let mut cmd = Command::new(builder.cc(target_triple));\n@@ -222,11 +224,7 @@ fn make_win_dist(\n         let idx = line.find(':').unwrap();\n         let key = &line[..idx];\n         let trim_chars: &[_] = &[' ', '='];\n-        let value =\n-            line[(idx + 1)..]\n-                .trim_start_matches(trim_chars)\n-                .split(';')\n-                .map(PathBuf::from);\n+        let value = line[(idx + 1)..].trim_start_matches(trim_chars).split(';').map(PathBuf::from);\n \n         if key == \"programs\" {\n             bin_path.extend(value);\n@@ -243,7 +241,8 @@ fn make_win_dist(\n         rustc_dlls.push(\"libgcc_s_seh-1.dll\");\n     }\n \n-    let target_libs = [ //MinGW libs\n+    let target_libs = [\n+        //MinGW libs\n         \"libgcc.a\",\n         \"libgcc_eh.a\",\n         \"libgcc_s.a\",\n@@ -312,7 +311,7 @@ fn make_win_dist(\n         &target_bin_dir.join(\"GCC-WARNING.txt\"),\n         \"gcc.exe contained in this folder cannot be used for compiling C files - it is only\\\n          used as a linker. In order to be able to compile projects containing C code use\\\n-         the GCC provided by MinGW or Cygwin.\"\n+         the GCC provided by MinGW or Cygwin.\",\n     );\n \n     //Copy platform libs to platform-specific lib directory\n@@ -366,15 +365,18 @@ impl Step for Mingw {\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust-MinGW\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=Rust-MinGW-is-installed.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(format!(\"--package-name={}-{}\", name, host))\n-           .arg(\"--component-name=rust-mingw\")\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+            .arg(\"--product-name=Rust-MinGW\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=Rust-MinGW-is-installed.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(format!(\"--package-name={}-{}\", name, host))\n+            .arg(\"--component-name=rust-mingw\")\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         builder.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n         Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host)))\n@@ -396,9 +398,8 @@ impl Step for Rustc {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustc {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.target),\n-        });\n+        run.builder\n+            .ensure(Rustc { compiler: run.builder.compiler(run.builder.top_stage, run.target) });\n     }\n \n     /// Creates the `rustc` installer component.\n@@ -452,16 +453,20 @@ impl Step for Rustc {\n         // Finally, wrap everything up in a nice tarball!\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(\"--non-installed-overlay\").arg(&overlay)\n-           .arg(format!(\"--package-name={}-{}\", name, host))\n-           .arg(\"--component-name=rustc\")\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=Rust-is-ready-to-roll.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\")\n+            .arg(&overlay)\n+            .arg(format!(\"--package-name={}-{}\", name, host))\n+            .arg(\"--component-name=rustc\")\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n \n         builder.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, host));\n         let _time = timeit(builder);\n@@ -508,16 +513,10 @@ impl Step for Rustc {\n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n                 let exe = exe(\"rust-lld\", &compiler.host);\n-                let src = builder.sysroot_libdir(compiler, host)\n-                    .parent()\n-                    .unwrap()\n-                    .join(\"bin\")\n-                    .join(&exe);\n+                let src =\n+                    builder.sysroot_libdir(compiler, host).parent().unwrap().join(\"bin\").join(&exe);\n                 // for the rationale about this rename check `compile::copy_lld_to_sysroot`\n-                let dst = image.join(\"lib/rustlib\")\n-                    .join(&*host)\n-                    .join(\"bin\")\n-                    .join(&exe);\n+                let dst = image.join(\"lib/rustlib\").join(&*host).join(\"bin\").join(&exe);\n                 t!(fs::create_dir_all(&dst.parent().unwrap()));\n                 builder.copy(&src, &dst);\n             }\n@@ -530,9 +529,10 @@ impl Step for Rustc {\n             // Reproducible builds: If SOURCE_DATE_EPOCH is set, use that as the time.\n             let time = env::var(\"SOURCE_DATE_EPOCH\")\n                 .map(|timestamp| {\n-                    let epoch = timestamp.parse().map_err(|err| {\n-                        format!(\"could not parse SOURCE_DATE_EPOCH: {}\", err)\n-                    }).unwrap();\n+                    let epoch = timestamp\n+                        .parse()\n+                        .map_err(|err| format!(\"could not parse SOURCE_DATE_EPOCH: {}\", err))\n+                        .unwrap();\n \n                     time::at(Timespec::new(epoch, 0))\n                 })\n@@ -546,16 +546,18 @@ impl Step for Rustc {\n                 let page_dst = man_dst.join(file_entry.file_name());\n                 t!(fs::copy(&page_src, &page_dst));\n                 // template in month/year and version number\n-                builder.replace_in_file(&page_dst,\n-                                &[(\"<INSERT DATE HERE>\", &month_year),\n-                                  (\"<INSERT VERSION HERE>\", channel::CFG_RELEASE_NUM)]);\n+                builder.replace_in_file(\n+                    &page_dst,\n+                    &[\n+                        (\"<INSERT DATE HERE>\", &month_year),\n+                        (\"<INSERT VERSION HERE>\", channel::CFG_RELEASE_NUM),\n+                    ],\n+                );\n             }\n \n             // Debugger scripts\n-            builder.ensure(DebuggerScripts {\n-                sysroot: INTERNER.intern_path(image.to_owned()),\n-                host,\n-            });\n+            builder\n+                .ensure(DebuggerScripts { sysroot: INTERNER.intern_path(image.to_owned()), host });\n \n             // Misc license info\n             let cp = |file: &str| {\n@@ -600,8 +602,11 @@ impl Step for DebuggerScripts {\n         };\n         if host.contains(\"windows-msvc\") {\n             // windbg debugger scripts\n-            builder.install(&builder.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n-                0o755);\n+            builder.install(\n+                &builder.src.join(\"src/etc/rust-windbg.cmd\"),\n+                &sysroot.join(\"bin\"),\n+                0o755,\n+            );\n \n             cp_debugger_script(\"natvis/intrinsic.natvis\");\n             cp_debugger_script(\"natvis/liballoc.natvis\");\n@@ -611,17 +616,14 @@ impl Step for DebuggerScripts {\n             cp_debugger_script(\"debugger_pretty_printers_common.py\");\n \n             // gdb debugger scripts\n-            builder.install(&builder.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n-                    0o755);\n-            builder.install(&builder.src.join(\"src/etc/rust-gdbgui\"), &sysroot.join(\"bin\"),\n-                    0o755);\n+            builder.install(&builder.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"), 0o755);\n+            builder.install(&builder.src.join(\"src/etc/rust-gdbgui\"), &sysroot.join(\"bin\"), 0o755);\n \n             cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n             cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n \n             // lldb debugger scripts\n-            builder.install(&builder.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n-                    0o755);\n+            builder.install(&builder.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"), 0o755);\n \n             cp_debugger_script(\"lldb_rust_formatters.py\");\n         }\n@@ -696,18 +698,21 @@ impl Step for Std {\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=std-is-standing-at-the-ready.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(format!(\"--package-name={}-{}\", name, target))\n-           .arg(format!(\"--component-name=rust-std-{}\", target))\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-\n-        builder.info(&format!(\"Dist std stage{} ({} -> {})\",\n-            compiler.stage, &compiler.host, target));\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=std-is-standing-at-the-ready.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(format!(\"--component-name=rust-std-{}\", target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+\n+        builder\n+            .info(&format!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host, target));\n         let _time = timeit(builder);\n         builder.run(&mut cmd);\n         builder.remove_dir(&image);\n@@ -762,18 +767,23 @@ impl Step for RustcDev {\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=Rust-is-ready-to-develop.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(format!(\"--package-name={}-{}\", name, target))\n-           .arg(format!(\"--component-name=rustc-dev-{}\", target))\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-\n-        builder.info(&format!(\"Dist rustc-dev stage{} ({} -> {})\",\n-            compiler.stage, &compiler.host, target));\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=Rust-is-ready-to-develop.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(format!(\"--component-name=rustc-dev-{}\", target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+\n+        builder.info(&format!(\n+            \"Dist rustc-dev stage{} ({} -> {})\",\n+            compiler.stage, &compiler.host, target\n+        ));\n         let _time = timeit(builder);\n         builder.run(&mut cmd);\n         builder.remove_dir(&image);\n@@ -825,8 +835,11 @@ impl Step for Analysis {\n \n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n \n-        let src = builder.stage_out(compiler, Mode::Std)\n-            .join(target).join(builder.cargo_dir()).join(\"deps\");\n+        let src = builder\n+            .stage_out(compiler, Mode::Std)\n+            .join(target)\n+            .join(builder.cargo_dir())\n+            .join(\"deps\");\n \n         let image_src = src.join(\"save-analysis\");\n         let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n@@ -836,15 +849,18 @@ impl Step for Analysis {\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=save-analysis-saved.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(format!(\"--package-name={}-{}\", name, target))\n-           .arg(format!(\"--component-name=rust-analysis-{}\", target))\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=save-analysis-saved.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(format!(\"--component-name=rust-analysis-{}\", target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n \n         builder.info(\"Dist analysis\");\n         let _time = timeit(builder);\n@@ -861,31 +877,35 @@ fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str]\n             None => return false,\n         };\n         if spath.ends_with(\"~\") || spath.ends_with(\".pyc\") {\n-            return false\n+            return false;\n         }\n \n         const LLVM_PROJECTS: &[&str] = &[\n-            \"llvm-project/clang\", \"llvm-project\\\\clang\",\n-            \"llvm-project/libunwind\", \"llvm-project\\\\libunwind\",\n-            \"llvm-project/lld\", \"llvm-project\\\\lld\",\n-            \"llvm-project/lldb\", \"llvm-project\\\\lldb\",\n-            \"llvm-project/llvm\", \"llvm-project\\\\llvm\",\n-            \"llvm-project/compiler-rt\", \"llvm-project\\\\compiler-rt\",\n+            \"llvm-project/clang\",\n+            \"llvm-project\\\\clang\",\n+            \"llvm-project/libunwind\",\n+            \"llvm-project\\\\libunwind\",\n+            \"llvm-project/lld\",\n+            \"llvm-project\\\\lld\",\n+            \"llvm-project/lldb\",\n+            \"llvm-project\\\\lldb\",\n+            \"llvm-project/llvm\",\n+            \"llvm-project\\\\llvm\",\n+            \"llvm-project/compiler-rt\",\n+            \"llvm-project\\\\compiler-rt\",\n         ];\n-        if spath.contains(\"llvm-project\") && !spath.ends_with(\"llvm-project\")\n+        if spath.contains(\"llvm-project\")\n+            && !spath.ends_with(\"llvm-project\")\n             && !LLVM_PROJECTS.iter().any(|path| spath.contains(path))\n         {\n             return false;\n         }\n \n-        const LLVM_TEST: &[&str] = &[\n-            \"llvm-project/llvm/test\", \"llvm-project\\\\llvm\\\\test\",\n-        ];\n-        if LLVM_TEST.iter().any(|path| spath.contains(path)) &&\n-            (spath.ends_with(\".ll\") ||\n-             spath.ends_with(\".td\") ||\n-             spath.ends_with(\".s\")) {\n-            return false\n+        const LLVM_TEST: &[&str] = &[\"llvm-project/llvm/test\", \"llvm-project\\\\llvm\\\\test\"];\n+        if LLVM_TEST.iter().any(|path| spath.contains(path))\n+            && (spath.ends_with(\".ll\") || spath.ends_with(\".td\") || spath.ends_with(\".s\"))\n+        {\n+            return false;\n         }\n \n         let full_path = Path::new(dir).join(path);\n@@ -894,22 +914,37 @@ fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str]\n         }\n \n         let excludes = [\n-            \"CVS\", \"RCS\", \"SCCS\", \".git\", \".gitignore\", \".gitmodules\",\n-            \".gitattributes\", \".cvsignore\", \".svn\", \".arch-ids\", \"{arch}\",\n-            \"=RELEASE-ID\", \"=meta-update\", \"=update\", \".bzr\", \".bzrignore\",\n-            \".bzrtags\", \".hg\", \".hgignore\", \".hgrags\", \"_darcs\",\n+            \"CVS\",\n+            \"RCS\",\n+            \"SCCS\",\n+            \".git\",\n+            \".gitignore\",\n+            \".gitmodules\",\n+            \".gitattributes\",\n+            \".cvsignore\",\n+            \".svn\",\n+            \".arch-ids\",\n+            \"{arch}\",\n+            \"=RELEASE-ID\",\n+            \"=meta-update\",\n+            \"=update\",\n+            \".bzr\",\n+            \".bzrignore\",\n+            \".bzrtags\",\n+            \".hg\",\n+            \".hgignore\",\n+            \".hgrags\",\n+            \"_darcs\",\n         ];\n-        !path.iter()\n-             .map(|s| s.to_str().unwrap())\n-             .any(|s| excludes.contains(&s))\n+        !path.iter().map(|s| s.to_str().unwrap()).any(|s| excludes.contains(&s))\n     }\n \n     // Copy the directories using our filter\n     for item in src_dirs {\n         let dst = &dst_dir.join(item);\n         t!(fs::create_dir_all(dst));\n-        builder.cp_filtered(\n-            &builder.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n+        builder\n+            .cp_filtered(&builder.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n     }\n }\n \n@@ -940,9 +975,7 @@ impl Step for Src {\n         let dst_src = dst.join(\"rust\");\n         t!(fs::create_dir_all(&dst_src));\n \n-        let src_files = [\n-            \"Cargo.lock\",\n-        ];\n+        let src_files = [\"Cargo.lock\"];\n         // This is the reduced set of paths which will become the rust-src component\n         // (essentially libstd and all of its path dependencies)\n         let std_src_dirs = [\n@@ -977,15 +1010,18 @@ impl Step for Src {\n         // Create source tarball in rust-installer format\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=Awesome-Source.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(format!(\"--package-name={}\", name))\n-           .arg(\"--component-name=rust-src\")\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=Awesome-Source.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(format!(\"--package-name={}\", name))\n+            .arg(\"--component-name=rust-src\")\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n \n         builder.info(\"Dist src\");\n         let _time = timeit(builder);\n@@ -1036,9 +1072,7 @@ impl Step for PlainSourceTarball {\n             \"Cargo.toml\",\n             \"Cargo.lock\",\n         ];\n-        let src_dirs = [\n-            \"src\",\n-        ];\n+        let src_dirs = [\"src\"];\n \n         copy_src_dirs(builder, &src_dirs[..], &[], &plain_dst_src);\n \n@@ -1057,8 +1091,7 @@ impl Step for PlainSourceTarball {\n         if builder.rust_info.is_git() {\n             // Vendor all Cargo dependencies\n             let mut cmd = Command::new(&builder.initial_cargo);\n-            cmd.arg(\"vendor\")\n-               .current_dir(&plain_dst_src);\n+            cmd.arg(\"vendor\").current_dir(&plain_dst_src);\n             builder.run(&mut cmd);\n         }\n \n@@ -1073,10 +1106,12 @@ impl Step for PlainSourceTarball {\n         builder.info(\"running installer\");\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"tarball\")\n-           .arg(\"--input\").arg(&plain_name)\n-           .arg(\"--output\").arg(&tarball)\n-           .arg(\"--work-dir=.\")\n-           .current_dir(tmpdir(builder));\n+            .arg(\"--input\")\n+            .arg(&plain_name)\n+            .arg(\"--output\")\n+            .arg(&tarball)\n+            .arg(\"--work-dir=.\")\n+            .current_dir(tmpdir(builder));\n \n         builder.info(\"Create plain source tarball\");\n         let _time = timeit(builder);\n@@ -1095,10 +1130,10 @@ pub fn sanitize_sh(path: &Path) -> String {\n         let mut ch = s.chars();\n         let drive = ch.next().unwrap_or('C');\n         if ch.next() != Some(':') {\n-            return None\n+            return None;\n         }\n         if ch.next() != Some('/') {\n-            return None\n+            return None;\n         }\n         Some(format!(\"/{}/{}\", drive, &s[drive.len_utf8() + 2..]))\n     }\n@@ -1154,8 +1189,7 @@ impl Step for Cargo {\n             builder.install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n         }\n         builder.install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n-        builder.copy(&etc.join(\"cargo.bashcomp.sh\"),\n-             &image.join(\"etc/bash_completion.d/cargo\"));\n+        builder.copy(&etc.join(\"cargo.bashcomp.sh\"), &image.join(\"etc/bash_completion.d/cargo\"));\n         let doc = image.join(\"share/doc/cargo\");\n         builder.install(&src.join(\"README.md\"), &doc, 0o644);\n         builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n@@ -1175,16 +1209,20 @@ impl Step for Cargo {\n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(\"--non-installed-overlay\").arg(&overlay)\n-           .arg(format!(\"--package-name={}-{}\", name, target))\n-           .arg(\"--component-name=cargo\")\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=Rust-is-ready-to-roll.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\")\n+            .arg(&overlay)\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(\"--component-name=cargo\")\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n \n         builder.info(&format!(\"Dist cargo stage{} ({})\", compiler.stage, target));\n         let _time = timeit(builder);\n@@ -1236,11 +1274,12 @@ impl Step for Rls {\n         // Prepare the image directory\n         // We expect RLS to build, because we've exited this step above if tool\n         // state for RLS isn't testing.\n-        let rls = builder.ensure(tool::Rls {\n-            compiler,\n-            target,\n-            extra_features: Vec::new(),\n-        }).or_else(|| { missing_tool(\"RLS\", builder.build.config.missing_tools); None })?;\n+        let rls = builder\n+            .ensure(tool::Rls { compiler, target, extra_features: Vec::new() })\n+            .or_else(|| {\n+                missing_tool(\"RLS\", builder.build.config.missing_tools);\n+                None\n+            })?;\n \n         builder.install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n@@ -1260,16 +1299,20 @@ impl Step for Rls {\n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=RLS-ready-to-serve.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(\"--non-installed-overlay\").arg(&overlay)\n-           .arg(format!(\"--package-name={}-{}\", name, target))\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-           .arg(\"--component-name=rls-preview\");\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=RLS-ready-to-serve.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\")\n+            .arg(&overlay)\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(\"--component-name=rls-preview\");\n \n         builder.info(&format!(\"Dist RLS stage{} ({})\", compiler.stage, target));\n         let _time = timeit(builder);\n@@ -1321,15 +1364,18 @@ impl Step for Clippy {\n         // Prepare the image directory\n         // We expect clippy to build, because we've exited this step above if tool\n         // state for clippy isn't testing.\n-        let clippy = builder.ensure(tool::Clippy {\n-            compiler,\n-            target,\n-            extra_features: Vec::new(),\n-        }).or_else(|| { missing_tool(\"clippy\", builder.build.config.missing_tools); None })?;\n-        let cargoclippy = builder.ensure(tool::CargoClippy {\n-            compiler,\n-            target, extra_features: Vec::new()\n-        }).or_else(|| { missing_tool(\"cargo clippy\", builder.build.config.missing_tools); None })?;\n+        let clippy = builder\n+            .ensure(tool::Clippy { compiler, target, extra_features: Vec::new() })\n+            .or_else(|| {\n+                missing_tool(\"clippy\", builder.build.config.missing_tools);\n+                None\n+            })?;\n+        let cargoclippy = builder\n+            .ensure(tool::CargoClippy { compiler, target, extra_features: Vec::new() })\n+            .or_else(|| {\n+                missing_tool(\"cargo clippy\", builder.build.config.missing_tools);\n+                None\n+            })?;\n \n         builder.install(&clippy, &image.join(\"bin\"), 0o755);\n         builder.install(&cargoclippy, &image.join(\"bin\"), 0o755);\n@@ -1350,16 +1396,20 @@ impl Step for Clippy {\n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=clippy-ready-to-serve.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(\"--non-installed-overlay\").arg(&overlay)\n-           .arg(format!(\"--package-name={}-{}\", name, target))\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-           .arg(\"--component-name=clippy-preview\");\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=clippy-ready-to-serve.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\")\n+            .arg(&overlay)\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(\"--component-name=clippy-preview\");\n \n         builder.info(&format!(\"Dist clippy stage{} ({})\", compiler.stage, target));\n         let _time = timeit(builder);\n@@ -1411,16 +1461,18 @@ impl Step for Miri {\n         // Prepare the image directory\n         // We expect miri to build, because we've exited this step above if tool\n         // state for miri isn't testing.\n-        let miri = builder.ensure(tool::Miri {\n-            compiler,\n-            target,\n-            extra_features: Vec::new(),\n-        }).or_else(|| { missing_tool(\"miri\", builder.build.config.missing_tools); None })?;\n-        let cargomiri = builder.ensure(tool::CargoMiri {\n-            compiler,\n-            target,\n-            extra_features: Vec::new()\n-        }).or_else(|| { missing_tool(\"cargo miri\", builder.build.config.missing_tools); None })?;\n+        let miri = builder\n+            .ensure(tool::Miri { compiler, target, extra_features: Vec::new() })\n+            .or_else(|| {\n+                missing_tool(\"miri\", builder.build.config.missing_tools);\n+                None\n+            })?;\n+        let cargomiri = builder\n+            .ensure(tool::CargoMiri { compiler, target, extra_features: Vec::new() })\n+            .or_else(|| {\n+                missing_tool(\"cargo miri\", builder.build.config.missing_tools);\n+                None\n+            })?;\n \n         builder.install(&miri, &image.join(\"bin\"), 0o755);\n         builder.install(&cargomiri, &image.join(\"bin\"), 0o755);\n@@ -1441,16 +1493,20 @@ impl Step for Miri {\n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=miri-ready-to-serve.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(\"--non-installed-overlay\").arg(&overlay)\n-           .arg(format!(\"--package-name={}-{}\", name, target))\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-           .arg(\"--component-name=miri-preview\");\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=miri-ready-to-serve.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\")\n+            .arg(&overlay)\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(\"--component-name=miri-preview\");\n \n         builder.info(&format!(\"Dist miri stage{} ({})\", compiler.stage, target));\n         let _time = timeit(builder);\n@@ -1499,16 +1555,18 @@ impl Step for Rustfmt {\n         builder.create_dir(&image);\n \n         // Prepare the image directory\n-        let rustfmt = builder.ensure(tool::Rustfmt {\n-            compiler,\n-            target,\n-            extra_features: Vec::new(),\n-        }).or_else(|| { missing_tool(\"Rustfmt\", builder.build.config.missing_tools); None })?;\n-        let cargofmt = builder.ensure(tool::Cargofmt {\n-            compiler,\n-            target,\n-            extra_features: Vec::new(),\n-        }).or_else(|| { missing_tool(\"Cargofmt\", builder.build.config.missing_tools); None })?;\n+        let rustfmt = builder\n+            .ensure(tool::Rustfmt { compiler, target, extra_features: Vec::new() })\n+            .or_else(|| {\n+                missing_tool(\"Rustfmt\", builder.build.config.missing_tools);\n+                None\n+            })?;\n+        let cargofmt = builder\n+            .ensure(tool::Cargofmt { compiler, target, extra_features: Vec::new() })\n+            .or_else(|| {\n+                missing_tool(\"Cargofmt\", builder.build.config.missing_tools);\n+                None\n+            })?;\n \n         builder.install(&rustfmt, &image.join(\"bin\"), 0o755);\n         builder.install(&cargofmt, &image.join(\"bin\"), 0o755);\n@@ -1529,16 +1587,20 @@ impl Step for Rustfmt {\n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n-           .arg(\"--product-name=Rust\")\n-           .arg(\"--rel-manifest-dir=rustlib\")\n-           .arg(\"--success-message=rustfmt-ready-to-fmt.\")\n-           .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(builder))\n-           .arg(\"--output-dir\").arg(&distdir(builder))\n-           .arg(\"--non-installed-overlay\").arg(&overlay)\n-           .arg(format!(\"--package-name={}-{}\", name, target))\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-           .arg(\"--component-name=rustfmt-preview\");\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=rustfmt-ready-to-fmt.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\")\n+            .arg(&overlay)\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(\"--component-name=rustfmt-preview\");\n \n         builder.info(&format!(\"Dist Rustfmt stage{} ({})\", compiler.stage, target));\n         let _time = timeit(builder);\n@@ -1580,9 +1642,7 @@ impl Step for Extended {\n \n         builder.info(&format!(\"Dist extended stage{} ({})\", compiler.stage, target));\n \n-        let rustc_installer = builder.ensure(Rustc {\n-            compiler: builder.compiler(stage, target),\n-        });\n+        let rustc_installer = builder.ensure(Rustc { compiler: builder.compiler(stage, target) });\n         let cargo_installer = builder.ensure(Cargo { compiler, target });\n         let rustfmt_installer = builder.ensure(Rustfmt { compiler, target });\n         let rls_installer = builder.ensure(Rls { compiler, target });\n@@ -1593,11 +1653,9 @@ impl Step for Extended {\n         let mingw_installer = builder.ensure(Mingw { host: target });\n         let analysis_installer = builder.ensure(Analysis { compiler, target });\n \n-        let docs_installer = builder.ensure(Docs { host: target, });\n-        let std_installer = builder.ensure(Std {\n-            compiler: builder.compiler(stage, target),\n-            target,\n-        });\n+        let docs_installer = builder.ensure(Docs { host: target });\n+        let std_installer =\n+            builder.ensure(Std { compiler: builder.compiler(stage, target), target });\n \n         let tmp = tmpdir(builder);\n         let overlay = tmp.join(\"extended-overlay\");\n@@ -1648,12 +1706,16 @@ impl Step for Extended {\n             .arg(\"--product-name=Rust\")\n             .arg(\"--rel-manifest-dir=rustlib\")\n             .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-            .arg(\"--work-dir\").arg(&work)\n-            .arg(\"--output-dir\").arg(&distdir(builder))\n+            .arg(\"--work-dir\")\n+            .arg(&work)\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n             .arg(format!(\"--package-name={}-{}\", pkgname(builder, \"rust\"), target))\n             .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--input-tarballs\").arg(input_tarballs)\n-            .arg(\"--non-installed-overlay\").arg(&overlay);\n+            .arg(\"--input-tarballs\")\n+            .arg(input_tarballs)\n+            .arg(\"--non-installed-overlay\")\n+            .arg(&overlay);\n         let time = timeit(&builder);\n         builder.run(&mut cmd);\n         drop(time);\n@@ -1718,17 +1780,21 @@ impl Step for Extended {\n \n             let pkgbuild = |component: &str| {\n                 let mut cmd = Command::new(\"pkgbuild\");\n-                cmd.arg(\"--identifier\").arg(format!(\"org.rust-lang.{}\", component))\n-                    .arg(\"--scripts\").arg(pkg.join(component))\n+                cmd.arg(\"--identifier\")\n+                    .arg(format!(\"org.rust-lang.{}\", component))\n+                    .arg(\"--scripts\")\n+                    .arg(pkg.join(component))\n                     .arg(\"--nopayload\")\n                     .arg(pkg.join(component).with_extension(\"pkg\"));\n                 builder.run(&mut cmd);\n             };\n \n             let prepare = |name: &str| {\n                 builder.create_dir(&pkg.join(name));\n-                builder.cp_r(&work.join(&format!(\"{}-{}\", pkgname(builder, name), target)),\n-                        &pkg.join(name));\n+                builder.cp_r(\n+                    &work.join(&format!(\"{}-{}\", pkgname(builder, name), target)),\n+                    &pkg.join(name),\n+                );\n                 builder.install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n                 pkgbuild(name);\n             };\n@@ -1756,12 +1822,13 @@ impl Step for Extended {\n             builder.create(&pkg.join(\"res/LICENSE.txt\"), &license);\n             builder.install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n             let mut cmd = Command::new(\"productbuild\");\n-            cmd.arg(\"--distribution\").arg(xform(&etc.join(\"pkg/Distribution.xml\")))\n-                .arg(\"--resources\").arg(pkg.join(\"res\"))\n-                .arg(distdir(builder).join(format!(\"{}-{}.pkg\",\n-                                                    pkgname(builder, \"rust\"),\n-                                                    target)))\n-                .arg(\"--package-path\").arg(&pkg);\n+            cmd.arg(\"--distribution\")\n+                .arg(xform(&etc.join(\"pkg/Distribution.xml\")))\n+                .arg(\"--resources\")\n+                .arg(pkg.join(\"res\"))\n+                .arg(distdir(builder).join(format!(\"{}-{}.pkg\", pkgname(builder, \"rust\"), target)))\n+                .arg(\"--package-path\")\n+                .arg(&pkg);\n             let _time = timeit(builder);\n             builder.run(&mut cmd);\n         }\n@@ -1783,9 +1850,10 @@ impl Step for Extended {\n                 } else {\n                     name.to_string()\n                 };\n-                builder.cp_r(&work.join(&format!(\"{}-{}\", pkgname(builder, name), target))\n-                            .join(dir),\n-                        &exe.join(name));\n+                builder.cp_r(\n+                    &work.join(&format!(\"{}-{}\", pkgname(builder, name), target)).join(dir),\n+                    &exe.join(name),\n+                );\n                 builder.remove(&exe.join(name).join(\"manifest.in\"));\n             };\n             prepare(\"rustc\");\n@@ -1815,19 +1883,19 @@ impl Step for Extended {\n             // Generate exe installer\n             builder.info(\"building `exe` installer with `iscc`\");\n             let mut cmd = Command::new(\"iscc\");\n-            cmd.arg(\"rust.iss\")\n-                .arg(\"/Q\")\n-                .current_dir(&exe);\n+            cmd.arg(\"rust.iss\").arg(\"/Q\").current_dir(&exe);\n             if target.contains(\"windows-gnu\") {\n                 cmd.arg(\"/dMINGW\");\n             }\n             add_env(builder, &mut cmd, target);\n             let time = timeit(builder);\n             builder.run(&mut cmd);\n             drop(time);\n-            builder.install(&exe.join(format!(\"{}-{}.exe\", pkgname(builder, \"rust\"), target)),\n-                    &distdir(builder),\n-                    0o755);\n+            builder.install(\n+                &exe.join(format!(\"{}-{}.exe\", pkgname(builder, \"rust\"), target)),\n+                &distdir(builder),\n+                0o755,\n+            );\n \n             // Generate msi installer\n             let wix = PathBuf::from(env::var_os(\"WIX\").unwrap());\n@@ -1836,106 +1904,165 @@ impl Step for Extended {\n             let light = wix.join(\"bin/light.exe\");\n \n             let heat_flags = [\"-nologo\", \"-gg\", \"-sfrag\", \"-srd\", \"-sreg\"];\n-            builder.run(Command::new(&heat)\n-                            .current_dir(&exe)\n-                            .arg(\"dir\")\n-                            .arg(\"rustc\")\n-                            .args(&heat_flags)\n-                            .arg(\"-cg\").arg(\"RustcGroup\")\n-                            .arg(\"-dr\").arg(\"Rustc\")\n-                            .arg(\"-var\").arg(\"var.RustcDir\")\n-                            .arg(\"-out\").arg(exe.join(\"RustcGroup.wxs\")));\n-            builder.run(Command::new(&heat)\n-                            .current_dir(&exe)\n-                            .arg(\"dir\")\n-                            .arg(\"rust-docs\")\n-                            .args(&heat_flags)\n-                            .arg(\"-cg\").arg(\"DocsGroup\")\n-                            .arg(\"-dr\").arg(\"Docs\")\n-                            .arg(\"-var\").arg(\"var.DocsDir\")\n-                            .arg(\"-out\").arg(exe.join(\"DocsGroup.wxs\"))\n-                            .arg(\"-t\").arg(etc.join(\"msi/squash-components.xsl\")));\n-            builder.run(Command::new(&heat)\n-                            .current_dir(&exe)\n-                            .arg(\"dir\")\n-                            .arg(\"cargo\")\n-                            .args(&heat_flags)\n-                            .arg(\"-cg\").arg(\"CargoGroup\")\n-                            .arg(\"-dr\").arg(\"Cargo\")\n-                            .arg(\"-var\").arg(\"var.CargoDir\")\n-                            .arg(\"-out\").arg(exe.join(\"CargoGroup.wxs\"))\n-                            .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n-            builder.run(Command::new(&heat)\n-                            .current_dir(&exe)\n-                            .arg(\"dir\")\n-                            .arg(\"rust-std\")\n-                            .args(&heat_flags)\n-                            .arg(\"-cg\").arg(\"StdGroup\")\n-                            .arg(\"-dr\").arg(\"Std\")\n-                            .arg(\"-var\").arg(\"var.StdDir\")\n-                            .arg(\"-out\").arg(exe.join(\"StdGroup.wxs\")));\n+            builder.run(\n+                Command::new(&heat)\n+                    .current_dir(&exe)\n+                    .arg(\"dir\")\n+                    .arg(\"rustc\")\n+                    .args(&heat_flags)\n+                    .arg(\"-cg\")\n+                    .arg(\"RustcGroup\")\n+                    .arg(\"-dr\")\n+                    .arg(\"Rustc\")\n+                    .arg(\"-var\")\n+                    .arg(\"var.RustcDir\")\n+                    .arg(\"-out\")\n+                    .arg(exe.join(\"RustcGroup.wxs\")),\n+            );\n+            builder.run(\n+                Command::new(&heat)\n+                    .current_dir(&exe)\n+                    .arg(\"dir\")\n+                    .arg(\"rust-docs\")\n+                    .args(&heat_flags)\n+                    .arg(\"-cg\")\n+                    .arg(\"DocsGroup\")\n+                    .arg(\"-dr\")\n+                    .arg(\"Docs\")\n+                    .arg(\"-var\")\n+                    .arg(\"var.DocsDir\")\n+                    .arg(\"-out\")\n+                    .arg(exe.join(\"DocsGroup.wxs\"))\n+                    .arg(\"-t\")\n+                    .arg(etc.join(\"msi/squash-components.xsl\")),\n+            );\n+            builder.run(\n+                Command::new(&heat)\n+                    .current_dir(&exe)\n+                    .arg(\"dir\")\n+                    .arg(\"cargo\")\n+                    .args(&heat_flags)\n+                    .arg(\"-cg\")\n+                    .arg(\"CargoGroup\")\n+                    .arg(\"-dr\")\n+                    .arg(\"Cargo\")\n+                    .arg(\"-var\")\n+                    .arg(\"var.CargoDir\")\n+                    .arg(\"-out\")\n+                    .arg(exe.join(\"CargoGroup.wxs\"))\n+                    .arg(\"-t\")\n+                    .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n+            );\n+            builder.run(\n+                Command::new(&heat)\n+                    .current_dir(&exe)\n+                    .arg(\"dir\")\n+                    .arg(\"rust-std\")\n+                    .args(&heat_flags)\n+                    .arg(\"-cg\")\n+                    .arg(\"StdGroup\")\n+                    .arg(\"-dr\")\n+                    .arg(\"Std\")\n+                    .arg(\"-var\")\n+                    .arg(\"var.StdDir\")\n+                    .arg(\"-out\")\n+                    .arg(exe.join(\"StdGroup.wxs\")),\n+            );\n             if rls_installer.is_some() {\n-                builder.run(Command::new(&heat)\n-                                .current_dir(&exe)\n-                                .arg(\"dir\")\n-                                .arg(\"rls\")\n-                                .args(&heat_flags)\n-                                .arg(\"-cg\").arg(\"RlsGroup\")\n-                                .arg(\"-dr\").arg(\"Rls\")\n-                                .arg(\"-var\").arg(\"var.RlsDir\")\n-                                .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n-                                .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+                builder.run(\n+                    Command::new(&heat)\n+                        .current_dir(&exe)\n+                        .arg(\"dir\")\n+                        .arg(\"rls\")\n+                        .args(&heat_flags)\n+                        .arg(\"-cg\")\n+                        .arg(\"RlsGroup\")\n+                        .arg(\"-dr\")\n+                        .arg(\"Rls\")\n+                        .arg(\"-var\")\n+                        .arg(\"var.RlsDir\")\n+                        .arg(\"-out\")\n+                        .arg(exe.join(\"RlsGroup.wxs\"))\n+                        .arg(\"-t\")\n+                        .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n+                );\n             }\n             if clippy_installer.is_some() {\n-                builder.run(Command::new(&heat)\n-                                .current_dir(&exe)\n-                                .arg(\"dir\")\n-                                .arg(\"clippy\")\n-                                .args(&heat_flags)\n-                                .arg(\"-cg\").arg(\"ClippyGroup\")\n-                                .arg(\"-dr\").arg(\"Clippy\")\n-                                .arg(\"-var\").arg(\"var.ClippyDir\")\n-                                .arg(\"-out\").arg(exe.join(\"ClippyGroup.wxs\"))\n-                                .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+                builder.run(\n+                    Command::new(&heat)\n+                        .current_dir(&exe)\n+                        .arg(\"dir\")\n+                        .arg(\"clippy\")\n+                        .args(&heat_flags)\n+                        .arg(\"-cg\")\n+                        .arg(\"ClippyGroup\")\n+                        .arg(\"-dr\")\n+                        .arg(\"Clippy\")\n+                        .arg(\"-var\")\n+                        .arg(\"var.ClippyDir\")\n+                        .arg(\"-out\")\n+                        .arg(exe.join(\"ClippyGroup.wxs\"))\n+                        .arg(\"-t\")\n+                        .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n+                );\n             }\n             if miri_installer.is_some() {\n-                builder.run(Command::new(&heat)\n-                                .current_dir(&exe)\n-                                .arg(\"dir\")\n-                                .arg(\"miri\")\n-                                .args(&heat_flags)\n-                                .arg(\"-cg\").arg(\"MiriGroup\")\n-                                .arg(\"-dr\").arg(\"Miri\")\n-                                .arg(\"-var\").arg(\"var.MiriDir\")\n-                                .arg(\"-out\").arg(exe.join(\"MiriGroup.wxs\"))\n-                                .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+                builder.run(\n+                    Command::new(&heat)\n+                        .current_dir(&exe)\n+                        .arg(\"dir\")\n+                        .arg(\"miri\")\n+                        .args(&heat_flags)\n+                        .arg(\"-cg\")\n+                        .arg(\"MiriGroup\")\n+                        .arg(\"-dr\")\n+                        .arg(\"Miri\")\n+                        .arg(\"-var\")\n+                        .arg(\"var.MiriDir\")\n+                        .arg(\"-out\")\n+                        .arg(exe.join(\"MiriGroup.wxs\"))\n+                        .arg(\"-t\")\n+                        .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n+                );\n             }\n-            builder.run(Command::new(&heat)\n-                            .current_dir(&exe)\n-                            .arg(\"dir\")\n-                            .arg(\"rust-analysis\")\n-                            .args(&heat_flags)\n-                            .arg(\"-cg\").arg(\"AnalysisGroup\")\n-                            .arg(\"-dr\").arg(\"Analysis\")\n-                            .arg(\"-var\").arg(\"var.AnalysisDir\")\n-                            .arg(\"-out\").arg(exe.join(\"AnalysisGroup.wxs\"))\n-                            .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            builder.run(\n+                Command::new(&heat)\n+                    .current_dir(&exe)\n+                    .arg(\"dir\")\n+                    .arg(\"rust-analysis\")\n+                    .args(&heat_flags)\n+                    .arg(\"-cg\")\n+                    .arg(\"AnalysisGroup\")\n+                    .arg(\"-dr\")\n+                    .arg(\"Analysis\")\n+                    .arg(\"-var\")\n+                    .arg(\"var.AnalysisDir\")\n+                    .arg(\"-out\")\n+                    .arg(exe.join(\"AnalysisGroup.wxs\"))\n+                    .arg(\"-t\")\n+                    .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n+            );\n             if target.contains(\"windows-gnu\") {\n-                builder.run(Command::new(&heat)\n-                                .current_dir(&exe)\n-                                .arg(\"dir\")\n-                                .arg(\"rust-mingw\")\n-                                .args(&heat_flags)\n-                                .arg(\"-cg\").arg(\"GccGroup\")\n-                                .arg(\"-dr\").arg(\"Gcc\")\n-                                .arg(\"-var\").arg(\"var.GccDir\")\n-                                .arg(\"-out\").arg(exe.join(\"GccGroup.wxs\")));\n+                builder.run(\n+                    Command::new(&heat)\n+                        .current_dir(&exe)\n+                        .arg(\"dir\")\n+                        .arg(\"rust-mingw\")\n+                        .args(&heat_flags)\n+                        .arg(\"-cg\")\n+                        .arg(\"GccGroup\")\n+                        .arg(\"-dr\")\n+                        .arg(\"Gcc\")\n+                        .arg(\"-var\")\n+                        .arg(\"var.GccDir\")\n+                        .arg(\"-out\")\n+                        .arg(exe.join(\"GccGroup.wxs\")),\n+                );\n             }\n \n             let candle = |input: &Path| {\n-                let output = exe.join(input.file_stem().unwrap())\n-                                .with_extension(\"wixobj\");\n-                let arch = if target.contains(\"x86_64\") {\"x64\"} else {\"x86\"};\n+                let output = exe.join(input.file_stem().unwrap()).with_extension(\"wixobj\");\n+                let arch = if target.contains(\"x86_64\") { \"x64\" } else { \"x86\" };\n                 let mut cmd = Command::new(&candle);\n                 cmd.current_dir(&exe)\n                     .arg(\"-nologo\")\n@@ -1944,8 +2071,10 @@ impl Step for Extended {\n                     .arg(\"-dCargoDir=cargo\")\n                     .arg(\"-dStdDir=rust-std\")\n                     .arg(\"-dAnalysisDir=rust-analysis\")\n-                    .arg(\"-arch\").arg(&arch)\n-                    .arg(\"-out\").arg(&output)\n+                    .arg(\"-arch\")\n+                    .arg(&arch)\n+                    .arg(\"-out\")\n+                    .arg(&output)\n                     .arg(&input);\n                 add_env(builder, &mut cmd, target);\n \n@@ -1993,9 +2122,12 @@ impl Step for Extended {\n             let filename = format!(\"{}-{}.msi\", pkgname(builder, \"rust\"), target);\n             let mut cmd = Command::new(&light);\n             cmd.arg(\"-nologo\")\n-                .arg(\"-ext\").arg(\"WixUIExtension\")\n-                .arg(\"-ext\").arg(\"WixUtilExtension\")\n-                .arg(\"-out\").arg(exe.join(&filename))\n+                .arg(\"-ext\")\n+                .arg(\"WixUIExtension\")\n+                .arg(\"-ext\")\n+                .arg(\"WixUtilExtension\")\n+                .arg(\"-out\")\n+                .arg(exe.join(&filename))\n                 .arg(\"rust.wixobj\")\n                 .arg(\"ui.wixobj\")\n                 .arg(\"rustwelcomedlg.wixobj\")\n@@ -2035,29 +2167,27 @@ impl Step for Extended {\n fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: Interned<String>) {\n     let mut parts = channel::CFG_RELEASE_NUM.split('.');\n     cmd.env(\"CFG_RELEASE_INFO\", builder.rust_version())\n-       .env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM)\n-       .env(\"CFG_RELEASE\", builder.rust_release())\n-       .env(\"CFG_VER_MAJOR\", parts.next().unwrap())\n-       .env(\"CFG_VER_MINOR\", parts.next().unwrap())\n-       .env(\"CFG_VER_PATCH\", parts.next().unwrap())\n-       .env(\"CFG_VER_BUILD\", \"0\") // just needed to build\n-       .env(\"CFG_PACKAGE_VERS\", builder.rust_package_vers())\n-       .env(\"CFG_PACKAGE_NAME\", pkgname(builder, \"rust\"))\n-       .env(\"CFG_BUILD\", target)\n-       .env(\"CFG_CHANNEL\", &builder.config.channel);\n+        .env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM)\n+        .env(\"CFG_RELEASE\", builder.rust_release())\n+        .env(\"CFG_VER_MAJOR\", parts.next().unwrap())\n+        .env(\"CFG_VER_MINOR\", parts.next().unwrap())\n+        .env(\"CFG_VER_PATCH\", parts.next().unwrap())\n+        .env(\"CFG_VER_BUILD\", \"0\") // just needed to build\n+        .env(\"CFG_PACKAGE_VERS\", builder.rust_package_vers())\n+        .env(\"CFG_PACKAGE_NAME\", pkgname(builder, \"rust\"))\n+        .env(\"CFG_BUILD\", target)\n+        .env(\"CFG_CHANNEL\", &builder.config.channel);\n \n     if target.contains(\"windows-gnu\") {\n-       cmd.env(\"CFG_MINGW\", \"1\")\n-          .env(\"CFG_ABI\", \"GNU\");\n+        cmd.env(\"CFG_MINGW\", \"1\").env(\"CFG_ABI\", \"GNU\");\n     } else {\n-       cmd.env(\"CFG_MINGW\", \"0\")\n-          .env(\"CFG_ABI\", \"MSVC\");\n+        cmd.env(\"CFG_MINGW\", \"0\").env(\"CFG_ABI\", \"MSVC\");\n     }\n \n     if target.contains(\"x86_64\") {\n-       cmd.env(\"CFG_PLATFORM\", \"x64\");\n+        cmd.env(\"CFG_PLATFORM\", \"x64\");\n     } else {\n-       cmd.env(\"CFG_PLATFORM\", \"x86\");\n+        cmd.env(\"CFG_PLATFORM\", \"x86\");\n     }\n }\n \n@@ -2130,17 +2260,11 @@ impl Step for HashSign {\n //\n // Note: This function does no yet support Windows but we also don't support\n //       linking LLVM tools dynamically on Windows yet.\n-pub fn maybe_install_llvm_dylib(builder: &Builder<'_>,\n-                                target: Interned<String>,\n-                                sysroot: &Path) {\n-    let src_libdir = builder\n-        .llvm_out(target)\n-        .join(\"lib\");\n+pub fn maybe_install_llvm_dylib(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+    let src_libdir = builder.llvm_out(target).join(\"lib\");\n     let dst_libdir1 = sysroot.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n-    let dst_libdir2 = sysroot.join(builder.sysroot_libdir_relative(Compiler {\n-        stage: 1,\n-        host: target,\n-    }));\n+    let dst_libdir2 =\n+        sysroot.join(builder.sysroot_libdir_relative(Compiler { stage: 1, host: target }));\n     t!(fs::create_dir_all(&dst_libdir1));\n     t!(fs::create_dir_all(&dst_libdir2));\n \n@@ -2150,7 +2274,7 @@ pub fn maybe_install_llvm_dylib(builder: &Builder<'_>,\n             builder.install(&llvm_dylib_path, &dst_libdir1, 0o644);\n             builder.install(&llvm_dylib_path, &dst_libdir2, 0o644);\n         }\n-        return\n+        return;\n     }\n \n     // Usually libLLVM.so is a symlink to something like libLLVM-6.0.so.\n@@ -2159,11 +2283,9 @@ pub fn maybe_install_llvm_dylib(builder: &Builder<'_>,\n     let llvm_dylib_path = src_libdir.join(\"libLLVM.so\");\n     if llvm_dylib_path.exists() {\n         let llvm_dylib_path = llvm_dylib_path.canonicalize().unwrap_or_else(|e| {\n-            panic!(\"dist: Error calling canonicalize path `{}`: {}\",\n-                   llvm_dylib_path.display(), e);\n+            panic!(\"dist: Error calling canonicalize path `{}`: {}\", llvm_dylib_path.display(), e);\n         });\n \n-\n         builder.install(&llvm_dylib_path, &dst_libdir1, 0o644);\n         builder.install(&llvm_dylib_path, &dst_libdir2, 0o644);\n     }\n@@ -2183,9 +2305,7 @@ impl Step for LlvmTools {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(LlvmTools {\n-            target: run.target,\n-        });\n+        run.builder.ensure(LlvmTools { target: run.target });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n@@ -2195,8 +2315,7 @@ impl Step for LlvmTools {\n         /* run only if llvm-config isn't used */\n         if let Some(config) = builder.config.target_config.get(&target) {\n             if let Some(ref _s) = config.llvm_config {\n-                builder.info(&format!(\"Skipping LlvmTools ({}): external LLVM\",\n-                    target));\n+                builder.info(&format!(\"Skipping LlvmTools ({}): external LLVM\", target));\n                 return None;\n             }\n         }\n@@ -2211,12 +2330,8 @@ impl Step for LlvmTools {\n         drop(fs::remove_dir_all(&image));\n \n         // Prepare the image directory\n-        let src_bindir = builder\n-            .llvm_out(target)\n-            .join(\"bin\");\n-        let dst_bindir = image.join(\"lib/rustlib\")\n-            .join(&*target)\n-            .join(\"bin\");\n+        let src_bindir = builder.llvm_out(target).join(\"bin\");\n+        let dst_bindir = image.join(\"lib/rustlib\").join(&*target).join(\"bin\");\n         t!(fs::create_dir_all(&dst_bindir));\n         for tool in LLVM_TOOLS {\n             let exe = src_bindir.join(exe(tool, &target));\n@@ -2237,15 +2352,18 @@ impl Step for LlvmTools {\n             .arg(\"--product-name=Rust\")\n             .arg(\"--rel-manifest-dir=rustlib\")\n             .arg(\"--success-message=llvm-tools-installed.\")\n-            .arg(\"--image-dir\").arg(&image)\n-            .arg(\"--work-dir\").arg(&tmpdir(builder))\n-            .arg(\"--output-dir\").arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\").arg(&overlay)\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\")\n+            .arg(&overlay)\n             .arg(format!(\"--package-name={}-{}\", name, target))\n             .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n             .arg(\"--component-name=llvm-tools-preview\");\n \n-\n         builder.run(&mut cmd);\n         Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n@@ -2266,9 +2384,7 @@ impl Step for Lldb {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Lldb {\n-            target: run.target,\n-        });\n+        run.builder.ensure(Lldb { target: run.target });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n@@ -2278,9 +2394,7 @@ impl Step for Lldb {\n             return None;\n         }\n \n-        let bindir = builder\n-            .llvm_out(target)\n-            .join(\"bin\");\n+        let bindir = builder.llvm_out(target).join(\"bin\");\n         let lldb_exe = bindir.join(exe(\"lldb\", &target));\n         if !lldb_exe.exists() {\n             return None;\n@@ -2314,7 +2428,7 @@ impl Step for Lldb {\n                     if t!(entry.file_type()).is_symlink() {\n                         builder.copy_to_folder(&entry.path(), &dst);\n                     } else {\n-                       builder.install(&entry.path(), &dst, 0o755);\n+                        builder.install(&entry.path(), &dst, 0o755);\n                     }\n                 }\n             }\n@@ -2333,8 +2447,7 @@ impl Step for Lldb {\n             let entry = t!(entry);\n             if let Ok(name) = entry.file_name().into_string() {\n                 if name.starts_with(\"python\") {\n-                    let dst = root.join(libdir_name)\n-                        .join(entry.file_name());\n+                    let dst = root.join(libdir_name).join(entry.file_name());\n                     t!(fs::create_dir_all(&dst));\n                     builder.cp_r(&entry.path(), &dst);\n                     break;\n@@ -2355,15 +2468,18 @@ impl Step for Lldb {\n             .arg(\"--product-name=Rust\")\n             .arg(\"--rel-manifest-dir=rustlib\")\n             .arg(\"--success-message=lldb-installed.\")\n-            .arg(\"--image-dir\").arg(&image)\n-            .arg(\"--work-dir\").arg(&tmpdir(builder))\n-            .arg(\"--output-dir\").arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\").arg(&overlay)\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\")\n+            .arg(&overlay)\n             .arg(format!(\"--package-name={}-{}\", name, target))\n             .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n             .arg(\"--component-name=lldb-preview\");\n \n-\n         builder.run(&mut cmd);\n         Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }"}, {"sha": "8cd7fc2c172571b13035d725a7c54383b1523061", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 70, "deletions": 93, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -10,17 +10,17 @@\n use std::collections::HashSet;\n use std::fs;\n use std::io;\n-use std::path::{PathBuf, Path};\n+use std::path::{Path, PathBuf};\n \n use crate::Mode;\n use build_helper::{t, up_to_date};\n \n-use crate::util::symlink_dir;\n use crate::builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n-use crate::tool::{self, prepare_tool_cargo, Tool, SourceType};\n+use crate::cache::{Interned, INTERNER};\n use crate::compile;\n-use crate::cache::{INTERNER, Interned};\n use crate::config::Config;\n+use crate::tool::{self, prepare_tool_cargo, SourceType, Tool};\n+use crate::util::symlink_dir;\n \n macro_rules! book {\n     ($($name:ident, $path:expr, $book_name:expr;)+) => {\n@@ -88,15 +88,11 @@ impl Step for UnstableBook {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(UnstableBook {\n-            target: run.target,\n-        });\n+        run.builder.ensure(UnstableBook { target: run.target });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        builder.ensure(UnstableBookGen {\n-            target: self.target,\n-        });\n+        builder.ensure(UnstableBookGen { target: self.target });\n         builder.ensure(RustbookSrc {\n             target: self.target,\n             name: INTERNER.intern_str(\"unstable-book\"),\n@@ -121,10 +117,7 @@ impl Step for CargoBook {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(CargoBook {\n-            target: run.target,\n-            name: INTERNER.intern_str(\"cargo\"),\n-        });\n+        run.builder.ensure(CargoBook { target: run.target, name: INTERNER.intern_str(\"cargo\") });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n@@ -141,11 +134,7 @@ impl Step for CargoBook {\n \n         let _ = fs::remove_dir_all(&out);\n \n-        builder.run(builder.tool_cmd(Tool::Rustbook)\n-                       .arg(\"build\")\n-                       .arg(&src)\n-                       .arg(\"-d\")\n-                       .arg(out));\n+        builder.run(builder.tool_cmd(Tool::Rustbook).arg(\"build\").arg(&src).arg(\"-d\").arg(out));\n     }\n }\n \n@@ -180,16 +169,12 @@ impl Step for RustbookSrc {\n         let rustbook = builder.tool_exe(Tool::Rustbook);\n         let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n         if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n-            return\n+            return;\n         }\n         builder.info(&format!(\"Rustbook ({}) - {}\", target, name));\n         let _ = fs::remove_dir_all(&out);\n \n-        builder.run(rustbook_cmd\n-                       .arg(\"build\")\n-                       .arg(&src)\n-                       .arg(\"-d\")\n-                       .arg(out));\n+        builder.run(rustbook_cmd.arg(\"build\").arg(&src).arg(\"-d\").arg(out));\n     }\n }\n \n@@ -262,10 +247,7 @@ impl Step for TheBook {\n         });\n \n         // build the version info page and CSS\n-        builder.ensure(Standalone {\n-            compiler,\n-            target,\n-        });\n+        builder.ensure(Standalone { compiler, target });\n \n         // build the redirect pages\n         builder.info(&format!(\"Documenting book redirect pages ({})\", target));\n@@ -297,13 +279,20 @@ fn invoke_rustdoc(\n \n     let out = out.join(\"book\");\n \n-    cmd.arg(\"--html-after-content\").arg(&footer)\n-        .arg(\"--html-before-content\").arg(&version_info)\n-        .arg(\"--html-in-header\").arg(&header)\n+    cmd.arg(\"--html-after-content\")\n+        .arg(&footer)\n+        .arg(\"--html-before-content\")\n+        .arg(&version_info)\n+        .arg(\"--html-in-header\")\n+        .arg(&header)\n         .arg(\"--markdown-no-toc\")\n-        .arg(\"--markdown-playground-url\").arg(\"https://play.rust-lang.org/\")\n-        .arg(\"-o\").arg(&out).arg(&path)\n-        .arg(\"--markdown-css\").arg(\"../rust.css\");\n+        .arg(\"--markdown-playground-url\")\n+        .arg(\"https://play.rust-lang.org/\")\n+        .arg(\"-o\")\n+        .arg(&out)\n+        .arg(&path)\n+        .arg(\"--markdown-css\")\n+        .arg(\"../rust.css\");\n \n     builder.run(&mut cmd);\n }\n@@ -366,33 +355,39 @@ impl Step for Standalone {\n             let path = file.path();\n             let filename = path.file_name().unwrap().to_str().unwrap();\n             if !filename.ends_with(\".md\") || filename == \"README.md\" {\n-                continue\n+                continue;\n             }\n \n             let html = out.join(filename).with_extension(\"html\");\n             let rustdoc = builder.rustdoc(compiler);\n-            if up_to_date(&path, &html) &&\n-               up_to_date(&footer, &html) &&\n-               up_to_date(&favicon, &html) &&\n-               up_to_date(&full_toc, &html) &&\n-               (builder.config.dry_run || up_to_date(&version_info, &html)) &&\n-               (builder.config.dry_run || up_to_date(&rustdoc, &html)) {\n-                continue\n+            if up_to_date(&path, &html)\n+                && up_to_date(&footer, &html)\n+                && up_to_date(&favicon, &html)\n+                && up_to_date(&full_toc, &html)\n+                && (builder.config.dry_run || up_to_date(&version_info, &html))\n+                && (builder.config.dry_run || up_to_date(&rustdoc, &html))\n+            {\n+                continue;\n             }\n \n             let mut cmd = builder.rustdoc_cmd(compiler);\n-            cmd.arg(\"--html-after-content\").arg(&footer)\n-               .arg(\"--html-before-content\").arg(&version_info)\n-               .arg(\"--html-in-header\").arg(&favicon)\n-               .arg(\"--markdown-no-toc\")\n-               .arg(\"--index-page\").arg(&builder.src.join(\"src/doc/index.md\"))\n-               .arg(\"--markdown-playground-url\").arg(\"https://play.rust-lang.org/\")\n-               .arg(\"-o\").arg(&out)\n-               .arg(&path);\n+            cmd.arg(\"--html-after-content\")\n+                .arg(&footer)\n+                .arg(\"--html-before-content\")\n+                .arg(&version_info)\n+                .arg(\"--html-in-header\")\n+                .arg(&favicon)\n+                .arg(\"--markdown-no-toc\")\n+                .arg(\"--index-page\")\n+                .arg(&builder.src.join(\"src/doc/index.md\"))\n+                .arg(\"--markdown-playground-url\")\n+                .arg(\"https://play.rust-lang.org/\")\n+                .arg(\"-o\")\n+                .arg(&out)\n+                .arg(&path);\n \n             if filename == \"not_found.md\" {\n-                cmd.arg(\"--markdown-css\")\n-                   .arg(\"https://doc.rust-lang.org/rust.css\");\n+                cmd.arg(\"--markdown-css\").arg(\"https://doc.rust-lang.org/rust.css\");\n             } else {\n                 cmd.arg(\"--markdown-css\").arg(\"rust.css\");\n             }\n@@ -417,10 +412,7 @@ impl Step for Std {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Std {\n-            stage: run.builder.top_stage,\n-            target: run.target\n-        });\n+        run.builder.ensure(Std { stage: run.builder.top_stage, target: run.target });\n     }\n \n     /// Compile all standard library documentation.\n@@ -436,8 +428,7 @@ impl Step for Std {\n         let compiler = builder.compiler(stage, builder.config.build);\n \n         builder.ensure(compile::Std { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Std)\n-                           .join(target).join(\"doc\");\n+        let out_dir = builder.stage_out(compiler, Mode::Std).join(target).join(\"doc\");\n \n         // Here what we're doing is creating a *symlink* (directory junction on\n         // Windows) to the final output location. This is not done as an\n@@ -462,18 +453,21 @@ impl Step for Std {\n \n             // Keep a whitelist so we do not build internal stdlib crates, these will be\n             // build by the rustc step later if enabled.\n-            cargo.arg(\"-Z\").arg(\"unstable-options\")\n-                 .arg(\"-p\").arg(package);\n+            cargo.arg(\"-Z\").arg(\"unstable-options\").arg(\"-p\").arg(package);\n             // Create all crate output directories first to make sure rustdoc uses\n             // relative links.\n             // FIXME: Cargo should probably do this itself.\n             t!(fs::create_dir_all(out_dir.join(package)));\n-            cargo.arg(\"--\")\n-                 .arg(\"--markdown-css\").arg(\"rust.css\")\n-                 .arg(\"--markdown-no-toc\")\n-                 .arg(\"--generate-redirect-pages\")\n-                 .arg(\"--resource-suffix\").arg(crate::channel::CFG_RELEASE_NUM)\n-                 .arg(\"--index-page\").arg(&builder.src.join(\"src/doc/index.md\"));\n+            cargo\n+                .arg(\"--\")\n+                .arg(\"--markdown-css\")\n+                .arg(\"rust.css\")\n+                .arg(\"--markdown-no-toc\")\n+                .arg(\"--generate-redirect-pages\")\n+                .arg(\"--resource-suffix\")\n+                .arg(crate::channel::CFG_RELEASE_NUM)\n+                .arg(\"--index-page\")\n+                .arg(&builder.src.join(\"src/doc/index.md\"));\n \n             builder.run(&mut cargo.into());\n         };\n@@ -501,10 +495,7 @@ impl Step for Rustc {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustc {\n-            stage: run.builder.top_stage,\n-            target: run.target,\n-        });\n+        run.builder.ensure(Rustc { stage: run.builder.top_stage, target: run.target });\n     }\n \n     /// Generates compiler documentation.\n@@ -568,7 +559,7 @@ impl Step for Rustc {\n fn find_compiler_crates(\n     builder: &Builder<'_>,\n     name: &Interned<String>,\n-    crates: &mut HashSet<Interned<String>>\n+    crates: &mut HashSet<Interned<String>>,\n ) {\n     // Add current crate.\n     crates.insert(*name);\n@@ -597,10 +588,7 @@ impl Step for Rustdoc {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustdoc {\n-            stage: run.builder.top_stage,\n-            target: run.target,\n-        });\n+        run.builder.ensure(Rustdoc { stage: run.builder.top_stage, target: run.target });\n     }\n \n     /// Generates compiler documentation.\n@@ -633,9 +621,7 @@ impl Step for Rustdoc {\n         builder.ensure(tool::Rustdoc { compiler: compiler });\n \n         // Symlink compiler docs to the output directory of rustdoc documentation.\n-        let out_dir = builder.stage_out(compiler, Mode::ToolRustc)\n-            .join(target)\n-            .join(\"doc\");\n+        let out_dir = builder.stage_out(compiler, Mode::ToolRustc).join(target).join(\"doc\");\n         t!(fs::create_dir_all(&out_dir));\n         t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n@@ -648,7 +634,7 @@ impl Step for Rustdoc {\n             \"doc\",\n             \"src/tools/rustdoc\",\n             SourceType::InTree,\n-            &[]\n+            &[],\n         );\n \n         // Only include compiler crates, no dependencies of those, such as `libc`.\n@@ -676,9 +662,7 @@ impl Step for ErrorIndex {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(ErrorIndex {\n-            target: run.target,\n-        });\n+        run.builder.ensure(ErrorIndex { target: run.target });\n     }\n \n     /// Generates the HTML rendered error-index by running the\n@@ -690,10 +674,7 @@ impl Step for ErrorIndex {\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(2, builder.config.build);\n-        let mut index = tool::ErrorIndex::command(\n-            builder,\n-            compiler,\n-        );\n+        let mut index = tool::ErrorIndex::command(builder, compiler);\n         index.arg(\"html\");\n         index.arg(out.join(\"error-index.html\"));\n         index.arg(crate::channel::CFG_RELEASE_NUM);\n@@ -721,9 +702,7 @@ impl Step for UnstableBookGen {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(UnstableBookGen {\n-            target: run.target,\n-        });\n+        run.builder.ensure(UnstableBookGen { target: run.target });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n@@ -751,9 +730,7 @@ fn symlink_dir_force(config: &Config, src: &Path, dst: &Path) -> io::Result<()>\n         } else {\n             // handle directory junctions on windows by falling back to\n             // `remove_dir`.\n-            fs::remove_file(dst).or_else(|_| {\n-                fs::remove_dir(dst)\n-            })?;\n+            fs::remove_file(dst).or_else(|_| fs::remove_dir(dst))?;\n         }\n     }\n "}, {"sha": "ffc24367db6e9cf214479ee779ddbd3fb097cb02", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 37, "deletions": 60, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -88,16 +88,15 @@ pub enum Subcommand {\n \n impl Default for Subcommand {\n     fn default() -> Subcommand {\n-        Subcommand::Build {\n-            paths: vec![PathBuf::from(\"nowhere\")],\n-        }\n+        Subcommand::Build { paths: vec![PathBuf::from(\"nowhere\")] }\n     }\n }\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n         let mut extra_help = String::new();\n-        let mut subcommand_help = String::from(\"\\\n+        let mut subcommand_help = String::from(\n+            \"\\\n Usage: x.py <subcommand> [options] [<paths>...]\n \n Subcommands:\n@@ -113,7 +112,7 @@ Subcommands:\n     dist        Build distribution artifacts\n     install     Install distribution artifacts\n \n-To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n+To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         );\n \n         let mut opts = Options::new();\n@@ -127,12 +126,20 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n         opts.optmulti(\"\", \"exclude\", \"build paths to exclude\", \"PATH\");\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n         opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n-        opts.optopt(\"\", \"stage\",\n+        opts.optopt(\n+            \"\",\n+            \"stage\",\n             \"stage to build (indicates compiler to use/test, e.g., stage 0 uses the \\\n              bootstrap compiler, stage 1 the stage 0 rustc artifacts, etc.)\",\n-            \"N\");\n-        opts.optmulti(\"\", \"keep-stage\", \"stage(s) to keep without recompiling \\\n-            (pass multiple times to keep e.g., both stages 0 and 1)\", \"N\");\n+            \"N\",\n+        );\n+        opts.optmulti(\n+            \"\",\n+            \"keep-stage\",\n+            \"stage(s) to keep without recompiling \\\n+            (pass multiple times to keep e.g., both stages 0 and 1)\",\n+            \"N\",\n+        );\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n@@ -197,11 +204,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n                 );\n                 opts.optflag(\"\", \"no-doc\", \"do not run doc tests\");\n                 opts.optflag(\"\", \"doc\", \"only run doc tests\");\n-                opts.optflag(\n-                    \"\",\n-                    \"bless\",\n-                    \"update all stderr/stdout files of failing ui tests\",\n-                );\n+                opts.optflag(\"\", \"bless\", \"update all stderr/stdout files of failing ui tests\");\n                 opts.optopt(\n                     \"\",\n                     \"compare-mode\",\n@@ -212,7 +215,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n                     \"\",\n                     \"pass\",\n                     \"force {check,build,run}-pass tests to this mode.\",\n-                    \"check | build | run\"\n+                    \"check | build | run\",\n                 );\n                 opts.optflag(\n                     \"\",\n@@ -386,10 +389,7 @@ Arguments:\n             _ => {}\n         };\n         // Get any optional paths which occur after the subcommand\n-        let paths = matches.free[1..]\n-            .iter()\n-            .map(|p| p.into())\n-            .collect::<Vec<PathBuf>>();\n+        let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n         let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n@@ -409,10 +409,8 @@ Arguments:\n             extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n         } else if !(subcommand.as_str() == \"clean\" || subcommand.as_str() == \"fmt\") {\n             extra_help.push_str(\n-                format!(\n-                    \"Run `./x.py {} -h -v` to see a list of available paths.\",\n-                    subcommand\n-                ).as_str(),\n+                format!(\"Run `./x.py {} -h -v` to see a list of available paths.\", subcommand)\n+                    .as_str(),\n             );\n         }\n \n@@ -443,26 +441,17 @@ Arguments:\n                     DocTests::Yes\n                 },\n             },\n-            \"bench\" => Subcommand::Bench {\n-                paths,\n-                test_args: matches.opt_strs(\"test-args\"),\n-            },\n+            \"bench\" => Subcommand::Bench { paths, test_args: matches.opt_strs(\"test-args\") },\n             \"doc\" => Subcommand::Doc { paths },\n             \"clean\" => {\n                 if !paths.is_empty() {\n                     println!(\"\\nclean does not take a path argument\\n\");\n                     usage(1, &opts, &subcommand_help, &extra_help);\n                 }\n \n-                Subcommand::Clean {\n-                    all: matches.opt_present(\"all\"),\n-                }\n-            }\n-            \"fmt\" => {\n-                Subcommand::Format {\n-                    check: matches.opt_present(\"check\"),\n-                }\n+                Subcommand::Clean { all: matches.opt_present(\"all\") }\n             }\n+            \"fmt\" => Subcommand::Format { check: matches.opt_present(\"check\") },\n             \"dist\" => Subcommand::Dist { paths },\n             \"install\" => Subcommand::Install { paths },\n             _ => {\n@@ -476,8 +465,10 @@ Arguments:\n             dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n             rustc_error_format: matches.opt_str(\"error-format\"),\n-            keep_stage: matches.opt_strs(\"keep-stage\")\n-                .into_iter().map(|j| j.parse().expect(\"`keep-stage` should be a number\"))\n+            keep_stage: matches\n+                .opt_strs(\"keep-stage\")\n+                .into_iter()\n+                .map(|j| j.parse().expect(\"`keep-stage` should be a number\"))\n                 .collect(),\n             host: split(&matches.opt_strs(\"host\"))\n                 .into_iter()\n@@ -504,21 +495,17 @@ impl Subcommand {\n     pub fn test_args(&self) -> Vec<&str> {\n         match *self {\n             Subcommand::Test { ref test_args, .. } | Subcommand::Bench { ref test_args, .. } => {\n-                test_args\n-                    .iter()\n-                    .flat_map(|s| s.split_whitespace())\n-                    .collect()\n+                test_args.iter().flat_map(|s| s.split_whitespace()).collect()\n             }\n             _ => Vec::new(),\n         }\n     }\n \n     pub fn rustc_args(&self) -> Vec<&str> {\n         match *self {\n-            Subcommand::Test { ref rustc_args, .. } => rustc_args\n-                .iter()\n-                .flat_map(|s| s.split_whitespace())\n-                .collect(),\n+            Subcommand::Test { ref rustc_args, .. } => {\n+                rustc_args.iter().flat_map(|s| s.split_whitespace()).collect()\n+            }\n             _ => Vec::new(),\n         }\n     }\n@@ -553,41 +540,31 @@ impl Subcommand {\n \n     pub fn compare_mode(&self) -> Option<&str> {\n         match *self {\n-            Subcommand::Test {\n-                ref compare_mode, ..\n-            } => compare_mode.as_ref().map(|s| &s[..]),\n+            Subcommand::Test { ref compare_mode, .. } => compare_mode.as_ref().map(|s| &s[..]),\n             _ => None,\n         }\n     }\n \n     pub fn pass(&self) -> Option<&str> {\n         match *self {\n-            Subcommand::Test {\n-                ref pass, ..\n-            } => pass.as_ref().map(|s| &s[..]),\n+            Subcommand::Test { ref pass, .. } => pass.as_ref().map(|s| &s[..]),\n             _ => None,\n         }\n     }\n }\n \n fn split(s: &[String]) -> Vec<String> {\n-    s.iter()\n-        .flat_map(|s| s.split(','))\n-        .map(|s| s.to_string())\n-        .collect()\n+    s.iter().flat_map(|s| s.split(',')).map(|s| s.to_string()).collect()\n }\n \n fn parse_deny_warnings(matches: &getopts::Matches) -> Option<bool> {\n     match matches.opt_str(\"warnings\").as_ref().map(|v| v.as_str()) {\n         Some(\"deny\") => Some(true),\n         Some(\"warn\") => Some(false),\n         Some(value) => {\n-            eprintln!(\n-                r#\"invalid value for --warnings: {:?}, expected \"warn\" or \"deny\"\"#,\n-                value,\n-                );\n+            eprintln!(r#\"invalid value for --warnings: {:?}, expected \"warn\" or \"deny\"\"#, value,);\n             process::exit(1);\n-        },\n+        }\n         None => None,\n     }\n }"}, {"sha": "57153e2ad39f4d7d23bbb8740be0a8be02368acc", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -29,11 +29,11 @@\n \n #![allow(nonstandard_style, dead_code)]\n \n+use crate::Build;\n use std::env;\n use std::io;\n use std::mem;\n use std::ptr;\n-use crate::Build;\n \n type HANDLE = *mut u8;\n type BOOL = i32;\n@@ -61,21 +61,23 @@ extern \"system\" {\n     fn CreateJobObjectW(lpJobAttributes: *mut u8, lpName: *const u8) -> HANDLE;\n     fn CloseHandle(hObject: HANDLE) -> BOOL;\n     fn GetCurrentProcess() -> HANDLE;\n-    fn OpenProcess(dwDesiredAccess: DWORD,\n-                   bInheritHandle: BOOL,\n-                   dwProcessId: DWORD) -> HANDLE;\n-    fn DuplicateHandle(hSourceProcessHandle: HANDLE,\n-                       hSourceHandle: HANDLE,\n-                       hTargetProcessHandle: HANDLE,\n-                       lpTargetHandle: LPHANDLE,\n-                       dwDesiredAccess: DWORD,\n-                       bInheritHandle: BOOL,\n-                       dwOptions: DWORD) -> BOOL;\n+    fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) -> HANDLE;\n+    fn DuplicateHandle(\n+        hSourceProcessHandle: HANDLE,\n+        hSourceHandle: HANDLE,\n+        hTargetProcessHandle: HANDLE,\n+        lpTargetHandle: LPHANDLE,\n+        dwDesiredAccess: DWORD,\n+        bInheritHandle: BOOL,\n+        dwOptions: DWORD,\n+    ) -> BOOL;\n     fn AssignProcessToJobObject(hJob: HANDLE, hProcess: HANDLE) -> BOOL;\n-    fn SetInformationJobObject(hJob: HANDLE,\n-                               JobObjectInformationClass: JOBOBJECTINFOCLASS,\n-                               lpJobObjectInformation: LPVOID,\n-                               cbJobObjectInformationLength: DWORD) -> BOOL;\n+    fn SetInformationJobObject(\n+        hJob: HANDLE,\n+        JobObjectInformationClass: JOBOBJECTINFOCLASS,\n+        lpJobObjectInformation: LPVOID,\n+        cbJobObjectInformationLength: DWORD,\n+    ) -> BOOL;\n     fn SetErrorMode(mode: UINT) -> UINT;\n }\n \n@@ -132,10 +134,12 @@ pub unsafe fn setup(build: &mut Build) {\n         info.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PRIORITY_CLASS;\n         info.BasicLimitInformation.PriorityClass = BELOW_NORMAL_PRIORITY_CLASS;\n     }\n-    let r = SetInformationJobObject(job,\n-                                    JobObjectExtendedLimitInformation,\n-                                    &mut info as *mut _ as LPVOID,\n-                                    mem::size_of_val(&info) as DWORD);\n+    let r = SetInformationJobObject(\n+        job,\n+        JobObjectExtendedLimitInformation,\n+        &mut info as *mut _ as LPVOID,\n+        mem::size_of_val(&info) as DWORD,\n+    );\n     assert!(r != 0, \"{}\", io::Error::last_os_error());\n \n     // Assign our process to this job object. Note that if this fails, one very\n@@ -150,7 +154,7 @@ pub unsafe fn setup(build: &mut Build) {\n     let r = AssignProcessToJobObject(job, GetCurrentProcess());\n     if r == 0 {\n         CloseHandle(job);\n-        return\n+        return;\n     }\n \n     // If we've got a parent process (e.g., the python script that called us)\n@@ -169,9 +173,15 @@ pub unsafe fn setup(build: &mut Build) {\n     let parent = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid.parse().unwrap());\n     assert!(!parent.is_null(), \"{}\", io::Error::last_os_error());\n     let mut parent_handle = ptr::null_mut();\n-    let r = DuplicateHandle(GetCurrentProcess(), job,\n-                            parent, &mut parent_handle,\n-                            0, FALSE, DUPLICATE_SAME_ACCESS);\n+    let r = DuplicateHandle(\n+        GetCurrentProcess(),\n+        job,\n+        parent,\n+        &mut parent_handle,\n+        0,\n+        FALSE,\n+        DUPLICATE_SAME_ACCESS,\n+    );\n \n     // If this failed, well at least we tried! An example of DuplicateHandle\n     // failing in the past has been when the wrong python2 package spawned this"}, {"sha": "1fee3fd9ac1d26038726a25287061fd75e7ade5e", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 129, "deletions": 122, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -106,12 +106,12 @@\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n \n-use std::cell::{RefCell, Cell};\n-use std::collections::{HashSet, HashMap};\n+use std::cell::{Cell, RefCell};\n+use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::fs::{self, OpenOptions, File};\n-use std::io::{Seek, SeekFrom, Write, Read};\n-use std::path::{PathBuf, Path};\n+use std::fs::{self, File, OpenOptions};\n+use std::io::{Read, Seek, SeekFrom, Write};\n+use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n use std::slice;\n use std::str;\n@@ -121,33 +121,31 @@ use std::os::unix::fs::symlink as symlink_file;\n #[cfg(windows)]\n use std::os::windows::fs::symlink_file;\n \n-use build_helper::{\n-    mtime, output, run, run_suppressed, t, try_run, try_run_suppressed,\n-};\n+use build_helper::{mtime, output, run, run_suppressed, t, try_run, try_run_suppressed};\n use filetime::FileTime;\n \n use crate::util::{exe, libdir, CiEnv};\n \n+mod builder;\n+mod cache;\n mod cc_detect;\n mod channel;\n mod check;\n-mod test;\n mod clean;\n mod compile;\n-mod metadata;\n mod config;\n mod dist;\n mod doc;\n mod flags;\n+mod format;\n mod install;\n+mod metadata;\n mod native;\n mod sanity;\n-pub mod util;\n-mod builder;\n-mod cache;\n+mod test;\n mod tool;\n mod toolstate;\n-mod format;\n+pub mod util;\n \n #[cfg(windows)]\n mod job;\n@@ -163,13 +161,12 @@ mod job {\n \n #[cfg(any(target_os = \"haiku\", target_os = \"hermit\", not(any(unix, windows))))]\n mod job {\n-    pub unsafe fn setup(_build: &mut crate::Build) {\n-    }\n+    pub unsafe fn setup(_build: &mut crate::Build) {}\n }\n \n+use crate::cache::{Interned, INTERNER};\n pub use crate::config::Config;\n use crate::flags::Subcommand;\n-use crate::cache::{Interned, INTERNER};\n \n const LLVM_TOOLS: &[&str] = &[\n     \"llvm-nm\", // used to inspect binaries; it shows symbol names, their sizes and visibility\n@@ -179,7 +176,7 @@ const LLVM_TOOLS: &[&str] = &[\n     \"llvm-readobj\", // used to get information from ELFs/objects that the other tools don't provide\n     \"llvm-size\", // used to prints the size of the linker sections of a program\n     \"llvm-strip\", // used to discard symbols from binary files to reduce their size\n-    \"llvm-ar\" // used for creating and modifying archive files\n+    \"llvm-ar\", // used for creating and modifying archive files\n ];\n \n /// A structure representing a Rust compiler.\n@@ -258,10 +255,8 @@ pub struct Build {\n     ci_env: CiEnv,\n     delayed_failures: RefCell<Vec<String>>,\n     prerelease_version: Cell<Option<u32>>,\n-    tool_artifacts: RefCell<HashMap<\n-        Interned<String>,\n-        HashMap<String, (&'static str, PathBuf, Vec<String>)>\n-    >>,\n+    tool_artifacts:\n+        RefCell<HashMap<Interned<String>, HashMap<String, (&'static str, PathBuf, Vec<String>)>>>,\n }\n \n #[derive(Debug)]\n@@ -274,8 +269,7 @@ struct Crate {\n \n impl Crate {\n     fn is_local(&self, build: &Build) -> bool {\n-        self.path.starts_with(&build.config.src) &&\n-        !self.path.to_string_lossy().ends_with(\"_shim\")\n+        self.path.starts_with(&build.config.src) && !self.path.to_string_lossy().ends_with(\"_shim\")\n     }\n \n     fn local_path(&self, build: &Build) -> PathBuf {\n@@ -316,7 +310,7 @@ impl Mode {\n     pub fn is_tool(&self) -> bool {\n         match self {\n             Mode::ToolBootstrap | Mode::ToolRustc | Mode::ToolStd => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n }\n@@ -331,12 +325,10 @@ impl Build {\n         let out = config.out.clone();\n \n         let is_sudo = match env::var_os(\"SUDO_USER\") {\n-            Some(sudo_user) => {\n-                match env::var_os(\"USER\") {\n-                    Some(user) => user != sudo_user,\n-                    None => false,\n-                }\n-            }\n+            Some(sudo_user) => match env::var_os(\"USER\") {\n+                Some(user) => user != sudo_user,\n+                None => false,\n+            },\n             None => false,\n         };\n \n@@ -393,11 +385,15 @@ impl Build {\n \n         // If local-rust is the same major.minor as the current version, then force a\n         // local-rebuild\n-        let local_version_verbose = output(\n-            Command::new(&build.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n+        let local_version_verbose =\n+            output(Command::new(&build.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n         let local_release = local_version_verbose\n-            .lines().filter(|x| x.starts_with(\"release:\"))\n-            .next().unwrap().trim_start_matches(\"release:\").trim();\n+            .lines()\n+            .filter(|x| x.starts_with(\"release:\"))\n+            .next()\n+            .unwrap()\n+            .trim_start_matches(\"release:\")\n+            .trim();\n         let my_version = channel::CFG_RELEASE_NUM;\n         if local_release.split('.').take(2).eq(my_version.split('.').take(2)) {\n             build.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n@@ -411,9 +407,7 @@ impl Build {\n     }\n \n     pub fn build_triple(&self) -> &[Interned<String>] {\n-        unsafe {\n-            slice::from_raw_parts(&self.build, 1)\n-        }\n+        unsafe { slice::from_raw_parts(&self.build, 1) }\n     }\n \n     /// Executes the entire build, as configured by the flags and configuration.\n@@ -514,7 +508,7 @@ impl Build {\n     /// Component directory that Cargo will produce output into (e.g.\n     /// release/debug)\n     fn cargo_dir(&self) -> &'static str {\n-        if self.config.rust_optimize {\"release\"} else {\"debug\"}\n+        if self.config.rust_optimize { \"release\" } else { \"debug\" }\n     }\n \n     fn tools_dir(&self, compiler: Compiler) -> PathBuf {\n@@ -535,17 +529,13 @@ impl Build {\n             Mode::ToolBootstrap => \"-bootstrap-tools\",\n             Mode::ToolStd | Mode::ToolRustc => \"-tools\",\n         };\n-        self.out.join(&*compiler.host)\n-                .join(format!(\"stage{}{}\", compiler.stage, suffix))\n+        self.out.join(&*compiler.host).join(format!(\"stage{}{}\", compiler.stage, suffix))\n     }\n \n     /// Returns the root output directory for all Cargo output in a given stage,\n     /// running a particular compiler, whether or not we're building the\n     /// standard library, and targeting the specified architecture.\n-    fn cargo_out(&self,\n-                 compiler: Compiler,\n-                 mode: Mode,\n-                 target: Interned<String>) -> PathBuf {\n+    fn cargo_out(&self, compiler: Compiler, mode: Mode, target: Interned<String>) -> PathBuf {\n         self.stage_out(compiler, mode).join(&*target).join(self.cargo_dir())\n     }\n \n@@ -589,7 +579,7 @@ impl Build {\n     fn is_rust_llvm(&self, target: Interned<String>) -> bool {\n         match self.config.target_config.get(&target) {\n             Some(ref c) => c.llvm_config.is_none(),\n-            None => true\n+            None => true,\n         }\n     }\n \n@@ -607,8 +597,8 @@ impl Build {\n                 // On Fedora the system LLVM installs FileCheck in the\n                 // llvm subdirectory of the libdir.\n                 let llvm_libdir = output(Command::new(s).arg(\"--libdir\"));\n-                let lib_filecheck = Path::new(llvm_libdir.trim())\n-                    .join(\"llvm\").join(exe(\"FileCheck\", &*target));\n+                let lib_filecheck =\n+                    Path::new(llvm_libdir.trim()).join(\"llvm\").join(exe(\"FileCheck\", &*target));\n                 if lib_filecheck.exists() {\n                     lib_filecheck\n                 } else {\n@@ -667,14 +657,18 @@ impl Build {\n \n     /// Runs a command, printing out nice contextual information if it fails.\n     fn run(&self, cmd: &mut Command) {\n-        if self.config.dry_run { return; }\n+        if self.config.dry_run {\n+            return;\n+        }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         run(cmd)\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n     fn run_quiet(&self, cmd: &mut Command) {\n-        if self.config.dry_run { return; }\n+        if self.config.dry_run {\n+            return;\n+        }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         run_suppressed(cmd)\n     }\n@@ -683,7 +677,9 @@ impl Build {\n     /// Exits if the command failed to execute at all, otherwise returns its\n     /// `status.success()`.\n     fn try_run(&self, cmd: &mut Command) -> bool {\n-        if self.config.dry_run { return true; }\n+        if self.config.dry_run {\n+            return true;\n+        }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         try_run(cmd)\n     }\n@@ -692,7 +688,9 @@ impl Build {\n     /// Exits if the command failed to execute at all, otherwise returns its\n     /// `status.success()`.\n     fn try_run_quiet(&self, cmd: &mut Command) -> bool {\n-        if self.config.dry_run { return true; }\n+        if self.config.dry_run {\n+            return true;\n+        }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         try_run_suppressed(cmd)\n     }\n@@ -720,7 +718,9 @@ impl Build {\n     }\n \n     fn info(&self, msg: &str) {\n-        if self.config.dry_run { return; }\n+        if self.config.dry_run {\n+            return;\n+        }\n         println!(\"{}\", msg);\n     }\n \n@@ -732,7 +732,7 @@ impl Build {\n \n     fn debuginfo_map(&self, which: GitRepo) -> Option<String> {\n         if !self.config.rust_remap_debuginfo {\n-            return None\n+            return None;\n         }\n \n         let path = match which {\n@@ -755,10 +755,12 @@ impl Build {\n     fn cflags(&self, target: Interned<String>, which: GitRepo) -> Vec<String> {\n         // Filter out -O and /O (the optimization flags) that we picked up from\n         // cc-rs because the build scripts will determine that for themselves.\n-        let mut base = self.cc[&target].args().iter()\n-                           .map(|s| s.to_string_lossy().into_owned())\n-                           .filter(|s| !s.starts_with(\"-O\") && !s.starts_with(\"/O\"))\n-                           .collect::<Vec<String>>();\n+        let mut base = self.cc[&target]\n+            .args()\n+            .iter()\n+            .map(|s| s.to_string_lossy().into_owned())\n+            .filter(|s| !s.starts_with(\"-O\") && !s.starts_with(\"/O\"))\n+            .collect::<Vec<String>>();\n \n         // If we're compiling on macOS then we add a few unconditional flags\n         // indicating that we want libc++ (more filled out than libstdc++) and\n@@ -776,7 +778,7 @@ impl Build {\n         }\n \n         if let Some(map) = self.debuginfo_map(which) {\n-        let cc = self.cc(target);\n+            let cc = self.cc(target);\n             if cc.ends_with(\"clang\") || cc.ends_with(\"gcc\") {\n                 base.push(format!(\"-fdebug-prefix-map={}\", map));\n             } else if cc.ends_with(\"clang-cl.exe\") {\n@@ -801,20 +803,21 @@ impl Build {\n     fn cxx(&self, target: Interned<String>) -> Result<&Path, String> {\n         match self.cxx.get(&target) {\n             Some(p) => Ok(p.path()),\n-            None => Err(format!(\n-                    \"target `{}` is not configured as a host, only as a target\",\n-                    target))\n+            None => {\n+                Err(format!(\"target `{}` is not configured as a host, only as a target\", target))\n+            }\n         }\n     }\n \n     /// Returns the path to the linker for the given target if it needs to be overridden.\n     fn linker(&self, target: Interned<String>) -> Option<&Path> {\n-        if let Some(linker) = self.config.target_config.get(&target)\n-                                                       .and_then(|c| c.linker.as_ref()) {\n+        if let Some(linker) = self.config.target_config.get(&target).and_then(|c| c.linker.as_ref())\n+        {\n             Some(linker)\n-        } else if target != self.config.build &&\n-                  util::use_host_linker(&target) &&\n-                  !target.contains(\"msvc\") {\n+        } else if target != self.config.build\n+            && util::use_host_linker(&target)\n+            && !target.contains(\"msvc\")\n+        {\n             Some(self.cc(target))\n         } else {\n             None\n@@ -826,37 +829,36 @@ impl Build {\n         if target.contains(\"pc-windows-msvc\") {\n             Some(true)\n         } else {\n-            self.config.target_config.get(&target)\n-                .and_then(|t| t.crt_static)\n+            self.config.target_config.get(&target).and_then(|t| t.crt_static)\n         }\n     }\n \n     /// Returns the \"musl root\" for this `target`, if defined\n     fn musl_root(&self, target: Interned<String>) -> Option<&Path> {\n-        self.config.target_config.get(&target)\n+        self.config\n+            .target_config\n+            .get(&target)\n             .and_then(|t| t.musl_root.as_ref())\n             .or(self.config.musl_root.as_ref())\n             .map(|p| &**p)\n     }\n \n     /// Returns the sysroot for the wasi target, if defined\n     fn wasi_root(&self, target: Interned<String>) -> Option<&Path> {\n-        self.config.target_config.get(&target)\n-            .and_then(|t| t.wasi_root.as_ref())\n-            .map(|p| &**p)\n+        self.config.target_config.get(&target).and_then(|t| t.wasi_root.as_ref()).map(|p| &**p)\n     }\n \n     /// Returns `true` if this is a no-std `target`, if defined\n     fn no_std(&self, target: Interned<String>) -> Option<bool> {\n-        self.config.target_config.get(&target)\n-            .map(|t| t.no_std)\n+        self.config.target_config.get(&target).map(|t| t.no_std)\n     }\n \n     /// Returns `true` if the target will be tested using the `remote-test-client`\n     /// and `remote-test-server` binaries.\n     fn remote_tested(&self, target: Interned<String>) -> bool {\n-        self.qemu_rootfs(target).is_some() || target.contains(\"android\") ||\n-        env::var_os(\"TEST_DEVICE_ADDR\").is_some()\n+        self.qemu_rootfs(target).is_some()\n+            || target.contains(\"android\")\n+            || env::var_os(\"TEST_DEVICE_ADDR\").is_some()\n     }\n \n     /// Returns the root of the \"rootfs\" image that this target will be using,\n@@ -865,9 +867,7 @@ impl Build {\n     /// If `Some` is returned then that means that tests for this target are\n     /// emulated with QEMU and binaries will need to be shipped to the emulator.\n     fn qemu_rootfs(&self, target: Interned<String>) -> Option<&Path> {\n-        self.config.target_config.get(&target)\n-            .and_then(|t| t.qemu_rootfs.as_ref())\n-            .map(|p| &**p)\n+        self.config.target_config.get(&target).and_then(|t| t.qemu_rootfs.as_ref()).map(|p| &**p)\n     }\n \n     /// Path to the python interpreter to use\n@@ -899,9 +899,9 @@ impl Build {\n     /// When all of these conditions are met the build will lift artifacts from\n     /// the previous stage forward.\n     fn force_use_stage1(&self, compiler: Compiler, target: Interned<String>) -> bool {\n-        !self.config.full_bootstrap &&\n-            compiler.stage >= 2 &&\n-            (self.hosts.iter().any(|h| *h == target) || target == self.build)\n+        !self.config.full_bootstrap\n+            && compiler.stage >= 2\n+            && (self.hosts.iter().any(|h| *h == target) || target == self.build)\n     }\n \n     /// Given `num` in the form \"a.b.c\" return a \"release string\" which\n@@ -912,45 +912,35 @@ impl Build {\n     fn release(&self, num: &str) -> String {\n         match &self.config.channel[..] {\n             \"stable\" => num.to_string(),\n-            \"beta\" => if self.rust_info.is_git() {\n-                format!(\"{}-beta.{}\", num, self.beta_prerelease_version())\n-            } else {\n-                format!(\"{}-beta\", num)\n-            },\n+            \"beta\" => {\n+                if self.rust_info.is_git() {\n+                    format!(\"{}-beta.{}\", num, self.beta_prerelease_version())\n+                } else {\n+                    format!(\"{}-beta\", num)\n+                }\n+            }\n             \"nightly\" => format!(\"{}-nightly\", num),\n             _ => format!(\"{}-dev\", num),\n         }\n     }\n \n     fn beta_prerelease_version(&self) -> u32 {\n         if let Some(s) = self.prerelease_version.get() {\n-            return s\n+            return s;\n         }\n \n         let beta = output(\n-            Command::new(\"git\")\n-                .arg(\"ls-remote\")\n-                .arg(\"origin\")\n-                .arg(\"beta\")\n-                .current_dir(&self.src)\n+            Command::new(\"git\").arg(\"ls-remote\").arg(\"origin\").arg(\"beta\").current_dir(&self.src),\n         );\n         let beta = beta.trim().split_whitespace().next().unwrap();\n         let master = output(\n-            Command::new(\"git\")\n-                .arg(\"ls-remote\")\n-                .arg(\"origin\")\n-                .arg(\"master\")\n-                .current_dir(&self.src)\n+            Command::new(\"git\").arg(\"ls-remote\").arg(\"origin\").arg(\"master\").current_dir(&self.src),\n         );\n         let master = master.trim().split_whitespace().next().unwrap();\n \n         // Figure out where the current beta branch started.\n         let base = output(\n-            Command::new(\"git\")\n-                .arg(\"merge-base\")\n-                .arg(beta)\n-                .arg(master)\n-                .current_dir(&self.src),\n+            Command::new(\"git\").arg(\"merge-base\").arg(beta).arg(master).current_dir(&self.src),\n         );\n         let base = base.trim();\n \n@@ -1061,7 +1051,7 @@ impl Build {\n             let prefix = \"version = \\\"\";\n             let suffix = \"\\\"\";\n             if line.starts_with(prefix) && line.ends_with(suffix) {\n-                return line[prefix.len()..line.len() - suffix.len()].to_string()\n+                return line[prefix.len()..line.len() - suffix.len()].to_string();\n             }\n         }\n \n@@ -1106,7 +1096,7 @@ impl Build {\n         // run_cargo for more information (in compile.rs).\n         for part in contents.split(|b| *b == 0) {\n             if part.is_empty() {\n-                continue\n+                continue;\n             }\n             let host = part[0] as char == 'h';\n             let path = PathBuf::from(t!(str::from_utf8(&part[1..])));\n@@ -1117,9 +1107,13 @@ impl Build {\n \n     /// Copies a file from `src` to `dst`\n     pub fn copy(&self, src: &Path, dst: &Path) {\n-        if self.config.dry_run { return; }\n+        if self.config.dry_run {\n+            return;\n+        }\n         self.verbose_than(1, &format!(\"Copy {:?} to {:?}\", src, dst));\n-        if src == dst { return; }\n+        if src == dst {\n+            return;\n+        }\n         let _ = fs::remove_file(&dst);\n         let metadata = t!(src.symlink_metadata());\n         if metadata.file_type().is_symlink() {\n@@ -1131,8 +1125,7 @@ impl Build {\n             // just fall back to a slow `copy` operation.\n         } else {\n             if let Err(e) = fs::copy(src, dst) {\n-                panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n-                       dst.display(), e)\n+                panic!(\"failed to copy `{}` to `{}`: {}\", src.display(), dst.display(), e)\n             }\n             t!(fs::set_permissions(dst, metadata.permissions()));\n             let atime = FileTime::from_last_access_time(&metadata);\n@@ -1144,7 +1137,9 @@ impl Build {\n     /// Search-and-replaces within a file. (Not maximally efficiently: allocates a\n     /// new string for each replacement.)\n     pub fn replace_in_file(&self, path: &Path, replacements: &[(&str, &str)]) {\n-        if self.config.dry_run { return; }\n+        if self.config.dry_run {\n+            return;\n+        }\n         let mut contents = String::new();\n         let mut file = t!(OpenOptions::new().read(true).write(true).open(path));\n         t!(file.read_to_string(&mut contents));\n@@ -1159,7 +1154,9 @@ impl Build {\n     /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n     /// when this function is called.\n     pub fn cp_r(&self, src: &Path, dst: &Path) {\n-        if self.config.dry_run { return; }\n+        if self.config.dry_run {\n+            return;\n+        }\n         for f in self.read_dir(src) {\n             let path = f.path();\n             let name = path.file_name().unwrap();\n@@ -1210,7 +1207,9 @@ impl Build {\n     }\n \n     fn install(&self, src: &Path, dstdir: &Path, perms: u32) {\n-        if self.config.dry_run { return; }\n+        if self.config.dry_run {\n+            return;\n+        }\n         let dst = dstdir.join(src.file_name().unwrap());\n         self.verbose_than(1, &format!(\"Install {:?} to {:?}\", src, dst));\n         t!(fs::create_dir_all(dstdir));\n@@ -1221,8 +1220,7 @@ impl Build {\n             }\n             let metadata = t!(src.symlink_metadata());\n             if let Err(e) = fs::copy(&src, &dst) {\n-                panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n-                       dst.display(), e)\n+                panic!(\"failed to copy `{}` to `{}`: {}\", src.display(), dst.display(), e)\n             }\n             t!(fs::set_permissions(&dst, metadata.permissions()));\n             let atime = FileTime::from_last_access_time(&metadata);\n@@ -1233,26 +1231,34 @@ impl Build {\n     }\n \n     fn create(&self, path: &Path, s: &str) {\n-        if self.config.dry_run { return; }\n+        if self.config.dry_run {\n+            return;\n+        }\n         t!(fs::write(path, s));\n     }\n \n     fn read(&self, path: &Path) -> String {\n-        if self.config.dry_run { return String::new(); }\n+        if self.config.dry_run {\n+            return String::new();\n+        }\n         t!(fs::read_to_string(path))\n     }\n \n     fn create_dir(&self, dir: &Path) {\n-        if self.config.dry_run { return; }\n+        if self.config.dry_run {\n+            return;\n+        }\n         t!(fs::create_dir_all(dir))\n     }\n \n     fn remove_dir(&self, dir: &Path) {\n-        if self.config.dry_run { return; }\n+        if self.config.dry_run {\n+            return;\n+        }\n         t!(fs::remove_dir_all(dir))\n     }\n \n-    fn read_dir(&self, dir: &Path) -> impl Iterator<Item=fs::DirEntry> {\n+    fn read_dir(&self, dir: &Path) -> impl Iterator<Item = fs::DirEntry> {\n         let iter = match fs::read_dir(dir) {\n             Ok(v) => v,\n             Err(_) if self.config.dry_run => return vec![].into_iter(),\n@@ -1262,7 +1268,9 @@ impl Build {\n     }\n \n     fn remove(&self, f: &Path) {\n-        if self.config.dry_run { return; }\n+        if self.config.dry_run {\n+            return;\n+        }\n         fs::remove_file(f).unwrap_or_else(|_| panic!(\"failed to remove {:?}\", f));\n     }\n }\n@@ -1275,7 +1283,6 @@ fn chmod(path: &Path, perms: u32) {\n #[cfg(windows)]\n fn chmod(_path: &Path, _perms: u32) {}\n \n-\n impl Compiler {\n     pub fn with_stage(mut self, stage: u32) -> Compiler {\n         self.stage = stage;"}, {"sha": "8a26adc7ed50109105f8846727cc6640513b1de4", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,14 +1,14 @@\n use std::collections::HashMap;\n-use std::process::Command;\n-use std::path::PathBuf;\n use std::collections::HashSet;\n+use std::path::PathBuf;\n+use std::process::Command;\n \n use build_helper::output;\n use serde::Deserialize;\n use serde_json;\n \n-use crate::{Build, Crate};\n use crate::cache::INTERNER;\n+use crate::{Build, Crate};\n \n #[derive(Deserialize)]\n struct Output {\n@@ -71,23 +71,22 @@ fn build_krate(features: &str, build: &mut Build, resolves: &mut Vec<ResolveNode\n     // to know what crates to test. Here we run `cargo metadata` to learn about\n     // the dependency graph and what `-p` arguments there are.\n     let mut cargo = Command::new(&build.initial_cargo);\n-    cargo.arg(\"metadata\")\n-         .arg(\"--format-version\").arg(\"1\")\n-         .arg(\"--features\").arg(features)\n-         .arg(\"--manifest-path\").arg(build.src.join(krate).join(\"Cargo.toml\"));\n+    cargo\n+        .arg(\"metadata\")\n+        .arg(\"--format-version\")\n+        .arg(\"1\")\n+        .arg(\"--features\")\n+        .arg(features)\n+        .arg(\"--manifest-path\")\n+        .arg(build.src.join(krate).join(\"Cargo.toml\"));\n     let output = output(&mut cargo);\n     let output: Output = serde_json::from_str(&output).unwrap();\n     for package in output.packages {\n         if package.source.is_none() {\n             let name = INTERNER.intern_string(package.name);\n             let mut path = PathBuf::from(package.manifest_path);\n             path.pop();\n-            build.crates.insert(name, Crate {\n-                name,\n-                id: package.id,\n-                deps: HashSet::new(),\n-                path,\n-            });\n+            build.crates.insert(name, Crate { name, id: package.id, deps: HashSet::new(), path });\n         }\n     }\n     resolves.extend(output.resolve.nodes);"}, {"sha": "afee154fe714314e614fb30f540219d47b44de37", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 106, "deletions": 129, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -15,15 +15,15 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use build_helper::{output, t};\n-use cmake;\n use cc;\n+use cmake;\n \n-use crate::channel;\n-use crate::util::{self, exe};\n-use build_helper::up_to_date;\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n+use crate::channel;\n+use crate::util::{self, exe};\n use crate::GitRepo;\n+use build_helper::up_to_date;\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n@@ -36,15 +36,11 @@ impl Step for Llvm {\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/llvm-project\")\n-            .path(\"src/llvm-project/llvm\")\n-            .path(\"src/llvm\")\n+        run.path(\"src/llvm-project\").path(\"src/llvm-project/llvm\").path(\"src/llvm\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Llvm {\n-            target: run.target,\n-        });\n+        run.builder.ensure(Llvm { target: run.target });\n     }\n \n     /// Compile LLVM for `target`.\n@@ -56,7 +52,7 @@ impl Step for Llvm {\n         if let Some(config) = builder.config.target_config.get(&target) {\n             if let Some(ref s) = config.llvm_config {\n                 check_llvm_version(builder, s);\n-                return s.to_path_buf()\n+                return s.to_path_buf();\n             }\n         }\n \n@@ -69,8 +65,8 @@ impl Step for Llvm {\n         }\n         llvm_config_ret_dir.push(\"bin\");\n \n-        let build_llvm_config = llvm_config_ret_dir\n-            .join(exe(\"llvm-config\", &*builder.config.build));\n+        let build_llvm_config =\n+            llvm_config_ret_dir.join(exe(\"llvm-config\", &*builder.config.build));\n         let done_stamp = out_dir.join(\"llvm-finished-building\");\n \n         if done_stamp.exists() {\n@@ -112,40 +108,42 @@ impl Step for Llvm {\n         // defaults!\n         let llvm_targets = match &builder.config.llvm_targets {\n             Some(s) => s,\n-            None => \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\\\n-                     Sparc;SystemZ;WebAssembly;X86\",\n+            None => {\n+                \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\\\n+                     Sparc;SystemZ;WebAssembly;X86\"\n+            }\n         };\n \n         let llvm_exp_targets = match builder.config.llvm_experimental_targets {\n             Some(ref s) => s,\n             None => \"\",\n         };\n \n-        let assertions = if builder.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n+        let assertions = if builder.config.llvm_assertions { \"ON\" } else { \"OFF\" };\n \n         cfg.out_dir(&out_dir)\n-           .profile(profile)\n-           .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n-           .define(\"LLVM_TARGETS_TO_BUILD\", llvm_targets)\n-           .define(\"LLVM_EXPERIMENTAL_TARGETS_TO_BUILD\", llvm_exp_targets)\n-           .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n-           .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n-           .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n-           .define(\"LLVM_INCLUDE_BENCHMARKS\", \"OFF\")\n-           .define(\"LLVM_ENABLE_ZLIB\", \"OFF\")\n-           .define(\"WITH_POLLY\", \"OFF\")\n-           .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n-           .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n-           .define(\"LLVM_ENABLE_BINDINGS\", \"OFF\")\n-           .define(\"LLVM_ENABLE_Z3_SOLVER\", \"OFF\")\n-           .define(\"LLVM_PARALLEL_COMPILE_JOBS\", builder.jobs().to_string())\n-           .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n-           .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n+            .profile(profile)\n+            .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n+            .define(\"LLVM_TARGETS_TO_BUILD\", llvm_targets)\n+            .define(\"LLVM_EXPERIMENTAL_TARGETS_TO_BUILD\", llvm_exp_targets)\n+            .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n+            .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n+            .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n+            .define(\"LLVM_INCLUDE_BENCHMARKS\", \"OFF\")\n+            .define(\"LLVM_ENABLE_ZLIB\", \"OFF\")\n+            .define(\"WITH_POLLY\", \"OFF\")\n+            .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n+            .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n+            .define(\"LLVM_ENABLE_BINDINGS\", \"OFF\")\n+            .define(\"LLVM_ENABLE_Z3_SOLVER\", \"OFF\")\n+            .define(\"LLVM_PARALLEL_COMPILE_JOBS\", builder.jobs().to_string())\n+            .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n+            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n         if builder.config.llvm_thin_lto {\n             cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\");\n             if !target.contains(\"apple\") {\n-               cfg.define(\"LLVM_ENABLE_LLD\", \"ON\");\n+                cfg.define(\"LLVM_ENABLE_LLD\", \"ON\");\n             }\n         }\n \n@@ -212,20 +210,17 @@ impl Step for Llvm {\n \n         // http://llvm.org/docs/HowToCrossCompileLLVM.html\n         if target != builder.config.build {\n-            builder.ensure(Llvm {\n-                target: builder.config.build,\n-            });\n+            builder.ensure(Llvm { target: builder.config.build });\n             // FIXME: if the llvm root for the build triple is overridden then we\n             //        should use llvm-tblgen from there, also should verify that it\n             //        actually exists most of the time in normal installs of LLVM.\n             let host = builder.llvm_out(builder.config.build).join(\"bin/llvm-tblgen\");\n-            cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n-               .define(\"LLVM_TABLEGEN\", &host);\n+            cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\").define(\"LLVM_TABLEGEN\", &host);\n \n             if target.contains(\"netbsd\") {\n-               cfg.define(\"CMAKE_SYSTEM_NAME\", \"NetBSD\");\n+                cfg.define(\"CMAKE_SYSTEM_NAME\", \"NetBSD\");\n             } else if target.contains(\"freebsd\") {\n-               cfg.define(\"CMAKE_SYSTEM_NAME\", \"FreeBSD\");\n+                cfg.define(\"CMAKE_SYSTEM_NAME\", \"FreeBSD\");\n             }\n \n             cfg.define(\"LLVM_NATIVE_BUILD\", builder.llvm_out(builder.config.build).join(\"build\"));\n@@ -237,11 +232,8 @@ impl Step for Llvm {\n                 cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n             }\n         } else {\n-            let mut default_suffix = format!(\n-                \"-rust-{}-{}\",\n-                channel::CFG_RELEASE_NUM,\n-                builder.config.channel,\n-            );\n+            let mut default_suffix =\n+                format!(\"-rust-{}-{}\", channel::CFG_RELEASE_NUM, builder.config.channel,);\n             if let Some(sha) = llvm_info.sha_short() {\n                 default_suffix.push_str(\"-\");\n                 default_suffix.push_str(sha);\n@@ -282,7 +274,7 @@ impl Step for Llvm {\n \n fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     if !builder.config.llvm_version_check {\n-        return\n+        return;\n     }\n \n     if builder.config.dry_run {\n@@ -291,28 +283,24 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n \n     let mut cmd = Command::new(llvm_config);\n     let version = output(cmd.arg(\"--version\"));\n-    let mut parts = version.split('.').take(2)\n-        .filter_map(|s| s.parse::<u32>().ok());\n+    let mut parts = version.split('.').take(2).filter_map(|s| s.parse::<u32>().ok());\n     if let (Some(major), Some(_minor)) = (parts.next(), parts.next()) {\n         if major >= 7 {\n-            return\n+            return;\n         }\n     }\n     panic!(\"\\n\\nbad LLVM version: {}, need >=7.0\\n\\n\", version)\n }\n \n-fn configure_cmake(builder: &Builder<'_>,\n-                   target: Interned<String>,\n-                   cfg: &mut cmake::Config) {\n+fn configure_cmake(builder: &Builder<'_>, target: Interned<String>, cfg: &mut cmake::Config) {\n     // Do not print installation messages for up-to-date files.\n     // LLVM and LLD builds can produce a lot of those and hit CI limits on log size.\n     cfg.define(\"CMAKE_INSTALL_MESSAGE\", \"LAZY\");\n \n     if builder.config.ninja {\n         cfg.generator(\"Ninja\");\n     }\n-    cfg.target(&target)\n-       .host(&builder.config.build);\n+    cfg.target(&target).host(&builder.config.build);\n \n     let sanitize_cc = |cc: &Path| {\n         if target.contains(\"msvc\") {\n@@ -326,7 +314,7 @@ fn configure_cmake(builder: &Builder<'_>,\n     // vars that we'd otherwise configure. In that case we just skip this\n     // entirely.\n     if target.contains(\"msvc\") && !builder.config.ninja {\n-        return\n+        return;\n     }\n \n     let (cc, cxx) = match builder.config.llvm_clang_cl {\n@@ -335,56 +323,52 @@ fn configure_cmake(builder: &Builder<'_>,\n     };\n \n     // Handle msvc + ninja + ccache specially (this is what the bots use)\n-    if target.contains(\"msvc\") &&\n-       builder.config.ninja &&\n-       builder.config.ccache.is_some()\n-    {\n-       let mut wrap_cc = env::current_exe().expect(\"failed to get cwd\");\n-       wrap_cc.set_file_name(\"sccache-plus-cl.exe\");\n-\n-       cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&wrap_cc))\n-          .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&wrap_cc));\n-       cfg.env(\"SCCACHE_PATH\",\n-               builder.config.ccache.as_ref().unwrap())\n-          .env(\"SCCACHE_TARGET\", target)\n-          .env(\"SCCACHE_CC\", &cc)\n-          .env(\"SCCACHE_CXX\", &cxx);\n-\n-       // Building LLVM on MSVC can be a little ludicrous at times. We're so far\n-       // off the beaten path here that I'm not really sure this is even half\n-       // supported any more. Here we're trying to:\n-       //\n-       // * Build LLVM on MSVC\n-       // * Build LLVM with `clang-cl` instead of `cl.exe`\n-       // * Build a project with `sccache`\n-       // * Build for 32-bit as well\n-       // * Build with Ninja\n-       //\n-       // For `cl.exe` there are different binaries to compile 32/64 bit which\n-       // we use but for `clang-cl` there's only one which internally\n-       // multiplexes via flags. As a result it appears that CMake's detection\n-       // of a compiler's architecture and such on MSVC **doesn't** pass any\n-       // custom flags we pass in CMAKE_CXX_FLAGS below. This means that if we\n-       // use `clang-cl.exe` it's always diagnosed as a 64-bit compiler which\n-       // definitely causes problems since all the env vars are pointing to\n-       // 32-bit libraries.\n-       //\n-       // To hack around this... again... we pass an argument that's\n-       // unconditionally passed in the sccache shim. This'll get CMake to\n-       // correctly diagnose it's doing a 32-bit compilation and LLVM will\n-       // internally configure itself appropriately.\n-       if builder.config.llvm_clang_cl.is_some() && target.contains(\"i686\") {\n-           cfg.env(\"SCCACHE_EXTRA_ARGS\", \"-m32\");\n-       }\n+    if target.contains(\"msvc\") && builder.config.ninja && builder.config.ccache.is_some() {\n+        let mut wrap_cc = env::current_exe().expect(\"failed to get cwd\");\n+        wrap_cc.set_file_name(\"sccache-plus-cl.exe\");\n+\n+        cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&wrap_cc))\n+            .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&wrap_cc));\n+        cfg.env(\"SCCACHE_PATH\", builder.config.ccache.as_ref().unwrap())\n+            .env(\"SCCACHE_TARGET\", target)\n+            .env(\"SCCACHE_CC\", &cc)\n+            .env(\"SCCACHE_CXX\", &cxx);\n+\n+        // Building LLVM on MSVC can be a little ludicrous at times. We're so far\n+        // off the beaten path here that I'm not really sure this is even half\n+        // supported any more. Here we're trying to:\n+        //\n+        // * Build LLVM on MSVC\n+        // * Build LLVM with `clang-cl` instead of `cl.exe`\n+        // * Build a project with `sccache`\n+        // * Build for 32-bit as well\n+        // * Build with Ninja\n+        //\n+        // For `cl.exe` there are different binaries to compile 32/64 bit which\n+        // we use but for `clang-cl` there's only one which internally\n+        // multiplexes via flags. As a result it appears that CMake's detection\n+        // of a compiler's architecture and such on MSVC **doesn't** pass any\n+        // custom flags we pass in CMAKE_CXX_FLAGS below. This means that if we\n+        // use `clang-cl.exe` it's always diagnosed as a 64-bit compiler which\n+        // definitely causes problems since all the env vars are pointing to\n+        // 32-bit libraries.\n+        //\n+        // To hack around this... again... we pass an argument that's\n+        // unconditionally passed in the sccache shim. This'll get CMake to\n+        // correctly diagnose it's doing a 32-bit compilation and LLVM will\n+        // internally configure itself appropriately.\n+        if builder.config.llvm_clang_cl.is_some() && target.contains(\"i686\") {\n+            cfg.env(\"SCCACHE_EXTRA_ARGS\", \"-m32\");\n+        }\n     } else {\n-       // If ccache is configured we inform the build a little differently how\n-       // to invoke ccache while also invoking our compilers.\n-       if let Some(ref ccache) = builder.config.ccache {\n-         cfg.define(\"CMAKE_C_COMPILER_LAUNCHER\", ccache)\n-            .define(\"CMAKE_CXX_COMPILER_LAUNCHER\", ccache);\n-       }\n-       cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n-          .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n+        // If ccache is configured we inform the build a little differently how\n+        // to invoke ccache while also invoking our compilers.\n+        if let Some(ref ccache) = builder.config.ccache {\n+            cfg.define(\"CMAKE_C_COMPILER_LAUNCHER\", ccache)\n+                .define(\"CMAKE_CXX_COMPILER_LAUNCHER\", ccache);\n+        }\n+        cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n+            .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n     }\n \n     cfg.build_arg(\"-j\").build_arg(builder.jobs().to_string());\n@@ -394,10 +378,7 @@ fn configure_cmake(builder: &Builder<'_>,\n     }\n     cfg.define(\"CMAKE_C_FLAGS\", cflags);\n     let mut cxxflags = builder.cflags(target, GitRepo::Llvm).join(\" \");\n-    if builder.config.llvm_static_stdcpp &&\n-        !target.contains(\"msvc\") &&\n-        !target.contains(\"netbsd\")\n-    {\n+    if builder.config.llvm_static_stdcpp && !target.contains(\"msvc\") && !target.contains(\"netbsd\") {\n         cxxflags.push_str(\" -static-libstdc++\");\n     }\n     if let Some(ref s) = builder.config.llvm_cxxflags {\n@@ -455,14 +436,12 @@ impl Step for Lld {\n         }\n         let target = self.target;\n \n-        let llvm_config = builder.ensure(Llvm {\n-            target: self.target,\n-        });\n+        let llvm_config = builder.ensure(Llvm { target: self.target });\n \n         let out_dir = builder.lld_out(target);\n         let done_stamp = out_dir.join(\"lld-finished-building\");\n         if done_stamp.exists() {\n-            return out_dir\n+            return out_dir;\n         }\n \n         builder.info(&format!(\"Building LLD for {}\", target));\n@@ -486,14 +465,12 @@ impl Step for Lld {\n         // ensure we don't hit the same bugs with escaping. It means that you\n         // can't build on a system where your paths require `\\` on Windows, but\n         // there's probably a lot of reasons you can't do that other than this.\n-        let llvm_config_shim = env::current_exe()\n-            .unwrap()\n-            .with_file_name(\"llvm-config-wrapper\");\n+        let llvm_config_shim = env::current_exe().unwrap().with_file_name(\"llvm-config-wrapper\");\n         cfg.out_dir(&out_dir)\n-           .profile(\"Release\")\n-           .env(\"LLVM_CONFIG_REAL\", llvm_config)\n-           .define(\"LLVM_CONFIG_PATH\", llvm_config_shim)\n-           .define(\"LLVM_INCLUDE_TESTS\", \"OFF\");\n+            .profile(\"Release\")\n+            .env(\"LLVM_CONFIG_REAL\", llvm_config)\n+            .define(\"LLVM_CONFIG_PATH\", llvm_config_shim)\n+            .define(\"LLVM_INCLUDE_TESTS\", \"OFF\");\n \n         cfg.build();\n \n@@ -528,7 +505,7 @@ impl Step for TestHelpers {\n         let dst = builder.test_helpers_out(target);\n         let src = builder.src.join(\"src/test/auxiliary/rust_test_helpers.c\");\n         if up_to_date(&src, &dst.join(\"librust_test_helpers.a\")) {\n-            return\n+            return;\n         }\n \n         builder.info(\"Building test helpers\");\n@@ -550,13 +527,13 @@ impl Step for TestHelpers {\n         }\n \n         cfg.cargo_metadata(false)\n-           .out_dir(&dst)\n-           .target(&target)\n-           .host(&builder.config.build)\n-           .opt_level(0)\n-           .warnings(false)\n-           .debug(false)\n-           .file(builder.src.join(\"src/test/auxiliary/rust_test_helpers.c\"))\n-           .compile(\"rust_test_helpers\");\n+            .out_dir(&dst)\n+            .target(&target)\n+            .host(&builder.config.build)\n+            .opt_level(0)\n+            .warnings(false)\n+            .debug(false)\n+            .file(builder.src.join(\"src/test/auxiliary/rust_test_helpers.c\"))\n+            .compile(\"rust_test_helpers\");\n     }\n }"}, {"sha": "8ff7056e628f32349a86b36e1bda086efd5762be", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 61, "deletions": 42, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -10,7 +10,7 @@\n \n use std::collections::HashMap;\n use std::env;\n-use std::ffi::{OsString, OsStr};\n+use std::ffi::{OsStr, OsString};\n use std::fs;\n use std::path::PathBuf;\n use std::process::Command;\n@@ -26,30 +26,31 @@ struct Finder {\n \n impl Finder {\n     fn new() -> Self {\n-        Self {\n-            cache: HashMap::new(),\n-            path: env::var_os(\"PATH\").unwrap_or_default()\n-        }\n+        Self { cache: HashMap::new(), path: env::var_os(\"PATH\").unwrap_or_default() }\n     }\n \n     fn maybe_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> Option<PathBuf> {\n         let cmd: OsString = cmd.as_ref().into();\n         let path = &self.path;\n-        self.cache.entry(cmd.clone()).or_insert_with(|| {\n-            for path in env::split_paths(path) {\n-                let target = path.join(&cmd);\n-                let mut cmd_exe = cmd.clone();\n-                cmd_exe.push(\".exe\");\n-\n-                if target.is_file()                   // some/path/git\n+        self.cache\n+            .entry(cmd.clone())\n+            .or_insert_with(|| {\n+                for path in env::split_paths(path) {\n+                    let target = path.join(&cmd);\n+                    let mut cmd_exe = cmd.clone();\n+                    cmd_exe.push(\".exe\");\n+\n+                    if target.is_file()                   // some/path/git\n                     || path.join(&cmd_exe).exists()   // some/path/git.exe\n-                    || target.join(&cmd_exe).exists() // some/path/git/git.exe\n-                {\n-                    return Some(target);\n+                    || target.join(&cmd_exe).exists()\n+                    // some/path/git/git.exe\n+                    {\n+                        return Some(target);\n+                    }\n                 }\n-            }\n-            None\n-        }).clone()\n+                None\n+            })\n+            .clone()\n     }\n \n     fn must_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> PathBuf {\n@@ -77,11 +78,17 @@ pub fn check(build: &mut Build) {\n     }\n \n     // We need cmake, but only if we're actually building LLVM or sanitizers.\n-    let building_llvm = build.hosts.iter()\n-        .map(|host| build.config.target_config\n-            .get(host)\n-            .map(|config| config.llvm_config.is_none())\n-            .unwrap_or(true))\n+    let building_llvm = build\n+        .hosts\n+        .iter()\n+        .map(|host| {\n+            build\n+                .config\n+                .target_config\n+                .get(host)\n+                .map(|config| config.llvm_config.is_none())\n+                .unwrap_or(true)\n+        })\n         .any(|build_llvm_ourselves| build_llvm_ourselves);\n     if building_llvm || build.config.sanitizers {\n         cmd_finder.must_have(\"cmake\");\n@@ -119,17 +126,29 @@ pub fn check(build: &mut Build) {\n         }\n     }\n \n-    build.config.python = build.config.python.take().map(|p| cmd_finder.must_have(p))\n+    build.config.python = build\n+        .config\n+        .python\n+        .take()\n+        .map(|p| cmd_finder.must_have(p))\n         .or_else(|| cmd_finder.maybe_have(\"python2.7\"))\n         .or_else(|| cmd_finder.maybe_have(\"python2\"))\n         .or_else(|| env::var_os(\"BOOTSTRAP_PYTHON\").map(PathBuf::from)) // set by bootstrap.py\n         .or_else(|| Some(cmd_finder.must_have(\"python\")));\n \n-    build.config.nodejs = build.config.nodejs.take().map(|p| cmd_finder.must_have(p))\n+    build.config.nodejs = build\n+        .config\n+        .nodejs\n+        .take()\n+        .map(|p| cmd_finder.must_have(p))\n         .or_else(|| cmd_finder.maybe_have(\"node\"))\n         .or_else(|| cmd_finder.maybe_have(\"nodejs\"));\n \n-    build.config.gdb = build.config.gdb.take().map(|p| cmd_finder.must_have(p))\n+    build.config.gdb = build\n+        .config\n+        .gdb\n+        .take()\n+        .map(|p| cmd_finder.must_have(p))\n         .or_else(|| cmd_finder.maybe_have(\"gdb\"));\n \n     // We're gonna build some custom C code here and there, host triples\n@@ -169,15 +188,13 @@ pub fn check(build: &mut Build) {\n \n     for target in &build.targets {\n         // Can't compile for iOS unless we're on macOS\n-        if target.contains(\"apple-ios\") &&\n-           !build.build.contains(\"apple-darwin\") {\n+        if target.contains(\"apple-ios\") && !build.build.contains(\"apple-darwin\") {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n         if target.contains(\"-none-\") || target.contains(\"nvptx\") {\n             if build.no_std(*target).is_none() {\n-                let target = build.config.target_config.entry(target.clone())\n-                    .or_default();\n+                let target = build.config.target_config.entry(target.clone()).or_default();\n \n                 target.no_std = true;\n             }\n@@ -192,22 +209,20 @@ pub fn check(build: &mut Build) {\n             // If this is a native target (host is also musl) and no musl-root is given,\n             // fall back to the system toolchain in /usr before giving up\n             if build.musl_root(*target).is_none() && build.config.build == *target {\n-                let target = build.config.target_config.entry(target.clone())\n-                    .or_default();\n+                let target = build.config.target_config.entry(target.clone()).or_default();\n                 target.musl_root = Some(\"/usr\".into());\n             }\n             match build.musl_root(*target) {\n                 Some(root) => {\n                     if fs::metadata(root.join(\"lib/libc.a\")).is_err() {\n-                        panic!(\"couldn't find libc.a in musl dir: {}\",\n-                               root.join(\"lib\").display());\n+                        panic!(\"couldn't find libc.a in musl dir: {}\", root.join(\"lib\").display());\n                     }\n                 }\n-                None => {\n-                    panic!(\"when targeting MUSL either the rust.musl-root \\\n+                None => panic!(\n+                    \"when targeting MUSL either the rust.musl-root \\\n                             option or the target.$TARGET.musl-root option must \\\n-                            be specified in config.toml\")\n-                }\n+                            be specified in config.toml\"\n+                ),\n             }\n         }\n \n@@ -217,7 +232,8 @@ pub fn check(build: &mut Build) {\n             // Studio, so detect that here and error.\n             let out = output(Command::new(\"cmake\").arg(\"--help\"));\n             if !out.contains(\"Visual Studio\") {\n-                panic!(\"\n+                panic!(\n+                    \"\n cmake does not support Visual Studio generators.\n \n This is likely due to it being an msys/cygwin build of cmake,\n@@ -228,7 +244,8 @@ If you are building under msys2 try installing the mingw-w64-x86_64-cmake\n package instead of cmake:\n \n $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n-\");\n+\"\n+                );\n             }\n         }\n     }\n@@ -240,8 +257,10 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n     if build.config.channel == \"stable\" {\n         let stage0 = t!(fs::read_to_string(build.src.join(\"src/stage0.txt\")));\n         if stage0.contains(\"\\ndev:\") {\n-            panic!(\"bootstrapping from a dev compiler in a stable release, but \\\n-                    should only be bootstrapping from a released compiler!\");\n+            panic!(\n+                \"bootstrapping from a dev compiler in a stable release, but \\\n+                    should only be bootstrapping from a released compiler!\"\n+            );\n         }\n     }\n }"}, {"sha": "58dc8ffc17da25df49ce871d0670f22b940422ff", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 177, "deletions": 311, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -19,11 +19,11 @@ use crate::compile;\n use crate::dist;\n use crate::flags::Subcommand;\n use crate::native;\n-use crate::tool::{self, Tool, SourceType};\n+use crate::tool::{self, SourceType, Tool};\n use crate::toolstate::ToolState;\n use crate::util::{self, dylib_path, dylib_path_var};\n use crate::Crate as CargoCrate;\n-use crate::{DocTests, Mode, GitRepo, envify};\n+use crate::{envify, DocTests, GitRepo, Mode};\n \n const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n@@ -115,16 +115,13 @@ impl Step for Linkcheck {\n         let _time = util::timeit(&builder);\n         try_run(\n             builder,\n-            builder\n-                .tool_cmd(Tool::Linkchecker)\n-                .arg(builder.out.join(host).join(\"doc\")),\n+            builder.tool_cmd(Tool::Linkchecker).arg(builder.out.join(host).join(\"doc\")),\n         );\n     }\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run.path(\"src/tools/linkchecker\")\n-            .default_condition(builder.config.docs)\n+        run.path(\"src/tools/linkchecker\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -147,10 +144,7 @@ impl Step for Cargotest {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Cargotest {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n+        run.builder.ensure(Cargotest { stage: run.builder.top_stage, host: run.target });\n     }\n \n     /// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n@@ -159,10 +153,7 @@ impl Step for Cargotest {\n     /// test` to ensure that we don't regress the test suites there.\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(self.stage, self.host);\n-        builder.ensure(compile::Rustc {\n-            compiler,\n-            target: compiler.host,\n-        });\n+        builder.ensure(compile::Rustc { compiler, target: compiler.host });\n \n         // Note that this is a short, cryptic, and not scoped directory name. This\n         // is currently to minimize the length of path on Windows where we otherwise\n@@ -197,28 +188,24 @@ impl Step for Cargo {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Cargo {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n+        run.builder.ensure(Cargo { stage: run.builder.top_stage, host: run.target });\n     }\n \n     /// Runs `cargo test` for `cargo` packaged with Rust.\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(self.stage, self.host);\n \n-        builder.ensure(tool::Cargo {\n+        builder.ensure(tool::Cargo { compiler, target: self.host });\n+        let mut cargo = tool::prepare_tool_cargo(\n+            builder,\n             compiler,\n-            target: self.host,\n-        });\n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 Mode::ToolRustc,\n-                                                 self.host,\n-                                                 \"test\",\n-                                                 \"src/tools/cargo\",\n-                                                 SourceType::Submodule,\n-                                                 &[]);\n+            Mode::ToolRustc,\n+            self.host,\n+            \"test\",\n+            \"src/tools/cargo\",\n+            SourceType::Submodule,\n+            &[],\n+        );\n \n         if !builder.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n@@ -254,10 +241,7 @@ impl Step for Rls {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rls {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n+        run.builder.ensure(Rls { stage: run.builder.top_stage, host: run.target });\n     }\n \n     /// Runs `cargo test` for the rls.\n@@ -266,28 +250,26 @@ impl Step for Rls {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        let build_result = builder.ensure(tool::Rls {\n-            compiler,\n-            target: self.host,\n-            extra_features: Vec::new(),\n-        });\n+        let build_result =\n+            builder.ensure(tool::Rls { compiler, target: self.host, extra_features: Vec::new() });\n         if build_result.is_none() {\n             eprintln!(\"failed to test rls: could not build\");\n             return;\n         }\n \n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 Mode::ToolRustc,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/rls\",\n-                                                 SourceType::Submodule,\n-                                                 &[]);\n+        let mut cargo = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolRustc,\n+            host,\n+            \"test\",\n+            \"src/tools/rls\",\n+            SourceType::Submodule,\n+            &[],\n+        );\n \n         builder.add_rustc_lib_path(compiler, &mut cargo);\n-        cargo.arg(\"--\")\n-            .args(builder.config.cmd.test_args());\n+        cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n         if try_run(builder, &mut cargo.into()) {\n             builder.save_toolstate(\"rls\", ToolState::TestPass);\n@@ -310,10 +292,7 @@ impl Step for Rustfmt {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustfmt {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n+        run.builder.ensure(Rustfmt { stage: run.builder.top_stage, host: run.target });\n     }\n \n     /// Runs `cargo test` for rustfmt.\n@@ -332,14 +311,16 @@ impl Step for Rustfmt {\n             return;\n         }\n \n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 Mode::ToolRustc,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/rustfmt\",\n-                                                 SourceType::Submodule,\n-                                                 &[]);\n+        let mut cargo = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolRustc,\n+            host,\n+            \"test\",\n+            \"src/tools/rustfmt\",\n+            SourceType::Submodule,\n+            &[],\n+        );\n \n         let dir = testdir(builder, compiler.host);\n         t!(fs::create_dir_all(&dir));\n@@ -368,10 +349,7 @@ impl Step for Miri {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Miri {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n+        run.builder.ensure(Miri { stage: run.builder.top_stage, host: run.target });\n     }\n \n     /// Runs `cargo test` for miri.\n@@ -380,11 +358,8 @@ impl Step for Miri {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        let miri = builder.ensure(tool::Miri {\n-            compiler,\n-            target: self.host,\n-            extra_features: Vec::new(),\n-        });\n+        let miri =\n+            builder.ensure(tool::Miri { compiler, target: self.host, extra_features: Vec::new() });\n         if let Some(miri) = miri {\n             let mut cargo = builder.cargo(compiler, Mode::ToolRustc, host, \"install\");\n             cargo.arg(\"xargo\");\n@@ -407,12 +382,7 @@ impl Step for Miri {\n                 SourceType::Submodule,\n                 &[],\n             );\n-            cargo\n-                .arg(\"--bin\")\n-                .arg(\"cargo-miri\")\n-                .arg(\"--\")\n-                .arg(\"miri\")\n-                .arg(\"setup\");\n+            cargo.arg(\"--bin\").arg(\"cargo-miri\").arg(\"--\").arg(\"miri\").arg(\"setup\");\n \n             // Tell `cargo miri` not to worry about the sysroot mismatch (we built with\n             // stage1 but run with stage2).\n@@ -441,7 +411,8 @@ impl Step for Miri {\n                 String::new()\n             } else {\n                 builder.verbose(&format!(\"running: {:?}\", cargo));\n-                let out = cargo.output()\n+                let out = cargo\n+                    .output()\n                     .expect(\"We already ran `cargo miri setup` before and that worked\");\n                 assert!(out.status.success(), \"`cargo miri setup` returned with non-0 exit code\");\n                 // Output is \"<sysroot>\\n\".\n@@ -497,24 +468,24 @@ impl Step for CompiletestTest {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(CompiletestTest {\n-            host: run.target,\n-        });\n+        run.builder.ensure(CompiletestTest { host: run.target });\n     }\n \n     /// Runs `cargo test` for compiletest.\n     fn run(self, builder: &Builder<'_>) {\n         let host = self.host;\n         let compiler = builder.compiler(0, host);\n \n-        let cargo = tool::prepare_tool_cargo(builder,\n-                                             compiler,\n-                                             Mode::ToolBootstrap,\n-                                             host,\n-                                             \"test\",\n-                                             \"src/tools/compiletest\",\n-                                             SourceType::InTree,\n-                                             &[]);\n+        let cargo = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolBootstrap,\n+            host,\n+            \"test\",\n+            \"src/tools/compiletest\",\n+            SourceType::InTree,\n+            &[],\n+        );\n \n         try_run(builder, &mut cargo.into());\n     }\n@@ -536,10 +507,7 @@ impl Step for Clippy {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Clippy {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n+        run.builder.ensure(Clippy { stage: run.builder.top_stage, host: run.target });\n     }\n \n     /// Runs `cargo test` for clippy.\n@@ -554,22 +522,22 @@ impl Step for Clippy {\n             extra_features: Vec::new(),\n         });\n         if let Some(clippy) = clippy {\n-            let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 Mode::ToolRustc,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/clippy\",\n-                                                 SourceType::Submodule,\n-                                                 &[]);\n+            let mut cargo = tool::prepare_tool_cargo(\n+                builder,\n+                compiler,\n+                Mode::ToolRustc,\n+                host,\n+                \"test\",\n+                \"src/tools/clippy\",\n+                SourceType::Submodule,\n+                &[],\n+            );\n \n             // clippy tests need to know about the stage sysroot\n             cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n             cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n             cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            let host_libs = builder\n-                .stage_out(compiler, Mode::ToolRustc)\n-                .join(builder.cargo_dir());\n+            let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());\n             let target_libs = builder\n                 .stage_out(compiler, Mode::ToolRustc)\n                 .join(&self.host)\n@@ -623,19 +591,10 @@ impl Step for RustdocTheme {\n         let rustdoc = builder.out.join(\"bootstrap/debug/rustdoc\");\n         let mut cmd = builder.tool_cmd(Tool::RustdocTheme);\n         cmd.arg(rustdoc.to_str().unwrap())\n-            .arg(\n-                builder\n-                    .src\n-                    .join(\"src/librustdoc/html/static/themes\")\n-                    .to_str()\n-                    .unwrap(),\n-            )\n+            .arg(builder.src.join(\"src/librustdoc/html/static/themes\").to_str().unwrap())\n             .env(\"RUSTC_STAGE\", self.compiler.stage.to_string())\n             .env(\"RUSTC_SYSROOT\", builder.sysroot(self.compiler))\n-            .env(\n-                \"RUSTDOC_LIBDIR\",\n-                builder.sysroot_libdir(self.compiler, self.compiler.host),\n-            )\n+            .env(\"RUSTDOC_LIBDIR\", builder.sysroot_libdir(self.compiler, self.compiler.host))\n             .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n             .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler))\n             .env(\"RUSTDOC_CRATE_VERSION\", builder.rust_version())\n@@ -663,25 +622,17 @@ impl Step for RustdocJSStd {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(RustdocJSStd {\n-            host: run.host,\n-            target: run.target,\n-        });\n+        run.builder.ensure(RustdocJSStd { host: run.host, target: run.target });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n         if let Some(ref nodejs) = builder.config.nodejs {\n             let mut command = Command::new(nodejs);\n             command.args(&[\"src/tools/rustdoc-js-std/tester.js\", &*self.host]);\n-            builder.ensure(crate::doc::Std {\n-                target: self.target,\n-                stage: builder.top_stage,\n-            });\n+            builder.ensure(crate::doc::Std { target: self.target, stage: builder.top_stage });\n             builder.run(&mut command);\n         } else {\n-            builder.info(\n-                \"No nodejs found, skipping \\\"src/test/rustdoc-js-std\\\" tests\"\n-            );\n+            builder.info(\"No nodejs found, skipping \\\"src/test/rustdoc-js-std\\\" tests\");\n         }\n     }\n }\n@@ -704,11 +655,7 @@ impl Step for RustdocJSNotStd {\n \n     fn make_run(run: RunConfig<'_>) {\n         let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n-        run.builder.ensure(RustdocJSNotStd {\n-            host: run.host,\n-            target: run.target,\n-            compiler,\n-        });\n+        run.builder.ensure(RustdocJSNotStd { host: run.host, target: run.target, compiler });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n@@ -722,9 +669,7 @@ impl Step for RustdocJSNotStd {\n                 compare_mode: None,\n             });\n         } else {\n-            builder.info(\n-                \"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\"\n-            );\n+            builder.info(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\");\n         }\n     }\n }\n@@ -747,11 +692,7 @@ impl Step for RustdocUi {\n \n     fn make_run(run: RunConfig<'_>) {\n         let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n-        run.builder.ensure(RustdocUi {\n-            host: run.host,\n-            target: run.target,\n-            compiler,\n-        });\n+        run.builder.ensure(RustdocUi { host: run.host, target: run.target, compiler });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n@@ -818,37 +759,55 @@ fn testdir(builder: &Builder<'_>, host: Interned<String>) -> PathBuf {\n macro_rules! default_test {\n     ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr }) => {\n         test!($name { path: $path, mode: $mode, suite: $suite, default: true, host: false });\n-    }\n+    };\n }\n \n macro_rules! default_test_with_compare_mode {\n     ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr,\n                    compare_mode: $compare_mode:expr }) => {\n-        test_with_compare_mode!($name { path: $path, mode: $mode, suite: $suite, default: true,\n-                                        host: false, compare_mode: $compare_mode });\n-    }\n+        test_with_compare_mode!($name {\n+            path: $path,\n+            mode: $mode,\n+            suite: $suite,\n+            default: true,\n+            host: false,\n+            compare_mode: $compare_mode\n+        });\n+    };\n }\n \n macro_rules! host_test {\n     ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr }) => {\n         test!($name { path: $path, mode: $mode, suite: $suite, default: true, host: true });\n-    }\n+    };\n }\n \n macro_rules! test {\n     ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr, default: $default:expr,\n                    host: $host:expr }) => {\n-        test_definitions!($name { path: $path, mode: $mode, suite: $suite, default: $default,\n-                                  host: $host, compare_mode: None });\n-    }\n+        test_definitions!($name {\n+            path: $path,\n+            mode: $mode,\n+            suite: $suite,\n+            default: $default,\n+            host: $host,\n+            compare_mode: None\n+        });\n+    };\n }\n \n macro_rules! test_with_compare_mode {\n     ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr, default: $default:expr,\n                    host: $host:expr, compare_mode: $compare_mode:expr }) => {\n-        test_definitions!($name { path: $path, mode: $mode, suite: $suite, default: $default,\n-                                  host: $host, compare_mode: Some($compare_mode) });\n-    }\n+        test_definitions!($name {\n+            path: $path,\n+            mode: $mode,\n+            suite: $suite,\n+            default: $default,\n+            host: $host,\n+            compare_mode: Some($compare_mode)\n+        });\n+    };\n }\n \n macro_rules! test_definitions {\n@@ -878,10 +837,7 @@ macro_rules! test_definitions {\n             fn make_run(run: RunConfig<'_>) {\n                 let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n \n-                run.builder.ensure($name {\n-                    compiler,\n-                    target: run.target,\n-                });\n+                run.builder.ensure($name { compiler, target: run.target });\n             }\n \n             fn run(self, builder: &Builder<'_>) {\n@@ -895,7 +851,7 @@ macro_rules! test_definitions {\n                 })\n             }\n         }\n-    }\n+    };\n }\n \n default_test_with_compare_mode!(Ui {\n@@ -911,29 +867,17 @@ default_test!(CompileFail {\n     suite: \"compile-fail\"\n });\n \n-default_test!(RunFail {\n-    path: \"src/test/run-fail\",\n-    mode: \"run-fail\",\n-    suite: \"run-fail\"\n-});\n+default_test!(RunFail { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" });\n \n default_test!(RunPassValgrind {\n     path: \"src/test/run-pass-valgrind\",\n     mode: \"run-pass-valgrind\",\n     suite: \"run-pass-valgrind\"\n });\n \n-default_test!(MirOpt {\n-    path: \"src/test/mir-opt\",\n-    mode: \"mir-opt\",\n-    suite: \"mir-opt\"\n-});\n+default_test!(MirOpt { path: \"src/test/mir-opt\", mode: \"mir-opt\", suite: \"mir-opt\" });\n \n-default_test!(Codegen {\n-    path: \"src/test/codegen\",\n-    mode: \"codegen\",\n-    suite: \"codegen\"\n-});\n+default_test!(Codegen { path: \"src/test/codegen\", mode: \"codegen\", suite: \"codegen\" });\n \n default_test!(CodegenUnits {\n     path: \"src/test/codegen-units\",\n@@ -947,29 +891,13 @@ default_test!(Incremental {\n     suite: \"incremental\"\n });\n \n-default_test!(Debuginfo {\n-    path: \"src/test/debuginfo\",\n-    mode: \"debuginfo\",\n-    suite: \"debuginfo\"\n-});\n+default_test!(Debuginfo { path: \"src/test/debuginfo\", mode: \"debuginfo\", suite: \"debuginfo\" });\n \n-host_test!(UiFullDeps {\n-    path: \"src/test/ui-fulldeps\",\n-    mode: \"ui\",\n-    suite: \"ui-fulldeps\"\n-});\n+host_test!(UiFullDeps { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-fulldeps\" });\n \n-host_test!(Rustdoc {\n-    path: \"src/test/rustdoc\",\n-    mode: \"rustdoc\",\n-    suite: \"rustdoc\"\n-});\n+host_test!(Rustdoc { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" });\n \n-host_test!(Pretty {\n-    path: \"src/test/pretty\",\n-    mode: \"pretty\",\n-    suite: \"pretty\"\n-});\n+host_test!(Pretty { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" });\n test!(RunFailPretty {\n     path: \"src/test/run-fail/pretty\",\n     mode: \"pretty\",\n@@ -985,23 +913,15 @@ test!(RunPassValgrindPretty {\n     host: true\n });\n \n-default_test!(RunMake {\n-    path: \"src/test/run-make\",\n-    mode: \"run-make\",\n-    suite: \"run-make\"\n-});\n+default_test!(RunMake { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" });\n \n host_test!(RunMakeFullDeps {\n     path: \"src/test/run-make-fulldeps\",\n     mode: \"run-make\",\n     suite: \"run-make-fulldeps\"\n });\n \n-default_test!(Assembly {\n-    path: \"src/test/assembly\",\n-    mode: \"assembly\",\n-    suite: \"assembly\"\n-});\n+default_test!(Assembly { path: \"src/test/assembly\", mode: \"assembly\", suite: \"assembly\" });\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n struct Compiletest {\n@@ -1048,10 +968,8 @@ impl Step for Compiletest {\n                 });\n             }\n \n-            builder.ensure(dist::DebuggerScripts {\n-                sysroot: builder.sysroot(compiler),\n-                host: target,\n-            });\n+            builder\n+                .ensure(dist::DebuggerScripts { sysroot: builder.sysroot(compiler), host: target });\n         }\n \n         if suite.ends_with(\"fulldeps\") {\n@@ -1077,10 +995,8 @@ impl Step for Compiletest {\n         // compiletest currently has... a lot of arguments, so let's just pass all\n         // of them!\n \n-        cmd.arg(\"--compile-lib-path\")\n-            .arg(builder.rustc_libdir(compiler));\n-        cmd.arg(\"--run-lib-path\")\n-            .arg(builder.sysroot_libdir(compiler, target));\n+        cmd.arg(\"--compile-lib-path\").arg(builder.rustc_libdir(compiler));\n+        cmd.arg(\"--run-lib-path\").arg(builder.sysroot_libdir(compiler, target));\n         cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n \n         let is_rustdoc = suite.ends_with(\"rustdoc-ui\") || suite.ends_with(\"rustdoc-js\");\n@@ -1091,33 +1007,25 @@ impl Step for Compiletest {\n             || (mode == \"ui\" && is_rustdoc)\n             || mode == \"js-doc-test\"\n         {\n-            cmd.arg(\"--rustdoc-path\")\n-                .arg(builder.rustdoc(compiler));\n+            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler));\n         }\n \n-        cmd.arg(\"--src-base\")\n-            .arg(builder.src.join(\"src/test\").join(suite));\n-        cmd.arg(\"--build-base\")\n-            .arg(testdir(builder, compiler.host).join(suite));\n-        cmd.arg(\"--stage-id\")\n-            .arg(format!(\"stage{}-{}\", compiler.stage, target));\n+        cmd.arg(\"--src-base\").arg(builder.src.join(\"src/test\").join(suite));\n+        cmd.arg(\"--build-base\").arg(testdir(builder, compiler.host).join(suite));\n+        cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n         cmd.arg(\"--mode\").arg(mode);\n         cmd.arg(\"--target\").arg(target);\n         cmd.arg(\"--host\").arg(&*compiler.host);\n-        cmd.arg(\"--llvm-filecheck\")\n-            .arg(builder.llvm_filecheck(builder.config.build));\n+        cmd.arg(\"--llvm-filecheck\").arg(builder.llvm_filecheck(builder.config.build));\n \n         if builder.config.cmd.bless() {\n             cmd.arg(\"--bless\");\n         }\n \n-        let compare_mode = builder.config.cmd.compare_mode().or_else(|| {\n-            if builder.config.test_compare_mode {\n-                self.compare_mode\n-            } else {\n-                None\n-            }\n-        });\n+        let compare_mode =\n+            builder.config.cmd.compare_mode().or_else(|| {\n+                if builder.config.test_compare_mode { self.compare_mode } else { None }\n+            });\n \n         if let Some(ref pass) = builder.config.cmd.pass() {\n             cmd.arg(\"--pass\");\n@@ -1128,11 +1036,7 @@ impl Step for Compiletest {\n             cmd.arg(\"--nodejs\").arg(nodejs);\n         }\n \n-        let mut flags = if is_rustdoc {\n-            Vec::new()\n-        } else {\n-            vec![\"-Crpath\".to_string()]\n-        };\n+        let mut flags = if is_rustdoc { Vec::new() } else { vec![\"-Crpath\".to_string()] };\n         if !is_rustdoc {\n             if builder.config.rust_optimize_tests {\n                 flags.push(\"-O\".to_string());\n@@ -1147,17 +1051,11 @@ impl Step for Compiletest {\n         }\n \n         let mut hostflags = flags.clone();\n-        hostflags.push(format!(\n-            \"-Lnative={}\",\n-            builder.test_helpers_out(compiler.host).display()\n-        ));\n+        hostflags.push(format!(\"-Lnative={}\", builder.test_helpers_out(compiler.host).display()));\n         cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n \n         let mut targetflags = flags;\n-        targetflags.push(format!(\n-            \"-Lnative={}\",\n-            builder.test_helpers_out(target).display()\n-        ));\n+        targetflags.push(format!(\"-Lnative={}\", builder.test_helpers_out(target).display()));\n         cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n \n         cmd.arg(\"--docck-python\").arg(builder.python());\n@@ -1178,9 +1076,10 @@ impl Step for Compiletest {\n         let run = |cmd: &mut Command| {\n             cmd.output().map(|output| {\n                 String::from_utf8_lossy(&output.stdout)\n-                    .lines().next().unwrap_or_else(|| {\n-                        panic!(\"{:?} failed {:?}\", cmd, output)\n-                    }).to_string()\n+                    .lines()\n+                    .next()\n+                    .unwrap_or_else(|| panic!(\"{:?} failed {:?}\", cmd, output))\n+                    .to_string()\n             })\n         };\n         let lldb_exe = if builder.config.lldb_enabled {\n@@ -1192,7 +1091,7 @@ impl Step for Compiletest {\n         let lldb_version = Command::new(&lldb_exe)\n             .arg(\"--version\")\n             .output()\n-            .map(|output| { String::from_utf8_lossy(&output.stdout).to_string() })\n+            .map(|output| String::from_utf8_lossy(&output.stdout).to_string())\n             .ok();\n         if let Some(ref vers) = lldb_version {\n             cmd.arg(\"--lldb-version\").arg(vers);\n@@ -1216,11 +1115,9 @@ impl Step for Compiletest {\n         // Get test-args by striping suite path\n         let mut test_args: Vec<&str> = paths\n             .iter()\n-            .map(|p| {\n-                match p.strip_prefix(\".\") {\n-                    Ok(path) => path,\n-                    Err(_) => p,\n-                }\n+            .map(|p| match p.strip_prefix(\".\") {\n+                Ok(path) => path,\n+                Err(_) => p,\n             })\n             .filter(|p| p.starts_with(suite_path) && (p.is_dir() || p.is_file()))\n             .filter_map(|p| {\n@@ -1250,9 +1147,7 @@ impl Step for Compiletest {\n         }\n \n         if builder.config.llvm_enabled() {\n-            let llvm_config = builder.ensure(native::Llvm {\n-                target: builder.config.build,\n-            });\n+            let llvm_config = builder.ensure(native::Llvm { target: builder.config.build });\n             if !builder.config.dry_run {\n                 let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n                 cmd.arg(\"--llvm-version\").arg(llvm_version);\n@@ -1282,23 +1177,24 @@ impl Step for Compiletest {\n \n                 // The llvm/bin directory contains many useful cross-platform\n                 // tools. Pass the path to run-make tests so they can use them.\n-                let llvm_bin_path = llvm_config.parent()\n+                let llvm_bin_path = llvm_config\n+                    .parent()\n                     .expect(\"Expected llvm-config to be contained in directory\");\n                 assert!(llvm_bin_path.is_dir());\n                 cmd.arg(\"--llvm-bin-dir\").arg(llvm_bin_path);\n \n                 // If LLD is available, add it to the PATH\n                 if builder.config.lld_enabled {\n-                    let lld_install_root = builder.ensure(native::Lld {\n-                        target: builder.config.build,\n-                    });\n+                    let lld_install_root =\n+                        builder.ensure(native::Lld { target: builder.config.build });\n \n                     let lld_bin_path = lld_install_root.join(\"bin\");\n \n                     let old_path = env::var_os(\"PATH\").unwrap_or_default();\n-                    let new_path = env::join_paths(std::iter::once(lld_bin_path)\n-                        .chain(env::split_paths(&old_path)))\n-                        .expect(\"Could not add LLD bin path to PATH\");\n+                    let new_path = env::join_paths(\n+                        std::iter::once(lld_bin_path).chain(env::split_paths(&old_path)),\n+                    )\n+                    .expect(\"Could not add LLD bin path to PATH\");\n                     cmd.env(\"PATH\", new_path);\n                 }\n             }\n@@ -1318,8 +1214,7 @@ impl Step for Compiletest {\n         }\n \n         if builder.remote_tested(target) {\n-            cmd.arg(\"--remote-test-client\")\n-                .arg(builder.tool_exe(Tool::RemoteTestClient));\n+            cmd.arg(\"--remote-test-client\").arg(builder.tool_exe(Tool::RemoteTestClient));\n         }\n \n         // Running a C compiler on MSVC requires a few env vars to be set, to be\n@@ -1349,7 +1244,6 @@ impl Step for Compiletest {\n         std::fs::create_dir_all(&tmp).unwrap();\n         cmd.env(\"RUST_TEST_TMPDIR\", tmp);\n \n-\n         cmd.arg(\"--adb-path\").arg(\"adb\");\n         cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n         if target.contains(\"android\") {\n@@ -1409,10 +1303,7 @@ impl Step for DocTest {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Std {\n-            compiler,\n-            target: compiler.host,\n-        });\n+        builder.ensure(compile::Std { compiler, target: compiler.host });\n \n         // Do a breadth-first traversal of the `src/doc` directory and just run\n         // tests for all files that end in `*.md`\n@@ -1516,9 +1407,8 @@ impl Step for ErrorIndex {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(ErrorIndex {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-        });\n+        run.builder\n+            .ensure(ErrorIndex { compiler: run.builder.compiler(run.builder.top_stage, run.host) });\n     }\n \n     /// Runs the error index generator tool to execute the tests located in the error\n@@ -1530,10 +1420,7 @@ impl Step for ErrorIndex {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Std {\n-            compiler,\n-            target: compiler.host,\n-        });\n+        builder.ensure(compile::Std { compiler, target: compiler.host });\n \n         let dir = testdir(builder, compiler.host);\n         t!(fs::create_dir_all(&dir));\n@@ -1543,9 +1430,7 @@ impl Step for ErrorIndex {\n             builder,\n             builder.compiler(compiler.stage, builder.config.build),\n         );\n-        tool.arg(\"markdown\")\n-            .arg(&output)\n-            .env(\"CFG_BUILD\", &builder.config.build);\n+        tool.arg(\"markdown\").arg(&output).env(\"CFG_BUILD\", &builder.config.build);\n \n         builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n         let _time = util::timeit(&builder);\n@@ -1825,23 +1710,12 @@ impl Step for Crate {\n         if target.contains(\"emscripten\") {\n             cargo.env(\n                 format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                builder\n-                    .config\n-                    .nodejs\n-                    .as_ref()\n-                    .expect(\"nodejs not configured\"),\n+                builder.config.nodejs.as_ref().expect(\"nodejs not configured\"),\n             );\n         } else if target.starts_with(\"wasm32\") {\n-            let node = builder\n-                .config\n-                .nodejs\n-                .as_ref()\n-                .expect(\"nodejs not configured\");\n-            let runner = format!(\n-                \"{} {}/src/etc/wasm32-shim.js\",\n-                node.display(),\n-                builder.src.display()\n-            );\n+            let node = builder.config.nodejs.as_ref().expect(\"nodejs not configured\");\n+            let runner =\n+                format!(\"{} {}/src/etc/wasm32-shim.js\", node.display(), builder.src.display());\n             cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n         } else if builder.remote_tested(target) {\n             cargo.env(\n@@ -1879,10 +1753,7 @@ impl Step for CrateRustdoc {\n \n         let test_kind = builder.kind.into();\n \n-        builder.ensure(CrateRustdoc {\n-            host: run.host,\n-            test_kind,\n-        });\n+        builder.ensure(CrateRustdoc { host: run.host, test_kind });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n@@ -1892,14 +1763,16 @@ impl Step for CrateRustdoc {\n         let target = compiler.host;\n         builder.ensure(compile::Rustc { compiler, target });\n \n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 Mode::ToolRustc,\n-                                                 target,\n-                                                 test_kind.subcommand(),\n-                                                 \"src/tools/rustdoc\",\n-                                                 SourceType::InTree,\n-                                                 &[]);\n+        let mut cargo = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolRustc,\n+            target,\n+            test_kind.subcommand(),\n+            \"src/tools/rustdoc\",\n+            SourceType::InTree,\n+            &[],\n+        );\n         if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n@@ -1961,18 +1834,13 @@ impl Step for RemoteCopyLibs {\n         builder.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n         t!(fs::create_dir_all(builder.out.join(\"tmp\")));\n \n-        let server = builder.ensure(tool::RemoteTestServer {\n-            compiler: compiler.with_stage(0),\n-            target,\n-        });\n+        let server =\n+            builder.ensure(tool::RemoteTestServer { compiler: compiler.with_stage(0), target });\n \n         // Spawn the emulator and wait for it to come online\n         let tool = builder.tool_exe(Tool::RemoteTestClient);\n         let mut cmd = Command::new(&tool);\n-        cmd.arg(\"spawn-emulator\")\n-            .arg(target)\n-            .arg(&server)\n-            .arg(builder.out.join(\"tmp\"));\n+        cmd.arg(\"spawn-emulator\").arg(target).arg(&server).arg(builder.out.join(\"tmp\"));\n         if let Some(rootfs) = builder.qemu_rootfs(target) {\n             cmd.arg(rootfs);\n         }\n@@ -2027,9 +1895,7 @@ impl Step for Distcheck {\n                 .current_dir(&dir),\n         );\n         builder.run(\n-            Command::new(build_helper::make(&builder.config.build))\n-                .arg(\"check\")\n-                .current_dir(&dir),\n+            Command::new(build_helper::make(&builder.config.build)).arg(\"check\").current_dir(&dir),\n         );\n \n         // Now make sure that rust-src has all of libstd's dependencies"}, {"sha": "9fd20386e367bd815c7cb872f1ca9aec4272913b", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 102, "deletions": 101, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,20 +1,20 @@\n-use std::fs;\n+use std::collections::HashSet;\n use std::env;\n+use std::fs;\n use std::path::PathBuf;\n-use std::process::{Command, exit};\n-use std::collections::HashSet;\n+use std::process::{exit, Command};\n \n use build_helper::t;\n \n-use crate::Mode;\n-use crate::Compiler;\n-use crate::builder::{Step, RunConfig, ShouldRun, Builder, Cargo as CargoCommand};\n-use crate::util::{exe, add_lib_path, CiEnv};\n-use crate::compile;\n-use crate::channel::GitInfo;\n-use crate::channel;\n+use crate::builder::{Builder, Cargo as CargoCommand, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n+use crate::channel;\n+use crate::channel::GitInfo;\n+use crate::compile;\n use crate::toolstate::ToolState;\n+use crate::util::{add_lib_path, exe, CiEnv};\n+use crate::Compiler;\n+use crate::Mode;\n \n #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n pub enum SourceType {\n@@ -53,14 +53,10 @@ impl Step for ToolBuild {\n         let is_optional_tool = self.is_optional_tool;\n \n         match self.mode {\n-            Mode::ToolRustc => {\n-                builder.ensure(compile::Rustc { compiler, target })\n-            }\n-            Mode::ToolStd => {\n-                builder.ensure(compile::Std { compiler, target })\n-            }\n+            Mode::ToolRustc => builder.ensure(compile::Rustc { compiler, target }),\n+            Mode::ToolStd => builder.ensure(compile::Std { compiler, target }),\n             Mode::ToolBootstrap => {} // uses downloaded stage0 compiler libs\n-            _ => panic!(\"unexpected Mode for tool build\")\n+            _ => panic!(\"unexpected Mode for tool build\"),\n         }\n \n         let cargo = prepare_tool_cargo(\n@@ -79,12 +75,7 @@ impl Step for ToolBuild {\n         let is_expected = compile::stream_cargo(builder, cargo, vec![], &mut |msg| {\n             // Only care about big things like the RLS/Cargo for now\n             match tool {\n-                | \"rls\"\n-                | \"cargo\"\n-                | \"clippy-driver\"\n-                | \"miri\"\n-                | \"rustfmt\"\n-                => {}\n+                \"rls\" | \"cargo\" | \"clippy-driver\" | \"miri\" | \"rustfmt\" => {}\n \n                 _ => return,\n             }\n@@ -94,9 +85,7 @@ impl Step for ToolBuild {\n                     features,\n                     filenames,\n                     target: _,\n-                } => {\n-                    (package_id, features, filenames)\n-                }\n+                } => (package_id, features, filenames),\n                 _ => return,\n             };\n             let features = features.iter().map(|s| s.to_string()).collect::<Vec<_>>();\n@@ -105,7 +94,7 @@ impl Step for ToolBuild {\n                 let val = (tool, PathBuf::from(&*path), features.clone());\n                 // we're only interested in deduplicating rlibs for now\n                 if val.1.extension().and_then(|s| s.to_str()) != Some(\"rlib\") {\n-                    continue\n+                    continue;\n                 }\n \n                 // Don't worry about compiles that turn out to be host\n@@ -132,9 +121,7 @@ impl Step for ToolBuild {\n                 // already listed then we need to see if we reused the same\n                 // artifact or produced a duplicate.\n                 let mut artifacts = builder.tool_artifacts.borrow_mut();\n-                let prev_artifacts = artifacts\n-                    .entry(target)\n-                    .or_default();\n+                let prev_artifacts = artifacts.entry(target).or_default();\n                 let prev = match prev_artifacts.get(&*id) {\n                     Some(prev) => prev,\n                     None => {\n@@ -160,21 +147,21 @@ impl Step for ToolBuild {\n \n                 // ... and otherwise this looks like we duplicated some sort of\n                 // compilation, so record it to generate an error later.\n-                duplicates.push((\n-                    id.to_string(),\n-                    val,\n-                    prev.clone(),\n-                ));\n+                duplicates.push((id.to_string(), val, prev.clone()));\n             }\n         });\n \n         if is_expected && !duplicates.is_empty() {\n-            println!(\"duplicate artifacts found when compiling a tool, this \\\n+            println!(\n+                \"duplicate artifacts found when compiling a tool, this \\\n                       typically means that something was recompiled because \\\n                       a transitive dependency has different features activated \\\n-                      than in a previous build:\\n\");\n-            println!(\"the following dependencies are duplicated although they \\\n-                      have the same features enabled:\");\n+                      than in a previous build:\\n\"\n+            );\n+            println!(\n+                \"the following dependencies are duplicated although they \\\n+                      have the same features enabled:\"\n+            );\n             for (id, cur, prev) in duplicates.drain_filter(|(_, cur, prev)| cur.2 == prev.2) {\n                 println!(\"  {}\", id);\n                 // same features\n@@ -185,24 +172,33 @@ impl Step for ToolBuild {\n                 println!(\"  {}\", id);\n                 let cur_features: HashSet<_> = cur.2.into_iter().collect();\n                 let prev_features: HashSet<_> = prev.2.into_iter().collect();\n-                println!(\"    `{}` additionally enabled features {:?} at {:?}\",\n-                         cur.0, &cur_features - &prev_features, cur.1);\n-                println!(\"    `{}` additionally enabled features {:?} at {:?}\",\n-                         prev.0, &prev_features - &cur_features, prev.1);\n+                println!(\n+                    \"    `{}` additionally enabled features {:?} at {:?}\",\n+                    cur.0,\n+                    &cur_features - &prev_features,\n+                    cur.1\n+                );\n+                println!(\n+                    \"    `{}` additionally enabled features {:?} at {:?}\",\n+                    prev.0,\n+                    &prev_features - &cur_features,\n+                    prev.1\n+                );\n             }\n             println!();\n-            println!(\"to fix this you will probably want to edit the local \\\n+            println!(\n+                \"to fix this you will probably want to edit the local \\\n                       src/tools/rustc-workspace-hack/Cargo.toml crate, as \\\n                       that will update the dependency graph to ensure that \\\n-                      these crates all share the same feature set\");\n+                      these crates all share the same feature set\"\n+            );\n             panic!(\"tools should not compile multiple copies of the same crate\");\n         }\n \n-        builder.save_toolstate(tool, if is_expected {\n-            ToolState::TestFail\n-        } else {\n-            ToolState::BuildFail\n-        });\n+        builder.save_toolstate(\n+            tool,\n+            if is_expected { ToolState::TestFail } else { ToolState::BuildFail },\n+        );\n \n         if !is_expected {\n             if !is_optional_tool {\n@@ -211,8 +207,8 @@ impl Step for ToolBuild {\n                 None\n             }\n         } else {\n-            let cargo_out = builder.cargo_out(compiler, self.mode, target)\n-                .join(exe(tool, &compiler.host));\n+            let cargo_out =\n+                builder.cargo_out(compiler, self.mode, target).join(exe(tool, &compiler.host));\n             let bin = builder.tools_dir(compiler).join(exe(tool, &compiler.host));\n             builder.copy(&cargo_out, &bin);\n             Some(bin)\n@@ -240,12 +236,12 @@ pub fn prepare_tool_cargo(\n \n     let mut features = extra_features.iter().cloned().collect::<Vec<_>>();\n     if builder.build.config.cargo_native_static {\n-        if path.ends_with(\"cargo\") ||\n-            path.ends_with(\"rls\") ||\n-            path.ends_with(\"clippy\") ||\n-            path.ends_with(\"miri\") ||\n-            path.ends_with(\"rustbook\") ||\n-            path.ends_with(\"rustfmt\")\n+        if path.ends_with(\"cargo\")\n+            || path.ends_with(\"rls\")\n+            || path.ends_with(\"clippy\")\n+            || path.ends_with(\"miri\")\n+            || path.ends_with(\"rustbook\")\n+            || path.ends_with(\"rustfmt\")\n         {\n             cargo.env(\"LIBZ_SYS_STATIC\", \"1\");\n             features.push(\"rustc-workspace-hack/all-static\".to_string());\n@@ -395,9 +391,7 @@ pub struct ErrorIndex {\n \n impl ErrorIndex {\n     pub fn command(builder: &Builder<'_>, compiler: Compiler) -> Command {\n-        let mut cmd = Command::new(builder.ensure(ErrorIndex {\n-            compiler\n-        }));\n+        let mut cmd = Command::new(builder.ensure(ErrorIndex { compiler }));\n         add_lib_path(\n             vec![PathBuf::from(&builder.sysroot_libdir(compiler, compiler.host))],\n             &mut cmd,\n@@ -417,22 +411,23 @@ impl Step for ErrorIndex {\n         // Compile the error-index in the same stage as rustdoc to avoid\n         // recompiling rustdoc twice if we can.\n         let stage = if run.builder.top_stage >= 2 { run.builder.top_stage } else { 0 };\n-        run.builder.ensure(ErrorIndex {\n-            compiler: run.builder.compiler(stage, run.builder.config.build),\n-        });\n+        run.builder\n+            .ensure(ErrorIndex { compiler: run.builder.compiler(stage, run.builder.config.build) });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.compiler.host,\n-            tool: \"error_index_generator\",\n-            mode: Mode::ToolRustc,\n-            path: \"src/tools/error_index_generator\",\n-            is_optional_tool: false,\n-            source_type: SourceType::InTree,\n-            extra_features: Vec::new(),\n-        }).expect(\"expected to build -- essential tool\")\n+        builder\n+            .ensure(ToolBuild {\n+                compiler: self.compiler,\n+                target: self.compiler.host,\n+                tool: \"error_index_generator\",\n+                mode: Mode::ToolRustc,\n+                path: \"src/tools/error_index_generator\",\n+                is_optional_tool: false,\n+                source_type: SourceType::InTree,\n+                extra_features: Vec::new(),\n+            })\n+            .expect(\"expected to build -- essential tool\")\n     }\n }\n \n@@ -457,16 +452,18 @@ impl Step for RemoteTestServer {\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"remote-test-server\",\n-            mode: Mode::ToolStd,\n-            path: \"src/tools/remote-test-server\",\n-            is_optional_tool: false,\n-            source_type: SourceType::InTree,\n-            extra_features: Vec::new(),\n-        }).expect(\"expected to build -- essential tool\")\n+        builder\n+            .ensure(ToolBuild {\n+                compiler: self.compiler,\n+                target: self.target,\n+                tool: \"remote-test-server\",\n+                mode: Mode::ToolStd,\n+                path: \"src/tools/remote-test-server\",\n+                is_optional_tool: false,\n+                source_type: SourceType::InTree,\n+                extra_features: Vec::new(),\n+            })\n+            .expect(\"expected to build -- essential tool\")\n     }\n }\n \n@@ -487,9 +484,8 @@ impl Step for Rustdoc {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustdoc {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-        });\n+        run.builder\n+            .ensure(Rustdoc { compiler: run.builder.compiler(run.builder.top_stage, run.host) });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n@@ -525,14 +521,17 @@ impl Step for Rustdoc {\n             &[],\n         );\n \n-        builder.info(&format!(\"Building rustdoc for stage{} ({})\",\n-            target_compiler.stage, target_compiler.host));\n+        builder.info(&format!(\n+            \"Building rustdoc for stage{} ({})\",\n+            target_compiler.stage, target_compiler.host\n+        ));\n         builder.run(&mut cargo.into());\n \n         // Cargo adds a number of paths to the dylib search path on windows, which results in\n         // the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n         // rustdoc a different name.\n-        let tool_rustdoc = builder.cargo_out(build_compiler, Mode::ToolRustc, target)\n+        let tool_rustdoc = builder\n+            .cargo_out(build_compiler, Mode::ToolRustc, target)\n             .join(exe(\"rustdoc_tool_binary\", &target_compiler.host));\n \n         // don't create a stage0-sysroot/bin directory.\n@@ -574,16 +573,18 @@ impl Step for Cargo {\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"cargo\",\n-            mode: Mode::ToolRustc,\n-            path: \"src/tools/cargo\",\n-            is_optional_tool: false,\n-            source_type: SourceType::Submodule,\n-            extra_features: Vec::new(),\n-        }).expect(\"expected to build -- essential tool\")\n+        builder\n+            .ensure(ToolBuild {\n+                compiler: self.compiler,\n+                target: self.target,\n+                tool: \"cargo\",\n+                mode: Mode::ToolRustc,\n+                path: \"src/tools/cargo\",\n+                is_optional_tool: false,\n+                source_type: SourceType::Submodule,\n+                extra_features: Vec::new(),\n+            })\n+            .expect(\"expected to build -- essential tool\")\n     }\n }\n \n@@ -682,7 +683,7 @@ impl<'a> Builder<'a> {\n             let curpaths = env::split_paths(&curpaths).collect::<Vec<_>>();\n             for &(ref k, ref v) in self.cc[&compiler.host].env() {\n                 if k != \"PATH\" {\n-                    continue\n+                    continue;\n                 }\n                 for path in env::split_paths(v) {\n                     if !curpaths.contains(&path) {"}, {"sha": "b068c8200acecb86302a162f6b402c0871d70919", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,14 +1,14 @@\n-use serde::{Deserialize, Serialize};\n+use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use build_helper::t;\n-use std::time;\n-use std::fs;\n-use std::io::{Seek, SeekFrom};\n+use serde::{Deserialize, Serialize};\n use std::collections::HashMap;\n-use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use std::env;\n use std::fmt;\n-use std::process::Command;\n+use std::fs;\n+use std::io::{Seek, SeekFrom};\n use std::path::PathBuf;\n-use std::env;\n+use std::process::Command;\n+use std::time;\n \n // Each cycle is 42 days long (6 weeks); the last week is 35..=42 then.\n const BETA_WEEK_START: u64 = 35;\n@@ -38,11 +38,15 @@ pub enum ToolState {\n \n impl fmt::Display for ToolState {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", match self {\n-            ToolState::TestFail => \"test-fail\",\n-            ToolState::TestPass => \"test-pass\",\n-            ToolState::BuildFail => \"build-fail\",\n-        })\n+        write!(\n+            f,\n+            \"{}\",\n+            match self {\n+                ToolState::TestFail => \"test-fail\",\n+                ToolState::TestPass => \"test-pass\",\n+                ToolState::BuildFail => \"build-fail\",\n+            }\n+        )\n     }\n }\n \n@@ -120,9 +124,7 @@ fn check_changed_files(toolstates: &HashMap<Box<str>, ToolState>) {\n     let output = t!(String::from_utf8(output.stdout));\n \n     for (tool, submodule) in STABLE_TOOLS.iter().chain(NIGHTLY_TOOLS.iter()) {\n-        let changed = output.lines().any(|l| {\n-            l.starts_with(\"M\") && l.ends_with(submodule)\n-        });\n+        let changed = output.lines().any(|l| l.starts_with(\"M\") && l.ends_with(submodule));\n         eprintln!(\"Verifying status of {}...\", tool);\n         if !changed {\n             continue;\n@@ -179,8 +181,10 @@ impl Step for ToolStateCheck {\n                     eprintln!(\"error: Tool `{}` should be test-pass but is {}\", tool, state);\n                 } else if in_beta_week {\n                     did_error = true;\n-                    eprintln!(\"error: Tool `{}` should be test-pass but is {} during beta week.\",\n-                        tool, state);\n+                    eprintln!(\n+                        \"error: Tool `{}` should be test-pass but is {} during beta week.\",\n+                        tool, state\n+                    );\n                 }\n             }\n         }\n@@ -210,11 +214,8 @@ impl Builder<'_> {\n                 // Ensure the parent directory always exists\n                 t!(std::fs::create_dir_all(parent));\n             }\n-            let mut file = t!(fs::OpenOptions::new()\n-                .create(true)\n-                .write(true)\n-                .read(true)\n-                .open(path));\n+            let mut file =\n+                t!(fs::OpenOptions::new().create(true).write(true).read(true).open(path));\n \n             serde_json::from_reader(&mut file).unwrap_or_default()\n         } else {\n@@ -233,11 +234,8 @@ impl Builder<'_> {\n                 // Ensure the parent directory always exists\n                 t!(std::fs::create_dir_all(parent));\n             }\n-            let mut file = t!(fs::OpenOptions::new()\n-                .create(true)\n-                .read(true)\n-                .write(true)\n-                .open(path));\n+            let mut file =\n+                t!(fs::OpenOptions::new().create(true).read(true).write(true).open(path));\n \n             let mut current_toolstates: HashMap<Box<str>, ToolState> =\n                 serde_json::from_reader(&mut file).unwrap_or_default();\n@@ -275,10 +273,7 @@ impl Builder<'_> {\n ///\n ///       * See <https://help.github.com/articles/about-commit-email-addresses/>\n ///           if a private email by GitHub is wanted.\n-fn commit_toolstate_change(\n-    current_toolstate: &ToolstateData,\n-    in_beta_week: bool,\n-) {\n+fn commit_toolstate_change(current_toolstate: &ToolstateData, in_beta_week: bool) {\n     fn git_config(key: &str, value: &str) {\n         let status = Command::new(\"git\").arg(\"config\").arg(\"--global\").arg(key).arg(value).status();\n         let success = match status {\n@@ -303,7 +298,8 @@ fn commit_toolstate_change(\n     let git_credential_path = PathBuf::from(t!(env::var(\"HOME\"))).join(\".git-credentials\");\n     t!(fs::write(&git_credential_path, credential));\n \n-    let status = Command::new(\"git\").arg(\"clone\")\n+    let status = Command::new(\"git\")\n+        .arg(\"clone\")\n         .arg(\"--depth=1\")\n         .arg(t!(env::var(\"TOOLSTATE_REPO\")))\n         .status();\n@@ -402,10 +398,7 @@ fn change_toolstate(\n         std::process::exit(1);\n     }\n \n-    let commit = t!(std::process::Command::new(\"git\")\n-        .arg(\"rev-parse\")\n-        .arg(\"HEAD\")\n-        .output());\n+    let commit = t!(std::process::Command::new(\"git\").arg(\"rev-parse\").arg(\"HEAD\").output());\n     let commit = t!(String::from_utf8(commit.stdout));\n \n     let toolstate_serialized = t!(serde_json::to_string(&current_toolstate));"}, {"sha": "5fd25981851d4e99af7b99024620843c842cf23a", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 62, "deletions": 67, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -4,36 +4,28 @@\n //! not a lot of interesting happenings here unfortunately.\n \n use std::env;\n-use std::str;\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n+use std::str;\n use std::time::Instant;\n \n use build_helper::t;\n \n-use crate::config::Config;\n use crate::builder::Builder;\n use crate::cache::Interned;\n+use crate::config::Config;\n \n /// Returns the `name` as the filename of a static library for `target`.\n pub fn staticlib(name: &str, target: &str) -> String {\n-    if target.contains(\"windows\") {\n-        format!(\"{}.lib\", name)\n-    } else {\n-        format!(\"lib{}.a\", name)\n-    }\n+    if target.contains(\"windows\") { format!(\"{}.lib\", name) } else { format!(\"lib{}.a\", name) }\n }\n \n /// Given an executable called `name`, return the filename for the\n /// executable for a particular target.\n pub fn exe(name: &str, target: &str) -> String {\n-    if target.contains(\"windows\") {\n-        format!(\"{}.exe\", name)\n-    } else {\n-        name.to_string()\n-    }\n+    if target.contains(\"windows\") { format!(\"{}.exe\", name) } else { name.to_string() }\n }\n \n /// Returns `true` if the file name given looks like a dynamic library.\n@@ -44,7 +36,7 @@ pub fn is_dylib(name: &str) -> bool {\n /// Returns the corresponding relative library directory that the compiler's\n /// dylibs will be found in.\n pub fn libdir(target: &str) -> &'static str {\n-    if target.contains(\"windows\") {\"bin\"} else {\"lib\"}\n+    if target.contains(\"windows\") { \"bin\" } else { \"lib\" }\n }\n \n /// Adds a list of lookup paths to `cmd`'s dynamic library lookup path.\n@@ -106,17 +98,17 @@ impl Drop for TimeIt {\n     fn drop(&mut self) {\n         let time = self.1.elapsed();\n         if !self.0 {\n-            println!(\"\\tfinished in {}.{:03}\",\n-                    time.as_secs(),\n-                    time.subsec_nanos() / 1_000_000);\n+            println!(\"\\tfinished in {}.{:03}\", time.as_secs(), time.subsec_nanos() / 1_000_000);\n         }\n     }\n }\n \n /// Symlinks two directories, using junctions on Windows and normal symlinks on\n /// Unix.\n pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n-    if config.dry_run { return Ok(()); }\n+    if config.dry_run {\n+        return Ok(());\n+    }\n     let _ = fs::remove_dir(dest);\n     return symlink_dir_inner(src, dest);\n \n@@ -136,9 +128,9 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n     #[cfg(windows)]\n     #[allow(nonstandard_style)]\n     fn symlink_dir_inner(target: &Path, junction: &Path) -> io::Result<()> {\n-        use std::ptr;\n         use std::ffi::OsStr;\n         use std::os::windows::ffi::OsStrExt;\n+        use std::ptr;\n \n         const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n         const GENERIC_WRITE: DWORD = 0x40000000;\n@@ -174,22 +166,25 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n         }\n \n         extern \"system\" {\n-            fn CreateFileW(lpFileName: LPCWSTR,\n-                           dwDesiredAccess: DWORD,\n-                           dwShareMode: DWORD,\n-                           lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-                           dwCreationDisposition: DWORD,\n-                           dwFlagsAndAttributes: DWORD,\n-                           hTemplateFile: HANDLE)\n-                           -> HANDLE;\n-            fn DeviceIoControl(hDevice: HANDLE,\n-                               dwIoControlCode: DWORD,\n-                               lpInBuffer: LPVOID,\n-                               nInBufferSize: DWORD,\n-                               lpOutBuffer: LPVOID,\n-                               nOutBufferSize: DWORD,\n-                               lpBytesReturned: LPDWORD,\n-                               lpOverlapped: LPOVERLAPPED) -> BOOL;\n+            fn CreateFileW(\n+                lpFileName: LPCWSTR,\n+                dwDesiredAccess: DWORD,\n+                dwShareMode: DWORD,\n+                lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+                dwCreationDisposition: DWORD,\n+                dwFlagsAndAttributes: DWORD,\n+                hTemplateFile: HANDLE,\n+            ) -> HANDLE;\n+            fn DeviceIoControl(\n+                hDevice: HANDLE,\n+                dwIoControlCode: DWORD,\n+                lpInBuffer: LPVOID,\n+                nInBufferSize: DWORD,\n+                lpOutBuffer: LPVOID,\n+                nOutBufferSize: DWORD,\n+                lpBytesReturned: LPDWORD,\n+                lpOverlapped: LPOVERLAPPED,\n+            ) -> BOOL;\n             fn CloseHandle(hObject: HANDLE) -> BOOL;\n         }\n \n@@ -207,17 +202,18 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n         let path = to_u16s(junction)?;\n \n         unsafe {\n-            let h = CreateFileW(path.as_ptr(),\n-                                GENERIC_WRITE,\n-                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n-                                ptr::null_mut(),\n-                                OPEN_EXISTING,\n-                                FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,\n-                                ptr::null_mut());\n+            let h = CreateFileW(\n+                path.as_ptr(),\n+                GENERIC_WRITE,\n+                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n+                ptr::null_mut(),\n+                OPEN_EXISTING,\n+                FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,\n+                ptr::null_mut(),\n+            );\n \n             let mut data = [0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-            let db = data.as_mut_ptr()\n-                            as *mut REPARSE_MOUNTPOINT_DATA_BUFFER;\n+            let db = data.as_mut_ptr() as *mut REPARSE_MOUNTPOINT_DATA_BUFFER;\n             let buf = &mut (*db).ReparseTarget as *mut u16;\n             let mut i = 0;\n             // FIXME: this conversion is very hacky\n@@ -232,23 +228,21 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n             (*db).ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n             (*db).ReparseTargetMaximumLength = (i * 2) as WORD;\n             (*db).ReparseTargetLength = ((i - 1) * 2) as WORD;\n-            (*db).ReparseDataLength =\n-                    (*db).ReparseTargetLength as DWORD + 12;\n+            (*db).ReparseDataLength = (*db).ReparseTargetLength as DWORD + 12;\n \n             let mut ret = 0;\n-            let res = DeviceIoControl(h as *mut _,\n-                                      FSCTL_SET_REPARSE_POINT,\n-                                      data.as_ptr() as *mut _,\n-                                      (*db).ReparseDataLength + 8,\n-                                      ptr::null_mut(), 0,\n-                                      &mut ret,\n-                                      ptr::null_mut());\n-\n-            let out = if res == 0 {\n-                Err(io::Error::last_os_error())\n-            } else {\n-                Ok(())\n-            };\n+            let res = DeviceIoControl(\n+                h as *mut _,\n+                FSCTL_SET_REPARSE_POINT,\n+                data.as_ptr() as *mut _,\n+                (*db).ReparseDataLength + 8,\n+                ptr::null_mut(),\n+                0,\n+                &mut ret,\n+                ptr::null_mut(),\n+            );\n+\n+            let out = if res == 0 { Err(io::Error::last_os_error()) } else { Ok(()) };\n             CloseHandle(h);\n             out\n         }\n@@ -299,8 +293,11 @@ pub fn forcing_clang_based_tests() -> bool {\n             \"0\" | \"no\" | \"off\" => false,\n             other => {\n                 // Let's make sure typos don't go unnoticed\n-                panic!(\"Unrecognized option '{}' set in \\\n-                        RUSTBUILD_FORCE_CLANG_BASED_TESTS\", other)\n+                panic!(\n+                    \"Unrecognized option '{}' set in \\\n+                        RUSTBUILD_FORCE_CLANG_BASED_TESTS\",\n+                    other\n+                )\n             }\n         }\n     } else {\n@@ -311,11 +308,9 @@ pub fn forcing_clang_based_tests() -> bool {\n pub fn use_host_linker(target: &Interned<String>) -> bool {\n     // FIXME: this information should be gotten by checking the linker flavor\n     // of the rustc target\n-    !(\n-        target.contains(\"emscripten\") ||\n-        target.contains(\"wasm32\") ||\n-        target.contains(\"nvptx\") ||\n-        target.contains(\"fortanix\") ||\n-        target.contains(\"fuchsia\")\n-    )\n+    !(target.contains(\"emscripten\")\n+        || target.contains(\"wasm32\")\n+        || target.contains(\"nvptx\")\n+        || target.contains(\"fortanix\")\n+        || target.contains(\"fuchsia\"))\n }"}, {"sha": "3f42533238a89dc0cfcba06e016f63dee2d209e1", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 26, "deletions": 49, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,9 +1,9 @@\n use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n+use std::thread;\n use std::time::{SystemTime, UNIX_EPOCH};\n use std::{env, fs};\n-use std::thread;\n \n /// A helper macro to `unwrap` a result except also print out details like:\n ///\n@@ -64,10 +64,7 @@ pub fn run(cmd: &mut Command) {\n pub fn try_run(cmd: &mut Command) -> bool {\n     let status = match cmd.status() {\n         Ok(status) => status,\n-        Err(e) => fail(&format!(\n-            \"failed to execute command: {:?}\\nerror: {}\",\n-            cmd, e\n-        )),\n+        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\", cmd, e)),\n     };\n     if !status.success() {\n         println!(\n@@ -88,10 +85,7 @@ pub fn run_suppressed(cmd: &mut Command) {\n pub fn try_run_suppressed(cmd: &mut Command) -> bool {\n     let output = match cmd.output() {\n         Ok(status) => status,\n-        Err(e) => fail(&format!(\n-            \"failed to execute command: {:?}\\nerror: {}\",\n-            cmd, e\n-        )),\n+        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\", cmd, e)),\n     };\n     if !output.status.success() {\n         println!(\n@@ -119,8 +113,10 @@ pub fn gnu_target(target: &str) -> &str {\n }\n \n pub fn make(host: &str) -> PathBuf {\n-    if host.contains(\"dragonfly\") || host.contains(\"freebsd\")\n-        || host.contains(\"netbsd\") || host.contains(\"openbsd\")\n+    if host.contains(\"dragonfly\")\n+        || host.contains(\"freebsd\")\n+        || host.contains(\"netbsd\")\n+        || host.contains(\"openbsd\")\n     {\n         PathBuf::from(\"gmake\")\n     } else {\n@@ -131,10 +127,7 @@ pub fn make(host: &str) -> PathBuf {\n pub fn output(cmd: &mut Command) -> String {\n     let output = match cmd.stderr(Stdio::inherit()).output() {\n         Ok(status) => status,\n-        Err(e) => fail(&format!(\n-            \"failed to execute command: {:?}\\nerror: {}\",\n-            cmd, e\n-        )),\n+        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\", cmd, e)),\n     };\n     if !output.status.success() {\n         panic!(\n@@ -147,7 +140,8 @@ pub fn output(cmd: &mut Command) -> String {\n }\n \n pub fn rerun_if_changed_anything_in_dir(dir: &Path) {\n-    let mut stack = dir.read_dir()\n+    let mut stack = dir\n+        .read_dir()\n         .unwrap()\n         .map(|e| e.unwrap())\n         .filter(|e| &*e.file_name() != \".git\")\n@@ -164,9 +158,7 @@ pub fn rerun_if_changed_anything_in_dir(dir: &Path) {\n \n /// Returns the last-modified time for `path`, or zero if it doesn't exist.\n pub fn mtime(path: &Path) -> SystemTime {\n-    fs::metadata(path)\n-        .and_then(|f| f.modified())\n-        .unwrap_or(UNIX_EPOCH)\n+    fs::metadata(path).and_then(|f| f.modified()).unwrap_or(UNIX_EPOCH)\n }\n \n /// Returns `true` if `dst` is up to date given that the file or files in `src`\n@@ -205,7 +197,7 @@ impl NativeLibBoilerplate {\n     /// ensure it's linked against correctly.\n     pub fn fixup_sanitizer_lib_name(&self, sanitizer_name: &str) {\n         if env::var(\"TARGET\").unwrap() != \"x86_64-apple-darwin\" {\n-            return\n+            return;\n         }\n \n         let dir = self.out_dir.join(\"build/lib/darwin\");\n@@ -248,45 +240,35 @@ pub fn native_lib_boilerplate(\n ) -> Result<NativeLibBoilerplate, ()> {\n     rerun_if_changed_anything_in_dir(src_dir);\n \n-    let out_dir = env::var_os(\"RUSTBUILD_NATIVE_DIR\").unwrap_or_else(||\n-        env::var_os(\"OUT_DIR\").unwrap());\n+    let out_dir =\n+        env::var_os(\"RUSTBUILD_NATIVE_DIR\").unwrap_or_else(|| env::var_os(\"OUT_DIR\").unwrap());\n     let out_dir = PathBuf::from(out_dir).join(out_name);\n     t!(fs::create_dir_all(&out_dir));\n     if link_name.contains('=') {\n         println!(\"cargo:rustc-link-lib={}\", link_name);\n     } else {\n         println!(\"cargo:rustc-link-lib=static={}\", link_name);\n     }\n-    println!(\n-        \"cargo:rustc-link-search=native={}\",\n-        out_dir.join(search_subdir).display()\n-    );\n+    println!(\"cargo:rustc-link-search=native={}\", out_dir.join(search_subdir).display());\n \n     let timestamp = out_dir.join(\"rustbuild.timestamp\");\n     if !up_to_date(Path::new(\"build.rs\"), &timestamp) || !up_to_date(src_dir, &timestamp) {\n-        Ok(NativeLibBoilerplate {\n-            src_dir: src_dir.to_path_buf(),\n-            out_dir,\n-        })\n+        Ok(NativeLibBoilerplate { src_dir: src_dir.to_path_buf(), out_dir })\n     } else {\n         Err(())\n     }\n }\n \n-pub fn sanitizer_lib_boilerplate(sanitizer_name: &str)\n-    -> Result<(NativeLibBoilerplate, String), ()>\n-{\n+pub fn sanitizer_lib_boilerplate(\n+    sanitizer_name: &str,\n+) -> Result<(NativeLibBoilerplate, String), ()> {\n     let (link_name, search_path, apple) = match &*env::var(\"TARGET\").unwrap() {\n-        \"x86_64-unknown-linux-gnu\" => (\n-            format!(\"clang_rt.{}-x86_64\", sanitizer_name),\n-            \"build/lib/linux\",\n-            false,\n-        ),\n-        \"x86_64-apple-darwin\" => (\n-            format!(\"clang_rt.{}_osx_dynamic\", sanitizer_name),\n-            \"build/lib/darwin\",\n-            true,\n-        ),\n+        \"x86_64-unknown-linux-gnu\" => {\n+            (format!(\"clang_rt.{}-x86_64\", sanitizer_name), \"build/lib/linux\", false)\n+        }\n+        \"x86_64-apple-darwin\" => {\n+            (format!(\"clang_rt.{}_osx_dynamic\", sanitizer_name), \"build/lib/darwin\", true)\n+        }\n         _ => return Err(()),\n     };\n     let to_link = if apple {\n@@ -297,12 +279,7 @@ pub fn sanitizer_lib_boilerplate(sanitizer_name: &str)\n     // This env var is provided by rustbuild to tell us where `compiler-rt`\n     // lives.\n     let dir = env::var_os(\"RUST_COMPILER_RT_ROOT\").unwrap();\n-    let lib = native_lib_boilerplate(\n-        dir.as_ref(),\n-        sanitizer_name,\n-        &to_link,\n-        search_path,\n-    )?;\n+    let lib = native_lib_boilerplate(dir.as_ref(), sanitizer_name, &to_link, search_path)?;\n     Ok((lib, link_name))\n }\n "}, {"sha": "60cf85c4a60cfbdaf33fe67fa078ec25777f76e9", "filename": "src/etc/test-float-parse/long-fractions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fetc%2Ftest-float-parse%2Flong-fractions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fetc%2Ftest-float-parse%2Flong-fractions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Flong-fractions.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,7 +1,7 @@\n mod _common;\n \n-use std::char;\n use _common::validate;\n+use std::char;\n \n fn main() {\n     for n in 0..10 {"}, {"sha": "599986e20dd0b1a08058d61b32f370fab695520c", "filename": "src/etc/test-float-parse/many-digits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fetc%2Ftest-float-parse%2Fmany-digits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fetc%2Ftest-float-parse%2Fmany-digits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fmany-digits.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -2,10 +2,10 @@ extern crate rand;\n \n mod _common;\n \n-use std::char;\n-use rand::{IsaacRng, Rng, SeedableRng};\n-use rand::distributions::{Range, Sample};\n use _common::{validate, SEED};\n+use rand::distributions::{Range, Sample};\n+use rand::{IsaacRng, Rng, SeedableRng};\n+use std::char;\n \n fn main() {\n     let mut rnd = IsaacRng::from_seed(&SEED);"}, {"sha": "ba68d31e4ed7e853979dd724ad9aa73f607226dd", "filename": "src/etc/test-float-parse/subnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fetc%2Ftest-float-parse%2Fsubnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fetc%2Ftest-float-parse%2Fsubnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsubnorm.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,7 +1,7 @@\n mod _common;\n \n-use std::mem::transmute;\n use _common::validate;\n+use std::mem::transmute;\n \n fn main() {\n     for bits in 0u32..(1 << 21) {"}, {"sha": "0c0dc928b95df4e5ef72fa01603bdfe47d2b36d1", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -24,10 +24,7 @@ extern \"Rust\" {\n     #[rustc_allocator_nounwind]\n     fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n     #[rustc_allocator_nounwind]\n-    fn __rust_realloc(ptr: *mut u8,\n-                      old_size: usize,\n-                      align: usize,\n-                      new_size: usize) -> *mut u8;\n+    fn __rust_realloc(ptr: *mut u8, old_size: usize, align: usize, new_size: usize) -> *mut u8;\n     #[rustc_allocator_nounwind]\n     fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n }\n@@ -178,12 +175,12 @@ unsafe impl Alloc for Global {\n     }\n \n     #[inline]\n-    unsafe fn realloc(&mut self,\n-                      ptr: NonNull<u8>,\n-                      layout: Layout,\n-                      new_size: usize)\n-                      -> Result<NonNull<u8>, AllocErr>\n-    {\n+    unsafe fn realloc(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(realloc(ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n \n@@ -204,11 +201,7 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     } else {\n         let layout = Layout::from_size_align_unchecked(size, align);\n         let ptr = alloc(layout);\n-        if !ptr.is_null() {\n-            ptr\n-        } else {\n-            handle_alloc_error(layout)\n-        }\n+        if !ptr.is_null() { ptr } else { handle_alloc_error(layout) }\n     }\n }\n "}, {"sha": "951477a24c8ed3453c655a72a9903ffb87b9933e", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -6,8 +6,8 @@ extern crate test;\n \n mod btree;\n mod linked_list;\n-mod string;\n-mod str;\n mod slice;\n+mod str;\n+mod string;\n mod vec;\n mod vec_deque;"}, {"sha": "a3da9e80cd0fceef6605a2d50efbe3afc2b692c1", "filename": "src/liballoc/benches/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,5 +1,5 @@\n+use std::iter::{repeat, FromIterator};\n use test::Bencher;\n-use std::iter::{FromIterator, repeat};\n \n #[bench]\n fn bench_new(b: &mut Bencher) {"}, {"sha": "51c233a21f1a41ced54ac718792c333dec3f3cae", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -16,8 +16,9 @@ use Cow::*;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B>\n-    where B: ToOwned,\n-          <B as ToOwned>::Owned: 'a\n+where\n+    B: ToOwned,\n+    <B as ToOwned>::Owned: 'a,\n {\n     fn borrow(&self) -> &B {\n         &**self\n@@ -69,17 +70,16 @@ pub trait ToOwned {\n     /// let mut v: Vec<i32> = Vec::new();\n     /// [1, 2][..].clone_into(&mut v);\n     /// ```\n-    #[unstable(feature = \"toowned_clone_into\",\n-               reason = \"recently added\",\n-               issue = \"41263\")]\n+    #[unstable(feature = \"toowned_clone_into\", reason = \"recently added\", issue = \"41263\")]\n     fn clone_into(&self, target: &mut Self::Owned) {\n         *target = self.to_owned();\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ToOwned for T\n-    where T: Clone\n+where\n+    T: Clone,\n {\n     type Owned = T;\n     fn to_owned(&self) -> T {\n@@ -169,17 +169,16 @@ impl<T> ToOwned for T\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Cow<'a, B: ?Sized + 'a>\n-    where B: ToOwned\n+where\n+    B: ToOwned,\n {\n     /// Borrowed data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Borrowed(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-             &'a B),\n+    Borrowed(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a B),\n \n     /// Owned data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Owned(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-          <B as ToOwned>::Owned),\n+    Owned(#[stable(feature = \"rust1\", since = \"1.0.0\")] <B as ToOwned>::Owned),\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -335,7 +334,8 @@ impl<B: ?Sized> Eq for Cow<'_, B> where B: Eq + ToOwned {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: ?Sized> Ord for Cow<'_, B>\n-    where B: Ord + ToOwned\n+where\n+    B: Ord + ToOwned,\n {\n     #[inline]\n     fn cmp(&self, other: &Self) -> Ordering {\n@@ -345,8 +345,9 @@ impl<B: ?Sized> Ord for Cow<'_, B>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B>\n-    where B: PartialEq<C> + ToOwned,\n-          C: ToOwned\n+where\n+    B: PartialEq<C> + ToOwned,\n+    C: ToOwned,\n {\n     #[inline]\n     fn eq(&self, other: &Cow<'b, C>) -> bool {\n@@ -356,7 +357,8 @@ impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, B: ?Sized> PartialOrd for Cow<'a, B>\n-    where B: PartialOrd + ToOwned\n+where\n+    B: PartialOrd + ToOwned,\n {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n@@ -403,7 +405,8 @@ where\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: ?Sized> Hash for Cow<'_, B>\n-    where B: Hash + ToOwned\n+where\n+    B: Hash + ToOwned,\n {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {"}, {"sha": "cc01de08cafb76bb50b25c96310721f2fdf05b83", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -134,21 +134,21 @@ use core::convert::{From, TryFrom};\n use core::fmt;\n use core::future::Future;\n use core::hash::{Hash, Hasher};\n-use core::iter::{Iterator, FromIterator, FusedIterator};\n+use core::iter::{FromIterator, FusedIterator, Iterator};\n use core::marker::{Unpin, Unsize};\n use core::mem;\n-use core::pin::Pin;\n use core::ops::{\n-    CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n+    CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Generator, GeneratorState, Receiver,\n };\n+use core::pin::Pin;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n use core::task::{Context, Poll};\n \n-use crate::alloc::{self, Global, Alloc};\n-use crate::vec::Vec;\n+use crate::alloc::{self, Alloc, Global};\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n+use crate::vec::Vec;\n \n /// A pointer type for heap allocation.\n ///\n@@ -196,12 +196,10 @@ impl<T> Box<T> {\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n         if layout.size() == 0 {\n-            return Box(NonNull::dangling().into())\n+            return Box(NonNull::dangling().into());\n         }\n-        let ptr = unsafe {\n-            Global.alloc(layout)\n-                .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-        };\n+        let ptr =\n+            unsafe { Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)) };\n         Box(ptr.cast().into())\n     }\n \n@@ -269,9 +267,7 @@ impl<T> Box<[T]> {\n             NonNull::dangling()\n         } else {\n             unsafe {\n-                Global.alloc(layout)\n-                    .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-                    .cast()\n+                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast()\n             }\n         };\n         let slice = unsafe { slice::from_raw_parts_mut(ptr.as_ptr(), len) };\n@@ -532,7 +528,7 @@ impl<T: ?Sized> Box<T> {\n     #[inline]\n     pub fn leak<'a>(b: Box<T>) -> &'a mut T\n     where\n-        T: 'a // Technically not needed, but kept to be explicit.\n+        T: 'a, // Technically not needed, but kept to be explicit.\n     {\n         unsafe { &mut *Box::into_raw(b) }\n     }\n@@ -625,15 +621,12 @@ impl<T: Clone> Clone for Box<T> {\n     }\n }\n \n-\n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl Clone for Box<str> {\n     fn clone(&self) -> Self {\n         // this makes a copy of the data\n         let buf: Box<[u8]> = self.as_bytes().into();\n-        unsafe {\n-            from_boxed_utf8_unchecked(buf)\n-        }\n+        unsafe { from_boxed_utf8_unchecked(buf) }\n     }\n }\n \n@@ -1053,10 +1046,7 @@ impl<A> FromIterator<A> for Box<[A]> {\n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl<T: Clone> Clone for Box<[T]> {\n     fn clone(&self) -> Self {\n-        let mut new = BoxBuilder {\n-            data: RawVec::with_capacity(self.len()),\n-            len: 0,\n-        };\n+        let mut new = BoxBuilder { data: RawVec::with_capacity(self.len()), len: 0 };\n \n         let mut target = new.data.ptr();\n \n@@ -1152,7 +1142,7 @@ impl<T: ?Sized> AsMut<T> for Box<T> {\n  *  could have a method to project a Pin<T> from it.\n  */\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized> Unpin for Box<T> { }\n+impl<T: ?Sized> Unpin for Box<T> {}\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator + Unpin> Generator for Box<G> {"}, {"sha": "0148711bb86255a2a1f70b9bc89906524bb79663", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -145,11 +145,11 @@\n #![allow(missing_docs)]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::ops::{Deref, DerefMut};\n+use core::fmt;\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n-use core::mem::{swap, size_of, ManuallyDrop};\n+use core::mem::{size_of, swap, ManuallyDrop};\n+use core::ops::{Deref, DerefMut};\n use core::ptr;\n-use core::fmt;\n \n use crate::slice;\n use crate::vec::{self, Vec};\n@@ -267,9 +267,7 @@ pub struct PeekMut<'a, T: 'a + Ord> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: Ord + fmt::Debug> fmt::Debug for PeekMut<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"PeekMut\")\n-         .field(&self.heap.data[0])\n-         .finish()\n+        f.debug_tuple(\"PeekMut\").field(&self.heap.data[0]).finish()\n     }\n }\n \n@@ -404,14 +402,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// Cost is O(1) in the worst case.\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n-        if self.is_empty() {\n-            None\n-        } else {\n-            Some(PeekMut {\n-                heap: self,\n-                sift: true,\n-            })\n-        }\n+        if self.is_empty() { None } else { Some(PeekMut { heap: self, sift: true }) }\n     }\n \n     /// Removes the greatest item from the binary heap and returns it, or `None` if it\n@@ -674,9 +665,7 @@ impl<T: Ord> BinaryHeap<T> {\n     #[inline]\n     #[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n     pub fn drain_sorted(&mut self) -> DrainSorted<'_, T> {\n-        DrainSorted {\n-            inner: self,\n-        }\n+        DrainSorted { inner: self }\n     }\n }\n \n@@ -718,9 +707,7 @@ impl<T> BinaryHeap<T> {\n     /// ```\n     #[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n     pub fn into_iter_sorted(self) -> IntoIterSorted<T> {\n-        IntoIterSorted {\n-            inner: self,\n-        }\n+        IntoIterSorted { inner: self }\n     }\n \n     /// Returns the greatest item in the binary heap, or `None` if it is empty.\n@@ -857,7 +844,7 @@ impl<T> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"56431\")]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n         self.data.shrink_to(min_capacity)\n     }\n@@ -991,11 +978,7 @@ impl<'a, T> Hole<'a, T> {\n         debug_assert!(pos < data.len());\n         // SAFE: pos should be inside the slice\n         let elt = ptr::read(data.get_unchecked(pos));\n-        Hole {\n-            data,\n-            elt: ManuallyDrop::new(elt),\n-            pos,\n-        }\n+        Hole { data, elt: ManuallyDrop::new(elt), pos }\n     }\n \n     #[inline]\n@@ -1059,9 +1042,7 @@ pub struct Iter<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Iter\")\n-         .field(&self.iter.as_slice())\n-         .finish()\n+        f.debug_tuple(\"Iter\").field(&self.iter.as_slice()).finish()\n     }\n }\n \n@@ -1127,9 +1108,7 @@ pub struct IntoIter<T> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"IntoIter\")\n-         .field(&self.iter.as_slice())\n-         .finish()\n+        f.debug_tuple(\"IntoIter\").field(&self.iter.as_slice()).finish()\n     }\n }\n \n@@ -1281,7 +1260,7 @@ impl<T: Ord> Iterator for DrainSorted<'_, T> {\n }\n \n #[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n-impl<T: Ord> ExactSizeIterator for DrainSorted<'_, T> { }\n+impl<T: Ord> ExactSizeIterator for DrainSorted<'_, T> {}\n \n #[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n impl<T: Ord> FusedIterator for DrainSorted<'_, T> {}"}, {"sha": "7d0a862d79e48cde5112a316f87250836c7e25ca", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 167, "deletions": 204, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -2,17 +2,17 @@ use core::borrow::Borrow;\n use core::cmp::Ordering;\n use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n-use core::iter::{FromIterator, Peekable, FusedIterator};\n+use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::marker::PhantomData;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, RangeBounds};\n use core::{fmt, intrinsics, mem, ptr};\n \n-use super::node::{self, Handle, NodeRef, marker, InsertResult::*, ForceResult::*};\n+use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n use super::search::{self, SearchResult::*};\n \n-use UnderflowResult::*;\n use Entry::*;\n+use UnderflowResult::*;\n \n /// A map based on a B-Tree.\n ///\n@@ -138,16 +138,15 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for BTreeMap<K, V> {\n impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n     fn clone(&self) -> BTreeMap<K, V> {\n         fn clone_subtree<'a, K: Clone, V: Clone>(\n-            node: node::NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n+            node: node::NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>,\n         ) -> BTreeMap<K, V>\n-        where K: 'a, V: 'a,\n+        where\n+            K: 'a,\n+            V: 'a,\n         {\n             match node.force() {\n                 Leaf(leaf) => {\n-                    let mut out_tree = BTreeMap {\n-                        root: node::Root::new_leaf(),\n-                        length: 0,\n-                    };\n+                    let mut out_tree = BTreeMap { root: node::Root::new_leaf(), length: 0 };\n \n                     {\n                         let mut out_node = match out_tree.root.as_mut().force() {\n@@ -203,19 +202,17 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n         if self.is_empty() {\n             // Ideally we'd call `BTreeMap::new` here, but that has the `K:\n             // Ord` constraint, which this method lacks.\n-            BTreeMap {\n-                root: node::Root::shared_empty_root(),\n-                length: 0,\n-            }\n+            BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n         } else {\n             clone_subtree(self.root.as_ref())\n         }\n     }\n }\n \n impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n-    where K: Borrow<Q> + Ord,\n-          Q: Ord\n+where\n+    K: Borrow<Q> + Ord,\n+    Q: Ord,\n {\n     type Key = K;\n \n@@ -228,15 +225,11 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n         match search::search_tree(self.root.as_mut(), key) {\n-            Found(handle) => {\n-                Some(OccupiedEntry {\n-                         handle,\n-                         length: &mut self.length,\n-                         _marker: PhantomData,\n-                     }\n-                     .remove_kv()\n-                     .0)\n-            }\n+            Found(handle) => Some(\n+                OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n+                    .remove_kv()\n+                    .0,\n+            ),\n             GoDown(_) => None,\n         }\n     }\n@@ -246,13 +239,8 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n         match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut(), &key) {\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n-                VacantEntry {\n-                    key,\n-                    handle,\n-                    length: &mut self.length,\n-                    _marker: PhantomData,\n-                }\n-                .insert(());\n+                VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData }\n+                    .insert(());\n                 None\n             }\n         }\n@@ -310,10 +298,7 @@ pub struct IntoIter<K, V> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let range = Range {\n-            front: self.front.reborrow(),\n-            back: self.back.reborrow(),\n-        };\n+        let range = Range { front: self.front.reborrow(), back: self.back.reborrow() };\n         f.debug_list().entries(range).finish()\n     }\n }\n@@ -408,10 +393,7 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let range = Range {\n-            front: self.front.reborrow(),\n-            back: self.back.reborrow(),\n-        };\n+        let range = Range { front: self.front.reborrow(), back: self.back.reborrow() };\n         f.debug_list().entries(range).finish()\n     }\n }\n@@ -426,25 +408,19 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// A vacant entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-           VacantEntry<'a, K, V>),\n+    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n \n     /// An occupied entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-             OccupiedEntry<'a, K, V>),\n+    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n }\n \n-#[stable(feature= \"debug_btree_map\", since = \"1.12.0\")]\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            Vacant(ref v) => f.debug_tuple(\"Entry\")\n-                              .field(v)\n-                              .finish(),\n-            Occupied(ref o) => f.debug_tuple(\"Entry\")\n-                                .field(o)\n-                                .finish(),\n+            Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n+            Occupied(ref o) => f.debug_tuple(\"Entry\").field(o).finish(),\n         }\n     }\n }\n@@ -463,12 +439,10 @@ pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     _marker: PhantomData<&'a mut (K, V)>,\n }\n \n-#[stable(feature= \"debug_btree_map\", since = \"1.12.0\")]\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n impl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"VacantEntry\")\n-         .field(self.key())\n-         .finish()\n+        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n     }\n }\n \n@@ -486,13 +460,10 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     _marker: PhantomData<&'a mut (K, V)>,\n }\n \n-#[stable(feature= \"debug_btree_map\", since = \"1.12.0\")]\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n impl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"OccupiedEntry\")\n-         .field(\"key\", self.key())\n-         .field(\"value\", self.get())\n-         .finish()\n+        f.debug_struct(\"OccupiedEntry\").field(\"key\", self.key()).field(\"value\", self.get()).finish()\n     }\n }\n \n@@ -519,10 +490,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeMap<K, V> {\n-        BTreeMap {\n-            root: node::Root::shared_empty_root(),\n-            length: 0,\n-        }\n+        BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n     }\n \n     /// Clears the map, removing all values.\n@@ -563,8 +531,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n-        where K: Borrow<Q>,\n-              Q: Ord\n+    where\n+        K: Borrow<Q>,\n+        Q: Ord,\n     {\n         match search::search_tree(self.root.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().1),\n@@ -589,8 +558,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n     pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n-        where K: Borrow<Q>,\n-              Q: Ord\n+    where\n+        K: Borrow<Q>,\n+        Q: Ord,\n     {\n         match search::search_tree(self.root.as_ref(), k) {\n             Found(handle) => Some(handle.into_kv()),\n@@ -617,7 +587,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn first_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n-        where T: Ord, K: Borrow<T>\n+    where\n+        T: Ord,\n+        K: Borrow<T>,\n     {\n         let front = first_leaf_edge(self.root.as_ref());\n         front.right_kv().ok().map(Handle::into_kv)\n@@ -644,15 +616,17 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn first_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n-        where T: Ord, K: Borrow<T>\n+    where\n+        T: Ord,\n+        K: Borrow<T>,\n     {\n         match self.length {\n             0 => None,\n             _ => Some(OccupiedEntry {\n-                          handle: self.root.as_mut().first_kv(),\n-                          length: &mut self.length,\n-                          _marker: PhantomData,\n-                      }),\n+                handle: self.root.as_mut().first_kv(),\n+                length: &mut self.length,\n+                _marker: PhantomData,\n+            }),\n         }\n     }\n \n@@ -674,7 +648,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn last_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n-        where T: Ord, K: Borrow<T>\n+    where\n+        T: Ord,\n+        K: Borrow<T>,\n     {\n         let back = last_leaf_edge(self.root.as_ref());\n         back.left_kv().ok().map(Handle::into_kv)\n@@ -701,15 +677,17 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn last_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n-        where T: Ord, K: Borrow<T>\n+    where\n+        T: Ord,\n+        K: Borrow<T>,\n     {\n         match self.length {\n             0 => None,\n             _ => Some(OccupiedEntry {\n-                          handle: self.root.as_mut().last_kv(),\n-                          length: &mut self.length,\n-                          _marker: PhantomData,\n-                      }),\n+                handle: self.root.as_mut().last_kv(),\n+                length: &mut self.length,\n+                _marker: PhantomData,\n+            }),\n         }\n     }\n \n@@ -732,8 +710,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n-        where K: Borrow<Q>,\n-              Q: Ord\n+    where\n+        K: Borrow<Q>,\n+        Q: Ord,\n     {\n         self.get(key).is_some()\n     }\n@@ -760,8 +739,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n-        where K: Borrow<Q>,\n-              Q: Ord\n+    where\n+        K: Borrow<Q>,\n+        Q: Ord,\n     {\n         match search::search_tree(self.root.as_mut(), key) {\n             Found(handle) => Some(handle.into_kv_mut().1),\n@@ -826,18 +806,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n-        where K: Borrow<Q>,\n-              Q: Ord\n+    where\n+        K: Borrow<Q>,\n+        Q: Ord,\n     {\n         match search::search_tree(self.root.as_mut(), key) {\n-            Found(handle) => {\n-                Some(OccupiedEntry {\n-                         handle,\n-                         length: &mut self.length,\n-                         _marker: PhantomData,\n-                     }\n-                     .remove())\n-            }\n+            Found(handle) => Some(\n+                OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }.remove(),\n+            ),\n             GoDown(_) => None,\n         }\n     }\n@@ -886,10 +862,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         // First, we merge `self` and `other` into a sorted sequence in linear time.\n         let self_iter = mem::take(self).into_iter();\n         let other_iter = mem::take(other).into_iter();\n-        let iter = MergeIter {\n-            left: self_iter.peekable(),\n-            right: other_iter.peekable(),\n-        };\n+        let iter = MergeIter { left: self_iter.peekable(), right: other_iter.peekable() };\n \n         // Second, we build a tree from the sorted sequence in linear time.\n         self.from_sorted_iter(iter);\n@@ -927,13 +900,16 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range<T: ?Sized, R>(&self, range: R) -> Range<'_, K, V>\n-        where T: Ord, K: Borrow<T>, R: RangeBounds<T>\n+    where\n+        T: Ord,\n+        K: Borrow<T>,\n+        R: RangeBounds<T>,\n     {\n         let root1 = self.root.as_ref();\n         let root2 = self.root.as_ref();\n         let (f, b) = range_search(root1, root2, range);\n \n-        Range { front: f, back: b}\n+        Range { front: f, back: b }\n     }\n \n     /// Constructs a mutable double-ended iterator over a sub-range of elements in the map.\n@@ -968,17 +944,16 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<'_, K, V>\n-        where T: Ord, K: Borrow<T>, R: RangeBounds<T>\n+    where\n+        T: Ord,\n+        K: Borrow<T>,\n+        R: RangeBounds<T>,\n     {\n         let root1 = self.root.as_mut();\n         let root2 = unsafe { ptr::read(&root1) };\n         let (f, b) = range_search(root1, root2, range);\n \n-        RangeMut {\n-            front: f,\n-            back: b,\n-            _marker: PhantomData,\n-        }\n+        RangeMut { front: f, back: b, _marker: PhantomData }\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n@@ -1005,19 +980,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.ensure_root_is_owned();\n         match search::search_tree(self.root.as_mut(), &key) {\n             Found(handle) => {\n-                Occupied(OccupiedEntry {\n-                    handle,\n-                    length: &mut self.length,\n-                    _marker: PhantomData,\n-                })\n+                Occupied(OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData })\n             }\n             GoDown(handle) => {\n-                Vacant(VacantEntry {\n-                    key,\n-                    handle,\n-                    length: &mut self.length,\n-                    _marker: PhantomData,\n-                })\n+                Vacant(VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData })\n             }\n         }\n     }\n@@ -1124,7 +1090,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n-        where K: Borrow<Q>\n+    where\n+        K: Borrow<Q>,\n     {\n         if self.is_empty() {\n             return Self::new();\n@@ -1182,10 +1149,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Calculates the number of elements if it is incorrect.\n     fn recalc_length(&mut self) {\n-        fn dfs<'a, K, V>(\n-            node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n-        ) -> usize\n-        where K: 'a, V: 'a\n+        fn dfs<'a, K, V>(node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>) -> usize\n+        where\n+            K: 'a,\n+            V: 'a,\n         {\n             let mut res = node.len();\n \n@@ -1338,10 +1305,7 @@ impl<K, V> ExactSizeIterator for Iter<'_, K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Clone for Iter<'_, K, V> {\n     fn clone(&self) -> Self {\n-        Iter {\n-            range: self.range.clone(),\n-            length: self.length,\n-        }\n+        Iter { range: self.range.clone(), length: self.length }\n     }\n }\n \n@@ -1410,11 +1374,7 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n         let len = self.length;\n         mem::forget(self);\n \n-        IntoIter {\n-            front: first_leaf_edge(root1),\n-            back: last_leaf_edge(root2),\n-            length: len,\n-        }\n+        IntoIter { front: first_leaf_edge(root1), back: last_leaf_edge(root2), length: len }\n     }\n }\n \n@@ -1619,11 +1579,7 @@ impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        if self.front == self.back {\n-            None\n-        } else {\n-            unsafe { Some(self.next_unchecked()) }\n-        }\n+        if self.front == self.back { None } else { unsafe { Some(self.next_unchecked()) } }\n     }\n \n     fn last(mut self) -> Option<(&'a K, &'a V)> {\n@@ -1700,11 +1656,7 @@ impl<'a, K, V> Range<'a, K, V> {\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n-        if self.front == self.back {\n-            None\n-        } else {\n-            unsafe { Some(self.next_back_unchecked()) }\n-        }\n+        if self.front == self.back { None } else { unsafe { Some(self.next_back_unchecked()) } }\n     }\n }\n \n@@ -1746,10 +1698,7 @@ impl<K, V> FusedIterator for Range<'_, K, V> {}\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<K, V> Clone for Range<'_, K, V> {\n     fn clone(&self) -> Self {\n-        Range {\n-            front: self.front,\n-            back: self.back,\n-        }\n+        Range { front: self.front, back: self.back }\n     }\n }\n \n@@ -1758,11 +1707,7 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.front == self.back {\n-            None\n-        } else {\n-            unsafe { Some(self.next_unchecked()) }\n-        }\n+        if self.front == self.back { None } else { unsafe { Some(self.next_unchecked()) } }\n     }\n \n     fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n@@ -1809,11 +1754,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.front == self.back {\n-            None\n-        } else {\n-            unsafe { Some(self.next_back_unchecked()) }\n-        }\n+        if self.front == self.back { None } else { unsafe { Some(self.next_back_unchecked()) } }\n     }\n }\n \n@@ -1934,8 +1875,9 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> Index<&Q> for BTreeMap<K, V>\n-    where K: Borrow<Q>,\n-          Q: Ord\n+where\n+    K: Borrow<Q>,\n+    Q: Ord,\n {\n     type Output = V;\n \n@@ -1950,9 +1892,9 @@ impl<K: Ord, Q: ?Sized, V> Index<&Q> for BTreeMap<K, V>\n     }\n }\n \n-fn first_leaf_edge<BorrowType, K, V>\n-    (mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>)\n-     -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+fn first_leaf_edge<BorrowType, K, V>(\n+    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     loop {\n         match node.force() {\n             Leaf(leaf) => return leaf.first_edge(),\n@@ -1963,9 +1905,9 @@ fn first_leaf_edge<BorrowType, K, V>\n     }\n }\n \n-fn last_leaf_edge<BorrowType, K, V>\n-    (mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>)\n-     -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+fn last_leaf_edge<BorrowType, K, V>(\n+    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     loop {\n         match node.force() {\n             Leaf(leaf) => return leaf.last_edge(),\n@@ -1979,20 +1921,28 @@ fn last_leaf_edge<BorrowType, K, V>\n fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    range: R\n-)-> (Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n-     Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>)\n-        where Q: Ord, K: Borrow<Q>\n+    range: R,\n+) -> (\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+)\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n {\n     match (range.start_bound(), range.end_bound()) {\n-        (Excluded(s), Excluded(e)) if s==e =>\n-            panic!(\"range start and end are equal and excluded in BTreeMap\"),\n-        (Included(s), Included(e)) |\n-        (Included(s), Excluded(e)) |\n-        (Excluded(s), Included(e)) |\n-        (Excluded(s), Excluded(e)) if s>e =>\n-            panic!(\"range start is greater than range end in BTreeMap\"),\n-        _ => {},\n+        (Excluded(s), Excluded(e)) if s == e => {\n+            panic!(\"range start and end are equal and excluded in BTreeMap\")\n+        }\n+        (Included(s), Included(e))\n+        | (Included(s), Excluded(e))\n+        | (Excluded(s), Included(e))\n+        | (Excluded(s), Excluded(e))\n+            if s > e =>\n+        {\n+            panic!(\"range start is greater than range end in BTreeMap\")\n+        }\n+        _ => {}\n     };\n \n     let mut min_node = root1;\n@@ -2004,11 +1954,17 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     loop {\n         let min_edge = match (min_found, range.start_bound()) {\n             (false, Included(key)) => match search::search_linear(&min_node, key) {\n-                (i, true) => { min_found = true; i },\n+                (i, true) => {\n+                    min_found = true;\n+                    i\n+                }\n                 (i, false) => i,\n             },\n             (false, Excluded(key)) => match search::search_linear(&min_node, key) {\n-                (i, true) => { min_found = true; i+1 },\n+                (i, true) => {\n+                    min_found = true;\n+                    i + 1\n+                }\n                 (i, false) => i,\n             },\n             (_, Unbounded) => 0,\n@@ -2018,11 +1974,17 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n \n         let max_edge = match (max_found, range.end_bound()) {\n             (false, Included(key)) => match search::search_linear(&max_node, key) {\n-                (i, true) => { max_found = true; i+1 },\n+                (i, true) => {\n+                    max_found = true;\n+                    i + 1\n+                }\n                 (i, false) => i,\n             },\n             (false, Excluded(key)) => match search::search_linear(&max_node, key) {\n-                (i, true) => { max_found = true; i },\n+                (i, true) => {\n+                    max_found = true;\n+                    i\n+                }\n                 (i, false) => i,\n             },\n             (_, Unbounded) => max_node.keys().len(),\n@@ -2031,20 +1993,24 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n         };\n \n         if !diverged {\n-            if max_edge < min_edge { panic!(\"Ord is ill-defined in BTreeMap range\") }\n-            if min_edge != max_edge { diverged = true; }\n+            if max_edge < min_edge {\n+                panic!(\"Ord is ill-defined in BTreeMap range\")\n+            }\n+            if min_edge != max_edge {\n+                diverged = true;\n+            }\n         }\n \n         let front = Handle::new_edge(min_node, min_edge);\n         let back = Handle::new_edge(max_node, max_edge);\n         match (front.force(), back.force()) {\n             (Leaf(f), Leaf(b)) => {\n                 return (f, b);\n-            },\n+            }\n             (Internal(min_int), Internal(max_int)) => {\n                 min_node = min_int.descend();\n                 max_node = max_int.descend();\n-            },\n+            }\n             _ => unreachable!(\"BTreeMap has different depths\"),\n         };\n     }\n@@ -2321,13 +2287,14 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n     pub fn and_modify<F>(self, f: F) -> Self\n-        where F: FnOnce(&mut V)\n+    where\n+        F: FnOnce(&mut V),\n     {\n         match self {\n             Occupied(mut entry) => {\n                 f(entry.get_mut());\n                 Occupied(entry)\n-            },\n+            }\n             Vacant(entry) => Vacant(entry),\n         }\n     }\n@@ -2354,7 +2321,6 @@ impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n             Vacant(entry) => entry.insert(Default::default()),\n         }\n     }\n-\n }\n \n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n@@ -2433,17 +2399,15 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n \n         loop {\n             match cur_parent {\n-                Ok(parent) => {\n-                    match parent.insert(ins_k, ins_v, ins_edge) {\n-                        Fit(_) => return unsafe { &mut *out_ptr },\n-                        Split(left, k, v, right) => {\n-                            ins_k = k;\n-                            ins_v = v;\n-                            ins_edge = right;\n-                            cur_parent = left.ascend().map_err(|n| n.into_root_mut());\n-                        }\n+                Ok(parent) => match parent.insert(ins_k, ins_v, ins_edge) {\n+                    Fit(_) => return unsafe { &mut *out_ptr },\n+                    Split(left, k, v, right) => {\n+                        ins_k = k;\n+                        ins_v = v;\n+                        ins_edge = right;\n+                        cur_parent = left.ascend().map_err(|n| n.into_root_mut());\n                     }\n-                }\n+                },\n                 Err(root) => {\n                     root.push_level().push(ins_k, ins_v, ins_edge);\n                     return unsafe { &mut *out_ptr };\n@@ -2669,8 +2633,9 @@ enum UnderflowResult<'a, K, V> {\n     Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n }\n \n-fn handle_underfull_node<K, V>(node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>)\n-                               -> UnderflowResult<'_, K, V> {\n+fn handle_underfull_node<K, V>(\n+    node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>,\n+) -> UnderflowResult<'_, K, V> {\n     let parent = if let Ok(parent) = node.ascend() {\n         parent\n     } else {\n@@ -2679,14 +2644,12 @@ fn handle_underfull_node<K, V>(node: NodeRef<marker::Mut<'_>, K, V, marker::Leaf\n \n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n-        Err(parent) => {\n-            match parent.right_kv() {\n-                Ok(right) => (false, right),\n-                Err(parent) => {\n-                    return EmptyParent(parent.into_node());\n-                }\n+        Err(parent) => match parent.right_kv() {\n+            Ok(right) => (false, right),\n+            Err(parent) => {\n+                return EmptyParent(parent.into_node());\n             }\n-        }\n+        },\n     };\n \n     if handle.can_merge() {"}, {"sha": "53c2c29a9b659db76ba7915b6964bf8d86711398", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 224, "deletions": 392, "changes": 616, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -33,10 +33,10 @@\n \n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n-use core::ptr::{self, Unique, NonNull};\n+use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{Global, Alloc, Layout};\n+use crate::alloc::{Alloc, Global, Layout};\n use crate::boxed::Box;\n \n const B: usize = 6;\n@@ -110,7 +110,7 @@ impl<K, V> LeafNode<K, V> {\n             vals: [MaybeUninit::UNINIT; CAPACITY],\n             parent: ptr::null(),\n             parent_idx: MaybeUninit::uninit(),\n-            len: 0\n+            len: 0,\n         }\n     }\n }\n@@ -127,12 +127,8 @@ unsafe impl Sync for NodeHeader<(), ()> {}\n // An empty node used as a placeholder for the root node, to avoid allocations.\n // We use just a header in order to save space, since no operation on an empty tree will\n // ever take a pointer past the first key.\n-static EMPTY_ROOT_NODE: NodeHeader<(), ()> = NodeHeader {\n-    parent: ptr::null(),\n-    parent_idx: MaybeUninit::uninit(),\n-    len: 0,\n-    keys_start: [],\n-};\n+static EMPTY_ROOT_NODE: NodeHeader<(), ()> =\n+    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0, keys_start: [] };\n \n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n /// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n@@ -157,10 +153,7 @@ impl<K, V> InternalNode<K, V> {\n     /// `len` of 0), there must be one initialized and valid edge. This function does not set up\n     /// such an edge.\n     unsafe fn new() -> Self {\n-        InternalNode {\n-            data: LeafNode::new(),\n-            edges: [MaybeUninit::UNINIT; 2*B]\n-        }\n+        InternalNode { data: LeafNode::new(), edges: [MaybeUninit::UNINIT; 2 * B] }\n     }\n }\n \n@@ -169,7 +162,7 @@ impl<K, V> InternalNode<K, V> {\n /// of nodes is actually behind the box, and, partially due to this lack of information, has no\n /// destructor.\n struct BoxedNode<K, V> {\n-    ptr: Unique<LeafNode<K, V>>\n+    ptr: Unique<LeafNode<K, V>>,\n }\n \n impl<K, V> BoxedNode<K, V> {\n@@ -196,11 +189,11 @@ impl<K, V> BoxedNode<K, V> {\n /// and must be cleaned up manually.\n pub struct Root<K, V> {\n     node: BoxedNode<K, V>,\n-    height: usize\n+    height: usize,\n }\n \n-unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> { }\n-unsafe impl<K: Send, V: Send> Send for Root<K, V> { }\n+unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> {}\n+unsafe impl<K: Send, V: Send> Send for Root<K, V> {}\n \n impl<K, V> Root<K, V> {\n     pub fn is_shared_root(&self) -> bool {\n@@ -211,22 +204,18 @@ impl<K, V> Root<K, V> {\n         Root {\n             node: unsafe {\n                 BoxedNode::from_ptr(NonNull::new_unchecked(\n-                    &EMPTY_ROOT_NODE as *const _ as *const LeafNode<K, V> as *mut _\n+                    &EMPTY_ROOT_NODE as *const _ as *const LeafNode<K, V> as *mut _,\n                 ))\n             },\n             height: 0,\n         }\n     }\n \n     pub fn new_leaf() -> Self {\n-        Root {\n-            node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })),\n-            height: 0\n-        }\n+        Root { node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })), height: 0 }\n     }\n \n-    pub fn as_ref(&self)\n-            -> NodeRef<marker::Immut<'_>, K, V, marker::LeafOrInternal> {\n+    pub fn as_ref(&self) -> NodeRef<marker::Immut<'_>, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n@@ -235,8 +224,7 @@ impl<K, V> Root<K, V> {\n         }\n     }\n \n-    pub fn as_mut(&mut self)\n-            -> NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal> {\n+    pub fn as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n@@ -245,8 +233,7 @@ impl<K, V> Root<K, V> {\n         }\n     }\n \n-    pub fn into_ref(self)\n-            -> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n+    pub fn into_ref(self) -> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n@@ -257,8 +244,7 @@ impl<K, V> Root<K, V> {\n \n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n     /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n-    pub fn push_level(&mut self)\n-            -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n+    pub fn push_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         debug_assert!(!self.is_shared_root());\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n@@ -270,7 +256,7 @@ impl<K, V> Root<K, V> {\n             height: self.height,\n             node: self.node.as_ptr(),\n             root: self as *mut _,\n-            _marker: PhantomData\n+            _marker: PhantomData,\n         };\n \n         unsafe {\n@@ -290,14 +276,14 @@ impl<K, V> Root<K, V> {\n         let top = self.node.ptr;\n \n         self.node = unsafe {\n-            BoxedNode::from_ptr(self.as_mut()\n-                                    .cast_unchecked::<marker::Internal>()\n-                                    .first_edge()\n-                                    .descend()\n-                                    .node)\n+            BoxedNode::from_ptr(\n+                self.as_mut().cast_unchecked::<marker::Internal>().first_edge().descend().node,\n+            )\n         };\n         self.height -= 1;\n-        unsafe { (*self.as_mut().as_leaf_mut()).parent = ptr::null(); }\n+        unsafe {\n+            (*self.as_mut().as_leaf_mut()).parent = ptr::null();\n+        }\n \n         unsafe {\n             Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n@@ -332,43 +318,34 @@ pub struct NodeRef<BorrowType, K, V, Type> {\n     node: NonNull<LeafNode<K, V>>,\n     // This is null unless the borrow type is `Mut`\n     root: *const Root<K, V>,\n-    _marker: PhantomData<(BorrowType, Type)>\n+    _marker: PhantomData<(BorrowType, Type)>,\n }\n \n-impl<'a, K: 'a, V: 'a, Type> Copy for NodeRef<marker::Immut<'a>, K, V, Type> { }\n+impl<'a, K: 'a, V: 'a, Type> Copy for NodeRef<marker::Immut<'a>, K, V, Type> {}\n impl<'a, K: 'a, V: 'a, Type> Clone for NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-unsafe impl<BorrowType, K: Sync, V: Sync, Type> Sync\n-    for NodeRef<BorrowType, K, V, Type> { }\n+unsafe impl<BorrowType, K: Sync, V: Sync, Type> Sync for NodeRef<BorrowType, K, V, Type> {}\n \n-unsafe impl<'a, K: Sync + 'a, V: Sync + 'a, Type> Send\n-   for NodeRef<marker::Immut<'a>, K, V, Type> { }\n-unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send\n-   for NodeRef<marker::Mut<'a>, K, V, Type> { }\n-unsafe impl<K: Send, V: Send, Type> Send\n-   for NodeRef<marker::Owned, K, V, Type> { }\n+unsafe impl<'a, K: Sync + 'a, V: Sync + 'a, Type> Send for NodeRef<marker::Immut<'a>, K, V, Type> {}\n+unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::Mut<'a>, K, V, Type> {}\n+unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type> {}\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     fn as_internal(&self) -> &InternalNode<K, V> {\n-        unsafe {\n-            &*(self.node.as_ptr() as *mut InternalNode<K, V>)\n-        }\n+        unsafe { &*(self.node.as_ptr() as *mut InternalNode<K, V>) }\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n-        unsafe {\n-            &mut *(self.node.as_ptr() as *mut InternalNode<K, V>)\n-        }\n+        unsafe { &mut *(self.node.as_ptr() as *mut InternalNode<K, V>) }\n     }\n }\n \n-\n impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the length of the node. This is the number of keys or values. In an\n     /// internal node, the number of edges is `len() + 1`.\n@@ -385,22 +362,12 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Removes any static information about whether this node is a `Leaf` or an\n     /// `Internal` node.\n     pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-        NodeRef {\n-            height: self.height,\n-            node: self.node,\n-            root: self.root,\n-            _marker: PhantomData\n-        }\n+        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n     /// Temporarily takes out another, immutable reference to the same node.\n     fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n-        NodeRef {\n-            height: self.height,\n-            node: self.node,\n-            root: self.root,\n-            _marker: PhantomData\n-        }\n+        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n     /// Assert that this is indeed a proper leaf node, and not the shared root.\n@@ -409,9 +376,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     fn as_header(&self) -> &NodeHeader<K, V> {\n-        unsafe {\n-            &*(self.node.as_ptr() as *const NodeHeader<K, V>)\n-        }\n+        unsafe { &*(self.node.as_ptr() as *const NodeHeader<K, V>) }\n     }\n \n     pub fn is_shared_root(&self) -> bool {\n@@ -433,28 +398,20 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     ///\n     /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n     /// both, upon success, do nothing.\n-    pub fn ascend(self) -> Result<\n-        Handle<\n-            NodeRef<\n-                BorrowType,\n-                K, V,\n-                marker::Internal\n-            >,\n-            marker::Edge\n-        >,\n-        Self\n-    > {\n+    pub fn ascend(\n+        self,\n+    ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {\n         let parent_as_leaf = self.as_header().parent as *const LeafNode<K, V>;\n         if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n                     height: self.height + 1,\n                     node: non_zero,\n                     root: self.root,\n-                    _marker: PhantomData\n+                    _marker: PhantomData,\n                 },\n                 idx: unsafe { usize::from(*self.as_header().parent_idx.as_ptr()) },\n-                _marker: PhantomData\n+                _marker: PhantomData,\n             })\n         } else {\n             Err(self)\n@@ -488,16 +445,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n     /// Similar to `ascend`, gets a reference to a node's parent node, but also\n     /// deallocate the current node in the process. This is unsafe because the\n     /// current node will still be accessible despite being deallocated.\n-    pub unsafe fn deallocate_and_ascend(self) -> Option<\n-        Handle<\n-            NodeRef<\n-                marker::Owned,\n-                K, V,\n-                marker::Internal\n-            >,\n-            marker::Edge\n-        >\n-    > {\n+    pub unsafe fn deallocate_and_ascend(\n+        self,\n+    ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n         debug_assert!(!self.is_shared_root());\n         let node = self.node;\n         let ret = self.ascend().ok();\n@@ -510,16 +460,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n     /// Similar to `ascend`, gets a reference to a node's parent node, but also\n     /// deallocate the current node in the process. This is unsafe because the\n     /// current node will still be accessible despite being deallocated.\n-    pub unsafe fn deallocate_and_ascend(self) -> Option<\n-        Handle<\n-            NodeRef<\n-                marker::Owned,\n-                K, V,\n-                marker::Internal\n-            >,\n-            marker::Edge\n-        >\n-    > {\n+    pub unsafe fn deallocate_and_ascend(\n+        self,\n+    ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n         let node = self.node;\n         let ret = self.ascend().ok();\n         Global.dealloc(node.cast(), Layout::new::<InternalNode<K, V>>());\n@@ -530,15 +473,8 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// Unsafely asserts to the compiler some static information about whether this\n     /// node is a `Leaf`.\n-    unsafe fn cast_unchecked<NewType>(&mut self)\n-            -> NodeRef<marker::Mut<'_>, K, V, NewType> {\n-\n-        NodeRef {\n-            height: self.height,\n-            node: self.node,\n-            root: self.root,\n-            _marker: PhantomData\n-        }\n+    unsafe fn cast_unchecked<NewType>(&mut self) -> NodeRef<marker::Mut<'_>, K, V, NewType> {\n+        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n     /// Temporarily takes out another, mutable reference to the same node. Beware, as\n@@ -552,12 +488,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n     // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n     unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {\n-        NodeRef {\n-            height: self.height,\n-            node: self.node,\n-            root: self.root,\n-            _marker: PhantomData\n-        }\n+        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n     /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n@@ -612,21 +543,14 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n             assert!(mem::size_of::<NodeHeader<K, V>>() == mem::size_of::<NodeHeader<K, V, K>>());\n             let header = self.as_header() as *const _ as *const NodeHeader<K, V, K>;\n             let keys = unsafe { &(*header).keys_start as *const _ as *const K };\n-            unsafe {\n-                slice::from_raw_parts(keys, self.len())\n-            }\n+            unsafe { slice::from_raw_parts(keys, self.len()) }\n         }\n     }\n \n     fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n         // We cannot be the root, so `as_leaf` is okay\n-        unsafe {\n-            slice::from_raw_parts(\n-                MaybeUninit::first_ptr(&self.as_leaf().vals),\n-                self.len()\n-            )\n-        }\n+        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n \n     fn into_slices(self) -> (&'a [K], &'a [V]) {\n@@ -639,9 +563,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// Gets a mutable reference to the root itself. This is useful primarily when the\n     /// height of the tree needs to be adjusted. Never call this on a reborrowed pointer.\n     pub fn into_root_mut(self) -> &'a mut Root<K, V> {\n-        unsafe {\n-            &mut *(self.root as *mut Root<K, V>)\n-        }\n+        unsafe { &mut *(self.root as *mut Root<K, V>) }\n     }\n \n     fn into_key_slice_mut(mut self) -> &'a mut [K] {\n@@ -653,7 +575,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n             unsafe {\n                 slice::from_raw_parts_mut(\n                     MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n-                    self.len()\n+                    self.len(),\n                 )\n             }\n         }\n@@ -664,7 +586,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe {\n             slice::from_raw_parts_mut(\n                 MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n-                self.len()\n+                self.len(),\n             )\n         }\n     }\n@@ -679,14 +601,10 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe {\n             let len = self.len();\n             let leaf = self.as_leaf_mut();\n-            let keys = slice::from_raw_parts_mut(\n-                MaybeUninit::first_ptr_mut(&mut (*leaf).keys),\n-                len\n-            );\n-            let vals = slice::from_raw_parts_mut(\n-                MaybeUninit::first_ptr_mut(&mut (*leaf).vals),\n-                len\n-            );\n+            let keys =\n+                slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len);\n+            let vals =\n+                slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len);\n             (keys, vals)\n         }\n     }\n@@ -769,10 +687,10 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n             slice_insert(\n                 slice::from_raw_parts_mut(\n                     MaybeUninit::first_ptr_mut(&mut self.as_internal_mut().edges),\n-                    self.len()+1\n+                    self.len() + 1,\n                 ),\n                 0,\n-                edge.node\n+                edge.node,\n             );\n \n             (*self.as_leaf_mut()).len += 1;\n@@ -797,9 +715,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(internal) => {\n-                    let edge = ptr::read(\n-                        internal.as_internal().edges.get_unchecked(idx + 1).as_ptr()\n-                    );\n+                    let edge =\n+                        ptr::read(internal.as_internal().edges.get_unchecked(idx + 1).as_ptr());\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n                     (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n                     Some(new_root)\n@@ -828,9 +745,9 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                     let edge = slice_remove(\n                         slice::from_raw_parts_mut(\n                             MaybeUninit::first_ptr_mut(&mut internal.as_internal_mut().edges),\n-                            old_len+1\n+                            old_len + 1,\n                         ),\n-                        0\n+                        0,\n                     );\n \n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n@@ -851,32 +768,31 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     }\n \n     fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n-        (\n-            self.keys_mut().as_mut_ptr(),\n-            self.vals_mut().as_mut_ptr()\n-        )\n+        (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n     }\n }\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     /// Checks whether a node is an `Internal` node or a `Leaf` node.\n-    pub fn force(self) -> ForceResult<\n+    pub fn force(\n+        self,\n+    ) -> ForceResult<\n         NodeRef<BorrowType, K, V, marker::Leaf>,\n-        NodeRef<BorrowType, K, V, marker::Internal>\n+        NodeRef<BorrowType, K, V, marker::Internal>,\n     > {\n         if self.height == 0 {\n             ForceResult::Leaf(NodeRef {\n                 height: self.height,\n                 node: self.node,\n                 root: self.root,\n-                _marker: PhantomData\n+                _marker: PhantomData,\n             })\n         } else {\n             ForceResult::Internal(NodeRef {\n                 height: self.height,\n                 node: self.node,\n                 root: self.root,\n-                _marker: PhantomData\n+                _marker: PhantomData,\n             })\n         }\n     }\n@@ -893,10 +809,10 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n pub struct Handle<Node, Type> {\n     node: Node,\n     idx: usize,\n-    _marker: PhantomData<Type>\n+    _marker: PhantomData<Type>,\n }\n \n-impl<Node: Copy, Type> Copy for Handle<Node, Type> { }\n+impl<Node: Copy, Type> Copy for Handle<Node, Type> {}\n // We don't need the full generality of `#[derive(Clone)]`, as the only time `Node` will be\n // `Clone`able is when it is an immutable reference and therefore `Copy`.\n impl<Node: Copy, Type> Clone for Handle<Node, Type> {\n@@ -918,11 +834,7 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n         // Necessary for correctness, but in a private module\n         debug_assert!(idx < node.len());\n \n-        Handle {\n-            node,\n-            idx,\n-            _marker: PhantomData\n-        }\n+        Handle { node, idx, _marker: PhantomData }\n     }\n \n     pub fn left_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n@@ -935,32 +847,24 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n }\n \n impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n-        for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType> {\n-\n+    for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n+{\n     fn eq(&self, other: &Self) -> bool {\n         self.node.node == other.node.node && self.idx == other.idx\n     }\n }\n \n impl<BorrowType, K, V, NodeType, HandleType>\n-        Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType> {\n-\n+    Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n+{\n     /// Temporarily takes out another, immutable handle on the same location.\n-    pub fn reborrow(&self)\n-            -> Handle<NodeRef<marker::Immut<'_>, K, V, NodeType>, HandleType> {\n-\n+    pub fn reborrow(&self) -> Handle<NodeRef<marker::Immut<'_>, K, V, NodeType>, HandleType> {\n         // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n-        Handle {\n-            node: self.node.reborrow(),\n-            idx: self.idx,\n-            _marker: PhantomData\n-        }\n+        Handle { node: self.node.reborrow(), idx: self.idx, _marker: PhantomData }\n     }\n }\n \n-impl<'a, K, V, NodeType, HandleType>\n-        Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n-\n+impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n     /// Temporarily takes out another, mutable handle on the same location. Beware, as\n     /// this method is very dangerous, doubly so since it may not immediately appear\n     /// dangerous.\n@@ -971,52 +875,30 @@ impl<'a, K, V, NodeType, HandleType>\n     /// of a reborrowed handle, out of bounds.\n     // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n     // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n-    pub unsafe fn reborrow_mut(&mut self)\n-            -> Handle<NodeRef<marker::Mut<'_>, K, V, NodeType>, HandleType> {\n-\n+    pub unsafe fn reborrow_mut(\n+        &mut self,\n+    ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NodeType>, HandleType> {\n         // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n-        Handle {\n-            node: self.node.reborrow_mut(),\n-            idx: self.idx,\n-            _marker: PhantomData\n-        }\n+        Handle { node: self.node.reborrow_mut(), idx: self.idx, _marker: PhantomData }\n     }\n }\n \n-impl<BorrowType, K, V, NodeType>\n-        Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n-\n+impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n     /// Creates a new handle to an edge in `node`. `idx` must be less than or equal to\n     /// `node.len()`.\n     pub fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         // Necessary for correctness, but in a private module\n         debug_assert!(idx <= node.len());\n \n-        Handle {\n-            node,\n-            idx,\n-            _marker: PhantomData\n-        }\n+        Handle { node, idx, _marker: PhantomData }\n     }\n \n-    pub fn left_kv(self)\n-            -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n-\n-        if self.idx > 0 {\n-            Ok(Handle::new_kv(self.node, self.idx - 1))\n-        } else {\n-            Err(self)\n-        }\n+    pub fn left_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n+        if self.idx > 0 { Ok(Handle::new_kv(self.node, self.idx - 1)) } else { Err(self) }\n     }\n \n-    pub fn right_kv(self)\n-            -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n-\n-        if self.idx < self.node.len() {\n-            Ok(Handle::new_kv(self.node, self.idx))\n-        } else {\n-            Err(self)\n-        }\n+    pub fn right_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n+        if self.idx < self.node.len() { Ok(Handle::new_kv(self.node, self.idx)) } else { Err(self) }\n     }\n }\n \n@@ -1045,25 +927,22 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// this edge. This method splits the node if there isn't enough room.\n     ///\n     /// The returned pointer points to the inserted value.\n-    pub fn insert(mut self, key: K, val: V)\n-            -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n-\n+    pub fn insert(mut self, key: K, val: V) -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n         if self.node.len() < CAPACITY {\n             let ptr = self.insert_fit(key, val);\n             (InsertResult::Fit(Handle::new_kv(self.node, self.idx)), ptr)\n         } else {\n             let middle = Handle::new_kv(self.node, B);\n             let (mut left, k, v, mut right) = middle.split();\n             let ptr = if self.idx <= B {\n-                unsafe {\n-                    Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val)\n-                }\n+                unsafe { Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val) }\n             } else {\n                 unsafe {\n                     Handle::new_edge(\n                         right.as_mut().cast_unchecked::<marker::Leaf>(),\n-                        self.idx - (B + 1)\n-                    ).insert_fit(key, val)\n+                        self.idx - (B + 1),\n+                    )\n+                    .insert_fit(key, val)\n                 }\n             };\n             (InsertResult::Split(left, k, v, right), ptr)\n@@ -1086,9 +965,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n     /// Unsafely asserts to the compiler some static information about whether the underlying\n     /// node of this handle is a `Leaf`.\n-    unsafe fn cast_unchecked<NewType>(&mut self)\n-            -> Handle<NodeRef<marker::Mut<'_>, K, V, NewType>, marker::Edge> {\n-\n+    unsafe fn cast_unchecked<NewType>(\n+        &mut self,\n+    ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NewType>, marker::Edge> {\n         Handle::new_edge(self.node.cast_unchecked(), self.idx)\n     }\n \n@@ -1107,13 +986,13 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             slice_insert(\n                 slice::from_raw_parts_mut(\n                     MaybeUninit::first_ptr_mut(&mut self.node.as_internal_mut().edges),\n-                    self.node.len()\n+                    self.node.len(),\n                 ),\n                 self.idx + 1,\n-                edge.node\n+                edge.node,\n             );\n \n-            for i in (self.idx+1)..(self.node.len()+1) {\n+            for i in (self.idx + 1)..(self.node.len() + 1) {\n                 Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n             }\n         }\n@@ -1122,9 +1001,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n     /// between this edge and the key/value pair to the right of this edge. This method splits\n     /// the node if there isn't enough room.\n-    pub fn insert(mut self, key: K, val: V, edge: Root<K, V>)\n-            -> InsertResult<'a, K, V, marker::Internal> {\n-\n+    pub fn insert(\n+        mut self,\n+        key: K,\n+        val: V,\n+        edge: Root<K, V>,\n+    ) -> InsertResult<'a, K, V, marker::Internal> {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.node.height - 1);\n \n@@ -1142,18 +1024,17 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 unsafe {\n                     Handle::new_edge(\n                         right.as_mut().cast_unchecked::<marker::Internal>(),\n-                        self.idx - (B + 1)\n-                    ).insert_fit(key, val, edge);\n+                        self.idx - (B + 1),\n+                    )\n+                    .insert_fit(key, val, edge);\n                 }\n             }\n             InsertResult::Split(left, k, v, right)\n         }\n     }\n }\n \n-impl<BorrowType, K, V>\n-        Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n-\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n     /// Finds the node pointed to by this edge.\n     ///\n     /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n@@ -1165,30 +1046,22 @@ impl<BorrowType, K, V>\n                 (&*self.node.as_internal().edges.get_unchecked(self.idx).as_ptr()).as_ptr()\n             },\n             root: self.node.root,\n-            _marker: PhantomData\n+            _marker: PhantomData,\n         }\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeType>\n-        Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n-\n+impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n         let (keys, vals) = self.node.into_slices();\n-        unsafe {\n-            (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx))\n-        }\n+        unsafe { (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx)) }\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeType>\n-        Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n-\n+impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n         let (keys, vals) = self.node.into_slices_mut();\n-        unsafe {\n-            (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx))\n-        }\n+        unsafe { (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx)) }\n     }\n }\n \n@@ -1209,8 +1082,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// - The key and value pointed to by this handle and extracted.\n     /// - All the key/value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n-    pub fn split(mut self)\n-            -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n+    pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n         debug_assert!(!self.node.is_shared_root());\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n@@ -1223,32 +1095,26 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n             ptr::copy_nonoverlapping(\n                 self.node.keys().as_ptr().add(self.idx + 1),\n                 new_node.keys.as_mut_ptr() as *mut K,\n-                new_len\n+                new_len,\n             );\n             ptr::copy_nonoverlapping(\n                 self.node.vals().as_ptr().add(self.idx + 1),\n                 new_node.vals.as_mut_ptr() as *mut V,\n-                new_len\n+                new_len,\n             );\n \n             (*self.node.as_leaf_mut()).len = self.idx as u16;\n             new_node.len = new_len as u16;\n \n-            (\n-                self.node,\n-                k, v,\n-                Root {\n-                    node: BoxedNode::from_leaf(new_node),\n-                    height: 0\n-                }\n-            )\n+            (self.node, k, v, Root { node: BoxedNode::from_leaf(new_node), height: 0 })\n         }\n     }\n \n     /// Removes the key/value pair pointed to by this handle, returning the edge between the\n     /// now adjacent key/value pairs to the left and right of this handle.\n-    pub fn remove(mut self)\n-            -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n+    pub fn remove(\n+        mut self,\n+    ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n         debug_assert!(!self.node.is_shared_root());\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n@@ -1267,8 +1133,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     /// - The key and value pointed to by this handle and extracted.\n     /// - All the edges and key/value pairs to the right of this handle are put into\n     ///   a newly allocated node.\n-    pub fn split(mut self)\n-            -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n+    pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n         unsafe {\n             let mut new_node = Box::new(InternalNode::new());\n \n@@ -1281,63 +1146,50 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             ptr::copy_nonoverlapping(\n                 self.node.keys().as_ptr().add(self.idx + 1),\n                 new_node.data.keys.as_mut_ptr() as *mut K,\n-                new_len\n+                new_len,\n             );\n             ptr::copy_nonoverlapping(\n                 self.node.vals().as_ptr().add(self.idx + 1),\n                 new_node.data.vals.as_mut_ptr() as *mut V,\n-                new_len\n+                new_len,\n             );\n             ptr::copy_nonoverlapping(\n                 self.node.as_internal().edges.as_ptr().add(self.idx + 1),\n                 new_node.edges.as_mut_ptr(),\n-                new_len + 1\n+                new_len + 1,\n             );\n \n             (*self.node.as_leaf_mut()).len = self.idx as u16;\n             new_node.data.len = new_len as u16;\n \n-            let mut new_root = Root {\n-                node: BoxedNode::from_internal(new_node),\n-                height,\n-            };\n+            let mut new_root = Root { node: BoxedNode::from_internal(new_node), height };\n \n-            for i in 0..(new_len+1) {\n+            for i in 0..(new_len + 1) {\n                 Handle::new_edge(new_root.as_mut().cast_unchecked(), i).correct_parent_link();\n             }\n \n-            (\n-                self.node,\n-                k, v,\n-                new_root\n-            )\n+            (self.node, k, v, new_root)\n         }\n     }\n \n     /// Returns `true` if it is valid to call `.merge()`, i.e., whether there is enough room in\n     /// a node to hold the combination of the nodes to the left and right of this handle along\n     /// with the key/value pair at this handle.\n     pub fn can_merge(&self) -> bool {\n-        (\n-            self.reborrow()\n-                .left_edge()\n-                .descend()\n-                .len()\n-          + self.reborrow()\n-                .right_edge()\n-                .descend()\n-                .len()\n-          + 1\n-        ) <= CAPACITY\n+        (self.reborrow().left_edge().descend().len()\n+            + self.reborrow().right_edge().descend().len()\n+            + 1)\n+            <= CAPACITY\n     }\n \n     /// Combines the node immediately to the left of this handle, the key/value pair pointed\n     /// to by this handle, and the node immediately to the right of this handle into one new\n     /// child of the underlying node, returning an edge referencing that new child.\n     ///\n     /// Assumes that this edge `.can_merge()`.\n-    pub fn merge(mut self)\n-            -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n+    pub fn merge(\n+        mut self,\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n         let self1 = unsafe { ptr::read(&self) };\n         let self2 = unsafe { ptr::read(&self) };\n         let mut left_node = self1.left_edge().descend();\n@@ -1349,23 +1201,27 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         debug_assert!(left_len + right_len + 1 <= CAPACITY);\n \n         unsafe {\n-            ptr::write(left_node.keys_mut().get_unchecked_mut(left_len),\n-                       slice_remove(self.node.keys_mut(), self.idx));\n+            ptr::write(\n+                left_node.keys_mut().get_unchecked_mut(left_len),\n+                slice_remove(self.node.keys_mut(), self.idx),\n+            );\n             ptr::copy_nonoverlapping(\n                 right_node.keys().as_ptr(),\n                 left_node.keys_mut().as_mut_ptr().add(left_len + 1),\n-                right_len\n+                right_len,\n+            );\n+            ptr::write(\n+                left_node.vals_mut().get_unchecked_mut(left_len),\n+                slice_remove(self.node.vals_mut(), self.idx),\n             );\n-            ptr::write(left_node.vals_mut().get_unchecked_mut(left_len),\n-                       slice_remove(self.node.vals_mut(), self.idx));\n             ptr::copy_nonoverlapping(\n                 right_node.vals().as_ptr(),\n                 left_node.vals_mut().as_mut_ptr().add(left_len + 1),\n-                right_len\n+                right_len,\n             );\n \n             slice_remove(&mut self.node.as_internal_mut().edges, self.idx + 1);\n-            for i in self.idx+1..self.node.len() {\n+            for i in self.idx + 1..self.node.len() {\n                 Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n             }\n             (*self.node.as_leaf_mut()).len -= 1;\n@@ -1375,30 +1231,23 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             if self.node.height > 1 {\n                 ptr::copy_nonoverlapping(\n                     right_node.cast_unchecked().as_internal().edges.as_ptr(),\n-                    left_node.cast_unchecked()\n-                             .as_internal_mut()\n-                             .edges\n-                             .as_mut_ptr()\n-                             .add(left_len + 1),\n-                    right_len + 1\n+                    left_node\n+                        .cast_unchecked()\n+                        .as_internal_mut()\n+                        .edges\n+                        .as_mut_ptr()\n+                        .add(left_len + 1),\n+                    right_len + 1,\n                 );\n \n-                for i in left_len+1..left_len+right_len+2 {\n-                    Handle::new_edge(\n-                        left_node.cast_unchecked().reborrow_mut(),\n-                        i\n-                    ).correct_parent_link();\n+                for i in left_len + 1..left_len + right_len + 2 {\n+                    Handle::new_edge(left_node.cast_unchecked().reborrow_mut(), i)\n+                        .correct_parent_link();\n                 }\n \n-                Global.dealloc(\n-                    right_node.node.cast(),\n-                    Layout::new::<InternalNode<K, V>>(),\n-                );\n+                Global.dealloc(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n             } else {\n-                Global.dealloc(\n-                    right_node.node.cast(),\n-                    Layout::new::<LeafNode<K, V>>(),\n-                );\n+                Global.dealloc(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n             }\n \n             Handle::new_edge(self.node, self.idx)\n@@ -1417,7 +1266,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             match self.reborrow_mut().right_edge().descend().force() {\n                 ForceResult::Leaf(mut leaf) => leaf.push_front(k, v),\n-                ForceResult::Internal(mut internal) => internal.push_front(k, v, edge.unwrap())\n+                ForceResult::Internal(mut internal) => internal.push_front(k, v, edge.unwrap()),\n             }\n         }\n     }\n@@ -1434,7 +1283,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             match self.reborrow_mut().left_edge().descend().force() {\n                 ForceResult::Leaf(mut leaf) => leaf.push(k, v),\n-                ForceResult::Internal(mut internal) => internal.push(k, v, edge.unwrap())\n+                ForceResult::Internal(mut internal) => internal.push(k, v, edge.unwrap()),\n             }\n         }\n     }\n@@ -1463,12 +1312,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 };\n \n                 // Make room for stolen elements in the right child.\n-                ptr::copy(right_kv.0,\n-                          right_kv.0.add(count),\n-                          right_len);\n-                ptr::copy(right_kv.1,\n-                          right_kv.1.add(count),\n-                          right_len);\n+                ptr::copy(right_kv.0, right_kv.0.add(count), right_len);\n+                ptr::copy(right_kv.1, right_kv.1.add(count), right_len);\n \n                 // Move elements from the left child to the right one.\n                 move_kv(left_kv, new_left_len + 1, right_kv, 0, count - 1);\n@@ -1487,15 +1332,15 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Make room for stolen edges.\n                     let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n-                    ptr::copy(right_edges,\n-                              right_edges.add(count),\n-                              right_len + 1);\n+                    ptr::copy(right_edges, right_edges.add(count), right_len + 1);\n                     right.correct_childrens_parent_links(count, count + right_len + 1);\n \n                     move_edges(left, new_left_len + 1, right, 0, count);\n-                },\n-                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => { }\n-                _ => { unreachable!(); }\n+                }\n+                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n+                _ => {\n+                    unreachable!();\n+                }\n             }\n         }\n     }\n@@ -1533,12 +1378,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 move_kv(right_kv, count - 1, parent_kv, 0, 1);\n \n                 // Fix right indexing\n-                ptr::copy(right_kv.0.add(count),\n-                          right_kv.0,\n-                          new_right_len);\n-                ptr::copy(right_kv.1.add(count),\n-                          right_kv.1,\n-                          new_right_len);\n+                ptr::copy(right_kv.0.add(count), right_kv.0, new_right_len);\n+                ptr::copy(right_kv.1.add(count), right_kv.1, new_right_len);\n             }\n \n             (*left_node.reborrow_mut().as_leaf_mut()).len += count as u16;\n@@ -1550,73 +1391,71 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n                     // Fix right indexing.\n                     let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n-                    ptr::copy(right_edges.add(count),\n-                              right_edges,\n-                              new_right_len + 1);\n+                    ptr::copy(right_edges.add(count), right_edges, new_right_len + 1);\n                     right.correct_childrens_parent_links(0, new_right_len + 1);\n-                },\n-                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => { }\n-                _ => { unreachable!(); }\n+                }\n+                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n+                _ => {\n+                    unreachable!();\n+                }\n             }\n         }\n     }\n }\n \n unsafe fn move_kv<K, V>(\n-    source: (*mut K, *mut V), source_offset: usize,\n-    dest: (*mut K, *mut V), dest_offset: usize,\n-    count: usize)\n-{\n-    ptr::copy_nonoverlapping(source.0.add(source_offset),\n-                             dest.0.add(dest_offset),\n-                             count);\n-    ptr::copy_nonoverlapping(source.1.add(source_offset),\n-                             dest.1.add(dest_offset),\n-                             count);\n+    source: (*mut K, *mut V),\n+    source_offset: usize,\n+    dest: (*mut K, *mut V),\n+    dest_offset: usize,\n+    count: usize,\n+) {\n+    ptr::copy_nonoverlapping(source.0.add(source_offset), dest.0.add(dest_offset), count);\n+    ptr::copy_nonoverlapping(source.1.add(source_offset), dest.1.add(dest_offset), count);\n }\n \n // Source and destination must have the same height.\n unsafe fn move_edges<K, V>(\n-    mut source: NodeRef<marker::Mut<'_>, K, V, marker::Internal>, source_offset: usize,\n-    mut dest: NodeRef<marker::Mut<'_>, K, V, marker::Internal>, dest_offset: usize,\n-    count: usize)\n-{\n+    mut source: NodeRef<marker::Mut<'_>, K, V, marker::Internal>,\n+    source_offset: usize,\n+    mut dest: NodeRef<marker::Mut<'_>, K, V, marker::Internal>,\n+    dest_offset: usize,\n+    count: usize,\n+) {\n     let source_ptr = source.as_internal_mut().edges.as_mut_ptr();\n     let dest_ptr = dest.as_internal_mut().edges.as_mut_ptr();\n-    ptr::copy_nonoverlapping(source_ptr.add(source_offset),\n-                             dest_ptr.add(dest_offset),\n-                             count);\n+    ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n     dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n }\n \n impl<BorrowType, K, V, HandleType>\n-        Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType> {\n-\n+    Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType>\n+{\n     /// Checks whether the underlying node is an `Internal` node or a `Leaf` node.\n-    pub fn force(self) -> ForceResult<\n+    pub fn force(\n+        self,\n+    ) -> ForceResult<\n         Handle<NodeRef<BorrowType, K, V, marker::Leaf>, HandleType>,\n-        Handle<NodeRef<BorrowType, K, V, marker::Internal>, HandleType>\n+        Handle<NodeRef<BorrowType, K, V, marker::Internal>, HandleType>,\n     > {\n         match self.node.force() {\n-            ForceResult::Leaf(node) => ForceResult::Leaf(Handle {\n-                node,\n-                idx: self.idx,\n-                _marker: PhantomData\n-            }),\n-            ForceResult::Internal(node) => ForceResult::Internal(Handle {\n-                node,\n-                idx: self.idx,\n-                _marker: PhantomData\n-            })\n+            ForceResult::Leaf(node) => {\n+                ForceResult::Leaf(Handle { node, idx: self.idx, _marker: PhantomData })\n+            }\n+            ForceResult::Internal(node) => {\n+                ForceResult::Internal(Handle { node, idx: self.idx, _marker: PhantomData })\n+            }\n         }\n     }\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {\n     /// Move the suffix after `self` from one node to another one. `right` must be empty.\n     /// The first edge of `right` remains unchanged.\n-    pub fn move_suffix(&mut self,\n-            right: &mut NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>) {\n+    pub fn move_suffix(\n+        &mut self,\n+        right: &mut NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n+    ) {\n         unsafe {\n             let left_new_len = self.idx;\n             let mut left_node = self.reborrow_mut().into_node();\n@@ -1630,7 +1469,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n             let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n             let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n \n-\n             move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n \n             (*left_node.reborrow_mut().as_leaf_mut()).len = left_new_len as u16;\n@@ -1639,54 +1477,48 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n                     move_edges(left, left_new_len + 1, right, 1, right_new_len);\n-                },\n-                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => { }\n-                _ => { unreachable!(); }\n+                }\n+                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n+                _ => {\n+                    unreachable!();\n+                }\n             }\n         }\n     }\n }\n \n pub enum ForceResult<Leaf, Internal> {\n     Leaf(Leaf),\n-    Internal(Internal)\n+    Internal(Internal),\n }\n \n pub enum InsertResult<'a, K, V, Type> {\n     Fit(Handle<NodeRef<marker::Mut<'a>, K, V, Type>, marker::KV>),\n-    Split(NodeRef<marker::Mut<'a>, K, V, Type>, K, V, Root<K, V>)\n+    Split(NodeRef<marker::Mut<'a>, K, V, Type>, K, V, Root<K, V>),\n }\n \n pub mod marker {\n     use core::marker::PhantomData;\n \n-    pub enum Leaf { }\n-    pub enum Internal { }\n-    pub enum LeafOrInternal { }\n+    pub enum Leaf {}\n+    pub enum Internal {}\n+    pub enum LeafOrInternal {}\n \n-    pub enum Owned { }\n+    pub enum Owned {}\n     pub struct Immut<'a>(PhantomData<&'a ()>);\n     pub struct Mut<'a>(PhantomData<&'a mut ()>);\n \n-    pub enum KV { }\n-    pub enum Edge { }\n+    pub enum KV {}\n+    pub enum Edge {}\n }\n \n unsafe fn slice_insert<T>(slice: &mut [T], idx: usize, val: T) {\n-    ptr::copy(\n-        slice.as_ptr().add(idx),\n-        slice.as_mut_ptr().add(idx + 1),\n-        slice.len() - idx\n-    );\n+    ptr::copy(slice.as_ptr().add(idx), slice.as_mut_ptr().add(idx + 1), slice.len() - idx);\n     ptr::write(slice.get_unchecked_mut(idx), val);\n }\n \n unsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n     let ret = ptr::read(slice.get_unchecked(idx));\n-    ptr::copy(\n-        slice.as_ptr().add(idx + 1),\n-        slice.as_mut_ptr().add(idx),\n-        slice.len() - idx - 1\n-    );\n+    ptr::copy(slice.as_ptr().add(idx + 1), slice.as_mut_ptr().add(idx), slice.len() - idx - 1);\n     ret\n }"}, {"sha": "282d163141bc8477eea827705482a7b285bff947", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 100, "deletions": 147, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -2,14 +2,14 @@\n // to TreeMap\n \n use core::borrow::Borrow;\n-use core::cmp::Ordering::{Less, Greater, Equal};\n+use core::cmp::Ordering::{Equal, Greater, Less};\n use core::cmp::{max, min};\n use core::fmt::{self, Debug};\n-use core::iter::{Peekable, FromIterator, FusedIterator};\n-use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeBounds};\n+use core::iter::{FromIterator, FusedIterator, Peekable};\n+use core::ops::{BitAnd, BitOr, BitXor, RangeBounds, Sub};\n \n-use crate::collections::btree_map::{self, BTreeMap, Keys};\n use super::Recover;\n+use crate::collections::btree_map::{self, BTreeMap, Keys};\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -77,9 +77,7 @@ pub struct Iter<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Iter\")\n-         .field(&self.iter.clone())\n-         .finish()\n+        f.debug_tuple(\"Iter\").field(&self.iter.clone()).finish()\n     }\n }\n \n@@ -114,8 +112,9 @@ pub struct Range<'a, T: 'a> {\n /// and crucially for SymmetricDifference, nexts() reports on both sides.\n #[derive(Clone)]\n struct MergeIterInner<I>\n-    where I: Iterator,\n-          I::Item: Copy,\n+where\n+    I: Iterator,\n+    I::Item: Copy,\n {\n     a: I,\n     b: I,\n@@ -129,8 +128,9 @@ enum MergeIterPeeked<I: Iterator> {\n }\n \n impl<I> MergeIterInner<I>\n-    where I: ExactSizeIterator + FusedIterator,\n-          I::Item: Copy + Ord,\n+where\n+    I: ExactSizeIterator + FusedIterator,\n+    I::Item: Copy + Ord,\n {\n     fn new(a: I, b: I) -> Self {\n         MergeIterInner { a, b, peeked: None }\n@@ -169,14 +169,12 @@ impl<I> MergeIterInner<I>\n }\n \n impl<I> Debug for MergeIterInner<I>\n-    where I: Iterator + Debug,\n-          I::Item: Copy + Debug,\n+where\n+    I: Iterator + Debug,\n+    I::Item: Copy + Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"MergeIterInner\")\n-            .field(&self.a)\n-            .field(&self.b)\n-            .finish()\n+        f.debug_tuple(\"MergeIterInner\").field(&self.a).field(&self.b).finish()\n     }\n }\n \n@@ -328,7 +326,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range<K: ?Sized, R>(&self, range: R) -> Range<'_, T>\n-        where K: Ord, T: Borrow<K>, R: RangeBounds<K>\n+    where\n+        K: Ord,\n+        T: Borrow<K>,\n+        R: RangeBounds<K>,\n     {\n         Range { iter: self.map.range(range) }\n     }\n@@ -355,24 +356,18 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n-        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n-            (self.first(), self.last())\n-        {\n-            (self_min, self_max)\n-        } else {\n-            return Difference {\n-                inner: DifferenceInner::Iterate(self.iter()),\n+        let (self_min, self_max) =\n+            if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {\n+                (self_min, self_max)\n+            } else {\n+                return Difference { inner: DifferenceInner::Iterate(self.iter()) };\n             };\n-        };\n-        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n-            (other.first(), other.last())\n-        {\n-            (other_min, other_max)\n-        } else {\n-            return Difference {\n-                inner: DifferenceInner::Iterate(self.iter()),\n+        let (other_min, other_max) =\n+            if let (Some(other_min), Some(other_max)) = (other.first(), other.last()) {\n+                (other_min, other_max)\n+            } else {\n+                return Difference { inner: DifferenceInner::Iterate(self.iter()) };\n             };\n-        };\n         Difference {\n             inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {\n                 (Greater, _) | (_, Less) => DifferenceInner::Iterate(self.iter()),\n@@ -387,10 +382,7 @@ impl<T: Ord> BTreeSet<T> {\n                     DifferenceInner::Iterate(self_iter)\n                 }\n                 _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n-                    DifferenceInner::Search {\n-                        self_iter: self.iter(),\n-                        other_set: other,\n-                    }\n+                    DifferenceInner::Search { self_iter: self.iter(), other_set: other }\n                 }\n                 _ => DifferenceInner::Stitch {\n                     self_iter: self.iter(),\n@@ -421,9 +413,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(sym_diff, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self,\n-                                    other: &'a BTreeSet<T>)\n-                                    -> SymmetricDifference<'a, T> {\n+    pub fn symmetric_difference<'a>(\n+        &'a self,\n+        other: &'a BTreeSet<T>,\n+    ) -> SymmetricDifference<'a, T> {\n         SymmetricDifference(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n@@ -449,45 +442,30 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n-        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n-            (self.first(), self.last())\n-        {\n-            (self_min, self_max)\n-        } else {\n-            return Intersection {\n-                inner: IntersectionInner::Answer(None),\n+        let (self_min, self_max) =\n+            if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {\n+                (self_min, self_max)\n+            } else {\n+                return Intersection { inner: IntersectionInner::Answer(None) };\n             };\n-        };\n-        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n-            (other.first(), other.last())\n-        {\n-            (other_min, other_max)\n-        } else {\n-            return Intersection {\n-                inner: IntersectionInner::Answer(None),\n+        let (other_min, other_max) =\n+            if let (Some(other_min), Some(other_max)) = (other.first(), other.last()) {\n+                (other_min, other_max)\n+            } else {\n+                return Intersection { inner: IntersectionInner::Answer(None) };\n             };\n-        };\n         Intersection {\n             inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {\n                 (Greater, _) | (_, Less) => IntersectionInner::Answer(None),\n                 (Equal, _) => IntersectionInner::Answer(Some(self_min)),\n                 (_, Equal) => IntersectionInner::Answer(Some(self_max)),\n                 _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n-                    IntersectionInner::Search {\n-                        small_iter: self.iter(),\n-                        large_set: other,\n-                    }\n+                    IntersectionInner::Search { small_iter: self.iter(), large_set: other }\n                 }\n                 _ if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n-                    IntersectionInner::Search {\n-                        small_iter: other.iter(),\n-                        large_set: self,\n-                    }\n+                    IntersectionInner::Search { small_iter: other.iter(), large_set: self }\n                 }\n-                _ => IntersectionInner::Stitch {\n-                    a: self.iter(),\n-                    b: other.iter(),\n-                },\n+                _ => IntersectionInner::Stitch { a: self.iter(), b: other.iter() },\n             },\n         }\n     }\n@@ -549,8 +527,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n-        where T: Borrow<Q>,\n-              Q: Ord\n+    where\n+        T: Borrow<Q>,\n+        Q: Ord,\n     {\n         self.map.contains_key(value)\n     }\n@@ -572,8 +551,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n-        where T: Borrow<Q>,\n-              Q: Ord\n+    where\n+        T: Borrow<Q>,\n+        Q: Ord,\n     {\n         Recover::get(&self.map, value)\n     }\n@@ -624,20 +604,18 @@ impl<T: Ord> BTreeSet<T> {\n         if self.len() > other.len() {\n             return false;\n         }\n-        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n-            (self.first(), self.last())\n-        {\n-            (self_min, self_max)\n-        } else {\n-            return true; // self is empty\n-        };\n-        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n-            (other.first(), other.last())\n-        {\n-            (other_min, other_max)\n-        } else {\n-            return false; // other is empty\n-        };\n+        let (self_min, self_max) =\n+            if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {\n+                (self_min, self_max)\n+            } else {\n+                return true; // self is empty\n+            };\n+        let (other_min, other_max) =\n+            if let (Some(other_min), Some(other_max)) = (other.first(), other.last()) {\n+                (other_min, other_max)\n+            } else {\n+                return false; // other is empty\n+            };\n         let mut self_iter = self.iter();\n         match self_min.cmp(other_min) {\n             Less => return false,\n@@ -855,8 +833,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n-        where T: Borrow<Q>,\n-              Q: Ord\n+    where\n+        T: Borrow<Q>,\n+        Q: Ord,\n     {\n         self.map.remove(value).is_some()\n     }\n@@ -878,8 +857,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n-        where T: Borrow<Q>,\n-              Q: Ord\n+    where\n+        T: Borrow<Q>,\n+        Q: Ord,\n     {\n         Recover::take(&mut self.map, value)\n     }\n@@ -947,7 +927,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(b.contains(&41));\n     /// ```\n     #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n-    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self where T: Borrow<Q> {\n+    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n+    where\n+        T: Borrow<Q>,\n+    {\n         BTreeSet { map: self.map.split_off(key) }\n     }\n }\n@@ -1213,7 +1196,9 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for Iter<'_, T> {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1238,7 +1223,9 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1279,20 +1266,13 @@ impl<T> Clone for Difference<'_, T> {\n     fn clone(&self) -> Self {\n         Difference {\n             inner: match &self.inner {\n-                DifferenceInner::Stitch {\n-                    self_iter,\n-                    other_iter,\n-                } => DifferenceInner::Stitch {\n+                DifferenceInner::Stitch { self_iter, other_iter } => DifferenceInner::Stitch {\n                     self_iter: self_iter.clone(),\n                     other_iter: other_iter.clone(),\n                 },\n-                DifferenceInner::Search {\n-                    self_iter,\n-                    other_set,\n-                } => DifferenceInner::Search {\n-                    self_iter: self_iter.clone(),\n-                    other_set,\n-                },\n+                DifferenceInner::Search { self_iter, other_set } => {\n+                    DifferenceInner::Search { self_iter: self_iter.clone(), other_set }\n+                }\n                 DifferenceInner::Iterate(iter) => DifferenceInner::Iterate(iter.clone()),\n             },\n         }\n@@ -1304,16 +1284,10 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n \n     fn next(&mut self) -> Option<&'a T> {\n         match &mut self.inner {\n-            DifferenceInner::Stitch {\n-                self_iter,\n-                other_iter,\n-            } => {\n+            DifferenceInner::Stitch { self_iter, other_iter } => {\n                 let mut self_next = self_iter.next()?;\n                 loop {\n-                    match other_iter\n-                        .peek()\n-                        .map_or(Less, |other_next| self_next.cmp(other_next))\n-                    {\n+                    match other_iter.peek().map_or(Less, |other_next| self_next.cmp(other_next)) {\n                         Less => return Some(self_next),\n                         Equal => {\n                             self_next = self_iter.next()?;\n@@ -1325,10 +1299,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n                     }\n                 }\n             }\n-            DifferenceInner::Search {\n-                self_iter,\n-                other_set,\n-            } => loop {\n+            DifferenceInner::Search { self_iter, other_set } => loop {\n                 let self_next = self_iter.next()?;\n                 if !other_set.contains(&self_next) {\n                     return Some(self_next);\n@@ -1340,14 +1311,10 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (self_len, other_len) = match &self.inner {\n-            DifferenceInner::Stitch {\n-                self_iter,\n-                other_iter,\n-            } => (self_iter.len(), other_iter.len()),\n-            DifferenceInner::Search {\n-                self_iter,\n-                other_set,\n-            } => (self_iter.len(), other_set.len()),\n+            DifferenceInner::Stitch { self_iter, other_iter } => {\n+                (self_iter.len(), other_iter.len())\n+            }\n+            DifferenceInner::Search { self_iter, other_set } => (self_iter.len(), other_set.len()),\n             DifferenceInner::Iterate(iter) => (iter.len(), 0),\n         };\n         (self_len.saturating_sub(other_len), Some(self_len))\n@@ -1393,20 +1360,12 @@ impl<T> Clone for Intersection<'_, T> {\n     fn clone(&self) -> Self {\n         Intersection {\n             inner: match &self.inner {\n-                IntersectionInner::Stitch {\n-                    a,\n-                    b,\n-                } => IntersectionInner::Stitch {\n-                    a: a.clone(),\n-                    b: b.clone(),\n-                },\n-                IntersectionInner::Search {\n-                    small_iter,\n-                    large_set,\n-                } => IntersectionInner::Search {\n-                    small_iter: small_iter.clone(),\n-                    large_set,\n-                },\n+                IntersectionInner::Stitch { a, b } => {\n+                    IntersectionInner::Stitch { a: a.clone(), b: b.clone() }\n+                }\n+                IntersectionInner::Search { small_iter, large_set } => {\n+                    IntersectionInner::Search { small_iter: small_iter.clone(), large_set }\n+                }\n                 IntersectionInner::Answer(answer) => IntersectionInner::Answer(*answer),\n             },\n         }\n@@ -1418,10 +1377,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n \n     fn next(&mut self) -> Option<&'a T> {\n         match &mut self.inner {\n-            IntersectionInner::Stitch {\n-                a,\n-                b,\n-            } => {\n+            IntersectionInner::Stitch { a, b } => {\n                 let mut a_next = a.next()?;\n                 let mut b_next = b.next()?;\n                 loop {\n@@ -1432,10 +1388,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n                     }\n                 }\n             }\n-            IntersectionInner::Search {\n-                small_iter,\n-                large_set,\n-            } => loop {\n+            IntersectionInner::Search { small_iter, large_set } => loop {\n                 let small_next = small_iter.next()?;\n                 if large_set.contains(&small_next) {\n                     return Some(small_next);"}, {"sha": "4931093c55c991a7d2b2a45a02df02c607738e2d", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 38, "deletions": 72, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -14,14 +14,14 @@\n \n use core::cmp::Ordering;\n use core::fmt;\n-use core::hash::{Hasher, Hash};\n+use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, FusedIterator};\n use core::marker::PhantomData;\n use core::mem;\n use core::ptr::NonNull;\n \n-use crate::boxed::Box;\n use super::SpecExtend;\n+use crate::boxed::Box;\n \n #[cfg(test)]\n mod tests;\n@@ -66,9 +66,7 @@ pub struct Iter<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Iter\")\n-         .field(&self.len)\n-         .finish()\n+        f.debug_tuple(\"Iter\").field(&self.len).finish()\n     }\n }\n \n@@ -101,10 +99,7 @@ pub struct IterMut<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"IterMut\")\n-         .field(&self.list)\n-         .field(&self.len)\n-         .finish()\n+        f.debug_tuple(\"IterMut\").field(&self.list).field(&self.len).finish()\n     }\n }\n \n@@ -124,19 +119,13 @@ pub struct IntoIter<T> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"IntoIter\")\n-         .field(&self.list)\n-         .finish()\n+        f.debug_tuple(\"IntoIter\").field(&self.list).finish()\n     }\n }\n \n impl<T> Node<T> {\n     fn new(element: T) -> Self {\n-        Node {\n-            next: None,\n-            prev: None,\n-            element,\n-        }\n+        Node { next: None, prev: None, element }\n     }\n \n     fn into_element(self: Box<Self>) -> T {\n@@ -278,12 +267,7 @@ impl<T> LinkedList<T> {\n     #[rustc_const_stable(feature = \"const_linked_list_new\", since = \"1.32.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn new() -> Self {\n-        LinkedList {\n-            head: None,\n-            tail: None,\n-            len: 0,\n-            marker: PhantomData,\n-        }\n+        LinkedList { head: None, tail: None, len: 0, marker: PhantomData }\n     }\n \n     /// Moves all elements from `other` to the end of the list.\n@@ -357,12 +341,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, T> {\n-        Iter {\n-            head: self.head,\n-            tail: self.tail,\n-            len: self.len,\n-            marker: PhantomData,\n-        }\n+        Iter { head: self.head, tail: self.tail, len: self.len, marker: PhantomData }\n     }\n \n     /// Provides a forward iterator with mutable references.\n@@ -391,12 +370,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n-        IterMut {\n-            head: self.head,\n-            tail: self.tail,\n-            len: self.len,\n-            list: self,\n-        }\n+        IterMut { head: self.head, tail: self.tail, len: self.len, list: self }\n     }\n \n     /// Returns `true` if the `LinkedList` is empty.\n@@ -491,7 +465,8 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"linked_list_contains\", since = \"1.12.0\")]\n     pub fn contains(&self, x: &T) -> bool\n-        where T: PartialEq<T>\n+    where\n+        T: PartialEq<T>,\n     {\n         self.iter().any(|e| e == x)\n     }\n@@ -513,9 +488,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n-        unsafe {\n-            self.head.as_ref().map(|node| &node.as_ref().element)\n-        }\n+        unsafe { self.head.as_ref().map(|node| &node.as_ref().element) }\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n@@ -541,9 +514,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        unsafe {\n-            self.head.as_mut().map(|node| &mut node.as_mut().element)\n-        }\n+        unsafe { self.head.as_mut().map(|node| &mut node.as_mut().element) }\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n@@ -563,9 +534,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        unsafe {\n-            self.tail.as_ref().map(|node| &node.as_ref().element)\n-        }\n+        unsafe { self.tail.as_ref().map(|node| &node.as_ref().element) }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n@@ -591,9 +560,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        unsafe {\n-            self.tail.as_mut().map(|node| &mut node.as_mut().element)\n-        }\n+        unsafe { self.tail.as_mut().map(|node| &mut node.as_mut().element) }\n     }\n \n     /// Adds an element first in the list.\n@@ -790,19 +757,14 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n     pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F>\n-        where F: FnMut(&mut T) -> bool\n+    where\n+        F: FnMut(&mut T) -> bool,\n     {\n         // avoid borrow issues.\n         let it = self.head;\n         let old_len = self.len;\n \n-        DrainFilter {\n-            list: self,\n-            it: it,\n-            pred: filter,\n-            idx: 0,\n-            old_len: old_len,\n-        }\n+        DrainFilter { list: self, it: it, pred: filter, idx: 0, old_len: old_len }\n     }\n }\n \n@@ -960,9 +922,11 @@ impl<T> IterMut<'_, T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"linked_list_extras\",\n-               reason = \"this is probably better handled by a cursor type -- we'll see\",\n-               issue = \"27794\")]\n+    #[unstable(\n+        feature = \"linked_list_extras\",\n+        reason = \"this is probably better handled by a cursor type -- we'll see\",\n+        issue = \"27794\"\n+    )]\n     pub fn insert_next(&mut self, element: T) {\n         match self.head {\n             // `push_back` is okay with aliasing `element` references\n@@ -1008,24 +972,25 @@ impl<T> IterMut<'_, T> {\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"linked_list_extras\",\n-               reason = \"this is probably better handled by a cursor type -- we'll see\",\n-               issue = \"27794\")]\n+    #[unstable(\n+        feature = \"linked_list_extras\",\n+        reason = \"this is probably better handled by a cursor type -- we'll see\",\n+        issue = \"27794\"\n+    )]\n     pub fn peek_next(&mut self) -> Option<&mut T> {\n         if self.len == 0 {\n             None\n         } else {\n-            unsafe {\n-                self.head.as_mut().map(|node| &mut node.as_mut().element)\n-            }\n+            unsafe { self.head.as_mut().map(|node| &mut node.as_mut().element) }\n         }\n     }\n }\n \n /// An iterator produced by calling `drain_filter` on LinkedList.\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n pub struct DrainFilter<'a, T: 'a, F: 'a>\n-    where F: FnMut(&mut T) -> bool,\n+where\n+    F: FnMut(&mut T) -> bool,\n {\n     list: &'a mut LinkedList<T>,\n     it: Option<NonNull<Node<T>>>,\n@@ -1036,7 +1001,8 @@ pub struct DrainFilter<'a, T: 'a, F: 'a>\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n impl<T, F> Iterator for DrainFilter<'_, T, F>\n-    where F: FnMut(&mut T) -> bool,\n+where\n+    F: FnMut(&mut T) -> bool,\n {\n     type Item = T;\n \n@@ -1064,7 +1030,8 @@ impl<T, F> Iterator for DrainFilter<'_, T, F>\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n impl<T, F> Drop for DrainFilter<'_, T, F>\n-    where F: FnMut(&mut T) -> bool,\n+where\n+    F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n         self.for_each(drop);\n@@ -1073,12 +1040,11 @@ impl<T, F> Drop for DrainFilter<'_, T, F>\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n impl<T: fmt::Debug, F> fmt::Debug for DrainFilter<'_, T, F>\n-    where F: FnMut(&mut T) -> bool\n+where\n+    F: FnMut(&mut T) -> bool,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"DrainFilter\")\n-         .field(&self.list)\n-         .finish()\n+        f.debug_tuple(\"DrainFilter\").field(&self.list).finish()\n     }\n }\n "}, {"sha": "0bb62373fab1e2b0655c8d92c85903294e2c80b4", "filename": "src/liballoc/collections/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -45,7 +45,7 @@ use crate::alloc::{Layout, LayoutErr};\n \n /// The error type for `try_reserve` methods.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n pub enum TryReserveError {\n     /// Error due to the computed capacity exceeding the collection's maximum\n     /// (usually `isize::MAX` bytes).\n@@ -57,15 +57,19 @@ pub enum TryReserveError {\n         layout: Layout,\n \n         #[doc(hidden)]\n-        #[unstable(feature = \"container_error_extra\", issue = \"none\", reason = \"\\\n+        #[unstable(\n+            feature = \"container_error_extra\",\n+            issue = \"none\",\n+            reason = \"\\\n             Enable exposing the allocator\u2019s custom error value \\\n             if an associated type is added in the future: \\\n-            https://github.com/rust-lang/wg-allocators/issues/23\")]\n+            https://github.com/rust-lang/wg-allocators/issues/23\"\n+        )]\n         non_exhaustive: (),\n     },\n }\n \n-#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n impl From<LayoutErr> for TryReserveError {\n     #[inline]\n     fn from(_: LayoutErr) -> Self {"}, {"sha": "9d2eec94a0c02c99f1374ea4db1117b22b5deda1", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 108, "deletions": 142, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -10,13 +10,13 @@\n use core::array::LengthAtMost32;\n use core::cmp::{self, Ordering};\n use core::fmt;\n+use core::hash::{Hash, Hasher};\n use core::iter::{once, repeat_with, FromIterator, FusedIterator};\n use core::mem::{self, replace};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds, Try};\n use core::ptr::{self, NonNull};\n use core::slice;\n-use core::hash::{Hash, Hasher};\n \n use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n@@ -89,13 +89,12 @@ impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n         !self.b0.is_empty()\n     }\n \n-    fn remainder(self) -> impl Iterator<Item=&'b [T]> {\n+    fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n         once(self.b0).chain(once(self.b1))\n     }\n }\n \n-impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T>\n-{\n+impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T> {\n     type Item = (&'a mut [T], &'b [T]);\n     fn next(&mut self) -> Option<Self::Item> {\n         // Get next part length\n@@ -247,41 +246,45 @@ impl<T> VecDeque<T> {\n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n     unsafe fn copy(&self, dst: usize, src: usize, len: usize) {\n-        debug_assert!(dst + len <= self.cap(),\n-                      \"cpy dst={} src={} len={} cap={}\",\n-                      dst,\n-                      src,\n-                      len,\n-                      self.cap());\n-        debug_assert!(src + len <= self.cap(),\n-                      \"cpy dst={} src={} len={} cap={}\",\n-                      dst,\n-                      src,\n-                      len,\n-                      self.cap());\n-        ptr::copy(self.ptr().add(src),\n-                  self.ptr().add(dst),\n-                  len);\n+        debug_assert!(\n+            dst + len <= self.cap(),\n+            \"cpy dst={} src={} len={} cap={}\",\n+            dst,\n+            src,\n+            len,\n+            self.cap()\n+        );\n+        debug_assert!(\n+            src + len <= self.cap(),\n+            \"cpy dst={} src={} len={} cap={}\",\n+            dst,\n+            src,\n+            len,\n+            self.cap()\n+        );\n+        ptr::copy(self.ptr().add(src), self.ptr().add(dst), len);\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n     unsafe fn copy_nonoverlapping(&self, dst: usize, src: usize, len: usize) {\n-        debug_assert!(dst + len <= self.cap(),\n-                      \"cno dst={} src={} len={} cap={}\",\n-                      dst,\n-                      src,\n-                      len,\n-                      self.cap());\n-        debug_assert!(src + len <= self.cap(),\n-                      \"cno dst={} src={} len={} cap={}\",\n-                      dst,\n-                      src,\n-                      len,\n-                      self.cap());\n-        ptr::copy_nonoverlapping(self.ptr().add(src),\n-                                 self.ptr().add(dst),\n-                                 len);\n+        debug_assert!(\n+            dst + len <= self.cap(),\n+            \"cno dst={} src={} len={} cap={}\",\n+            dst,\n+            src,\n+            len,\n+            self.cap()\n+        );\n+        debug_assert!(\n+            src + len <= self.cap(),\n+            \"cno dst={} src={} len={} cap={}\",\n+            dst,\n+            src,\n+            len,\n+            self.cap()\n+        );\n+        ptr::copy_nonoverlapping(self.ptr().add(src), self.ptr().add(dst), len);\n     }\n \n     /// Copies a potentially wrapping block of memory len long from src to dest.\n@@ -292,12 +295,14 @@ impl<T> VecDeque<T> {\n         fn diff(a: usize, b: usize) -> usize {\n             if a <= b { b - a } else { a - b }\n         }\n-        debug_assert!(cmp::min(diff(dst, src), self.cap() - diff(dst, src)) + len <= self.cap(),\n-                      \"wrc dst={} src={} len={} cap={}\",\n-                      dst,\n-                      src,\n-                      len,\n-                      self.cap());\n+        debug_assert!(\n+            cmp::min(diff(dst, src), self.cap() - diff(dst, src)) + len <= self.cap(),\n+            \"wrc dst={} src={} len={} cap={}\",\n+            dst,\n+            src,\n+            len,\n+            self.cap()\n+        );\n \n         if src == dst || len == 0 {\n             return;\n@@ -475,11 +480,7 @@ impl<T> VecDeque<T> {\n         let cap = cmp::max(capacity + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n         assert!(cap > capacity, \"capacity overflow\");\n \n-        VecDeque {\n-            tail: 0,\n-            head: 0,\n-            buf: RawVec::with_capacity(cap),\n-        }\n+        VecDeque { tail: 0, head: 0, buf: RawVec::with_capacity(cap) }\n     }\n \n     /// Retrieves an element in the `VecDeque` by index.\n@@ -565,10 +566,7 @@ impl<T> VecDeque<T> {\n         assert!(j < self.len());\n         let ri = self.wrap_add(self.tail, i);\n         let rj = self.wrap_add(self.tail, j);\n-        unsafe {\n-            ptr::swap(self.ptr().add(ri),\n-                      self.ptr().add(rj))\n-        }\n+        unsafe { ptr::swap(self.ptr().add(ri), self.ptr().add(rj)) }\n     }\n \n     /// Returns the number of elements the `VecDeque` can hold without\n@@ -635,7 +633,8 @@ impl<T> VecDeque<T> {\n     pub fn reserve(&mut self, additional: usize) {\n         let old_cap = self.cap();\n         let used_cap = self.len() + 1;\n-        let new_cap = used_cap.checked_add(additional)\n+        let new_cap = used_cap\n+            .checked_add(additional)\n             .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n             .expect(\"capacity overflow\");\n \n@@ -683,8 +682,8 @@ impl<T> VecDeque<T> {\n     /// }\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n-    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.try_reserve(additional)\n     }\n \n@@ -721,11 +720,12 @@ impl<T> VecDeque<T> {\n     /// }\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n-    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n     pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         let old_cap = self.cap();\n         let used_cap = self.len() + 1;\n-        let new_cap = used_cap.checked_add(additional)\n+        let new_cap = used_cap\n+            .checked_add(additional)\n             .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n             .ok_or(TryReserveError::CapacityOverflow)?;\n \n@@ -781,16 +781,14 @@ impl<T> VecDeque<T> {\n     /// buf.shrink_to(0);\n     /// assert!(buf.capacity() >= 4);\n     /// ```\n-    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"56431\")]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n         assert!(self.capacity() >= min_capacity, \"Tried to shrink to a larger capacity\");\n \n         // +1 since the ringbuffer always leaves one space empty\n         // len + 1 can't overflow for an existing, well-formed ringbuffer.\n-        let target_cap = cmp::max(\n-            cmp::max(min_capacity, self.len()) + 1,\n-            MINIMUM_CAPACITY + 1\n-        ).next_power_of_two();\n+        let target_cap = cmp::max(cmp::max(min_capacity, self.len()) + 1, MINIMUM_CAPACITY + 1)\n+            .next_power_of_two();\n \n         if target_cap < self.cap() {\n             // There are three cases of interest:\n@@ -913,11 +911,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, T> {\n-        Iter {\n-            tail: self.tail,\n-            head: self.head,\n-            ring: unsafe { self.buffer_as_slice() },\n-        }\n+        Iter { tail: self.tail, head: self.head, ring: unsafe { self.buffer_as_slice() } }\n     }\n \n     /// Returns a front-to-back iterator that returns mutable references.\n@@ -939,11 +933,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n-        IterMut {\n-            tail: self.tail,\n-            head: self.head,\n-            ring: unsafe { self.buffer_as_mut_slice() },\n-        }\n+        IterMut { tail: self.tail, head: self.head, ring: unsafe { self.buffer_as_mut_slice() } }\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n@@ -1073,7 +1063,8 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<'_, T>\n-        where R: RangeBounds<usize>\n+    where\n+        R: RangeBounds<usize>,\n     {\n         // Memory safety\n         //\n@@ -1089,12 +1080,12 @@ impl<T> VecDeque<T> {\n         let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n-            Unbounded    => 0,\n+            Unbounded => 0,\n         };\n         let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n-            Unbounded    => len,\n+            Unbounded => len,\n         };\n         assert!(start <= end, \"drain lower bound was too large\");\n         assert!(end <= len, \"drain upper bound was too large\");\n@@ -1174,7 +1165,8 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"vec_deque_contains\", since = \"1.12.0\")]\n     pub fn contains(&self, x: &T) -> bool\n-        where T: PartialEq<T>\n+    where\n+        T: PartialEq<T>,\n     {\n         let (a, b) = self.as_slices();\n         a.contains(x) || b.contains(x)\n@@ -1197,11 +1189,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n-        if !self.is_empty() {\n-            Some(&self[0])\n-        } else {\n-            None\n-        }\n+        if !self.is_empty() { Some(&self[0]) } else { None }\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the\n@@ -1225,11 +1213,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        if !self.is_empty() {\n-            Some(&mut self[0])\n-        } else {\n-            None\n-        }\n+        if !self.is_empty() { Some(&mut self[0]) } else { None }\n     }\n \n     /// Provides a reference to the back element, or `None` if the `VecDeque` is\n@@ -1249,11 +1233,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        if !self.is_empty() {\n-            Some(&self[self.len() - 1])\n-        } else {\n-            None\n-        }\n+        if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the\n@@ -1278,11 +1258,7 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let len = self.len();\n-        if !self.is_empty() {\n-            Some(&mut self[len - 1])\n-        } else {\n-            None\n-        }\n+        if !self.is_empty() { Some(&mut self[len - 1]) } else { None }\n     }\n \n     /// Removes the first element and returns it, or `None` if the `VecDeque` is\n@@ -1897,22 +1873,24 @@ impl<T> VecDeque<T> {\n                 // `at` lies in the first half.\n                 let amount_in_first = first_len - at;\n \n-                ptr::copy_nonoverlapping(first_half.as_ptr().add(at),\n-                                         other.ptr(),\n-                                         amount_in_first);\n+                ptr::copy_nonoverlapping(first_half.as_ptr().add(at), other.ptr(), amount_in_first);\n \n                 // just take all of the second half.\n-                ptr::copy_nonoverlapping(second_half.as_ptr(),\n-                                         other.ptr().add(amount_in_first),\n-                                         second_len);\n+                ptr::copy_nonoverlapping(\n+                    second_half.as_ptr(),\n+                    other.ptr().add(amount_in_first),\n+                    second_len,\n+                );\n             } else {\n                 // `at` lies in the second half, need to factor in the elements we skipped\n                 // in the first half.\n                 let offset = at - first_len;\n                 let amount_in_second = second_len - offset;\n-                ptr::copy_nonoverlapping(second_half.as_ptr().add(offset),\n-                                         other.ptr(),\n-                                         amount_in_second);\n+                ptr::copy_nonoverlapping(\n+                    second_half.as_ptr().add(offset),\n+                    other.ptr(),\n+                    amount_in_second,\n+                );\n             }\n         }\n \n@@ -1979,7 +1957,8 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"vec_deque_retain\", since = \"1.4.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n-        where F: FnMut(&T) -> bool\n+    where\n+        F: FnMut(&T) -> bool,\n     {\n         let len = self.len();\n         let mut del = 0;\n@@ -2034,7 +2013,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf, [5, 10, 101, 102, 103]);\n     /// ```\n     #[stable(feature = \"vec_resize_with\", since = \"1.33.0\")]\n-    pub fn resize_with(&mut self, new_len: usize, generator: impl FnMut()->T) {\n+    pub fn resize_with(&mut self, new_len: usize, generator: impl FnMut() -> T) {\n         let len = self.len();\n \n         if new_len > len {\n@@ -2250,22 +2229,15 @@ pub struct Iter<'a, T: 'a> {\n impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        f.debug_tuple(\"Iter\")\n-            .field(&front)\n-            .field(&back)\n-            .finish()\n+        f.debug_tuple(\"Iter\").field(&front).field(&back).finish()\n     }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Iter<'_, T> {\n     fn clone(&self) -> Self {\n-        Iter {\n-            ring: self.ring,\n-            tail: self.tail,\n-            head: self.head,\n-        }\n+        Iter { ring: self.ring, tail: self.tail, head: self.head }\n     }\n }\n \n@@ -2290,7 +2262,8 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n \n     fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         accum = front.iter().fold(accum, &mut f);\n@@ -2350,7 +2323,8 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     }\n \n     fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         accum = back.iter().rfold(accum, &mut f);\n@@ -2392,7 +2366,6 @@ impl<T> ExactSizeIterator for Iter<'_, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Iter<'_, T> {}\n \n-\n /// A mutable iterator over the elements of a `VecDeque`.\n ///\n /// This `struct` is created by the [`iter_mut`] method on [`VecDeque`]. See its\n@@ -2411,10 +2384,7 @@ pub struct IterMut<'a, T: 'a> {\n impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let (front, back) = RingSlices::ring_slices(&*self.ring, self.head, self.tail);\n-        f.debug_tuple(\"IterMut\")\n-            .field(&front)\n-            .field(&back)\n-            .finish()\n+        f.debug_tuple(\"IterMut\").field(&front).field(&back).finish()\n     }\n }\n \n@@ -2443,7 +2413,8 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n \n     fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         accum = front.iter_mut().fold(accum, &mut f);\n@@ -2482,7 +2453,8 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     }\n \n     fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         accum = back.iter_mut().rfold(accum, &mut f);\n@@ -2516,9 +2488,7 @@ pub struct IntoIter<T> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"IntoIter\")\n-         .field(&self.inner)\n-         .finish()\n+        f.debug_tuple(\"IntoIter\").field(&self.inner).finish()\n     }\n }\n \n@@ -2575,10 +2545,10 @@ pub struct Drain<'a, T: 'a> {\n impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Drain\")\n-         .field(&self.after_tail)\n-         .field(&self.after_head)\n-         .field(&self.iter)\n-         .finish()\n+            .field(&self.after_tail)\n+            .field(&self.after_head)\n+            .field(&self.iter)\n+            .finish()\n     }\n }\n \n@@ -2835,7 +2805,9 @@ impl<A> Extend<A> for VecDeque<A> {\n \n             let head = self.head;\n             self.head = self.wrap_add(self.head, 1);\n-            unsafe { self.buffer_write(head, element); }\n+            unsafe {\n+                self.buffer_write(head, element);\n+            }\n         }\n     }\n }\n@@ -2873,17 +2845,15 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n \n             // We need to extend the buf if it's not a power of two, too small\n             // or doesn't have at least one free space\n-            if !buf.capacity().is_power_of_two() || (buf.capacity() < (MINIMUM_CAPACITY + 1)) ||\n-               (buf.capacity() == len) {\n+            if !buf.capacity().is_power_of_two()\n+                || (buf.capacity() < (MINIMUM_CAPACITY + 1))\n+                || (buf.capacity() == len)\n+            {\n                 let cap = cmp::max(buf.capacity() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n                 buf.reserve_exact(len, cap - len);\n             }\n \n-            VecDeque {\n-                tail: 0,\n-                head: len,\n-                buf,\n-            }\n+            VecDeque { tail: 0, head: len, buf }\n         }\n     }\n }\n@@ -2936,9 +2906,7 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n                     // do this in at most three copy moves.\n                     if (cap - tail) > head {\n                         // right hand block is the long one; move that enough for the left\n-                        ptr::copy(buf.add(tail),\n-                                  buf.add(tail - head),\n-                                  cap - tail);\n+                        ptr::copy(buf.add(tail), buf.add(tail - head), cap - tail);\n                         // copy left in the end\n                         ptr::copy(buf, buf.add(cap - head), head);\n                         // shift the new thing to the start\n@@ -2976,10 +2944,8 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n                         let n_ops = right_edge - left_edge;\n                         left_edge += n_ops;\n                         right_edge += right_offset + 1;\n-\n                     }\n                 }\n-\n             }\n             let out = Vec::from_raw_parts(buf, len, cap);\n             mem::forget(other);"}, {"sha": "fdabf109b2ead3da8a0577e739901fdaed776233", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -58,22 +58,21 @@\n \n #![allow(unused_attributes)]\n #![stable(feature = \"alloc\", since = \"1.36.0\")]\n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n-       test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n+#![doc(\n+    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+    issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n+    test(no_crate_inject, attr(allow(unused_variables), deny(warnings)))\n+)]\n #![no_std]\n #![needs_allocator]\n-\n #![warn(deprecated_in_future)]\n #![warn(missing_docs)]\n #![warn(missing_debug_implementations)]\n #![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n #![allow(explicit_outlives_requirements)]\n #![allow(incomplete_features)]\n-\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n-\n #![feature(allocator_api)]\n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n@@ -150,19 +149,19 @@ pub mod boxed;\n mod boxed {\n     pub use std::boxed::Box;\n }\n-#[cfg(test)]\n-mod tests;\n-pub mod collections;\n-#[cfg(target_has_atomic = \"ptr\")]\n-pub mod sync;\n-pub mod rc;\n-pub mod raw_vec;\n-pub mod prelude;\n pub mod borrow;\n+pub mod collections;\n pub mod fmt;\n+pub mod prelude;\n+pub mod raw_vec;\n+pub mod rc;\n pub mod slice;\n pub mod str;\n pub mod string;\n+#[cfg(target_has_atomic = \"ptr\")]\n+pub mod sync;\n+#[cfg(test)]\n+mod tests;\n pub mod vec;\n \n #[cfg(not(test))]"}, {"sha": "86aed612efe0434cd8ac172cb38df5f73f10844c", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 55, "deletions": 71, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -7,9 +7,9 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{Alloc, Layout, Global, AllocErr, handle_alloc_error};\n-use crate::collections::TryReserveError::{self, *};\n+use crate::alloc::{handle_alloc_error, Alloc, AllocErr, Global, Layout};\n use crate::boxed::Box;\n+use crate::collections::TryReserveError::{self, *};\n \n #[cfg(test)]\n mod tests;\n@@ -55,11 +55,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n         let cap = if mem::size_of::<T>() == 0 { core::usize::MAX } else { 0 };\n \n         // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n-        RawVec {\n-            ptr: Unique::empty(),\n-            cap,\n-            a,\n-        }\n+        RawVec { ptr: Unique::empty(), cap, a }\n     }\n \n     /// Like `with_capacity`, but parameterized over the choice of\n@@ -89,22 +85,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n             } else {\n                 let align = mem::align_of::<T>();\n                 let layout = Layout::from_size_align(alloc_size, align).unwrap();\n-                let result = if zeroed {\n-                    a.alloc_zeroed(layout)\n-                } else {\n-                    a.alloc(layout)\n-                };\n+                let result = if zeroed { a.alloc_zeroed(layout) } else { a.alloc(layout) };\n                 match result {\n                     Ok(ptr) => ptr.cast(),\n                     Err(_) => handle_alloc_error(layout),\n                 }\n             };\n \n-            RawVec {\n-                ptr: ptr.into(),\n-                cap: capacity,\n-                a,\n-            }\n+            RawVec { ptr: ptr.into(), cap: capacity, a }\n         }\n     }\n }\n@@ -168,11 +156,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n     /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n     pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n-        RawVec {\n-            ptr: Unique::new_unchecked(ptr),\n-            cap: capacity,\n-            a,\n-        }\n+        RawVec { ptr: Unique::new_unchecked(ptr), cap: capacity, a }\n     }\n }\n \n@@ -185,11 +169,7 @@ impl<T> RawVec<T, Global> {\n     /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n     /// If the `ptr` and `capacity` come from a `RawVec`, then this is guaranteed.\n     pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n-        RawVec {\n-            ptr: Unique::new_unchecked(ptr),\n-            cap: capacity,\n-            a: Global,\n-        }\n+        RawVec { ptr: Unique::new_unchecked(ptr), cap: capacity, a: Global }\n     }\n \n     /// Converts a `Box<[T]>` into a `RawVec<T>`.\n@@ -215,11 +195,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// This will always be `usize::MAX` if `T` is zero-sized.\n     #[inline(always)]\n     pub fn capacity(&self) -> usize {\n-        if mem::size_of::<T>() == 0 {\n-            !0\n-        } else {\n-            self.cap\n-        }\n+        if mem::size_of::<T>() == 0 { !0 } else { self.cap }\n     }\n \n     /// Returns a shared reference to the allocator backing this `RawVec`.\n@@ -319,14 +295,13 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n                     alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n-                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(),\n-                                                 cur,\n-                                                 new_size);\n+                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(), cur, new_size);\n                     match ptr_res {\n                         Ok(ptr) => (new_cap, ptr.cast().into()),\n-                        Err(_) => handle_alloc_error(\n-                            Layout::from_size_align_unchecked(new_size, cur.align())\n-                        ),\n+                        Err(_) => handle_alloc_error(Layout::from_size_align_unchecked(\n+                            new_size,\n+                            cur.align(),\n+                        )),\n                     }\n                 }\n                 None => {\n@@ -386,17 +361,17 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     self.cap = new_cap;\n                     true\n                 }\n-                Err(_) => {\n-                    false\n-                }\n+                Err(_) => false,\n             }\n         }\n     }\n \n     /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n-           -> Result<(), TryReserveError> {\n-\n+    pub fn try_reserve_exact(\n+        &mut self,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n+    ) -> Result<(), TryReserveError> {\n         self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Exact)\n     }\n \n@@ -425,27 +400,32 @@ impl<T, A: Alloc> RawVec<T, A> {\n             Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocError { .. }) => unreachable!(),\n             Ok(()) => { /* yay */ }\n-         }\n-     }\n+        }\n+    }\n \n     /// Calculates the buffer's new size given that it'll hold `used_capacity +\n     /// needed_extra_capacity` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n-    fn amortized_new_size(&self, used_capacity: usize, needed_extra_capacity: usize)\n-        -> Result<usize, TryReserveError> {\n-\n+    fn amortized_new_size(\n+        &self,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n+    ) -> Result<usize, TryReserveError> {\n         // Nothing we can really do about these checks, sadly.\n-        let required_cap = used_capacity.checked_add(needed_extra_capacity)\n-            .ok_or(CapacityOverflow)?;\n+        let required_cap =\n+            used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n         let double_cap = self.cap * 2;\n         // `double_cap` guarantees exponential growth.\n         Ok(cmp::max(double_cap, required_cap))\n     }\n \n     /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n-        -> Result<(), TryReserveError> {\n+    pub fn try_reserve(\n+        &mut self,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n+    ) -> Result<(), TryReserveError> {\n         self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Amortized)\n     }\n \n@@ -543,7 +523,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 return false;\n             }\n \n-            let new_cap = self.amortized_new_size(used_capacity, needed_extra_capacity)\n+            let new_cap = self\n+                .amortized_new_size(used_capacity, needed_extra_capacity)\n                 .unwrap_or_else(|_| capacity_overflow());\n \n             // Here, `cap < used_capacity + needed_extra_capacity <= new_cap`\n@@ -554,15 +535,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_layout.size()).unwrap_or_else(|_| capacity_overflow());\n             match self.a.grow_in_place(\n-                NonNull::from(self.ptr).cast(), old_layout, new_layout.size(),\n+                NonNull::from(self.ptr).cast(),\n+                old_layout,\n+                new_layout.size(),\n             ) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n                     true\n                 }\n-                Err(_) => {\n-                    false\n-                }\n+                Err(_) => false,\n             }\n         }\n     }\n@@ -615,13 +596,11 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n                 let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-                match self.a.realloc(NonNull::from(self.ptr).cast(),\n-                                     old_layout,\n-                                     new_size) {\n+                match self.a.realloc(NonNull::from(self.ptr).cast(), old_layout, new_size) {\n                     Ok(p) => self.ptr = p.cast().into(),\n-                    Err(_) => handle_alloc_error(\n-                        Layout::from_size_align_unchecked(new_size, align)\n-                    ),\n+                    Err(_) => {\n+                        handle_alloc_error(Layout::from_size_align_unchecked(new_size, align))\n+                    }\n                 }\n             }\n             self.cap = amount;\n@@ -665,7 +644,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // Nothing we can really do about these checks, sadly.\n             let new_cap = match strategy {\n-                Exact => used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?,\n+                Exact => {\n+                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?\n+                }\n                 Amortized => self.amortized_new_size(used_capacity, needed_extra_capacity)?,\n             };\n             let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n@@ -682,10 +663,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             let ptr = match (res, fallibility) {\n                 (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n-                (Err(AllocErr), Fallible) => return Err(TryReserveError::AllocError {\n-                    layout: new_layout,\n-                    non_exhaustive: (),\n-                }),\n+                (Err(AllocErr), Fallible) => {\n+                    return Err(TryReserveError::AllocError {\n+                        layout: new_layout,\n+                        non_exhaustive: (),\n+                    });\n+                }\n                 (Ok(ptr), _) => ptr,\n             };\n \n@@ -695,7 +678,6 @@ impl<T, A: Alloc> RawVec<T, A> {\n             Ok(())\n         }\n     }\n-\n }\n \n impl<T> RawVec<T, Global> {\n@@ -733,7 +715,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n-        unsafe { self.dealloc_buffer(); }\n+        unsafe {\n+            self.dealloc_buffer();\n+        }\n     }\n }\n "}, {"sha": "3080a8bf459661588614914d0818835f758139c4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 49, "deletions": 84, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -239,20 +239,20 @@ use core::array::LengthAtMost32;\n use core::borrow;\n use core::cell::Cell;\n use core::cmp::Ordering;\n+use core::convert::{From, TryFrom};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::iter;\n-use core::marker::{self, Unpin, Unsize, PhantomData};\n+use core::marker::{self, PhantomData, Unpin, Unsize};\n use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n-use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n+use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::slice::{self, from_raw_parts_mut};\n-use core::convert::{From, TryFrom};\n use core::usize;\n \n-use crate::alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n+use crate::alloc::{box_free, handle_alloc_error, Alloc, Global, Layout};\n use crate::string::String;\n use crate::vec::Vec;\n \n@@ -296,10 +296,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Rc<U>> for Rc<T> {}\n \n impl<T: ?Sized> Rc<T> {\n     fn from_inner(ptr: NonNull<RcBox<T>>) -> Self {\n-        Self {\n-            ptr,\n-            phantom: PhantomData,\n-        }\n+        Self { ptr, phantom: PhantomData }\n     }\n \n     unsafe fn from_ptr(ptr: *mut RcBox<T>) -> Self {\n@@ -354,10 +351,9 @@ impl<T> Rc<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {\n         unsafe {\n-            Rc::from_ptr(Rc::allocate_for_layout(\n-                Layout::new::<T>(),\n-                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n-            ))\n+            Rc::from_ptr(Rc::allocate_for_layout(Layout::new::<T>(), |mem| {\n+                mem as *mut RcBox<mem::MaybeUninit<T>>\n+            }))\n         }\n     }\n \n@@ -466,9 +462,7 @@ impl<T> Rc<[T]> {\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n-        unsafe {\n-            Rc::from_ptr(Rc::allocate_for_slice(len))\n-        }\n+        unsafe { Rc::from_ptr(Rc::allocate_for_slice(len)) }\n     }\n }\n \n@@ -733,13 +727,7 @@ impl<T: ?Sized> Rc<T> {\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n-        if Rc::is_unique(this) {\n-            unsafe {\n-                Some(Rc::get_mut_unchecked(this))\n-            }\n-        } else {\n-            None\n-        }\n+        if Rc::is_unique(this) { unsafe { Some(Rc::get_mut_unchecked(this)) } } else { None }\n     }\n \n     /// Returns a mutable reference into the given `Rc`,\n@@ -872,9 +860,7 @@ impl<T: Clone> Rc<T> {\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n         // reference to the allocation.\n-        unsafe {\n-            &mut this.ptr.as_mut().value\n-        }\n+        unsafe { &mut this.ptr.as_mut().value }\n     }\n }\n \n@@ -918,19 +904,16 @@ impl<T: ?Sized> Rc<T> {\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n     unsafe fn allocate_for_layout(\n         value_layout: Layout,\n-        mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>\n+        mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>,\n     ) -> *mut RcBox<T> {\n         // Calculate layout using the given value layout.\n         // Previously, layout was calculated on the expression\n         // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n         // reference (see #54908).\n-        let layout = Layout::new::<RcBox<()>>()\n-            .extend(value_layout).unwrap().0\n-            .pad_to_align();\n+        let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let mem = Global.alloc(layout)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let mem = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n         let inner = mem_to_rcbox(mem.as_ptr());\n@@ -945,10 +928,9 @@ impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for an unsized inner value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n-        Self::allocate_for_layout(\n-            Layout::for_value(&*ptr),\n-            |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n-        )\n+        Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n+            set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>\n+        })\n     }\n \n     fn from_box(v: Box<T>) -> Rc<T> {\n@@ -963,7 +945,8 @@ impl<T: ?Sized> Rc<T> {\n             ptr::copy_nonoverlapping(\n                 bptr as *const T as *const u8,\n                 &mut (*ptr).value as *mut _ as *mut u8,\n-                value_size);\n+                value_size,\n+            );\n \n             // Free the allocation without dropping its contents\n             box_free(box_unique);\n@@ -976,10 +959,9 @@ impl<T: ?Sized> Rc<T> {\n impl<T> Rc<[T]> {\n     /// Allocates an `RcBox<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n-        Self::allocate_for_layout(\n-            Layout::array::<T>(len).unwrap(),\n-            |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>,\n-        )\n+        Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n+            ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>\n+        })\n     }\n }\n \n@@ -999,10 +981,7 @@ impl<T> Rc<[T]> {\n     unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {\n         let ptr = Self::allocate_for_slice(v.len());\n \n-        ptr::copy_nonoverlapping(\n-            v.as_ptr(),\n-            &mut (*ptr).value as *mut [T] as *mut T,\n-            v.len());\n+        ptr::copy_nonoverlapping(v.as_ptr(), &mut (*ptr).value as *mut [T] as *mut T, v.len());\n \n         Self::from_ptr(ptr)\n     }\n@@ -1040,12 +1019,7 @@ impl<T> Rc<[T]> {\n         // Pointer to first element\n         let elems = &mut (*ptr).value as *mut [T] as *mut T;\n \n-        let mut guard = Guard {\n-            mem: NonNull::new_unchecked(mem),\n-            elems,\n-            layout,\n-            n_elems: 0,\n-        };\n+        let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };\n \n         for (i, item) in iter.enumerate() {\n             ptr::write(elems.add(i), item);\n@@ -1067,9 +1041,7 @@ trait RcFromSlice<T> {\n impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n     #[inline]\n     default fn from_slice(v: &[T]) -> Self {\n-        unsafe {\n-            Self::from_iter_exact(v.iter().cloned(), v.len())\n-        }\n+        unsafe { Self::from_iter_exact(v.iter().cloned(), v.len()) }\n     }\n }\n \n@@ -1543,13 +1515,14 @@ impl<T, I: Iterator<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n     }\n }\n \n-impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]>  {\n+impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n     default fn from_iter(iter: I) -> Self {\n         // This is the case for a `TrustedLen` iterator.\n         let (low, high) = iter.size_hint();\n         if let Some(high) = high {\n             debug_assert_eq!(\n-                low, high,\n+                low,\n+                high,\n                 \"TrustedLen iterator's size hint is not exact: {:?}\",\n                 (low, high)\n             );\n@@ -1641,9 +1614,7 @@ impl<T> Weak<T> {\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n-        Weak {\n-            ptr: NonNull::new(usize::MAX as *mut RcBox<T>).expect(\"MAX is not 0\"),\n-        }\n+        Weak { ptr: NonNull::new(usize::MAX as *mut RcBox<T>).expect(\"MAX is not 0\") }\n     }\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n@@ -1781,9 +1752,7 @@ impl<T> Weak<T> {\n             let offset = data_offset(ptr);\n             let fake_ptr = ptr as *mut RcBox<T>;\n             let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n-            Weak {\n-                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n-            }\n+            Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n         }\n     }\n }\n@@ -1838,36 +1807,30 @@ impl<T: ?Sized> Weak<T> {\n     /// [`Weak::new`]: #method.new\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n-        if let Some(inner) = self.inner() {\n-            inner.strong()\n-        } else {\n-            0\n-        }\n+        if let Some(inner) = self.inner() { inner.strong() } else { 0 }\n     }\n \n     /// Gets the number of `Weak` pointers pointing to this allocation.\n     ///\n     /// If no strong pointers remain, this will return zero.\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn weak_count(&self) -> usize {\n-        self.inner().map(|inner| {\n-            if inner.strong() > 0 {\n-                inner.weak() - 1  // subtract the implicit weak ptr\n-            } else {\n-                0\n-            }\n-        }).unwrap_or(0)\n+        self.inner()\n+            .map(|inner| {\n+                if inner.strong() > 0 {\n+                    inner.weak() - 1 // subtract the implicit weak ptr\n+                } else {\n+                    0\n+                }\n+            })\n+            .unwrap_or(0)\n     }\n \n     /// Returns `None` when the pointer is dangling and there is no allocated `RcBox`\n     /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<&RcBox<T>> {\n-        if is_dangling(self.ptr) {\n-            None\n-        } else {\n-            Some(unsafe { self.ptr.as_ref() })\n-        }\n+        if is_dangling(self.ptr) { None } else { Some(unsafe { self.ptr.as_ref() }) }\n     }\n \n     /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n@@ -2035,7 +1998,9 @@ trait RcBoxPtr<T: ?Sized> {\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n         if strong == 0 || strong == usize::max_value() {\n-            unsafe { abort(); }\n+            unsafe {\n+                abort();\n+            }\n         }\n         self.inner().strong.set(strong + 1);\n     }\n@@ -2059,7 +2024,9 @@ trait RcBoxPtr<T: ?Sized> {\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n         if weak == 0 || weak == usize::max_value() {\n-            unsafe { abort(); }\n+            unsafe {\n+                abort();\n+            }\n         }\n         self.inner().weak.set(weak + 1);\n     }\n@@ -2073,9 +2040,7 @@ trait RcBoxPtr<T: ?Sized> {\n impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n-        unsafe {\n-            self.ptr.as_ref()\n-        }\n+        unsafe { self.ptr.as_ref() }\n     }\n }\n \n@@ -2101,7 +2066,7 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n }\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized> Unpin for Rc<T> { }\n+impl<T: ?Sized> Unpin for Rc<T> {}\n \n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Align the unsized value to the end of the `RcBox`."}, {"sha": "56788bb56d5504579b967bbd1b92ecbb79cfb795", "filename": "src/liballoc/rc/tests.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -2,11 +2,11 @@ use super::*;\n \n use std::boxed::Box;\n use std::cell::RefCell;\n-use std::option::Option::{self, None, Some};\n-use std::result::Result::{Err, Ok};\n-use std::mem::drop;\n use std::clone::Clone;\n use std::convert::{From, TryInto};\n+use std::mem::drop;\n+use std::option::Option::{self, None, Some};\n+use std::result::Result::{Err, Ok};\n \n #[test]\n fn test_clone() {\n@@ -341,11 +341,8 @@ fn test_clone_from_slice_panic() {\n         }\n     }\n \n-    let s: &[Fail] = &[\n-        Fail(0, \"foo\".to_string()),\n-        Fail(1, \"bar\".to_string()),\n-        Fail(2, \"baz\".to_string()),\n-    ];\n+    let s: &[Fail] =\n+        &[Fail(0, \"foo\".to_string()), Fail(1, \"bar\".to_string()), Fail(2, \"baz\".to_string())];\n \n     // Should panic, but not cause memory corruption\n     let _r: Rc<[Fail]> = Rc::from(s);"}, {"sha": "843a2f1f8e9fc9e350e03ac12d2de4e182392aa5", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -23,16 +23,15 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n // Many of the usings in this module are only used in the test configuration.\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![allow(unused_imports)]\n \n use core::borrow::{Borrow, BorrowMut};\n-use core::str::pattern::{Pattern, Searcher, ReverseSearcher, DoubleEndedSearcher};\n+use core::iter::FusedIterator;\n use core::mem;\n use core::ptr;\n-use core::iter::FusedIterator;\n+use core::str::pattern::{DoubleEndedSearcher, Pattern, ReverseSearcher, Searcher};\n use core::unicode::conversions;\n \n use crate::borrow::ToOwned;\n@@ -42,34 +41,34 @@ use crate::string::String;\n use crate::vec::Vec;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{FromStr, Utf8Error};\n-#[allow(deprecated)]\n+pub use core::str::pattern;\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+pub use core::str::EncodeUtf16;\n+#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n+pub use core::str::SplitAsciiWhitespace;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{Lines, LinesAny};\n+pub use core::str::SplitWhitespace;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{Split, RSplit};\n+pub use core::str::{from_utf8, from_utf8_mut, Bytes, CharIndices, Chars};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{SplitN, RSplitN};\n+pub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError};\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+pub use core::str::{EscapeDebug, EscapeDefault, EscapeUnicode};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{SplitTerminator, RSplitTerminator};\n+pub use core::str::{FromStr, Utf8Error};\n+#[allow(deprecated)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{Matches, RMatches};\n+pub use core::str::{Lines, LinesAny};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::{MatchIndices, RMatchIndices};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{from_utf8, from_utf8_mut, Chars, CharIndices, Bytes};\n+pub use core::str::{Matches, RMatches};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError};\n+pub use core::str::{RSplit, Split};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::SplitWhitespace;\n+pub use core::str::{RSplitN, SplitN};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::pattern;\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-pub use core::str::EncodeUtf16;\n-#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n-pub use core::str::SplitAsciiWhitespace;\n-#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-pub use core::str::{EscapeDebug, EscapeDefault, EscapeUnicode};\n+pub use core::str::{RSplitTerminator, SplitTerminator};\n \n /// Note: `str` in `Concat<str>` is not meaningful here.\n /// This type parameter of the trait only exists to enable another impl.\n@@ -87,9 +86,7 @@ impl<S: Borrow<str>> Join<&str> for [S] {\n     type Output = String;\n \n     fn join(slice: &Self, sep: &str) -> String {\n-        unsafe {\n-            String::from_utf8_unchecked( join_generic_copy(slice, sep.as_bytes()) )\n-        }\n+        unsafe { String::from_utf8_unchecked(join_generic_copy(slice, sep.as_bytes())) }\n     }\n }\n \n@@ -123,10 +120,10 @@ macro_rules! spezialize_for_lengths {\n macro_rules! copy_slice_and_advance {\n     ($target:expr, $bytes:expr) => {\n         let len = $bytes.len();\n-        let (head, tail) = {$target}.split_at_mut(len);\n+        let (head, tail) = { $target }.split_at_mut(len);\n         head.copy_from_slice($bytes);\n         $target = tail;\n-    }\n+    };\n }\n \n // Optimized join implementation that works for both Vec<T> (T: Copy) and String's inner vec\n@@ -156,11 +153,12 @@ where\n     // if the `len` calculation overflows, we'll panic\n     // we would have run out of memory anyway and the rest of the function requires\n     // the entire Vec pre-allocated for safety\n-    let len =  sep_len.checked_mul(iter.len()).and_then(|n| {\n-            slice.iter()\n-                .map(|s| s.borrow().as_ref().len())\n-                .try_fold(n, usize::checked_add)\n-        }).expect(\"attempt to join into collection with len > usize::MAX\");\n+    let len = sep_len\n+        .checked_mul(iter.len())\n+        .and_then(|n| {\n+            slice.iter().map(|s| s.borrow().as_ref().len()).try_fold(n, usize::checked_add)\n+        })\n+        .expect(\"attempt to join into collection with len > usize::MAX\");\n \n     // crucial for safety\n     let mut result = Vec::with_capacity(len);\n@@ -390,13 +388,13 @@ impl str {\n             // See http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n             // for the definition of `Final_Sigma`.\n             debug_assert!('\u03a3'.len_utf8() == 2);\n-            let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev()) &&\n-                                !case_ignoreable_then_cased(from[i + 2..].chars());\n+            let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev())\n+                && !case_ignoreable_then_cased(from[i + 2..].chars());\n             to.push_str(if is_word_final { \"\u03c2\" } else { \"\u03c3\" });\n         }\n \n         fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n-            use core::unicode::derived_property::{Cased, Case_Ignorable};\n+            use core::unicode::derived_property::{Case_Ignorable, Cased};\n             match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n                 Some(c) => Cased(c),\n                 None => false,"}, {"sha": "96f871d88970855d9cbf51f2ea6d86ad05b64a6a", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -50,15 +50,15 @@ use core::char::{decode_utf16, REPLACEMENT_CHARACTER};\n use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n-use core::ops::{self, Add, AddAssign, Index, IndexMut, RangeBounds};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{self, Add, AddAssign, Index, IndexMut, RangeBounds};\n use core::ptr;\n-use core::str::{pattern::Pattern, lossy};\n+use core::str::{lossy, pattern::Pattern};\n \n use crate::borrow::{Cow, ToOwned};\n-use crate::collections::TryReserveError;\n use crate::boxed::Box;\n-use crate::str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n+use crate::collections::TryReserveError;\n+use crate::str::{self, from_boxed_utf8_unchecked, Chars, FromStr, Utf8Error};\n use crate::vec::Vec;\n \n /// A UTF-8 encoded, growable string.\n@@ -491,12 +491,7 @@ impl String {\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n         match str::from_utf8(&vec) {\n             Ok(..) => Ok(String { vec }),\n-            Err(e) => {\n-                Err(FromUtf8Error {\n-                    bytes: vec,\n-                    error: e,\n-                })\n-            }\n+            Err(e) => Err(FromUtf8Error { bytes: vec, error: e }),\n         }\n     }\n \n@@ -985,7 +980,7 @@ impl String {\n     /// }\n     /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n     /// ```\n-    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n     pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.vec.try_reserve(additional)\n     }\n@@ -1023,8 +1018,8 @@ impl String {\n     /// }\n     /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n     /// ```\n-    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.vec.try_reserve_exact(additional)\n     }\n \n@@ -1072,7 +1067,7 @@ impl String {\n     /// assert!(s.capacity() >= 3);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"56431\")]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n         self.vec.shrink_to(min_capacity)\n     }\n@@ -1222,9 +1217,7 @@ impl String {\n         let next = idx + ch.len_utf8();\n         let len = self.len();\n         unsafe {\n-            ptr::copy(self.vec.as_ptr().add(next),\n-                      self.vec.as_mut_ptr().add(idx),\n-                      len - next);\n+            ptr::copy(self.vec.as_ptr().add(next), self.vec.as_mut_ptr().add(idx), len - next);\n             self.vec.set_len(len - (next - idx));\n         }\n         ch\n@@ -1258,25 +1251,26 @@ impl String {\n     #[inline]\n     #[stable(feature = \"string_retain\", since = \"1.26.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n-        where F: FnMut(char) -> bool\n+    where\n+        F: FnMut(char) -> bool,\n     {\n         let len = self.len();\n         let mut del_bytes = 0;\n         let mut idx = 0;\n \n         while idx < len {\n-            let ch = unsafe {\n-                self.get_unchecked(idx..len).chars().next().unwrap()\n-            };\n+            let ch = unsafe { self.get_unchecked(idx..len).chars().next().unwrap() };\n             let ch_len = ch.len_utf8();\n \n             if !f(ch) {\n                 del_bytes += ch_len;\n             } else if del_bytes > 0 {\n                 unsafe {\n-                    ptr::copy(self.vec.as_ptr().add(idx),\n-                              self.vec.as_mut_ptr().add(idx - del_bytes),\n-                              ch_len);\n+                    ptr::copy(\n+                        self.vec.as_ptr().add(idx),\n+                        self.vec.as_mut_ptr().add(idx - del_bytes),\n+                        ch_len,\n+                    );\n                 }\n             }\n \n@@ -1285,7 +1279,9 @@ impl String {\n         }\n \n         if del_bytes > 0 {\n-            unsafe { self.vec.set_len(len - del_bytes); }\n+            unsafe {\n+                self.vec.set_len(len - del_bytes);\n+            }\n         }\n     }\n \n@@ -1331,12 +1327,8 @@ impl String {\n         let amt = bytes.len();\n         self.vec.reserve(amt);\n \n-        ptr::copy(self.vec.as_ptr().add(idx),\n-                  self.vec.as_mut_ptr().add(idx + amt),\n-                  len - idx);\n-        ptr::copy(bytes.as_ptr(),\n-                  self.vec.as_mut_ptr().add(idx),\n-                  amt);\n+        ptr::copy(self.vec.as_ptr().add(idx), self.vec.as_mut_ptr().add(idx + amt), len - idx);\n+        ptr::copy(bytes.as_ptr(), self.vec.as_mut_ptr().add(idx), amt);\n         self.vec.set_len(len + amt);\n     }\n \n@@ -1531,7 +1523,8 @@ impl String {\n     /// ```\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<'_>\n-        where R: RangeBounds<usize>\n+    where\n+        R: RangeBounds<usize>,\n     {\n         // Memory safety\n         //\n@@ -1557,12 +1550,7 @@ impl String {\n         // slicing does the appropriate bounds checks\n         let chars_iter = self[start..end].chars();\n \n-        Drain {\n-            start,\n-            end,\n-            iter: chars_iter,\n-            string: self_ptr,\n-        }\n+        Drain { start, end, iter: chars_iter, string: self_ptr }\n     }\n \n     /// Removes the specified range in the string,\n@@ -1591,27 +1579,26 @@ impl String {\n     /// ```\n     #[stable(feature = \"splice\", since = \"1.27.0\")]\n     pub fn replace_range<R>(&mut self, range: R, replace_with: &str)\n-        where R: RangeBounds<usize>\n+    where\n+        R: RangeBounds<usize>,\n     {\n         // Memory safety\n         //\n         // Replace_range does not have the memory safety issues of a vector Splice.\n         // of the vector version. The data is just plain bytes.\n \n         match range.start_bound() {\n-             Included(&n) => assert!(self.is_char_boundary(n)),\n-             Excluded(&n) => assert!(self.is_char_boundary(n + 1)),\n-             Unbounded => {},\n+            Included(&n) => assert!(self.is_char_boundary(n)),\n+            Excluded(&n) => assert!(self.is_char_boundary(n + 1)),\n+            Unbounded => {}\n         };\n         match range.end_bound() {\n-             Included(&n) => assert!(self.is_char_boundary(n + 1)),\n-             Excluded(&n) => assert!(self.is_char_boundary(n)),\n-             Unbounded => {},\n+            Included(&n) => assert!(self.is_char_boundary(n + 1)),\n+            Excluded(&n) => assert!(self.is_char_boundary(n)),\n+            Unbounded => {}\n         };\n \n-        unsafe {\n-            self.as_mut_vec()\n-        }.splice(range, replace_with.bytes());\n+        unsafe { self.as_mut_vec() }.splice(range, replace_with.bytes());\n     }\n \n     /// Converts this `String` into a [`Box`]`<`[`str`]`>`.\n@@ -1840,9 +1827,11 @@ impl<'a> Extend<Cow<'a, str>> for String {\n }\n \n /// A convenience impl that delegates to the impl for `&str`\n-#[unstable(feature = \"pattern\",\n-           reason = \"API not fully fleshed out and ready to be stabilized\",\n-           issue = \"27721\")]\n+#[unstable(\n+    feature = \"pattern\",\n+    reason = \"API not fully fleshed out and ready to be stabilized\",\n+    issue = \"27721\"\n+)]\n impl<'a, 'b> Pattern<'a> for &'b String {\n     type Searcher = <&'b str as Pattern<'a>>::Searcher;\n \n@@ -1879,21 +1868,28 @@ macro_rules! impl_eq {\n         #[allow(unused_lifetimes)]\n         impl<'a, 'b> PartialEq<$rhs> for $lhs {\n             #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n+            fn eq(&self, other: &$rhs) -> bool {\n+                PartialEq::eq(&self[..], &other[..])\n+            }\n             #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&self[..], &other[..]) }\n+            fn ne(&self, other: &$rhs) -> bool {\n+                PartialEq::ne(&self[..], &other[..])\n+            }\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(unused_lifetimes)]\n         impl<'a, 'b> PartialEq<$lhs> for $rhs {\n             #[inline]\n-            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n+            fn eq(&self, other: &$lhs) -> bool {\n+                PartialEq::eq(&self[..], &other[..])\n+            }\n             #[inline]\n-            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&self[..], &other[..]) }\n+            fn ne(&self, other: &$lhs) -> bool {\n+                PartialEq::ne(&self[..], &other[..])\n+            }\n         }\n-\n-    }\n+    };\n }\n \n impl_eq! { String, str }\n@@ -2134,7 +2130,6 @@ impl FromStr for String {\n     }\n }\n \n-\n /// A trait for converting a value to a `String`.\n ///\n /// This trait is automatically implemented for any type which implements the\n@@ -2175,7 +2170,7 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n         use fmt::Write;\n         let mut buf = String::new();\n         buf.write_fmt(format_args!(\"{}\", self))\n-           .expect(\"a Display implementation returned an error unexpectedly\");\n+            .expect(\"a Display implementation returned an error unexpectedly\");\n         buf.shrink_to_fit();\n         buf\n     }"}, {"sha": "dc53ad28407276827775435f9c0c12225b302954", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 56, "deletions": 95, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -8,24 +8,24 @@\n \n use core::any::Any;\n use core::array::LengthAtMost32;\n-use core::sync::atomic;\n-use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n-use core::fmt;\n use core::cmp::Ordering;\n-use core::iter;\n+use core::convert::{From, TryFrom};\n+use core::fmt;\n+use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n+use core::iter;\n+use core::marker::{PhantomData, Unpin, Unsize};\n use core::mem::{self, align_of, align_of_val, size_of_val};\n-use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n+use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::marker::{Unpin, Unsize, PhantomData};\n-use core::hash::{Hash, Hasher};\n-use core::{isize, usize};\n-use core::convert::{From, TryFrom};\n use core::slice::{self, from_raw_parts_mut};\n+use core::sync::atomic;\n+use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n+use core::{isize, usize};\n \n-use crate::alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n+use crate::alloc::{box_free, handle_alloc_error, Alloc, Global, Layout};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n use crate::string::String;\n@@ -211,10 +211,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Arc<U>> for Arc<T> {}\n \n impl<T: ?Sized> Arc<T> {\n     fn from_inner(ptr: NonNull<ArcInner<T>>) -> Self {\n-        Self {\n-            ptr,\n-            phantom: PhantomData,\n-        }\n+        Self { ptr, phantom: PhantomData }\n     }\n \n     unsafe fn from_ptr(ptr: *mut ArcInner<T>) -> Self {\n@@ -334,10 +331,9 @@ impl<T> Arc<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {\n         unsafe {\n-            Arc::from_ptr(Arc::allocate_for_layout(\n-                Layout::new::<T>(),\n-                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n-            ))\n+            Arc::from_ptr(Arc::allocate_for_layout(Layout::new::<T>(), |mem| {\n+                mem as *mut ArcInner<mem::MaybeUninit<T>>\n+            }))\n         }\n     }\n \n@@ -446,9 +442,7 @@ impl<T> Arc<[T]> {\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n-        unsafe {\n-            Arc::from_ptr(Arc::allocate_for_slice(len))\n-        }\n+        unsafe { Arc::from_ptr(Arc::allocate_for_slice(len)) }\n     }\n }\n \n@@ -772,18 +766,15 @@ impl<T: ?Sized> Arc<T> {\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n     unsafe fn allocate_for_layout(\n         value_layout: Layout,\n-        mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>\n+        mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n     ) -> *mut ArcInner<T> {\n         // Calculate layout using the given value layout.\n         // Previously, layout was calculated on the expression\n         // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n         // reference (see #54908).\n-        let layout = Layout::new::<ArcInner<()>>()\n-            .extend(value_layout).unwrap().0\n-            .pad_to_align();\n+        let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let mem = Global.alloc(layout)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let mem = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n         let inner = mem_to_arcinner(mem.as_ptr());\n@@ -798,10 +789,9 @@ impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n-        Self::allocate_for_layout(\n-            Layout::for_value(&*ptr),\n-            |mem| set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>,\n-        )\n+        Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n+            set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>\n+        })\n     }\n \n     fn from_box(v: Box<T>) -> Arc<T> {\n@@ -816,7 +806,8 @@ impl<T: ?Sized> Arc<T> {\n             ptr::copy_nonoverlapping(\n                 bptr as *const T as *const u8,\n                 &mut (*ptr).data as *mut _ as *mut u8,\n-                value_size);\n+                value_size,\n+            );\n \n             // Free the allocation without dropping its contents\n             box_free(box_unique);\n@@ -829,10 +820,9 @@ impl<T: ?Sized> Arc<T> {\n impl<T> Arc<[T]> {\n     /// Allocates an `ArcInner<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n-        Self::allocate_for_layout(\n-            Layout::array::<T>(len).unwrap(),\n-            |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>,\n-        )\n+        Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n+            ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>\n+        })\n     }\n }\n \n@@ -852,10 +842,7 @@ impl<T> Arc<[T]> {\n     unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n         let ptr = Self::allocate_for_slice(v.len());\n \n-        ptr::copy_nonoverlapping(\n-            v.as_ptr(),\n-            &mut (*ptr).data as *mut [T] as *mut T,\n-            v.len());\n+        ptr::copy_nonoverlapping(v.as_ptr(), &mut (*ptr).data as *mut [T] as *mut T, v.len());\n \n         Self::from_ptr(ptr)\n     }\n@@ -893,12 +880,7 @@ impl<T> Arc<[T]> {\n         // Pointer to first element\n         let elems = &mut (*ptr).data as *mut [T] as *mut T;\n \n-        let mut guard = Guard {\n-            mem: NonNull::new_unchecked(mem),\n-            elems,\n-            layout,\n-            n_elems: 0,\n-        };\n+        let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };\n \n         for (i, item) in iter.enumerate() {\n             ptr::write(elems.add(i), item);\n@@ -920,9 +902,7 @@ trait ArcFromSlice<T> {\n impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n     #[inline]\n     default fn from_slice(v: &[T]) -> Self {\n-        unsafe {\n-            Self::from_iter_exact(v.iter().cloned(), v.len())\n-        }\n+        unsafe { Self::from_iter_exact(v.iter().cloned(), v.len()) }\n     }\n }\n \n@@ -1079,9 +1059,7 @@ impl<T: Clone> Arc<T> {\n \n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n-        unsafe {\n-            &mut this.ptr.as_mut().data\n-        }\n+        unsafe { &mut this.ptr.as_mut().data }\n     }\n }\n \n@@ -1121,9 +1099,7 @@ impl<T: ?Sized> Arc<T> {\n             // reference count is guaranteed to be 1 at this point, and we required\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n-            unsafe {\n-                Some(Arc::get_mut_unchecked(this))\n-            }\n+            unsafe { Some(Arc::get_mut_unchecked(this)) }\n         } else {\n             None\n         }\n@@ -1317,9 +1293,7 @@ impl<T> Weak<T> {\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n-        Weak {\n-            ptr: NonNull::new(usize::MAX as *mut ArcInner<T>).expect(\"MAX is not 0\"),\n-        }\n+        Weak { ptr: NonNull::new(usize::MAX as *mut ArcInner<T>).expect(\"MAX is not 0\") }\n     }\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n@@ -1458,9 +1432,7 @@ impl<T> Weak<T> {\n             let offset = data_offset(ptr);\n             let fake_ptr = ptr as *mut ArcInner<T>;\n             let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n-            Weak {\n-                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n-            }\n+            Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n         }\n     }\n }\n@@ -1531,11 +1503,7 @@ impl<T: ?Sized> Weak<T> {\n     /// [`Weak::new`]: #method.new\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n-        if let Some(inner) = self.inner() {\n-            inner.strong.load(SeqCst)\n-        } else {\n-            0\n-        }\n+        if let Some(inner) = self.inner() { inner.strong.load(SeqCst) } else { 0 }\n     }\n \n     /// Gets an approximation of the number of `Weak` pointers pointing to this\n@@ -1553,31 +1521,29 @@ impl<T: ?Sized> Weak<T> {\n     /// [`Weak::new`]: #method.new\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn weak_count(&self) -> usize {\n-        self.inner().map(|inner| {\n-            let weak = inner.weak.load(SeqCst);\n-            let strong = inner.strong.load(SeqCst);\n-            if strong == 0 {\n-                0\n-            } else {\n-                // Since we observed that there was at least one strong pointer\n-                // after reading the weak count, we know that the implicit weak\n-                // reference (present whenever any strong references are alive)\n-                // was still around when we observed the weak count, and can\n-                // therefore safely subtract it.\n-                weak - 1\n-            }\n-        }).unwrap_or(0)\n+        self.inner()\n+            .map(|inner| {\n+                let weak = inner.weak.load(SeqCst);\n+                let strong = inner.strong.load(SeqCst);\n+                if strong == 0 {\n+                    0\n+                } else {\n+                    // Since we observed that there was at least one strong pointer\n+                    // after reading the weak count, we know that the implicit weak\n+                    // reference (present whenever any strong references are alive)\n+                    // was still around when we observed the weak count, and can\n+                    // therefore safely subtract it.\n+                    weak - 1\n+                }\n+            })\n+            .unwrap_or(0)\n     }\n \n     /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,\n     /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<&ArcInner<T>> {\n-        if is_dangling(self.ptr) {\n-            None\n-        } else {\n-            Some(unsafe { self.ptr.as_ref() })\n-        }\n+        if is_dangling(self.ptr) { None } else { Some(unsafe { self.ptr.as_ref() }) }\n     }\n \n     /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n@@ -1722,17 +1688,11 @@ impl<T: ?Sized> Drop for Weak<T> {\n         // weak count can only be locked if there was precisely one weak ref,\n         // meaning that drop could only subsequently run ON that remaining weak\n         // ref, which can only happen after the lock is released.\n-        let inner = if let Some(inner) = self.inner() {\n-            inner\n-        } else {\n-            return\n-        };\n+        let inner = if let Some(inner) = self.inner() { inner } else { return };\n \n         if inner.weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            unsafe {\n-                Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n-            }\n+            unsafe { Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref())) }\n         }\n     }\n }\n@@ -2110,7 +2070,8 @@ impl<T, I: iter::TrustedLen<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n         let (low, high) = iter.size_hint();\n         if let Some(high) = high {\n             debug_assert_eq!(\n-                low, high,\n+                low,\n+                high,\n                 \"TrustedLen iterator's size hint is not exact: {:?}\",\n                 (low, high)\n             );\n@@ -2155,7 +2116,7 @@ impl<T: ?Sized> AsRef<T> for Arc<T> {\n }\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized> Unpin for Arc<T> { }\n+impl<T: ?Sized> Unpin for Arc<T> {}\n \n /// Computes the offset of the data field within `ArcInner`.\n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {"}, {"sha": "edc2820ee22f1e00743082da484220076b7ac67b", "filename": "src/liballoc/sync/tests.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -2,14 +2,17 @@ use super::*;\n \n use std::boxed::Box;\n use std::clone::Clone;\n-use std::sync::mpsc::channel;\n+use std::convert::{From, TryInto};\n use std::mem::drop;\n use std::ops::Drop;\n use std::option::Option::{self, None, Some};\n-use std::sync::atomic::{self, Ordering::{Acquire, SeqCst}};\n-use std::thread;\n+use std::sync::atomic::{\n+    self,\n+    Ordering::{Acquire, SeqCst},\n+};\n+use std::sync::mpsc::channel;\n use std::sync::Mutex;\n-use std::convert::{From, TryInto};\n+use std::thread;\n \n use crate::vec::Vec;\n \n@@ -394,11 +397,8 @@ fn test_clone_from_slice_panic() {\n         }\n     }\n \n-    let s: &[Fail] = &[\n-        Fail(0, \"foo\".to_string()),\n-        Fail(1, \"bar\".to_string()),\n-        Fail(2, \"baz\".to_string()),\n-    ];\n+    let s: &[Fail] =\n+        &[Fail(0, \"foo\".to_string()), Fail(1, \"bar\".to_string()), Fail(2, \"baz\".to_string())];\n \n     // Should panic, but not cause memory corruption\n     let _r: Arc<[Fail]> = Arc::from(s);"}, {"sha": "f49ca7139212f4bc1305e373272f23ac7c4b1d03", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,5 +1,5 @@\n-use std::collections::BinaryHeap;\n use std::collections::binary_heap::{Drain, PeekMut};\n+use std::collections::BinaryHeap;\n use std::iter::TrustedLen;\n \n #[test]\n@@ -349,10 +349,10 @@ fn assert_covariance() {\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n fn panic_safe() {\n+    use rand::{seq::SliceRandom, thread_rng};\n     use std::cmp;\n     use std::panic::{self, AssertUnwindSafe};\n     use std::sync::atomic::{AtomicUsize, Ordering};\n-    use rand::{thread_rng, seq::SliceRandom};\n \n     static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n \n@@ -389,10 +389,8 @@ fn panic_safe() {\n         for i in 1..=DATASZ {\n             DROP_COUNTER.store(0, Ordering::SeqCst);\n \n-            let mut panic_ords: Vec<_> = data.iter()\n-                                             .filter(|&&x| x != i)\n-                                             .map(|&x| PanicOrd(x, false))\n-                                             .collect();\n+            let mut panic_ords: Vec<_> =\n+                data.iter().filter(|&&x| x != i).map(|&x| PanicOrd(x, false)).collect();\n             let panic_item = PanicOrd(i, true);\n \n             // heapify the sane items"}, {"sha": "3177f19927edaafa00f295f9fd4e9430fde58bd1", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,8 +1,8 @@\n-use std::collections::BTreeMap;\n use std::collections::btree_map::Entry::{Occupied, Vacant};\n+use std::collections::BTreeMap;\n+use std::iter::FromIterator;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::rc::Rc;\n-use std::iter::FromIterator;\n \n use super::DeterministicRng;\n \n@@ -101,7 +101,8 @@ fn test_iter() {\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test<T>(size: usize, mut iter: T)\n-        where T: Iterator<Item = (usize, usize)>\n+    where\n+        T: Iterator<Item = (usize, usize)>,\n     {\n         for i in 0..size {\n             assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n@@ -126,7 +127,8 @@ fn test_iter_rev() {\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test<T>(size: usize, mut iter: T)\n-        where T: Iterator<Item = (usize, usize)>\n+    where\n+        T: Iterator<Item = (usize, usize)>,\n     {\n         for i in 0..size {\n             assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n@@ -165,7 +167,8 @@ fn test_iter_mixed() {\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test<T>(size: usize, mut iter: T)\n-        where T: Iterator<Item = (usize, usize)> + DoubleEndedIterator\n+    where\n+        T: Iterator<Item = (usize, usize)> + DoubleEndedIterator,\n     {\n         for i in 0..size / 4 {\n             assert_eq!(iter.size_hint(), (size - i * 2, Some(size - i * 2)));\n@@ -207,8 +210,9 @@ fn test_range_inclusive() {\n     let map: BTreeMap<_, _> = (0..=size).map(|i| (i, i)).collect();\n \n     fn check<'a, L, R>(lhs: L, rhs: R)\n-        where L: IntoIterator<Item=(&'a i32, &'a i32)>,\n-              R: IntoIterator<Item=(&'a i32, &'a i32)>,\n+    where\n+        L: IntoIterator<Item = (&'a i32, &'a i32)>,\n+        R: IntoIterator<Item = (&'a i32, &'a i32)>,\n     {\n         let lhs: Vec<_> = lhs.into_iter().collect();\n         let rhs: Vec<_> = rhs.into_iter().collect();\n@@ -313,7 +317,7 @@ fn test_range_borrowed_key() {\n     map.insert(\"coyote\".to_string(), 3);\n     map.insert(\"dingo\".to_string(), 4);\n     // NOTE: would like to use simply \"b\"..\"d\" here...\n-    let mut iter = map.range::<str, _>((Included(\"b\"),Excluded(\"d\")));\n+    let mut iter = map.range::<str, _>((Included(\"b\"), Excluded(\"d\")));\n     assert_eq!(iter.next(), Some((&\"baboon\".to_string(), &2)));\n     assert_eq!(iter.next(), Some((&\"coyote\".to_string(), &3)));\n     assert_eq!(iter.next(), None);\n@@ -408,7 +412,6 @@ fn test_entry() {\n     assert_eq!(map.get(&1).unwrap(), &100);\n     assert_eq!(map.len(), 6);\n \n-\n     // Existing key (update)\n     match map.entry(2) {\n         Vacant(_) => unreachable!(),\n@@ -430,7 +433,6 @@ fn test_entry() {\n     assert_eq!(map.get(&3), None);\n     assert_eq!(map.len(), 5);\n \n-\n     // Inexistent key (insert)\n     match map.entry(10) {\n         Occupied(_) => unreachable!(),\n@@ -555,7 +557,7 @@ fn test_clone() {\n #[test]\n #[allow(dead_code)]\n fn test_variance() {\n-    use std::collections::btree_map::{Iter, IntoIter, Range, Keys, Values};\n+    use std::collections::btree_map::{IntoIter, Iter, Keys, Range, Values};\n \n     fn map_key<'new>(v: BTreeMap<&'static str, ()>) -> BTreeMap<&'new str, ()> {\n         v\n@@ -649,7 +651,6 @@ fn test_first_last_entry() {\n     assert_eq!(a.last_entry().unwrap().key(), &1);\n }\n \n-\n macro_rules! create_append_test {\n     ($name:ident, $len:expr) => {\n         #[test]\n@@ -661,7 +662,7 @@ macro_rules! create_append_test {\n \n             let mut b = BTreeMap::new();\n             for i in 5..$len {\n-                b.insert(i, 2*i);\n+                b.insert(i, 2 * i);\n             }\n \n             a.append(&mut b);\n@@ -673,12 +674,12 @@ macro_rules! create_append_test {\n                 if i < 5 {\n                     assert_eq!(a[&i], i);\n                 } else {\n-                    assert_eq!(a[&i], 2*i);\n+                    assert_eq!(a[&i], 2 * i);\n                 }\n             }\n \n-            assert_eq!(a.remove(&($len-1)), Some(2*($len-1)));\n-            assert_eq!(a.insert($len-1, 20), None);\n+            assert_eq!(a.remove(&($len - 1)), Some(2 * ($len - 1)));\n+            assert_eq!(a.insert($len - 1, 20), None);\n         }\n     };\n }"}, {"sha": "ed29ed62b1b3e961c1e019c8c0cea406dd708137", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -32,7 +32,8 @@ fn test_hash() {\n }\n \n fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F)\n-    where F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, &mut dyn FnMut(&i32) -> bool) -> bool\n+where\n+    F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, &mut dyn FnMut(&i32) -> bool) -> bool,\n {\n     let mut set_a = BTreeSet::new();\n     let mut set_b = BTreeSet::new();\n@@ -45,15 +46,13 @@ fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F)\n     }\n \n     let mut i = 0;\n-    f(&set_a,\n-      &set_b,\n-      &mut |&x| {\n-          if i < expected.len() {\n-              assert_eq!(x, expected[i]);\n-          }\n-          i += 1;\n-          true\n-      });\n+    f(&set_a, &set_b, &mut |&x| {\n+        if i < expected.len() {\n+            assert_eq!(x, expected[i]);\n+        }\n+        i += 1;\n+        true\n+    });\n     assert_eq!(i, expected.len());\n }\n \n@@ -68,11 +67,10 @@ fn test_intersection() {\n     check_intersection(&[], &[1, 2, 3], &[]);\n     check_intersection(&[2], &[1, 2, 3], &[2]);\n     check_intersection(&[1, 2, 3], &[2], &[2]);\n-    check_intersection(&[11, 1, 3, 77, 103, 5, -5],\n-                       &[2, 11, 77, -9, -42, 5, 3],\n-                       &[3, 5, 11, 77]);\n+    check_intersection(&[11, 1, 3, 77, 103, 5, -5], &[2, 11, 77, -9, -42, 5, 3], &[3, 5, 11, 77]);\n \n-    if cfg!(miri) { // Miri is too slow\n+    if cfg!(miri) {\n+        // Miri is too slow\n         return;\n     }\n \n@@ -87,9 +85,7 @@ fn test_intersection() {\n     check_intersection(&large, &[99], &[99]);\n     check_intersection(&[100], &large, &[]);\n     check_intersection(&large, &[100], &[]);\n-    check_intersection(&[11, 5000, 1, 3, 77, 8924],\n-                       &large,\n-                       &[1, 3, 11, 77]);\n+    check_intersection(&[11, 5000, 1, 3, 77, 8924], &large, &[1, 3, 11, 77]);\n }\n \n #[test]\n@@ -121,11 +117,14 @@ fn test_difference() {\n     check_difference(&[1, 3, 5, 9, 11], &[3, 6, 9], &[1, 5, 11]);\n     check_difference(&[1, 3, 5, 9, 11], &[0, 1], &[3, 5, 9, 11]);\n     check_difference(&[1, 3, 5, 9, 11], &[11, 12], &[1, 3, 5, 9]);\n-    check_difference(&[-5, 11, 22, 33, 40, 42],\n-                     &[-12, -5, 14, 23, 34, 38, 39, 50],\n-                     &[11, 22, 33, 40, 42]);\n-\n-    if cfg!(miri) { // Miri is too slow\n+    check_difference(\n+        &[-5, 11, 22, 33, 40, 42],\n+        &[-12, -5, 14, 23, 34, 38, 39, 50],\n+        &[11, 22, 33, 40, 42],\n+    );\n+\n+    if cfg!(miri) {\n+        // Miri is too slow\n         return;\n     }\n \n@@ -135,9 +134,7 @@ fn test_difference() {\n     check_difference(&[0], &large, &[]);\n     check_difference(&[99], &large, &[]);\n     check_difference(&[100], &large, &[100]);\n-    check_difference(&[11, 5000, 1, 3, 77, 8924],\n-                     &large,\n-                     &[5000, 8924]);\n+    check_difference(&[11, 5000, 1, 3, 77, 8924], &large, &[5000, 8924]);\n     check_difference(&large, &[], &large);\n     check_difference(&large, &[-1], &large);\n     check_difference(&large, &[100], &large);\n@@ -216,9 +213,7 @@ fn test_symmetric_difference() {\n     check_symmetric_difference(&[], &[], &[]);\n     check_symmetric_difference(&[1, 2, 3], &[2], &[1, 3]);\n     check_symmetric_difference(&[2], &[1, 2, 3], &[1, 3]);\n-    check_symmetric_difference(&[1, 3, 5, 9, 11],\n-                               &[-2, 3, 9, 14, 22],\n-                               &[-2, 1, 5, 11, 14, 22]);\n+    check_symmetric_difference(&[1, 3, 5, 9, 11], &[-2, 3, 9, 14, 22], &[-2, 1, 5, 11, 14, 22]);\n }\n \n #[test]\n@@ -242,9 +237,11 @@ fn test_union() {\n     check_union(&[], &[], &[]);\n     check_union(&[1, 2, 3], &[2], &[1, 2, 3]);\n     check_union(&[2], &[1, 2, 3], &[1, 2, 3]);\n-    check_union(&[1, 3, 5, 9, 11, 16, 19, 24],\n-                &[-2, 1, 5, 9, 13, 19],\n-                &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n+    check_union(\n+        &[1, 3, 5, 9, 11, 16, 19, 24],\n+        &[-2, 1, 5, 9, 13, 19],\n+        &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24],\n+    );\n }\n \n #[test]\n@@ -285,14 +282,14 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[1, 2], &[1]), false);\n     assert_eq!(is_subset(&[1, 2], &[1, 2]), true);\n     assert_eq!(is_subset(&[1, 2], &[2, 3]), false);\n-    assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n-                         &[-12, -5, 11, 14, 22, 23, 33, 34, 38, 39, 40, 42]),\n-               true);\n-    assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n-                         &[-12, -5, 11, 14, 22, 23, 34, 38]),\n-               false);\n-\n-    if cfg!(miri) { // Miri is too slow\n+    assert_eq!(\n+        is_subset(&[-5, 11, 22, 33, 40, 42], &[-12, -5, 11, 14, 22, 23, 33, 34, 38, 39, 40, 42]),\n+        true\n+    );\n+    assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42], &[-12, -5, 11, 14, 22, 23, 34, 38]), false);\n+\n+    if cfg!(miri) {\n+        // Miri is too slow\n         return;\n     }\n "}, {"sha": "43cd7187823f0ad0b395dde8b5ce8b7704217cc4", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,4 +1,4 @@\n-use std::alloc::{Global, Alloc, Layout, System};\n+use std::alloc::{Alloc, Global, Layout, System};\n \n /// Issue #45955 and #62251.\n #[test]\n@@ -12,16 +12,23 @@ fn std_heap_overaligned_request() {\n }\n \n fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n-    for &align in &[4, 8, 16, 32] { // less than and bigger than `MIN_ALIGN`\n-        for &size in &[align/2, align-1] { // size less than alignment\n+    for &align in &[4, 8, 16, 32] {\n+        // less than and bigger than `MIN_ALIGN`\n+        for &size in &[align / 2, align - 1] {\n+            // size less than alignment\n             let iterations = 128;\n             unsafe {\n-                let pointers: Vec<_> = (0..iterations).map(|_| {\n-                    allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n-                }).collect();\n+                let pointers: Vec<_> = (0..iterations)\n+                    .map(|_| {\n+                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n+                    })\n+                    .collect();\n                 for &ptr in &pointers {\n-                    assert_eq!((ptr.as_ptr() as usize) % align, 0,\n-                               \"Got a pointer less aligned than requested\")\n+                    assert_eq!(\n+                        (ptr.as_ptr() as usize) % align,\n+                        0,\n+                        \"Got a pointer less aligned than requested\"\n+                    )\n                 }\n \n                 // Clean up"}, {"sha": "3fdee8bbfdf107c96dadc3cd809504df7b6edbf3", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -12,8 +12,8 @@\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(binary_heap_drain_sorted)]\n \n-use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n+use std::hash::{Hash, Hasher};\n \n mod arc;\n mod binary_heap;\n@@ -27,8 +27,8 @@ mod rc;\n mod slice;\n mod str;\n mod string;\n-mod vec_deque;\n mod vec;\n+mod vec_deque;\n \n fn hash<T: Hash>(t: &T) -> u64 {\n     let mut s = DefaultHasher::new();"}, {"sha": "b7736515b262a17e7c7bbedf16657c9e16fa2563", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -531,7 +531,6 @@ fn drain_filter_complex() {\n     }\n }\n \n-\n #[test]\n fn test_drop() {\n     static mut DROPS: i32 = 0;"}, {"sha": "51ddb5e7a4ec68852cb6db7bffe6df21baa41eca", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 116, "deletions": 78, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -3,11 +3,11 @@ use std::cmp::Ordering::{self, Equal, Greater, Less};\n use std::mem;\n use std::panic;\n use std::rc::Rc;\n-use std::sync::atomic::{Ordering::Relaxed, AtomicUsize};\n+use std::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n \n-use rand::{Rng, RngCore, thread_rng};\n-use rand::seq::SliceRandom;\n use rand::distributions::Standard;\n+use rand::seq::SliceRandom;\n+use rand::{thread_rng, Rng, RngCore};\n \n fn square(n: usize) -> usize {\n     n * n\n@@ -231,7 +231,6 @@ fn test_slice_to() {\n     assert_eq!(&vec[..0], b);\n }\n \n-\n #[test]\n fn test_pop() {\n     let mut v = vec![5];\n@@ -395,10 +394,8 @@ fn test_sort() {\n     for len in (2..25).chain(500..510) {\n         for &modulus in &[5, 10, 100, 1000] {\n             for _ in 0..10 {\n-                let orig: Vec<_> = rng.sample_iter::<i32, _>(&Standard)\n-                    .map(|x| x % modulus)\n-                    .take(len)\n-                    .collect();\n+                let orig: Vec<_> =\n+                    rng.sample_iter::<i32, _>(&Standard).map(|x| x % modulus).take(len).collect();\n \n                 // Sort in default order.\n                 let mut v = orig.clone();\n@@ -543,7 +540,7 @@ fn test_rotate_left() {\n \n     // non-small prime rotation, has a few rounds of swapping\n     v = (389..1000).chain(0..389).collect();\n-    v.rotate_left(1000-389);\n+    v.rotate_left(1000 - 389);\n     assert_eq!(v, expected);\n }\n \n@@ -697,7 +694,7 @@ macro_rules! assert_order {\n     (Equal, $a:expr, $b:expr) => {\n         assert_eq!($a.cmp($b), Equal);\n         assert_eq!($a, $b);\n-    }\n+    };\n }\n \n #[test]\n@@ -714,7 +711,6 @@ fn test_total_ord_u8() {\n     assert_order!(Greater, &[2u8, 2][..], &c[..]);\n }\n \n-\n #[test]\n fn test_total_ord_i32() {\n     let c = &[1, 2, 3];\n@@ -804,7 +800,6 @@ fn test_mut_iterator() {\n \n #[test]\n fn test_rev_iterator() {\n-\n     let xs = [1, 2, 5, 10, 11];\n     let ys = [11, 10, 5, 2, 1];\n     let mut i = 0;\n@@ -827,15 +822,13 @@ fn test_mut_rev_iterator() {\n #[test]\n fn test_move_iterator() {\n     let xs = vec![1, 2, 3, 4, 5];\n-    assert_eq!(xs.into_iter().fold(0, |a: usize, b: usize| 10 * a + b),\n-               12345);\n+    assert_eq!(xs.into_iter().fold(0, |a: usize, b: usize| 10 * a + b), 12345);\n }\n \n #[test]\n fn test_move_rev_iterator() {\n     let xs = vec![1, 2, 3, 4, 5];\n-    assert_eq!(xs.into_iter().rev().fold(0, |a: usize, b: usize| 10 * a + b),\n-               54321);\n+    assert_eq!(xs.into_iter().rev().fold(0, |a: usize, b: usize| 10 * a + b), 54321);\n }\n \n #[test]\n@@ -879,11 +872,9 @@ fn test_splitnator_mut() {\n     let xs = &mut [1, 2, 3, 4, 5];\n \n     let splits: &[&mut [_]] = &[&mut [1, 2, 3, 4, 5]];\n-    assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-               splits);\n+    assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n     let splits: &[&mut [_]] = &[&mut [1], &mut [3, 4, 5]];\n-    assert_eq!(xs.splitn_mut(2, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-               splits);\n+    assert_eq!(xs.splitn_mut(2, |x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n     let splits: &[&mut [_]] = &[&mut [], &mut [], &mut [], &mut [4, 5]];\n     assert_eq!(xs.splitn_mut(4, |_| true).collect::<Vec<_>>(), splits);\n \n@@ -1055,11 +1046,11 @@ fn test_reverse_part() {\n #[test]\n fn test_show() {\n     macro_rules! test_show_vec {\n-        ($x:expr, $x_str:expr) => ({\n+        ($x:expr, $x_str:expr) => {{\n             let (x, x_str) = ($x, $x_str);\n             assert_eq!(format!(\"{:?}\", x), x_str);\n             assert_eq!(format!(\"{:?}\", x), x_str);\n-        })\n+        }};\n     }\n     let empty = Vec::<i32>::new();\n     test_show_vec!(empty, \"[]\");\n@@ -1083,7 +1074,7 @@ fn test_vec_default() {\n         ($ty:ty) => {{\n             let v: $ty = Default::default();\n             assert!(v.is_empty());\n-        }}\n+        }};\n     }\n \n     t!(&[i32]);\n@@ -1406,8 +1397,8 @@ fn test_box_slice_clone() {\n #[allow(unused_must_use)] // here, we care about the side effects of `.clone()`\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n fn test_box_slice_clone_panics() {\n-    use std::sync::Arc;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n+    use std::sync::Arc;\n \n     struct Canary {\n         count: Arc<AtomicUsize>,\n@@ -1426,32 +1417,23 @@ fn test_box_slice_clone_panics() {\n                 panic!()\n             }\n \n-            Canary {\n-                count: self.count.clone(),\n-                panics: self.panics,\n-            }\n+            Canary { count: self.count.clone(), panics: self.panics }\n         }\n     }\n \n     let drop_count = Arc::new(AtomicUsize::new(0));\n-    let canary = Canary {\n-        count: drop_count.clone(),\n-        panics: false,\n-    };\n-    let panic = Canary {\n-        count: drop_count.clone(),\n-        panics: true,\n-    };\n+    let canary = Canary { count: drop_count.clone(), panics: false };\n+    let panic = Canary { count: drop_count.clone(), panics: true };\n \n     std::panic::catch_unwind(move || {\n-            // When xs is dropped, +5.\n-            let xs = vec![canary.clone(), canary.clone(), canary.clone(), panic, canary]\n-                .into_boxed_slice();\n+        // When xs is dropped, +5.\n+        let xs =\n+            vec![canary.clone(), canary.clone(), canary.clone(), panic, canary].into_boxed_slice();\n \n-            // When panic is cloned, +3.\n-            xs.clone();\n-        })\n-        .unwrap_err();\n+        // When panic is cloned, +3.\n+        xs.clone();\n+    })\n+    .unwrap_err();\n \n     // Total = 8\n     assert_eq!(drop_count.load(Ordering::SeqCst), 8);\n@@ -1485,26 +1467,86 @@ const MAX_LEN: usize = 80;\n \n static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n     // FIXME(RFC 1109): AtomicUsize is not Copy.\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n ];\n \n static VERSIONS: AtomicUsize = AtomicUsize::new(0);\n@@ -1551,7 +1593,10 @@ macro_rules! test {\n         // Work out the total number of comparisons required to sort\n         // this array...\n         let mut count = 0usize;\n-        $input.to_owned().$func(|a, b| { count += 1; a.cmp(b) });\n+        $input.to_owned().$func(|a, b| {\n+            count += 1;\n+            a.cmp(b)\n+        });\n \n         // ... and then panic on each and every single one.\n         for panic_countdown in 0..count {\n@@ -1579,15 +1624,13 @@ macro_rules! test {\n             // what we expect (i.e., the contents of `v`).\n             for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n                 let count = c.load(Relaxed);\n-                assert!(count == 1,\n-                        \"found drop count == {} for i == {}, len == {}\",\n-                        count, i, len);\n+                assert!(count == 1, \"found drop count == {} for i == {}, len == {}\", count, i, len);\n             }\n \n             // Check that the most recent versions of values were dropped.\n             assert_eq!(VERSIONS.load(Relaxed), 0);\n         }\n-    }\n+    };\n }\n \n thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n@@ -1618,12 +1661,10 @@ fn panic_safe() {\n         for &modulus in moduli {\n             for &has_runs in &[false, true] {\n                 let mut input = (0..len)\n-                    .map(|id| {\n-                        DropCounter {\n-                            x: rng.next_u32() % modulus,\n-                            id: id,\n-                            version: Cell::new(0),\n-                        }\n+                    .map(|id| DropCounter {\n+                        x: rng.next_u32() % modulus,\n+                        id: id,\n+                        version: Cell::new(0),\n                     })\n                     .collect::<Vec<_>>();\n \n@@ -1658,8 +1699,5 @@ fn repeat_generic_slice() {\n     assert_eq!([1, 2].repeat(2), vec![1, 2, 1, 2]);\n     assert_eq!([1, 2, 3, 4].repeat(0), vec![]);\n     assert_eq!([1, 2, 3, 4].repeat(1), vec![1, 2, 3, 4]);\n-    assert_eq!(\n-        [1, 2, 3, 4].repeat(3),\n-        vec![1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]\n-    );\n+    assert_eq!([1, 2, 3, 4].repeat(3), vec![1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n }"}, {"sha": "d3c72615696d5f52ca9a0908dc41d2e7b6643e84", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 175, "deletions": 179, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -13,19 +13,19 @@ fn test_le() {\n #[test]\n fn test_find() {\n     assert_eq!(\"hello\".find('l'), Some(2));\n-    assert_eq!(\"hello\".find(|c:char| c == 'o'), Some(4));\n+    assert_eq!(\"hello\".find(|c: char| c == 'o'), Some(4));\n     assert!(\"hello\".find('x').is_none());\n-    assert!(\"hello\".find(|c:char| c == 'x').is_none());\n+    assert!(\"hello\".find(|c: char| c == 'x').is_none());\n     assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find('\u534e'), Some(30));\n     assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find(|c: char| c == '\u534e'), Some(30));\n }\n \n #[test]\n fn test_rfind() {\n     assert_eq!(\"hello\".rfind('l'), Some(3));\n-    assert_eq!(\"hello\".rfind(|c:char| c == 'o'), Some(4));\n+    assert_eq!(\"hello\".rfind(|c: char| c == 'o'), Some(4));\n     assert!(\"hello\".rfind('x').is_none());\n-    assert!(\"hello\".rfind(|c:char| c == 'x').is_none());\n+    assert!(\"hello\".rfind(|c: char| c == 'x').is_none());\n     assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind('\u534e'), Some(30));\n     assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|c: char| c == '\u534e'), Some(30));\n }\n@@ -65,7 +65,7 @@ fn test_find_str() {\n     assert_eq!(data[0..43].find(\"\"), Some(0));\n     assert_eq!(data[6..43].find(\"\"), Some(6 - 6));\n \n-    assert_eq!(data[0..43].find(\"\u0e1b\u0e23\u0e30\"), Some( 0));\n+    assert_eq!(data[0..43].find(\"\u0e1b\u0e23\u0e30\"), Some(0));\n     assert_eq!(data[0..43].find(\"\u0e17\u0e28\u0e44\"), Some(12));\n     assert_eq!(data[0..43].find(\"\u0e22\u4e2d\"), Some(24));\n     assert_eq!(data[0..43].find(\"i\u1ec7t\"), Some(34));\n@@ -81,10 +81,7 @@ fn test_find_str() {\n     let string = \"Vi\u1ec7t Namacbaabcaabaaba\";\n     for (i, ci) in string.char_indices() {\n         let ip = i + ci.len_utf8();\n-        for j in string[ip..].char_indices()\n-                             .map(|(i, _)| i)\n-                             .chain(Some(string.len() - ip))\n-        {\n+        for j in string[ip..].char_indices().map(|(i, _)| i).chain(Some(string.len() - ip)) {\n             let pat = &string[i..ip + j];\n             assert!(match string.find(pat) {\n                 None => false,\n@@ -98,15 +95,15 @@ fn test_find_str() {\n     }\n }\n \n-fn s(x: &str) -> String { x.to_string() }\n+fn s(x: &str) -> String {\n+    x.to_string()\n+}\n \n macro_rules! test_concat {\n-    ($expected: expr, $string: expr) => {\n-        {\n-            let s: String = $string.concat();\n-            assert_eq!($expected, s);\n-        }\n-    }\n+    ($expected: expr, $string: expr) => {{\n+        let s: String = $string.concat();\n+        assert_eq!($expected, s);\n+    }};\n }\n \n #[test]\n@@ -125,12 +122,10 @@ fn test_concat_for_different_lengths() {\n }\n \n macro_rules! test_join {\n-    ($expected: expr, $string: expr, $delim: expr) => {\n-        {\n-            let s = $string.join($delim);\n-            assert_eq!($expected, s);\n-        }\n-    }\n+    ($expected: expr, $string: expr, $delim: expr) => {{\n+        let s = $string.join($delim);\n+        assert_eq!($expected, s);\n+    }};\n }\n \n #[test]\n@@ -168,9 +163,9 @@ fn test_join_for_different_lengths_with_long_separator() {\n #[test]\n #[cfg_attr(miri, ignore)] // Miri is too slow\n fn test_unsafe_slice() {\n-    assert_eq!(\"ab\", unsafe {\"abc\".get_unchecked(0..2)});\n-    assert_eq!(\"bc\", unsafe {\"abc\".get_unchecked(1..3)});\n-    assert_eq!(\"\", unsafe {\"abc\".get_unchecked(1..1)});\n+    assert_eq!(\"ab\", unsafe { \"abc\".get_unchecked(0..2) });\n+    assert_eq!(\"bc\", unsafe { \"abc\".get_unchecked(1..3) });\n+    assert_eq!(\"\", unsafe { \"abc\".get_unchecked(1..1) });\n     fn a_million_letter_a() -> String {\n         let mut i = 0;\n         let mut rs = String::new();\n@@ -190,8 +185,7 @@ fn test_unsafe_slice() {\n         rs\n     }\n     let letters = a_million_letter_a();\n-    assert_eq!(half_a_million_letter_a(),\n-        unsafe { letters.get_unchecked(0..500000)});\n+    assert_eq!(half_a_million_letter_a(), unsafe { letters.get_unchecked(0..500000) });\n }\n \n #[test]\n@@ -304,8 +298,7 @@ mod slice_index {\n     //\n     // This is not suitable for testing failure on invalid inputs.\n     macro_rules! assert_range_eq {\n-        ($s:expr, $range:expr, $expected:expr)\n-        => {\n+        ($s:expr, $range:expr, $expected:expr) => {\n             let mut s: String = $s.to_owned();\n             let mut expected: String = $expected.to_owned();\n             {\n@@ -316,7 +309,8 @@ mod slice_index {\n                 assert_eq!(s.get($range), Some(expected), \"(in assertion for: get)\");\n                 unsafe {\n                     assert_eq!(\n-                        s.get_unchecked($range), expected,\n+                        s.get_unchecked($range),\n+                        expected,\n                         \"(in assertion for: get_unchecked)\",\n                     );\n                 }\n@@ -325,22 +319,21 @@ mod slice_index {\n                 let s: &mut str = &mut s;\n                 let expected: &mut str = &mut expected;\n \n+                assert_eq!(&mut s[$range], expected, \"(in assertion for: index_mut)\",);\n                 assert_eq!(\n-                    &mut s[$range], expected,\n-                    \"(in assertion for: index_mut)\",\n-                );\n-                assert_eq!(\n-                    s.get_mut($range), Some(&mut expected[..]),\n+                    s.get_mut($range),\n+                    Some(&mut expected[..]),\n                     \"(in assertion for: get_mut)\",\n                 );\n                 unsafe {\n                     assert_eq!(\n-                        s.get_unchecked_mut($range), expected,\n+                        s.get_unchecked_mut($range),\n+                        expected,\n                         \"(in assertion for: get_unchecked_mut)\",\n                     );\n                 }\n             }\n-        }\n+        };\n     }\n \n     // Make sure the macro can actually detect bugs,\n@@ -460,15 +453,15 @@ mod slice_index {\n         assert_range_eq!(data, 30..33, \"\u534e\");\n \n         /*0: \u4e2d\n-          3: \u534e\n-          6: V\n-          7: i\n-          8: \u1ec7\n-         11: t\n-         12:\n-         13: N\n-         14: a\n-         15: m */\n+         3: \u534e\n+         6: V\n+         7: i\n+         8: \u1ec7\n+        11: t\n+        12:\n+        13: N\n+        14: a\n+        15: m */\n         let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n         assert_range_eq!(ss, 3..6, \"\u534e\");\n         assert_range_eq!(ss, 6..16, \"Vi\u1ec7t Nam\");\n@@ -660,13 +653,13 @@ mod slice_index {\n \n     // check the panic includes the prefix of the sliced string\n     #[test]\n-    #[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n+    #[should_panic(expected = \"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n     fn test_slice_fail_truncated_1() {\n         &LOREM_PARAGRAPH[..1024];\n     }\n     // check the truncation in the panic message\n     #[test]\n-    #[should_panic(expected=\"luctus, im`[...]\")]\n+    #[should_panic(expected = \"luctus, im`[...]\")]\n     fn test_slice_fail_truncated_2() {\n         &LOREM_PARAGRAPH[..1024];\n     }\n@@ -712,8 +705,12 @@ fn test_is_char_boundary() {\n         // ensure character locations are boundaries and continuation bytes are not\n         assert!(s.is_char_boundary(i), \"{} is a char boundary in {:?}\", i, s);\n         for j in 1..ch.len_utf8() {\n-            assert!(!s.is_char_boundary(i + j),\n-                    \"{} should not be a char boundary in {:?}\", i + j, s);\n+            assert!(\n+                !s.is_char_boundary(i + j),\n+                \"{} should not be a char boundary in {:?}\",\n+                i + j,\n+                s\n+            );\n         }\n     }\n }\n@@ -846,7 +843,7 @@ fn from_utf8_error() {\n             let error = from_utf8($input).unwrap_err();\n             assert_eq!(error.valid_up_to(), $expected_valid_up_to);\n             assert_eq!(error.error_len(), $expected_error_len);\n-        }\n+        };\n     }\n     test!(b\"A\\xC3\\xA9 \\xFF \", 4, Some(1));\n     test!(b\"A\\xC3\\xA9 \\x80 \", 4, Some(1));\n@@ -873,9 +870,8 @@ fn from_utf8_error() {\n fn test_as_bytes() {\n     // no null\n     let v = [\n-        224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-        184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-        109\n+        224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228, 184, 173, 229, 141, 142,\n+        86, 105, 225, 187, 135, 116, 32, 78, 97, 109,\n     ];\n     let b: &[u8] = &[];\n     assert_eq!(\"\".as_bytes(), b);\n@@ -1010,8 +1006,10 @@ fn test_escape_debug() {\n     assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_debug().to_string(), \"\\u{10000}\\\\u{10ffff}\");\n     assert_eq!(\"ab\\u{200b}\".escape_debug().to_string(), \"ab\\\\u{200b}\");\n     assert_eq!(\"\\u{10d4ea}\\r\".escape_debug().to_string(), \"\\\\u{10d4ea}\\\\r\");\n-    assert_eq!(\"\\u{301}a\\u{301}b\u00e9\\u{e000}\".escape_debug().to_string(),\n-               \"\\\\u{301}a\\u{301}b\u00e9\\\\u{e000}\");\n+    assert_eq!(\n+        \"\\u{301}a\\u{301}b\u00e9\\u{e000}\".escape_debug().to_string(),\n+        \"\\\\u{301}a\\u{301}b\u00e9\\\\u{e000}\"\n+    );\n }\n \n #[test]\n@@ -1040,7 +1038,7 @@ fn test_total_ord() {\n #[test]\n fn test_iterator() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-    let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+    let v = ['\u0e28', '\u0e44', '\u0e17', '\u0e22', '\u4e2d', '\u534e', 'V', 'i', '\u1ec7', 't', ' ', 'N', 'a', 'm'];\n \n     let mut pos = 0;\n     let it = s.chars();\n@@ -1056,7 +1054,7 @@ fn test_iterator() {\n #[test]\n fn test_rev_iterator() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-    let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n+    let v = ['m', 'a', 'N', ' ', 't', '\u1ec7', 'i', 'V', '\u534e', '\u4e2d', '\u0e22', '\u0e17', '\u0e44', '\u0e28'];\n \n     let mut pos = 0;\n     let it = s.chars().rev();\n@@ -1097,7 +1095,7 @@ fn test_iterator_clone() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     let mut it = s.chars();\n     it.next();\n-    assert!(it.clone().zip(it).all(|(x,y)| x == y));\n+    assert!(it.clone().zip(it).all(|(x, y)| x == y));\n }\n \n #[test]\n@@ -1122,9 +1120,8 @@ fn test_chars_debug() {\n fn test_bytesator() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     let v = [\n-        224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-        184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-        109\n+        224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228, 184, 173, 229, 141, 142,\n+        86, 105, 225, 187, 135, 116, 32, 78, 97, 109,\n     ];\n     let mut pos = 0;\n \n@@ -1138,9 +1135,8 @@ fn test_bytesator() {\n fn test_bytes_revator() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     let v = [\n-        224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-        184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-        109\n+        224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228, 184, 173, 229, 141, 142,\n+        86, 105, 225, 187, 135, 116, 32, 78, 97, 109,\n     ];\n     let mut pos = v.len();\n \n@@ -1154,9 +1150,8 @@ fn test_bytes_revator() {\n fn test_bytesator_nth() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     let v = [\n-        224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-        184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-        109\n+        224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228, 184, 173, 229, 141, 142,\n+        86, 105, 225, 187, 135, 116, 32, 78, 97, 109,\n     ];\n \n     let mut b = s.bytes();\n@@ -1185,7 +1180,7 @@ fn test_bytesator_last() {\n fn test_char_indicesator() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     let p = [0, 3, 6, 9, 12, 15, 18, 19, 20, 23, 24, 25, 26, 27];\n-    let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+    let v = ['\u0e28', '\u0e44', '\u0e17', '\u0e22', '\u4e2d', '\u534e', 'V', 'i', '\u1ec7', 't', ' ', 'N', 'a', 'm'];\n \n     let mut pos = 0;\n     let it = s.char_indices();\n@@ -1202,7 +1197,7 @@ fn test_char_indicesator() {\n fn test_char_indices_revator() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     let p = [27, 26, 25, 24, 23, 20, 19, 18, 15, 12, 9, 6, 3, 0];\n-    let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n+    let v = ['m', 'a', 'N', ' ', 't', '\u1ec7', 'i', 'V', '\u534e', '\u4e2d', '\u0e22', '\u0e17', '\u0e44', '\u0e28'];\n \n     let mut pos = 0;\n     let it = s.char_indices().rev();\n@@ -1314,10 +1309,10 @@ fn test_splitator() {\n     t(\"zzXXXzYYYz\", \"XXX\", &[\"zz\", \"zYYYz\"]);\n     t(\".XXX.YYY.\", \".\", &[\"\", \"XXX\", \"YYY\", \"\"]);\n     t(\"\", \".\", &[\"\"]);\n-    t(\"zz\", \"zz\", &[\"\",\"\"]);\n+    t(\"zz\", \"zz\", &[\"\", \"\"]);\n     t(\"ok\", \"z\", &[\"ok\"]);\n-    t(\"zzz\", \"zz\", &[\"\",\"z\"]);\n-    t(\"zzzzz\", \"zz\", &[\"\",\"\",\"z\"]);\n+    t(\"zzz\", \"zz\", &[\"\", \"z\"]);\n+    t(\"zzzzz\", \"zz\", &[\"\", \"\", \"z\"]);\n }\n \n #[test]\n@@ -1383,7 +1378,7 @@ fn test_bool_from_str() {\n fn check_contains_all_substrings(s: &str) {\n     assert!(s.contains(\"\"));\n     for i in 0..s.len() {\n-        for j in i+1..=s.len() {\n+        for j in i + 1..=s.len() {\n             assert!(s.contains(&s[i..j]));\n         }\n     }\n@@ -1405,7 +1400,6 @@ fn strslice_issue_16878() {\n     assert!(!\"00abc01234567890123456789abc\".contains(\"bcabc\"));\n }\n \n-\n #[test]\n #[cfg_attr(miri, ignore)] // Miri is too slow\n fn test_strslice_contains() {\n@@ -1440,29 +1434,29 @@ fn test_split_char_iterator() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n     let split: Vec<&str> = data.split(' ').collect();\n-    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n     rsplit.reverse();\n     assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n-    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n     rsplit.reverse();\n     assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     // Unicode\n     let split: Vec<&str> = data.split('\u00e4').collect();\n-    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n     rsplit.reverse();\n     assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n     let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n-    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n     rsplit.reverse();\n@@ -1484,8 +1478,7 @@ fn test_rev_split_char_iterator_no_trailing() {\n \n #[test]\n fn test_utf16_code_units() {\n-    assert_eq!(\"\u00e9\\u{1F4A9}\".encode_utf16().collect::<Vec<u16>>(),\n-               [0xE9, 0xD83D, 0xDCA9])\n+    assert_eq!(\"\u00e9\\u{1F4A9}\".encode_utf16().collect::<Vec<u16>>(), [0xE9, 0xD83D, 0xDCA9])\n }\n \n #[test]\n@@ -1521,26 +1514,16 @@ fn contains_weird_cases() {\n \n #[test]\n fn trim_ws() {\n-    assert_eq!(\" \\t  a \\t  \".trim_start_matches(|c: char| c.is_whitespace()),\n-                    \"a \\t  \");\n-    assert_eq!(\" \\t  a \\t  \".trim_end_matches(|c: char| c.is_whitespace()),\n-               \" \\t  a\");\n-    assert_eq!(\" \\t  a \\t  \".trim_start_matches(|c: char| c.is_whitespace()),\n-                    \"a \\t  \");\n-    assert_eq!(\" \\t  a \\t  \".trim_end_matches(|c: char| c.is_whitespace()),\n-               \" \\t  a\");\n-    assert_eq!(\" \\t  a \\t  \".trim_matches(|c: char| c.is_whitespace()),\n-                    \"a\");\n-    assert_eq!(\" \\t   \\t  \".trim_start_matches(|c: char| c.is_whitespace()),\n-                         \"\");\n-    assert_eq!(\" \\t   \\t  \".trim_end_matches(|c: char| c.is_whitespace()),\n-               \"\");\n-    assert_eq!(\" \\t   \\t  \".trim_start_matches(|c: char| c.is_whitespace()),\n-                         \"\");\n-    assert_eq!(\" \\t   \\t  \".trim_end_matches(|c: char| c.is_whitespace()),\n-               \"\");\n-    assert_eq!(\" \\t   \\t  \".trim_matches(|c: char| c.is_whitespace()),\n-               \"\");\n+    assert_eq!(\" \\t  a \\t  \".trim_start_matches(|c: char| c.is_whitespace()), \"a \\t  \");\n+    assert_eq!(\" \\t  a \\t  \".trim_end_matches(|c: char| c.is_whitespace()), \" \\t  a\");\n+    assert_eq!(\" \\t  a \\t  \".trim_start_matches(|c: char| c.is_whitespace()), \"a \\t  \");\n+    assert_eq!(\" \\t  a \\t  \".trim_end_matches(|c: char| c.is_whitespace()), \" \\t  a\");\n+    assert_eq!(\" \\t  a \\t  \".trim_matches(|c: char| c.is_whitespace()), \"a\");\n+    assert_eq!(\" \\t   \\t  \".trim_start_matches(|c: char| c.is_whitespace()), \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_end_matches(|c: char| c.is_whitespace()), \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_start_matches(|c: char| c.is_whitespace()), \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_end_matches(|c: char| c.is_whitespace()), \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_matches(|c: char| c.is_whitespace()), \"\");\n }\n \n #[test]\n@@ -1616,8 +1599,8 @@ fn test_repeat() {\n }\n \n mod pattern {\n-    use std::str::pattern::{Pattern, Searcher, ReverseSearcher};\n-    use std::str::pattern::SearchStep::{self, Match, Reject, Done};\n+    use std::str::pattern::SearchStep::{self, Done, Match, Reject};\n+    use std::str::pattern::{Pattern, ReverseSearcher, Searcher};\n \n     macro_rules! make_test {\n         ($name:ident, $p:expr, $h:expr, [$($e:expr,)*]) => {\n@@ -1641,12 +1624,12 @@ mod pattern {\n         rev: bool,\n         pat: impl Pattern<'a, Searcher: ReverseSearcher<'a>>,\n         haystack: &'a str,\n-        right: Vec<SearchStep>\n+        right: Vec<SearchStep>,\n     ) {\n         let mut searcher = pat.into_searcher(haystack);\n         let mut v = vec![];\n         loop {\n-            match if !rev {searcher.next()} else {searcher.next_back()} {\n+            match if !rev { searcher.next() } else { searcher.next_back() } {\n                 Match(a, b) => v.push(Match(a, b)),\n                 Reject(a, b) => v.push(Reject(a, b)),\n                 Done => break,\n@@ -1661,8 +1644,7 @@ mod pattern {\n \n         for (i, e) in right.iter().enumerate() {\n             match *e {\n-                Match(a, b) | Reject(a, b)\n-                if a <= b && a == first_index => {\n+                Match(a, b) | Reject(a, b) if a <= b && a == first_index => {\n                     first_index = b;\n                 }\n                 _ => {\n@@ -1683,77 +1665,88 @@ mod pattern {\n         assert_eq!(v, right);\n     }\n \n-    make_test!(str_searcher_ascii_haystack, \"bb\", \"abbcbbd\", [\n-        Reject(0, 1),\n-        Match (1, 3),\n-        Reject(3, 4),\n-        Match (4, 6),\n-        Reject(6, 7),\n-    ]);\n-    make_test!(str_searcher_ascii_haystack_seq, \"bb\", \"abbcbbbbd\", [\n-        Reject(0, 1),\n-        Match (1, 3),\n-        Reject(3, 4),\n-        Match (4, 6),\n-        Match (6, 8),\n-        Reject(8, 9),\n-    ]);\n-    make_test!(str_searcher_empty_needle_ascii_haystack, \"\", \"abbcbbd\", [\n-        Match (0, 0),\n-        Reject(0, 1),\n-        Match (1, 1),\n-        Reject(1, 2),\n-        Match (2, 2),\n-        Reject(2, 3),\n-        Match (3, 3),\n-        Reject(3, 4),\n-        Match (4, 4),\n-        Reject(4, 5),\n-        Match (5, 5),\n-        Reject(5, 6),\n-        Match (6, 6),\n-        Reject(6, 7),\n-        Match (7, 7),\n-    ]);\n-    make_test!(str_searcher_multibyte_haystack, \" \", \"\u251c\u2500\u2500\", [\n-        Reject(0, 3),\n-        Reject(3, 6),\n-        Reject(6, 9),\n-    ]);\n-    make_test!(str_searcher_empty_needle_multibyte_haystack, \"\", \"\u251c\u2500\u2500\", [\n-        Match (0, 0),\n-        Reject(0, 3),\n-        Match (3, 3),\n-        Reject(3, 6),\n-        Match (6, 6),\n-        Reject(6, 9),\n-        Match (9, 9),\n-    ]);\n-    make_test!(str_searcher_empty_needle_empty_haystack, \"\", \"\", [\n-        Match(0, 0),\n-    ]);\n-    make_test!(str_searcher_nonempty_needle_empty_haystack, \"\u251c\", \"\", [\n-    ]);\n-    make_test!(char_searcher_ascii_haystack, 'b', \"abbcbbd\", [\n-        Reject(0, 1),\n-        Match (1, 2),\n-        Match (2, 3),\n-        Reject(3, 4),\n-        Match (4, 5),\n-        Match (5, 6),\n-        Reject(6, 7),\n-    ]);\n-    make_test!(char_searcher_multibyte_haystack, ' ', \"\u251c\u2500\u2500\", [\n-        Reject(0, 3),\n-        Reject(3, 6),\n-        Reject(6, 9),\n-    ]);\n-    make_test!(char_searcher_short_haystack, '\\u{1F4A9}', \"* \\t\", [\n-        Reject(0, 1),\n-        Reject(1, 2),\n-        Reject(2, 3),\n-    ]);\n-\n+    make_test!(\n+        str_searcher_ascii_haystack,\n+        \"bb\",\n+        \"abbcbbd\",\n+        [Reject(0, 1), Match(1, 3), Reject(3, 4), Match(4, 6), Reject(6, 7),]\n+    );\n+    make_test!(\n+        str_searcher_ascii_haystack_seq,\n+        \"bb\",\n+        \"abbcbbbbd\",\n+        [Reject(0, 1), Match(1, 3), Reject(3, 4), Match(4, 6), Match(6, 8), Reject(8, 9),]\n+    );\n+    make_test!(\n+        str_searcher_empty_needle_ascii_haystack,\n+        \"\",\n+        \"abbcbbd\",\n+        [\n+            Match(0, 0),\n+            Reject(0, 1),\n+            Match(1, 1),\n+            Reject(1, 2),\n+            Match(2, 2),\n+            Reject(2, 3),\n+            Match(3, 3),\n+            Reject(3, 4),\n+            Match(4, 4),\n+            Reject(4, 5),\n+            Match(5, 5),\n+            Reject(5, 6),\n+            Match(6, 6),\n+            Reject(6, 7),\n+            Match(7, 7),\n+        ]\n+    );\n+    make_test!(\n+        str_searcher_multibyte_haystack,\n+        \" \",\n+        \"\u251c\u2500\u2500\",\n+        [Reject(0, 3), Reject(3, 6), Reject(6, 9),]\n+    );\n+    make_test!(\n+        str_searcher_empty_needle_multibyte_haystack,\n+        \"\",\n+        \"\u251c\u2500\u2500\",\n+        [\n+            Match(0, 0),\n+            Reject(0, 3),\n+            Match(3, 3),\n+            Reject(3, 6),\n+            Match(6, 6),\n+            Reject(6, 9),\n+            Match(9, 9),\n+        ]\n+    );\n+    make_test!(str_searcher_empty_needle_empty_haystack, \"\", \"\", [Match(0, 0),]);\n+    make_test!(str_searcher_nonempty_needle_empty_haystack, \"\u251c\", \"\", []);\n+    make_test!(\n+        char_searcher_ascii_haystack,\n+        'b',\n+        \"abbcbbd\",\n+        [\n+            Reject(0, 1),\n+            Match(1, 2),\n+            Match(2, 3),\n+            Reject(3, 4),\n+            Match(4, 5),\n+            Match(5, 6),\n+            Reject(6, 7),\n+        ]\n+    );\n+    make_test!(\n+        char_searcher_multibyte_haystack,\n+        ' ',\n+        \"\u251c\u2500\u2500\",\n+        [Reject(0, 3), Reject(3, 6), Reject(6, 9),]\n+    );\n+    make_test!(\n+        char_searcher_short_haystack,\n+        '\\u{1F4A9}',\n+        \"* \\t\",\n+        [Reject(0, 1), Reject(1, 2), Reject(2, 3),]\n+    );\n }\n \n macro_rules! generate_iterator_test {\n@@ -1850,7 +1843,10 @@ generate_iterator_test! {\n fn different_str_pattern_forwarding_lifetimes() {\n     use std::str::pattern::Pattern;\n \n-    fn foo<'a, P>(p: P) where for<'b> &'b P: Pattern<'a> {\n+    fn foo<'a, P>(p: P)\n+    where\n+        for<'b> &'b P: Pattern<'a>,\n+    {\n         for _ in 0..3 {\n             \"asdf\".find(&p);\n         }"}, {"sha": "dd44495845961dad751c59bba81bb1689b892abe", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 119, "deletions": 69, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,9 +1,12 @@\n use std::borrow::Cow;\n use std::collections::TryReserveError::*;\n use std::mem::size_of;\n-use std::{usize, isize};\n+use std::{isize, usize};\n \n-pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n+pub trait IntoCow<'a, B: ?Sized>\n+where\n+    B: ToOwned,\n+{\n     fn into_cow(self) -> Cow<'a, B>;\n }\n \n@@ -43,8 +46,7 @@ fn test_from_utf8() {\n     assert_eq!(String::from_utf8(xs).unwrap(), String::from(\"hello\"));\n \n     let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes().to_vec();\n-    assert_eq!(String::from_utf8(xs).unwrap(),\n-               String::from(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+    assert_eq!(String::from_utf8(xs).unwrap(), String::from(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n     let xs = b\"hello\\xFF\".to_vec();\n     let err = String::from_utf8(xs).unwrap_err();\n@@ -62,60 +64,87 @@ fn test_from_utf8_lossy() {\n     assert_eq!(String::from_utf8_lossy(xs), ys);\n \n     let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n-    assert_eq!(String::from_utf8_lossy(xs),\n-               String::from(\"Hello\\u{FFFD} There\\u{FFFD} Goodbye\").into_cow());\n+    assert_eq!(\n+        String::from_utf8_lossy(xs),\n+        String::from(\"Hello\\u{FFFD} There\\u{FFFD} Goodbye\").into_cow()\n+    );\n \n     let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n-    assert_eq!(String::from_utf8_lossy(xs),\n-               String::from(\"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\").into_cow());\n+    assert_eq!(\n+        String::from_utf8_lossy(xs),\n+        String::from(\"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\").into_cow()\n+    );\n \n     let xs = b\"\\xF5foo\\xF5\\x80bar\";\n-    assert_eq!(String::from_utf8_lossy(xs),\n-               String::from(\"\\u{FFFD}foo\\u{FFFD}\\u{FFFD}bar\").into_cow());\n+    assert_eq!(\n+        String::from_utf8_lossy(xs),\n+        String::from(\"\\u{FFFD}foo\\u{FFFD}\\u{FFFD}bar\").into_cow()\n+    );\n \n     let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n-    assert_eq!(String::from_utf8_lossy(xs),\n-               String::from(\"\\u{FFFD}foo\\u{FFFD}bar\\u{FFFD}baz\").into_cow());\n+    assert_eq!(\n+        String::from_utf8_lossy(xs),\n+        String::from(\"\\u{FFFD}foo\\u{FFFD}bar\\u{FFFD}baz\").into_cow()\n+    );\n \n     let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n-    assert_eq!(String::from_utf8_lossy(xs),\n-               String::from(\"\\u{FFFD}foo\\u{FFFD}bar\\u{FFFD}\\u{FFFD}baz\").into_cow());\n+    assert_eq!(\n+        String::from_utf8_lossy(xs),\n+        String::from(\"\\u{FFFD}foo\\u{FFFD}bar\\u{FFFD}\\u{FFFD}baz\").into_cow()\n+    );\n \n     let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n-    assert_eq!(String::from_utf8_lossy(xs),\n-               String::from(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}\\u{FFFD}foo\\u{10000}bar\").into_cow());\n+    assert_eq!(\n+        String::from_utf8_lossy(xs),\n+        String::from(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}\\u{FFFD}foo\\u{10000}bar\").into_cow()\n+    );\n \n     // surrogates\n     let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n-    assert_eq!(String::from_utf8_lossy(xs),\n-               String::from(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}foo\\u{FFFD}\\u{FFFD}\\u{FFFD}bar\").into_cow());\n+    assert_eq!(\n+        String::from_utf8_lossy(xs),\n+        String::from(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}foo\\u{FFFD}\\u{FFFD}\\u{FFFD}bar\").into_cow()\n+    );\n }\n \n #[test]\n fn test_from_utf16() {\n-    let pairs = [(String::from(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\"),\n-                  vec![0xd800, 0xdf45, 0xd800, 0xdf3f, 0xd800, 0xdf3b, 0xd800, 0xdf46, 0xd800,\n-                       0xdf39, 0xd800, 0xdf3b, 0xd800, 0xdf30, 0x000a]),\n-\n-                 (String::from(\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\"),\n-                  vec![0xd801, 0xdc12, 0xd801, 0xdc49, 0xd801, 0xdc2e, 0xd801, 0xdc40, 0xd801,\n-                       0xdc32, 0xd801, 0xdc4b, 0x0020, 0xd801, 0xdc0f, 0xd801, 0xdc32, 0xd801,\n-                       0xdc4d, 0x000a]),\n-\n-                 (String::from(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\"),\n-                  vec![0xd800, 0xdf00, 0xd800, 0xdf16, 0xd800, 0xdf0b, 0xd800, 0xdf04, 0xd800,\n-                       0xdf11, 0xd800, 0xdf09, 0x00b7, 0xd800, 0xdf0c, 0xd800, 0xdf04, 0xd800,\n-                       0xdf15, 0xd800, 0xdf04, 0xd800, 0xdf0b, 0xd800, 0xdf09, 0xd800, 0xdf11,\n-                       0x000a]),\n-\n-                 (String::from(\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\"),\n-                  vec![0xd801, 0xdc8b, 0xd801, 0xdc98, 0xd801, 0xdc88, 0xd801, 0xdc91, 0xd801,\n-                       0xdc9b, 0xd801, 0xdc92, 0x0020, 0xd801, 0xdc95, 0xd801, 0xdc93, 0x0020,\n-                       0xd801, 0xdc88, 0xd801, 0xdc9a, 0xd801, 0xdc8d, 0x0020, 0xd801, 0xdc8f,\n-                       0xd801, 0xdc9c, 0xd801, 0xdc92, 0xd801, 0xdc96, 0xd801, 0xdc86, 0x0020,\n-                       0xd801, 0xdc95, 0xd801, 0xdc86, 0x000a]),\n-                 // Issue #12318, even-numbered non-BMP planes\n-                 (String::from(\"\\u{20000}\"), vec![0xD840, 0xDC00])];\n+    let pairs = [\n+        (\n+            String::from(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\"),\n+            vec![\n+                0xd800, 0xdf45, 0xd800, 0xdf3f, 0xd800, 0xdf3b, 0xd800, 0xdf46, 0xd800, 0xdf39,\n+                0xd800, 0xdf3b, 0xd800, 0xdf30, 0x000a,\n+            ],\n+        ),\n+        (\n+            String::from(\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\"),\n+            vec![\n+                0xd801, 0xdc12, 0xd801, 0xdc49, 0xd801, 0xdc2e, 0xd801, 0xdc40, 0xd801, 0xdc32,\n+                0xd801, 0xdc4b, 0x0020, 0xd801, 0xdc0f, 0xd801, 0xdc32, 0xd801, 0xdc4d, 0x000a,\n+            ],\n+        ),\n+        (\n+            String::from(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\"),\n+            vec![\n+                0xd800, 0xdf00, 0xd800, 0xdf16, 0xd800, 0xdf0b, 0xd800, 0xdf04, 0xd800, 0xdf11,\n+                0xd800, 0xdf09, 0x00b7, 0xd800, 0xdf0c, 0xd800, 0xdf04, 0xd800, 0xdf15, 0xd800,\n+                0xdf04, 0xd800, 0xdf0b, 0xd800, 0xdf09, 0xd800, 0xdf11, 0x000a,\n+            ],\n+        ),\n+        (\n+            String::from(\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\"),\n+            vec![\n+                0xd801, 0xdc8b, 0xd801, 0xdc98, 0xd801, 0xdc88, 0xd801, 0xdc91, 0xd801, 0xdc9b,\n+                0xd801, 0xdc92, 0x0020, 0xd801, 0xdc95, 0xd801, 0xdc93, 0x0020, 0xd801, 0xdc88,\n+                0xd801, 0xdc9a, 0xd801, 0xdc8d, 0x0020, 0xd801, 0xdc8f, 0xd801, 0xdc9c, 0xd801,\n+                0xdc92, 0xd801, 0xdc96, 0xd801, 0xdc86, 0x0020, 0xd801, 0xdc95, 0xd801, 0xdc86,\n+                0x000a,\n+            ],\n+        ),\n+        // Issue #12318, even-numbered non-BMP planes\n+        (String::from(\"\\u{20000}\"), vec![0xD840, 0xDC00]),\n+    ];\n \n     for p in &pairs {\n         let (s, u) = (*p).clone();\n@@ -152,19 +181,18 @@ fn test_utf16_invalid() {\n fn test_from_utf16_lossy() {\n     // completely positive cases tested above.\n     // lead + eof\n-    assert_eq!(String::from_utf16_lossy(&[0xD800]),\n-               String::from(\"\\u{FFFD}\"));\n+    assert_eq!(String::from_utf16_lossy(&[0xD800]), String::from(\"\\u{FFFD}\"));\n     // lead + lead\n-    assert_eq!(String::from_utf16_lossy(&[0xD800, 0xD800]),\n-               String::from(\"\\u{FFFD}\\u{FFFD}\"));\n+    assert_eq!(String::from_utf16_lossy(&[0xD800, 0xD800]), String::from(\"\\u{FFFD}\\u{FFFD}\"));\n \n     // isolated trail\n-    assert_eq!(String::from_utf16_lossy(&[0x0061, 0xDC00]),\n-               String::from(\"a\\u{FFFD}\"));\n+    assert_eq!(String::from_utf16_lossy(&[0x0061, 0xDC00]), String::from(\"a\\u{FFFD}\"));\n \n     // general\n-    assert_eq!(String::from_utf16_lossy(&[0xD800, 0xd801, 0xdc8b, 0xD800]),\n-               String::from(\"\\u{FFFD}\ud801\udc8b\\u{FFFD}\"));\n+    assert_eq!(\n+        String::from_utf16_lossy(&[0xD800, 0xd801, 0xdc8b, 0xD800]),\n+        String::from(\"\\u{FFFD}\ud801\udc8b\\u{FFFD}\")\n+    );\n }\n \n #[test]\n@@ -525,7 +553,6 @@ fn test_reserve_exact() {\n #[test]\n #[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n fn test_try_reserve() {\n-\n     // These are the interesting cases:\n     // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n     // * > isize::MAX should always fail\n@@ -559,23 +586,30 @@ fn test_try_reserve() {\n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n             if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             // Check usize::MAX does count as overflow\n             if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n             if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n \n             // Check usize::MAX is an OOM\n             if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: String = String::from(\"0123456789\");\n@@ -588,22 +622,26 @@ fn test_try_reserve() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         // Should always overflow in the add-to-len\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n-\n }\n \n #[test]\n #[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n-\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments.\n \n@@ -624,20 +662,27 @@ fn test_try_reserve_exact() {\n \n         if guards_against_isize {\n             if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n \n             if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         let mut ten_bytes: String = String::from(\"0123456789\");\n \n@@ -649,13 +694,18 @@ fn test_try_reserve_exact() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n-\n }"}, {"sha": "19acc70c73c8e4ce199af8618c2c51465ee9ad77", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 117, "deletions": 116, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,8 +1,8 @@\n use std::borrow::Cow;\n+use std::collections::TryReserveError::*;\n use std::mem::size_of;\n-use std::{usize, isize};\n use std::vec::{Drain, IntoIter};\n-use std::collections::TryReserveError::*;\n+use std::{isize, usize};\n \n struct DropCounter<'a> {\n     count: &'a mut u32,\n@@ -28,10 +28,7 @@ fn test_double_drop() {\n \n     let (mut count_x, mut count_y) = (0, 0);\n     {\n-        let mut tv = TwoVec {\n-            x: Vec::new(),\n-            y: Vec::new(),\n-        };\n+        let mut tv = TwoVec { x: Vec::new(), y: Vec::new() };\n         tv.x.push(DropCounter { count: &mut count_x });\n         tv.y.push(DropCounter { count: &mut count_y });\n \n@@ -271,7 +268,12 @@ fn test_dedup_by() {\n     assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n \n     let mut vec = vec![(\"foo\", 1), (\"foo\", 2), (\"bar\", 3), (\"bar\", 4), (\"bar\", 5)];\n-    vec.dedup_by(|a, b| a.0 == b.0 && { b.1 += a.1; true });\n+    vec.dedup_by(|a, b| {\n+        a.0 == b.0 && {\n+            b.1 += a.1;\n+            true\n+        }\n+    });\n \n     assert_eq!(vec, [(\"foo\", 3), (\"bar\", 12)]);\n }\n@@ -323,14 +325,10 @@ fn zero_sized_values() {\n \n #[test]\n fn test_partition() {\n-    assert_eq!(vec![].into_iter().partition(|x: &i32| *x < 3),\n-               (vec![], vec![]));\n-    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 4),\n-               (vec![1, 2, 3], vec![]));\n-    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 2),\n-               (vec![1], vec![2, 3]));\n-    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 0),\n-               (vec![], vec![1, 2, 3]));\n+    assert_eq!(vec![].into_iter().partition(|x: &i32| *x < 3), (vec![], vec![]));\n+    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 4), (vec![1, 2, 3], vec![]));\n+    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 2), (vec![1], vec![2, 3]));\n+    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 0), (vec![], vec![1, 2, 3]));\n }\n \n #[test]\n@@ -509,66 +507,59 @@ fn test_drain_out_of_bounds() {\n #[test]\n fn test_drain_range() {\n     let mut v = vec![1, 2, 3, 4, 5];\n-    for _ in v.drain(4..) {\n-    }\n+    for _ in v.drain(4..) {}\n     assert_eq!(v, &[1, 2, 3, 4]);\n \n     let mut v: Vec<_> = (1..6).map(|x| x.to_string()).collect();\n-    for _ in v.drain(1..4) {\n-    }\n+    for _ in v.drain(1..4) {}\n     assert_eq!(v, &[1.to_string(), 5.to_string()]);\n \n     let mut v: Vec<_> = (1..6).map(|x| x.to_string()).collect();\n-    for _ in v.drain(1..4).rev() {\n-    }\n+    for _ in v.drain(1..4).rev() {}\n     assert_eq!(v, &[1.to_string(), 5.to_string()]);\n \n     let mut v: Vec<_> = vec![(); 5];\n-    for _ in v.drain(1..4).rev() {\n-    }\n+    for _ in v.drain(1..4).rev() {}\n     assert_eq!(v, &[(), ()]);\n }\n \n #[test]\n fn test_drain_inclusive_range() {\n     let mut v = vec!['a', 'b', 'c', 'd', 'e'];\n-    for _ in v.drain(1..=3) {\n-    }\n+    for _ in v.drain(1..=3) {}\n     assert_eq!(v, &['a', 'e']);\n \n     let mut v: Vec<_> = (0..=5).map(|x| x.to_string()).collect();\n-    for _ in v.drain(1..=5) {\n-    }\n+    for _ in v.drain(1..=5) {}\n     assert_eq!(v, &[\"0\".to_string()]);\n \n     let mut v: Vec<String> = (0..=5).map(|x| x.to_string()).collect();\n-    for _ in v.drain(0..=5) {\n-    }\n+    for _ in v.drain(0..=5) {}\n     assert_eq!(v, Vec::<String>::new());\n \n     let mut v: Vec<_> = (0..=5).map(|x| x.to_string()).collect();\n-    for _ in v.drain(0..=3) {\n-    }\n+    for _ in v.drain(0..=3) {}\n     assert_eq!(v, &[\"4\".to_string(), \"5\".to_string()]);\n \n     let mut v: Vec<_> = (0..=1).map(|x| x.to_string()).collect();\n-    for _ in v.drain(..=0) {\n-    }\n+    for _ in v.drain(..=0) {}\n     assert_eq!(v, &[\"1\".to_string()]);\n }\n \n #[test]\n fn test_drain_max_vec_size() {\n     let mut v = Vec::<()>::with_capacity(usize::max_value());\n-    unsafe { v.set_len(usize::max_value()); }\n-    for _ in v.drain(usize::max_value() - 1..) {\n+    unsafe {\n+        v.set_len(usize::max_value());\n     }\n+    for _ in v.drain(usize::max_value() - 1..) {}\n     assert_eq!(v.len(), usize::max_value() - 1);\n \n     let mut v = Vec::<()>::with_capacity(usize::max_value());\n-    unsafe { v.set_len(usize::max_value()); }\n-    for _ in v.drain(usize::max_value() - 1..=usize::max_value() - 1) {\n+    unsafe {\n+        v.set_len(usize::max_value());\n     }\n+    for _ in v.drain(usize::max_value() - 1..=usize::max_value() - 1) {}\n     assert_eq!(v.len(), usize::max_value() - 1);\n }\n \n@@ -864,17 +855,12 @@ fn drain_filter_true() {\n \n #[test]\n fn drain_filter_complex() {\n-\n-    {   //                [+xxx++++++xxxxx++++x+x++]\n-        let mut vec = vec![1,\n-                           2, 4, 6,\n-                           7, 9, 11, 13, 15, 17,\n-                           18, 20, 22, 24, 26,\n-                           27, 29, 31, 33,\n-                           34,\n-                           35,\n-                           36,\n-                           37, 39];\n+    {\n+        //                [+xxx++++++xxxxx++++x+x++]\n+        let mut vec = vec![\n+            1, 2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37,\n+            39,\n+        ];\n \n         let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -884,15 +870,11 @@ fn drain_filter_complex() {\n         assert_eq!(vec, vec![1, 7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]);\n     }\n \n-    {   //                [xxx++++++xxxxx++++x+x++]\n-        let mut vec = vec![2, 4, 6,\n-                           7, 9, 11, 13, 15, 17,\n-                           18, 20, 22, 24, 26,\n-                           27, 29, 31, 33,\n-                           34,\n-                           35,\n-                           36,\n-                           37, 39];\n+    {\n+        //                [xxx++++++xxxxx++++x+x++]\n+        let mut vec = vec![\n+            2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37, 39,\n+        ];\n \n         let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -902,14 +884,10 @@ fn drain_filter_complex() {\n         assert_eq!(vec, vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]);\n     }\n \n-    {   //                [xxx++++++xxxxx++++x+x]\n-        let mut vec = vec![2, 4, 6,\n-                           7, 9, 11, 13, 15, 17,\n-                           18, 20, 22, 24, 26,\n-                           27, 29, 31, 33,\n-                           34,\n-                           35,\n-                           36];\n+    {\n+        //                [xxx++++++xxxxx++++x+x]\n+        let mut vec =\n+            vec![2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36];\n \n         let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -919,9 +897,9 @@ fn drain_filter_complex() {\n         assert_eq!(vec, vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35]);\n     }\n \n-    {   //                [xxxxxxxxxx+++++++++++]\n-        let mut vec = vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n-                           1, 3, 5, 7, 9, 11, 13, 15, 17, 19];\n+    {\n+        //                [xxxxxxxxxx+++++++++++]\n+        let mut vec = vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];\n \n         let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -931,9 +909,9 @@ fn drain_filter_complex() {\n         assert_eq!(vec, vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n     }\n \n-    {   //                [+++++++++++xxxxxxxxxx]\n-        let mut vec = vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n-                           2, 4, 6, 8, 10, 12, 14, 16, 18, 20];\n+    {\n+        //                [+++++++++++xxxxxxxxxx]\n+        let mut vec = vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20];\n \n         let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -1082,7 +1060,6 @@ fn test_reserve_exact() {\n #[test]\n #[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n fn test_try_reserve() {\n-\n     // These are the interesting cases:\n     // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n     // * > isize::MAX should always fail\n@@ -1116,23 +1093,30 @@ fn test_try_reserve() {\n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             // Check usize::MAX does count as overflow\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n             if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n \n             // Check usize::MAX is an OOM\n             if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n@@ -1145,47 +1129,54 @@ fn test_try_reserve() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         // Should always overflow in the add-to-len\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n \n-\n     {\n         // Same basic idea, but with interesting type size\n         let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         // Should fail in the mul-by-size\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n     }\n-\n }\n \n #[test]\n #[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n-\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments.\n \n@@ -1206,20 +1197,27 @@ fn test_try_reserve_exact() {\n \n         if guards_against_isize {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n \n             if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n@@ -1231,36 +1229,46 @@ fn test_try_reserve_exact() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n \n-\n     {\n         let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n-\n }\n \n #[test]\n@@ -1311,18 +1319,11 @@ fn vec_macro_repeating_null_raw_fat_pointer() {\n     // Polyfill for https://github.com/rust-lang/rfcs/pull/2580\n \n     fn ptr_metadata(ptr: *mut dyn Fn()) -> *mut () {\n-        unsafe {\n-            std::mem::transmute::<*mut dyn Fn(), DynRepr>(ptr).vtable\n-        }\n+        unsafe { std::mem::transmute::<*mut dyn Fn(), DynRepr>(ptr).vtable }\n     }\n \n-    fn ptr_from_raw_parts(data: *mut (), vtable: *mut()) -> *mut dyn Fn() {\n-        unsafe {\n-            std::mem::transmute::<DynRepr, *mut dyn Fn()>(DynRepr {\n-                data,\n-                vtable\n-            })\n-        }\n+    fn ptr_from_raw_parts(data: *mut (), vtable: *mut ()) -> *mut dyn Fn() {\n+        unsafe { std::mem::transmute::<DynRepr, *mut dyn Fn()>(DynRepr { data, vtable }) }\n     }\n \n     #[repr(C)]"}, {"sha": "dcd7dc49526b60bb7a22a096bcf0f1479323c548", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 125, "deletions": 123, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -64,14 +64,14 @@ use core::intrinsics::{arith_offset, assume};\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::marker::PhantomData;\n use core::mem;\n-use core::ops::{self, Index, IndexMut, RangeBounds};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{self, Index, IndexMut, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice::{self, SliceIndex};\n \n-use crate::borrow::{ToOwned, Cow};\n-use crate::collections::TryReserveError;\n+use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n+use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n@@ -318,10 +318,7 @@ impl<T> Vec<T> {\n     #[rustc_const_stable(feature = \"const_vec_new\", since = \"1.32.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn new() -> Vec<T> {\n-        Vec {\n-            buf: RawVec::NEW,\n-            len: 0,\n-        }\n+        Vec { buf: RawVec::NEW, len: 0 }\n     }\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n@@ -355,10 +352,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> Vec<T> {\n-        Vec {\n-            buf: RawVec::with_capacity(capacity),\n-            len: 0,\n-        }\n+        Vec { buf: RawVec::with_capacity(capacity), len: 0 }\n     }\n \n     /// Decomposes a `Vec<T>` into its raw components.\n@@ -459,10 +453,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Vec<T> {\n-        Vec {\n-            buf: RawVec::from_raw_parts(ptr, capacity),\n-            len: length,\n-        }\n+        Vec { buf: RawVec::from_raw_parts(ptr, capacity), len: length }\n     }\n \n     /// Returns the number of elements the vector can hold without\n@@ -559,7 +550,7 @@ impl<T> Vec<T> {\n     /// }\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n-    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n     pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.buf.try_reserve(self.len, additional)\n     }\n@@ -599,8 +590,8 @@ impl<T> Vec<T> {\n     /// }\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n-    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.buf.try_reserve_exact(self.len, additional)\n     }\n \n@@ -647,7 +638,7 @@ impl<T> Vec<T> {\n     /// vec.shrink_to(0);\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n-    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"56431\")]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n         self.buf.shrink_to_fit(cmp::max(self.len, min_capacity));\n     }\n@@ -812,7 +803,9 @@ impl<T> Vec<T> {\n         // We shadow the slice method of the same name to avoid going through\n         // `deref`, which creates an intermediate reference.\n         let ptr = self.buf.ptr();\n-        unsafe { assume(!ptr.is_null()); }\n+        unsafe {\n+            assume(!ptr.is_null());\n+        }\n         ptr\n     }\n \n@@ -846,7 +839,9 @@ impl<T> Vec<T> {\n         // We shadow the slice method of the same name to avoid going through\n         // `deref_mut`, which creates an intermediate reference.\n         let ptr = self.buf.ptr();\n-        unsafe { assume(!ptr.is_null()); }\n+        unsafe {\n+            assume(!ptr.is_null());\n+        }\n         ptr\n     }\n \n@@ -1074,7 +1069,8 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n-        where F: FnMut(&T) -> bool\n+    where\n+        F: FnMut(&T) -> bool,\n     {\n         let len = self.len();\n         let mut del = 0;\n@@ -1110,7 +1106,11 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n     #[inline]\n-    pub fn dedup_by_key<F, K>(&mut self, mut key: F) where F: FnMut(&mut T) -> K, K: PartialEq {\n+    pub fn dedup_by_key<F, K>(&mut self, mut key: F)\n+    where\n+        F: FnMut(&mut T) -> K,\n+        K: PartialEq,\n+    {\n         self.dedup_by(|a, b| key(a) == key(b))\n     }\n \n@@ -1133,7 +1133,10 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n     /// ```\n     #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n-    pub fn dedup_by<F>(&mut self, same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n+    pub fn dedup_by<F>(&mut self, same_bucket: F)\n+    where\n+        F: FnMut(&mut T, &mut T) -> bool,\n+    {\n         let len = {\n             let (dedup, _) = self.as_mut_slice().partition_dedup_by(same_bucket);\n             dedup.len()\n@@ -1256,7 +1259,8 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<'_, T>\n-        where R: RangeBounds<usize>\n+    where\n+        R: RangeBounds<usize>,\n     {\n         // Memory safety\n         //\n@@ -1272,12 +1276,12 @@ impl<T> Vec<T> {\n         let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n-            Unbounded    => 0,\n+            Unbounded => 0,\n         };\n         let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n-            Unbounded    => len,\n+            Unbounded => len,\n         };\n         assert!(start <= end);\n         assert!(end <= len);\n@@ -1287,8 +1291,7 @@ impl<T> Vec<T> {\n             self.set_len(start);\n             // Use the borrow in the IterMut to indicate borrowing behavior of the\n             // whole Drain iterator (like &mut T).\n-            let range_slice = slice::from_raw_parts_mut(self.as_mut_ptr().add(start),\n-                                                        end - start);\n+            let range_slice = slice::from_raw_parts_mut(self.as_mut_ptr().add(start), end - start);\n             Drain {\n                 tail_start: end,\n                 tail_len: len - end,\n@@ -1380,9 +1383,7 @@ impl<T> Vec<T> {\n             self.set_len(at);\n             other.set_len(other_len);\n \n-            ptr::copy_nonoverlapping(self.as_ptr().add(at),\n-                                     other.as_mut_ptr(),\n-                                     other.len());\n+            ptr::copy_nonoverlapping(self.as_ptr().add(at), other.as_mut_ptr(), other.len());\n         }\n         other\n     }\n@@ -1418,7 +1419,8 @@ impl<T> Vec<T> {\n     /// [`Clone`]: ../../std/clone/trait.Clone.html\n     #[stable(feature = \"vec_resize_with\", since = \"1.33.0\")]\n     pub fn resize_with<F>(&mut self, new_len: usize, f: F)\n-        where F: FnMut() -> T\n+    where\n+        F: FnMut() -> T,\n     {\n         let len = self.len();\n         if new_len > len {\n@@ -1455,7 +1457,7 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn leak<'a>(vec: Vec<T>) -> &'a mut [T]\n     where\n-        T: 'a // Technically not needed, but kept to be explicit.\n+        T: 'a, // Technically not needed, but kept to be explicit.\n     {\n         Box::leak(vec.into_boxed_slice())\n     }\n@@ -1553,9 +1555,12 @@ impl<T: Default> Vec<T> {\n     /// [`Default`]: ../../std/default/trait.Default.html\n     /// [`Clone`]: ../../std/clone/trait.Clone.html\n     #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n-    #[rustc_deprecated(reason = \"This is moving towards being removed in favor \\\n+    #[rustc_deprecated(\n+        reason = \"This is moving towards being removed in favor \\\n         of `.resize_with(Default::default)`.  If you disagree, please comment \\\n-        in the tracking issue.\", since = \"1.33.0\")]\n+        in the tracking issue.\",\n+        since = \"1.33.0\"\n+    )]\n     pub fn resize_default(&mut self, new_len: usize) {\n         let len = self.len();\n \n@@ -1575,20 +1580,32 @@ trait ExtendWith<T> {\n \n struct ExtendElement<T>(T);\n impl<T: Clone> ExtendWith<T> for ExtendElement<T> {\n-    fn next(&mut self) -> T { self.0.clone() }\n-    fn last(self) -> T { self.0 }\n+    fn next(&mut self) -> T {\n+        self.0.clone()\n+    }\n+    fn last(self) -> T {\n+        self.0\n+    }\n }\n \n struct ExtendDefault;\n impl<T: Default> ExtendWith<T> for ExtendDefault {\n-    fn next(&mut self) -> T { Default::default() }\n-    fn last(self) -> T { Default::default() }\n+    fn next(&mut self) -> T {\n+        Default::default()\n+    }\n+    fn last(self) -> T {\n+        Default::default()\n+    }\n }\n \n struct ExtendFunc<F>(F);\n impl<T, F: FnMut() -> T> ExtendWith<T> for ExtendFunc<F> {\n-    fn next(&mut self) -> T { (self.0)() }\n-    fn last(mut self) -> T { (self.0)() }\n+    fn next(&mut self) -> T {\n+        (self.0)()\n+    }\n+    fn last(mut self) -> T {\n+        (self.0)()\n+    }\n }\n \n impl<T> Vec<T> {\n@@ -1718,10 +1735,7 @@ impl SpecFromElem for u8 {\n     #[inline]\n     fn from_elem(elem: u8, n: usize) -> Vec<u8> {\n         if elem == 0 {\n-            return Vec {\n-                buf: RawVec::with_capacity_zeroed(n),\n-                len: n,\n-            }\n+            return Vec { buf: RawVec::with_capacity_zeroed(n), len: n };\n         }\n         unsafe {\n             let mut v = Vec::with_capacity(n);\n@@ -1736,10 +1750,7 @@ impl<T: Clone + IsZero> SpecFromElem for T {\n     #[inline]\n     fn from_elem(elem: T, n: usize) -> Vec<T> {\n         if elem.is_zero() {\n-            return Vec {\n-                buf: RawVec::with_capacity_zeroed(n),\n-                len: n,\n-            }\n+            return Vec { buf: RawVec::with_capacity_zeroed(n), len: n };\n         }\n         let mut v = Vec::with_capacity(n);\n         v.extend_with(n, ExtendElement(elem));\n@@ -1760,7 +1771,7 @@ macro_rules! impl_is_zero {\n                 $is_zero(*self)\n             }\n         }\n-    }\n+    };\n }\n \n impl_is_zero!(i8, |x| x == 0);\n@@ -1821,7 +1832,6 @@ unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n     }\n }\n \n-\n ////////////////////////////////////////////////////////////////////////////////\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1857,8 +1867,8 @@ impl<T: Hash> Hash for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    message=\"vector indices are of type `usize` or ranges of `usize`\",\n-    label=\"vector indices are of type `usize` or ranges of `usize`\",\n+    message = \"vector indices are of type `usize` or ranges of `usize`\",\n+    label = \"vector indices are of type `usize` or ranges of `usize`\"\n )]\n impl<T, I: SliceIndex<[T]>> Index<I> for Vec<T> {\n     type Output = I::Output;\n@@ -1871,8 +1881,8 @@ impl<T, I: SliceIndex<[T]>> Index<I> for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    message=\"vector indices are of type `usize` or ranges of `usize`\",\n-    label=\"vector indices are of type `usize` or ranges of `usize`\",\n+    message = \"vector indices are of type `usize` or ranges of `usize`\",\n+    label = \"vector indices are of type `usize` or ranges of `usize`\"\n )]\n impl<T, I: SliceIndex<[T]>> IndexMut<I> for Vec<T> {\n     #[inline]\n@@ -1886,18 +1896,14 @@ impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n \n     fn deref(&self) -> &[T] {\n-        unsafe {\n-            slice::from_raw_parts(self.as_ptr(), self.len)\n-        }\n+        unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut(&mut self) -> &mut [T] {\n-        unsafe {\n-            slice::from_raw_parts_mut(self.as_mut_ptr(), self.len)\n-        }\n+        unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }\n     }\n }\n \n@@ -1984,7 +1990,8 @@ trait SpecExtend<T, I> {\n }\n \n impl<T, I> SpecExtend<T, I> for Vec<T>\n-    where I: Iterator<Item=T>,\n+where\n+    I: Iterator<Item = T>,\n {\n     default fn from_iter(mut iterator: I) -> Self {\n         // Unroll the first iteration, as the vector is going to be\n@@ -2014,7 +2021,8 @@ impl<T, I> SpecExtend<T, I> for Vec<T>\n }\n \n impl<T, I> SpecExtend<T, I> for Vec<T>\n-    where I: TrustedLen<Item=T>,\n+where\n+    I: TrustedLen<Item = T>,\n {\n     default fn from_iter(iterator: I) -> Self {\n         let mut vector = Vec::new();\n@@ -2026,9 +2034,12 @@ impl<T, I> SpecExtend<T, I> for Vec<T>\n         // This is the case for a TrustedLen iterator.\n         let (low, high) = iterator.size_hint();\n         if let Some(high_value) = high {\n-            debug_assert_eq!(low, high_value,\n-                             \"TrustedLen iterator's size hint is not exact: {:?}\",\n-                             (low, high));\n+            debug_assert_eq!(\n+                low,\n+                high_value,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n         }\n         if let Some(additional) = high {\n             self.reserve(additional);\n@@ -2055,9 +2066,7 @@ impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n         // has not been advanced at all.\n         if iterator.buf.as_ptr() as *const _ == iterator.ptr {\n             unsafe {\n-                let vec = Vec::from_raw_parts(iterator.buf.as_ptr(),\n-                                              iterator.len(),\n-                                              iterator.cap);\n+                let vec = Vec::from_raw_parts(iterator.buf.as_ptr(), iterator.len(), iterator.cap);\n                 mem::forget(iterator);\n                 vec\n             }\n@@ -2077,8 +2086,9 @@ impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n }\n \n impl<'a, T: 'a, I> SpecExtend<&'a T, I> for Vec<T>\n-    where I: Iterator<Item=&'a T>,\n-          T: Clone,\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Clone,\n {\n     default fn from_iter(iterator: I) -> Self {\n         SpecExtend::from_iter(iterator.cloned())\n@@ -2090,7 +2100,8 @@ impl<'a, T: 'a, I> SpecExtend<&'a T, I> for Vec<T>\n }\n \n impl<'a, T: 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T>\n-    where T: Copy,\n+where\n+    T: Copy,\n {\n     fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n         let slice = iterator.as_slice();\n@@ -2162,12 +2173,11 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n     pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter>\n-        where R: RangeBounds<usize>, I: IntoIterator<Item=T>\n+    where\n+        R: RangeBounds<usize>,\n+        I: IntoIterator<Item = T>,\n     {\n-        Splice {\n-            drain: self.drain(range),\n-            replace_with: replace_with.into_iter(),\n-        }\n+        Splice { drain: self.drain(range), replace_with: replace_with.into_iter() }\n     }\n \n     /// Creates an iterator which uses a closure to determine if an element should be removed.\n@@ -2217,21 +2227,17 @@ impl<T> Vec<T> {\n     /// ```\n     #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n     pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F>\n-        where F: FnMut(&mut T) -> bool,\n+    where\n+        F: FnMut(&mut T) -> bool,\n     {\n         let old_len = self.len();\n \n         // Guard against us getting leaked (leak amplification)\n-        unsafe { self.set_len(0); }\n-\n-        DrainFilter {\n-            vec: self,\n-            idx: 0,\n-            del: 0,\n-            old_len,\n-            pred: filter,\n-            panic_flag: false,\n+        unsafe {\n+            self.set_len(0);\n         }\n+\n+        DrainFilter { vec: self, idx: 0, del: 0, old_len, pred: filter, panic_flag: false }\n     }\n }\n \n@@ -2380,7 +2386,10 @@ impl<T: Clone> From<&mut [T]> for Vec<T> {\n }\n \n #[stable(feature = \"vec_from_cow_slice\", since = \"1.14.0\")]\n-impl<'a, T> From<Cow<'a, [T]>> for Vec<T> where [T]: ToOwned<Owned=Vec<T>> {\n+impl<'a, T> From<Cow<'a, [T]>> for Vec<T>\n+where\n+    [T]: ToOwned<Owned = Vec<T>>,\n+{\n     fn from(s: Cow<'a, [T]>) -> Vec<T> {\n         s.into_owned()\n     }\n@@ -2437,7 +2446,10 @@ impl<'a, T: Clone> From<&'a Vec<T>> for Cow<'a, [T]> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n+impl<'a, T> FromIterator<T> for Cow<'a, [T]>\n+where\n+    T: Clone,\n+{\n     fn from_iter<I: IntoIterator<Item = T>>(it: I) -> Cow<'a, [T]> {\n         Cow::Owned(FromIterator::from_iter(it))\n     }\n@@ -2466,9 +2478,7 @@ pub struct IntoIter<T> {\n #[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\n impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"IntoIter\")\n-            .field(&self.as_slice())\n-            .finish()\n+        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n     }\n }\n \n@@ -2486,9 +2496,7 @@ impl<T> IntoIter<T> {\n     /// ```\n     #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n     pub fn as_slice(&self) -> &[T] {\n-        unsafe {\n-            slice::from_raw_parts(self.ptr, self.len())\n-        }\n+        unsafe { slice::from_raw_parts(self.ptr, self.len()) }\n     }\n \n     /// Returns the remaining items of this iterator as a mutable slice.\n@@ -2506,9 +2514,7 @@ impl<T> IntoIter<T> {\n     /// ```\n     #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        unsafe {\n-            slice::from_raw_parts_mut(self.ptr as *mut T, self.len())\n-        }\n+        unsafe { slice::from_raw_parts_mut(self.ptr as *mut T, self.len()) }\n     }\n }\n \n@@ -2636,9 +2642,7 @@ pub struct Drain<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Drain\")\n-         .field(&self.iter.as_slice())\n-         .finish()\n+        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n     }\n }\n \n@@ -2711,7 +2715,6 @@ impl<T> Drop for Drain<'_, T> {\n     }\n }\n \n-\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<T> ExactSizeIterator for Drain<'_, T> {\n     fn is_empty(&self) -> bool {\n@@ -2762,7 +2765,6 @@ impl<I: Iterator> DoubleEndedIterator for Splice<'_, I> {\n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n impl<I: Iterator> ExactSizeIterator for Splice<'_, I> {}\n \n-\n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n impl<I: Iterator> Drop for Splice<'_, I> {\n     fn drop(&mut self) {\n@@ -2771,21 +2773,21 @@ impl<I: Iterator> Drop for Splice<'_, I> {\n         unsafe {\n             if self.drain.tail_len == 0 {\n                 self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n-                return\n+                return;\n             }\n \n             // First fill the range left by drain().\n             if !self.drain.fill(&mut self.replace_with) {\n-                return\n+                return;\n             }\n \n             // There may be more elements. Use the lower bound as an estimate.\n             // FIXME: Is the upper bound a better guess? Or something else?\n             let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n-            if lower_bound > 0  {\n+            if lower_bound > 0 {\n                 self.drain.move_tail(lower_bound);\n                 if !self.drain.fill(&mut self.replace_with) {\n-                    return\n+                    return;\n                 }\n             }\n \n@@ -2810,20 +2812,19 @@ impl<T> Drain<'_, T> {\n     /// that have been moved out.\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n     /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n-    unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n+    unsafe fn fill<I: Iterator<Item = T>>(&mut self, replace_with: &mut I) -> bool {\n         let vec = self.vec.as_mut();\n         let range_start = vec.len;\n         let range_end = self.tail_start;\n-        let range_slice = slice::from_raw_parts_mut(\n-            vec.as_mut_ptr().add(range_start),\n-            range_end - range_start);\n+        let range_slice =\n+            slice::from_raw_parts_mut(vec.as_mut_ptr().add(range_start), range_end - range_start);\n \n         for place in range_slice {\n             if let Some(new_item) = replace_with.next() {\n                 ptr::write(place, new_item);\n                 vec.len += 1;\n             } else {\n-                return false\n+                return false;\n             }\n         }\n         true\n@@ -2847,7 +2848,8 @@ impl<T> Drain<'_, T> {\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n #[derive(Debug)]\n pub struct DrainFilter<'a, T, F>\n-    where F: FnMut(&mut T) -> bool,\n+where\n+    F: FnMut(&mut T) -> bool,\n {\n     vec: &'a mut Vec<T>,\n     /// The index of the item that will be inspected by the next call to `next`.\n@@ -2868,7 +2870,8 @@ pub struct DrainFilter<'a, T, F>\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n impl<T, F> Iterator for DrainFilter<'_, T, F>\n-    where F: FnMut(&mut T) -> bool,\n+where\n+    F: FnMut(&mut T) -> bool,\n {\n     type Item = T;\n \n@@ -2905,19 +2908,20 @@ impl<T, F> Iterator for DrainFilter<'_, T, F>\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n impl<T, F> Drop for DrainFilter<'_, T, F>\n-    where F: FnMut(&mut T) -> bool,\n+where\n+    F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n         struct BackshiftOnDrop<'a, 'b, T, F>\n-            where\n-                F: FnMut(&mut T) -> bool,\n+        where\n+            F: FnMut(&mut T) -> bool,\n         {\n             drain: &'b mut DrainFilter<'a, T, F>,\n         }\n \n         impl<'a, 'b, T, F> Drop for BackshiftOnDrop<'a, 'b, T, F>\n-            where\n-                F: FnMut(&mut T) -> bool\n+        where\n+            F: FnMut(&mut T) -> bool,\n         {\n             fn drop(&mut self) {\n                 unsafe {\n@@ -2939,9 +2943,7 @@ impl<T, F> Drop for DrainFilter<'_, T, F>\n             }\n         }\n \n-        let backshift = BackshiftOnDrop {\n-            drain: self\n-        };\n+        let backshift = BackshiftOnDrop { drain: self };\n \n         // Attempt to consume any remaining elements if the filter predicate\n         // has not yet panicked. We'll backshift any remaining elements"}, {"sha": "beb0bac17d2ea0d3c6fcbe4042470c5a48206b6f", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 17, "deletions": 33, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -8,14 +8,14 @@\n //! This crate implements `TypedArena`, a simple arena that can only hold\n //! objects of a single type.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       test(no_crate_inject, attr(deny(warnings))))]\n-\n+#![doc(\n+    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+    test(no_crate_inject, attr(deny(warnings)))\n+)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(raw_vec_internals)]\n #![cfg_attr(test, feature(test))]\n-\n #![allow(deprecated)]\n \n extern crate alloc;\n@@ -61,10 +61,7 @@ struct TypedArenaChunk<T> {\n impl<T> TypedArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n-        TypedArenaChunk {\n-            storage: RawVec::with_capacity(capacity),\n-            entries: 0,\n-        }\n+        TypedArenaChunk { storage: RawVec::with_capacity(capacity), entries: 0 }\n     }\n \n     /// Destroys this arena chunk.\n@@ -133,9 +130,7 @@ impl<T> TypedArena<T> {\n \n         unsafe {\n             if mem::size_of::<T>() == 0 {\n-                self.ptr\n-                    .set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1)\n-                        as *mut T);\n+                self.ptr.set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1) as *mut T);\n                 let ptr = mem::align_of::<T>() as *mut T;\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);\n@@ -260,7 +255,7 @@ impl<T> TypedArena<T> {\n                 self.clear_last_chunk(&mut last_chunk);\n                 let len = chunks_borrow.len();\n                 // If `T` is ZST, code below has no effect.\n-                for mut chunk in chunks_borrow.drain(..len-1) {\n+                for mut chunk in chunks_borrow.drain(..len - 1) {\n                     chunk.destroy(chunk.entries);\n                 }\n             }\n@@ -360,10 +355,7 @@ impl DroplessArena {\n             let (chunk, mut new_capacity);\n             if let Some(last_chunk) = chunks.last_mut() {\n                 let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n-                if last_chunk\n-                    .storage\n-                    .reserve_in_place(used_bytes, needed_bytes)\n-                {\n+                if last_chunk.storage.reserve_in_place(used_bytes, needed_bytes) {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n@@ -399,9 +391,7 @@ impl DroplessArena {\n \n             let ptr = self.ptr.get();\n             // Set the pointer past ourselves\n-            self.ptr.set(\n-                intrinsics::arith_offset(self.ptr.get(), bytes as isize) as *mut u8,\n-            );\n+            self.ptr.set(intrinsics::arith_offset(self.ptr.get(), bytes as isize) as *mut u8);\n             slice::from_raw_parts_mut(ptr, bytes)\n         }\n     }\n@@ -410,9 +400,7 @@ impl DroplessArena {\n     pub fn alloc<T>(&self, object: T) -> &mut T {\n         assert!(!mem::needs_drop::<T>());\n \n-        let mem = self.alloc_raw(\n-            mem::size_of::<T>(),\n-            mem::align_of::<T>()) as *mut _ as *mut T;\n+        let mem = self.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut _ as *mut T;\n \n         unsafe {\n             // Write into uninitialized memory.\n@@ -437,9 +425,8 @@ impl DroplessArena {\n         assert!(mem::size_of::<T>() != 0);\n         assert!(!slice.is_empty());\n \n-        let mem = self.alloc_raw(\n-            slice.len() * mem::size_of::<T>(),\n-            mem::align_of::<T>()) as *mut _ as *mut T;\n+        let mem = self.alloc_raw(slice.len() * mem::size_of::<T>(), mem::align_of::<T>()) as *mut _\n+            as *mut T;\n \n         unsafe {\n             let arena_slice = slice::from_raw_parts_mut(mem, slice.len());\n@@ -484,13 +471,11 @@ impl DroplessArena {\n                 let len = min;\n \n                 if len == 0 {\n-                    return &mut []\n+                    return &mut [];\n                 }\n                 let size = len.checked_mul(mem::size_of::<T>()).unwrap();\n                 let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut _ as *mut T;\n-                unsafe {\n-                    self.write_from_iter(iter, len, mem)\n-                }\n+                unsafe { self.write_from_iter(iter, len, mem) }\n             }\n             (_, _) => {\n                 cold_path(move || -> &mut [T] {\n@@ -502,10 +487,9 @@ impl DroplessArena {\n                     // the content of the SmallVec\n                     unsafe {\n                         let len = vec.len();\n-                        let start_ptr = self.alloc_raw(\n-                            len * mem::size_of::<T>(),\n-                            mem::align_of::<T>()\n-                        ) as *mut _ as *mut T;\n+                        let start_ptr = self\n+                            .alloc_raw(len * mem::size_of::<T>(), mem::align_of::<T>())\n+                            as *mut _ as *mut T;\n                         vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n                         vec.set_len(0);\n                         slice::from_raw_parts_mut(start_ptr, len)"}, {"sha": "8e63bdf545841b727ff59e1dd41eb1430750c9d4", "filename": "src/libarena/tests.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibarena%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibarena%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Ftests.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,7 +1,7 @@\n extern crate test;\n-use test::Bencher;\n use super::TypedArena;\n use std::cell::Cell;\n+use test::Bencher;\n \n #[allow(dead_code)]\n #[derive(Debug, Eq, PartialEq)]\n@@ -53,9 +53,7 @@ fn test_arena_alloc_nested() {\n \n     let arena = Wrap(TypedArena::default());\n \n-    let result = arena.alloc_outer(|| Outer {\n-        inner: arena.alloc_inner(|| Inner { value: 10 }),\n-    });\n+    let result = arena.alloc_outer(|| Outer { inner: arena.alloc_inner(|| Inner { value: 10 }) });\n \n     assert_eq!(result.inner.value, 10);\n }\n@@ -91,10 +89,7 @@ struct Noncopy {\n pub fn test_noncopy() {\n     let arena = TypedArena::default();\n     for _ in 0..100000 {\n-        arena.alloc(Noncopy {\n-            string: \"hello world\".to_string(),\n-            array: vec![1, 2, 3, 4, 5],\n-        });\n+        arena.alloc(Noncopy { string: \"hello world\".to_string(), array: vec![1, 2, 3, 4, 5] });\n     }\n }\n \n@@ -195,19 +190,14 @@ fn test_typed_arena_drop_small_count() {\n pub fn bench_noncopy(b: &mut Bencher) {\n     let arena = TypedArena::default();\n     b.iter(|| {\n-        arena.alloc(Noncopy {\n-            string: \"hello world\".to_string(),\n-            array: vec![1, 2, 3, 4, 5],\n-        })\n+        arena.alloc(Noncopy { string: \"hello world\".to_string(), array: vec![1, 2, 3, 4, 5] })\n     })\n }\n \n #[bench]\n pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n     b.iter(|| {\n-        let _: Box<_> = Box::new(Noncopy {\n-            string: \"hello world\".to_string(),\n-            array: vec![1, 2, 3, 4, 5],\n-        });\n+        let _: Box<_> =\n+            Box::new(Noncopy { string: \"hello world\".to_string(), array: vec![1, 2, 3, 4, 5] });\n     })\n }"}, {"sha": "b2d4b1b5fb91604ed310171da3dde8812a359a65", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 71, "deletions": 96, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -7,9 +7,9 @@\n use crate::cmp;\n use crate::fmt;\n use crate::mem;\n-use crate::usize;\n-use crate::ptr::{self, NonNull};\n use crate::num::NonZeroUsize;\n+use crate::ptr::{self, NonNull};\n+use crate::usize;\n \n /// Represents the combination of a starting address and\n /// a total capacity of the returned block.\n@@ -88,9 +88,7 @@ impl Layout {\n             return Err(LayoutErr { private: () });\n         }\n \n-        unsafe {\n-            Ok(Layout::from_size_align_unchecked(size, align))\n-        }\n+        unsafe { Ok(Layout::from_size_align_unchecked(size, align)) }\n     }\n \n     /// Creates a layout, bypassing all checks.\n@@ -109,12 +107,16 @@ impl Layout {\n     /// The minimum size in bytes for a memory block of this layout.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n-    pub fn size(&self) -> usize { self.size_ }\n+    pub fn size(&self) -> usize {\n+        self.size_\n+    }\n \n     /// The minimum byte alignment for a memory block of this layout.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n-    pub fn align(&self) -> usize { self.align_.get() }\n+    pub fn align(&self) -> usize {\n+        self.align_.get()\n+    }\n \n     /// Constructs a `Layout` suitable for holding a value of type `T`.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n@@ -126,9 +128,7 @@ impl Layout {\n         // result use the unchecked constructor here to avoid inserting code\n         // that panics if it isn't optimized well enough.\n         debug_assert!(Layout::from_size_align(size, align).is_ok());\n-        unsafe {\n-            Layout::from_size_align_unchecked(size, align)\n-        }\n+        unsafe { Layout::from_size_align_unchecked(size, align) }\n     }\n \n     /// Produces layout describing a record that could be used to\n@@ -140,9 +140,7 @@ impl Layout {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n         // See rationale in `new` for why this is using an unsafe variant below\n         debug_assert!(Layout::from_size_align(size, align).is_ok());\n-        unsafe {\n-            Layout::from_size_align_unchecked(size, align)\n-        }\n+        unsafe { Layout::from_size_align_unchecked(size, align) }\n     }\n \n     /// Creates a layout describing the record that can hold a value\n@@ -206,8 +204,7 @@ impl Layout {\n         // size and padding overflow in the above manner should cause\n         // the allocator to yield an error anyway.)\n \n-        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1)\n-            & !align.wrapping_sub(1);\n+        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);\n         len_rounded_up.wrapping_sub(len)\n     }\n \n@@ -245,8 +242,7 @@ impl Layout {\n         // > must not overflow (i.e., the rounded value must be less than\n         // > `usize::MAX`)\n         let padded_size = self.size() + self.padding_needed_for(self.align());\n-        let alloc_size = padded_size.checked_mul(n)\n-            .ok_or(LayoutErr { private: () })?;\n+        let alloc_size = padded_size.checked_mul(n).ok_or(LayoutErr { private: () })?;\n \n         unsafe {\n             // self.align is already known to be valid and alloc_size has been\n@@ -275,10 +271,8 @@ impl Layout {\n         let new_align = cmp::max(self.align(), next.align());\n         let pad = self.padding_needed_for(next.align());\n \n-        let offset = self.size().checked_add(pad)\n-            .ok_or(LayoutErr { private: () })?;\n-        let new_size = offset.checked_add(next.size())\n-            .ok_or(LayoutErr { private: () })?;\n+        let offset = self.size().checked_add(pad).ok_or(LayoutErr { private: () })?;\n+        let new_size = offset.checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n \n         let layout = Layout::from_size_align(new_size, new_align)?;\n         Ok((layout, offset))\n@@ -312,8 +306,7 @@ impl Layout {\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n     #[inline]\n     pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutErr> {\n-        let new_size = self.size().checked_add(next.size())\n-            .ok_or(LayoutErr { private: () })?;\n+        let new_size = self.size().checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n         Layout::from_size_align(new_size, self.align())\n     }\n \n@@ -323,12 +316,10 @@ impl Layout {\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n     #[inline]\n     pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n-        Layout::new::<T>()\n-            .repeat(n)\n-            .map(|(k, offs)| {\n-                debug_assert!(offs == mem::size_of::<T>());\n-                k\n-            })\n+        Layout::new::<T>().repeat(n).map(|(k, offs)| {\n+            debug_assert!(offs == mem::size_of::<T>());\n+            k\n+        })\n     }\n }\n \n@@ -338,7 +329,7 @@ impl Layout {\n #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct LayoutErr {\n-    private: ()\n+    private: (),\n }\n \n // (we need this for downstream impl of trait Error)\n@@ -577,11 +568,7 @@ pub unsafe trait GlobalAlloc {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let new_ptr = self.alloc(new_layout);\n         if !new_ptr.is_null() {\n-            ptr::copy_nonoverlapping(\n-                ptr,\n-                new_ptr,\n-                cmp::min(layout.size(), new_size),\n-            );\n+            ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n             self.dealloc(ptr, layout);\n         }\n         new_ptr\n@@ -669,7 +656,6 @@ pub unsafe trait GlobalAlloc {\n /// the future.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait Alloc {\n-\n     // (Note: some existing allocators have unspecified but well-defined\n     // behavior in response to a zero size allocation request ;\n     // e.g., in C, `malloc` of 0 will either return a null pointer or a\n@@ -826,10 +812,12 @@ pub unsafe trait Alloc {\n     /// rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc(&mut self,\n-                      ptr: NonNull<u8>,\n-                      layout: Layout,\n-                      new_size: usize) -> Result<NonNull<u8>, AllocErr> {\n+    unsafe fn realloc(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<NonNull<u8>, AllocErr> {\n         let old_size = layout.size();\n \n         if new_size >= old_size {\n@@ -846,9 +834,7 @@ pub unsafe trait Alloc {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let result = self.alloc(new_layout);\n         if let Ok(new_ptr) = result {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(),\n-                                     new_ptr.as_ptr(),\n-                                     cmp::min(old_size, new_size));\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n             self.dealloc(ptr, layout);\n         }\n         result\n@@ -924,14 +910,15 @@ pub unsafe trait Alloc {\n     /// rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_excess(&mut self,\n-                             ptr: NonNull<u8>,\n-                             layout: Layout,\n-                             new_size: usize) -> Result<Excess, AllocErr> {\n+    unsafe fn realloc_excess(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<Excess, AllocErr> {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let usable_size = self.usable_size(&new_layout);\n-        self.realloc(ptr, layout, new_size)\n-            .map(|p| Excess(p, usable_size.1))\n+        self.realloc(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n     }\n \n     /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n@@ -969,20 +956,18 @@ pub unsafe trait Alloc {\n     /// function; clients are expected either to be able to recover from\n     /// `grow_in_place` failures without aborting, or to fall back on\n     /// another reallocation method before resorting to an abort.\n-    unsafe fn grow_in_place(&mut self,\n-                            ptr: NonNull<u8>,\n-                            layout: Layout,\n-                            new_size: usize) -> Result<(), CannotReallocInPlace> {\n+    unsafe fn grow_in_place(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n         debug_assert!(new_size >= layout.size());\n         let (_l, u) = self.usable_size(&layout);\n         // _l <= layout.size()                       [guaranteed by usable_size()]\n         //       layout.size() <= new_layout.size()  [required by this method]\n-        if new_size <= u {\n-            Ok(())\n-        } else {\n-            Err(CannotReallocInPlace)\n-        }\n+        if new_size <= u { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n \n     /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n@@ -1024,23 +1009,20 @@ pub unsafe trait Alloc {\n     /// function; clients are expected either to be able to recover from\n     /// `shrink_in_place` failures without aborting, or to fall back\n     /// on another reallocation method before resorting to an abort.\n-    unsafe fn shrink_in_place(&mut self,\n-                              ptr: NonNull<u8>,\n-                              layout: Layout,\n-                              new_size: usize) -> Result<(), CannotReallocInPlace> {\n+    unsafe fn shrink_in_place(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n         debug_assert!(new_size <= layout.size());\n         let (l, _u) = self.usable_size(&layout);\n         //                      layout.size() <= _u  [guaranteed by usable_size()]\n         // new_layout.size() <= layout.size()        [required by this method]\n-        if l <= new_size {\n-            Ok(())\n-        } else {\n-            Err(CannotReallocInPlace)\n-        }\n+        if l <= new_size { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n \n-\n     // == COMMON USAGE PATTERNS ==\n     // alloc_one, dealloc_one, alloc_array, realloc_array. dealloc_array\n \n@@ -1074,14 +1056,11 @@ pub unsafe trait Alloc {\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>\n-        where Self: Sized\n+    where\n+        Self: Sized,\n     {\n         let k = Layout::new::<T>();\n-        if k.size() > 0 {\n-            unsafe { self.alloc(k).map(|p| p.cast()) }\n-        } else {\n-            Err(AllocErr)\n-        }\n+        if k.size() > 0 { unsafe { self.alloc(k).map(|p| p.cast()) } } else { Err(AllocErr) }\n     }\n \n     /// Deallocates a block suitable for holding an instance of `T`.\n@@ -1102,7 +1081,8 @@ pub unsafe trait Alloc {\n     ///\n     /// * the layout of `T` must *fit* that block of memory.\n     unsafe fn dealloc_one<T>(&mut self, ptr: NonNull<T>)\n-        where Self: Sized\n+    where\n+        Self: Sized,\n     {\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n@@ -1143,14 +1123,11 @@ pub unsafe trait Alloc {\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>\n-        where Self: Sized\n+    where\n+        Self: Sized,\n     {\n         match Layout::array::<T>(n) {\n-            Ok(layout) if layout.size() > 0 => {\n-                unsafe {\n-                    self.alloc(layout).map(|p| p.cast())\n-                }\n-            }\n+            Ok(layout) if layout.size() > 0 => unsafe { self.alloc(layout).map(|p| p.cast()) },\n             _ => Err(AllocErr),\n         }\n     }\n@@ -1189,20 +1166,21 @@ pub unsafe trait Alloc {\n     /// rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_array<T>(&mut self,\n-                               ptr: NonNull<T>,\n-                               n_old: usize,\n-                               n_new: usize) -> Result<NonNull<T>, AllocErr>\n-        where Self: Sized\n+    unsafe fn realloc_array<T>(\n+        &mut self,\n+        ptr: NonNull<T>,\n+        n_old: usize,\n+        n_new: usize,\n+    ) -> Result<NonNull<T>, AllocErr>\n+    where\n+        Self: Sized,\n     {\n         match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n             (Ok(k_old), Ok(k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n                 debug_assert!(k_old.align() == k_new.align());\n                 self.realloc(ptr.cast(), k_old, k_new.size()).map(NonNull::cast)\n             }\n-            _ => {\n-                Err(AllocErr)\n-            }\n+            _ => Err(AllocErr),\n         }\n     }\n \n@@ -1227,15 +1205,12 @@ pub unsafe trait Alloc {\n     ///\n     /// Always returns `Err` on arithmetic overflow.\n     unsafe fn dealloc_array<T>(&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>\n-        where Self: Sized\n+    where\n+        Self: Sized,\n     {\n         match Layout::array::<T>(n) {\n-            Ok(k) if k.size() > 0 => {\n-                Ok(self.dealloc(ptr.cast(), k))\n-            }\n-            _ => {\n-                Err(AllocErr)\n-            }\n+            Ok(k) if k.size() > 0 => Ok(self.dealloc(ptr.cast(), k)),\n+            _ => Err(AllocErr),\n         }\n     }\n }"}, {"sha": "4afea12a362c89f04810544c1c4f46448f1a4d56", "filename": "src/libcore/any.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -105,8 +105,10 @@ pub trait Any: 'static {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: 'static + ?Sized > Any for T {\n-    fn type_id(&self) -> TypeId { TypeId::of::<T>() }\n+impl<T: 'static + ?Sized> Any for T {\n+    fn type_id(&self) -> TypeId {\n+        TypeId::of::<T>()\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -193,9 +195,7 @@ impl dyn Any {\n     pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n         if self.is::<T>() {\n             // SAFETY: just checked whether we are pointing to the correct type\n-            unsafe {\n-                Some(&*(self as *const dyn Any as *const T))\n-            }\n+            unsafe { Some(&*(self as *const dyn Any as *const T)) }\n         } else {\n             None\n         }\n@@ -229,16 +229,14 @@ impl dyn Any {\n     pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n             // SAFETY: just checked whether we are pointing to the correct type\n-            unsafe {\n-                Some(&mut *(self as *mut dyn Any as *mut T))\n-            }\n+            unsafe { Some(&mut *(self as *mut dyn Any as *mut T)) }\n         } else {\n             None\n         }\n     }\n }\n \n-impl dyn Any+Send {\n+impl dyn Any + Send {\n     /// Forwards to the method defined on the type `Any`.\n     ///\n     /// # Examples\n@@ -316,7 +314,7 @@ impl dyn Any+Send {\n     }\n }\n \n-impl dyn Any+Send+Sync {\n+impl dyn Any + Send + Sync {\n     /// Forwards to the method defined on the type `Any`.\n     ///\n     /// # Examples\n@@ -433,11 +431,9 @@ impl TypeId {\n     /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature=\"const_type_id\", issue = \"41875\")]\n+    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"41875\")]\n     pub const fn of<T: ?Sized + 'static>() -> TypeId {\n-        TypeId {\n-            t: intrinsics::type_id::<T>(),\n-        }\n+        TypeId { t: intrinsics::type_id::<T>() }\n     }\n }\n "}, {"sha": "80eaae0d4afb5ef1eb9f87358b5907749d347981", "filename": "src/libcore/array/iter.rs", "status": "modified", "additions": 16, "deletions": 38, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,14 +1,13 @@\n //! Defines the `IntoIter` owned iterator for arrays.\n \n+use super::LengthAtMost32;\n use crate::{\n     fmt,\n     iter::{ExactSizeIterator, FusedIterator, TrustedLen},\n     mem::{self, MaybeUninit},\n     ops::Range,\n     ptr,\n };\n-use super::LengthAtMost32;\n-\n \n /// A by-value [array] iterator.\n ///\n@@ -40,7 +39,7 @@ where\n     alive: Range<usize>,\n }\n \n-impl<T, const N: usize> IntoIter<T, {N}>\n+impl<T, const N: usize> IntoIter<T, { N }>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -75,10 +74,7 @@ where\n             data\n         };\n \n-        Self {\n-            data,\n-            alive: 0..N,\n-        }\n+        Self { data, alive: 0..N }\n     }\n \n     /// Returns an immutable slice of all elements that have not been yielded\n@@ -88,9 +84,7 @@ where\n         // SAFETY: This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n         // the size and alignment of `T`. Furthermore, we know that all\n         // elements within `alive` are properly initialized.\n-        unsafe {\n-            mem::transmute::<&[MaybeUninit<T>], &[T]>(slice)\n-        }\n+        unsafe { mem::transmute::<&[MaybeUninit<T>], &[T]>(slice) }\n     }\n \n     /// Returns a mutable slice of all elements that have not been yielded yet.\n@@ -100,15 +94,12 @@ where\n         // SAFETY: This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n         // the size and alignment of `T`. Furthermore, we know that all\n         // elements within `alive` are properly initialized.\n-        unsafe {\n-            mem::transmute::<&mut [MaybeUninit<T>], &mut [T]>(slice)\n-        }\n+        unsafe { mem::transmute::<&mut [MaybeUninit<T>], &mut [T]>(slice) }\n     }\n }\n \n-\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> Iterator for IntoIter<T, {N}>\n+impl<T, const N: usize> Iterator for IntoIter<T, { N }>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -155,7 +146,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, {N}>\n+impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, { N }>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -191,22 +182,20 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> Drop for IntoIter<T, {N}>\n+impl<T, const N: usize> Drop for IntoIter<T, { N }>\n where\n     [T; N]: LengthAtMost32,\n {\n     fn drop(&mut self) {\n         // SAFETY: This is safe: `as_mut_slice` returns exactly the sub-slice\n         // of elements that have not been moved out yet and that remain\n         // to be dropped.\n-        unsafe {\n-            ptr::drop_in_place(self.as_mut_slice())\n-        }\n+        unsafe { ptr::drop_in_place(self.as_mut_slice()) }\n     }\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> ExactSizeIterator for IntoIter<T, {N}>\n+impl<T, const N: usize> ExactSizeIterator for IntoIter<T, { N }>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -221,23 +210,17 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> FusedIterator for IntoIter<T, {N}>\n-where\n-    [T; N]: LengthAtMost32,\n-{}\n+impl<T, const N: usize> FusedIterator for IntoIter<T, { N }> where [T; N]: LengthAtMost32 {}\n \n // The iterator indeed reports the correct length. The number of \"alive\"\n // elements (that will still be yielded) is the length of the range `alive`.\n // This range is decremented in length in either `next` or `next_back`. It is\n // always decremented by 1 in those methods, but only if `Some(_)` is returned.\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, {N}>\n-where\n-    [T; N]: LengthAtMost32,\n-{}\n+unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, { N }> where [T; N]: LengthAtMost32 {}\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T: Clone, const N: usize> Clone for IntoIter<T, {N}>\n+impl<T: Clone, const N: usize> Clone for IntoIter<T, { N }>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -260,24 +243,19 @@ where\n                 new_data.get_unchecked_mut(idx).write(clone);\n             }\n \n-            Self {\n-                data: new_data,\n-                alive: self.alive.clone(),\n-            }\n+            Self { data: new_data, alive: self.alive.clone() }\n         }\n     }\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, {N}>\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, { N }>\n where\n     [T; N]: LengthAtMost32,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Only print the elements that were not yielded yet: we cannot\n         // access the yielded elements anymore.\n-        f.debug_tuple(\"IntoIter\")\n-            .field(&self.as_slice())\n-            .finish()\n+        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n     }\n }"}, {"sha": "937451274cfc2fe85b94c55945df8a78f5aec627", "filename": "src/libcore/array/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -10,7 +10,7 @@ use crate::borrow::{Borrow, BorrowMut};\n use crate::cmp::Ordering;\n use crate::convert::{Infallible, TryFrom};\n use crate::fmt;\n-use crate::hash::{Hash, self};\n+use crate::hash::{self, Hash};\n use crate::marker::Unsize;\n use crate::slice::{Iter, IterMut};\n \n@@ -71,10 +71,12 @@ impl fmt::Display for TryFromSliceError {\n }\n \n impl TryFromSliceError {\n-    #[unstable(feature = \"array_error_internals\",\n-           reason = \"available through Error trait and this method should not \\\n+    #[unstable(\n+        feature = \"array_error_internals\",\n+        reason = \"available through Error trait and this method should not \\\n                      be exposed publicly\",\n-           issue = \"none\")]\n+        issue = \"none\"\n+    )]\n     #[inline]\n     #[doc(hidden)]\n     pub fn __description(&self) -> &str {\n@@ -385,11 +387,12 @@ where\n }\n \n /// Implemented for lengths where trait impls are allowed on arrays in core/std\n-#[rustc_on_unimplemented(\n-    message=\"arrays only have std trait implementations for lengths 0..=32\",\n+#[rustc_on_unimplemented(message = \"arrays only have std trait implementations for lengths 0..=32\")]\n+#[unstable(\n+    feature = \"const_generic_impls_guard\",\n+    issue = \"none\",\n+    reason = \"will never be stable, just a temporary step until const generics are stable\"\n )]\n-#[unstable(feature = \"const_generic_impls_guard\", issue = \"none\",\n-    reason = \"will never be stable, just a temporary step until const generics are stable\")]\n pub trait LengthAtMost32 {}\n \n macro_rules! array_impls {\n@@ -429,4 +432,4 @@ macro_rules! array_impl_default {\n     };\n }\n \n-array_impl_default!{32, T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T}\n+array_impl_default! {32, T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T}"}, {"sha": "480ac6f36d202bc4d50fb16aa45a41b27bcc5e48", "filename": "src/libcore/benches/pattern.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fbenches%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fbenches%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fpattern.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -21,7 +21,6 @@ fn starts_with_str(b: &mut Bencher) {\n     })\n }\n \n-\n #[bench]\n fn ends_with_char(b: &mut Bencher) {\n     let text = black_box(\"kdjsfhlakfhlsghlkvcnljknfqiunvcijqenwodind\");"}, {"sha": "3e533255becb5e48a86dd72a5e32686c76ff642a", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -189,7 +189,7 @@ pub trait Borrow<Borrowed: ?Sized> {\n ///\n /// [`Borrow<T>`]: trait.Borrow.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n+pub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {\n     /// Mutably borrows from an owned value.\n     ///\n     /// # Examples\n@@ -211,25 +211,35 @@ pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Borrow<T> for T {\n-    fn borrow(&self) -> &T { self }\n+    fn borrow(&self) -> &T {\n+        self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> BorrowMut<T> for T {\n-    fn borrow_mut(&mut self) -> &mut T { self }\n+    fn borrow_mut(&mut self) -> &mut T {\n+        self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Borrow<T> for &T {\n-    fn borrow(&self) -> &T { &**self }\n+    fn borrow(&self) -> &T {\n+        &**self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Borrow<T> for &mut T {\n-    fn borrow(&self) -> &T { &**self }\n+    fn borrow(&self) -> &T {\n+        &**self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> BorrowMut<T> for &mut T {\n-    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n+    fn borrow_mut(&mut self) -> &mut T {\n+        &mut **self\n+    }\n }"}, {"sha": "4fcd0d9737d562252f7d82508e57e0beeba21e6e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 29, "deletions": 52, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -195,7 +195,7 @@ use crate::cmp::Ordering;\n use crate::fmt::{self, Debug, Display};\n use crate::marker::Unsize;\n use crate::mem;\n-use crate::ops::{Deref, DerefMut, CoerceUnsized};\n+use crate::ops::{CoerceUnsized, Deref, DerefMut};\n use crate::ptr;\n \n /// A mutable memory location.\n@@ -243,7 +243,7 @@ unsafe impl<T: ?Sized> Send for Cell<T> where T: Send {}\n impl<T: ?Sized> !Sync for Cell<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T:Copy> Clone for Cell<T> {\n+impl<T: Copy> Clone for Cell<T> {\n     #[inline]\n     fn clone(&self) -> Cell<T> {\n         Cell::new(self.get())\n@@ -327,9 +327,7 @@ impl<T> Cell<T> {\n     #[rustc_const_stable(feature = \"const_cell_new\", since = \"1.32.0\")]\n     #[inline]\n     pub const fn new(value: T) -> Cell<T> {\n-        Cell {\n-            value: UnsafeCell::new(value),\n-        }\n+        Cell { value: UnsafeCell::new(value) }\n     }\n \n     /// Sets the contained value.\n@@ -410,7 +408,7 @@ impl<T> Cell<T> {\n     }\n }\n \n-impl<T:Copy> Cell<T> {\n+impl<T: Copy> Cell<T> {\n     /// Returns a copy of the contained value.\n     ///\n     /// # Examples\n@@ -425,7 +423,7 @@ impl<T:Copy> Cell<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> T {\n-        unsafe{ *self.value.get() }\n+        unsafe { *self.value.get() }\n     }\n \n     /// Updates the contained value using a function and returns the new value.\n@@ -493,9 +491,7 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n-        unsafe {\n-            &mut *self.value.get()\n-        }\n+        unsafe { &mut *self.value.get() }\n     }\n \n     /// Returns a `&Cell<T>` from a `&mut T`\n@@ -514,9 +510,7 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"as_cell\", since = \"1.37.0\")]\n     pub fn from_mut(t: &mut T) -> &Cell<T> {\n-        unsafe {\n-            &*(t as *mut T as *const Cell<T>)\n-        }\n+        unsafe { &*(t as *mut T as *const Cell<T>) }\n     }\n }\n \n@@ -559,9 +553,7 @@ impl<T> Cell<[T]> {\n     /// ```\n     #[stable(feature = \"as_cell\", since = \"1.37.0\")]\n     pub fn as_slice_of_cells(&self) -> &[Cell<T>] {\n-        unsafe {\n-            &*(self as *const Cell<[T]> as *const [Cell<T>])\n-        }\n+        unsafe { &*(self as *const Cell<[T]> as *const [Cell<T>]) }\n     }\n }\n \n@@ -654,10 +646,7 @@ impl<T> RefCell<T> {\n     #[rustc_const_stable(feature = \"const_refcell_new\", since = \"1.32.0\")]\n     #[inline]\n     pub const fn new(value: T) -> RefCell<T> {\n-        RefCell {\n-            value: UnsafeCell::new(value),\n-            borrow: Cell::new(UNUSED),\n-        }\n+        RefCell { value: UnsafeCell::new(value), borrow: Cell::new(UNUSED) }\n     }\n \n     /// Consumes the `RefCell`, returning the wrapped value.\n@@ -700,7 +689,7 @@ impl<T> RefCell<T> {\n     /// assert_eq!(cell, RefCell::new(6));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"refcell_replace\", since=\"1.24.0\")]\n+    #[stable(feature = \"refcell_replace\", since = \"1.24.0\")]\n     pub fn replace(&self, t: T) -> T {\n         mem::replace(&mut *self.borrow_mut(), t)\n     }\n@@ -722,7 +711,7 @@ impl<T> RefCell<T> {\n     /// assert_eq!(cell, RefCell::new(6));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"refcell_replace_swap\", since=\"1.35.0\")]\n+    #[stable(feature = \"refcell_replace_swap\", since = \"1.35.0\")]\n     pub fn replace_with<F: FnOnce(&mut T) -> T>(&self, f: F) -> T {\n         let mut_borrow = &mut *self.borrow_mut();\n         let replacement = f(mut_borrow);\n@@ -749,7 +738,7 @@ impl<T> RefCell<T> {\n     /// assert_eq!(d, RefCell::new(5));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"refcell_swap\", since=\"1.24.0\")]\n+    #[stable(feature = \"refcell_swap\", since = \"1.24.0\")]\n     pub fn swap(&self, other: &Self) {\n         mem::swap(&mut *self.borrow_mut(), &mut *other.borrow_mut())\n     }\n@@ -827,10 +816,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub fn try_borrow(&self) -> Result<Ref<'_, T>, BorrowError> {\n         match BorrowRef::new(&self.borrow) {\n-            Some(b) => Ok(Ref {\n-                value: unsafe { &*self.value.get() },\n-                borrow: b,\n-            }),\n+            Some(b) => Ok(Ref { value: unsafe { &*self.value.get() }, borrow: b }),\n             None => Err(BorrowError { _private: () }),\n         }\n     }\n@@ -905,10 +891,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub fn try_borrow_mut(&self) -> Result<RefMut<'_, T>, BorrowMutError> {\n         match BorrowRefMut::new(&self.borrow) {\n-            Some(b) => Ok(RefMut {\n-                value: unsafe { &mut *self.value.get() },\n-                borrow: b,\n-            }),\n+            Some(b) => Ok(RefMut { value: unsafe { &mut *self.value.get() }, borrow: b }),\n             None => Err(BorrowMutError { _private: () }),\n         }\n     }\n@@ -957,9 +940,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n-        unsafe {\n-            &mut *self.value.get()\n-        }\n+        unsafe { &mut *self.value.get() }\n     }\n \n     /// Immutably borrows the wrapped value, returning an error if the value is\n@@ -1189,10 +1170,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     #[stable(feature = \"cell_extras\", since = \"1.15.0\")]\n     #[inline]\n     pub fn clone(orig: &Ref<'b, T>) -> Ref<'b, T> {\n-        Ref {\n-            value: orig.value,\n-            borrow: orig.borrow.clone(),\n-        }\n+        Ref { value: orig.value, borrow: orig.borrow.clone() }\n     }\n \n     /// Makes a new `Ref` for a component of the borrowed data.\n@@ -1216,12 +1194,10 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     #[stable(feature = \"cell_map\", since = \"1.8.0\")]\n     #[inline]\n     pub fn map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Ref<'b, U>\n-        where F: FnOnce(&T) -> &U\n+    where\n+        F: FnOnce(&T) -> &U,\n     {\n-        Ref {\n-            value: f(orig.value),\n-            borrow: orig.borrow,\n-        }\n+        Ref { value: f(orig.value), borrow: orig.borrow }\n     }\n \n     /// Splits a `Ref` into multiple `Ref`s for different components of the\n@@ -1247,7 +1223,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     #[stable(feature = \"refcell_map_split\", since = \"1.35.0\")]\n     #[inline]\n     pub fn map_split<U: ?Sized, V: ?Sized, F>(orig: Ref<'b, T>, f: F) -> (Ref<'b, U>, Ref<'b, V>)\n-        where F: FnOnce(&T) -> (&U, &V)\n+    where\n+        F: FnOnce(&T) -> (&U, &V),\n     {\n         let (a, b) = f(orig.value);\n         let borrow = orig.borrow.clone();\n@@ -1292,14 +1269,12 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     #[stable(feature = \"cell_map\", since = \"1.8.0\")]\n     #[inline]\n     pub fn map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>\n-        where F: FnOnce(&mut T) -> &mut U\n+    where\n+        F: FnOnce(&mut T) -> &mut U,\n     {\n         // FIXME(nll-rfc#40): fix borrow-check\n         let RefMut { value, borrow } = orig;\n-        RefMut {\n-            value: f(value),\n-            borrow,\n-        }\n+        RefMut { value: f(value), borrow }\n     }\n \n     /// Splits a `RefMut` into multiple `RefMut`s for different components of the\n@@ -1330,9 +1305,11 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     #[stable(feature = \"refcell_map_split\", since = \"1.35.0\")]\n     #[inline]\n     pub fn map_split<U: ?Sized, V: ?Sized, F>(\n-        orig: RefMut<'b, T>, f: F\n+        orig: RefMut<'b, T>,\n+        f: F,\n     ) -> (RefMut<'b, U>, RefMut<'b, V>)\n-        where F: FnOnce(&mut T) -> (&mut U, &mut V)\n+    where\n+        F: FnOnce(&mut T) -> (&mut U, &mut V),\n     {\n         let (a, b) = f(orig.value);\n         let borrow = orig.borrow.clone();\n@@ -1364,7 +1341,7 @@ impl<'b> BorrowRefMut<'b> {\n             UNUSED => {\n                 borrow.set(UNUSED - 1);\n                 Some(BorrowRefMut { borrow })\n-            },\n+            }\n             _ => None,\n         }\n     }"}, {"sha": "0d4788dfc570b9d869910ae74f08bac079121a4e", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 140, "deletions": 50, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -195,8 +195,8 @@ use self::Ordering::*;\n #[doc(alias = \"==\")]\n #[doc(alias = \"!=\")]\n #[rustc_on_unimplemented(\n-    message=\"can't compare `{Self}` with `{Rhs}`\",\n-    label=\"no implementation for `{Self} == {Rhs}`\",\n+    message = \"can't compare `{Self}` with `{Rhs}`\",\n+    label = \"no implementation for `{Self} == {Rhs}`\"\n )]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used\n@@ -209,14 +209,18 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n     #[inline]\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &Rhs) -> bool {\n+        !self.eq(other)\n+    }\n }\n \n /// Derive macro generating an impl of the trait `PartialEq`.\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, structural_match)]\n-pub macro PartialEq($item:item) { /* compiler built-in */ }\n+pub macro PartialEq($item:item) {\n+    /* compiler built-in */\n+}\n \n /// Trait for equality comparisons which are [equivalence relations](\n /// https://en.wikipedia.org/wiki/Equivalence_relation).\n@@ -278,18 +282,20 @@ pub trait Eq: PartialEq<Self> {\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_eq, structural_match)]\n-pub macro Eq($item:item) { /* compiler built-in */ }\n+pub macro Eq($item:item) {\n+    /* compiler built-in */\n+}\n \n // FIXME: this struct is used solely by #[derive] to\n // assert that every component of a type implements Eq.\n //\n // This struct should never appear in user code.\n #[doc(hidden)]\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"derive_eq\",\n-           reason = \"deriving hack, should not be public\",\n-           issue = \"none\")]\n-pub struct AssertParamIsEq<T: Eq + ?Sized> { _field: crate::marker::PhantomData<T> }\n+#[unstable(feature = \"derive_eq\", reason = \"deriving hack, should not be public\", issue = \"none\")]\n+pub struct AssertParamIsEq<T: Eq + ?Sized> {\n+    _field: crate::marker::PhantomData<T>,\n+}\n \n /// An `Ordering` is the result of a comparison between two values.\n ///\n@@ -460,13 +466,21 @@ impl<T: PartialOrd> PartialOrd for Reverse<T> {\n     }\n \n     #[inline]\n-    fn lt(&self, other: &Self) -> bool { other.0 < self.0 }\n+    fn lt(&self, other: &Self) -> bool {\n+        other.0 < self.0\n+    }\n     #[inline]\n-    fn le(&self, other: &Self) -> bool { other.0 <= self.0 }\n+    fn le(&self, other: &Self) -> bool {\n+        other.0 <= self.0\n+    }\n     #[inline]\n-    fn gt(&self, other: &Self) -> bool { other.0 > self.0 }\n+    fn gt(&self, other: &Self) -> bool {\n+        other.0 > self.0\n+    }\n     #[inline]\n-    fn ge(&self, other: &Self) -> bool { other.0 >= self.0 }\n+    fn ge(&self, other: &Self) -> bool {\n+        other.0 >= self.0\n+    }\n }\n \n #[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n@@ -570,7 +584,9 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     #[inline]\n     fn max(self, other: Self) -> Self\n-    where Self: Sized {\n+    where\n+        Self: Sized,\n+    {\n         max_by(self, other, Ord::cmp)\n     }\n \n@@ -587,7 +603,9 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     #[inline]\n     fn min(self, other: Self) -> Self\n-    where Self: Sized {\n+    where\n+        Self: Sized,\n+    {\n         min_by(self, other, Ord::cmp)\n     }\n \n@@ -611,7 +629,9 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// ```\n     #[unstable(feature = \"clamp\", issue = \"44095\")]\n     fn clamp(self, min: Self, max: Self) -> Self\n-    where Self: Sized {\n+    where\n+        Self: Sized,\n+    {\n         assert!(min <= max);\n         if self < min {\n             min\n@@ -627,7 +647,9 @@ pub trait Ord: Eq + PartialOrd<Self> {\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n-pub macro Ord($item:item) { /* compiler built-in */ }\n+pub macro Ord($item:item) {\n+    /* compiler built-in */\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Eq for Ordering {}\n@@ -753,8 +775,8 @@ impl PartialOrd for Ordering {\n #[doc(alias = \"<=\")]\n #[doc(alias = \">=\")]\n #[rustc_on_unimplemented(\n-    message=\"can't compare `{Self}` with `{Rhs}`\",\n-    label=\"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\",\n+    message = \"can't compare `{Self}` with `{Rhs}`\",\n+    label = \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\"\n )]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values if one exists.\n@@ -875,7 +897,9 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n-pub macro PartialOrd($item:item) { /* compiler built-in */ }\n+pub macro PartialOrd($item:item) {\n+    /* compiler built-in */\n+}\n \n /// Compares and returns the minimum of two values.\n ///\n@@ -1005,8 +1029,8 @@ pub fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n \n // Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\n mod impls {\n+    use crate::cmp::Ordering::{self, Equal, Greater, Less};\n     use crate::hint::unreachable_unchecked;\n-    use crate::cmp::Ordering::{self, Less, Greater, Equal};\n \n     macro_rules! partial_eq_impl {\n         ($($t:ty)*) => ($(\n@@ -1023,9 +1047,13 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialEq for () {\n         #[inline]\n-        fn eq(&self, _other: &()) -> bool { true }\n+        fn eq(&self, _other: &()) -> bool {\n+            true\n+        }\n         #[inline]\n-        fn ne(&self, _other: &()) -> bool { false }\n+        fn ne(&self, _other: &()) -> bool {\n+            false\n+        }\n     }\n \n     partial_eq_impl! {\n@@ -1119,7 +1147,9 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Ord for () {\n         #[inline]\n-        fn cmp(&self, _other: &()) -> Ordering { Equal }\n+        fn cmp(&self, _other: &()) -> Ordering {\n+            Equal\n+        }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1168,80 +1198,140 @@ mod impls {\n     // & pointers\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &A\n+    where\n+        A: PartialEq<B>,\n+    {\n         #[inline]\n-        fn eq(&self, other: & &B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&B) -> bool {\n+            PartialEq::eq(*self, *other)\n+        }\n         #[inline]\n-        fn ne(&self, other: & &B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&B) -> bool {\n+            PartialEq::ne(*self, *other)\n+        }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A: ?Sized, B: ?Sized> PartialOrd<&B> for &A where A: PartialOrd<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialOrd<&B> for &A\n+    where\n+        A: PartialOrd<B>,\n+    {\n         #[inline]\n         fn partial_cmp(&self, other: &&B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n         }\n         #[inline]\n-        fn lt(&self, other: & &B) -> bool { PartialOrd::lt(*self, *other) }\n+        fn lt(&self, other: &&B) -> bool {\n+            PartialOrd::lt(*self, *other)\n+        }\n         #[inline]\n-        fn le(&self, other: & &B) -> bool { PartialOrd::le(*self, *other) }\n+        fn le(&self, other: &&B) -> bool {\n+            PartialOrd::le(*self, *other)\n+        }\n         #[inline]\n-        fn gt(&self, other: & &B) -> bool { PartialOrd::gt(*self, *other) }\n+        fn gt(&self, other: &&B) -> bool {\n+            PartialOrd::gt(*self, *other)\n+        }\n         #[inline]\n-        fn ge(&self, other: & &B) -> bool { PartialOrd::ge(*self, *other) }\n+        fn ge(&self, other: &&B) -> bool {\n+            PartialOrd::ge(*self, *other)\n+        }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A: ?Sized> Ord for &A where A: Ord {\n+    impl<A: ?Sized> Ord for &A\n+    where\n+        A: Ord,\n+    {\n         #[inline]\n-        fn cmp(&self, other: &Self) -> Ordering { Ord::cmp(*self, *other) }\n+        fn cmp(&self, other: &Self) -> Ordering {\n+            Ord::cmp(*self, *other)\n+        }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<A: ?Sized> Eq for &A where A: Eq {}\n \n     // &mut pointers\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A: ?Sized, B: ?Sized> PartialEq<&mut B> for &mut A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&mut B> for &mut A\n+    where\n+        A: PartialEq<B>,\n+    {\n         #[inline]\n-        fn eq(&self, other: &&mut B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&mut B) -> bool {\n+            PartialEq::eq(*self, *other)\n+        }\n         #[inline]\n-        fn ne(&self, other: &&mut B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&mut B) -> bool {\n+            PartialEq::ne(*self, *other)\n+        }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A: ?Sized, B: ?Sized> PartialOrd<&mut B> for &mut A where A: PartialOrd<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialOrd<&mut B> for &mut A\n+    where\n+        A: PartialOrd<B>,\n+    {\n         #[inline]\n         fn partial_cmp(&self, other: &&mut B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n         }\n         #[inline]\n-        fn lt(&self, other: &&mut B) -> bool { PartialOrd::lt(*self, *other) }\n+        fn lt(&self, other: &&mut B) -> bool {\n+            PartialOrd::lt(*self, *other)\n+        }\n         #[inline]\n-        fn le(&self, other: &&mut B) -> bool { PartialOrd::le(*self, *other) }\n+        fn le(&self, other: &&mut B) -> bool {\n+            PartialOrd::le(*self, *other)\n+        }\n         #[inline]\n-        fn gt(&self, other: &&mut B) -> bool { PartialOrd::gt(*self, *other) }\n+        fn gt(&self, other: &&mut B) -> bool {\n+            PartialOrd::gt(*self, *other)\n+        }\n         #[inline]\n-        fn ge(&self, other: &&mut B) -> bool { PartialOrd::ge(*self, *other) }\n+        fn ge(&self, other: &&mut B) -> bool {\n+            PartialOrd::ge(*self, *other)\n+        }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A: ?Sized> Ord for &mut A where A: Ord {\n+    impl<A: ?Sized> Ord for &mut A\n+    where\n+        A: Ord,\n+    {\n         #[inline]\n-        fn cmp(&self, other: &Self) -> Ordering { Ord::cmp(*self, *other) }\n+        fn cmp(&self, other: &Self) -> Ordering {\n+            Ord::cmp(*self, *other)\n+        }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<A: ?Sized> Eq for &mut A where A: Eq {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A: ?Sized, B: ?Sized> PartialEq<&mut B> for &A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&mut B> for &A\n+    where\n+        A: PartialEq<B>,\n+    {\n         #[inline]\n-        fn eq(&self, other: &&mut B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&mut B) -> bool {\n+            PartialEq::eq(*self, *other)\n+        }\n         #[inline]\n-        fn ne(&self, other: &&mut B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&mut B) -> bool {\n+            PartialEq::ne(*self, *other)\n+        }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &mut A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &mut A\n+    where\n+        A: PartialEq<B>,\n+    {\n         #[inline]\n-        fn eq(&self, other: &&B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&B) -> bool {\n+            PartialEq::eq(*self, *other)\n+        }\n         #[inline]\n-        fn ne(&self, other: &&B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&B) -> bool {\n+            PartialEq::ne(*self, *other)\n+        }\n     }\n }"}, {"sha": "626eb1e862d992eb8f9cfbae986a0aee422de5a2", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 34, "deletions": 65, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -11,21 +11,18 @@ struct PadAdapterState {\n \n impl Default for PadAdapterState {\n     fn default() -> Self {\n-        PadAdapterState {\n-            on_newline: true,\n-        }\n+        PadAdapterState { on_newline: true }\n     }\n }\n \n impl<'buf, 'state> PadAdapter<'buf, 'state> {\n-    fn wrap<'slot, 'fmt: 'buf+'slot>(fmt: &'fmt mut fmt::Formatter<'_>,\n-                                     slot: &'slot mut Option<Self>,\n-                                     state: &'state mut PadAdapterState) -> fmt::Formatter<'slot> {\n+    fn wrap<'slot, 'fmt: 'buf + 'slot>(\n+        fmt: &'fmt mut fmt::Formatter<'_>,\n+        slot: &'slot mut Option<Self>,\n+        state: &'state mut PadAdapterState,\n+    ) -> fmt::Formatter<'slot> {\n         fmt.wrap_buf(move |buf| {\n-            *slot = Some(PadAdapter {\n-                buf,\n-                state,\n-            });\n+            *slot = Some(PadAdapter { buf, state });\n             slot.as_mut().unwrap()\n         })\n     }\n@@ -98,15 +95,12 @@ pub struct DebugStruct<'a, 'b: 'a> {\n     has_fields: bool,\n }\n \n-pub(super) fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>,\n-                                name: &str)\n-                                -> DebugStruct<'a, 'b> {\n+pub(super) fn debug_struct_new<'a, 'b>(\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    name: &str,\n+) -> DebugStruct<'a, 'b> {\n     let result = fmt.write_str(name);\n-    DebugStruct {\n-        fmt,\n-        result,\n-        has_fields: false,\n-    }\n+    DebugStruct { fmt, result, has_fields: false }\n }\n \n impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n@@ -196,11 +190,7 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n     pub fn finish(&mut self) -> fmt::Result {\n         if self.has_fields {\n             self.result = self.result.and_then(|_| {\n-                if self.is_pretty() {\n-                    self.fmt.write_str(\"}\")\n-                } else {\n-                    self.fmt.write_str(\" }\")\n-                }\n+                if self.is_pretty() { self.fmt.write_str(\"}\") } else { self.fmt.write_str(\" }\") }\n             });\n         }\n         self.result\n@@ -256,12 +246,7 @@ pub(super) fn debug_tuple_new<'a, 'b>(\n     name: &str,\n ) -> DebugTuple<'a, 'b> {\n     let result = fmt.write_str(name);\n-    DebugTuple {\n-        fmt,\n-        result,\n-        fields: 0,\n-        empty_name: name.is_empty(),\n-    }\n+    DebugTuple { fmt, result, fields: 0, empty_name: name.is_empty() }\n }\n \n impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n@@ -423,13 +408,7 @@ pub struct DebugSet<'a, 'b: 'a> {\n \n pub(super) fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b> {\n     let result = fmt.write_str(\"{\");\n-    DebugSet {\n-        inner: DebugInner {\n-            fmt,\n-            result,\n-            has_fields: false,\n-        },\n-    }\n+    DebugSet { inner: DebugInner { fmt, result, has_fields: false } }\n }\n \n impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n@@ -487,8 +466,9 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugSet<'a, 'b>\n-        where D: fmt::Debug,\n-              I: IntoIterator<Item = D>\n+    where\n+        D: fmt::Debug,\n+        I: IntoIterator<Item = D>,\n     {\n         for entry in entries {\n             self.entry(&entry);\n@@ -560,13 +540,7 @@ pub struct DebugList<'a, 'b: 'a> {\n \n pub(super) fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b> {\n     let result = fmt.write_str(\"[\");\n-    DebugList {\n-        inner: DebugInner {\n-            fmt,\n-            result,\n-            has_fields: false,\n-        },\n-    }\n+    DebugList { inner: DebugInner { fmt, result, has_fields: false } }\n }\n \n impl<'a, 'b: 'a> DebugList<'a, 'b> {\n@@ -624,8 +598,9 @@ impl<'a, 'b: 'a> DebugList<'a, 'b> {\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugList<'a, 'b>\n-        where D: fmt::Debug,\n-              I: IntoIterator<Item = D>\n+    where\n+        D: fmt::Debug,\n+        I: IntoIterator<Item = D>,\n     {\n         for entry in entries {\n             self.entry(&entry);\n@@ -702,13 +677,7 @@ pub struct DebugMap<'a, 'b: 'a> {\n \n pub(super) fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n     let result = fmt.write_str(\"{\");\n-    DebugMap {\n-        fmt,\n-        result,\n-        has_fields: false,\n-        has_key: false,\n-        state: Default::default(),\n-    }\n+    DebugMap { fmt, result, has_fields: false, has_key: false, state: Default::default() }\n }\n \n impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n@@ -771,13 +740,14 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n     /// );\n     /// ```\n-    #[unstable(feature = \"debug_map_key_value\",\n-               reason = \"recently added\",\n-               issue = \"62482\")]\n+    #[unstable(feature = \"debug_map_key_value\", reason = \"recently added\", issue = \"62482\")]\n     pub fn key(&mut self, key: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n         self.result = self.result.and_then(|_| {\n-            assert!(!self.has_key, \"attempted to begin a new map entry \\\n-                                    without completing the previous one\");\n+            assert!(\n+                !self.has_key,\n+                \"attempted to begin a new map entry \\\n+                                    without completing the previous one\"\n+            );\n \n             if self.is_pretty() {\n                 if !self.has_fields {\n@@ -835,9 +805,7 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n     /// );\n     /// ```\n-    #[unstable(feature = \"debug_map_key_value\",\n-               reason = \"recently added\",\n-               issue = \"62482\")]\n+    #[unstable(feature = \"debug_map_key_value\", reason = \"recently added\", issue = \"62482\")]\n     pub fn value(&mut self, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n         self.result = self.result.and_then(|_| {\n             assert!(self.has_key, \"attempted to format a map value before its key\");\n@@ -885,9 +853,10 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entries<K, V, I>(&mut self, entries: I) -> &mut DebugMap<'a, 'b>\n-        where K: fmt::Debug,\n-              V: fmt::Debug,\n-              I: IntoIterator<Item = (K, V)>\n+    where\n+        K: fmt::Debug,\n+        V: fmt::Debug,\n+        I: IntoIterator<Item = (K, V)>,\n     {\n         for (k, v) in entries {\n             self.entry(&k, &v);"}, {"sha": "7b20677ffb54cb2390c809059e55faec4a08a226", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -2,17 +2,17 @@\n \n // ignore-tidy-undocumented-unsafe\n \n-\n use crate::fmt;\n+use crate::mem::MaybeUninit;\n use crate::ops::{Div, Rem, Sub};\n-use crate::str;\n-use crate::slice;\n use crate::ptr;\n-use crate::mem::MaybeUninit;\n+use crate::slice;\n+use crate::str;\n \n #[doc(hidden)]\n-trait Int: PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n-           Sub<Output=Self> + Copy {\n+trait Int:\n+    PartialEq + PartialOrd + Div<Output = Self> + Rem<Output = Self> + Sub<Output = Self> + Copy\n+{\n     fn zero() -> Self;\n     fn from_u8(u: u8) -> Self;\n     fn to_u8(&self) -> u8;\n@@ -60,33 +60,32 @@ trait GenericRadix {\n             // Accumulate each digit of the number from the least significant\n             // to the most significant figure.\n             for byte in buf.iter_mut().rev() {\n-                let n = x % base;               // Get the current place value.\n-                x = x / base;                   // Deaccumulate the number.\n+                let n = x % base; // Get the current place value.\n+                x = x / base; // Deaccumulate the number.\n                 byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                 curr -= 1;\n                 if x == zero {\n                     // No more digits left to accumulate.\n-                    break\n+                    break;\n                 };\n             }\n         } else {\n             // Do the same as above, but accounting for two's complement.\n             for byte in buf.iter_mut().rev() {\n-                let n = zero - (x % base);      // Get the current place value.\n-                x = x / base;                   // Deaccumulate the number.\n+                let n = zero - (x % base); // Get the current place value.\n+                x = x / base; // Deaccumulate the number.\n                 byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                 curr -= 1;\n                 if x == zero {\n                     // No more digits left to accumulate.\n-                    break\n+                    break;\n                 };\n             }\n         }\n         let buf = &buf[curr..];\n-        let buf = unsafe { str::from_utf8_unchecked(slice::from_raw_parts(\n-            MaybeUninit::first_ptr(buf),\n-            buf.len()\n-        )) };\n+        let buf = unsafe {\n+            str::from_utf8_unchecked(slice::from_raw_parts(MaybeUninit::first_ptr(buf), buf.len()))\n+        };\n         f.pad_integral(is_nonnegative, Self::PREFIX, buf)\n     }\n }\n@@ -125,9 +124,9 @@ macro_rules! radix {\n radix! { Binary,    2, \"0b\", x @  0 ..=  1 => b'0' + x }\n radix! { Octal,     8, \"0o\", x @  0 ..=  7 => b'0' + x }\n radix! { LowerHex, 16, \"0x\", x @  0 ..=  9 => b'0' + x,\n-                             x @ 10 ..= 15 => b'a' + (x - 10) }\n+x @ 10 ..= 15 => b'a' + (x - 10) }\n radix! { UpperHex, 16, \"0x\", x @  0 ..=  9 => b'0' + x,\n-                             x @ 10 ..= 15 => b'A' + (x - 10) }\n+x @ 10 ..= 15 => b'A' + (x - 10) }\n \n macro_rules! int_base {\n     ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n@@ -137,7 +136,7 @@ macro_rules! int_base {\n                 $Radix.fmt_int(*self as $U, f)\n             }\n         }\n-    }\n+    };\n }\n \n macro_rules! debug {\n@@ -155,7 +154,7 @@ macro_rules! debug {\n                 }\n             }\n         }\n-    }\n+    };\n }\n \n macro_rules! integer {\n@@ -171,7 +170,7 @@ macro_rules! integer {\n         int_base! { LowerHex for $Uint as $Uint -> LowerHex }\n         int_base! { UpperHex for $Uint as $Uint -> UpperHex }\n         debug! { $Uint }\n-    }\n+    };\n }\n integer! { isize, usize }\n integer! { i8, u8 }\n@@ -180,9 +179,7 @@ integer! { i32, u32 }\n integer! { i64, u64 }\n integer! { i128, u128 }\n \n-\n-static DEC_DIGITS_LUT: &[u8; 200] =\n-    b\"0001020304050607080910111213141516171819\\\n+static DEC_DIGITS_LUT: &[u8; 200] = b\"0001020304050607080910111213141516171819\\\n       2021222324252627282930313233343536373839\\\n       4041424344454647484950515253545556575859\\\n       6061626364656667686970717273747576777879\\"}, {"sha": "e6bae4864a4e1721106d2040780a21c5b4a2e09a", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -29,18 +29,22 @@\n //!   guaranteed to happen in order. This is the standard mode for working\n //!   with atomic types and is equivalent to Java's `volatile`.\n \n-#![unstable(feature = \"core_intrinsics\",\n-            reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n+#![unstable(\n+    feature = \"core_intrinsics\",\n+    reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n                       they should be used through stabilized interfaces \\\n                       in the rest of the standard library\",\n-            issue = \"none\")]\n+    issue = \"none\"\n+)]\n #![allow(missing_docs)]\n \n use crate::mem;\n \n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n-#[rustc_deprecated(reason = \"no longer an intrinsic - use `ptr::drop_in_place` directly\",\n-                   since = \"1.18.0\")]\n+#[rustc_deprecated(\n+    reason = \"no longer an intrinsic - use `ptr::drop_in_place` directly\",\n+    since = \"1.18.0\"\n+)]\n pub use crate::ptr::drop_in_place;\n \n extern \"rust-intrinsic\" {\n@@ -705,13 +709,14 @@ extern \"rust-intrinsic\" {\n     /// which is unsafe unless `T` is `Copy`. Also, even if T is\n     /// `Copy`, an all-zero value may not correspond to any legitimate\n     /// state for the type in question.\n-    #[unstable(feature = \"core_intrinsics\",\n-               reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n+    #[unstable(\n+        feature = \"core_intrinsics\",\n+        reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n                          they should be used through stabilized interfaces \\\n                          in the rest of the standard library\",\n-               issue = \"none\")]\n-    #[rustc_deprecated(reason = \"superseded by MaybeUninit, removal planned\",\n-                       since = \"1.38.0\")]\n+        issue = \"none\"\n+    )]\n+    #[rustc_deprecated(reason = \"superseded by MaybeUninit, removal planned\", since = \"1.38.0\")]\n     pub fn init<T>() -> T;\n \n     /// Creates an uninitialized value.\n@@ -721,13 +726,14 @@ extern \"rust-intrinsic\" {\n     /// state, which means it may claim either dropped or\n     /// undropped. In the general case one must use `ptr::write` to\n     /// initialize memory previous set to the result of `uninit`.\n-    #[unstable(feature = \"core_intrinsics\",\n-               reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n+    #[unstable(\n+        feature = \"core_intrinsics\",\n+        reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n                          they should be used through stabilized interfaces \\\n                          in the rest of the standard library\",\n-               issue = \"none\")]\n-    #[rustc_deprecated(reason = \"superseded by MaybeUninit, removal planned\",\n-                       since = \"1.38.0\")]\n+        issue = \"none\"\n+    )]\n+    #[rustc_deprecated(reason = \"superseded by MaybeUninit, removal planned\", since = \"1.38.0\")]\n     pub fn uninit<T>() -> T;\n \n     /// Moves a value out of scope without running drop glue.\n@@ -985,8 +991,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The volatile parameter is set to `true`, so it will not be optimized out\n     /// unless size is equal to zero.\n-    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T,\n-                                                  count: usize);\n+    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n@@ -1148,7 +1153,6 @@ extern \"rust-intrinsic\" {\n     /// https://github.com/rust-lang/rust/issues/10184\n     pub fn float_to_int_approx_unchecked<Float, Int>(value: Float) -> Int;\n \n-\n     /// Returns the number of bits set in an integer type `T`\n     pub fn ctpop<T>(x: T) -> T;\n \n@@ -1376,11 +1380,7 @@ fn overlaps<T>(src: *const T, dst: *const T, count: usize) -> bool {\n     let src_usize = src as usize;\n     let dst_usize = dst as usize;\n     let size = mem::size_of::<T>().checked_mul(count).unwrap();\n-    let diff = if src_usize > dst_usize {\n-        src_usize - dst_usize\n-    } else {\n-        dst_usize - src_usize\n-    };\n+    let diff = if src_usize > dst_usize { src_usize - dst_usize } else { dst_usize - src_usize };\n     size > diff\n }\n "}, {"sha": "3611a1aadaddba0492cd9a776cbe322310108896", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,7 +1,7 @@\n use crate::ops::Try;\n use crate::usize;\n \n-use super::super::{Iterator, DoubleEndedIterator, FusedIterator, TrustedLen};\n+use super::super::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n \n /// An iterator that links two iterators together, in a chain.\n ///\n@@ -48,9 +48,10 @@ enum ChainState {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> Iterator for Chain<A, B> where\n+impl<A, B> Iterator for Chain<A, B>\n+where\n     A: Iterator,\n-    B: Iterator<Item = A::Item>\n+    B: Iterator<Item = A::Item>,\n {\n     type Item = A::Item;\n \n@@ -79,8 +80,11 @@ impl<A, B> Iterator for Chain<A, B> where\n         }\n     }\n \n-    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n-        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         let mut accum = init;\n         match self.state {\n@@ -90,7 +94,7 @@ impl<A, B> Iterator for Chain<A, B> where\n                     self.state = ChainState::Back;\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n         if let ChainState::Back = self.state {\n             accum = self.b.try_fold(accum, &mut f)?;\n@@ -99,20 +103,21 @@ impl<A, B> Iterator for Chain<A, B> where\n     }\n \n     fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let mut accum = init;\n         match self.state {\n             ChainState::Both | ChainState::Front => {\n                 accum = self.a.fold(accum, &mut f);\n             }\n-            _ => { }\n+            _ => {}\n         }\n         match self.state {\n             ChainState::Both | ChainState::Back => {\n                 accum = self.b.fold(accum, &mut f);\n             }\n-            _ => { }\n+            _ => {}\n         }\n         accum\n     }\n@@ -123,7 +128,7 @@ impl<A, B> Iterator for Chain<A, B> where\n             ChainState::Both | ChainState::Front => {\n                 for x in self.a.by_ref() {\n                     if n == 0 {\n-                        return Some(x)\n+                        return Some(x);\n                     }\n                     n -= 1;\n                 }\n@@ -133,15 +138,12 @@ impl<A, B> Iterator for Chain<A, B> where\n             }\n             ChainState::Back => {}\n         }\n-        if let ChainState::Back = self.state {\n-            self.b.nth(n)\n-        } else {\n-            None\n-        }\n+        if let ChainState::Back = self.state { self.b.nth(n) } else { None }\n     }\n \n     #[inline]\n-    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+    where\n         P: FnMut(&Self::Item) -> bool,\n     {\n         match self.state {\n@@ -150,7 +152,7 @@ impl<A, B> Iterator for Chain<A, B> where\n                     self.state = ChainState::Back;\n                     self.b.find(predicate)\n                 }\n-                v => v\n+                v => v,\n             },\n             ChainState::Front => self.a.find(predicate),\n             ChainState::Back => self.b.find(predicate),\n@@ -165,9 +167,9 @@ impl<A, B> Iterator for Chain<A, B> where\n                 let a_last = self.a.last();\n                 let b_last = self.b.last();\n                 b_last.or(a_last)\n-            },\n+            }\n             ChainState::Front => self.a.last(),\n-            ChainState::Back => self.b.last()\n+            ChainState::Back => self.b.last(),\n         }\n     }\n \n@@ -182,7 +184,7 @@ impl<A, B> Iterator for Chain<A, B> where\n \n                 let upper = match (a_upper, b_upper) {\n                     (Some(x), Some(y)) => x.checked_add(y),\n-                    _ => None\n+                    _ => None,\n                 };\n \n                 (lower, upper)\n@@ -194,9 +196,10 @@ impl<A, B> Iterator for Chain<A, B> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> DoubleEndedIterator for Chain<A, B> where\n+impl<A, B> DoubleEndedIterator for Chain<A, B>\n+where\n     A: DoubleEndedIterator,\n-    B: DoubleEndedIterator<Item=A::Item>,\n+    B: DoubleEndedIterator<Item = A::Item>,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A::Item> {\n@@ -219,7 +222,7 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n             ChainState::Both | ChainState::Back => {\n                 for x in self.b.by_ref().rev() {\n                     if n == 0 {\n-                        return Some(x)\n+                        return Some(x);\n                     }\n                     n -= 1;\n                 }\n@@ -229,15 +232,14 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n             }\n             ChainState::Front => {}\n         }\n-        if let ChainState::Front = self.state {\n-            self.a.nth_back(n)\n-        } else {\n-            None\n-        }\n+        if let ChainState::Front = self.state { self.a.nth_back(n) } else { None }\n     }\n \n-    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n-        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         let mut accum = init;\n         match self.state {\n@@ -247,7 +249,7 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n                     self.state = ChainState::Front;\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n         if let ChainState::Front = self.state {\n             accum = self.a.try_rfold(accum, &mut f)?;\n@@ -256,34 +258,39 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n     }\n \n     fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let mut accum = init;\n         match self.state {\n             ChainState::Both | ChainState::Back => {\n                 accum = self.b.rfold(accum, &mut f);\n             }\n-            _ => { }\n+            _ => {}\n         }\n         match self.state {\n             ChainState::Both | ChainState::Front => {\n                 accum = self.a.rfold(accum, &mut f);\n             }\n-            _ => { }\n+            _ => {}\n         }\n         accum\n     }\n-\n }\n \n // Note: *both* must be fused to handle double-ended iterators.\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A, B> FusedIterator for Chain<A, B>\n-    where A: FusedIterator,\n-          B: FusedIterator<Item=A::Item>,\n-{}\n+where\n+    A: FusedIterator,\n+    B: FusedIterator<Item = A::Item>,\n+{\n+}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<A, B> TrustedLen for Chain<A, B>\n-    where A: TrustedLen, B: TrustedLen<Item=A::Item>,\n-{}\n+where\n+    A: TrustedLen,\n+    B: TrustedLen<Item = A::Item>,\n+{\n+}"}, {"sha": "b13e12e2e86083b6c17e4616297dfffbe25fc974", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 62, "deletions": 38, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -2,7 +2,7 @@\n \n use crate::cmp;\n \n-use super::super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};\n+use super::super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedLen};\n \n /// An iterator that iterates two other iterators simultaneously.\n ///\n@@ -27,15 +27,20 @@ impl<A: Iterator, B: Iterator> Zip<A, B> {\n     }\n     fn super_nth(&mut self, mut n: usize) -> Option<(A::Item, B::Item)> {\n         while let Some(x) = Iterator::next(self) {\n-            if n == 0 { return Some(x) }\n+            if n == 0 {\n+                return Some(x);\n+            }\n             n -= 1;\n         }\n         None\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n+impl<A, B> Iterator for Zip<A, B>\n+where\n+    A: Iterator,\n+    B: Iterator,\n {\n     type Item = (A::Item, B::Item);\n \n@@ -56,7 +61,8 @@ impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> DoubleEndedIterator for Zip<A, B> where\n+impl<A, B> DoubleEndedIterator for Zip<A, B>\n+where\n     A: DoubleEndedIterator + ExactSizeIterator,\n     B: DoubleEndedIterator + ExactSizeIterator,\n {\n@@ -75,22 +81,25 @@ trait ZipImpl<A, B> {\n     fn size_hint(&self) -> (usize, Option<usize>);\n     fn nth(&mut self, n: usize) -> Option<Self::Item>;\n     fn next_back(&mut self) -> Option<Self::Item>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator;\n+    where\n+        A: DoubleEndedIterator + ExactSizeIterator,\n+        B: DoubleEndedIterator + ExactSizeIterator;\n }\n \n // General Zip impl\n #[doc(hidden)]\n impl<A, B> ZipImpl<A, B> for Zip<A, B>\n-    where A: Iterator, B: Iterator\n+where\n+    A: Iterator,\n+    B: Iterator,\n {\n     type Item = (A::Item, B::Item);\n     default fn new(a: A, b: B) -> Self {\n         Zip {\n             a,\n             b,\n             index: 0, // unused\n-            len: 0, // unused\n+            len: 0,   // unused\n         }\n     }\n \n@@ -108,17 +117,22 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n \n     #[inline]\n     default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator\n+    where\n+        A: DoubleEndedIterator + ExactSizeIterator,\n+        B: DoubleEndedIterator + ExactSizeIterator,\n     {\n         let a_sz = self.a.len();\n         let b_sz = self.b.len();\n         if a_sz != b_sz {\n             // Adjust a, b to equal length\n             if a_sz > b_sz {\n-                for _ in 0..a_sz - b_sz { self.a.next_back(); }\n+                for _ in 0..a_sz - b_sz {\n+                    self.a.next_back();\n+                }\n             } else {\n-                for _ in 0..b_sz - a_sz { self.b.next_back(); }\n+                for _ in 0..b_sz - a_sz {\n+                    self.b.next_back();\n+                }\n             }\n         }\n         match (self.a.next_back(), self.b.next_back()) {\n@@ -136,10 +150,10 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         let lower = cmp::min(a_lower, b_lower);\n \n         let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n+            (Some(x), Some(y)) => Some(cmp::min(x, y)),\n             (Some(x), None) => Some(x),\n             (None, Some(y)) => Some(y),\n-            (None, None) => None\n+            (None, None) => None,\n         };\n \n         (lower, upper)\n@@ -148,26 +162,21 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n \n #[doc(hidden)]\n impl<A, B> ZipImpl<A, B> for Zip<A, B>\n-    where A: TrustedRandomAccess, B: TrustedRandomAccess\n+where\n+    A: TrustedRandomAccess,\n+    B: TrustedRandomAccess,\n {\n     fn new(a: A, b: B) -> Self {\n         let len = cmp::min(a.len(), b.len());\n-        Zip {\n-            a,\n-            b,\n-            index: 0,\n-            len,\n-        }\n+        Zip { a, b, index: 0, len }\n     }\n \n     #[inline]\n     fn next(&mut self) -> Option<(A::Item, B::Item)> {\n         if self.index < self.len {\n             let i = self.index;\n             self.index += 1;\n-            unsafe {\n-                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n-            }\n+            unsafe { Some((self.a.get_unchecked(i), self.b.get_unchecked(i))) }\n         } else if A::may_have_side_effect() && self.index < self.a.len() {\n             // match the base implementation's potential side effects\n             unsafe {\n@@ -194,10 +203,14 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n             let i = self.index;\n             self.index += 1;\n             if A::may_have_side_effect() {\n-                unsafe { self.a.get_unchecked(i); }\n+                unsafe {\n+                    self.a.get_unchecked(i);\n+                }\n             }\n             if B::may_have_side_effect() {\n-                unsafe { self.b.get_unchecked(i); }\n+                unsafe {\n+                    self.b.get_unchecked(i);\n+                }\n             }\n         }\n \n@@ -206,8 +219,9 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n \n     #[inline]\n     fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator\n+    where\n+        A: DoubleEndedIterator + ExactSizeIterator,\n+        B: DoubleEndedIterator + ExactSizeIterator,\n     {\n         // Adjust a, b to equal length\n         if A::may_have_side_effect() {\n@@ -229,9 +243,7 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         if self.index < self.len {\n             self.len -= 1;\n             let i = self.len;\n-            unsafe {\n-                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n-            }\n+            unsafe { Some((self.a.get_unchecked(i), self.b.get_unchecked(i))) }\n         } else {\n             None\n         }\n@@ -240,12 +252,17 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> ExactSizeIterator for Zip<A, B>\n-    where A: ExactSizeIterator, B: ExactSizeIterator {}\n+where\n+    A: ExactSizeIterator,\n+    B: ExactSizeIterator,\n+{\n+}\n \n #[doc(hidden)]\n unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n-    where A: TrustedRandomAccess,\n-          B: TrustedRandomAccess,\n+where\n+    A: TrustedRandomAccess,\n+    B: TrustedRandomAccess,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n         (self.a.get_unchecked(i), self.b.get_unchecked(i))\n@@ -258,12 +275,19 @@ unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A, B> FusedIterator for Zip<A, B>\n-    where A: FusedIterator, B: FusedIterator, {}\n+where\n+    A: FusedIterator,\n+    B: FusedIterator,\n+{\n+}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<A, B> TrustedLen for Zip<A, B>\n-    where A: TrustedLen, B: TrustedLen,\n-{}\n+where\n+    A: TrustedLen,\n+    B: TrustedLen,\n+{\n+}\n \n /// An iterator whose items are random-accessible efficiently\n ///\n@@ -275,7 +299,7 @@ unsafe impl<A, B> TrustedLen for Zip<A, B>\n /// .get_unchecked() must return distinct mutable references for distinct\n /// indices (if applicable), and must return a valid reference if index is in\n /// 0..self.len().\n-pub(crate) unsafe trait TrustedRandomAccess : ExactSizeIterator {\n+pub(crate) unsafe trait TrustedRandomAccess: ExactSizeIterator {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n     /// Returns `true` if getting an iterator element may have\n     /// side effects. Remember to take inner iterators into account."}, {"sha": "80294de714d2571d1e0d4f61bb9182e335c476bb", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -309,56 +309,58 @@ use crate::ops::Try;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::traits::Iterator;\n \n-#[unstable(feature = \"step_trait\",\n-           reason = \"likely to be replaced by finer-grained traits\",\n-           issue = \"42168\")]\n+#[unstable(\n+    feature = \"step_trait\",\n+    reason = \"likely to be replaced by finer-grained traits\",\n+    issue = \"42168\"\n+)]\n pub use self::range::Step;\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::sources::{Repeat, repeat};\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-pub use self::sources::{RepeatWith, repeat_with};\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-pub use self::sources::{Empty, empty};\n+pub use self::sources::{empty, Empty};\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+pub use self::sources::{from_fn, FromFn};\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-pub use self::sources::{Once, once};\n+pub use self::sources::{once, Once};\n #[unstable(feature = \"iter_once_with\", issue = \"57581\")]\n-pub use self::sources::{OnceWith, once_with};\n-#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-pub use self::sources::{FromFn, from_fn};\n+pub use self::sources::{once_with, OnceWith};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::sources::{repeat, Repeat};\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+pub use self::sources::{repeat_with, RepeatWith};\n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-pub use self::sources::{Successors, successors};\n+pub use self::sources::{successors, Successors};\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::traits::{ExactSizeIterator, Sum, Product};\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n pub use self::traits::FusedIterator;\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n pub use self::traits::TrustedLen;\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::adapters::{Rev, Cycle, Chain, Zip, Map, Filter, FilterMap, Enumerate};\n+pub use self::traits::{DoubleEndedIterator, Extend, FromIterator, IntoIterator};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::adapters::{Peekable, SkipWhile, TakeWhile, Skip, Take, Scan, FlatMap};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::adapters::{Fuse, Inspect};\n+pub use self::traits::{ExactSizeIterator, Product, Sum};\n+\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n pub use self::adapters::Cloned;\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-pub use self::adapters::StepBy;\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-pub use self::adapters::Flatten;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n pub use self::adapters::Copied;\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+pub use self::adapters::Flatten;\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+pub use self::adapters::StepBy;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::adapters::{Chain, Cycle, Enumerate, Filter, FilterMap, Map, Rev, Zip};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::adapters::{FlatMap, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::adapters::{Fuse, Inspect};\n \n-pub(crate) use self::adapters::{TrustedRandomAccess, process_results};\n+pub(crate) use self::adapters::{process_results, TrustedRandomAccess};\n \n+mod adapters;\n mod range;\n mod sources;\n mod traits;\n-mod adapters;\n \n /// Used to make try_fold closures more like normal loops\n #[derive(PartialEq)]\n@@ -378,9 +380,13 @@ impl<C, B> Try for LoopState<C, B> {\n         }\n     }\n     #[inline]\n-    fn from_error(v: Self::Error) -> Self { LoopState::Break(v) }\n+    fn from_error(v: Self::Error) -> Self {\n+        LoopState::Break(v)\n+    }\n     #[inline]\n-    fn from_ok(v: Self::Ok) -> Self { LoopState::Continue(v) }\n+    fn from_ok(v: Self::Ok) -> Self {\n+        LoopState::Continue(v)\n+    }\n }\n \n impl<C, B> LoopState<C, B> {"}, {"sha": "eac3c107d22839fab2af2728d5dcded36d369018", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -9,9 +9,11 @@ use super::{FusedIterator, TrustedLen};\n ///\n /// The `steps_between` function provides a way to efficiently compare\n /// two `Step` objects.\n-#[unstable(feature = \"step_trait\",\n-           reason = \"likely to be replaced by finer-grained traits\",\n-           issue = \"42168\")]\n+#[unstable(\n+    feature = \"step_trait\",\n+    reason = \"likely to be replaced by finer-grained traits\",\n+    issue = \"42168\"\n+)]\n pub trait Step: Clone + PartialOrd + Sized {\n     /// Returns the number of steps between two step objects. The count is\n     /// inclusive of `start` and exclusive of `end`.\n@@ -170,8 +172,8 @@ macro_rules! step_impl_signed {\n }\n \n step_impl_unsigned!(usize u8 u16 u32 u64 u128);\n-step_impl_signed!([isize: usize] [i8: u8] [i16: u16]);\n-step_impl_signed!([i32: u32] [i64: u64] [i128: u128]);\n+step_impl_signed!([isize: usize][i8: u8][i16: u16]);\n+step_impl_signed!([i32: u32][i64: u64][i128: u128]);\n \n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n@@ -227,7 +229,7 @@ impl<A: Step> Iterator for ops::Range<A> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         match Step::steps_between(&self.start, &self.end) {\n             Some(hint) => (hint, Some(hint)),\n-            None => (usize::MAX, None)\n+            None => (usize::MAX, None),\n         }\n     }\n \n@@ -236,7 +238,7 @@ impl<A: Step> Iterator for ops::Range<A> {\n         if let Some(plus_n) = self.start.add_usize(n) {\n             if plus_n < self.end {\n                 self.start = plus_n.add_one();\n-                return Some(plus_n)\n+                return Some(plus_n);\n             }\n         }\n \n@@ -291,7 +293,7 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n         if let Some(minus_n) = self.end.sub_usize(n) {\n             if minus_n > self.start {\n                 self.end = minus_n.sub_one();\n-                return Some(self.end.clone())\n+                return Some(self.end.clone());\n             }\n         }\n \n@@ -396,7 +398,9 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n     where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n         self.compute_is_empty();\n \n@@ -484,8 +488,11 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     }\n \n     #[inline]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n         self.compute_is_empty();\n "}, {"sha": "404cc84495c9697cf082585c3ebd8b203e498f83", "filename": "src/libcore/iter/traits/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -38,7 +38,7 @@ impl<I: FusedIterator + ?Sized> FusedIterator for &mut I {}\n /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n /// [`.size_hint`]: ../../std/iter/trait.Iterator.html#method.size_hint\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-pub unsafe trait TrustedLen : Iterator {}\n+pub unsafe trait TrustedLen: Iterator {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<I: TrustedLen + ?Sized> TrustedLen for &mut I {}"}, {"sha": "efd1580a54807e0a53d10bec7ce64487740094ac", "filename": "src/libcore/iter/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,15 +1,15 @@\n-mod iterator;\n+mod accum;\n+mod collect;\n mod double_ended;\n mod exact_size;\n-mod collect;\n-mod accum;\n+mod iterator;\n mod marker;\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::iterator::Iterator;\n+pub use self::accum::{Product, Sum};\n+pub use self::collect::{Extend, FromIterator, IntoIterator};\n pub use self::double_ended::DoubleEndedIterator;\n pub use self::exact_size::ExactSizeIterator;\n-pub use self::collect::{FromIterator, IntoIterator, Extend};\n-pub use self::accum::{Sum, Product};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::iterator::Iterator;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::marker::{FusedIterator, TrustedLen};"}, {"sha": "7c5e06ace67292b9bf9e34b36074aaa122b43fe6", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -49,22 +49,21 @@\n //\n // This cfg won't affect doc tests.\n #![cfg(not(test))]\n-\n #![stable(feature = \"core\", since = \"1.6.0\")]\n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n-       test(no_crate_inject, attr(deny(warnings))),\n-       test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n+#![doc(\n+    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+    html_playground_url = \"https://play.rust-lang.org/\",\n+    issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n+    test(no_crate_inject, attr(deny(warnings))),\n+    test(attr(allow(dead_code, deprecated, unused_variables, unused_mut)))\n+)]\n #![no_core]\n-\n #![warn(deprecated_in_future)]\n #![warn(missing_docs)]\n #![warn(missing_debug_implementations)]\n #![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n #![allow(explicit_outlives_requirements)]\n #![allow(incomplete_features)]\n-\n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n #![feature(asm)]\n@@ -148,22 +147,36 @@ mod int_macros;\n #[macro_use]\n mod uint_macros;\n \n-#[path = \"num/isize.rs\"] pub mod isize;\n-#[path = \"num/i8.rs\"]    pub mod i8;\n-#[path = \"num/i16.rs\"]   pub mod i16;\n-#[path = \"num/i32.rs\"]   pub mod i32;\n-#[path = \"num/i64.rs\"]   pub mod i64;\n-#[path = \"num/i128.rs\"]  pub mod i128;\n+#[path = \"num/i128.rs\"]\n+pub mod i128;\n+#[path = \"num/i16.rs\"]\n+pub mod i16;\n+#[path = \"num/i32.rs\"]\n+pub mod i32;\n+#[path = \"num/i64.rs\"]\n+pub mod i64;\n+#[path = \"num/i8.rs\"]\n+pub mod i8;\n+#[path = \"num/isize.rs\"]\n+pub mod isize;\n \n-#[path = \"num/usize.rs\"] pub mod usize;\n-#[path = \"num/u8.rs\"]    pub mod u8;\n-#[path = \"num/u16.rs\"]   pub mod u16;\n-#[path = \"num/u32.rs\"]   pub mod u32;\n-#[path = \"num/u64.rs\"]   pub mod u64;\n-#[path = \"num/u128.rs\"]  pub mod u128;\n+#[path = \"num/u128.rs\"]\n+pub mod u128;\n+#[path = \"num/u16.rs\"]\n+pub mod u16;\n+#[path = \"num/u32.rs\"]\n+pub mod u32;\n+#[path = \"num/u64.rs\"]\n+pub mod u64;\n+#[path = \"num/u8.rs\"]\n+pub mod u8;\n+#[path = \"num/usize.rs\"]\n+pub mod usize;\n \n-#[path = \"num/f32.rs\"]   pub mod f32;\n-#[path = \"num/f64.rs\"]   pub mod f64;\n+#[path = \"num/f32.rs\"]\n+pub mod f32;\n+#[path = \"num/f64.rs\"]\n+pub mod f64;\n \n #[macro_use]\n pub mod num;\n@@ -174,52 +187,52 @@ pub mod prelude;\n \n /* Core modules for ownership management */\n \n+pub mod hint;\n pub mod intrinsics;\n pub mod mem;\n pub mod ptr;\n-pub mod hint;\n \n /* Core language traits */\n \n+pub mod borrow;\n #[cfg(not(test))] // See #65860\n-pub mod marker;\n-pub mod ops;\n+pub mod clone;\n #[cfg(not(test))] // See #65860\n pub mod cmp;\n-#[cfg(not(test))] // See #65860\n-pub mod clone;\n+pub mod convert;\n #[cfg(not(test))] // See #65860\n pub mod default;\n-pub mod convert;\n-pub mod borrow;\n+#[cfg(not(test))] // See #65860\n+pub mod marker;\n+pub mod ops;\n \n /* Core types and methods on primitives */\n \n pub mod any;\n #[cfg(not(test))] // See #65860\n pub mod array;\n pub mod ascii;\n-pub mod sync;\n pub mod cell;\n pub mod char;\n+pub mod ffi;\n+#[cfg(not(test))] // See #65860\n+pub mod iter;\n+pub mod option;\n pub mod panic;\n pub mod panicking;\n #[cfg(not(test))] // See #65860\n pub mod pin;\n-#[cfg(not(test))] // See #65860\n-pub mod iter;\n-pub mod option;\n pub mod raw;\n pub mod result;\n-pub mod ffi;\n+pub mod sync;\n \n-pub mod slice;\n #[cfg(not(test))] // See #65860\n-pub mod str;\n+pub mod fmt;\n #[cfg(not(test))] // See #65860\n pub mod hash;\n+pub mod slice;\n #[cfg(not(test))] // See #65860\n-pub mod fmt;\n+pub mod str;\n pub mod time;\n \n pub mod unicode;"}, {"sha": "978d622156413b4d3f9e56087f0dbf37f6573041", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -31,17 +31,17 @@ use crate::hash::Hasher;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"send_trait\")]\n #[rustc_on_unimplemented(\n-    message=\"`{Self}` cannot be sent between threads safely\",\n-    label=\"`{Self}` cannot be sent between threads safely\"\n+    message = \"`{Self}` cannot be sent between threads safely\",\n+    label = \"`{Self}` cannot be sent between threads safely\"\n )]\n pub unsafe auto trait Send {\n     // empty.\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> !Send for *const T { }\n+impl<T: ?Sized> !Send for *const T {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> !Send for *mut T { }\n+impl<T: ?Sized> !Send for *mut T {}\n \n /// Types with a constant size known at compile time.\n ///\n@@ -83,11 +83,11 @@ impl<T: ?Sized> !Send for *mut T { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sized\"]\n #[rustc_on_unimplemented(\n-    on(parent_trait=\"std::path::Path\", label=\"borrow the `Path` instead\"),\n-    message=\"the size for values of type `{Self}` cannot be known at compilation time\",\n-    label=\"doesn't have a size known at compile-time\",\n-    note=\"to learn more, visit <https://doc.rust-lang.org/book/\\\n-          ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\",\n+    on(parent_trait = \"std::path::Path\", label = \"borrow the `Path` instead\"),\n+    message = \"the size for values of type `{Self}` cannot be known at compilation time\",\n+    label = \"doesn't have a size known at compile-time\",\n+    note = \"to learn more, visit <https://doc.rust-lang.org/book/\\\n+          ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\"\n )]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n pub trait Sized {\n@@ -148,7 +148,7 @@ pub trait Unsize<T: ?Sized> {\n /// [RFC1445]: https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md\n /// [issue 63438]: https://github.com/rust-lang/rust/issues/63438\n #[unstable(feature = \"structural_match\", issue = \"31434\")]\n-#[rustc_on_unimplemented(message=\"the type `{Self}` does not `#[derive(PartialEq)]`\")]\n+#[rustc_on_unimplemented(message = \"the type `{Self}` does not `#[derive(PartialEq)]`\")]\n #[lang = \"structural_peq\"]\n pub trait StructuralPartialEq {\n     // Empty.\n@@ -198,7 +198,7 @@ pub trait StructuralPartialEq {\n /// of the two derives (`#[derive(PartialEq)]` and `#[derive(Eq)]`) and check\n /// that both of them are present as part of structural-match checking.\n #[unstable(feature = \"structural_match\", issue = \"31434\")]\n-#[rustc_on_unimplemented(message=\"the type `{Self}` does not `#[derive(Eq)]`\")]\n+#[rustc_on_unimplemented(message = \"the type `{Self}` does not `#[derive(Eq)]`\")]\n #[lang = \"structural_teq\"]\n pub trait StructuralEq {\n     // Empty.\n@@ -362,15 +362,17 @@ pub trait StructuralEq {\n /// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n-pub trait Copy : Clone {\n+pub trait Copy: Clone {\n     // Empty.\n }\n \n /// Derive macro generating an impl of the trait `Copy`.\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n-pub macro Copy($item:item) { /* compiler built-in */ }\n+pub macro Copy($item:item) {\n+    /* compiler built-in */\n+}\n \n /// Types for which it is safe to share references between threads.\n ///\n@@ -444,8 +446,8 @@ pub macro Copy($item:item) { /* compiler built-in */ }\n #[cfg_attr(not(test), rustc_diagnostic_item = \"sync_trait\")]\n #[lang = \"sync\"]\n #[rustc_on_unimplemented(\n-    message=\"`{Self}` cannot be shared between threads safely\",\n-    label=\"`{Self}` cannot be shared between threads safely\"\n+    message = \"`{Self}` cannot be shared between threads safely\",\n+    label = \"`{Self}` cannot be shared between threads safely\"\n )]\n pub unsafe auto trait Sync {\n     // FIXME(estebank): once support to add notes in `rustc_on_unimplemented`\n@@ -462,67 +464,65 @@ pub unsafe auto trait Sync {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> !Sync for *const T { }\n+impl<T: ?Sized> !Sync for *const T {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> !Sync for *mut T { }\n+impl<T: ?Sized> !Sync for *mut T {}\n \n-macro_rules! impls{\n-    ($t: ident) => (\n+macro_rules! impls {\n+    ($t: ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T:?Sized> Hash for $t<T> {\n+        impl<T: ?Sized> Hash for $t<T> {\n             #[inline]\n-            fn hash<H: Hasher>(&self, _: &mut H) {\n-            }\n+            fn hash<H: Hasher>(&self, _: &mut H) {}\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T:?Sized> cmp::PartialEq for $t<T> {\n+        impl<T: ?Sized> cmp::PartialEq for $t<T> {\n             fn eq(&self, _other: &$t<T>) -> bool {\n                 true\n             }\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T:?Sized> cmp::Eq for $t<T> {\n-        }\n+        impl<T: ?Sized> cmp::Eq for $t<T> {}\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T:?Sized> cmp::PartialOrd for $t<T> {\n+        impl<T: ?Sized> cmp::PartialOrd for $t<T> {\n             fn partial_cmp(&self, _other: &$t<T>) -> Option<cmp::Ordering> {\n                 Option::Some(cmp::Ordering::Equal)\n             }\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T:?Sized> cmp::Ord for $t<T> {\n+        impl<T: ?Sized> cmp::Ord for $t<T> {\n             fn cmp(&self, _other: &$t<T>) -> cmp::Ordering {\n                 cmp::Ordering::Equal\n             }\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T:?Sized> Copy for $t<T> { }\n+        impl<T: ?Sized> Copy for $t<T> {}\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T:?Sized> Clone for $t<T> {\n+        impl<T: ?Sized> Clone for $t<T> {\n             fn clone(&self) -> $t<T> {\n                 $t\n             }\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T:?Sized> Default for $t<T> {\n+        impl<T: ?Sized> Default for $t<T> {\n             fn default() -> $t<T> {\n                 $t\n             }\n         }\n \n         #[unstable(feature = \"structural_match\", issue = \"31434\")]\n-        impl<T: ?Sized> StructuralPartialEq for $t<T> { }\n+        impl<T: ?Sized> StructuralPartialEq for $t<T> {}\n \n         #[unstable(feature = \"structural_match\", issue = \"31434\")]\n-        impl<T: ?Sized> StructuralEq for $t<T> { }\n-        )\n+        impl<T: ?Sized> StructuralEq for $t<T> {}\n+    };\n }\n \n /// Zero-sized type used to mark things that \"act like\" they own a `T`.\n@@ -661,7 +661,7 @@ macro_rules! impls{\n #[lang = \"phantom_data\"]\n #[structural_match]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct PhantomData<T:?Sized>;\n+pub struct PhantomData<T: ?Sized>;\n \n impls! { PhantomData }\n \n@@ -788,5 +788,4 @@ mod copy_impls {\n     // Shared references can be copied, but mutable references *cannot*!\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized> Copy for &T {}\n-\n }"}, {"sha": "5fb3c651b6b38e6bea5cc3cbf088d47d90e5359b", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -304,14 +304,15 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_uninit_array\", issue = \"none\")]\n     #[inline(always)]\n     pub fn uninit_array<const LEN: usize>() -> [Self; LEN] {\n-        unsafe {\n-            MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init()\n-        }\n+        unsafe { MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init() }\n     }\n \n     /// A promotable constant, equivalent to `uninit()`.\n-    #[unstable(feature = \"internal_uninit_const\", issue = \"none\",\n-        reason = \"hack to work around promotability\")]\n+    #[unstable(\n+        feature = \"internal_uninit_const\",\n+        issue = \"none\",\n+        reason = \"hack to work around promotability\"\n+    )]\n     pub const UNINIT: Self = Self::uninit();\n \n     /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being"}, {"sha": "e11072db0dcc63c096ead6b7af5d487961c0a4d6", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -745,7 +745,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// [`Copy`]: ../../std/marker/trait.Copy.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn drop<T>(_x: T) { }\n+pub fn drop<T>(_x: T) {}\n \n /// Interprets `src` as having type `&U`, and then reads `src` without moving\n /// the contained value.\n@@ -834,9 +834,7 @@ impl<T> hash::Hash for Discriminant<T> {\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n impl<T> fmt::Debug for Discriminant<T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt.debug_tuple(\"Discriminant\")\n-           .field(&self.0)\n-           .finish()\n+        fmt.debug_tuple(\"Discriminant\").field(&self.0).finish()\n     }\n }\n "}, {"sha": "e1e6c57a0fb7dee863d7d9e99d93d1ea4f8d634c", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -342,7 +342,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n+    #[stable(feature = \"f32_deg_rad_conversions\", since = \"1.7.0\")]\n     #[inline]\n     pub fn to_degrees(self) -> f32 {\n         // Use a constant for better precision.\n@@ -361,7 +361,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n+    #[stable(feature = \"f32_deg_rad_conversions\", since = \"1.7.0\")]\n     #[inline]\n     pub fn to_radians(self) -> f32 {\n         let value: f32 = consts::PI;\n@@ -424,7 +424,10 @@ impl f32 {\n     /// * Be representable in the return type `Int`, after truncating off its fractional part\n     #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n     #[inline]\n-    pub unsafe fn approx_unchecked_to<Int>(self) -> Int where Self: FloatToInt<Int> {\n+    pub unsafe fn approx_unchecked_to<Int>(self) -> Int\n+    where\n+        Self: FloatToInt<Int>,\n+    {\n         FloatToInt::<Int>::approx_unchecked(self)\n     }\n "}, {"sha": "dbfcbca3ffcbfd3b60233a6ebdf63cfc8d931f62", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -37,28 +37,28 @@ pub struct PanicInfo<'a> {\n }\n \n impl<'a> PanicInfo<'a> {\n-    #[unstable(feature = \"panic_internals\",\n-               reason = \"internal details of the implementation of the `panic!` \\\n+    #[unstable(\n+        feature = \"panic_internals\",\n+        reason = \"internal details of the implementation of the `panic!` \\\n                          and related macros\",\n-               issue = \"none\")]\n+        issue = \"none\"\n+    )]\n     #[doc(hidden)]\n     #[inline]\n     pub fn internal_constructor(\n         message: Option<&'a fmt::Arguments<'a>>,\n         location: &'a Location<'a>,\n     ) -> Self {\n         struct NoPayload;\n-        PanicInfo {\n-            location,\n-            message,\n-            payload: &NoPayload,\n-        }\n+        PanicInfo { location, message, payload: &NoPayload }\n     }\n \n-    #[unstable(feature = \"panic_internals\",\n-               reason = \"internal details of the implementation of the `panic!` \\\n+    #[unstable(\n+        feature = \"panic_internals\",\n+        reason = \"internal details of the implementation of the `panic!` \\\n                          and related macros\",\n-               issue = \"none\")]\n+        issue = \"none\"\n+    )]\n     #[doc(hidden)]\n     #[inline]\n     pub fn set_payload(&mut self, info: &'a (dyn Any + Send)) {\n@@ -222,20 +222,24 @@ impl<'a> Location<'a> {\n     /// assert_ne!(this_location.line(), another_location.line());\n     /// assert_ne!(this_location.column(), another_location.column());\n     /// ```\n-    #[unstable(feature = \"track_caller\",\n-               reason = \"uses #[track_caller] which is not yet stable\",\n-               issue = \"47809\")]\n+    #[unstable(\n+        feature = \"track_caller\",\n+        reason = \"uses #[track_caller] which is not yet stable\",\n+        issue = \"47809\"\n+    )]\n     #[track_caller]\n     pub const fn caller() -> &'static Location<'static> {\n         crate::intrinsics::caller_location()\n     }\n }\n \n impl<'a> Location<'a> {\n-    #![unstable(feature = \"panic_internals\",\n-                reason = \"internal details of the implementation of the `panic!` \\\n+    #![unstable(\n+        feature = \"panic_internals\",\n+        reason = \"internal details of the implementation of the `panic!` \\\n                           and related macros\",\n-                issue = \"none\")]\n+        issue = \"none\"\n+    )]\n     #[doc(hidden)]\n     pub const fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n         Location { file, line, col }"}, {"sha": "e5297a0c1e0942f0498710a953be4391cde6cf0e", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 45, "deletions": 35, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,7 +1,7 @@\n-use crate::cmp::Ordering::{self, Less, Equal, Greater};\n+use super::*;\n+use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n use crate::mem;\n-use super::*;\n \n // ignore-tidy-undocumented-unsafe\n \n@@ -154,8 +154,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub unsafe fn offset(self, count: isize) -> *const T\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         intrinsics::offset(self, count)\n     }\n@@ -212,8 +212,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[inline]\n     pub fn wrapping_offset(self, count: isize) -> *const T\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         unsafe { intrinsics::arith_offset(self, count) }\n     }\n@@ -284,8 +284,8 @@ impl<T: ?Sized> *const T {\n     #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n     #[inline]\n     pub const unsafe fn offset_from(self, origin: *const T) -> isize\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         let pointee_size = mem::size_of::<T>();\n         let ok = 0 < pointee_size && pointee_size <= isize::max_value() as usize;\n@@ -332,8 +332,8 @@ impl<T: ?Sized> *const T {\n     #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n     #[inline]\n     pub fn wrapping_offset_from(self, origin: *const T) -> isize\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         let pointee_size = mem::size_of::<T>();\n         assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n@@ -396,8 +396,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn add(self, count: usize) -> Self\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.offset(count as isize)\n     }\n@@ -457,8 +457,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn sub(self, count: usize) -> Self\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.offset((count as isize).wrapping_neg())\n     }\n@@ -512,8 +512,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_add(self, count: usize) -> Self\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.wrapping_offset(count as isize)\n     }\n@@ -567,8 +567,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_sub(self, count: usize) -> Self\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n@@ -582,8 +582,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         read(self)\n     }\n@@ -601,8 +601,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         read_volatile(self)\n     }\n@@ -618,8 +618,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         read_unaligned(self)\n     }\n@@ -635,8 +635,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy(self, dest, count)\n     }\n@@ -652,8 +652,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy_nonoverlapping(self, dest, count)\n     }\n@@ -699,8 +699,8 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n     pub fn align_offset(self, align: usize) -> usize\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         if !align.is_power_of_two() {\n             panic!(\"align_offset: align is not a power-of-two\");\n@@ -713,7 +713,9 @@ impl<T: ?Sized> *const T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> PartialEq for *const T {\n     #[inline]\n-    fn eq(&self, other: &*const T) -> bool { *self == *other }\n+    fn eq(&self, other: &*const T) -> bool {\n+        *self == *other\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -742,14 +744,22 @@ impl<T: ?Sized> PartialOrd for *const T {\n     }\n \n     #[inline]\n-    fn lt(&self, other: &*const T) -> bool { *self < *other }\n+    fn lt(&self, other: &*const T) -> bool {\n+        *self < *other\n+    }\n \n     #[inline]\n-    fn le(&self, other: &*const T) -> bool { *self <= *other }\n+    fn le(&self, other: &*const T) -> bool {\n+        *self <= *other\n+    }\n \n     #[inline]\n-    fn gt(&self, other: &*const T) -> bool { *self > *other }\n+    fn gt(&self, other: &*const T) -> bool {\n+        *self > *other\n+    }\n \n     #[inline]\n-    fn ge(&self, other: &*const T) -> bool { *self >= *other }\n+    fn ge(&self, other: &*const T) -> bool {\n+        *self >= *other\n+    }\n }"}, {"sha": "d7b351f13458ac2c18095221d9d7650c50b28db0", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -69,11 +69,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::intrinsics;\n+use crate::cmp::Ordering;\n use crate::fmt;\n use crate::hash;\n+use crate::intrinsics;\n use crate::mem::{self, MaybeUninit};\n-use crate::cmp::Ordering;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::intrinsics::copy_nonoverlapping;"}, {"sha": "b3bb2f179b17e291949363f176ca1c2179cf5463", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 61, "deletions": 51, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -1,6 +1,6 @@\n-use crate::cmp::Ordering::{self, Less, Equal, Greater};\n-use crate::intrinsics;\n use super::*;\n+use crate::cmp::Ordering::{self, Equal, Greater, Less};\n+use crate::intrinsics;\n \n // ignore-tidy-undocumented-unsafe\n \n@@ -148,8 +148,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub unsafe fn offset(self, count: isize) -> *mut T\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         intrinsics::offset(self, count) as *mut T\n     }\n@@ -205,8 +205,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[inline]\n     pub fn wrapping_offset(self, count: isize) -> *mut T\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         unsafe { intrinsics::arith_offset(self, count) as *mut T }\n     }\n@@ -322,8 +322,8 @@ impl<T: ?Sized> *mut T {\n     #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n     #[inline]\n     pub const unsafe fn offset_from(self, origin: *const T) -> isize\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         (self as *const T).offset_from(origin)\n     }\n@@ -365,8 +365,8 @@ impl<T: ?Sized> *mut T {\n     #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n     #[inline]\n     pub fn wrapping_offset_from(self, origin: *const T) -> isize\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         (self as *const T).wrapping_offset_from(origin)\n     }\n@@ -425,8 +425,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn add(self, count: usize) -> Self\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.offset(count as isize)\n     }\n@@ -486,8 +486,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn sub(self, count: usize) -> Self\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.offset((count as isize).wrapping_neg())\n     }\n@@ -541,8 +541,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_add(self, count: usize) -> Self\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.wrapping_offset(count as isize)\n     }\n@@ -596,8 +596,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_sub(self, count: usize) -> Self\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n@@ -611,8 +611,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         read(self)\n     }\n@@ -630,8 +630,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         read_volatile(self)\n     }\n@@ -647,8 +647,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         read_unaligned(self)\n     }\n@@ -664,8 +664,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy(self, dest, count)\n     }\n@@ -681,8 +681,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy_nonoverlapping(self, dest, count)\n     }\n@@ -698,8 +698,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from(self, src: *const T, count: usize)\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy(src, self, count)\n     }\n@@ -715,8 +715,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy_nonoverlapping(src, self, count)\n     }\n@@ -741,8 +741,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write(self, val: T)\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         write(self, val)\n     }\n@@ -756,8 +756,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_bytes(self, val: u8, count: usize)\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         write_bytes(self, val, count)\n     }\n@@ -775,8 +775,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_volatile(self, val: T)\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         write_volatile(self, val)\n     }\n@@ -792,8 +792,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_unaligned(self, val: T)\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         write_unaligned(self, val)\n     }\n@@ -807,8 +807,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn replace(self, src: T) -> T\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         replace(self, src)\n     }\n@@ -823,8 +823,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn swap(self, with: *mut T)\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         swap(self, with)\n     }\n@@ -870,8 +870,8 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n     pub fn align_offset(self, align: usize) -> usize\n-        where\n-            T: Sized,\n+    where\n+        T: Sized,\n     {\n         if !align.is_power_of_two() {\n             panic!(\"align_offset: align is not a power-of-two\");\n@@ -884,7 +884,9 @@ impl<T: ?Sized> *mut T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> PartialEq for *mut T {\n     #[inline]\n-    fn eq(&self, other: &*mut T) -> bool { *self == *other }\n+    fn eq(&self, other: &*mut T) -> bool {\n+        *self == *other\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -912,14 +914,22 @@ impl<T: ?Sized> PartialOrd for *mut T {\n     }\n \n     #[inline]\n-    fn lt(&self, other: &*mut T) -> bool { *self < *other }\n+    fn lt(&self, other: &*mut T) -> bool {\n+        *self < *other\n+    }\n \n     #[inline]\n-    fn le(&self, other: &*mut T) -> bool { *self <= *other }\n+    fn le(&self, other: &*mut T) -> bool {\n+        *self <= *other\n+    }\n \n     #[inline]\n-    fn gt(&self, other: &*mut T) -> bool { *self > *other }\n+    fn gt(&self, other: &*mut T) -> bool {\n+        *self > *other\n+    }\n \n     #[inline]\n-    fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n+    fn ge(&self, other: &*mut T) -> bool {\n+        *self >= *other\n+    }\n }"}, {"sha": "ce4c8995a3c4866e316cfff1b6f63aace01f7042", "filename": "src/libcore/result.rs", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60", "patch": "@@ -283,7 +283,7 @@ impl<T, E> Result<T, E> {\n     pub fn is_ok(&self) -> bool {\n         match *self {\n             Ok(_) => true,\n-            Err(_) => false\n+            Err(_) => false,\n         }\n     }\n \n@@ -328,10 +328,13 @@ impl<T, E> Result<T, E> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n-    pub fn contains<U>(&self, x: &U) -> bool where U: PartialEq<T> {\n+    pub fn contains<U>(&self, x: &U) -> bool\n+    where\n+        U: PartialEq<T>,\n+    {\n         match self {\n             Ok(y) => x == y,\n-            Err(_) => false\n+            Err(_) => false,\n         }\n     }\n \n@@ -354,10 +357,13 @@ impl<T, E> Result<T, E> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"result_contains_err\", issue = \"62358\")]\n-    pub fn contains_err<F>(&self, f: &F) -> bool where F: PartialEq<E> {\n+    pub fn contains_err<F>(&self, f: &F) -> bool\n+    where\n+        F: PartialEq<E>,\n+    {\n         match self {\n             Ok(_) => false,\n-            Err(e) => f == e\n+            Err(e) => f == e,\n         }\n     }\n \n@@ -387,7 +393,7 @@ impl<T, E> Result<T, E> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ok(self) -> Option<T> {\n         match self {\n-            Ok(x)  => Some(x),\n+            Ok(x) => Some(x),\n             Err(_) => None,\n         }\n     }\n@@ -414,7 +420,7 @@ impl<T, E> Result<T, E> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn err(self) -> Option<E> {\n         match self {\n-            Ok(_)  => None,\n+            Ok(_) => None,\n             Err(x) => Some(x),\n         }\n     }\n@@ -507,10 +513,10 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> {\n+    pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U, E> {\n         match self {\n             Ok(t) => Ok(op(t)),\n-            Err(e) => Err(e)\n+            Err(e) => Err(e),\n         }\n     }\n \n@@ -591,10 +597,10 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> {\n+    pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n-            Err(e) => Err(op(e))\n+            Err(e) => Err(op(e)),\n         }\n     }\n \n@@ -813,7 +819,7 @@ impl<T, E> Result<T, E> {\n     pub fn unwrap_or(self, optb: T) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(_) => optb\n+            Err(_) => optb,\n         }\n     }\n \n@@ -838,7 +844,7 @@ impl<T, E> Result<T, E> {\n     pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(e) => op(e)\n+            Err(e) => op(e),\n         }\n     }\n }\n@@ -923,7 +929,6 @@ impl<T: Clone, E> Result<&mut T, E> {\n     }\n }\n \n-\n impl<T, E: fmt::Debug> Result<T, E> {\n     /// Unwraps a result, yielding the content of an [`Ok`].\n     ///\n@@ -1100,8 +1105,7 @@ impl<T, E: Deref> Result<T, E> {\n     ///\n     /// Leaves the original `Result` in-place, creating a new one containing a reference to the\n     /// `Err` type's `Deref::Target` type.\n-    pub fn as_deref_err(&self) -> Result<&T, &E::Target>\n-    {\n+    pub fn as_deref_err(&self) -> Result<&T, &E::Target> {\n         self.as_ref().map_err(|e| e.deref())\n     }\n }\n@@ -1112,8 +1116,7 @@ impl<T: Deref, E: Deref> Result<T, E> {\n     ///\n     /// Leaves the original `Result` in-place, creating a new one containing a reference to both\n     /// the `Ok` and `Err` types' `Deref::Target` types.\n-    pub fn as_deref(&self) -> Result<&T::Target, &E::Target>\n-    {\n+    pub fn as_deref(&self) -> Result<&T::Target, &E::Target> {\n         self.as_ref().map(|t| t.deref()).map_err(|e| e.deref())\n     }\n }\n@@ -1135,8 +1138,7 @@ impl<T, E: DerefMut> Result<T, E> {\n     ///\n     /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n     /// the `Err` type's `Deref::Target` type.\n-    pub fn as_deref_mut_err(&mut self) -> Result<&mut T, &mut E::Target>\n-    {\n+    pub fn as_deref_mut_err(&mut self) -> Result<&mut T, &mut E::Target> {\n         self.as_mut().map_err(|e| e.deref_mut())\n     }\n }\n@@ -1148,8 +1150,7 @@ impl<T: DerefMut, E: DerefMut> Result<T, E> {\n     ///\n     /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n     /// both the `Ok` and `Err` types' `Deref::Target` types.\n-    pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E::Target>\n-    {\n+    pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E::Target> {\n         self.as_mut().map(|t| t.deref_mut()).map_err(|e| e.deref_mut())\n     }\n }\n@@ -1212,7 +1213,6 @@ impl<T: Clone, E: Clone> Clone for Result<T, E> {\n     }\n }\n \n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, E> IntoIterator for Result<T, E> {\n     type Item = T;\n@@ -1276,25 +1276,31 @@ impl<'a, T, E> IntoIterator for &'a mut Result<T, E> {\n /// [`Result::iter`]: enum.Result.html#method.iter\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n+pub struct Iter<'a, T: 'a> {\n+    inner: Option<&'a T>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a T> { self.inner.take() }\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.inner.take()\n+    }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let n = if self.inner.is_some() {1} else {0};\n+        let n = if self.inner.is_some() { 1 } else { 0 };\n         (n, Some(n))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        self.inner.take()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1309,7 +1315,9 @@ unsafe impl<A> TrustedLen for Iter<'_, A> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Iter<'_, T> {\n     #[inline]\n-    fn clone(&self) -> Self { Iter { inner: self.inner } }\n+    fn clone(&self) -> Self {\n+        Iter { inner: self.inner }\n+    }\n }\n \n /// An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].\n@@ -1321,25 +1329,31 @@ impl<T> Clone for Iter<'_, T> {\n /// [`Result::iter_mut`]: enum.Result.html#method.iter_mut\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n+pub struct IterMut<'a, T: 'a> {\n+    inner: Option<&'a mut T>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a mut T> { self.inner.take() }\n+    fn next(&mut self) -> Option<&'a mut T> {\n+        self.inner.take()\n+    }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let n = if self.inner.is_some() {1} else {0};\n+        let n = if self.inner.is_some() { 1 } else { 0 };\n         (n, Some(n))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n+    fn next_back(&mut self) -> Option<&'a mut T> {\n+        self.inner.take()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1364,25 +1378,31 @@ unsafe impl<A> TrustedLen for IterMut<'_, A> {}\n /// [`IntoIterator`]: ../iter/trait.IntoIterator.html\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<T> { inner: Option<T> }\n+pub struct IntoIter<T> {\n+    inner: Option<T>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<T> { self.inner.take() }\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.take()\n+    }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let n = if self.inner.is_some() {1} else {0};\n+        let n = if self.inner.is_some() { 1 } else { 0 };\n         (n, Some(n))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<T> { self.inner.take() }\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.take()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1443,7 +1463,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// Since the third element caused an underflow, no further elements were taken,\n     /// so the final value of `shared` is 6 (= `3 + 2 + 1`), not 16.\n     #[inline]\n-    fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {\n+    fn from_iter<I: IntoIterator<Item = Result<A, E>>>(iter: I) -> Result<V, E> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n@@ -1452,7 +1472,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n }\n \n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n-impl<T,E> ops::Try for Result<T, E> {\n+impl<T, E> ops::Try for Result<T, E> {\n     type Ok = T;\n     type Error = E;\n "}, {"sha": "5ddf5d48965d5fb2545f11b04739fbb20e81baee", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "8a1fb9de54667db0b7e1c96e9d9e1f7c8b6567f1", "filename": "src/libcore/str/lossy.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Flossy.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "ab771b1164bada9cac464668ce8ab02b5755636d", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 243, "deletions": 176, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "2cbdeb2e4eed82015eb733bb4d0d073371a8813e", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 130, "deletions": 101, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "a2352c08e7316083c8ee73afb41fe38dfc3443b6", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 76, "deletions": 60, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "4086917780fa4ae46ac17834567e5e34f6571fab", "filename": "src/libcore/tests/cmp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcmp.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "90a9bccda15800022286157e17faa035a24893b4", "filename": "src/libcore/tests/fmt/builders.rs", "status": "modified", "additions": 110, "deletions": 125, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "1566d35749017c99b2d8df5a0be2805abd739cd4", "filename": "src/libcore/tests/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "cf28ec8a636bcd23a91aa4d8f628ef7a29041d43", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 167, "deletions": 137, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "a1fa5556ae5dbbf36a6cdaf27734476c453e894e", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "f693504824641ce18efb8a4a28091afca8fc491d", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 584, "deletions": 452, "changes": 1036, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "f61793a3bca814ee8ba3130379d34eba086fd983", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 121, "deletions": 122, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "6ec61cc97c97260edf44fc869ec002c2ca72eb27", "filename": "src/libcore/tests/pattern.rs", "status": "modified", "additions": 341, "deletions": 128, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fpattern.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "a008b3319f39a0de508e70e07b426a5436190874", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "499a5613bd2fe3eeb88852ae064cb8b5f2931534", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "fa0021a7c734f2f2529325ce92512d367bb20733", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "71a6d51fc870cc893c58f9ed8301f6db796b0cef", "filename": "src/libfmt_macros/tests.rs", "status": "modified", "additions": 101, "deletions": 102, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibfmt_macros%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibfmt_macros%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Ftests.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "d04f5c1d4ee77228e9ea7bd8e8b5dbc2bd81d01c", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "055e13156ae84e3cb682d3caaa656e66cbd2b9b9", "filename": "src/libgraphviz/tests.rs", "status": "modified", "additions": 103, "deletions": 75, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibgraphviz%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibgraphviz%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Ftests.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "db7c250e21157810f35b357b6a2d072a924a042b", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "302478cfac8f5ebf1fffc3516235a3d79d9e2861", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "649bbce52a364ccc6a329816c2a2ca462562cb0c", "filename": "src/libpanic_unwind/dwarf/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "2098404ee1b9d6cbb7b908c5a8094739b601fcd5", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "e5e8e805b6e89466d72284b166e88943ad3929f4", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "2f53df2861d4436bcf84ce88b4ddf7cdc87594d6", "filename": "src/libpanic_unwind/hermit.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Fhermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Fhermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fhermit.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "e721162edc067b789edf572623e09699fe970166", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "9a28c47ba9458d22ea5d9db173534b9968a1b521", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "aeecbd496621bb45f31970ba66945cfb51cad781", "filename": "src/libproc_macro/bridge/buffer.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "dd948025c91cacfb256899427e6f02ff4f9e71ab", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "5bfe287d33ab7af03cff1171e19432a77e4eb1dc", "filename": "src/libproc_macro/bridge/closure.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclosure.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "bcbb86812470a3e9702c0291cea97dec0efc9c26", "filename": "src/libproc_macro/bridge/handle.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fhandle.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "a0e7d90f4974ef14631c0e8fec8fd4746f8575fe", "filename": "src/libproc_macro/bridge/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "ca18d4459aa899fd0ab7dc590df2dce3b22d40d8", "filename": "src/libproc_macro/bridge/server.rs", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fserver.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "fdf252e53387ecee7dcc4e2073cb55860e9e221e", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "0b74a104da44bd510eb2bb18bdadb0176b666918", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "04cd2efe00093d80a859bf56b64a553abdcd9be4", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "bb1f2785deb1bf46d0871ef1c09a69d3c9e21f16", "filename": "src/libprofiler_builtins/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibprofiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibprofiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "3d5bd313f88384adb01c34ac126060f2dc33a549", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "ffb12f11c5136fb1169e53e764210888ffd32bad", "filename": "src/librustc/benches/lib.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "d44c54593a6276319794e872fee07419f1e8cafd", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "57f72ba0507899d1ad33a6b0c53177544d45228a", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "0d03c834e0f7bf433ba730f628fed3567840f7d8", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 207, "deletions": 214, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "eb377d20f5963cc17ee6f2c8f5e948721e8f67ae", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "fbc8f7bc997e095762bc513e49e7e5e5bc469f6c", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "c71c11ed0ebdf22701758709416e58fee683dfe5", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "5395117ff24fcf0f07970f063ae6b724c36d4956", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "640877d3d55c3bca47d42082ce85f186180f70b6", "filename": "src/librustc/dep_graph/serialized.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "5918ff03d585d6370456a63eace8bcd85938492f", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 116, "deletions": 100, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "38223843e27567c3598660514a052cfc07d6c4d9", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "b26617a57f4758e0d6c782f746a712d66c845c07", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "dc2008fdd9743f706750b0b9a2f91e77bd6ed935", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 134, "deletions": 147, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "56dcf91a134ce43fd7b5336ae3eb1bd35e0b57ab", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "8939b5eef266062f3c32ece766a9baf0400c3a49", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 139, "deletions": 260, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "04ebe3e8a72baa15416de8b015a7f67493225432", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 251, "deletions": 351, "changes": 602, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "880e6d6dcf4cc5f83fbaa9750a9295a99fd95a97", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 68, "deletions": 64, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "feab7cdac1e5eb2cb317d5e8c4d38ca7e8487f94", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 89, "deletions": 91, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "15819f3b6e02305d94cd7c0b9269f81eaf394237", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 75, "deletions": 108, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "4c250aba96d091a4cbdfc389a2abb808445fc46e", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "f3be7e32ceabf88015680dc3936f5e9ef6954de1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 370, "deletions": 464, "changes": 834, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "4aa8c12a219cabeed5740044c452278b1ad73ca1", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 191, "deletions": 222, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "c0aa54beac2759239443c23d882259eed9c33a0b", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "767e53f9519013173f736b81ea4fe8c934d9087f", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 301, "deletions": 318, "changes": 619, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "b5d0c6b051f8d5e08b94e8faa5c8e8068f5abc9f", "filename": "src/librustc/hir/ptr.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fptr.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "2df7a38693af63e3477dfff47a37a93ba179b2a6", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "9442392ea9e31cfb4fa2726b85a9734512cdfd3a", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 39, "deletions": 52, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "360fa99c6208f019639236a4a13b5f4475eae2b7", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 33, "deletions": 84, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "e13822aed4de73c6ccd8f388597892277058f0bf", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "6af0cee948d8610b41bf694262afc12855836d0d", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "4ad3e9482ded84be6c01984c74d402b7e6cd109b", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "c58f1bd87bd8df907065a52c9d6b2e0dc0f2dcf3", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 102, "deletions": 137, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "d5666f6975bc7a51543207f9c3d304bc989a430f", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 39, "deletions": 83, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "f6a716a1204693f1ed949c48ba490622c1ff6bc1", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 48, "deletions": 78, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "f35bec0c81d5b7b03bd08eb85e6daad552146f38", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 59, "deletions": 98, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "92516345633f21134b1f3fc7f53046698326c1a6", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "9e47c178415a54d1bf629f5e3649d84825c9766a", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 122, "deletions": 116, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "6a7707b3c0ad169b7c7b24d814d552127cad5e8f", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "027143a3d22c0fa2d61c2c1388f6ff32935785b4", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 142, "deletions": 182, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "9954c35433c313963e0072fde17b63b6427eb81b", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 66, "deletions": 78, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "cfb6d5bd244b9161b1d9702d01094a5635dc95ba", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "decc00826dd9c7a148752f6568f0e5d2b6814524", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "023d9f89b039ced8f36db4436979944c6ea7903e", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "94b8d16668a3fd1c77b103184adc9355c05bb605", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "e6758f6596d505a30e53057c6f6d13422adfb0fc", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "8f6fbd27a58af1dc93b288514722ea72865ae3cd", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "6f9fe25b63058bf0f6a2853909d5f54404cec4b6", "filename": "src/librustc/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "36e91fa3e37a9d989b749ce3736df95ca519e6a0", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "979bcca619c2ff6a3573fdc75fb60cb4198e3143", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 467, "deletions": 271, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "f258968b2a31b50891358c3b52e79cc7907832e9", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 72, "deletions": 81, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "df265bf0147b657f8eb206ecd07e8b1da530ea7f", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "293dc80d983a957fafbe3e0332ce352a3affe7d8", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "bbca4823431e80800f21ac0830b99f7a063d9e58", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "3e0aa4727ae1ae50dbcb1fdbba41650f1ca3aae6", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "2a3187afd710096207bff93f975433abd3d5f0fc", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "723169b9f5fc5416e8e83a287295a68c1545e118", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "b512d3df3e8df285251b71080c2e8c4cfc07d0cf", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "e563f986f57e17f1131b3b436b5cb9f88ddb606c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 90, "deletions": 139, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "74f1c26b0f21d4eb8859083bdf8b694458f15923", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 24, "deletions": 68, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "3e9f68cebefaeabb360c6caa83201243b9b164b8", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 62, "deletions": 70, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "a49b770ceb845555e39b54ad205b43a17d7a2922", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "42f506606e69ae17ce280516e5e855c58e55c6c8", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "4bafd2ebf40a133179eda55e44424bae4093d577", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 24, "deletions": 57, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "828d4c2e0e760bbc69d5ae7e9f4d5d38c21c553a", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "3b3a464ba557ad5b33ef84cd170aa9405f29fe39", "filename": "src/librustc/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "19b3c30e537338cf3af614a9f639a5afbac28da2", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 27, "deletions": 56, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "d7dc6070442229de0c5d1fba7e7b82c5c5b511e1", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "f355ffe196202de3323b419252d344ad97941654", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 52, "deletions": 38, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "fb301037fa5d13e4474996f1d309ebae17953b57", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "023b15f7943e6cc9e613aab583d45d3a8a44dd50", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "55713aedbcb67589677696ef39d1f2f6004c98b6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "1da9661cbf27008ea2f9490a6bf578ea85a373ea", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "113084e7b7e0eafbe3efb95d5b99f8daadd82303", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 182, "deletions": 195, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "55ed46e774ded93097fef82ed629fbe114659c91", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "edf7df16c87faefa49d5ff5ad70349b0173e537f", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 96, "deletions": 115, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "9dd913ab345888448109bac1cf19edf406779188", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "32ef1338712bb60b390690f5a6b293c7ffcd62e1", "filename": "src/librustc/middle/diagnostic_items.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "756af9be6573ffe0cb46f541963840c5ca18de03", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "e6c51cc7c0844106c633ea2b7b2985d18378ddca", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "5881b82f7549e3cdd174278287740c330f7f8f57", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "b4ddb09861df5cd51508e4f309e4aa2f35a69869", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "fc48999115e861e0f92c5a2e9bdb0d175df192cf", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "22af74c1361b2aeb464a52bc53c8124daeef1154", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 92, "deletions": 111, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "8f19494d388dfb98ee82c3741c458e9e503a65d6", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "3e97beb7bce23c4217e9cb57e3f387e12df0878e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 179, "deletions": 171, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "f1c07f36da5d03c5a2eb92e14bfa4efe80caa964", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 161, "deletions": 158, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "600b05068cdc9f4611137d172e624232d5115bd0", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "00ecc7a7a0aa1b7c3da43ec8c135a310eaa2f431", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 19, "deletions": 35, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "67f1c8072d6800e235c153a0ff445f84d658687d", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 75, "deletions": 106, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "843880200f3d745196d4ca9cb05907c66415cada", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 201, "deletions": 219, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "185fa4cf9416f9fab846f53b7d15ba5a944ddd79", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 38, "deletions": 53, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "9b0399e22c59cc1532b53f8594ea4d218c55d369", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "e6caa146a627f6e02eca792df595ba600b14c590", "filename": "src/librustc/mir/interpret/queries.rs", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "49b542af0a034957c942269d3333ac37d816a950", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 57, "deletions": 45, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "dc74ff1e98d66c9acd31ce06d6e51b0d8c0c7e31", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 119, "deletions": 119, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "b13b4fd3b8d37e108d2674c6039ad5c64556f39c", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 97, "deletions": 131, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "234221130d8328c94978d77f944e2c293688d3ea", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 52, "deletions": 70, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "a89811ed43bb80a65cc2c90ba21e14b1a1189631", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "50c5bd9299f36bc44ad023d3f586d6d9882152ff", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "24841a1ccf4563ca4fac249360889180b5a34129", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "89b28aeda1c5efe383ff1286dc340ac300f8e53a", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 81, "deletions": 104, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "a765e55d99fc2166ccf30289b52819896da78ffa", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "8bd3f3141d53d6b963e0579cb3dff0cd4f212ffc", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "3eaa9db0b15227df6fc251982305ad13bbed7317", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 88, "deletions": 98, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "b6645404026053cd625f83a9e97ac6e240532f5c", "filename": "src/librustc/traits/engine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "2ac2d789b2d348ba2a1f36629b53fcf70e9235d3", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 765, "deletions": 635, "changes": 1400, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "614375287ba6effd4d89777ede2395984cefb6ed", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 123, "deletions": 105, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "ac49f522f431fdefffce636044789eb41122d0bb", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 137, "deletions": 147, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "ff4d8980054cfa7b4516c70da9e3f805583cd1db", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 98, "deletions": 67, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "90381895f0a332b7e3029d9c35d83b7c47d7a2f4", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 407, "deletions": 455, "changes": 862, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "80a82021c9a342bc1b3a3473d4d0dcd509b8f5b7", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "b9ce3ccff274888190eb458edba83d6570958281", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "4ef775750ec3778144c0cde60877a994f717df7d", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "fb9f46011b99b3075e0f4a96d1339f96851b1d67", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "8f23f98a2a423991c69e71294b3a3efdb2fd84fa", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "2fa52e8810bd99621a3f2011a398b5ef56655bb1", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "722bd0bca6a5b91fdc953b816d682126a763038d", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "e183a5a54702d524da2c8434fe9df25f13a9b2e1", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "3ca6636c1dea602b908e317f2175132fe16426e3", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "267722362c5c79eca79ca8038fb99b0bfed95af9", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "adf63e4d60c99ccfd2a3e50618187ce3c18297e9", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "8a028eecd5b622a7e90024f43cff8916e00ac085", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "35afa6379688306a1cecd1e231f1cd494d481c9f", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "c70508a20a182341d34aba5dd7e12b5a0cc2b385", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "f11fcc4ebae4ed04be00bd339e412f61577c2881", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 265, "deletions": 527, "changes": 792, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "d527aa310ad28de521a01933ea5ca80a1143d92a", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 114, "deletions": 99, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "8d2dcee22f5448f5b1fe0d89ae50139c1c827108", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 52, "deletions": 62, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "ed0842d80988f1d2170a73db7ecea1988f227052", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 80, "deletions": 132, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "d36ff8c236f8f31144e89b52752e9bdf2a37a14c", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 127, "deletions": 128, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "35f8eb20475c7f8e328f5edbd33341c8470714a0", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "e1b63a6d9e703434c3a664831da4d5ea7b3f974b", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "222950785acd8c9a956bc6cd41cddf5361943e4d", "filename": "src/librustc/ty/binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "5ba3f80b82296842f8117b555156a8990cc7c5dc", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "d55b756adf6d188f39e70f08760db89424ebbfe7", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "d1eb21e25ffaf0183fb7d3e31fb873ee685b204b", "filename": "src/librustc/ty/diagnostics.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fdiagnostics.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "4bf08096edeb8e589f25ee24760bbf721ffd9bbf", "filename": "src/librustc/ty/erase_regions.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "c4a134926aed9080cc0c39fb5fc0002203b1f1c9", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 166, "deletions": 152, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "f5dce6b3958a294b339581e6ab2fe23caf144624", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "b9aa12b46658946dc1fc76edeea5f8a66087ac29", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "53a1727d1cc136b988c63e2ae5c4fbc3b3b34e8e", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 107, "deletions": 128, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "5a2e19156535aeefb980865f4465ffc7d76118fa", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "73ca0075994a517dc647bb1b37369b6448e57b41", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "faa83ceaddea2ab977300cf851815a73a2d51773", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 93, "deletions": 127, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "98aa299a7040549179ae3e9be6fd7d67e83d563e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 519, "deletions": 573, "changes": 1092, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "8834e0e5a08c47c8ffdf396214059e829ad59083", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 399, "deletions": 438, "changes": 837, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "383ccbd337a7d25ffc66ccb46c0affe33645f172", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "e58c912960817870824229eba94165eabf29ad4e", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 76, "deletions": 77, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "7c3579d59205e0d8d614d28f48ea2cea3c166959", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "9bd7701da1feb22431b1e15031f163507428761a", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 198, "deletions": 268, "changes": 466, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "5af0e78b04616d5bc14cd98aee3a6b4b255e17c3", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "7361485c55d9fd35b713ebd1ba98edb5b00bfd63", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 71, "deletions": 88, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "78e97f701ea579eae2dab6f2a38267f7c850e3df", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "8be0536a18ec62f6c62c57ade44e64ec767fee81", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "2a03413ee603d8dafd7ee205af3e1baffe6242e7", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 104, "deletions": 118, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "0114cd9076a88b40eb0a8108457070d7f29fd763", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 90, "deletions": 102, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "65298ed65d1973c3939ffdd025ebc94139000ba3", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "933358dce018b679d56e5a7e3382b979daa4f6ae", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 114, "deletions": 159, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "224e76845d708ad729370a7140980b9b08945485", "filename": "src/librustc/ty/steal.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fsteal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fsteal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsteal.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "61ee7288a9bdf9fb3a6e396452a88be41e6fa38c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 150, "deletions": 275, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "426dd93c55732a65fb1f59f6808ca1ce3e62656e", "filename": "src/librustc/ty/structural_match.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_match.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "c17fff29810d4e35797442cba2075a409ebd597c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 300, "deletions": 236, "changes": 536, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "3804b5aed7161d52a82ec9f48f3c2e7bb5fb7178", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 70, "deletions": 110, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "422d1b1173792c4c1274fb469e3d4d0b2828c274", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "41b3d0f7391b2956dc55ab636d21ef7eee49cfbf", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 182, "deletions": 218, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "9e0dd8e067a203a5d2356730a86dd93d4c68f354", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "8c1f416235a6c554ec0233d10c90fc27a0f1071a", "filename": "src/librustc/util/bug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Futil%2Fbug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Futil%2Fbug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fbug.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "26b90ebfd5f117076cd4a99d4f1c772e0e1a8e5d", "filename": "src/librustc/util/captures.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Futil%2Fcaptures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Futil%2Fcaptures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcaptures.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "581f1c0ab6a2db592a456a2209d6c11073ce121d", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "ce0f77e0b6d37d7525824f5dfe0f1f5ccf27254b", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "dd56835edbac5e78536619885c77688a66af31fe", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 104, "deletions": 128, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "d08ff60a366ccf52e57ade5b6df24204d799d84e", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 61, "deletions": 39, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}, {"sha": "e0b306ac47cc4c34527507ee00309186437d5716", "filename": "src/librustc_apfloat/ppc.rs", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06baa56b95674fc626b3c3fd680d6a65357fe60/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=a06baa56b95674fc626b3c3fd680d6a65357fe60"}]}