{"sha": "0c97fcbf6689d8d4f466cdea80369ae057a4523e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjOTdmY2JmNjY4OWQ4ZDRmNDY2Y2RlYTgwMzY5YWUwNTdhNDUyM2U=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-18T09:20:51Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-18T11:49:01Z"}, "message": "Properly check kinds in instantiation of generics\n\nIssue #1177", "tree": {"sha": "163bf50707800b0a400c551cca7c5c102a60458b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/163bf50707800b0a400c551cca7c5c102a60458b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c97fcbf6689d8d4f466cdea80369ae057a4523e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c97fcbf6689d8d4f466cdea80369ae057a4523e", "html_url": "https://github.com/rust-lang/rust/commit/0c97fcbf6689d8d4f466cdea80369ae057a4523e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c97fcbf6689d8d4f466cdea80369ae057a4523e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bef89f9b5da4ab327a39419c176e65d6e8938b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bef89f9b5da4ab327a39419c176e65d6e8938b1", "html_url": "https://github.com/rust-lang/rust/commit/7bef89f9b5da4ab327a39419c176e65d6e8938b1"}], "stats": {"total": 315, "additions": 29, "deletions": 286}, "files": [{"sha": "6437e00f99b1236db9609df423dd5b21bc92da19", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 27, "deletions": 284, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/0c97fcbf6689d8d4f466cdea80369ae057a4523e/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c97fcbf6689d8d4f466cdea80369ae057a4523e/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=0c97fcbf6689d8d4f466cdea80369ae057a4523e", "patch": "@@ -1,4 +1,4 @@\n-import std::option::some;\n+import std::option::{some, none};\n import syntax::{visit, ast_util};\n import syntax::ast::*;\n import syntax::codemap::span;\n@@ -50,12 +50,33 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_bind(_, args) {\n         for a in args { alt a { some(ex) { maybe_copy(cx, ex); } _ {} } }\n       }\n-      // FIXME check for by-copy args\n-      expr_call(_f, _args, _) {\n-\n+      expr_call(f, args, _) {\n+        let i = 0u;\n+        for arg_t in ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f)) {\n+            alt arg_t.mode { by_copy. { maybe_copy(cx, args[i]); } _ {} }\n+            i += 1u;\n+        }\n+      }\n+      expr_path(_) {\n+        let substs = ty::node_id_to_ty_param_substs_opt_and_ty(cx.tcx, e.id);\n+        alt substs.substs {\n+          some(ts) {\n+            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n+            let kinds = ty::lookup_item_type(cx.tcx, did).kinds, i = 0u;\n+            for ty in ts {\n+                let kind = ty::type_kind(cx.tcx, ty);\n+                if !ty::kind_lteq(kinds[i], kind) {\n+                    cx.tcx.sess.span_err(e.span, \"instantiating a \" +\n+                                         kind_to_str(kinds[i]) +\n+                                         \" type parameter with a \"\n+                                         + kind_to_str(kind) + \" type\");\n+                }\n+                i += 1u;\n+            }\n+          }\n+          none. {}\n+        }\n       }\n-      // FIXME: generic instantiation\n-      expr_path(_) {}\n       expr_fn({proto: proto_shared(_), _}) {\n         for free in *freevars::get_freevars(cx.tcx, e.id) {\n             let id = ast_util::def_id_of_def(free).node;\n@@ -114,284 +135,6 @@ fn check_copy(cx: ctx, ty: ty::t, sp: span) {\n     }\n }\n \n-\n-/*\n-* Kinds are types of type.\n-*\n-* Every type has a kind. Every type parameter has a set of kind-capabilities\n-* saying which kind of type may be passed as the parameter.\n-*\n-* The kinds are based on two capabilities: move and send. These may each be\n-* present or absent, though only three of the four combinations can actually\n-* occur:\n-*\n-*\n-*\n-*    MOVE +   SEND  =  \"Unique\": no shared substructures or pins, only\n-*                                interiors and ~ boxes.\n-*\n-*    MOVE + NOSEND  =  \"Shared\": structures containing @, fixed to the local\n-*                                task heap/pool; or ~ structures pointing to\n-*                                pinned values.\n-*\n-*  NOMOVE + NOSEND  =  \"Pinned\": structures directly containing resources, or\n-*                                by-alias closures as interior or\n-*                                uniquely-boxed members.\n-*\n-*  NOMOVE +   SEND  =  --      : no types are like this.\n-*\n-*\n-* Since this forms a lattice, we denote the capabilites in terms of a\n-* worst-case requirement. That is, if your function needs to move-and-send (or\n-* copy) your T, you write fn<uniq T>(...). If you need to move but not send,\n-* you write fn<T>(...). And if you need neither -- can work with any sort of\n-* pinned data at all -- then you write fn<pin T>(...).\n-*\n-* Most types are unique or shared. Other possible name combinations for these\n-* two: (tree, graph; pruned, pooled; message, local; owned, common) are\n-* plausible but nothing stands out as completely pithy-and-obvious.\n-*\n-* Pinned values arise in 2 contexts: resources and &-closures (blocks). The\n-* latter absolutely must not be moved, since they could escape to the heap;\n-* the former must not be copied, since they'd then be multiply-destructed.\n-* We achieve the no-copy restriction by recycling the no-move restriction\n-* in place on pinned kinds for &-closures; and as a benefit we can guarantee\n-* that a resource passed by reference to C will never move during its life,\n-* occasionally useful for FFI-code.\n-*\n-* Resources cannot be sent because we don't want to oblige the communication\n-* system to run destructors in some weird limbo context of\n-* messages-in-transit. It should always be ok to just free messages it's\n-* dropping. Even if you wanted to send them, you'd need a new sigil for the\n-* NOMOVE + SEND combination, and you couldn't use the move-mode library\n-* interface to chan.send in that case (NOMOVE after all), so the whole thing\n-* wouldn't really work as minimally as the encoding we have here.\n-*\n-* Note that obj~ and fn~ -- those that capture a unique environment -- can be\n-* sent, so satisfy ~T. So can plain obj and fn. They can all also be copied.\n-*\n-* Further notes on copying and moving; sending is accomplished by calling a\n-* move-in operator on something constrained to a unique type ~T.\n-*\n-*\n-* COPYING:\n-* --------\n-*\n-*   A copy is made any time you pass-by-value or execute the = operator in a\n-*   non-init expression. Copying requires discriminating on type constructor.\n-*\n-*   @-boxes copy shallow, copying is always legal.\n-*\n-*   ~-boxes copy deep, copying is only legal if pointee is unique-kind.\n-*\n-*     Pinned-kind values (resources, &-closures) can't be copied. All other\n-*     unique-kind (eg. interior) values can be copied, and copy shallow.\n-*\n-*   Note: If you have no type constructor -- only an opaque typaram -- then\n-*   you can only copy if the typaram is constrained to ~T; this is because @T\n-*   might be a \"~resource\" box, and making a copy would cause a deep\n-*   resource-copy.\n-*\n-*\n-* MOVING:\n-* -------\n-*\n-*  A move is made any time you pass-by-move (that is, with move mode '-') or\n-*  execute the move ('<-') or swap ('<->') operators.\n-*\n-*/\n-\n-/*\n-fn type_and_kind(tcx: ty::ctxt, e: @ast::expr) ->\n-   {ty: ty::t, kind: ast::kind} {\n-    let t = ty::expr_ty(tcx, e);\n-    let k = ty::type_kind(tcx, t);\n-    {ty: t, kind: k}\n-}\n-\n-fn need_expr_kind(tcx: ty::ctxt, e: @ast::expr, k_need: ast::kind,\n-                  descr: str) {\n-    let tk = type_and_kind(tcx, e);\n-    log #fmt[\"for %s: want %s type, got %s type %s\", descr,\n-             kind_to_str(k_need), kind_to_str(tk.kind),\n-             util::ppaux::ty_to_str(tcx, tk.ty)];\n-\n-    demand_kind(tcx, e.span, tk.ty, k_need, descr);\n-}\n-\n-fn demand_kind(tcx: ty::ctxt, sp: codemap::span, t: ty::t,\n-               k_need: ast::kind, descr: str) {\n-    let k = ty::type_kind(tcx, t);\n-    if !kind_lteq(k_need, k) {\n-        let s =\n-            #fmt[\"mismatched kinds for %s: needed %s type, got %s type %s\",\n-                 descr, kind_to_str(k_need), kind_to_str(k),\n-                 util::ppaux::ty_to_str(tcx, t)];\n-        tcx.sess.span_err(sp, s);\n-    }\n-}\n-\n-fn need_shared_lhs_rhs(tcx: ty::ctxt, a: @ast::expr, b: @ast::expr, op: str) {\n-    need_expr_kind(tcx, a, ast::kind_copyable, op + \" lhs\");\n-    need_expr_kind(tcx, b, ast::kind_copyable, op + \" rhs\");\n-}\n-\n-/*\n-This ... is a hack (I find myself writing that too often *sadface*).\n-\n-We need to be able to put pinned kinds into other types but such operations\n-are conceptually copies, and pinned kinds can't do that, e.g.\n-\n-let a = my_resource(x);\n-let b = @a; // no-go\n-\n-So this function attempts to make a loophole where resources can be put into\n-other types as long as it's done in a safe way, specifically like\n-\n-let b = @my_resource(x);\n-*/\n-fn need_shared_or_pinned_ctor(tcx: ty::ctxt, a: @ast::expr, descr: str) {\n-    let tk = type_and_kind(tcx, a);\n-    if tk.kind == ast::kind_pinned && !pinned_ctor(a) {\n-        let err =\n-            #fmt[\"mismatched kinds for %s: cannot copy pinned type %s\",\n-                 descr, util::ppaux::ty_to_str(tcx, tk.ty)];\n-        tcx.sess.span_err(a.span, err);\n-        let note =\n-            #fmt[\"try constructing %s directly into %s\",\n-                 util::ppaux::ty_to_str(tcx, tk.ty), descr];\n-        tcx.sess.span_note(a.span, note);\n-    } else if tk.kind != ast::kind_pinned {\n-        need_expr_kind(tcx, a, ast::kind_shared, descr);\n-    }\n-\n-    fn pinned_ctor(a: @ast::expr) -> bool {\n-        // FIXME: Technically a lambda block is also a pinned ctor\n-        alt a.node {\n-          ast::expr_call(cexpr, _, _) {\n-            // Assuming that if it's a call that it's safe to move in, mostly\n-            // because I don't know offhand how to ensure that it's a call\n-            // specifically to a resource constructor\n-            true\n-          }\n-          ast::expr_rec(_, _) {\n-            true\n-          }\n-          ast::expr_unary(ast::uniq(_), _) {\n-            true\n-          }\n-          ast::expr_tup(_) {\n-            true\n-          }\n-          ast::expr_vec(exprs, _) {\n-            true\n-          }\n-          _ { false }\n-        }\n-    }\n-}\n-\n-fn check_expr(tcx: ty::ctxt, e: @ast::expr) {\n-    alt e.node {\n-\n-      // FIXME: These rules do not fully implement the copy type-constructor\n-      // discrimination described by the block comment at the top of this\n-      // file. This code is wrong; it lets you copy anything shared-kind.\n-\n-      ast::expr_move(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<-\"); }\n-      ast::expr_assign(a, b) {\n-        need_shared_lhs_rhs(tcx, a, b, \"=\");\n-      }\n-      ast::expr_assign_op(_, a, b) {\n-        need_shared_lhs_rhs(tcx, a, b, \"op=\");\n-      }\n-      ast::expr_swap(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<->\"); }\n-      ast::expr_copy(a) {\n-        need_expr_kind(tcx, a, ast::kind_shared, \"'copy' operand\");\n-      }\n-      ast::expr_ret(option::some(a)) {\n-        need_expr_kind(tcx, a, ast::kind_shared, \"'ret' operand\");\n-      }\n-      ast::expr_be(a) {\n-        need_expr_kind(tcx, a, ast::kind_shared, \"'be' operand\");\n-      }\n-      ast::expr_fail(option::some(a)) {\n-        need_expr_kind(tcx, a, ast::kind_shared, \"'fail' operand\");\n-      }\n-      ast::expr_call(callee, _, _) {\n-        let tpt = ty::expr_ty_params_and_ty(tcx, callee);\n-\n-        // If we have typarams, we're calling an item; we need to check\n-        // that all the types we're supplying as typarams conform to the\n-        // typaram kind constraints on that item.\n-        if vec::len(tpt.params) != 0u {\n-            let callee_def =\n-                ast_util::def_id_of_def(tcx.def_map.get(callee.id));\n-            let item_tk = ty::lookup_item_type(tcx, callee_def);\n-            let i = 0;\n-            assert (vec::len(item_tk.kinds) == vec::len(tpt.params));\n-            for k_need: ast::kind in item_tk.kinds {\n-                let t = tpt.params[i];\n-                demand_kind(tcx, e.span, t, k_need,\n-                            #fmt(\"typaram %d\", i));\n-                i += 1;\n-            }\n-        }\n-      }\n-      ast::expr_unary(op, a) {\n-        alt op {\n-          ast::box(_) {\n-            need_shared_or_pinned_ctor(tcx, a, \"'@' operand\");\n-          }\n-          ast::uniq(_) {\n-            need_shared_or_pinned_ctor(tcx, a, \"'~' operand\");\n-          }\n-          _ { /* fall through */ }\n-        }\n-      }\n-      ast::expr_rec(fields, _) {\n-        for field in fields {\n-            need_shared_or_pinned_ctor(tcx, field.node.expr, \"record field\");\n-        }\n-      }\n-      ast::expr_tup(exprs) {\n-        for expr in exprs {\n-            need_shared_or_pinned_ctor(tcx, expr, \"tuple parameter\");\n-        }\n-      }\n-      ast::expr_vec(exprs, _) {\n-        // Putting pinned things into vectors is pretty useless since vector\n-        // addition can't work (it's a copy)\n-        for expr in exprs {\n-            need_expr_kind(tcx, expr, ast::kind_shared, \"vector element\");\n-        }\n-      }\n-      _ { }\n-    }\n-}\n-\n-fn check_stmt(tcx: ty::ctxt, stmt: @ast::stmt) {\n-    alt stmt.node {\n-      ast::stmt_decl(@{node: ast::decl_local(locals), _}, _) {\n-        for (let_style, local) in locals {\n-            alt local.node.init {\n-              option::some({op: ast::init_assign., expr}) {\n-                need_shared_or_pinned_ctor(tcx, expr,\n-                                           \"local initializer\");\n-              }\n-              option::some({op: ast::init_move., expr}) {\n-                need_shared_or_pinned_ctor(tcx, expr,\n-                                           \"local initializer\");\n-              }\n-              option::none. { /* fall through */ }\n-            }\n-        }\n-      }\n-      _ { /* fall through */ }\n-    }\n-}\n-*/\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "1f8218346306a3ebcb8a6393e6cf95b7ed2b3bbb", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c97fcbf6689d8d4f466cdea80369ae057a4523e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c97fcbf6689d8d4f466cdea80369ae057a4523e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0c97fcbf6689d8d4f466cdea80369ae057a4523e", "patch": "@@ -4079,7 +4079,7 @@ fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n \n // Call this to compile an expression that you need as an intermediate value,\n // and you want to know whether you're dealing with an lval or not (the kind\n-// field in the returned struct). For non-immediates, use trans_expr or\n+// field in the returned struct). For non-intermediates, use trans_expr or\n // trans_expr_save_in. For intermediates where you don't care about lval-ness,\n // use trans_temp_expr.\n fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {"}, {"sha": "dc7394f057177d42b41bbd291ecc335af1727387", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c97fcbf6689d8d4f466cdea80369ae057a4523e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c97fcbf6689d8d4f466cdea80369ae057a4523e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=0c97fcbf6689d8d4f466cdea80369ae057a4523e", "patch": "@@ -1143,7 +1143,7 @@ fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n           }\n           _ { false }\n         };\n-    }) && type_kind(cx, t) != ast::kind_noncopyable;\n+    }) && type_kind(cx, ty) != ast::kind_noncopyable;\n }\n \n fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {"}]}