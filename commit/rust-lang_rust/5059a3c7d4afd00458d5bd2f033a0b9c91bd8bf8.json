{"sha": "5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNTlhM2M3ZDRhZmQwMDQ1OGQ1YmQyZjAzM2EwYjljOTFiZDhiZjg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-09-04T16:44:58Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-31T18:00:15Z"}, "message": "rustc_codegen_ssa: move debuginfo-related things to a new mir::debuginfo module.", "tree": {"sha": "f42d86de1d8add544f96070b711f7132c1007fa2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f42d86de1d8add544f96070b711f7132c1007fa2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "html_url": "https://github.com/rust-lang/rust/commit/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92df638162b7ccea6f97a8e1287ed05c5c0818b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/92df638162b7ccea6f97a8e1287ed05c5c0818b4", "html_url": "https://github.com/rust-lang/rust/commit/92df638162b7ccea6f97a8e1287ed05c5c0818b4"}], "stats": {"total": 321, "additions": 165, "deletions": 156}, "files": [{"sha": "abd6827680e06ae129a7d759e351d777311d870a", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "patch": "@@ -1,4 +1,4 @@\n-use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, FunctionDebugContextData, MirDebugScope};\n+use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, FunctionDebugContextData, DebugScope};\n use super::metadata::file_metadata;\n use super::utils::{DIB, span_start};\n \n@@ -22,8 +22,8 @@ pub fn create_mir_scopes(\n     cx: &CodegenCx<'ll, '_>,\n     mir: &Body<'_>,\n     debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n-) -> IndexVec<SourceScope, MirDebugScope<&'ll DIScope>> {\n-    let null_scope = MirDebugScope {\n+) -> IndexVec<SourceScope, DebugScope<&'ll DIScope>> {\n+    let null_scope = DebugScope {\n         scope_metadata: None,\n         file_start_pos: BytePos(0),\n         file_end_pos: BytePos(0)\n@@ -59,7 +59,7 @@ fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n                   has_variables: &BitSet<SourceScope>,\n                   debug_context: &FunctionDebugContextData<&'ll DISubprogram>,\n                   scope: SourceScope,\n-                  scopes: &mut IndexVec<SourceScope, MirDebugScope<&'ll DIScope>>) {\n+                  scopes: &mut IndexVec<SourceScope, DebugScope<&'ll DIScope>>) {\n     if scopes[scope].is_valid() {\n         return;\n     }\n@@ -71,7 +71,7 @@ fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n     } else {\n         // The root is the function itself.\n         let loc = span_start(cx, mir.span);\n-        scopes[scope] = MirDebugScope {\n+        scopes[scope] = DebugScope {\n             scope_metadata: Some(debug_context.fn_metadata),\n             file_start_pos: loc.file.start_pos,\n             file_end_pos: loc.file.end_pos,\n@@ -105,7 +105,7 @@ fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n             loc.line as c_uint,\n             loc.col.to_usize() as c_uint))\n     };\n-    scopes[scope] = MirDebugScope {\n+    scopes[scope] = DebugScope {\n         scope_metadata,\n         file_start_pos: loc.file.start_pos,\n         file_end_pos: loc.file.end_pos,"}, {"sha": "d7706b3251bb0a7d20ea23ac21060a6a7c89db65", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "patch": "@@ -1,8 +1,8 @@\n // See doc.rs for documentation.\n mod doc;\n \n-use rustc_codegen_ssa::debuginfo::VariableAccess::*;\n-use rustc_codegen_ssa::debuginfo::VariableKind::*;\n+use rustc_codegen_ssa::mir::debuginfo::VariableAccess::*;\n+use rustc_codegen_ssa::mir::debuginfo::VariableKind::*;\n \n use self::utils::{DIB, span_start, create_DIArray, is_node_local_to_unit};\n use self::namespace::mangled_name_of_instance;\n@@ -27,8 +27,9 @@ use rustc::session::config::{self, DebugInfo};\n use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_index::vec::IndexVec;\n-use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, MirDebugScope, VariableAccess,\n-    VariableKind, FunctionDebugContextData, type_names};\n+use rustc_codegen_ssa::debuginfo::type_names;\n+use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, DebugScope, VariableAccess,\n+    VariableKind, FunctionDebugContextData};\n \n use libc::c_uint;\n use std::cell::RefCell;\n@@ -553,7 +554,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         &self,\n         mir: &mir::Body<'_>,\n         debug_context: &mut FunctionDebugContext<&'ll DISubprogram>,\n-    ) -> IndexVec<mir::SourceScope, MirDebugScope<&'ll DIScope>> {\n+    ) -> IndexVec<mir::SourceScope, DebugScope<&'ll DIScope>> {\n         create_scope_map::create_mir_scopes(self, mir, debug_context)\n     }\n "}, {"sha": "014c1d285d28579deed123bdecd548d1bae7c40a", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "patch": "@@ -2,7 +2,7 @@ use self::InternalDebugLocation::*;\n \n use super::utils::{debug_context, span_start};\n use super::metadata::UNKNOWN_COLUMN_NUMBER;\n-use rustc_codegen_ssa::debuginfo::FunctionDebugContext;\n+use rustc_codegen_ssa::mir::debuginfo::FunctionDebugContext;\n \n use crate::llvm;\n use crate::llvm::debuginfo::DIScope;"}, {"sha": "d1a0cf78d6a2efdae2902abc19a32c78015fcf55", "filename": "src/librustc_codegen_ssa/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 81, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs?ref=5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "patch": "@@ -1,82 +1,2 @@\n-use syntax_pos::{BytePos, Span};\n-use rustc::hir::def_id::CrateNum;\n-\n+// FIXME(eddyb) find a place for this (or a way to replace it).\n pub mod type_names;\n-\n-pub enum FunctionDebugContext<D> {\n-    RegularContext(FunctionDebugContextData<D>),\n-    DebugInfoDisabled,\n-    FunctionWithoutDebugInfo,\n-}\n-\n-impl<D> FunctionDebugContext<D> {\n-    pub fn get_ref(&self, span: Span) -> &FunctionDebugContextData<D> {\n-        match *self {\n-            FunctionDebugContext::RegularContext(ref data) => data,\n-            FunctionDebugContext::DebugInfoDisabled => {\n-                span_bug!(\n-                    span,\n-                    \"debuginfo: Error trying to access FunctionDebugContext \\\n-                     although debug info is disabled!\",\n-                );\n-            }\n-            FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                span_bug!(\n-                    span,\n-                    \"debuginfo: Error trying to access FunctionDebugContext \\\n-                     for function that should be ignored by debug info!\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-/// Enables emitting source locations for the given functions.\n-///\n-/// Since we don't want source locations to be emitted for the function prelude,\n-/// they are disabled when beginning to codegen a new function. This functions\n-/// switches source location emitting on and must therefore be called before the\n-/// first real statement/expression of the function is codegened.\n-pub fn start_emitting_source_locations<D>(dbg_context: &mut FunctionDebugContext<D>) {\n-    match *dbg_context {\n-        FunctionDebugContext::RegularContext(ref mut data) => {\n-            data.source_locations_enabled = true;\n-        },\n-        _ => { /* safe to ignore */ }\n-    }\n-}\n-\n-pub struct FunctionDebugContextData<D> {\n-    pub fn_metadata: D,\n-    pub source_locations_enabled: bool,\n-    pub defining_crate: CrateNum,\n-}\n-\n-pub enum VariableAccess<'a, V> {\n-    // The llptr given is an alloca containing the variable's value\n-    DirectVariable { alloca: V },\n-    // The llptr given is an alloca containing the start of some pointer chain\n-    // leading to the variable's content.\n-    IndirectVariable { alloca: V, address_operations: &'a [i64] }\n-}\n-\n-pub enum VariableKind {\n-    ArgumentVariable(usize /*index*/),\n-    LocalVariable,\n-}\n-\n-\n-#[derive(Clone, Copy, Debug)]\n-pub struct MirDebugScope<D> {\n-    pub scope_metadata: Option<D>,\n-    // Start and end offsets of the file to which this DIScope belongs.\n-    // These are used to quickly determine whether some span refers to the same file.\n-    pub file_start_pos: BytePos,\n-    pub file_end_pos: BytePos,\n-}\n-\n-impl<D> MirDebugScope<D> {\n-    pub fn is_valid(&self) -> bool {\n-        !self.scope_metadata.is_none()\n-    }\n-}"}, {"sha": "a253523f18120530ceb17cdcbdf138ac1c69c432", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "patch": "@@ -0,0 +1,145 @@\n+use rustc::hir::def_id::CrateNum;\n+use rustc::mir;\n+use crate::traits::*;\n+\n+use syntax_pos::{DUMMY_SP, BytePos, Span};\n+\n+use super::FunctionCx;\n+\n+pub enum FunctionDebugContext<D> {\n+    RegularContext(FunctionDebugContextData<D>),\n+    DebugInfoDisabled,\n+    FunctionWithoutDebugInfo,\n+}\n+\n+impl<D> FunctionDebugContext<D> {\n+    pub fn get_ref(&self, span: Span) -> &FunctionDebugContextData<D> {\n+        match *self {\n+            FunctionDebugContext::RegularContext(ref data) => data,\n+            FunctionDebugContext::DebugInfoDisabled => {\n+                span_bug!(\n+                    span,\n+                    \"debuginfo: Error trying to access FunctionDebugContext \\\n+                     although debug info is disabled!\",\n+                );\n+            }\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n+                span_bug!(\n+                    span,\n+                    \"debuginfo: Error trying to access FunctionDebugContext \\\n+                     for function that should be ignored by debug info!\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Enables emitting source locations for the given functions.\n+///\n+/// Since we don't want source locations to be emitted for the function prelude,\n+/// they are disabled when beginning to codegen a new function. This functions\n+/// switches source location emitting on and must therefore be called before the\n+/// first real statement/expression of the function is codegened.\n+pub fn start_emitting_source_locations<D>(dbg_context: &mut FunctionDebugContext<D>) {\n+    match *dbg_context {\n+        FunctionDebugContext::RegularContext(ref mut data) => {\n+            data.source_locations_enabled = true;\n+        },\n+        _ => { /* safe to ignore */ }\n+    }\n+}\n+\n+pub struct FunctionDebugContextData<D> {\n+    pub fn_metadata: D,\n+    pub source_locations_enabled: bool,\n+    pub defining_crate: CrateNum,\n+}\n+\n+pub enum VariableAccess<'a, V> {\n+    // The llptr given is an alloca containing the variable's value\n+    DirectVariable { alloca: V },\n+    // The llptr given is an alloca containing the start of some pointer chain\n+    // leading to the variable's content.\n+    IndirectVariable { alloca: V, address_operations: &'a [i64] }\n+}\n+\n+pub enum VariableKind {\n+    ArgumentVariable(usize /*index*/),\n+    LocalVariable,\n+}\n+\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct DebugScope<D> {\n+    pub scope_metadata: Option<D>,\n+    // Start and end offsets of the file to which this DIScope belongs.\n+    // These are used to quickly determine whether some span refers to the same file.\n+    pub file_start_pos: BytePos,\n+    pub file_end_pos: BytePos,\n+}\n+\n+impl<D> DebugScope<D> {\n+    pub fn is_valid(&self) -> bool {\n+        !self.scope_metadata.is_none()\n+    }\n+}\n+\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn set_debug_loc(\n+        &mut self,\n+        bx: &mut Bx,\n+        source_info: mir::SourceInfo\n+    ) {\n+        let (scope, span) = self.debug_loc(source_info);\n+        bx.set_source_location(&mut self.debug_context, scope, span);\n+    }\n+\n+    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> (Option<Bx::DIScope>, Span) {\n+        // Bail out if debug info emission is not enabled.\n+        match self.debug_context {\n+            FunctionDebugContext::DebugInfoDisabled |\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n+                return (self.scopes[source_info.scope].scope_metadata, source_info.span);\n+            }\n+            FunctionDebugContext::RegularContext(_) =>{}\n+        }\n+\n+        // In order to have a good line stepping behavior in debugger, we overwrite debug\n+        // locations of macro expansions with that of the outermost expansion site\n+        // (unless the crate is being compiled with `-Z debug-macros`).\n+        if !source_info.span.from_expansion() ||\n+           self.cx.sess().opts.debugging_opts.debug_macros {\n+            let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n+            (scope, source_info.span)\n+        } else {\n+            // Walk up the macro expansion chain until we reach a non-expanded span.\n+            // We also stop at the function body level because no line stepping can occur\n+            // at the level above that.\n+            let span = syntax_pos::hygiene::walk_chain(source_info.span, self.mir.span.ctxt());\n+            let scope = self.scope_metadata_for_loc(source_info.scope, span.lo());\n+            // Use span of the outermost expansion site, while keeping the original lexical scope.\n+            (scope, span)\n+        }\n+    }\n+\n+    // DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n+    // it may so happen that the current span belongs to a different file than the DIScope\n+    // corresponding to span's containing source scope.  If so, we need to create a DIScope\n+    // \"extension\" into that file.\n+    fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n+                              -> Option<Bx::DIScope> {\n+        let scope_metadata = self.scopes[scope_id].scope_metadata;\n+        if pos < self.scopes[scope_id].file_start_pos ||\n+           pos >= self.scopes[scope_id].file_end_pos {\n+            let sm = self.cx.sess().source_map();\n+            let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n+            Some(self.cx.extend_scope_to_file(\n+                scope_metadata.unwrap(),\n+                &sm.lookup_char_pos(pos).file,\n+                defining_crate\n+            ))\n+        } else {\n+            scope_metadata\n+        }\n+    }\n+}"}, {"sha": "650584fbdf7bd95196fab0893f6843768a379640", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 61, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "patch": "@@ -5,10 +5,9 @@ use rustc::session::config::DebugInfo;\n use rustc_target::abi::call::{FnType, PassMode};\n use rustc_target::abi::{Variants, VariantIdx};\n use crate::base;\n-use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n use crate::traits::*;\n \n-use syntax_pos::{DUMMY_SP, BytePos, Span};\n+use syntax_pos::DUMMY_SP;\n use syntax::symbol::kw;\n \n use std::iter;\n@@ -17,6 +16,7 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n use self::analyze::CleanupKind;\n+use self::debuginfo::{VariableAccess, VariableKind, FunctionDebugContext};\n use self::place::PlaceRef;\n use rustc::mir::traversal;\n \n@@ -80,7 +80,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     locals: IndexVec<mir::Local, LocalRef<'tcx, Bx::Value>>,\n \n     /// Debug information for MIR scopes.\n-    scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<Bx::DIScope>>,\n+    scopes: IndexVec<mir::SourceScope, debuginfo::DebugScope<Bx::DIScope>>,\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -93,64 +93,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             value,\n         )\n     }\n-\n-    pub fn set_debug_loc(\n-        &mut self,\n-        bx: &mut Bx,\n-        source_info: mir::SourceInfo\n-    ) {\n-        let (scope, span) = self.debug_loc(source_info);\n-        bx.set_source_location(&mut self.debug_context, scope, span);\n-    }\n-\n-    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> (Option<Bx::DIScope>, Span) {\n-        // Bail out if debug info emission is not enabled.\n-        match self.debug_context {\n-            FunctionDebugContext::DebugInfoDisabled |\n-            FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                return (self.scopes[source_info.scope].scope_metadata, source_info.span);\n-            }\n-            FunctionDebugContext::RegularContext(_) =>{}\n-        }\n-\n-        // In order to have a good line stepping behavior in debugger, we overwrite debug\n-        // locations of macro expansions with that of the outermost expansion site\n-        // (unless the crate is being compiled with `-Z debug-macros`).\n-        if !source_info.span.from_expansion() ||\n-           self.cx.sess().opts.debugging_opts.debug_macros {\n-            let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n-            (scope, source_info.span)\n-        } else {\n-            // Walk up the macro expansion chain until we reach a non-expanded span.\n-            // We also stop at the function body level because no line stepping can occur\n-            // at the level above that.\n-            let span = syntax_pos::hygiene::walk_chain(source_info.span, self.mir.span.ctxt());\n-            let scope = self.scope_metadata_for_loc(source_info.scope, span.lo());\n-            // Use span of the outermost expansion site, while keeping the original lexical scope.\n-            (scope, span)\n-        }\n-    }\n-\n-    // DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n-    // it may so happen that the current span belongs to a different file than the DIScope\n-    // corresponding to span's containing source scope.  If so, we need to create a DIScope\n-    // \"extension\" into that file.\n-    fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n-                              -> Option<Bx::DIScope> {\n-        let scope_metadata = self.scopes[scope_id].scope_metadata;\n-        if pos < self.scopes[scope_id].file_start_pos ||\n-           pos >= self.scopes[scope_id].file_end_pos {\n-            let sm = self.cx.sess().source_map();\n-            let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n-            Some(self.cx.extend_scope_to_file(\n-                scope_metadata.unwrap(),\n-                &sm.lookup_char_pos(pos).file,\n-                defining_crate\n-            ))\n-        } else {\n-            scope_metadata\n-        }\n-    }\n }\n \n enum LocalRef<'tcx, V> {\n@@ -721,6 +663,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n mod analyze;\n mod block;\n pub mod constant;\n+pub mod debuginfo;\n pub mod place;\n pub mod operand;\n mod rvalue;"}, {"sha": "244fe845d7ddf992690e494233dc320aed8b53c7", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=5059a3c7d4afd00458d5bd2f033a0b9c91bd8bf8", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use crate::debuginfo::{FunctionDebugContext, MirDebugScope, VariableAccess, VariableKind};\n+use crate::mir::debuginfo::{FunctionDebugContext, DebugScope, VariableAccess, VariableKind};\n use rustc::hir::def_id::CrateNum;\n use rustc::mir;\n use rustc::ty::{self, Ty, Instance};\n@@ -28,7 +28,7 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         &self,\n         mir: &mir::Body<'_>,\n         debug_context: &mut FunctionDebugContext<Self::DIScope>,\n-    ) -> IndexVec<mir::SourceScope, MirDebugScope<Self::DIScope>>;\n+    ) -> IndexVec<mir::SourceScope, DebugScope<Self::DIScope>>;\n     fn extend_scope_to_file(\n         &self,\n         scope_metadata: Self::DIScope,"}]}