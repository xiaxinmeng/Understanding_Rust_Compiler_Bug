{"sha": "6d9184609a6edb54eb06f402dedcbc8f13da3d1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkOTE4NDYwOWE2ZWRiNTRlYjA2ZjQwMmRlZGNiYzhmMTNkYTNkMWE=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-15T18:08:25Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:08:58Z"}, "message": "(cleanup) Don't check taskgroup generation monotonicity unless cfg(test).", "tree": {"sha": "6bf9835a612ecd51cb419b9804d8b146b31874ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bf9835a612ecd51cb419b9804d8b146b31874ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d9184609a6edb54eb06f402dedcbc8f13da3d1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d9184609a6edb54eb06f402dedcbc8f13da3d1a", "html_url": "https://github.com/rust-lang/rust/commit/6d9184609a6edb54eb06f402dedcbc8f13da3d1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d9184609a6edb54eb06f402dedcbc8f13da3d1a/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87bbcb579a170f4d2c36df4370703075c81b0b5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/87bbcb579a170f4d2c36df4370703075c81b0b5d", "html_url": "https://github.com/rust-lang/rust/commit/87bbcb579a170f4d2c36df4370703075c81b0b5d"}], "stats": {"total": 32, "additions": 16, "deletions": 16}, "files": [{"sha": "477d386afb601910f9a2ba697a8d34e396e9276f", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6d9184609a6edb54eb06f402dedcbc8f13da3d1a/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d9184609a6edb54eb06f402dedcbc8f13da3d1a/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=6d9184609a6edb54eb06f402dedcbc8f13da3d1a", "patch": "@@ -176,7 +176,6 @@ struct AncestorNode {\n     // circular references arise, deadlock and memory leaks are imminent).\n     // Hence we assert that this counter monotonically decreases as we\n     // approach the tail of the list.\n-    // FIXME(#3068): Make the generation counter togglable with #[cfg(debug)].\n     generation:     uint,\n     // Handle to the tasks in the group of the current generation.\n     parent_group:   TaskGroupArc,\n@@ -202,6 +201,18 @@ fn access_ancestors<U>(x: &Exclusive<AncestorNode>,\n     }\n }\n \n+#[inline] #[cfg(test)]\n+fn check_generation(younger: uint, older: uint) { assert!(younger > older); }\n+#[inline] #[cfg(not(test))]\n+fn check_generation(_younger: uint, _older: uint) { }\n+\n+#[inline] #[cfg(test)]\n+fn incr_generation(ancestors: &AncestorList) -> uint {\n+    ancestors.map_default(0, |arc| access_ancestors(arc, |a| a.generation+1))\n+}\n+#[inline] #[cfg(not(test))]\n+fn incr_generation(_ancestors: &AncestorList) -> uint { 0 }\n+\n // Iterates over an ancestor list.\n // (1) Runs forward_blk on each ancestral taskgroup in the list\n // (2) If forward_blk \"break\"s, runs optional bail_blk on all ancestral\n@@ -264,7 +275,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                 // Argh, but we couldn't give it to coalesce() otherwise.\n                 let forward_blk = forward_blk.take();\n                 // Check monotonicity\n-                assert!(last_generation > nobe.generation);\n+                check_generation(last_generation, nobe.generation);\n                 /*##########################################################*\n                  * Step 1: Look at this ancestor group (call iterator block).\n                  *##########################################################*/\n@@ -594,16 +605,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 descendants: new_taskset(),\n             }));\n             let a = if supervised {\n-                // FIXME(#3068) - The generation counter is only used for a\n-                // debug assertion, but initialising it requires locking a\n-                // mutex. Hence it should be enabled only in debug builds.\n-                let new_generation =\n-                    match *ancestors {\n-                        Some(ref arc) => {\n-                            access_ancestors(arc, |a| a.generation+1)\n-                        }\n-                        None => 0 // the actual value doesn't really matter.\n-                    };\n+                let new_generation = incr_generation(&ancestors);\n                 assert!(new_generation < uint::max_value);\n                 // Child's ancestors start with the spawner.\n                 // Build a new node in the ancestor list.\n@@ -710,8 +712,7 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n         let child_data = Cell::new((child_tg, ancestors, f));\n         // Being killed with the unsafe task/closure pointers would leak them.\n         do unkillable {\n-            // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let (child_tg, ancestors, f) = child_data.take();\n+            let (child_tg, ancestors, f) = child_data.take(); // :(\n             // Create child task.\n             let new_task = match opts.sched.mode {\n                 DefaultScheduler => rt::new_task(),\n@@ -745,8 +746,7 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n                        -> ~fn() {\n         let child_data = Cell::new((notify_chan, child_arc, ancestors));\n         let result: ~fn() = || {\n-            // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let (notify_chan, child_arc, ancestors) = child_data.take();\n+            let (notify_chan, child_arc, ancestors) = child_data.take(); // :(\n             let mut ancestors = ancestors;\n             // Child task runs this code.\n "}]}