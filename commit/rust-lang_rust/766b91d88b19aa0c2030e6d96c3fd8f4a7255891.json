{"sha": "766b91d88b19aa0c2030e6d96c3fd8f4a7255891", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NmI5MWQ4OGIxOWFhMGMyMDMwZTZkOTZjM2ZkOGY0YTcyNTU4OTE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-17T21:13:58Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-17T21:48:00Z"}, "message": "Add support for a reserved-words list and reserve the various not-supported-but-plausible IEEE datatypes.", "tree": {"sha": "6a1d33f6a7fe4d4047c1eb25d8e876a713c6557d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a1d33f6a7fe4d4047c1eb25d8e876a713c6557d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/766b91d88b19aa0c2030e6d96c3fd8f4a7255891", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/766b91d88b19aa0c2030e6d96c3fd8f4a7255891", "html_url": "https://github.com/rust-lang/rust/commit/766b91d88b19aa0c2030e6d96c3fd8f4a7255891", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/766b91d88b19aa0c2030e6d96c3fd8f4a7255891/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "560d7b4983f60aad4a9c49dcd62f1b5d9b1d0b78", "url": "https://api.github.com/repos/rust-lang/rust/commits/560d7b4983f60aad4a9c49dcd62f1b5d9b1d0b78", "html_url": "https://github.com/rust-lang/rust/commit/560d7b4983f60aad4a9c49dcd62f1b5d9b1d0b78"}], "stats": {"total": 125, "additions": 108, "deletions": 17}, "files": [{"sha": "fcfb6499b50b6a002a4840bc46de90da3c5f72db", "filename": "doc/rust.texi", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/766b91d88b19aa0c2030e6d96c3fd8f4a7255891/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/766b91d88b19aa0c2030e6d96c3fd8f4a7255891/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=766b91d88b19aa0c2030e6d96c3fd8f4a7255891", "patch": "@@ -599,6 +599,7 @@ Unicode characters.\n * Ref.Lex.Ignore::       Ignored characters.\n * Ref.Lex.Ident::        Identifier tokens.\n * Ref.Lex.Key::          Keyword tokens.\n+* Ref.Lex.Res::          Reserved tokens.\n * Ref.Lex.Num::          Numeric tokens.\n * Ref.Lex.Text::         String and character tokens.\n * Ref.Lex.Syntax::       Syntactic extension tokens.\n@@ -636,7 +637,7 @@ token or a syntactic extension token.  Multi-line comments may be nested.\n Identifiers follow the pattern of C identifiers: they begin with a\n @emph{letter} or @emph{underscore}, and continue with any combination of\n @emph{letters}, @emph{decimal digits} and underscores, and must not be equal\n-to any keyword. @xref{Ref.Lex.Key}.\n+to any keyword or reserved token. @xref{Ref.Lex.Key}. @xref{Ref.Lex.Res}.\n \n A @emph{letter} is a Unicode character in the ranges U+0061-U+007A and\n U+0041-U+005A (@code{'a'}-@code{'z'} and @code{'A'}-@code{'Z'}).\n@@ -728,6 +729,35 @@ The keywords are:\n @tab @code{be}\n @end multitable\n \n+@node       Ref.Lex.Res\n+@subsection Ref.Lex.Res\n+@c * Ref.Lex.Res::                Reserved tokens.\n+\n+The reserved tokens are:\n+@cindex Reserved\n+\n+@sp 2\n+\n+@multitable @columnfractions .15 .15 .15 .15 .15\n+@item @code{f16}\n+@tab @code{f80}\n+@tab @code{f128}\n+@item @code{m32}\n+@tab @code{m64}\n+@tab @code{m128}\n+@tab @code{dec}\n+@end multitable\n+\n+@sp 2\n+\n+At present these tokens have no defined meaning in the Rust language.\n+\n+These tokens may correspond, in some current or future implementation,\n+to additional built-in types for decimal floating-point, extended\n+binary and interchange floating-point formats, as defined in the IEEE\n+754-1985 and IEEE 754-2008 specifications.\n+\n+\n @node       Ref.Lex.Num\n @subsection Ref.Lex.Num\n @c * Ref.Lex.Num::                 Numeric tokens.\n@@ -785,6 +815,10 @@ only two floating-point suffixes: @code{f32} and @code{f64}. Each of these\n gives the floating point literal the associated type, rather than\n @code{float}.\n \n+A set of suffixes are also reserved to accommodate literal support for\n+types corresponding to reserved tokens. The reserved suffixes are @code{f16},\n+@code{f80}, @code{f128}, @code{m}, @code{m32}, @code{m64} and @code{m128}.\n+\n @sp 1\n A @dfn{hex digit} is either a @emph{decimal digit} or else a character in the\n ranges U+0061-U+0066 and U+0041-U+0046 (@code{'a'}-@code{'f'},\n@@ -2024,7 +2058,7 @@ The signed two's complement word types @code{i8}, @code{i16}, @code{i32} and\n @end ifhtml\n  respectively.\n @item\n-The IEEE 754 single-precision and double-precision floating-point types:\n+The IEEE 754-2008 @code{binary32} and @code{binary64} floating-point types:\n @code{f32} and @code{f64}, respectively.\n @end itemize\n "}, {"sha": "af8eab6a7c6cda2786f58a40778867fd5af78970", "filename": "src/boot/fe/lexer.mll", "status": "modified", "additions": 72, "deletions": 15, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/766b91d88b19aa0c2030e6d96c3fd8f4a7255891/src%2Fboot%2Ffe%2Flexer.mll", "raw_url": "https://github.com/rust-lang/rust/raw/766b91d88b19aa0c2030e6d96c3fd8f4a7255891/src%2Fboot%2Ffe%2Flexer.mll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Flexer.mll?ref=766b91d88b19aa0c2030e6d96c3fd8f4a7255891", "patch": "@@ -27,8 +27,12 @@\n     <- (bump_line lexbuf.Lexing.lex_curr_p)\n   ;;\n \n-  let mach_suf_table = Hashtbl.create 0\n+  let mach_suf_table = Hashtbl.create 10\n   ;;\n+\n+  let reserved_suf_table = Hashtbl.create 10\n+  ;;\n+\n   let _ =\n     List.iter (fun (suf, ty) -> Common.htab_put mach_suf_table suf ty)\n       [ (\"u8\", Common.TY_u8);\n@@ -43,8 +47,24 @@\n         (\"f64\", Common.TY_f64); ]\n   ;;\n \n+  let _ =\n+    List.iter (fun suf -> Common.htab_put reserved_suf_table suf ())\n+      [ \"f16\";  (* IEEE 754-2008 'binary16' interchange format. *)\n+        \"f80\";  (* IEEE 754-1985 'extended'   *)\n+        \"f128\"; (* IEEE 754-2008 'binary128'  *)\n+        \"m32\";  (* IEEE 754-2008 'decimal32'  *)\n+        \"m64\";  (* IEEE 754-2008 'decimal64'  *)\n+        \"m128\"; (* IEEE 754-2008 'decimal128' *)\n+        \"m\";  (* One of m32, m64, m128.     *)\n+      ]\n+  ;;\n+\n   let keyword_table = Hashtbl.create 100\n   ;;\n+\n+  let reserved_table = Hashtbl.create 10\n+  ;;\n+\n   let _ =\n     List.iter (fun (kwd, tok) -> Common.htab_put keyword_table kwd tok)\n               [ (\"mod\", MOD);\n@@ -141,6 +161,19 @@\n                 (\"f64\", MACH TY_f64)\n               ]\n ;;\n+\n+  let _ =\n+    List.iter (fun kwd -> Common.htab_put reserved_table kwd ())\n+              [ \"f16\";  (* IEEE 754-2008 'binary16' interchange format. *)\n+                \"f80\";  (* IEEE 754-1985 'extended'   *)\n+                \"f128\"; (* IEEE 754-2008 'binary128'  *)\n+                \"m32\";  (* IEEE 754-2008 'decimal32'  *)\n+                \"m64\";  (* IEEE 754-2008 'decimal64'  *)\n+                \"m128\"; (* IEEE 754-2008 'decimal128' *)\n+                \"dec\";  (* One of m32, m64, m128.     *)\n+              ];\n+  ;;\n+\n }\n \n let hexdig = ['0'-'9' 'a'-'f' 'A'-'F']\n@@ -153,6 +186,7 @@ let flo = (dec '.' dec (exp?)) | (dec exp)\n \n let mach_float_suf = \"f32\"|\"f64\"\n let mach_int_suf = ['u''i']('8'|\"16\"|\"32\"|\"64\")\n+let flo_suf = ['m''f'](\"16\"|\"32\"|\"64\"|\"80\"|\"128\")\n \n let ws = [ ' ' '\\t' '\\r' ]\n \n@@ -218,26 +252,39 @@ rule token = parse\n | ']'                          { RBRACKET   }\n \n | id as i\n-                               { try\n-                                     Hashtbl.find keyword_table i\n-                                 with\n-                                     Not_found -> IDENT (i)        }\n+    {\n+      match Common.htab_search keyword_table i with\n+          Some tok -> tok\n+        | None ->\n+            if Hashtbl.mem reserved_table i\n+            then fail lexbuf \"reserved keyword\"\n+            else IDENT (i)\n+    }\n \n | (bin|hex|dec) as n           { LIT_INT (Int64.of_string n)       }\n | ((bin|hex|dec) as n) 'u'     { LIT_UINT (Int64.of_string n)      }\n | ((bin|hex|dec) as n)\n-  (mach_int_suf as s)          { try\n-                                   let tm =\n-                                     Hashtbl.find mach_suf_table s\n-                                   in\n-                                     LIT_MACH_INT\n-                                       (tm, Int64.of_string n)\n-                                 with\n-                                     Not_found ->\n-                                       fail lexbuf\n-                                         \"bad mach-int suffix\"     }\n+  (mach_int_suf as s)\n+  {\n+    match Common.htab_search mach_suf_table s with\n+        Some tm -> LIT_MACH_INT (tm, Int64.of_string n)\n+      | None ->\n+          if Hashtbl.mem reserved_suf_table s\n+          then fail lexbuf \"reserved mach-int suffix\"\n+          else fail lexbuf \"bad mach-int suffix\"\n+  }\n \n | flo as n                     { LIT_FLOAT (float_of_string n)     }\n+| flo 'm'                      { fail lexbuf \"reseved mach-float suffix\" }\n+| (flo as n) (flo_suf as s)\n+  {\n+    match Common.htab_search mach_suf_table s with\n+        Some tm -> LIT_MACH_FLOAT (tm, float_of_string n)\n+      | None ->\n+          if Hashtbl.mem reserved_suf_table s\n+          then fail lexbuf \"reserved mach-float suffix\"\n+          else fail lexbuf \"bad mach-float suffix\"\n+  }\n \n | '\\''                         { char lexbuf                       }\n | '\"'                          { let buf = Buffer.create 32 in\n@@ -411,3 +458,13 @@ and comment depth = parse\n                                   comment depth lexbuf           }\n \n | _                             { comment depth lexbuf           }\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}]}