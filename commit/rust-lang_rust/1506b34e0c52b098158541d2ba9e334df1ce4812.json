{"sha": "1506b34e0c52b098158541d2ba9e334df1ce4812", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MDZiMzRlMGM1MmIwOTgxNTg1NDFkMmJhOWUzMzRkZjFjZTQ4MTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T23:52:01Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T23:52:01Z"}, "message": "rollup merge of #22286: nikomatsakis/variance-4b\n\nConflicts:\n\tsrc/librustc/middle/infer/combine.rs\n\tsrc/librustc_typeck/check/wf.rs", "tree": {"sha": "a9ead87eacaf0acafdb0c4f72c334c2d5601b0ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9ead87eacaf0acafdb0c4f72c334c2d5601b0ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1506b34e0c52b098158541d2ba9e334df1ce4812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1506b34e0c52b098158541d2ba9e334df1ce4812", "html_url": "https://github.com/rust-lang/rust/commit/1506b34e0c52b098158541d2ba9e334df1ce4812", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1506b34e0c52b098158541d2ba9e334df1ce4812/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e7a04cb3cac2b803dc8188d9a55ba1836404ea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3", "html_url": "https://github.com/rust-lang/rust/commit/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3"}, {"sha": "9f8b9d6847ab02f7f1c28c84988ceae4c0a10f26", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f8b9d6847ab02f7f1c28c84988ceae4c0a10f26", "html_url": "https://github.com/rust-lang/rust/commit/9f8b9d6847ab02f7f1c28c84988ceae4c0a10f26"}], "stats": {"total": 4654, "additions": 3307, "deletions": 1347}, "files": [{"sha": "db940947040d48f41c4811bb46c4aca7e8ae1244", "filename": "src/doc/reference.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -572,7 +572,7 @@ the final namespace qualifier is omitted.\n Two examples of paths with type arguments:\n \n ```\n-# struct HashMap<K, V>;\n+# struct HashMap<K, V>(K,V);\n # fn f() {\n # fn id<T>(t: T) -> T { t }\n type T = HashMap<i32,String>; // Type arguments used in a type expression\n@@ -1599,7 +1599,7 @@ pointer values (pointing to a type for which an implementation of the given\n trait is in scope) to pointers to the trait name, used as a type.\n \n ```\n-# trait Shape { }\n+# trait Shape { fn dummy(&self) { } }\n # impl Shape for i32 { }\n # let mycircle = 0i32;\n let myshape: Box<Shape> = Box::new(mycircle) as Box<Shape>;\n@@ -1630,8 +1630,8 @@ let x: f64 = Num::from_i32(42);\n Traits may inherit from other traits. For example, in\n \n ```\n-trait Shape { fn area() -> f64; }\n-trait Circle : Shape { fn radius() -> f64; }\n+trait Shape { fn area(&self) -> f64; }\n+trait Circle : Shape { fn radius(&self) -> f64; }\n ```\n \n the syntax `Circle : Shape` means that types that implement `Circle` must also\n@@ -1725,7 +1725,7 @@ type parameters taken by the trait it implements. Implementation parameters\n are written after the `impl` keyword.\n \n ```\n-# trait Seq<T> { }\n+# trait Seq<T> { fn dummy(&self, _: T) { } }\n impl<T> Seq<T> for Vec<T> {\n    /* ... */\n }"}, {"sha": "b43f9adfb26d92ed9c8f8f4ee8df7bc634c0cb46", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -96,7 +96,7 @@ pub struct Arena<'longer_than_self> {\n     head: RefCell<Chunk>,\n     copy_head: RefCell<Chunk>,\n     chunks: RefCell<Vec<Chunk>>,\n-    _invariant: marker::InvariantLifetime<'longer_than_self>,\n+    _marker: marker::PhantomData<*mut &'longer_than_self()>,\n }\n \n impl<'a> Arena<'a> {\n@@ -111,7 +111,7 @@ impl<'a> Arena<'a> {\n             head: RefCell::new(chunk(initial_size, false)),\n             copy_head: RefCell::new(chunk(initial_size, true)),\n             chunks: RefCell::new(Vec::new()),\n-            _invariant: marker::InvariantLifetime,\n+            _marker: marker::PhantomData,\n         }\n     }\n }\n@@ -361,6 +361,8 @@ pub struct TypedArena<T> {\n }\n \n struct TypedArenaChunk<T> {\n+    marker: marker::PhantomData<T>,\n+\n     /// Pointer to the next arena segment.\n     next: *mut TypedArenaChunk<T>,\n "}, {"sha": "7823f536c7a213a8f5f3b2b8e0c7a6a6fad81c73", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -512,13 +512,22 @@ mod stack {\n     use super::super::node::handle;\n     use vec::Vec;\n \n+    struct InvariantLifetime<'id>(\n+        marker::PhantomData<::core::cell::Cell<&'id ()>>);\n+\n+    impl<'id> InvariantLifetime<'id> {\n+        fn new() -> InvariantLifetime<'id> {\n+            InvariantLifetime(marker::PhantomData)\n+        }\n+    }\n+\n     /// A generic mutable reference, identical to `&mut` except for the fact that its lifetime\n     /// parameter is invariant. This means that wherever an `IdRef` is expected, only an `IdRef`\n     /// with the exact requested lifetime can be used. This is in contrast to normal references,\n     /// where `&'static` can be used in any function expecting any lifetime reference.\n     pub struct IdRef<'id, T: 'id> {\n         inner: &'id mut T,\n-        marker: marker::InvariantLifetime<'id>\n+        _marker: InvariantLifetime<'id>,\n     }\n \n     impl<'id, T> Deref for IdRef<'id, T> {\n@@ -560,7 +569,7 @@ mod stack {\n     pub struct Pusher<'id, 'a, K:'a, V:'a> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n-        marker: marker::InvariantLifetime<'id>\n+        _marker: InvariantLifetime<'id>,\n     }\n \n     impl<'a, K, V> PartialSearchStack<'a, K, V> {\n@@ -595,11 +604,11 @@ mod stack {\n             let pusher = Pusher {\n                 map: self.map,\n                 stack: self.stack,\n-                marker: marker::InvariantLifetime\n+                _marker: InvariantLifetime::new(),\n             };\n             let node = IdRef {\n                 inner: unsafe { &mut *self.next },\n-                marker: marker::InvariantLifetime\n+                _marker: InvariantLifetime::new(),\n             };\n \n             closure(pusher, node)"}, {"sha": "f0fc12da7275e000d814d796db75a0f58c2a48f2", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 52, "deletions": 32, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -20,10 +20,11 @@ use core::prelude::*;\n \n use core::cmp::Ordering::{Greater, Less, Equal};\n use core::iter::Zip;\n+use core::marker::PhantomData;\n use core::ops::{Deref, DerefMut, Index, IndexMut};\n use core::ptr::Unique;\n use core::{slice, mem, ptr, cmp, num, raw};\n-use alloc::heap;\n+use alloc::heap::{self, EMPTY};\n \n use borrow::Borrow;\n \n@@ -58,8 +59,8 @@ pub struct Node<K, V> {\n     keys: Unique<K>,\n     vals: Unique<V>,\n \n-    // In leaf nodes, this will be null, and no space will be allocated for edges.\n-    edges: Unique<Node<K, V>>,\n+    // In leaf nodes, this will be None, and no space will be allocated for edges.\n+    edges: Option<Unique<Node<K, V>>>,\n \n     // At any given time, there will be `_len` keys, `_len` values, and (in an internal node)\n     // `_len + 1` edges. In a leaf node, there will never be any edges.\n@@ -279,8 +280,11 @@ impl<T> Drop for RawItems<T> {\n #[unsafe_destructor]\n impl<K, V> Drop for Node<K, V> {\n     fn drop(&mut self) {\n-        if self.keys.ptr.is_null() {\n-            // We have already cleaned up this node.\n+        if self.keys.is_null() {\n+            // Since we have #[unsafe_no_drop_flag], we have to watch\n+            // out for a null value being stored in self.keys. (Using\n+            // null is technically a violation of the `Unique`\n+            // requirements, though.)\n             return;\n         }\n \n@@ -293,7 +297,7 @@ impl<K, V> Drop for Node<K, V> {\n             self.destroy();\n         }\n \n-        self.keys.ptr = ptr::null_mut();\n+        self.keys = unsafe { Unique::new(0 as *mut K) };\n     }\n }\n \n@@ -309,9 +313,9 @@ impl<K, V> Node<K, V> {\n         let (vals_offset, edges_offset) = calculate_offsets_generic::<K, V>(capacity, false);\n \n         Node {\n-            keys: Unique(buffer as *mut K),\n-            vals: Unique(buffer.offset(vals_offset as isize) as *mut V),\n-            edges: Unique(buffer.offset(edges_offset as isize) as *mut Node<K, V>),\n+            keys: Unique::new(buffer as *mut K),\n+            vals: Unique::new(buffer.offset(vals_offset as isize) as *mut V),\n+            edges: Some(Unique::new(buffer.offset(edges_offset as isize) as *mut Node<K, V>)),\n             _len: 0,\n             _capacity: capacity,\n         }\n@@ -327,9 +331,9 @@ impl<K, V> Node<K, V> {\n         let (vals_offset, _) = calculate_offsets_generic::<K, V>(capacity, true);\n \n         Node {\n-            keys: Unique(buffer as *mut K),\n-            vals: Unique(unsafe { buffer.offset(vals_offset as isize) as *mut V }),\n-            edges: Unique(ptr::null_mut()),\n+            keys: unsafe { Unique::new(buffer as *mut K) },\n+            vals: unsafe { Unique::new(buffer.offset(vals_offset as isize) as *mut V) },\n+            edges: None,\n             _len: 0,\n             _capacity: capacity,\n         }\n@@ -338,18 +342,18 @@ impl<K, V> Node<K, V> {\n     unsafe fn destroy(&mut self) {\n         let (alignment, size) =\n                 calculate_allocation_generic::<K, V>(self.capacity(), self.is_leaf());\n-        heap::deallocate(self.keys.ptr as *mut u8, size, alignment);\n+        heap::deallocate(*self.keys as *mut u8, size, alignment);\n     }\n \n     #[inline]\n     pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n         unsafe {(\n             mem::transmute(raw::Slice {\n-                data: self.keys.ptr,\n+                data: *self.keys as *const K,\n                 len: self.len()\n             }),\n             mem::transmute(raw::Slice {\n-                data: self.vals.ptr,\n+                data: *self.vals as *const V,\n                 len: self.len()\n             })\n         )}\n@@ -368,8 +372,12 @@ impl<K, V> Node<K, V> {\n             &[]\n         } else {\n             unsafe {\n+                let data = match self.edges {\n+                    None => heap::EMPTY as *const Node<K,V>,\n+                    Some(ref p) => **p as *const Node<K,V>,\n+                };\n                 mem::transmute(raw::Slice {\n-                    data: self.edges.ptr,\n+                    data: data,\n                     len: self.len() + 1\n                 })\n             }\n@@ -525,7 +533,8 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n #[derive(Copy)]\n pub struct Handle<NodeRef, Type, NodeType> {\n     node: NodeRef,\n-    index: usize\n+    index: usize,\n+    marker: PhantomData<(Type, NodeType)>,\n }\n \n pub mod handle {\n@@ -549,8 +558,8 @@ impl<K: Ord, V> Node<K, V> {\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for usizes.\n         match node.as_slices_internal().search_linear(key) {\n-            (index, true) => Found(Handle { node: node, index: index }),\n-            (index, false) => GoDown(Handle { node: node, index: index }),\n+            (index, true) => Found(Handle { node: node, index: index, marker: PhantomData }),\n+            (index, false) => GoDown(Handle { node: node, index: index, marker: PhantomData }),\n         }\n     }\n }\n@@ -587,7 +596,7 @@ impl <K, V> Node<K, V> {\n \n     /// If the node has any children\n     pub fn is_leaf(&self) -> bool {\n-        self.edges.ptr.is_null()\n+        self.edges.is_none()\n     }\n \n     /// if the node has too few elements\n@@ -619,7 +628,8 @@ impl<K, V, NodeRef, Type, NodeType> Handle<NodeRef, Type, NodeType> where\n     pub fn as_raw(&mut self) -> Handle<*mut Node<K, V>, Type, NodeType> {\n         Handle {\n             node: &mut *self.node as *mut _,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -631,7 +641,8 @@ impl<K, V, Type, NodeType> Handle<*mut Node<K, V>, Type, NodeType> {\n     pub unsafe fn from_raw<'a>(&'a self) -> Handle<&'a Node<K, V>, Type, NodeType> {\n         Handle {\n             node: &*self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -641,7 +652,8 @@ impl<K, V, Type, NodeType> Handle<*mut Node<K, V>, Type, NodeType> {\n     pub unsafe fn from_raw_mut<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, Type, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -689,12 +701,14 @@ impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type> Handle<NodeRef, Type, handle\n         if self.node.is_leaf() {\n             Leaf(Handle {\n                 node: self.node,\n-                index: self.index\n+                index: self.index,\n+                marker: PhantomData,\n             })\n         } else {\n             Internal(Handle {\n                 node: self.node,\n-                index: self.index\n+                index: self.index,\n+                marker: PhantomData,\n             })\n         }\n     }\n@@ -827,7 +841,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType> where\n     unsafe fn left_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index - 1\n+            index: self.index - 1,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -837,7 +852,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType> where\n     unsafe fn right_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -877,7 +893,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n     pub fn into_left_edge(self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -927,7 +944,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n     pub fn left_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -936,7 +954,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n     pub fn right_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index + 1\n+            index: self.index + 1,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -1045,7 +1064,8 @@ impl<K, V> Node<K, V> {\n         debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n         Handle {\n             node: self,\n-            index: index\n+            index: index,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -1065,7 +1085,7 @@ impl<K, V> Node<K, V> {\n                     vals: RawItems::from_slice(self.vals()),\n                     edges: RawItems::from_slice(self.edges()),\n \n-                    ptr: self.keys.ptr as *mut u8,\n+                    ptr: *self.keys as *mut u8,\n                     capacity: self.capacity(),\n                     is_leaf: self.is_leaf()\n                 },"}, {"sha": "0c95742606083fbe33402ca667d840ed620c406c", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,6 +14,7 @@\n //! representation to hold C-like enum variants.\n \n use core::prelude::*;\n+use core::marker;\n use core::fmt;\n use core::num::Int;\n use core::iter::{FromIterator, IntoIterator};\n@@ -26,7 +27,8 @@ use core::ops::{Sub, BitOr, BitAnd, BitXor};\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists\n-    bits: usize\n+    bits: usize,\n+    marker: marker::PhantomData<E>,\n }\n \n impl<E> Copy for EnumSet<E> {}\n@@ -86,7 +88,7 @@ impl<E:CLike> EnumSet<E> {\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn new() -> EnumSet<E> {\n-        EnumSet {bits: 0}\n+        EnumSet {bits: 0, marker: marker::PhantomData}\n     }\n \n     /// Returns the number of elements in the given `EnumSet`.\n@@ -130,12 +132,14 @@ impl<E:CLike> EnumSet<E> {\n \n     /// Returns the union of both `EnumSets`.\n     pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits | e.bits}\n+        EnumSet {bits: self.bits | e.bits,\n+                 marker: marker::PhantomData}\n     }\n \n     /// Returns the intersection of both `EnumSets`.\n     pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits}\n+        EnumSet {bits: self.bits & e.bits,\n+                 marker: marker::PhantomData}\n     }\n \n     /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n@@ -175,38 +179,39 @@ impl<E:CLike> Sub for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & !e.bits}\n+        EnumSet {bits: self.bits & !e.bits, marker: marker::PhantomData}\n     }\n }\n \n impl<E:CLike> BitOr for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits | e.bits}\n+        EnumSet {bits: self.bits | e.bits, marker: marker::PhantomData}\n     }\n }\n \n impl<E:CLike> BitAnd for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits}\n+        EnumSet {bits: self.bits & e.bits, marker: marker::PhantomData}\n     }\n }\n \n impl<E:CLike> BitXor for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits ^ e.bits}\n+        EnumSet {bits: self.bits ^ e.bits, marker: marker::PhantomData}\n     }\n }\n \n /// An iterator over an EnumSet\n pub struct Iter<E> {\n     index: usize,\n     bits: usize,\n+    marker: marker::PhantomData<E>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -215,13 +220,14 @@ impl<E> Clone for Iter<E> {\n         Iter {\n             index: self.index,\n             bits: self.bits,\n+            marker: marker::PhantomData,\n         }\n     }\n }\n \n impl<E:CLike> Iter<E> {\n     fn new(bits: usize) -> Iter<E> {\n-        Iter { index: 0, bits: bits }\n+        Iter { index: 0, bits: bits, marker: marker::PhantomData }\n     }\n }\n "}, {"sha": "1cc2a5235abec1a1af6a5cfe6a7361a758d7910c", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -57,13 +57,13 @@ use core::fmt;\n use core::hash::{self, Hash};\n use core::intrinsics::assume;\n use core::iter::{repeat, FromIterator, IntoIterator};\n-use core::marker::{self, ContravariantLifetime, InvariantType};\n+use core::marker::PhantomData;\n use core::mem;\n-use core::nonzero::NonZero;\n use core::num::{Int, UnsignedInt};\n use core::ops::{Index, IndexMut, Deref, Add};\n use core::ops;\n use core::ptr;\n+use core::ptr::Unique;\n use core::raw::Slice as RawSlice;\n use core::slice;\n use core::usize;\n@@ -139,10 +139,9 @@ use borrow::{Cow, IntoCow};\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n-    ptr: NonZero<*mut T>,\n+    ptr: Unique<T>,\n     len: usize,\n     cap: usize,\n-    _own: marker::PhantomData<T>,\n }\n \n unsafe impl<T: Send> Send for Vec<T> { }\n@@ -251,10 +250,9 @@ impl<T> Vec<T> {\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: usize,\n                                  capacity: usize) -> Vec<T> {\n         Vec {\n-            ptr: NonZero::new(ptr),\n+            ptr: Unique::new(ptr),\n             len: length,\n             cap: capacity,\n-            _own: marker::PhantomData,\n         }\n     }\n \n@@ -375,7 +373,7 @@ impl<T> Vec<T> {\n                                      self.len * mem::size_of::<T>(),\n                                      mem::min_align_of::<T>()) as *mut T;\n                 if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n+                self.ptr = Unique::new(ptr);\n             }\n             self.cap = self.len;\n         }\n@@ -657,7 +655,7 @@ impl<T> Vec<T> {\n             unsafe {\n                 let ptr = alloc_or_realloc(*self.ptr, old_size, size);\n                 if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n+                self.ptr = Unique::new(ptr);\n             }\n             self.cap = max(self.cap, 2) * 2;\n         }\n@@ -758,7 +756,7 @@ impl<T> Vec<T> {\n             Drain {\n                 ptr: begin,\n                 end: end,\n-                marker: ContravariantLifetime,\n+                marker: PhantomData,\n             }\n         }\n     }\n@@ -873,6 +871,8 @@ impl<T> Vec<T> {\n                 end_t: unsafe { start.offset(offset) },\n                 start_u: start as *mut U,\n                 end_u: start as *mut U,\n+\n+                _marker: PhantomData,\n             };\n             //  start_t\n             //  start_u\n@@ -969,8 +969,7 @@ impl<T> Vec<T> {\n             let mut pv = PartialVecZeroSized::<T,U> {\n                 num_t: vec.len(),\n                 num_u: 0,\n-                marker_t: InvariantType,\n-                marker_u: InvariantType,\n+                marker: PhantomData,\n             };\n             unsafe { mem::forget(vec); }\n \n@@ -1228,7 +1227,7 @@ impl<T> Vec<T> {\n             unsafe {\n                 let ptr = alloc_or_realloc(*self.ptr, self.cap * mem::size_of::<T>(), size);\n                 if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n+                self.ptr = Unique::new(ptr);\n             }\n             self.cap = capacity;\n         }\n@@ -1795,10 +1794,10 @@ impl<T> Drop for IntoIter<T> {\n #[unsafe_no_drop_flag]\n #[unstable(feature = \"collections\",\n            reason = \"recently added as part of collections reform 2\")]\n-pub struct Drain<'a, T> {\n+pub struct Drain<'a, T:'a> {\n     ptr: *const T,\n     end: *const T,\n-    marker: ContravariantLifetime<'a>,\n+    marker: PhantomData<&'a T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1883,9 +1882,9 @@ impl<'a, T> Drop for Drain<'a, T> {\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n #[unstable(feature = \"collections\")]\n-pub struct DerefVec<'a, T> {\n+pub struct DerefVec<'a, T:'a> {\n     x: Vec<T>,\n-    l: ContravariantLifetime<'a>\n+    l: PhantomData<&'a T>,\n }\n \n #[unstable(feature = \"collections\")]\n@@ -1913,7 +1912,7 @@ pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {\n         DerefVec {\n             x: Vec::from_raw_parts(x.as_ptr() as *mut T, x.len(), x.len()),\n-            l: ContravariantLifetime::<'a>\n+            l: PhantomData,\n         }\n     }\n }\n@@ -1937,6 +1936,8 @@ struct PartialVecNonZeroSized<T,U> {\n     end_u: *mut U,\n     start_t: *mut T,\n     end_t: *mut T,\n+\n+    _marker: PhantomData<U>,\n }\n \n /// An owned, partially type-converted vector of zero-sized elements.\n@@ -1946,8 +1947,7 @@ struct PartialVecNonZeroSized<T,U> {\n struct PartialVecZeroSized<T,U> {\n     num_t: usize,\n     num_u: usize,\n-    marker_t: InvariantType<T>,\n-    marker_u: InvariantType<U>,\n+    marker: PhantomData<::core::cell::Cell<(T,U)>>,\n }\n \n #[unsafe_destructor]"}, {"sha": "3ba22a41ff74097d73626b926a0bcda8b971486e", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -28,7 +28,7 @@ use core::marker;\n use core::mem;\n use core::num::{Int, UnsignedInt};\n use core::ops::{Index, IndexMut};\n-use core::ptr;\n+use core::ptr::{self, Unique};\n use core::raw::Slice as RawSlice;\n \n use core::hash::{Hash, Hasher};\n@@ -57,7 +57,7 @@ pub struct VecDeque<T> {\n     tail: usize,\n     head: usize,\n     cap: usize,\n-    ptr: *mut T\n+    ptr: Unique<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -80,7 +80,7 @@ impl<T> Drop for VecDeque<T> {\n         self.clear();\n         unsafe {\n             if mem::size_of::<T>() != 0 {\n-                heap::deallocate(self.ptr as *mut u8,\n+                heap::deallocate(*self.ptr as *mut u8,\n                                  self.cap * mem::size_of::<T>(),\n                                  mem::min_align_of::<T>())\n             }\n@@ -98,13 +98,13 @@ impl<T> VecDeque<T> {\n     /// Turn ptr into a slice\n     #[inline]\n     unsafe fn buffer_as_slice(&self) -> &[T] {\n-        mem::transmute(RawSlice { data: self.ptr, len: self.cap })\n+        mem::transmute(RawSlice { data: *self.ptr as *const T, len: self.cap })\n     }\n \n     /// Turn ptr into a mut slice\n     #[inline]\n     unsafe fn buffer_as_mut_slice(&mut self) -> &mut [T] {\n-        mem::transmute(RawSlice { data: self.ptr, len: self.cap })\n+        mem::transmute(RawSlice { data: *self.ptr as *const T, len: self.cap })\n     }\n \n     /// Moves an element out of the buffer\n@@ -171,21 +171,21 @@ impl<T> VecDeque<T> {\n         let size = cap.checked_mul(mem::size_of::<T>())\n                       .expect(\"capacity overflow\");\n \n-        let ptr = if mem::size_of::<T>() != 0 {\n-            unsafe {\n+        let ptr = unsafe {\n+            if mem::size_of::<T>() != 0 {\n                 let ptr = heap::allocate(size, mem::min_align_of::<T>())  as *mut T;;\n                 if ptr.is_null() { ::alloc::oom() }\n-                ptr\n+                Unique::new(ptr)\n+            } else {\n+                Unique::new(heap::EMPTY as *mut T)\n             }\n-        } else {\n-            heap::EMPTY as *mut T\n         };\n \n         VecDeque {\n             tail: 0,\n             head: 0,\n             cap: cap,\n-            ptr: ptr\n+            ptr: ptr,\n         }\n     }\n \n@@ -341,11 +341,12 @@ impl<T> VecDeque<T> {\n                 let new = count.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n                 unsafe {\n-                    self.ptr = heap::reallocate(self.ptr as *mut u8,\n-                                                old,\n-                                                new,\n-                                                mem::min_align_of::<T>()) as *mut T;\n-                    if self.ptr.is_null() { ::alloc::oom() }\n+                    let ptr = heap::reallocate(*self.ptr as *mut u8,\n+                                               old,\n+                                               new,\n+                                               mem::min_align_of::<T>()) as *mut T;\n+                    if ptr.is_null() { ::alloc::oom() }\n+                    self.ptr = Unique::new(ptr);\n                 }\n             }\n \n@@ -459,11 +460,12 @@ impl<T> VecDeque<T> {\n                 let old = self.cap * mem::size_of::<T>();\n                 let new_size = target_cap * mem::size_of::<T>();\n                 unsafe {\n-                    self.ptr = heap::reallocate(self.ptr as *mut u8,\n-                                                old,\n-                                                new_size,\n-                                                mem::min_align_of::<T>()) as *mut T;\n-                    if self.ptr.is_null() { ::alloc::oom() }\n+                    let ptr = heap::reallocate(*self.ptr as *mut u8,\n+                                               old,\n+                                               new_size,\n+                                               mem::min_align_of::<T>()) as *mut T;\n+                    if ptr.is_null() { ::alloc::oom() }\n+                    self.ptr = Unique::new(ptr);\n                 }\n             }\n             self.cap = target_cap;\n@@ -545,8 +547,8 @@ impl<T> VecDeque<T> {\n             tail: self.tail,\n             head: self.head,\n             cap: self.cap,\n-            ptr: self.ptr,\n-            marker: marker::ContravariantLifetime,\n+            ptr: *self.ptr,\n+            marker: marker::PhantomData,\n         }\n     }\n \n@@ -1342,7 +1344,7 @@ impl<T> VecDeque<T> {\n                 // `at` lies in the first half.\n                 let amount_in_first = first_len - at;\n \n-                ptr::copy_nonoverlapping_memory(other.ptr,\n+                ptr::copy_nonoverlapping_memory(*other.ptr,\n                                                 first_half.as_ptr().offset(at as isize),\n                                                 amount_in_first);\n \n@@ -1355,7 +1357,7 @@ impl<T> VecDeque<T> {\n                 // in the first half.\n                 let offset = at - first_len;\n                 let amount_in_second = second_len - offset;\n-                ptr::copy_nonoverlapping_memory(other.ptr,\n+                ptr::copy_nonoverlapping_memory(*other.ptr,\n                                                 second_half.as_ptr().offset(offset as isize),\n                                                 amount_in_second);\n             }\n@@ -1524,7 +1526,7 @@ pub struct IterMut<'a, T:'a> {\n     tail: usize,\n     head: usize,\n     cap: usize,\n-    marker: marker::ContravariantLifetime<'a>,\n+    marker: marker::PhantomData<&'a mut T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2004,9 +2006,9 @@ mod tests {\n \n     #[derive(Clone, PartialEq, Debug)]\n     enum Taggypar<T> {\n-        Onepar(i32),\n-        Twopar(i32, i32),\n-        Threepar(i32, i32, i32),\n+        Onepar(T),\n+        Twopar(T, T),\n+        Threepar(T, T, T),\n     }\n \n     #[derive(Clone, PartialEq, Debug)]"}, {"sha": "54589a3142345833b443956f65a17227b35fe915", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -876,7 +876,7 @@ pub struct IntoIter<V> {\n }\n \n #[unstable(feature = \"collections\")]\n-pub struct Drain<'a, V> {\n+pub struct Drain<'a, V:'a> {\n     iter: FilterMap<\n     Enumerate<vec::Drain<'a, Option<V>>>,\n     fn((usize, Option<V>)) -> Option<(usize, V)>>"}, {"sha": "6afe5b2257d279736daa4db1799d48a679f3e53b", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -76,6 +76,7 @@ use marker::Sync;\n \n use intrinsics;\n use cell::UnsafeCell;\n+use marker::PhantomData;\n \n /// A boolean type which can be safely shared between threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -105,6 +106,7 @@ unsafe impl Sync for AtomicUsize {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<usize>,\n+    _marker: PhantomData<*mut T>,\n }\n \n unsafe impl<T> Sync for AtomicPtr<T> {}\n@@ -791,7 +793,8 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: UnsafeCell::new(p as usize) }\n+        AtomicPtr { p: UnsafeCell::new(p as usize),\n+                    _marker: PhantomData }\n     }\n \n     /// Loads a value from the pointer."}, {"sha": "a2c1bbc03317e9da08451e0b2b2d6194d385568b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -16,7 +16,7 @@ use any;\n use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n use char::CharExt;\n use iter::{Iterator, IteratorExt};\n-use marker::{Copy, Sized};\n+use marker::{Copy, PhantomData, Sized};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n@@ -914,6 +914,11 @@ impl Debug for () {\n         f.pad(\"()\")\n     }\n }\n+impl<T> Debug for PhantomData<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(\"PhantomData\")\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Copy + Debug> Debug for Cell<T> {"}, {"sha": "8fb10b5b2dc2a53ca3d40709ce7c2abcd46b6e66", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -62,6 +62,7 @@ use clone::Clone;\n use cmp;\n use cmp::Ord;\n use default::Default;\n+use marker;\n use mem;\n use num::{ToPrimitive, Int};\n use ops::{Add, Deref, FnMut};\n@@ -947,7 +948,7 @@ pub trait IteratorExt: Iterator + Sized {\n         FromB: Default + Extend<B>,\n         Self: Iterator<Item=(A, B)>,\n     {\n-        struct SizeHint<A>(usize, Option<usize>);\n+        struct SizeHint<A>(usize, Option<usize>, marker::PhantomData<A>);\n         impl<A> Iterator for SizeHint<A> {\n             type Item = A;\n \n@@ -961,8 +962,8 @@ pub trait IteratorExt: Iterator + Sized {\n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n-        ts.extend(SizeHint(lo, hi));\n-        us.extend(SizeHint(lo, hi));\n+        ts.extend(SizeHint(lo, hi, marker::PhantomData));\n+        us.extend(SizeHint(lo, hi, marker::PhantomData));\n \n         for (t, u) in self {\n             ts.extend(Some(t).into_iter());\n@@ -2064,8 +2065,8 @@ pub struct Scan<I, St, F> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, St, F> Iterator for Scan<I, St, F> where\n-    F: FnMut(&mut St, I::Item) -> Option<B>,\n+impl<A, B, I: Iterator<Item=A>, St, F> Iterator for Scan<I, St, F> where\n+    F: FnMut(&mut St, A) -> Option<B>,\n {\n     type Item = B;\n "}, {"sha": "dc792a3f47f60c98f693488ede491b72f7e85cf6", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 181, "deletions": 205, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -26,6 +26,10 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n+use cmp;\n+use option::Option;\n+use hash::Hash;\n+use hash::Hasher;\n \n /// Types able to be transferred across thread boundaries.\n #[unstable(feature = \"core\",\n@@ -37,20 +41,19 @@ pub unsafe trait Send: 'static {\n     // empty.\n }\n /// Types able to be transferred across thread boundaries.\n-#[unstable(feature = \"core\",\n-           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n #[cfg(not(stage0))]\n-pub unsafe trait Send {\n+pub unsafe trait Send : MarkerTrait {\n     // empty.\n }\n \n /// Types with a constant size known at compile-time.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n-pub trait Sized {\n+pub trait Sized : MarkerTrait {\n     // Empty.\n }\n \n@@ -155,7 +158,7 @@ pub trait Sized {\n /// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"copy\"]\n-pub trait Copy {\n+pub trait Copy : MarkerTrait {\n     // Empty.\n }\n \n@@ -204,236 +207,172 @@ pub trait Copy {\n /// around the value(s) which can be mutated when behind a `&`\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n-#[unstable(feature = \"core\",\n-           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n-pub unsafe trait Sync {\n+pub unsafe trait Sync : MarkerTrait {\n     // Empty\n }\n \n-/// A marker type that indicates to the compiler that the instances\n-/// of the type itself owns instances of the type parameter `T`.\n-///\n-/// This is used to indicate that one or more instances of the type\n-/// `T` could be dropped when instances of the type itself is dropped,\n-/// though that may not be apparent from the other structure of the\n-/// type itself. For example, the type may hold a `*mut T`, which the\n-/// compiler does not automatically treat as owned.\n+/// A type which is considered \"not POD\", meaning that it is not\n+/// implicitly copyable. This is typically embedded in other types to\n+/// ensure that they are never copied, even if they lack a destructor.\n #[unstable(feature = \"core\",\n-           reason = \"Newly added to deal with scoping and destructor changes\")]\n-#[lang=\"phantom_data\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct PhantomData<T: ?Sized>;\n+           reason = \"likely to change with new variance strategy\")]\n+#[lang=\"no_copy_bound\"]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct NoCopy;\n \n-impl<T: ?Sized> Copy for PhantomData<T> {}\n-impl<T: ?Sized> Clone for PhantomData<T> {\n-    fn clone(&self) -> PhantomData<T> { *self }\n+/// A type which is considered managed by the GC. This is typically\n+/// embedded in other types.\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n+#[lang=\"managed_bound\"]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Managed;\n+\n+macro_rules! impls{\n+    ($t: ident) => (\n+        impl<T:?Sized, S: Hasher> Hash<S> for $t<T> {\n+            #[inline]\n+            fn hash(&self, _: &mut S) {\n+            }\n+        }\n+\n+        impl<T:?Sized> cmp::PartialEq for $t<T> {\n+            fn eq(&self, _other: &$t<T>) -> bool {\n+                true\n+            }\n+        }\n+\n+        impl<T:?Sized> cmp::Eq for $t<T> {\n+        }\n+\n+        impl<T:?Sized> cmp::PartialOrd for $t<T> {\n+            fn partial_cmp(&self, _other: &$t<T>) -> Option<cmp::Ordering> {\n+                Option::Some(cmp::Ordering::Equal)\n+            }\n+        }\n+\n+        impl<T:?Sized> cmp::Ord for $t<T> {\n+            fn cmp(&self, _other: &$t<T>) -> cmp::Ordering {\n+                cmp::Ordering::Equal\n+            }\n+        }\n+\n+        impl<T:?Sized> Copy for $t<T> { }\n+\n+        impl<T:?Sized> Clone for $t<T> {\n+            fn clone(&self) -> $t<T> {\n+                $t\n+            }\n+        }\n+        )\n }\n \n-/// A marker type whose type parameter `T` is considered to be\n-/// covariant with respect to the type itself. This is (typically)\n-/// used to indicate that an instance of the type `T` is being stored\n-/// into memory and read from, even though that may not be apparent.\n-///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-///\n-/// *Note:* It is very unusual to have to add a covariant constraint.\n-/// If you are not sure, you probably want to use `InvariantType`.\n+/// `MarkerTrait` is intended to be used as the supertrait for traits\n+/// that don't have any methods but instead serve just to designate\n+/// categories of types. An example would be the `Send` trait, which\n+/// indicates types that are sendable: `Send` does not itself offer\n+/// any methods, but instead is used to gate access to data.\n+///\n+/// FIXME. Better documentation needed here!\n+pub trait MarkerTrait : PhantomFn<Self> { }\n+impl<T:?Sized> MarkerTrait for T { }\n+\n+/// `PhantomFn` is a marker trait for use with traits that contain\n+/// type or lifetime parameters that do not appear in any of their\n+/// methods. In that case, you can either remove those parameters, or\n+/// add a `PhantomFn` supertrait that reflects the signature of\n+/// methods that compiler should \"pretend\" exists. This most commonly\n+/// occurs for traits with no methods: in that particular case, you\n+/// can extend `MarkerTrait`, which is equivalent to\n+/// `PhantomFn<Self>`.\n ///\n /// # Example\n ///\n-/// Given a struct `S` that includes a type parameter `T`\n-/// but does not actually *reference* that type parameter:\n+/// As an example, consider a trait with no methods like `Even`, meant\n+/// to represent types that are \"even\":\n ///\n-/// ```ignore\n-/// use std::mem;\n-///\n-/// struct S<T> { x: *() }\n-/// fn get<T>(s: &S<T>) -> T {\n-///    unsafe {\n-///        let x: *T = mem::transmute(s.x);\n-///        *x\n-///    }\n-/// }\n+/// ```rust\n+/// trait Even { }\n /// ```\n ///\n-/// The type system would currently infer that the value of\n-/// the type parameter `T` is irrelevant, and hence a `S<int>` is\n-/// a subtype of `S<Box<int>>` (or, for that matter, `S<U>` for\n-/// any `U`). But this is incorrect because `get()` converts the\n-/// `*()` into a `*T` and reads from it. Therefore, we should include the\n-/// a marker field `CovariantType<T>` to inform the type checker that\n-/// `S<T>` is a subtype of `S<U>` if `T` is a subtype of `U`\n-/// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n-/// for some lifetime `'a`, but not the other way around).\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"covariant_type\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct CovariantType<T: ?Sized>;\n-\n-impl<T: ?Sized> Copy for CovariantType<T> {}\n-impl<T: ?Sized> Clone for CovariantType<T> {\n-    fn clone(&self) -> CovariantType<T> { *self }\n-}\n-\n-/// A marker type whose type parameter `T` is considered to be\n-/// contravariant with respect to the type itself. This is (typically)\n-/// used to indicate that an instance of the type `T` will be consumed\n-/// (but not read from), even though that may not be apparent.\n+/// In this case, because the implicit parameter `Self` is unused, the\n+/// compiler will issue an error. The only purpose of this trait is to\n+/// categorize types (and hence instances of those types) as \"even\" or\n+/// not, so if we *were* going to have a method, it might look like:\n ///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+/// ```rust\n+/// trait Even {\n+///     fn is_even(self) -> bool { true }\n+/// }\n+/// ```\n ///\n-/// *Note:* It is very unusual to have to add a contravariant constraint.\n-/// If you are not sure, you probably want to use `InvariantType`.\n+/// Therefore, we can model a method like this as follows:\n ///\n-/// # Example\n+/// ```rust\n+/// use std::marker::PhantomFn\n+/// trait Even : PhantomFn<Self> { }\n+/// ```\n ///\n-/// Given a struct `S` that includes a type parameter `T`\n-/// but does not actually *reference* that type parameter:\n+/// Another equivalent, but clearer, option would be to use\n+/// `MarkerTrait`:\n ///\n+/// ```rust\n+/// use std::marker::MarkerTrait;\n+/// trait Even : MarkerTrait { }\n /// ```\n-/// use std::mem;\n-///\n-/// struct S<T> { x: *const () }\n-/// fn get<T>(s: &S<T>, v: T) {\n-///    unsafe {\n-///        let x: fn(T) = mem::transmute(s.x);\n-///        x(v)\n-///    }\n-/// }\n-/// ```\n-///\n-/// The type system would currently infer that the value of\n-/// the type parameter `T` is irrelevant, and hence a `S<int>` is\n-/// a subtype of `S<Box<int>>` (or, for that matter, `S<U>` for\n-/// any `U`). But this is incorrect because `get()` converts the\n-/// `*()` into a `fn(T)` and then passes a value of type `T` to it.\n-///\n-/// Supplying a `ContravariantType` marker would correct the\n-/// problem, because it would mark `S` so that `S<T>` is only a\n-/// subtype of `S<U>` if `U` is a subtype of `T`; given that the\n-/// function requires arguments of type `T`, it must also accept\n-/// arguments of type `U`, hence such a conversion is safe.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"contravariant_type\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct ContravariantType<T: ?Sized>;\n-\n-impl<T: ?Sized> Copy for ContravariantType<T> {}\n-impl<T: ?Sized> Clone for ContravariantType<T> {\n-    fn clone(&self) -> ContravariantType<T> { *self }\n-}\n-\n-/// A marker type whose type parameter `T` is considered to be\n-/// invariant with respect to the type itself. This is (typically)\n-/// used to indicate that instances of the type `T` may be read or\n-/// written, even though that may not be apparent.\n ///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+/// # Parameters\n ///\n-/// # Example\n+/// - `A` represents the type of the method's argument. You can use a\n+///   tuple to represent \"multiple\" arguments. Any types appearing here\n+///   will be considered \"contravariant\".\n+/// - `R`, if supplied, represents the method's return type. This defaults\n+///   to `()` as it is rarely needed.\n ///\n-/// The Cell type is an example of an `InvariantType` which uses unsafe\n-/// code to achieve \"interior\" mutability:\n+/// # Additional reading\n ///\n-/// ```\n-/// struct Cell<T> { value: T }\n-/// ```\n+/// More details and background can be found in [RFC 738][738].\n ///\n-/// The type system would infer that `value` is only read here\n-/// and never written, but in fact `Cell` uses unsafe code to achieve\n-/// interior mutability. In order to get correct behavior, the\n-/// `InvariantType` marker must be applied.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"invariant_type\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct InvariantType<T: ?Sized>;\n-\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-impl<T: ?Sized> Copy for InvariantType<T> {}\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-impl<T: ?Sized> Clone for InvariantType<T> {\n-    fn clone(&self) -> InvariantType<T> { *self }\n-}\n-\n-/// As `CovariantType`, but for lifetime parameters. Using\n-/// `CovariantLifetime<'a>` indicates that it is ok to substitute\n-/// a *longer* lifetime for `'a` than the one you originally\n-/// started with (e.g., you could convert any lifetime `'foo` to\n-/// `'static`). You almost certainly want `ContravariantLifetime`\n-/// instead, or possibly `InvariantLifetime`. The only case where\n-/// it would be appropriate is that you have a (type-casted, and\n-/// hence hidden from the type system) function pointer with a\n-/// signature like `fn(&'a T)` (and no other uses of `'a`). In\n-/// this case, it is ok to substitute a larger lifetime for `'a`\n-/// (e.g., `fn(&'static T)`), because the function is only\n-/// becoming more selective in terms of what it accepts as\n-/// argument.\n-///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"covariant_lifetime\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct CovariantLifetime<'a>;\n+/// [738]: https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md\n+#[lang=\"phantom_fn\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n \n-/// As `ContravariantType`, but for lifetime parameters. Using\n-/// `ContravariantLifetime<'a>` indicates that it is ok to\n-/// substitute a *shorter* lifetime for `'a` than the one you\n-/// originally started with (e.g., you could convert `'static` to\n-/// any lifetime `'foo`). This is appropriate for cases where you\n-/// have an unsafe pointer that is actually a pointer into some\n-/// memory with lifetime `'a`, and thus you want to limit the\n-/// lifetime of your data structure to `'a`. An example of where\n-/// this is used is the iterator for vectors.\n-///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"contravariant_lifetime\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct ContravariantLifetime<'a>;\n+#[cfg(stage0)] // built into the trait matching system after stage0\n+impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n \n-/// As `InvariantType`, but for lifetime parameters. Using\n-/// `InvariantLifetime<'a>` indicates that it is not ok to\n-/// substitute any other lifetime for `'a` besides its original\n-/// value. This is appropriate for cases where you have an unsafe\n-/// pointer that is actually a pointer into memory with lifetime `'a`,\n-/// and this pointer is itself stored in an inherently mutable\n-/// location (such as a `Cell`).\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"invariant_lifetime\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct InvariantLifetime<'a>;\n+/// Specific to stage0. You should not be seeing these docs!\n+#[cfg(stage0)]\n+#[lang=\"covariant_type\"] // only relevant to stage0\n+pub struct PhantomData<T:?Sized>;\n \n-/// A type which is considered \"not POD\", meaning that it is not\n-/// implicitly copyable. This is typically embedded in other types to\n-/// ensure that they are never copied, even if they lack a destructor.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"no_copy_bound\"]\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct NoCopy;\n+/// `PhantomData` is a way to tell the compiler about fake fields.\n+/// Phantom data is required whenever type parameters are not used.\n+/// The idea is that if the compiler encounters a `PhantomData<T>`\n+/// instance, it will behave *as if* an instance of the type `T` were\n+/// present for the purpose of various automatic analyses.\n+///\n+/// For example, embedding a `PhantomData<T>` will inform the compiler\n+/// that one or more instances of the type `T` could be dropped when\n+/// instances of the type itself is dropped, though that may not be\n+/// apparent from the other structure of the type itself. This is\n+/// commonly necessary if the structure is using an unsafe pointer\n+/// like `*mut T` whose referent may be dropped when the type is\n+/// dropped, as a `*mut T` is otherwise not treated as owned.\n+///\n+/// FIXME. Better documentation and examples of common patterns needed\n+/// here! For now, please see [RFC 738][738] for more information.\n+///\n+/// [738]: https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md\n+#[cfg(not(stage0))]\n+#[lang=\"phantom_data\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct PhantomData<T:?Sized>;\n \n-/// A type which is considered managed by the GC. This is typically\n-/// embedded in other types.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"managed_bound\"]\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct Managed;\n+impls! { PhantomData }\n \n #[cfg(not(stage0))]\n mod impls {\n@@ -442,3 +381,40 @@ mod impls {\n     unsafe impl<'a, T: Sync + ?Sized> Send for &'a T {}\n     unsafe impl<'a, T: Send + ?Sized> Send for &'a mut T {}\n }\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<&'a ()>`\")]\n+#[lang=\"contravariant_lifetime\"]\n+pub struct ContravariantLifetime<'a>;\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<fn(&'a ())>`\")]\n+#[lang=\"covariant_lifetime\"]\n+pub struct CovariantLifetime<'a>;\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<Cell<&'a ()>>`\")]\n+#[lang=\"invariant_lifetime\"]\n+pub struct InvariantLifetime<'a>;\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<fn(T)>`\")]\n+#[lang=\"contravariant_type\"]\n+pub struct ContravariantType<T>;\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<T>`\")]\n+#[lang=\"covariant_type\"]\n+#[cfg(not(stage0))]\n+pub struct CovariantType<T>;\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<Cell<T>>`\")]\n+#[lang=\"invariant_type\"]\n+pub struct InvariantType<T>;"}, {"sha": "230587b726fd1e022748df5e76ab48899237be7f", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,15 +10,14 @@\n \n //! Exposes the NonZero lang item which provides optimization hints.\n \n+use marker::{Sized, MarkerTrait};\n use ops::Deref;\n-use ptr::Unique;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n-pub unsafe trait Zeroable {}\n+pub unsafe trait Zeroable : MarkerTrait {}\n \n-unsafe impl<T> Zeroable for *const T {}\n-unsafe impl<T> Zeroable for *mut T {}\n-unsafe impl<T> Zeroable for Unique<T> { }\n+unsafe impl<T:?Sized> Zeroable for *const T {}\n+unsafe impl<T:?Sized> Zeroable for *mut T {}\n unsafe impl Zeroable for isize {}\n unsafe impl Zeroable for usize {}\n unsafe impl Zeroable for i8 {}"}, {"sha": "16b84dcf18e24aed5952b17cfbf1b7f45b1648c0", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -91,8 +91,10 @@\n use mem;\n use clone::Clone;\n use intrinsics;\n+use ops::Deref;\n use option::Option::{self, Some, None};\n-use marker::{self, Send, Sized, Sync};\n+use marker::{PhantomData, Send, Sized, Sync};\n+use nonzero::NonZero;\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd};\n use cmp::Ordering::{self, Less, Equal, Greater};\n@@ -517,15 +519,16 @@ impl<T> PartialOrd for *mut T {\n \n /// A wrapper around a raw `*mut T` that indicates that the possessor\n /// of this wrapper owns the referent. This in turn implies that the\n-/// `Unique<T>` is `Send`/`Sync` if `T` is `Send`/`Sync`, unlike a\n-/// raw `*mut T` (which conveys no particular ownership semantics).\n-/// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n+/// `Unique<T>` is `Send`/`Sync` if `T` is `Send`/`Sync`, unlike a raw\n+/// `*mut T` (which conveys no particular ownership semantics).  It\n+/// also implies that the referent of the pointer should not be\n+/// modified without a unique path to the `Unique` reference. Useful\n+/// for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n #[unstable(feature = \"core\", reason = \"recently added to this module\")]\n-pub struct Unique<T: ?Sized> {\n-    /// The wrapped `*mut T`.\n-    pub ptr: *mut T,\n-    _own: marker::PhantomData<T>,\n+pub struct Unique<T:?Sized> {\n+    pointer: NonZero<*const T>,\n+    _marker: PhantomData<T>,\n }\n \n /// `Unique` pointers are `Send` if `T` is `Send` because the data they\n@@ -542,25 +545,34 @@ unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n #[unstable(feature = \"core\", reason = \"recently added to this module\")]\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n-impl<T> Unique<T> {\n-    /// Returns a null Unique.\n+impl<T:?Sized> Unique<T> {\n+    /// Create a new `Unique`.\n     #[unstable(feature = \"core\",\n                reason = \"recently added to this module\")]\n-    pub fn null() -> Unique<T> {\n-        Unique(null_mut())\n+    pub unsafe fn new(ptr: *mut T) -> Unique<T> {\n+        Unique { pointer: NonZero::new(ptr as *const T), _marker: PhantomData }\n     }\n \n-    /// Return an (unsafe) pointer into the memory owned by `self`.\n+    /// Dereference the content.\n     #[unstable(feature = \"core\",\n                reason = \"recently added to this module\")]\n-    pub unsafe fn offset(self, offset: isize) -> *mut T {\n-        self.ptr.offset(offset)\n+    pub unsafe fn get(&self) -> &T {\n+        &**self.pointer\n+    }\n+\n+    /// Mutably dereference the content.\n+    #[unstable(feature = \"core\",\n+               reason = \"recently added to this module\")]\n+    pub unsafe fn get_mut(&mut self) -> &mut T {\n+        &mut ***self\n     }\n }\n \n-/// Creates a `Unique` wrapped around `ptr`, taking ownership of the\n-/// data referenced by `ptr`.\n-#[allow(non_snake_case)]\n-pub fn Unique<T: ?Sized>(ptr: *mut T) -> Unique<T> {\n-    Unique { ptr: ptr, _own: marker::PhantomData }\n+impl<T:?Sized> Deref for Unique<T> {\n+    type Target = *mut T;\n+\n+    #[inline]\n+    fn deref<'a>(&'a self) -> &'a *mut T {\n+        unsafe { mem::transmute(&*self.pointer) }\n+    }\n }"}, {"sha": "a86da53b372a9bfc2b14969f445fc7ad1be40465", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -140,11 +140,11 @@ impl<T> SliceExt for [T] {\n             if mem::size_of::<T>() == 0 {\n                 Iter {ptr: p,\n                       end: (p as usize + self.len()) as *const T,\n-                      marker: marker::ContravariantLifetime::<'a>}\n+                      _marker: marker::PhantomData}\n             } else {\n                 Iter {ptr: p,\n                       end: p.offset(self.len() as isize),\n-                      marker: marker::ContravariantLifetime::<'a>}\n+                      _marker: marker::PhantomData}\n             }\n         }\n     }\n@@ -279,11 +279,11 @@ impl<T> SliceExt for [T] {\n             if mem::size_of::<T>() == 0 {\n                 IterMut {ptr: p,\n                          end: (p as usize + self.len()) as *mut T,\n-                         marker: marker::ContravariantLifetime::<'a>}\n+                         _marker: marker::PhantomData}\n             } else {\n                 IterMut {ptr: p,\n                          end: p.offset(self.len() as isize),\n-                         marker: marker::ContravariantLifetime::<'a>}\n+                         _marker: marker::PhantomData}\n             }\n         }\n     }\n@@ -733,7 +733,7 @@ macro_rules! make_slice {\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n-    marker: marker::ContravariantLifetime<'a>\n+    _marker: marker::PhantomData<&'a T>,\n }\n \n #[unstable(feature = \"core\")]\n@@ -790,7 +790,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n-    fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, marker: self.marker } }\n+    fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n@@ -823,7 +823,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n-    marker: marker::ContravariantLifetime<'a>,\n+    _marker: marker::PhantomData<&'a mut T>,\n }\n \n "}, {"sha": "5aeb330b78b54023ac388d83d22f5eeff636b319", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -92,7 +92,7 @@ fn test_transmute_copy() {\n \n #[test]\n fn test_transmute() {\n-    trait Foo {}\n+    trait Foo { fn dummy(&self) { } }\n     impl Foo for int {}\n \n     let a = box 100 as Box<Foo>;"}, {"sha": "57456bfb1a79ba04ce4b68c77999d37c2b507a90", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -171,8 +171,8 @@ fn test_set_memory() {\n #[test]\n fn test_unsized_unique() {\n     let xs: &mut [_] = &mut [1, 2, 3];\n-    let ptr = Unique(xs as *mut [_]);\n-    let ys = unsafe { &mut *ptr.ptr };\n+    let ptr = unsafe { Unique::new(xs as *mut [_]) };\n+    let ys = unsafe { &mut **ptr };\n     let zs: &mut [_] = &mut [1, 2, 3];\n     assert!(ys == zs);\n }"}, {"sha": "24660b3f396c105031903ceb43822ff6b690cb66", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -45,13 +45,13 @@ pub struct Bytes {\n impl Deref for Bytes {\n     type Target = [u8];\n     fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts_mut(self.ptr.ptr, self.len) }\n+        unsafe { slice::from_raw_parts(*self.ptr, self.len) }\n     }\n }\n \n impl Drop for Bytes {\n     fn drop(&mut self) {\n-        unsafe { libc::free(self.ptr.ptr as *mut _); }\n+        unsafe { libc::free(*self.ptr as *mut _); }\n     }\n }\n \n@@ -84,7 +84,7 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n                                              &mut outsz,\n                                              flags);\n         if !res.is_null() {\n-            let res = Unique(res as *mut u8);\n+            let res = Unique::new(res as *mut u8);\n             Some(Bytes { ptr: res, len: outsz as uint })\n         } else {\n             None\n@@ -110,7 +110,7 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n                                                &mut outsz,\n                                                flags);\n         if !res.is_null() {\n-            let res = Unique(res as *mut u8);\n+            let res = Unique::new(res as *mut u8);\n             Some(Bytes { ptr: res, len: outsz as uint })\n         } else {\n             None"}, {"sha": "5a85552dc384eb10536faa8520621827fe5416cd", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -21,6 +21,7 @@\n \n use core::prelude::*;\n use core::num::{Float, Int};\n+use core::marker::PhantomData;\n \n use {Rng, Rand};\n \n@@ -56,7 +57,13 @@ pub trait IndependentSample<Support>: Sample<Support> {\n \n /// A wrapper for generating types that implement `Rand` via the\n /// `Sample` & `IndependentSample` traits.\n-pub struct RandSample<Sup>;\n+pub struct RandSample<Sup> { _marker: PhantomData<Sup> }\n+\n+impl<Sup> RandSample<Sup> {\n+    pub fn new() -> RandSample<Sup> {\n+        RandSample { _marker: PhantomData }\n+    }\n+}\n \n impl<Sup: Rand> Sample<Sup> for RandSample<Sup> {\n     fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup { self.ind_sample(rng) }\n@@ -285,7 +292,7 @@ mod tests {\n \n     #[test]\n     fn test_rand_sample() {\n-        let mut rand_sample = RandSample::<ConstRand>;\n+        let mut rand_sample = RandSample::<ConstRand>::new();\n \n         assert_eq!(rand_sample.sample(&mut ::test::rng()), ConstRand(0));\n         assert_eq!(rand_sample.ind_sample(&mut ::test::rng()), ConstRand(0));"}, {"sha": "7588bf7c5158e7f27114784bbe2d025ec8dbfdbe", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -41,6 +41,7 @@ extern crate core;\n #[cfg(test)] #[macro_use] extern crate log;\n \n use core::prelude::*;\n+use core::marker::PhantomData;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n pub use chacha::ChaChaRng;\n@@ -206,7 +207,7 @@ pub trait Rng : Sized {\n     ///                     .collect::<Vec<(f64, bool)>>());\n     /// ```\n     fn gen_iter<'a, T: Rand>(&'a mut self) -> Generator<'a, T, Self> {\n-        Generator { rng: self }\n+        Generator { rng: self, _marker: PhantomData }\n     }\n \n     /// Generate a random value in the range [`low`, `high`).\n@@ -317,6 +318,7 @@ pub trait Rng : Sized {\n /// This iterator is created via the `gen_iter` method on `Rng`.\n pub struct Generator<'a, T, R:'a> {\n     rng: &'a mut R,\n+    _marker: PhantomData<T>\n }\n \n impl<'a, T: Rand, R: Rng> Iterator for Generator<'a, T, R> {"}, {"sha": "e99d214742a0b668b40becf51bccafc8c387022b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -29,7 +29,6 @@ use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::ty::{MethodStatic, MethodStaticClosure};\n use util::ppaux::Repr;\n \n-use std::marker;\n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n use syntax::codemap::Span;\n@@ -128,16 +127,14 @@ pub enum MatchMode {\n     MovingMatch,\n }\n \n-#[derive(PartialEq,Debug)]\n-enum TrackMatchMode<T> {\n+#[derive(Copy, PartialEq, Debug)]\n+enum TrackMatchMode {\n     Unknown,\n     Definite(MatchMode),\n     Conflicting,\n }\n \n-impl<T> marker::Copy for TrackMatchMode<T> {}\n-\n-impl<T> TrackMatchMode<T> {\n+impl TrackMatchMode {\n     // Builds up the whole match mode for a pattern from its constituent\n     // parts.  The lattice looks like this:\n     //\n@@ -931,7 +928,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         return true;\n     }\n \n-    fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) -> TrackMatchMode<Span> {\n+    fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) -> TrackMatchMode {\n         let mut mode = Unknown;\n         for pat in &arm.pats {\n             self.determine_pat_move_mode(discr_cmt.clone(), &**pat, &mut mode);\n@@ -966,7 +963,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn determine_pat_move_mode(&mut self,\n                                cmt_discr: mc::cmt<'tcx>,\n                                pat: &ast::Pat,\n-                               mode: &mut TrackMatchMode<Span>) {\n+                               mode: &mut TrackMatchMode) {\n         debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {"}, {"sha": "93c80fb754f71f8d83db96d9c1b058b326926d22", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,145 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Applies the \"bivariance relationship\" to two types and/or regions.\n+//! If (A,B) are bivariant then either A <: B or B <: A. It occurs\n+//! when type/lifetime parameters are unconstrained. Usually this is\n+//! an error, but we permit it in the specific case where a type\n+//! parameter is constrained in a where-clause via an associated type.\n+//!\n+//! There are several ways one could implement bivariance. You could\n+//! just do nothing at all, for example, or you could fully verify\n+//! that one of the two subtyping relationships hold. We choose to\n+//! thread a middle line: we relate types up to regions, but ignore\n+//! all region relationships.\n+//!\n+//! At one point, handling bivariance in this fashion was necessary\n+//! for inference, but I'm actually not sure if that is true anymore.\n+//! In particular, it might be enough to say (A,B) are bivariant for\n+//! all (A,B).\n+\n+use middle::ty::{BuiltinBounds};\n+use middle::ty::{self, Ty};\n+use middle::ty::TyVar;\n+use middle::infer::combine::*;\n+use middle::infer::{cres};\n+use middle::infer::type_variable::{BiTo};\n+use util::ppaux::{Repr};\n+\n+use syntax::ast::{Unsafety};\n+\n+pub struct Bivariate<'f, 'tcx: 'f> {\n+    fields: CombineFields<'f, 'tcx>\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn Bivariate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Bivariate<'f, 'tcx> {\n+    Bivariate { fields: cf }\n+}\n+\n+impl<'f, 'tcx> Combine<'tcx> for Bivariate<'f, 'tcx> {\n+    fn tag(&self) -> String { \"Bivariate\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Contravariant => self.tys(a, b),\n+            ty::Bivariant => self.tys(a, b),\n+        }\n+    }\n+\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Contravariant => self.regions(a, b),\n+            ty::Bivariant => self.regions(a, b),\n+        }\n+    }\n+\n+    fn regions(&self, a: ty::Region, _: ty::Region) -> cres<'tcx, ty::Region> {\n+        Ok(a)\n+    }\n+\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n+        debug!(\"mts({} <: {})\",\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+\n+        if a.mutbl != b.mutbl { return Err(ty::terr_mutability); }\n+        let t = try!(self.tys(a.ty, b.ty));\n+        Ok(ty::mt { mutbl: a.mutbl, ty: t })\n+    }\n+\n+    fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety> {\n+        if a != b {\n+            Err(ty::terr_unsafety_mismatch(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn builtin_bounds(&self,\n+                      a: BuiltinBounds,\n+                      b: BuiltinBounds)\n+                      -> cres<'tcx, BuiltinBounds>\n+    {\n+        if a != b {\n+            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n+        debug!(\"{}.tys({}, {})\", self.tag(),\n+               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n+        if a == b { return Ok(a); }\n+\n+        let infcx = self.fields.infcx;\n+        let a = infcx.type_variables.borrow().replace_if_possible(a);\n+        let b = infcx.type_variables.borrow().replace_if_possible(b);\n+        match (&a.sty, &b.sty) {\n+            (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n+                infcx.type_variables.borrow_mut().relate_vars(a_id, BiTo, b_id);\n+                Ok(a)\n+            }\n+\n+            (&ty::ty_infer(TyVar(a_id)), _) => {\n+                try!(self.fields.instantiate(b, BiTo, a_id));\n+                Ok(a)\n+            }\n+\n+            (_, &ty::ty_infer(TyVar(b_id))) => {\n+                try!(self.fields.instantiate(a, BiTo, b_id));\n+                Ok(a)\n+            }\n+\n+            _ => {\n+                super_tys(self, a, b)\n+            }\n+        }\n+    }\n+\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>\n+    {\n+        let a1 = ty::erase_late_bound_regions(self.tcx(), a);\n+        let b1 = ty::erase_late_bound_regions(self.tcx(), b);\n+        let c = try!(Combineable::combine(self, &a1, &b1));\n+        Ok(ty::Binder(c))\n+    }\n+}"}, {"sha": "0eeafb767d8a625d2792a3c393f4888aec8cf68c", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 76, "deletions": 70, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -32,14 +32,15 @@\n // is also useful to track which value is the \"expected\" value in\n // terms of error reporting.\n \n+use super::bivariate::Bivariate;\n use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n use super::{InferCtxt, cres};\n use super::{MiscVariable, TypeTrace};\n-use super::type_variable::{RelationDir, EqTo, SubtypeOf, SupertypeOf};\n+use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n use middle::subst;\n use middle::subst::{ErasedRegions, NonerasedRegions, Substs};\n@@ -48,7 +49,7 @@ use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n use middle::ty_fold;\n-use middle::ty_fold::{TypeFoldable};\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n@@ -58,48 +59,44 @@ use syntax::abi;\n use syntax::codemap::Span;\n \n pub trait Combine<'tcx> : Sized {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx>;\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n     fn tag(&self) -> String;\n-    fn a_is_expected(&self) -> bool;\n-    fn trace(&self) -> TypeTrace<'tcx>;\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx>;\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx>;\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx>;\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx>;\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx>;\n+\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields().infcx }\n+    fn a_is_expected(&self) -> bool { self.fields().a_is_expected }\n+    fn trace(&self) -> TypeTrace<'tcx> { self.fields().trace.clone() }\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { self.fields().equate() }\n+    fn bivariate<'a>(&'a self) -> Bivariate<'a, 'tcx> { self.fields().bivariate() }\n+\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { self.fields().sub() }\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields().clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields().clone()) }\n \n     fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>>;\n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n+\n+    fn tys_with_variance(&self, variance: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>;\n+\n     fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n \n-    fn tps(&self,\n-           _: subst::ParamSpace,\n-           as_: &[Ty<'tcx>],\n-           bs: &[Ty<'tcx>])\n-           -> cres<'tcx, Vec<Ty<'tcx>>> {\n-        // FIXME -- In general, we treat variance a bit wrong\n-        // here. For historical reasons, we treat tps and Self\n-        // as invariant. This is overly conservative.\n-\n-        if as_.len() != bs.len() {\n-            return Err(ty::terr_ty_param_size(expected_found(self,\n-                                                             as_.len(),\n-                                                             bs.len())));\n-        }\n+    fn regions_with_variance(&self, variance: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>;\n \n-        try!(as_.iter().zip(bs.iter())\n-                .map(|(a, b)| self.equate().tys(*a, *b))\n-                .collect::<cres<Vec<Ty>>>());\n-        Ok(as_.to_vec())\n-    }\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n \n     fn substs(&self,\n               item_def_id: ast::DefId,\n               a_subst: &subst::Substs<'tcx>,\n               b_subst: &subst::Substs<'tcx>)\n               -> cres<'tcx, subst::Substs<'tcx>>\n     {\n+        debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n+               item_def_id.repr(self.infcx().tcx),\n+               a_subst.repr(self.infcx().tcx),\n+               b_subst.repr(self.infcx().tcx));\n+\n         let variances = if self.infcx().tcx.variance_computed.get() {\n             Some(ty::item_variances(self.infcx().tcx, item_def_id))\n         } else {\n@@ -119,7 +116,8 @@ pub trait Combine<'tcx> : Sized {\n         for &space in &subst::ParamSpace::all() {\n             let a_tps = a_subst.types.get_slice(space);\n             let b_tps = b_subst.types.get_slice(space);\n-            let tps = try!(self.tps(space, a_tps, b_tps));\n+            let t_variances = variances.map(|v| v.types.get_slice(space));\n+            let tps = try!(relate_type_params(self, t_variances, a_tps, b_tps));\n             substs.types.replace(space, tps);\n         }\n \n@@ -132,20 +130,7 @@ pub trait Combine<'tcx> : Sized {\n                 for &space in &subst::ParamSpace::all() {\n                     let a_regions = a.get_slice(space);\n                     let b_regions = b.get_slice(space);\n-\n-                    let mut invariance = Vec::new();\n-                    let r_variances = match variances {\n-                        Some(variances) => {\n-                            variances.regions.get_slice(space)\n-                        }\n-                        None => {\n-                            for _ in a_regions {\n-                                invariance.push(ty::Invariant);\n-                            }\n-                            &invariance[..]\n-                        }\n-                    };\n-\n+                    let r_variances = variances.map(|v| v.regions.get_slice(space));\n                     let regions = try!(relate_region_params(self,\n                                                             r_variances,\n                                                             a_regions,\n@@ -157,13 +142,34 @@ pub trait Combine<'tcx> : Sized {\n \n         return Ok(substs);\n \n+        fn relate_type_params<'tcx, C: Combine<'tcx>>(this: &C,\n+                                                      variances: Option<&[ty::Variance]>,\n+                                                      a_tys: &[Ty<'tcx>],\n+                                                      b_tys: &[Ty<'tcx>])\n+                                                      -> cres<'tcx, Vec<Ty<'tcx>>>\n+        {\n+            if a_tys.len() != b_tys.len() {\n+                return Err(ty::terr_ty_param_size(expected_found(this,\n+                                                                 a_tys.len(),\n+                                                                 b_tys.len())));\n+            }\n+\n+            range(0, a_tys.len()).map(|i| {\n+                let a_ty = a_tys[i];\n+                let b_ty = b_tys[i];\n+                let v = variances.map_or(ty::Invariant, |v| v[i]);\n+                this.tys_with_variance(v, a_ty, b_ty)\n+            }).collect()\n+        }\n+\n         fn relate_region_params<'tcx, C: Combine<'tcx>>(this: &C,\n-                                                        variances: &[ty::Variance],\n+                                                        variances: Option<&[ty::Variance]>,\n                                                         a_rs: &[ty::Region],\n                                                         b_rs: &[ty::Region])\n-                                                        -> cres<'tcx, Vec<ty::Region>> {\n+                                                        -> cres<'tcx, Vec<ty::Region>>\n+        {\n             let tcx = this.infcx().tcx;\n-            let num_region_params = variances.len();\n+            let num_region_params = a_rs.len();\n \n             debug!(\"relate_region_params(\\\n                    a_rs={}, \\\n@@ -173,22 +179,18 @@ pub trait Combine<'tcx> : Sized {\n                    b_rs.repr(tcx),\n                    variances.repr(tcx));\n \n-            assert_eq!(num_region_params, a_rs.len());\n+            assert_eq!(num_region_params,\n+                       variances.map_or(num_region_params,\n+                                        |v| v.len()));\n+\n             assert_eq!(num_region_params, b_rs.len());\n-            let mut rs = vec!();\n-            for i in 0..num_region_params {\n+\n+            (0..a_rs.len()).map(|i| {\n                 let a_r = a_rs[i];\n                 let b_r = b_rs[i];\n-                let variance = variances[i];\n-                let r = match variance {\n-                    ty::Invariant => this.equate().regions(a_r, b_r),\n-                    ty::Covariant => this.regions(a_r, b_r),\n-                    ty::Contravariant => this.contraregions(a_r, b_r),\n-                    ty::Bivariant => Ok(a_r),\n-                };\n-                rs.push(try!(r));\n-            }\n-            Ok(rs)\n+                let variance = variances.map_or(ty::Invariant, |v| v[i]);\n+                this.regions_with_variance(variance, a_r, b_r)\n+            }).collect()\n         }\n     }\n \n@@ -241,7 +243,7 @@ pub trait Combine<'tcx> : Sized {\n     }\n \n     fn args(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        self.contratys(a, b).and_then(|t| Ok(t))\n+        self.tys_with_variance(ty::Contravariant, a, b).and_then(|t| Ok(t))\n     }\n \n     fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety>;\n@@ -309,7 +311,7 @@ pub trait Combine<'tcx> : Sized {\n                           b: &ty::ExistentialBounds<'tcx>)\n                           -> cres<'tcx, ty::ExistentialBounds<'tcx>>\n     {\n-        let r = try!(self.contraregions(a.region_bound, b.region_bound));\n+        let r = try!(self.regions_with_variance(ty::Contravariant, a.region_bound, b.region_bound));\n         let nb = try!(self.builtin_bounds(a.builtin_bounds, b.builtin_bounds));\n         let pb = try!(self.projection_bounds(&a.projection_bounds, &b.projection_bounds));\n         Ok(ty::ExistentialBounds { region_bound: r,\n@@ -322,11 +324,6 @@ pub trait Combine<'tcx> : Sized {\n                       b: ty::BuiltinBounds)\n                       -> cres<'tcx, ty::BuiltinBounds>;\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                  -> cres<'tcx, ty::Region>;\n-\n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n-\n     fn trait_refs(&self,\n                   a: &ty::TraitRef<'tcx>,\n                   b: &ty::TraitRef<'tcx>)\n@@ -540,7 +537,8 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n-            let r = try!(this.contraregions(*a_r, *b_r));\n+            let r = try!(this.regions_with_variance(ty::Contravariant, *a_r, *b_r));\n+\n             // FIXME(14985)  If we have mutable references to trait objects, we\n             // used to use covariant subtyping. I have preserved this behaviour,\n             // even though it is probably incorrect. So don't go down the usual\n@@ -644,6 +642,10 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n         Equate((*self).clone())\n     }\n \n+    fn bivariate(&self) -> Bivariate<'f, 'tcx> {\n+        Bivariate((*self).clone())\n+    }\n+\n     fn sub(&self) -> Sub<'f, 'tcx> {\n         Sub((*self).clone())\n     }\n@@ -697,7 +699,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                         EqTo => {\n                             self.generalize(a_ty, b_vid, false)\n                         }\n-                        SupertypeOf | SubtypeOf => {\n+                        BiTo | SupertypeOf | SubtypeOf => {\n                             self.generalize(a_ty, b_vid, true)\n                         }\n                     });\n@@ -721,6 +723,10 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n             match dir {\n+                BiTo => {\n+                    try!(self.bivariate().tys(a_ty, b_ty));\n+                }\n+\n                 EqTo => {\n                     try!(self.equate().tys(a_ty, b_ty));\n                 }\n@@ -730,7 +736,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                 }\n \n                 SupertypeOf => {\n-                    try!(self.sub().contratys(a_ty, b_ty));\n+                    try!(self.sub().tys_with_variance(ty::Contravariant, a_ty, b_ty));\n                 }\n             }\n         }"}, {"sha": "7194e20b0cf655224c08530e4f569c158d197cab", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,11 +13,7 @@ use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use middle::infer::combine::*;\n use middle::infer::{cres};\n-use middle::infer::glb::Glb;\n-use middle::infer::InferCtxt;\n-use middle::infer::lub::Lub;\n-use middle::infer::sub::Sub;\n-use middle::infer::{TypeTrace, Subtype};\n+use middle::infer::{Subtype};\n use middle::infer::type_variable::{EqTo};\n use util::ppaux::{Repr};\n \n@@ -33,21 +29,20 @@ pub fn Equate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Equate<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"eq\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n+    fn tag(&self) -> String { \"Equate\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n-\n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n+    fn tys_with_variance(&self, _: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        // Once we're equating, it doesn't matter what the variance is.\n         self.tys(a, b)\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n+    fn regions_with_variance(&self, _: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        // Once we're equating, it doesn't matter what the variance is.\n         self.regions(a, b)\n     }\n "}, {"sha": "53032f9b9ac64ac512d673d0faece23d2bee32a9", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -675,6 +675,17 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     sup,\n                     \"\");\n             }\n+            infer::Operand(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of operand does not outlive \\\n+                     the operation\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the operand is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n             infer::AddrOf(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n@@ -1593,6 +1604,11 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"...so that return value is valid for the call\");\n             }\n+            infer::Operand(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"...so that operand is valid for operation\");\n+            }\n             infer::AddrOf(span) => {\n                 self.tcx.sess.span_note(\n                     span,"}, {"sha": "33303808e84910ebb7062c4bf9147451ee7aaecd", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,12 +10,9 @@\n \n use super::combine::*;\n use super::lattice::*;\n-use super::equate::Equate;\n use super::higher_ranked::HigherRankedRelations;\n-use super::lub::Lub;\n-use super::sub::Sub;\n-use super::{cres, InferCtxt};\n-use super::{TypeTrace, Subtype};\n+use super::{cres};\n+use super::Subtype;\n \n use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n@@ -34,15 +31,30 @@ pub fn Glb<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Glb<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"glb\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n+    fn tag(&self) -> String { \"Glb\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Bivariant => self.bivariate().tys(a, b),\n+            ty::Contravariant => self.lub().tys(a, b),\n+        }\n+    }\n+\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Bivariant => self.bivariate().regions(a, b),\n+            ty::Contravariant => self.lub().regions(a, b),\n+        }\n+    }\n \n     fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         let tcx = self.fields.infcx.tcx;\n@@ -75,10 +87,6 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        self.lub().tys(a, b)\n-    }\n-\n     fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety> {\n         match (a, b) {\n           (Unsafety::Normal, _) | (_, Unsafety::Normal) => Ok(Unsafety::Normal),\n@@ -104,11 +112,6 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         Ok(self.fields.infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<'tcx, ty::Region> {\n-        self.lub().regions(a, b)\n-    }\n-\n     fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         super_lattice_tys(self, a, b)\n     }"}, {"sha": "a729156c88b3588e3d85e442d6878b6c526fcd15", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -31,7 +31,7 @@ pub trait HigherRankedRelations<'tcx> {\n         where T : Combineable<'tcx>;\n }\n \n-trait InferCtxtExt<'tcx> {\n+trait InferCtxtExt {\n     fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region>;\n \n     fn region_vars_confined_to_snapshot(&self,\n@@ -371,7 +371,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n     }))\n }\n \n-impl<'a,'tcx> InferCtxtExt<'tcx> for InferCtxt<'a,'tcx> {\n+impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n     fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r)\n     }"}, {"sha": "3570effa9fa709ff2de3c304db15f75f6dd4d428", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -9,13 +9,10 @@\n // except according to those terms.\n \n use super::combine::*;\n-use super::equate::Equate;\n-use super::glb::Glb;\n use super::higher_ranked::HigherRankedRelations;\n use super::lattice::*;\n-use super::sub::Sub;\n-use super::{cres, InferCtxt};\n-use super::{TypeTrace, Subtype};\n+use super::{cres};\n+use super::{Subtype};\n \n use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n@@ -34,15 +31,30 @@ pub fn Lub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Lub<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"lub\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n+    fn tag(&self) -> String { \"Lub\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Bivariant => self.bivariate().tys(a, b),\n+            ty::Contravariant => self.glb().tys(a, b),\n+        }\n+    }\n+\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Bivariant => self.bivariate().regions(a, b),\n+            ty::Contravariant => self.glb().regions(a, b),\n+        }\n+    }\n \n     fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         let tcx = self.tcx();\n@@ -70,10 +82,6 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        self.glb().tys(a, b)\n-    }\n-\n     fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety> {\n         match (a, b) {\n           (Unsafety::Unsafe, _) | (_, Unsafety::Unsafe) => Ok(Unsafety::Unsafe),\n@@ -90,11 +98,6 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         Ok(a.intersection(b))\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<'tcx, ty::Region> {\n-        self.glb().regions(a, b)\n-    }\n-\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),"}, {"sha": "b0576ff55ff7390605b889c93df55b3b10aa6b2f", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -45,6 +45,7 @@ use self::lub::Lub;\n use self::unify::{UnificationTable, InferCtxtMethodsForSimplyUnifiableTypes};\n use self::error_reporting::ErrorReporting;\n \n+pub mod bivariate;\n pub mod combine;\n pub mod equate;\n pub mod error_reporting;\n@@ -209,6 +210,9 @@ pub enum SubregionOrigin<'tcx> {\n     // Region in return type of invoked fn must enclose call\n     CallReturn(Span),\n \n+    // Operands must be in scope\n+    Operand(Span),\n+\n     // Region resulting from a `&` expr must enclose the `&` expr\n     AddrOf(Span),\n \n@@ -1194,6 +1198,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             CallRcvr(a) => a,\n             CallArg(a) => a,\n             CallReturn(a) => a,\n+            Operand(a) => a,\n             AddrOf(a) => a,\n             AutoBorrow(a) => a,\n             SafeDestructor(a) => a,\n@@ -1257,6 +1262,7 @@ impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n             CallRcvr(a) => format!(\"CallRcvr({})\", a.repr(tcx)),\n             CallArg(a) => format!(\"CallArg({})\", a.repr(tcx)),\n             CallReturn(a) => format!(\"CallReturn({})\", a.repr(tcx)),\n+            Operand(a) => format!(\"Operand({})\", a.repr(tcx)),\n             AddrOf(a) => format!(\"AddrOf({})\", a.repr(tcx)),\n             AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr(tcx)),\n             SafeDestructor(a) => format!(\"SafeDestructor({})\", a.repr(tcx)),"}, {"sha": "33da3092b2a256f8d4c8232f9eb50827603a87c8", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,12 +10,8 @@\n \n use super::combine::*;\n use super::{cres, CresCompare};\n-use super::equate::Equate;\n-use super::glb::Glb;\n use super::higher_ranked::HigherRankedRelations;\n-use super::InferCtxt;\n-use super::lub::Lub;\n-use super::{TypeTrace, Subtype};\n+use super::{Subtype};\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n use middle::ty::{BuiltinBounds};\n@@ -37,28 +33,30 @@ pub fn Sub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Sub<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"sub\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n-\n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n-\n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        Sub(self.fields.switch_expected()).tys(b, a)\n+    fn tag(&self) -> String { \"Sub\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Bivariant => self.bivariate().tys(a, b),\n+            ty::Contravariant => Sub(self.fields.switch_expected()).tys(b, a),\n+        }\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                     -> cres<'tcx, ty::Region> {\n-                         let opp = CombineFields {\n-                             a_is_expected: !self.fields.a_is_expected,\n-                             ..self.fields.clone()\n-                         };\n-                         Sub(opp).regions(b, a)\n-                     }\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Bivariant => self.bivariate().regions(a, b),\n+            ty::Contravariant => Sub(self.fields.switch_expected()).regions(b, a),\n+        }\n+    }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\","}, {"sha": "a856137af090a706c68461ad0beac834086e1aa5", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,6 +14,7 @@ use self::UndoEntry::*;\n \n use middle::ty::{self, Ty};\n use std::cmp::min;\n+use std::marker::PhantomData;\n use std::mem;\n use std::u32;\n use util::snapshot_vec as sv;\n@@ -42,28 +43,29 @@ enum UndoEntry {\n     Relate(ty::TyVid, ty::TyVid),\n }\n \n-struct Delegate<'tcx>;\n+struct Delegate<'tcx>(PhantomData<&'tcx ()>);\n \n type Relation = (RelationDir, ty::TyVid);\n \n #[derive(Copy, PartialEq, Debug)]\n pub enum RelationDir {\n-    SubtypeOf, SupertypeOf, EqTo\n+    SubtypeOf, SupertypeOf, EqTo, BiTo\n }\n \n impl RelationDir {\n     fn opposite(self) -> RelationDir {\n         match self {\n             SubtypeOf => SupertypeOf,\n             SupertypeOf => SubtypeOf,\n-            EqTo => EqTo\n+            EqTo => EqTo,\n+            BiTo => BiTo,\n         }\n     }\n }\n \n impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new() -> TypeVariableTable<'tcx> {\n-        TypeVariableTable { values: sv::SnapshotVec::new(Delegate) }\n+        TypeVariableTable { values: sv::SnapshotVec::new(Delegate(PhantomData)) }\n     }\n \n     fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {"}, {"sha": "0675cec6f69b5d61a0dac228d73d24f8c3108cf3", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -18,6 +18,7 @@ use middle::infer::{uok, ures};\n use middle::infer::InferCtxt;\n use std::cell::RefCell;\n use std::fmt::Debug;\n+use std::marker::PhantomData;\n use syntax::ast;\n use util::snapshot_vec as sv;\n \n@@ -79,7 +80,7 @@ pub struct UnificationTable<K:UnifyKey> {\n /// made during the snapshot may either be *committed* or *rolled back*.\n pub struct Snapshot<K:UnifyKey> {\n     // Link snapshot to the key type `K` of the table.\n-    marker: marker::CovariantType<K>,\n+    marker: marker::PhantomData<K>,\n     snapshot: sv::Snapshot,\n }\n \n@@ -92,7 +93,7 @@ pub struct Node<K:UnifyKey> {\n }\n \n #[derive(Copy)]\n-pub struct Delegate<K>;\n+pub struct Delegate<K>(PhantomData<K>);\n \n // We can't use V:LatticeValue, much as I would like to,\n // because frequently the pattern is that V=Option<U> for some\n@@ -102,14 +103,14 @@ pub struct Delegate<K>;\n impl<K:UnifyKey> UnificationTable<K> {\n     pub fn new() -> UnificationTable<K> {\n         UnificationTable {\n-            values: sv::SnapshotVec::new(Delegate),\n+            values: sv::SnapshotVec::new(Delegate(PhantomData)),\n         }\n     }\n \n     /// Starts a new snapshot. Each snapshot must be either\n     /// rolled back or committed in a \"LIFO\" (stack) order.\n     pub fn snapshot(&mut self) -> Snapshot<K> {\n-        Snapshot { marker: marker::CovariantType::<K>,\n+        Snapshot { marker: marker::PhantomData::<K>,\n                    snapshot: self.values.start_snapshot() }\n     }\n "}, {"sha": "56c5928a132b14cd56ac92d19588bc227c912c55", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -306,12 +306,13 @@ lets_do_this! {\n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n     OwnedBoxLangItem,                \"owned_box\",               owned_box;\n \n+    PhantomFnItem,                   \"phantom_fn\",              phantom_fn;\n     PhantomDataItem,                 \"phantom_data\",            phantom_data;\n \n+    // Deprecated:\n     CovariantTypeItem,               \"covariant_type\",          covariant_type;\n     ContravariantTypeItem,           \"contravariant_type\",      contravariant_type;\n     InvariantTypeItem,               \"invariant_type\",          invariant_type;\n-\n     CovariantLifetimeItem,           \"covariant_lifetime\",      covariant_lifetime;\n     ContravariantLifetimeItem,       \"contravariant_lifetime\",  contravariant_lifetime;\n     InvariantLifetimeItem,           \"invariant_lifetime\",      invariant_lifetime;"}, {"sha": "e199a60c370e30cf732f0dbb2d3a300f9276e3f8", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 72, "deletions": 29, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,53 +10,96 @@\n \n //! See `doc.rs` for high-level documentation\n \n+use super::Normalized;\n use super::SelectionContext;\n-use super::{Obligation, ObligationCause};\n+use super::{ObligationCause};\n+use super::PredicateObligation;\n use super::project;\n use super::util;\n \n use middle::subst::{Subst, TypeSpace};\n-use middle::ty::{self, Ty};\n-use middle::infer::InferCtxt;\n+use middle::ty::{self, ToPolyTraitRef, Ty};\n+use middle::infer::{self, InferCtxt};\n use std::collections::HashSet;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n use util::ppaux::Repr;\n \n-pub fn impl_can_satisfy(infcx: &InferCtxt,\n-                        impl1_def_id: ast::DefId,\n-                        impl2_def_id: ast::DefId)\n-                        -> bool\n+/// True if there exist types that satisfy both of the two given impls.\n+pub fn overlapping_impls(infcx: &InferCtxt,\n+                         impl1_def_id: ast::DefId,\n+                         impl2_def_id: ast::DefId)\n+                         -> bool\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={}, \\\n            impl2_def_id={})\",\n            impl1_def_id.repr(infcx.tcx),\n            impl2_def_id.repr(infcx.tcx));\n \n-    let param_env = ty::empty_parameter_environment(infcx.tcx);\n-    let mut selcx = SelectionContext::intercrate(infcx, &param_env);\n-    let cause = ObligationCause::dummy();\n-\n-    // `impl1` provides an implementation of `Foo<X,Y> for Z`.\n-    let impl1_substs =\n-        util::fresh_substs_for_impl(infcx, DUMMY_SP, impl1_def_id);\n-    let impl1_trait_ref =\n-        (*ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()).subst(infcx.tcx, &impl1_substs);\n-    let impl1_trait_ref =\n-        project::normalize(&mut selcx, cause.clone(), &impl1_trait_ref);\n-\n-    // Determine whether `impl2` can provide an implementation for those\n-    // same types.\n-    let obligation = Obligation::new(cause,\n-                                     ty::Binder(ty::TraitPredicate {\n-                                         trait_ref: Rc::new(impl1_trait_ref.value),\n-                                     }));\n-    debug!(\"impl_can_satisfy(obligation={})\", obligation.repr(infcx.tcx));\n-    selcx.evaluate_impl(impl2_def_id, &obligation) &&\n-        impl1_trait_ref.obligations.iter().all(\n-            |o| selcx.evaluate_obligation(o))\n+    let param_env = &ty::empty_parameter_environment(infcx.tcx);\n+    let selcx = &mut SelectionContext::intercrate(infcx, param_env);\n+    infcx.probe(|_| {\n+        overlap(selcx, impl1_def_id, impl2_def_id) || overlap(selcx, impl2_def_id, impl1_def_id)\n+    })\n+}\n+\n+/// Can the types from impl `a` be used to satisfy impl `b`?\n+/// (Including all conditions)\n+fn overlap(selcx: &mut SelectionContext,\n+           a_def_id: ast::DefId,\n+           b_def_id: ast::DefId)\n+           -> bool\n+{\n+    let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx, a_def_id);\n+    let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx, b_def_id);\n+\n+    // Does `a <: b` hold? If not, no overlap.\n+    if let Err(_) = infer::mk_sub_poly_trait_refs(selcx.infcx(),\n+                                                  true,\n+                                                  infer::Misc(DUMMY_SP),\n+                                                  a_trait_ref.to_poly_trait_ref(),\n+                                                  b_trait_ref.to_poly_trait_ref()) {\n+        return false;\n+    }\n+\n+    // Are any of the obligations unsatisfiable? If so, no overlap.\n+    a_obligations.iter()\n+                 .chain(b_obligations.iter())\n+                 .all(|o| selcx.evaluate_obligation(o))\n+}\n+\n+/// Instantiate fresh variables for all bound parameters of the impl\n+/// and return the impl trait ref with those variables substituted.\n+fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                                     impl_def_id: ast::DefId)\n+                                     -> (Rc<ty::TraitRef<'tcx>>,\n+                                         Vec<PredicateObligation<'tcx>>)\n+{\n+    let impl_substs =\n+        &util::fresh_substs_for_impl(selcx.infcx(), DUMMY_SP, impl_def_id);\n+    let impl_trait_ref =\n+        ty::impl_trait_ref(selcx.tcx(), impl_def_id).unwrap();\n+    let impl_trait_ref =\n+        impl_trait_ref.subst(selcx.tcx(), impl_substs);\n+    let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n+        project::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n+\n+    let predicates = ty::lookup_predicates(selcx.tcx(), impl_def_id);\n+    let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n+    let Normalized { value: predicates, obligations: normalization_obligations2 } =\n+        project::normalize(selcx, ObligationCause::dummy(), &predicates);\n+    let impl_obligations =\n+        util::predicates_for_generics(selcx.tcx(), ObligationCause::dummy(), 0, &predicates);\n+\n+    let impl_obligations: Vec<_> =\n+        impl_obligations.into_iter()\n+        .chain(normalization_obligations1.into_iter())\n+        .chain(normalization_obligations2.into_iter())\n+        .collect();\n+\n+    (impl_trait_ref, impl_obligations)\n }\n \n pub enum OrphanCheckErr<'tcx> {"}, {"sha": "a63dcfc24a10ec6d76314be312d3e0d81a671433", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -28,6 +28,7 @@ use util::ppaux::{Repr, UserString};\n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n+pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n@@ -270,16 +271,6 @@ pub struct VtableObjectData<'tcx> {\n     pub object_ty: Ty<'tcx>,\n }\n \n-/// True if there exist types that satisfy both of the two given impls.\n-pub fn overlapping_impls(infcx: &InferCtxt,\n-                         impl1_def_id: ast::DefId,\n-                         impl2_def_id: ast::DefId)\n-                         -> bool\n-{\n-    coherence::impl_can_satisfy(infcx, impl1_def_id, impl2_def_id) &&\n-    coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n-}\n-\n /// Creates predicate obligations from the generic bounds.\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,"}, {"sha": "0e29892084175d180047412a39c9a2e936c750a7", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -132,6 +132,7 @@ pub enum MethodMatchedData {\n /// parameters) that would have to be inferred from the impl.\n #[derive(PartialEq,Eq,Debug,Clone)]\n enum SelectionCandidate<'tcx> {\n+    PhantomFnCandidate,\n     BuiltinCandidate(ty::BuiltinBound),\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(ast::DefId),\n@@ -793,15 +794,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                stack: &TraitObligationStack<'o, 'tcx>)\n                                -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n-        // Check for overflow.\n-\n         let TraitObligationStack { obligation, .. } = *stack;\n \n         let mut candidates = SelectionCandidateSet {\n             vec: Vec::new(),\n             ambiguous: false\n         };\n \n+        // Check for the `PhantomFn` trait. This is really just a\n+        // special annotation that is *always* considered to match, no\n+        // matter what the type parameters are etc.\n+        if self.tcx().lang_items.phantom_fn() == Some(obligation.predicate.def_id()) {\n+            candidates.vec.push(PhantomFnCandidate);\n+            return Ok(candidates);\n+        }\n+\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n \n@@ -1629,6 +1636,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     try!(self.confirm_builtin_candidate(obligation, builtin_bound))))\n             }\n \n+            PhantomFnCandidate |\n             ErrorCandidate => {\n                 Ok(VtableBuiltin(VtableBuiltinData { nested: VecPerParamSpace::empty() }))\n             }\n@@ -2295,6 +2303,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n+            PhantomFnCandidate => format!(\"PhantomFnCandidate\"),\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({:?})\", b),\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),"}, {"sha": "e9908397f970387782fb097c4d478013d92c480a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -3008,6 +3008,13 @@ impl<'tcx> TyS<'tcx> {\n         assert_eq!(r, Some(self));\n         walker\n     }\n+\n+    pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n+        match self.sty {\n+            ty::ty_param(ref d) => Some(d.clone()),\n+            _ => None,\n+        }\n+    }\n }\n \n pub fn walk_ty<'tcx, F>(ty_root: Ty<'tcx>, mut f: F)"}, {"sha": "1639772103b7aef5f95e7c5b6a6674d99b083152", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -306,10 +306,10 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n         // Crate-local:\n         //\n         // meh.\n-        struct Visitor<'a, 'b: 'a, 'tcx: 'a + 'b> {\n+        struct Visitor<'a> {\n             traits: &'a mut AllTraitsVec,\n         }\n-        impl<'v,'a, 'b, 'tcx> visit::Visitor<'v> for Visitor<'a, 'b, 'tcx> {\n+        impl<'v, 'a> visit::Visitor<'v> for Visitor<'a> {\n             fn visit_item(&mut self, i: &'v ast::Item) {\n                 match i.node {\n                     ast::ItemTrait(..) => {"}, {"sha": "82abff8c425f42c5aca7d2aa62f73ac9c85a78de", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -626,6 +626,20 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr);\n         }\n \n+        ast::ExprBinary(_, ref lhs, ref rhs) => {\n+            // If you do `x OP y`, then the types of `x` and `y` must\n+            // outlive the operation you are performing.\n+            let lhs_ty = rcx.resolve_expr_type_adjusted(&**lhs);\n+            let rhs_ty = rcx.resolve_expr_type_adjusted(&**rhs);\n+            for &ty in [lhs_ty, rhs_ty].iter() {\n+                type_must_outlive(rcx,\n+                                  infer::Operand(expr.span),\n+                                  ty,\n+                                  ty::ReScope(CodeExtent::from_node_id(expr.id)));\n+            }\n+            visit::walk_expr(rcx, expr);\n+        }\n+\n         ast::ExprUnary(op, ref lhs) if has_method_map => {\n             let implicitly_ref_args = !ast_util::is_by_value_unop(op);\n "}, {"sha": "2601c4d275291d144762ff46ac1484aee3e3b5eb", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 145, "deletions": 13, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,21 +10,22 @@\n \n use astconv::AstConv;\n use check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n+use constrained_type_params::identify_constrained_type_params;\n use CrateCtxt;\n use middle::region;\n-use middle::subst;\n+use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n use middle::ty::{self, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr, UserString};\n \n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_util::{local_def};\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, special_idents};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -38,6 +39,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         CheckTypeWellFormedVisitor { ccx: ccx, cache: HashSet::new() }\n     }\n \n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.ccx.tcx\n+    }\n+\n     /// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n     /// well-formed, meaning that they do not require any constraints not declared in the struct\n     /// definition itself. For example, this definition would be illegal:\n@@ -96,19 +101,29 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             ast::ItemConst(..) => {\n                 self.check_item_type(item);\n             }\n-            ast::ItemStruct(ref struct_def, _) => {\n-                self.check_type_defn(item, |fcx| vec![struct_variant(fcx, &**struct_def)]);\n+            ast::ItemStruct(ref struct_def, ref ast_generics) => {\n+                self.check_type_defn(item, |fcx| {\n+                    vec![struct_variant(fcx, &**struct_def)]\n+                });\n+\n+                self.check_variances_for_type_defn(item, ast_generics);\n             }\n-            ast::ItemEnum(ref enum_def, _) => {\n-                self.check_type_defn(item, |fcx| enum_variants(fcx, enum_def));\n+            ast::ItemEnum(ref enum_def, ref ast_generics) => {\n+                self.check_type_defn(item, |fcx| {\n+                    enum_variants(fcx, enum_def)\n+                });\n+\n+                self.check_variances_for_type_defn(item, ast_generics);\n             }\n-            ast::ItemTrait(..) => {\n+            ast::ItemTrait(_, ref ast_generics, _, _) => {\n                 let trait_predicates =\n                     ty::lookup_predicates(ccx.tcx, local_def(item.id));\n                 reject_non_type_param_bounds(\n                     ccx.tcx,\n                     item.span,\n                     &trait_predicates);\n+                self.check_variances(item, ast_generics, &trait_predicates,\n+                                     self.tcx().lang_items.phantom_fn());\n             }\n             _ => {}\n         }\n@@ -276,6 +291,123 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n         });\n     }\n+\n+    fn check_variances_for_type_defn(&self,\n+                                     item: &ast::Item,\n+                                     ast_generics: &ast::Generics)\n+    {\n+        let item_def_id = local_def(item.id);\n+        let predicates = ty::lookup_predicates(self.tcx(), item_def_id);\n+        self.check_variances(item,\n+                             ast_generics,\n+                             &predicates,\n+                             self.tcx().lang_items.phantom_data());\n+    }\n+\n+    fn check_variances(&self,\n+                       item: &ast::Item,\n+                       ast_generics: &ast::Generics,\n+                       ty_predicates: &ty::GenericPredicates<'tcx>,\n+                       suggested_marker_id: Option<ast::DefId>)\n+    {\n+        let variance_lang_items = &[\n+            self.tcx().lang_items.phantom_fn(),\n+            self.tcx().lang_items.phantom_data(),\n+        ];\n+\n+        let item_def_id = local_def(item.id);\n+        let is_lang_item = variance_lang_items.iter().any(|n| *n == Some(item_def_id));\n+        if is_lang_item {\n+            return;\n+        }\n+\n+        let variances = ty::item_variances(self.tcx(), item_def_id);\n+\n+        let mut constrained_parameters: HashSet<_> =\n+            variances.types\n+            .iter_enumerated()\n+            .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n+            .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n+            .collect();\n+\n+        identify_constrained_type_params(self.tcx(),\n+                                         ty_predicates.predicates.as_slice(),\n+                                         None,\n+                                         &mut constrained_parameters);\n+\n+        for (space, index, _) in variances.types.iter_enumerated() {\n+            let param_ty = self.param_ty(ast_generics, space, index);\n+            if constrained_parameters.contains(&param_ty) {\n+                continue;\n+            }\n+            let span = self.ty_param_span(ast_generics, item, space, index);\n+            self.report_bivariance(span, param_ty.name, suggested_marker_id);\n+        }\n+\n+        for (space, index, &variance) in variances.regions.iter_enumerated() {\n+            if variance != ty::Bivariant {\n+                continue;\n+            }\n+\n+            assert_eq!(space, TypeSpace);\n+            let span = ast_generics.lifetimes[index].lifetime.span;\n+            let name = ast_generics.lifetimes[index].lifetime.name;\n+            self.report_bivariance(span, name, suggested_marker_id);\n+        }\n+    }\n+\n+    fn param_ty(&self,\n+                ast_generics: &ast::Generics,\n+                space: ParamSpace,\n+                index: usize)\n+                -> ty::ParamTy\n+    {\n+        let name = match space {\n+            TypeSpace => ast_generics.ty_params[index].ident.name,\n+            SelfSpace => special_idents::type_self.name,\n+            FnSpace => self.tcx().sess.bug(\"Fn space occupied?\"),\n+        };\n+\n+        ty::ParamTy { space: space, idx: index as u32, name: name }\n+    }\n+\n+    fn ty_param_span(&self,\n+                     ast_generics: &ast::Generics,\n+                     item: &ast::Item,\n+                     space: ParamSpace,\n+                     index: usize)\n+                     -> Span\n+    {\n+        match space {\n+            TypeSpace => ast_generics.ty_params[index].span,\n+            SelfSpace => item.span,\n+            FnSpace => self.tcx().sess.span_bug(item.span, \"Fn space occupied?\"),\n+        }\n+    }\n+\n+    fn report_bivariance(&self,\n+                         span: Span,\n+                         param_name: ast::Name,\n+                         suggested_marker_id: Option<ast::DefId>)\n+    {\n+        self.tcx().sess.span_err(\n+            span,\n+            &format!(\"parameter `{}` is never used\",\n+                     param_name.user_string(self.tcx()))[]);\n+\n+        match suggested_marker_id {\n+            Some(def_id) => {\n+                self.tcx().sess.span_help(\n+                    span,\n+                    format!(\"consider removing `{}` or using a marker such as `{}`\",\n+                            param_name.user_string(self.tcx()),\n+                            ty::item_path_str(self.tcx(), def_id)).as_slice());\n+            }\n+            None => {\n+                // no lang items, no help!\n+            }\n+        }\n+    }\n }\n \n // Reject any predicates that do not involve a type parameter.\n@@ -343,9 +475,9 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         match fk {\n             visit::FkFnBlock | visit::FkItemFn(..) => {}\n             visit::FkMethod(..) => {\n-                match ty::impl_or_trait_item(self.ccx.tcx, local_def(id)) {\n+                match ty::impl_or_trait_item(self.tcx(), local_def(id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n-                        reject_shadowing_type_parameters(self.ccx.tcx, span, &ty_method.generics)\n+                        reject_shadowing_type_parameters(self.tcx(), span, &ty_method.generics)\n                     }\n                     _ => {}\n                 }\n@@ -359,14 +491,14 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             &ast::TraitItem::ProvidedMethod(_) |\n             &ast::TraitItem::TypeTraitItem(_) => {},\n             &ast::TraitItem::RequiredMethod(ref method) => {\n-                match ty::impl_or_trait_item(self.ccx.tcx, local_def(method.id)) {\n+                match ty::impl_or_trait_item(self.tcx(), local_def(method.id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                         reject_non_type_param_bounds(\n-                            self.ccx.tcx,\n+                            self.tcx(),\n                             method.span,\n                             &ty_method.predicates);\n                         reject_shadowing_type_parameters(\n-                            self.ccx.tcx,\n+                            self.tcx(),\n                             method.span,\n                             &ty_method.generics);\n                     }"}, {"sha": "0b78af18e2617b2869bba2d8431488275e11f620", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 49, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -87,6 +87,7 @@ There are some shortcomings in this design:\n \n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n use middle::def;\n+use constrained_type_params::identify_constrained_type_params;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n@@ -1960,51 +1961,15 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let mut input_parameters: HashSet<_> =\n         impl_trait_ref.iter()\n                       .flat_map(|t| t.input_types().iter()) // Types in trait ref, if any\n-                      .chain(Some(impl_scheme.ty).iter())  // Self type, always\n+                      .chain(Some(impl_scheme.ty).iter())   // Self type, always\n                       .flat_map(|t| t.walk())\n-                      .filter_map(to_opt_param_ty)\n+                      .filter_map(|t| t.as_opt_param_ty())\n                       .collect();\n \n-    loop {\n-        let num_inputs = input_parameters.len();\n-\n-        let projection_predicates =\n-            impl_predicates.predicates\n-                           .iter()\n-                           .filter_map(|predicate| {\n-                               match *predicate {\n-                                   // Ignore higher-ranked binders. For the purposes\n-                                   // of this check, they don't matter because they\n-                                   // only affect named regions, and we're just\n-                                   // concerned about type parameters here.\n-                                   ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n-                                   _ => None,\n-                               }\n-                           });\n-\n-        for projection in projection_predicates {\n-            // Special case: watch out for some kind of sneaky attempt\n-            // to project out an associated type defined by this very trait.\n-            if Some(projection.projection_ty.trait_ref.clone()) == impl_trait_ref {\n-                continue;\n-            }\n-\n-            let relies_only_on_inputs =\n-                projection.projection_ty.trait_ref.input_types().iter()\n-                .flat_map(|t| t.walk())\n-                .filter_map(to_opt_param_ty)\n-                .all(|t| input_parameters.contains(&t));\n-\n-            if relies_only_on_inputs {\n-                input_parameters.extend(\n-                    projection.ty.walk().filter_map(to_opt_param_ty));\n-            }\n-        }\n-\n-        if input_parameters.len() == num_inputs {\n-            break;\n-        }\n-    }\n+    identify_constrained_type_params(tcx,\n+                                     impl_predicates.predicates.as_slice(),\n+                                     impl_trait_ref,\n+                                     &mut input_parameters);\n \n     for (index, ty_param) in ast_generics.ty_params.iter().enumerate() {\n         let param_ty = ty::ParamTy { space: TypeSpace,\n@@ -2025,11 +1990,4 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         }\n     }\n-\n-    fn to_opt_param_ty<'tcx>(ty: Ty<'tcx>) -> Option<ty::ParamTy> {\n-        match ty.sty {\n-            ty::ty_param(ref d) => Some(d.clone()),\n-            _ => None,\n-        }\n-    }\n }"}, {"sha": "83d7e98500007318c645114089fd8b54decb032e", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{self};\n+\n+use std::collections::HashSet;\n+use std::rc::Rc;\n+\n+pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,\n+                                              predicates: &[ty::Predicate<'tcx>],\n+                                              impl_trait_ref: Option<Rc<ty::TraitRef<'tcx>>>,\n+                                              input_parameters: &mut HashSet<ty::ParamTy>)\n+{\n+    loop {\n+        let num_inputs = input_parameters.len();\n+\n+        let projection_predicates =\n+            predicates.iter()\n+                      .filter_map(|predicate| {\n+                          match *predicate {\n+                              // Ignore higher-ranked binders. For the purposes\n+                              // of this check, they don't matter because they\n+                              // only affect named regions, and we're just\n+                              // concerned about type parameters here.\n+                              ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n+                              _ => None,\n+                          }\n+                      });\n+\n+        for projection in projection_predicates {\n+            // Special case: watch out for some kind of sneaky attempt\n+            // to project out an associated type defined by this very trait.\n+            if Some(projection.projection_ty.trait_ref.clone()) == impl_trait_ref {\n+                continue;\n+            }\n+\n+            let relies_only_on_inputs =\n+                projection.projection_ty.trait_ref.input_types()\n+                                                  .iter()\n+                                                  .flat_map(|t| t.walk())\n+                                                  .filter_map(|t| t.as_opt_param_ty())\n+                                                  .all(|t| input_parameters.contains(&t));\n+\n+            if relies_only_on_inputs {\n+                input_parameters.extend(\n+                    projection.ty.walk().filter_map(|t| t.as_opt_param_ty()));\n+            }\n+        }\n+\n+        if input_parameters.len() == num_inputs {\n+            break;\n+        }\n+    }\n+}"}, {"sha": "b5dca0bd4f6f42348e2981d23bf079541b91986b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -123,6 +123,7 @@ mod check;\n mod rscope;\n mod astconv;\n mod collect;\n+mod constrained_type_params;\n mod coherence;\n mod variance;\n "}, {"sha": "1adcf133bf3e0788490204a73c62a4e120497526", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 269, "deletions": 125, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -187,6 +187,22 @@\n //!   and the definition-site variance of the [corresponding] type parameter\n //!   of a class `C` is `V1`, then the variance of `X` in the type expression\n //!   `C<E>` is `V3 = V1.xform(V2)`.\n+//!\n+//! ### Constraints\n+//!\n+//! If I have a struct or enum with where clauses:\n+//!\n+//!     struct Foo<T:Bar> { ... }\n+//!\n+//! you might wonder whether the variance of `T` with respect to `Bar`\n+//! affects the variance `T` with respect to `Foo`. I claim no.  The\n+//! reason: assume that `T` is invariant w/r/t `Bar` but covariant w/r/t\n+//! `Foo`. And then we have a `Foo<X>` that is upcast to `Foo<Y>`, where\n+//! `X <: Y`. However, while `X : Bar`, `Y : Bar` does not hold.  In that\n+//! case, the upcast will be illegal, but not because of a variance\n+//! failure, but rather because the target type `Foo<Y>` is itself just\n+//! not well-formed. Basically we get to assume well-formedness of all\n+//! types involved before considering variance.\n \n use self::VarianceTerm::*;\n use self::ParamKind::*;\n@@ -199,7 +215,6 @@ use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace}\n use middle::ty::{self, Ty};\n use std::fmt;\n use std::rc::Rc;\n-use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -258,6 +273,11 @@ struct TermsContext<'a, 'tcx: 'a> {\n \n     empty_variances: Rc<ty::ItemVariances>,\n \n+    // For marker types, UnsafeCell, and other lang items where\n+    // variance is hardcoded, records the item-id and the hardcoded\n+    // variance.\n+    lang_items: Vec<(ast::NodeId, Vec<ty::Variance>)>,\n+\n     // Maps from the node id of a type/generic parameter to the\n     // corresponding inferred index.\n     inferred_map: NodeMap<InferredIndex>,\n@@ -269,7 +289,7 @@ struct TermsContext<'a, 'tcx: 'a> {\n #[derive(Copy, Debug, PartialEq)]\n enum ParamKind {\n     TypeParam,\n-    RegionParam\n+    RegionParam,\n }\n \n struct InferredInfo<'a> {\n@@ -279,6 +299,11 @@ struct InferredInfo<'a> {\n     index: uint,\n     param_id: ast::NodeId,\n     term: VarianceTermPtr<'a>,\n+\n+    // Initial value to use for this parameter when inferring\n+    // variance. For most parameters, this is Bivariant. But for lang\n+    // items and input type parameters on traits, it is different.\n+    initial_variance: ty::Variance,\n }\n \n fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n@@ -291,6 +316,8 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n         inferred_map: NodeMap(),\n         inferred_infos: Vec::new(),\n \n+        lang_items: lang_items(tcx),\n+\n         // cache and share the variance struct used for items with\n         // no type/region parameters\n         empty_variances: Rc::new(ty::ItemVariances {\n@@ -304,7 +331,78 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n     terms_cx\n }\n \n+fn lang_items(tcx: &ty::ctxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n+    let all = vec![\n+        (tcx.lang_items.phantom_fn(), vec![ty::Contravariant, ty::Covariant]),\n+        (tcx.lang_items.phantom_data(), vec![ty::Covariant]),\n+        (tcx.lang_items.unsafe_cell_type(), vec![ty::Invariant]),\n+\n+        // Deprecated:\n+        (tcx.lang_items.covariant_type(), vec![ty::Covariant]),\n+        (tcx.lang_items.contravariant_type(), vec![ty::Contravariant]),\n+        (tcx.lang_items.invariant_type(), vec![ty::Invariant]),\n+        (tcx.lang_items.covariant_lifetime(), vec![ty::Covariant]),\n+        (tcx.lang_items.contravariant_lifetime(), vec![ty::Contravariant]),\n+        (tcx.lang_items.invariant_lifetime(), vec![ty::Invariant]),\n+\n+        ];\n+\n+    all.into_iter()\n+       .filter(|&(ref d,_)| d.is_some())\n+       .filter(|&(ref d,_)| d.as_ref().unwrap().krate == ast::LOCAL_CRATE)\n+       .map(|(d, v)| (d.unwrap().node, v))\n+       .collect()\n+}\n+\n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n+    fn add_inferreds_for_item(&mut self,\n+                              item_id: ast::NodeId,\n+                              has_self: bool,\n+                              generics: &ast::Generics)\n+    {\n+        /*!\n+         * Add \"inferreds\" for the generic parameters declared on this\n+         * item. This has a lot of annoying parameters because we are\n+         * trying to drive this from the AST, rather than the\n+         * ty::Generics, so that we can get span info -- but this\n+         * means we must accommodate syntactic distinctions.\n+         */\n+\n+        // NB: In the code below for writing the results back into the\n+        // tcx, we rely on the fact that all inferreds for a particular\n+        // item are assigned continuous indices.\n+\n+        let inferreds_on_entry = self.num_inferred();\n+\n+        if has_self {\n+            self.add_inferred(item_id, TypeParam, SelfSpace, 0, item_id);\n+        }\n+\n+        for (i, p) in generics.lifetimes.iter().enumerate() {\n+            let id = p.lifetime.id;\n+            self.add_inferred(item_id, RegionParam, TypeSpace, i, id);\n+        }\n+\n+        for (i, p) in generics.ty_params.iter().enumerate() {\n+            self.add_inferred(item_id, TypeParam, TypeSpace, i, p.id);\n+        }\n+\n+        // If this item has no type or lifetime parameters,\n+        // then there are no variances to infer, so just\n+        // insert an empty entry into the variance map.\n+        // Arguably we could just leave the map empty in this\n+        // case but it seems cleaner to be able to distinguish\n+        // \"invalid item id\" from \"item id with no\n+        // parameters\".\n+        if self.num_inferred() == inferreds_on_entry {\n+            let newly_added =\n+                self.tcx.item_variance_map.borrow_mut().insert(\n+                    ast_util::local_def(item_id),\n+                    self.empty_variances.clone()).is_none();\n+            assert!(newly_added);\n+        }\n+    }\n+\n     fn add_inferred(&mut self,\n                     item_id: ast::NodeId,\n                     kind: ParamKind,\n@@ -313,21 +411,48 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                     param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n         let term = self.arena.alloc(InferredTerm(inf_index));\n+        let initial_variance = self.pick_initial_variance(item_id, space, index);\n         self.inferred_infos.push(InferredInfo { item_id: item_id,\n                                                 kind: kind,\n                                                 space: space,\n                                                 index: index,\n                                                 param_id: param_id,\n-                                                term: term });\n+                                                term: term,\n+                                                initial_variance: initial_variance });\n         let newly_added = self.inferred_map.insert(param_id, inf_index).is_none();\n         assert!(newly_added);\n \n-        debug!(\"add_inferred(item_id={}, \\\n+        debug!(\"add_inferred(item_path={}, \\\n+                item_id={}, \\\n                 kind={:?}, \\\n+                space={:?}, \\\n                 index={}, \\\n-                param_id={},\n-                inf_index={:?})\",\n-                item_id, kind, index, param_id, inf_index);\n+                param_id={}, \\\n+                inf_index={:?}, \\\n+                initial_variance={:?})\",\n+               ty::item_path_str(self.tcx, ast_util::local_def(item_id)),\n+               item_id, kind, space, index, param_id, inf_index,\n+               initial_variance);\n+    }\n+\n+    fn pick_initial_variance(&self,\n+                             item_id: ast::NodeId,\n+                             space: ParamSpace,\n+                             index: uint)\n+                             -> ty::Variance\n+    {\n+        match space {\n+            SelfSpace | FnSpace => {\n+                ty::Bivariant\n+            }\n+\n+            TypeSpace => {\n+                match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n+                    Some(&(_, ref variances)) => variances[index],\n+                    None => ty::Bivariant\n+                }\n+            }\n+        }\n     }\n \n     fn num_inferred(&self) -> uint {\n@@ -339,44 +464,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n \n-        let inferreds_on_entry = self.num_inferred();\n-\n-        // NB: In the code below for writing the results back into the\n-        // tcx, we rely on the fact that all inferreds for a particular\n-        // item are assigned continuous indices.\n-        match item.node {\n-            ast::ItemTrait(..) => {\n-                self.add_inferred(item.id, TypeParam, SelfSpace, 0, item.id);\n-            }\n-            _ => { }\n-        }\n-\n         match item.node {\n             ast::ItemEnum(_, ref generics) |\n-            ast::ItemStruct(_, ref generics) |\n+            ast::ItemStruct(_, ref generics) => {\n+                self.add_inferreds_for_item(item.id, false, generics);\n+            }\n             ast::ItemTrait(_, ref generics, _, _) => {\n-                for (i, p) in generics.lifetimes.iter().enumerate() {\n-                    let id = p.lifetime.id;\n-                    self.add_inferred(item.id, RegionParam, TypeSpace, i, id);\n-                }\n-                for (i, p) in generics.ty_params.iter().enumerate() {\n-                    self.add_inferred(item.id, TypeParam, TypeSpace, i, p.id);\n-                }\n-\n-                // If this item has no type or lifetime parameters,\n-                // then there are no variances to infer, so just\n-                // insert an empty entry into the variance map.\n-                // Arguably we could just leave the map empty in this\n-                // case but it seems cleaner to be able to distinguish\n-                // \"invalid item id\" from \"item id with no\n-                // parameters\".\n-                if self.num_inferred() == inferreds_on_entry {\n-                    let newly_added = self.tcx.item_variance_map.borrow_mut().insert(\n-                        ast_util::local_def(item.id),\n-                        self.empty_variances.clone()).is_none();\n-                    assert!(newly_added);\n-                }\n-\n+                self.add_inferreds_for_item(item.id, true, generics);\n                 visit::walk_item(self, item);\n             }\n \n@@ -404,16 +498,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n struct ConstraintContext<'a, 'tcx: 'a> {\n     terms_cx: TermsContext<'a, 'tcx>,\n \n-    // These are the def-id of the std::marker::InvariantType,\n-    // std::marker::InvariantLifetime, and so on. The arrays\n-    // are indexed by the `ParamKind` (type, lifetime, self). Note\n-    // that there are no marker types for self, so the entries for\n-    // self are always None.\n-    invariant_lang_items: [Option<ast::DefId>; 2],\n-    covariant_lang_items: [Option<ast::DefId>; 2],\n-    contravariant_lang_items: [Option<ast::DefId>; 2],\n-    unsafe_cell_lang_item: Option<ast::DefId>,\n-\n     // These are pointers to common `ConstantTerm` instances\n     covariant: VarianceTermPtr<'a>,\n     contravariant: VarianceTermPtr<'a>,\n@@ -433,40 +517,14 @@ struct Constraint<'a> {\n \n fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n                                         krate: &ast::Crate)\n-                                        -> ConstraintContext<'a, 'tcx> {\n-    let mut invariant_lang_items = [None; 2];\n-    let mut covariant_lang_items = [None; 2];\n-    let mut contravariant_lang_items = [None; 2];\n-\n-    covariant_lang_items[TypeParam as uint] =\n-        terms_cx.tcx.lang_items.covariant_type();\n-    covariant_lang_items[RegionParam as uint] =\n-        terms_cx.tcx.lang_items.covariant_lifetime();\n-\n-    contravariant_lang_items[TypeParam as uint] =\n-        terms_cx.tcx.lang_items.contravariant_type();\n-    contravariant_lang_items[RegionParam as uint] =\n-        terms_cx.tcx.lang_items.contravariant_lifetime();\n-\n-    invariant_lang_items[TypeParam as uint] =\n-        terms_cx.tcx.lang_items.invariant_type();\n-    invariant_lang_items[RegionParam as uint] =\n-        terms_cx.tcx.lang_items.invariant_lifetime();\n-\n-    let unsafe_cell_lang_item = terms_cx.tcx.lang_items.unsafe_cell_type();\n-\n+                                        -> ConstraintContext<'a, 'tcx>\n+{\n     let covariant = terms_cx.arena.alloc(ConstantTerm(ty::Covariant));\n     let contravariant = terms_cx.arena.alloc(ConstantTerm(ty::Contravariant));\n     let invariant = terms_cx.arena.alloc(ConstantTerm(ty::Invariant));\n     let bivariant = terms_cx.arena.alloc(ConstantTerm(ty::Bivariant));\n     let mut constraint_cx = ConstraintContext {\n         terms_cx: terms_cx,\n-\n-        invariant_lang_items: invariant_lang_items,\n-        covariant_lang_items: covariant_lang_items,\n-        contravariant_lang_items: contravariant_lang_items,\n-        unsafe_cell_lang_item: unsafe_cell_lang_item,\n-\n         covariant: covariant,\n         contravariant: contravariant,\n         invariant: invariant,\n@@ -487,7 +545,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n \n         match item.node {\n             ast::ItemEnum(ref enum_definition, _) => {\n-                let generics = &ty::lookup_item_type(tcx, did).generics;\n+                let scheme = ty::lookup_item_type(tcx, did);\n+\n+                // Not entirely obvious: constraints on structs/enums do not\n+                // affect the variance of their type parameters. See discussion\n+                // in comment at top of module.\n+                //\n+                // self.add_constraints_from_generics(&scheme.generics);\n \n                 // Hack: If we directly call `ty::enum_variants`, it\n                 // annoyingly takes it upon itself to run off and\n@@ -505,29 +569,48 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                                                           &**ast_variant,\n                                                           /*discriminant*/ 0);\n                     for arg_ty in &variant.args {\n-                        self.add_constraints_from_ty(generics, *arg_ty, self.covariant);\n+                        self.add_constraints_from_ty(&scheme.generics, *arg_ty, self.covariant);\n                     }\n                 }\n             }\n \n             ast::ItemStruct(..) => {\n-                let generics = &ty::lookup_item_type(tcx, did).generics;\n+                let scheme = ty::lookup_item_type(tcx, did);\n+\n+                // Not entirely obvious: constraints on structs/enums do not\n+                // affect the variance of their type parameters. See discussion\n+                // in comment at top of module.\n+                //\n+                // self.add_constraints_from_generics(&scheme.generics);\n+\n                 let struct_fields = ty::lookup_struct_fields(tcx, did);\n                 for field_info in &struct_fields {\n                     assert_eq!(field_info.id.krate, ast::LOCAL_CRATE);\n                     let field_ty = ty::node_id_to_type(tcx, field_info.id.node);\n-                    self.add_constraints_from_ty(generics, field_ty, self.covariant);\n+                    self.add_constraints_from_ty(&scheme.generics, field_ty, self.covariant);\n                 }\n             }\n \n             ast::ItemTrait(..) => {\n+                let trait_def = ty::lookup_trait_def(tcx, did);\n+                let predicates = ty::predicates(tcx, ty::mk_self_type(tcx), &trait_def.bounds);\n+                self.add_constraints_from_predicates(&trait_def.generics,\n+                                                     &predicates[],\n+                                                     self.covariant);\n+\n                 let trait_items = ty::trait_items(tcx, did);\n                 for trait_item in &*trait_items {\n                     match *trait_item {\n                         ty::MethodTraitItem(ref method) => {\n-                            self.add_constraints_from_sig(&method.generics,\n-                                                          &method.fty.sig,\n-                                                          self.covariant);\n+                            self.add_constraints_from_predicates(\n+                                &method.generics,\n+                                method.predicates.predicates.get_slice(FnSpace),\n+                                self.contravariant);\n+\n+                            self.add_constraints_from_sig(\n+                                &method.generics,\n+                                &method.fty.sig,\n+                                self.covariant);\n                         }\n                         ty::TypeTraitItem(_) => {}\n                     }\n@@ -544,9 +627,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             ast::ItemTy(..) |\n             ast::ItemImpl(..) |\n             ast::ItemMac(..) => {\n-                visit::walk_item(self, item);\n             }\n         }\n+\n+        visit::walk_item(self, item);\n     }\n }\n \n@@ -648,15 +732,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n \n-        if self.invariant_lang_items[kind as uint] == Some(item_def_id) {\n-            self.invariant\n-        } else if self.covariant_lang_items[kind as uint] == Some(item_def_id) {\n-            self.covariant\n-        } else if self.contravariant_lang_items[kind as uint] == Some(item_def_id) {\n-            self.contravariant\n-        } else if kind == TypeParam && Some(item_def_id) == self.unsafe_cell_lang_item {\n-            self.invariant\n-        } else if param_def_id.krate == ast::LOCAL_CRATE {\n+        if param_def_id.krate == ast::LOCAL_CRATE {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n@@ -724,14 +800,35 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n+    fn add_constraints_from_trait_ref(&mut self,\n+                                      generics: &ty::Generics<'tcx>,\n+                                      trait_ref: &ty::TraitRef<'tcx>,\n+                                      variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_trait_ref: trait_ref={} variance={:?}\",\n+               trait_ref.repr(self.tcx()),\n+               variance);\n+\n+        let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n+\n+        self.add_constraints_from_substs(\n+            generics,\n+            trait_ref.def_id,\n+            trait_def.generics.types.as_slice(),\n+            trait_def.generics.regions.as_slice(),\n+            trait_ref.substs,\n+            variance);\n+    }\n+\n     /// Adds constraints appropriate for an instance of `ty` appearing\n     /// in a context with the generics defined in `generics` and\n     /// ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n                                generics: &ty::Generics<'tcx>,\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n+        debug!(\"add_constraints_from_ty(ty={}, variance={:?})\",\n+               ty.repr(self.tcx()),\n+               variance);\n \n         match ty.sty {\n             ty::ty_bool |\n@@ -754,6 +851,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_ty(generics, typ, variance);\n             }\n \n+\n             ty::ty_ptr(ref mt) => {\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n@@ -797,27 +895,16 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ty_trait(ref data) => {\n-                let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(),\n-                                                                      self.tcx().types.err);\n-                let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id());\n-\n-                // Traits never declare region parameters in the self\n-                // space nor anything in the fn space.\n-                assert!(trait_def.generics.regions.is_empty_in(subst::SelfSpace));\n-                assert!(trait_def.generics.types.is_empty_in(subst::FnSpace));\n-                assert!(trait_def.generics.regions.is_empty_in(subst::FnSpace));\n+                let poly_trait_ref =\n+                    data.principal_trait_ref_with_self_ty(self.tcx(),\n+                                                          self.tcx().types.err);\n \n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(generics, data.bounds.region_bound, contra);\n \n-                self.add_constraints_from_substs(\n-                    generics,\n-                    trait_ref.def_id(),\n-                    trait_def.generics.types.get_slice(subst::TypeSpace),\n-                    trait_def.generics.regions.get_slice(subst::TypeSpace),\n-                    trait_ref.substs(),\n-                    variance);\n+                // Ignore the SelfSpace, it is erased.\n+                self.add_constraints_from_trait_ref(generics, &*poly_trait_ref.0, variance);\n \n                 let projections = data.projection_bounds_with_self_ty(self.tcx(),\n                                                                       self.tcx().types.err);\n@@ -845,7 +932,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_sig(generics, sig, variance);\n             }\n \n-            ty::ty_infer(..) | ty::ty_err => {\n+            ty::ty_err => {\n+                // we encounter this when walking the trait references for object\n+                // types, where we use ty_err as the Self type\n+            }\n+\n+            ty::ty_infer(..) => {\n                 self.tcx().sess.bug(\n                     &format!(\"unexpected type encountered in \\\n                             variance inference: {}\",\n@@ -864,14 +956,19 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &subst::Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n+        debug!(\"add_constraints_from_substs(def_id={}, substs={}, variance={:?})\",\n+               def_id.repr(self.tcx()),\n+               substs.repr(self.tcx()),\n+               variance);\n \n         for p in type_param_defs {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam,\n                                        p.space, p.index as uint);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_ty = *substs.types.get(p.space, p.index as uint);\n+            debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n+                   variance_decl, variance_i);\n             self.add_constraints_from_ty(generics, substs_ty, variance_i);\n         }\n \n@@ -885,6 +982,51 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n+    fn add_constraints_from_predicates(&mut self,\n+                                       generics: &ty::Generics<'tcx>,\n+                                       predicates: &[ty::Predicate<'tcx>],\n+                                       variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_generics({})\",\n+               generics.repr(self.tcx()));\n+\n+        for predicate in predicates.iter() {\n+            match *predicate {\n+                ty::Predicate::Trait(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_trait_ref(generics, &*data.trait_ref, variance);\n+                }\n+\n+                ty::Predicate::Equate(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_ty(generics, data.0, variance);\n+                    self.add_constraints_from_ty(generics, data.1, variance);\n+                }\n+\n+                ty::Predicate::TypeOutlives(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_ty(generics, data.0, variance);\n+\n+                    let variance_r = self.xform(variance, self.contravariant);\n+                    self.add_constraints_from_region(generics, data.1, variance_r);\n+                }\n+\n+                ty::Predicate::RegionOutlives(ty::Binder(ref data)) => {\n+                    // `'a : 'b` is still true if 'a gets bigger\n+                    self.add_constraints_from_region(generics, data.0, variance);\n+\n+                    // `'a : 'b` is still true if 'b gets smaller\n+                    let variance_r = self.xform(variance, self.contravariant);\n+                    self.add_constraints_from_region(generics, data.1, variance_r);\n+                }\n+\n+                ty::Predicate::Projection(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_trait_ref(generics,\n+                                                        &*data.projection_ty.trait_ref,\n+                                                        variance);\n+\n+                    self.add_constraints_from_ty(generics, data.ty, self.invariant);\n+                }\n+            }\n+        }\n+    }\n+\n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n@@ -969,7 +1111,12 @@ struct SolveContext<'a, 'tcx: 'a> {\n \n fn solve_constraints(constraints_cx: ConstraintContext) {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n-    let solutions: Vec<_> = repeat(ty::Bivariant).take(terms_cx.num_inferred()).collect();\n+\n+    let solutions =\n+        terms_cx.inferred_infos.iter()\n+                               .map(|ii| ii.initial_variance)\n+                               .collect();\n+\n     let mut solutions_cx = SolveContext {\n         terms_cx: terms_cx,\n         constraints: constraints,\n@@ -1034,20 +1181,16 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             let mut types = VecPerParamSpace::empty();\n             let mut regions = VecPerParamSpace::empty();\n \n-            while index < num_inferred &&\n-                  inferred_infos[index].item_id == item_id {\n+            while index < num_inferred && inferred_infos[index].item_id == item_id {\n                 let info = &inferred_infos[index];\n                 let variance = solutions[index];\n                 debug!(\"Index {} Info {} / {:?} / {:?} Variance {:?}\",\n                        index, info.index, info.kind, info.space, variance);\n                 match info.kind {\n-                    TypeParam => {\n-                        types.push(info.space, variance);\n-                    }\n-                    RegionParam => {\n-                        regions.push(info.space, variance);\n-                    }\n+                    TypeParam => { types.push(info.space, variance); }\n+                    RegionParam => { regions.push(info.space, variance); }\n                 }\n+\n                 index += 1;\n             }\n \n@@ -1144,3 +1287,4 @@ fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n         (x, ty::Bivariant) | (ty::Bivariant, x) => x,\n     }\n }\n+"}, {"sha": "7e6dd45b51e48f69f553388787dc490f1f843e03", "filename": "src/libstd/collections/hash/state.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,6 +11,7 @@\n use clone::Clone;\n use default::Default;\n use hash;\n+use marker;\n \n /// A trait representing stateful hashes which can be used to hash keys in a\n /// `HashMap`.\n@@ -37,17 +38,17 @@ pub trait HashState {\n ///\n /// This struct has is 0-sized and does not need construction.\n #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-pub struct DefaultState<H>;\n+pub struct DefaultState<H>(marker::PhantomData<H>);\n \n impl<H: Default + hash::Hasher> HashState for DefaultState<H> {\n     type Hasher = H;\n     fn hasher(&self) -> H { Default::default() }\n }\n \n impl<H> Clone for DefaultState<H> {\n-    fn clone(&self) -> DefaultState<H> { DefaultState }\n+    fn clone(&self) -> DefaultState<H> { DefaultState(marker::PhantomData) }\n }\n \n impl<H> Default for DefaultState<H> {\n-    fn default() -> DefaultState<H> { DefaultState }\n+    fn default() -> DefaultState<H> { DefaultState(marker::PhantomData) }\n }"}, {"sha": "f301f6db92f96a7bf96d2ee545128212db7c9de7", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -23,8 +23,8 @@ use num::{Int, UnsignedInt};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};\n-use ptr::{self, PtrExt, copy_nonoverlapping_memory, zero_memory};\n-use rt::heap::{allocate, deallocate};\n+use ptr::{self, PtrExt, copy_nonoverlapping_memory, Unique, zero_memory};\n+use rt::heap::{allocate, deallocate, EMPTY};\n use collections::hash_state::HashState;\n \n const EMPTY_BUCKET: u64 = 0u64;\n@@ -69,10 +69,11 @@ const EMPTY_BUCKET: u64 = 0u64;\n pub struct RawTable<K, V> {\n     capacity: usize,\n     size:     usize,\n-    hashes:   *mut u64,\n+    hashes:   Unique<u64>,\n+\n     // Because K/V do not appear directly in any of the types in the struct,\n     // inform rustc that in fact instances of K and V are reachable from here.\n-    marker:   marker::CovariantType<(K,V)>,\n+    marker:   marker::PhantomData<(K,V)>,\n }\n \n unsafe impl<K: Send, V: Send> Send for RawTable<K, V> {}\n@@ -81,7 +82,8 @@ unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n struct RawBucket<K, V> {\n     hash: *mut u64,\n     key:  *mut K,\n-    val:  *mut V\n+    val:  *mut V,\n+    _marker: marker::PhantomData<(K,V)>,\n }\n \n impl<K,V> Copy for RawBucket<K,V> {}\n@@ -187,11 +189,12 @@ fn can_alias_safehash_as_u64() {\n }\n \n impl<K, V> RawBucket<K, V> {\n-    unsafe fn offset(self, count: int) -> RawBucket<K, V> {\n+    unsafe fn offset(self, count: isize) -> RawBucket<K, V> {\n         RawBucket {\n             hash: self.hash.offset(count),\n             key:  self.key.offset(count),\n             val:  self.val.offset(count),\n+            _marker: marker::PhantomData,\n         }\n     }\n }\n@@ -584,10 +587,11 @@ impl<K, V> RawTable<K, V> {\n             return RawTable {\n                 size: 0,\n                 capacity: 0,\n-                hashes: ptr::null_mut(),\n-                marker: marker::CovariantType,\n+                hashes: Unique::new(EMPTY as *mut u64),\n+                marker: marker::PhantomData,\n             };\n         }\n+\n         // No need for `checked_mul` before a more restrictive check performed\n         // later in this method.\n         let hashes_size = capacity * size_of::<u64>();\n@@ -623,25 +627,26 @@ impl<K, V> RawTable<K, V> {\n         RawTable {\n             capacity: capacity,\n             size:     0,\n-            hashes:   hashes,\n-            marker:   marker::CovariantType,\n+            hashes:   Unique::new(hashes),\n+            marker:   marker::PhantomData,\n         }\n     }\n \n     fn first_bucket_raw(&self) -> RawBucket<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n         let keys_size = self.capacity * size_of::<K>();\n \n-        let buffer = self.hashes as *mut u8;\n+        let buffer = *self.hashes as *mut u8;\n         let (keys_offset, vals_offset) = calculate_offsets(hashes_size,\n                                                            keys_size, min_align_of::<K>(),\n                                                            min_align_of::<V>());\n \n         unsafe {\n             RawBucket {\n-                hash: self.hashes,\n+                hash: *self.hashes,\n                 key:  buffer.offset(keys_offset as isize) as *mut K,\n-                val:  buffer.offset(vals_offset as isize) as *mut V\n+                val:  buffer.offset(vals_offset as isize) as *mut V,\n+                _marker: marker::PhantomData,\n             }\n         }\n     }\n@@ -651,7 +656,7 @@ impl<K, V> RawTable<K, V> {\n     pub fn new(capacity: usize) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);\n-            zero_memory(ret.hashes, capacity);\n+            zero_memory(*ret.hashes, capacity);\n             ret\n         }\n     }\n@@ -673,7 +678,7 @@ impl<K, V> RawTable<K, V> {\n             hashes_end: unsafe {\n                 self.hashes.offset(self.capacity as isize)\n             },\n-            marker: marker::ContravariantLifetime,\n+            marker: marker::PhantomData,\n         }\n     }\n \n@@ -698,7 +703,7 @@ impl<K, V> RawTable<K, V> {\n             iter: RawBuckets {\n                 raw: raw,\n                 hashes_end: hashes_end,\n-                marker: marker::ContravariantLifetime,\n+                marker: marker::PhantomData,\n             },\n             table: self,\n         }\n@@ -711,7 +716,7 @@ impl<K, V> RawTable<K, V> {\n             iter: RawBuckets {\n                 raw: raw,\n                 hashes_end: hashes_end,\n-                marker: marker::ContravariantLifetime::<'static>,\n+                marker: marker::PhantomData,\n             },\n             table: self,\n         }\n@@ -725,7 +730,7 @@ impl<K, V> RawTable<K, V> {\n             raw: raw_bucket.offset(self.capacity as isize),\n             hashes_end: raw_bucket.hash,\n             elems_left: self.size,\n-            marker:     marker::ContravariantLifetime,\n+            marker:     marker::PhantomData,\n         }\n     }\n }\n@@ -735,7 +740,13 @@ impl<K, V> RawTable<K, V> {\n struct RawBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n     hashes_end: *mut u64,\n-    marker: marker::ContravariantLifetime<'a>,\n+\n+    // Strictly speaking, this should be &'a (K,V), but that would\n+    // require that K:'a, and we often use RawBuckets<'static...> for\n+    // move iterations, so that messes up a lot of other things. So\n+    // just use `&'a (K,V)` as this is not a publicly exposed type\n+    // anyway.\n+    marker: marker::PhantomData<&'a ()>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -744,7 +755,7 @@ impl<'a, K, V> Clone for RawBuckets<'a, K, V> {\n         RawBuckets {\n             raw: self.raw,\n             hashes_end: self.hashes_end,\n-            marker: marker::ContravariantLifetime,\n+            marker: marker::PhantomData,\n         }\n     }\n }\n@@ -776,7 +787,11 @@ struct RevMoveBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n     hashes_end: *mut u64,\n     elems_left: usize,\n-    marker: marker::ContravariantLifetime<'a>,\n+\n+    // As above, `&'a (K,V)` would seem better, but we often use\n+    // 'static for the lifetime, and this is not a publicly exposed\n+    // type.\n+    marker: marker::PhantomData<&'a ()>,\n }\n \n impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> {\n@@ -983,9 +998,10 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n #[unsafe_destructor]\n impl<K, V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n-        if self.hashes.is_null() {\n+        if self.capacity == 0 {\n             return;\n         }\n+\n         // This is done in reverse because we've likely partially taken\n         // some elements out with `.into_iter()` from the front.\n         // Check if the size is 0, so we don't do a useless scan when\n@@ -1003,7 +1019,7 @@ impl<K, V> Drop for RawTable<K, V> {\n                                                     vals_size, min_align_of::<V>());\n \n         unsafe {\n-            deallocate(self.hashes as *mut u8, size, align);\n+            deallocate(*self.hashes as *mut u8, size, align);\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}, {"sha": "fc3deb67f41ec97148e6a2639964129193006150", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -252,7 +252,7 @@ use error::Error;\n use fmt;\n use isize;\n use iter::{Iterator, IteratorExt};\n-use marker::Sized;\n+use marker::{PhantomFn, Sized};\n use mem::transmute;\n use ops::FnOnce;\n use option::Option;\n@@ -433,7 +433,7 @@ pub enum IoErrorKind {\n }\n \n /// A trait that lets you add a `detail` to an IoError easily\n-trait UpdateIoError<T> {\n+trait UpdateIoError {\n     /// Returns an IoError with updated description and detail\n     fn update_err<D>(self, desc: &'static str, detail: D) -> Self where\n         D: FnOnce(&IoError) -> String;\n@@ -446,7 +446,7 @@ trait UpdateIoError<T> {\n     fn update_desc(self, desc: &'static str) -> Self;\n }\n \n-impl<T> UpdateIoError<T> for IoResult<T> {\n+impl<T> UpdateIoError for IoResult<T> {\n     fn update_err<D>(self, desc: &'static str, detail: D) -> IoResult<T> where\n         D: FnOnce(&IoError) -> String,\n     {\n@@ -1572,7 +1572,9 @@ pub trait Seek {\n /// connections.\n ///\n /// Doing so produces some sort of Acceptor.\n-pub trait Listener<T, A: Acceptor<T>> {\n+pub trait Listener<T, A: Acceptor<T>>\n+    : PhantomFn<T,T> // FIXME should be an assoc type anyhow\n+{\n     /// Spin up the listener and start queuing incoming connections\n     ///\n     /// # Error"}, {"sha": "3653e7e31d5c6df556132b437f9ea107f16547a4", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -153,7 +153,7 @@ use any::Any;\n use cell::UnsafeCell;\n use fmt;\n use io;\n-use marker;\n+use marker::PhantomData;\n use old_io::stdio;\n use rt::{self, unwind};\n use sync::{Mutex, Condvar, Arc};\n@@ -260,7 +260,7 @@ impl Builder {\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n         self.spawn_inner(Thunk::new(f)).map(|inner| {\n-            JoinGuard { inner: inner, _marker: marker::CovariantType }\n+            JoinGuard { inner: inner, _marker: PhantomData }\n         })\n     }\n \n@@ -642,7 +642,7 @@ impl Drop for JoinHandle {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct JoinGuard<'a, T: 'a> {\n     inner: JoinInner<T>,\n-    _marker: marker::CovariantType<&'a T>,\n+    _marker: PhantomData<&'a T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "4e4a571ede7b864af3b797be5784fb6fc582e7b9", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -45,11 +45,11 @@ fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"no_implicit_prelude\")\n }\n \n-struct StandardLibraryInjector<'a> {\n-    alt_std_name: Option<String>\n+struct StandardLibraryInjector {\n+    alt_std_name: Option<String>,\n }\n \n-impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n+impl fold::Folder for StandardLibraryInjector {\n     fn fold_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n \n         // The name to use in `extern crate \"name\" as std;`\n@@ -80,9 +80,10 @@ fn inject_crates_ref(krate: ast::Crate, alt_std_name: Option<String>) -> ast::Cr\n     fold.fold_crate(krate)\n }\n \n-struct PreludeInjector<'a>;\n+struct PreludeInjector;\n \n-impl<'a> fold::Folder for PreludeInjector<'a> {\n+\n+impl fold::Folder for PreludeInjector {\n     fn fold_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         // only add `use std::prelude::*;` if there wasn't a\n         // `#![no_implicit_prelude]` at the crate level."}, {"sha": "5418533aff1d918129f9bae1f6f5059dd603fe55", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -50,7 +50,6 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![deny(missing_docs)]\n \n-#![feature(core)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(int_uint)]"}, {"sha": "cc42b288e6638a0f7c36e385dbf25012c8ac791c", "filename": "src/test/auxiliary/coherence-orphan-lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fcoherence-orphan-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fcoherence-orphan-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcoherence-orphan-lib.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait TheTrait<T> {\n+pub trait TheTrait<T> : ::std::marker::PhantomFn<T> {\n     fn the_fn(&self);\n }\n "}, {"sha": "0a65174911ec7149b473c4e9216bb35e2c173a27", "filename": "src/test/auxiliary/default_type_params_xc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,4 +12,5 @@ pub struct Heap;\n \n pub struct FakeHeap;\n \n-pub struct FakeVec<T, A = FakeHeap>;\n+pub struct FakeVec<T, A = FakeHeap> { pub f: Option<(T,A)> }\n+"}, {"sha": "ca5c6072cb371b98bd9ea096807f65abbb570944", "filename": "src/test/auxiliary/inner_static.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Finner_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Finner_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finner_static.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct A<T>;\n-pub struct B<T>;\n+pub struct A<T> { pub v: T }\n+pub struct B<T> { pub v: T }\n \n pub mod test {\n-    pub struct A<T>;\n+    pub struct A<T> { pub v: T }\n \n     impl<T> A<T> {\n         pub fn foo(&self) -> int {\n@@ -52,9 +52,9 @@ impl<T> B<T> {\n }\n \n pub fn foo() -> int {\n-    let a = A::<()>;\n-    let b = B::<()>;\n-    let c = test::A::<()>;\n+    let a = A { v: () };\n+    let b = B { v: () };\n+    let c = test::A { v: () };\n     return a.foo() + a.bar() +\n            b.foo() + b.bar() +\n            c.foo() + c.bar();"}, {"sha": "a48088609f982ca7565fccde0828912430998f4c", "filename": "src/test/auxiliary/issue-14421.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue-14421.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue-14421.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-14421.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,6 +10,7 @@\n \n #![crate_type=\"lib\"]\n #![deny(warnings)]\n+#![allow(dead_code)]\n \n pub use src::aliases::B;\n pub use src::hidden_core::make;\n@@ -23,9 +24,9 @@ mod src {\n     pub mod hidden_core {\n         use super::aliases::B;\n \n-        pub struct A<T>;\n+        pub struct A<T> { t: T }\n \n-        pub fn make() -> B { A }\n+        pub fn make() -> B { A { t: 1.0 } }\n \n         impl<T> A<T> {\n             pub fn foo(&mut self) { println!(\"called foo\"); }"}, {"sha": "b590160a0c2ab5d8c1c467660a26dbc4818081a8", "filename": "src/test/auxiliary/issue-16643.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-16643.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,7 @@\n \n #![crate_type = \"lib\"]\n \n-pub struct TreeBuilder<H>;\n+pub struct TreeBuilder<H> { pub h: H }\n \n impl<H> TreeBuilder<H> {\n     pub fn process_token(&mut self) {"}, {"sha": "fb55a077005eb8d9662a02f4e24f1b2f67900784", "filename": "src/test/auxiliary/issue-17662.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue-17662.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue-17662.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17662.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,7 @@\n #![crate_type = \"lib\"]\n \n pub trait Foo<'a, T> {\n-    fn foo(&self) -> T;\n+    fn foo(&'a self) -> T;\n }\n \n pub fn foo<'a, T>(x: &'a Foo<'a, T>) -> T {"}, {"sha": "96f33f97a696973c891a36bbe0e0a742f5598bf9", "filename": "src/test/auxiliary/issue-2380.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2380.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,7 +14,10 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-pub trait i<T> { }\n+pub trait i<T>\n+{\n+    fn dummy(&self, t: T) -> T { panic!() }\n+}\n \n pub fn f<T>() -> Box<i<T>+'static> {\n     impl<T> i<T> for () { }"}, {"sha": "89b3b56121a1614961297566eb8088c21a5808ef", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,8 +13,11 @@\n \n #![feature(unsafe_destructor)]\n \n+use std::marker;\n+\n struct arc_destruct<T> {\n-  _data: int,\n+    _data: int,\n+    _marker: marker::PhantomData<T>\n }\n \n #[unsafe_destructor]\n@@ -24,7 +27,8 @@ impl<T: Sync> Drop for arc_destruct<T> {\n \n fn arc_destruct<T: Sync>(data: int) -> arc_destruct<T> {\n     arc_destruct {\n-        _data: data\n+        _data: data,\n+        _marker: marker::PhantomData\n     }\n }\n "}, {"sha": "4ce7e3079e330a0a82f8b445076d55bf51ff4c92", "filename": "src/test/auxiliary/issue_20389.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue_20389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue_20389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_20389.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,4 +10,5 @@\n \n pub trait T {\n     type C;\n+    fn dummy(&self) { }\n }"}, {"sha": "545e15fe1664d657ef941e983f72dd1b6c66b4d9", "filename": "src/test/auxiliary/issue_3907.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3907.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait Foo {\n+use std::marker::MarkerTrait;\n+\n+pub trait Foo : MarkerTrait {\n     fn bar();\n }\n "}, {"sha": "9006a5d1775f764eb7f569fa7f491b09dd7b27da", "filename": "src/test/auxiliary/issue_8401.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue_8401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue_8401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_8401.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,7 +12,9 @@\n \n use std::mem;\n \n-trait A {}\n+trait A {\n+    fn dummy(&self) { }\n+}\n struct B;\n impl A for B {}\n "}, {"sha": "4f2792aebcd2408639256271ae4254015e744f07", "filename": "src/test/auxiliary/issue_9123.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue_9123.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fissue_9123.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_9123.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,5 +15,6 @@ pub trait X {\n         fn f() { }\n         f();\n     }\n+    fn dummy(&self) { }\n }\n "}, {"sha": "b9cc20b63cc5640258ac6bc70afde33440a6d24a", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,8 +12,12 @@\n #![no_std]\n #![feature(lang_items)]\n \n+#[lang=\"phantom_fn\"]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n+impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n+\n #[lang=\"sized\"]\n-pub trait Sized {}\n+pub trait Sized : PhantomFn<Self> {}\n \n #[lang=\"panic\"]\n fn panic(_: &(&'static str, &'static str, uint)) -> ! { loop {} }\n@@ -25,6 +29,8 @@ extern fn stack_exhausted() {}\n extern fn eh_personality() {}\n \n #[lang=\"copy\"]\n-pub trait Copy {}\n+pub trait Copy : PhantomFn<Self> {\n+    // Empty.\n+}\n \n "}, {"sha": "fb535eb8336f9b2df90d027c61cef3fb9f731097", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -96,7 +96,7 @@ pub trait Trait {\n impl Trait for MethodTester {}\n \n #[unstable(feature = \"test_feature\")]\n-pub trait UnstableTrait {}\n+pub trait UnstableTrait { fn dummy(&self) { } }\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n #[deprecated(since = \"1.0.0\")]"}, {"sha": "fc1bea5a9fd41128c88b9a1b2506ed398cdb9477", "filename": "src/test/auxiliary/nested_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnested_item.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -25,7 +25,7 @@ impl Foo {\n }\n \n // issue 8134\n-pub struct Parser<T>;\n+pub struct Parser<T>(T);\n impl<T: std::iter::Iterator<Item=char>> Parser<T> {\n     fn in_doctype(&mut self) {\n         static DOCTYPEPattern: [char; 6] = ['O', 'C', 'T', 'Y', 'P', 'E'];"}, {"sha": "cf3e9903b5ad001e2bef688a792cfe8c5e630d07", "filename": "src/test/auxiliary/orphan_check_diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Forphan_check_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Forphan_check_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Forphan_check_diagnostics.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait RemoteTrait {}\n+pub trait RemoteTrait { fn dummy(&self) { } }"}, {"sha": "3c8cba13ae73d07296407009850cd94adca716ed", "filename": "src/test/auxiliary/overloaded_autoderef_xc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,8 @@\n use std::ops::Deref;\n \n struct DerefWithHelper<H, T> {\n-    pub helper: H\n+    pub helper: H,\n+    pub value: Option<T>\n }\n \n trait Helper<T> {\n@@ -34,6 +35,6 @@ impl<T, H: Helper<T>> Deref for DerefWithHelper<H, T> {\n \n // Test cross-crate autoderef + vtable.\n pub fn check<T: PartialEq>(x: T, y: T) -> bool {\n-    let d: DerefWithHelper<Option<T>, T> = DerefWithHelper { helper: Some(x) };\n+    let d: DerefWithHelper<Option<T>, T> = DerefWithHelper { helper: Some(x), value: None };\n     d.eq(&y)\n }"}, {"sha": "42691579491bbfb7e7abb069fd995bf62288e8f0", "filename": "src/test/auxiliary/private_trait_xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {}\n+trait Foo : ::std::marker::MarkerTrait {}"}, {"sha": "04f1062c16f02a572e8f97c9345b2f6b99469983", "filename": "src/test/auxiliary/svh-a-base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "fabd2289e9a44ea61c62f41c56fb5c41a7b2be99", "filename": "src/test/auxiliary/svh-a-change-lit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "3fdb861bd40c178d430e26c4b51059b55debb0d8", "filename": "src/test/auxiliary/svh-a-change-significant-cfg.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "3116d24673d4847bef21ac198e648c5f098a4257", "filename": "src/test/auxiliary/svh-a-change-trait-bound.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "b49a1533628f6f526225f062d21e06987dca295b", "filename": "src/test/auxiliary/svh-a-change-type-arg.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "6562a93135f39740c5210eaa7824ed37668ffdd5", "filename": "src/test/auxiliary/svh-a-change-type-ret.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "c7b392c6ee82b07b942cd7188a9fe316b8ad7579", "filename": "src/test/auxiliary/svh-a-change-type-static.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "450f61020260dd49416c27ea402223efd0c20157", "filename": "src/test/auxiliary/svh-a-comment.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "c000737c854c6a85b1264f8a87c251ac718a9d40", "filename": "src/test/auxiliary/svh-a-doc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "1e12659dc4b92f15dff148558217b6eb28ba4446", "filename": "src/test/auxiliary/svh-a-macro.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "04f1062c16f02a572e8f97c9345b2f6b99469983", "filename": "src/test/auxiliary/svh-a-no-change.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "1e82b74f1ef2e5cd6240b735add8776a5a0d025f", "filename": "src/test/auxiliary/svh-a-redundant-cfg.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "3c3dac9cdab96209dc789d35c42546ffd90ec6ef", "filename": "src/test/auxiliary/svh-a-whitespace.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,12 +15,14 @@\n \n #![crate_name = \"a\"]\n \n+use std::marker::MarkerTrait;\n+\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U {}\n-pub trait V {}\n+pub trait U : MarkerTrait {}\n+pub trait V : MarkerTrait {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "a7c469fccaa5abbcba151be4cb6e579771fd3cae", "filename": "src/test/auxiliary/trait_bounds_on_structs_and_enums_xc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Ftrait_bounds_on_structs_and_enums_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Ftrait_bounds_on_structs_and_enums_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_bounds_on_structs_and_enums_xc.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait Trait {}\n+pub trait Trait {\n+    fn dummy(&self) { }\n+}\n \n pub struct Foo<T:Trait> {\n     pub x: T,"}, {"sha": "0982efbdbf47e4d8770a7adc1aa0aa4a78ac5071", "filename": "src/test/auxiliary/trait_impl_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait Foo {\n+pub trait Foo : ::std::marker::MarkerTrait {\n }\n \n impl Foo for int {"}, {"sha": "56fb40bc0a469af3021f8e4a9346fb0a3161b197", "filename": "src/test/auxiliary/use_from_trait_xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fuse_from_trait_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fauxiliary%2Fuse_from_trait_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fuse_from_trait_xc.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,7 @@\n pub use self::sub::{Bar, Baz};\n \n pub trait Trait {\n-    fn foo();\n+    fn foo(&self);\n }\n \n struct Foo;"}, {"sha": "edd1b8255ccdc38e6a4b1f7459443f0f0bda90e9", "filename": "src/test/compile-fail/associated-types-ICE-when-projecting-out-of-err.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -16,8 +16,12 @@\n #![feature(no_std)]\n #![no_std]\n \n+#[lang=\"phantom_fn\"]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n+impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n+\n #[lang=\"sized\"]\n-pub trait Sized {\n+pub trait Sized : PhantomFn<Self> {\n     // Empty.\n }\n "}, {"sha": "b7a16c68a34e1a43fdbb1548dc903a80a3e740b8", "filename": "src/test/compile-fail/associated-types-coherence-failure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,9 +11,10 @@\n // Test that coherence detects overlap when some of the types in the\n // impls are projections of associated type. Issue #20624.\n \n+use std::marker::PhantomData;\n use std::ops::Deref;\n \n-pub struct Cow<'a, B: ?Sized>;\n+pub struct Cow<'a, B: ?Sized>(PhantomData<(&'a (),B)>);\n \n /// Trait for moving into a `Cow`\n pub trait IntoCow<'a, B: ?Sized> {"}, {"sha": "c48f9972ebc18765fca88e164449f57bb5a9ea11", "filename": "src/test/compile-fail/associated-types-eq-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,7 @@\n \n // Check that an associated type cannot be bound in an expression path.\n \n-trait Foo {\n+trait Foo : ::std::marker::MarkerTrait {\n     type A;\n     fn bar() -> isize;\n }"}, {"sha": "625f4cdb8ef3dbc3af68abee2124f51eefb1a5b2", "filename": "src/test/compile-fail/associated-types-issue-17359.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,7 @@\n // Test that we do not ICE when an impl is missing an associated type (and that we report\n // a useful error, of course).\n \n-trait Trait {\n+trait Trait : ::std::marker::MarkerTrait {\n     type Type;\n }\n "}, {"sha": "5632f148da67ce2e1d00f4f0738c07406c00f88d", "filename": "src/test/compile-fail/associated-types-multiple-types-one-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-multiple-types-one-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-multiple-types-one-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-multiple-types-one-trait.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {\n+trait Foo : ::std::marker::MarkerTrait {\n     type X;\n     type Y;\n }"}, {"sha": "2b84c38f80b542b309443d17c13a2f122383de9d", "filename": "src/test/compile-fail/associated-types-no-suitable-supertrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,7 @@\n // Check that we get an error when you use `<Self as Get>::Value` in\n // the trait definition but `Self` does not, in fact, implement `Get`.\n \n-trait Get {\n+trait Get : ::std::marker::MarkerTrait {\n     type Value;\n }\n "}, {"sha": "b9a62ff4e417afd9d3840bdc836bb69ff8c53cd7", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,6 +12,8 @@\n \n pub trait Foo {\n     type A;\n+\n+    fn dummy(&self) { }\n }\n \n impl Foo for i32 {"}, {"sha": "8832028f9aba1e87781545bb2426653882439b3c", "filename": "src/test/compile-fail/associated-types-unconstrained.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,7 @@\n \n // Check that an associated type cannot be bound in an expression path.\n \n-trait Foo {\n+trait Foo : ::std::marker::MarkerTrait {\n     type A;\n     fn bar() -> isize;\n }"}, {"sha": "3e02a11c378bd5a2292e8824c149cc4792479098", "filename": "src/test/compile-fail/bad-mid-path-type-params.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,13 +10,6 @@\n \n // ignore-tidy-linelength\n \n-#![feature(no_std)]\n-#![no_std]\n-#![feature(lang_items)]\n-\n-#[lang=\"sized\"]\n-pub trait Sized {}\n-\n struct S<T> {\n     contents: T,\n }"}, {"sha": "1944acbe1f34560115eb28ee004e6424d2e866de", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,7 +12,7 @@\n \n use std::cell::RefCell;\n \n-trait Trait {}\n+trait Trait : ::std::marker::MarkerTrait {}\n \n pub fn main() {\n     let x: Vec<Trait + Sized> = Vec::new();"}, {"sha": "d4decb713498df2e3e35eff101178d59b87af488", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-implemented.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,6 +10,7 @@\n \n use std::fmt::Show;\n use std::default::Default;\n+use std::marker::MarkerTrait;\n \n // Test that two blanket impls conflict (at least without negative\n // bounds).  After all, some other crate could implement Even or Odd\n@@ -19,9 +20,9 @@ trait MyTrait {\n     fn get(&self) -> usize;\n }\n \n-trait Even { }\n+trait Even : MarkerTrait { }\n \n-trait Odd { }\n+trait Odd : MarkerTrait { }\n \n impl Even for isize { }\n "}, {"sha": "b1ee1762b6e71ab2d9c722de3564acc3da722821", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -19,9 +19,9 @@ trait MyTrait {\n     fn get(&self) -> usize;\n }\n \n-trait Even { }\n+trait Even : ::std::marker::MarkerTrait { }\n \n-trait Odd { }\n+trait Odd : ::std::marker::MarkerTrait { }\n \n impl<T:Even> MyTrait for T { //~ ERROR E0119\n     fn get(&self) -> usize { 0 }"}, {"sha": "a225f6cf473041387b09124fbe54803d4f65f645", "filename": "src/test/compile-fail/coherence-conflicting-negative-trait-impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,18 +10,18 @@\n \n #![feature(optin_builtin_traits)]\n \n-trait MyTrait {}\n+trait MyTrait : ::std::marker::MarkerTrait {}\n \n-struct TestType<T>;\n+struct TestType<T>(::std::marker::PhantomData<T>);\n \n-unsafe impl<T: MyTrait> Send for TestType<T> {}\n+unsafe impl<T: MyTrait+'static> Send for TestType<T> {}\n //~^ ERROR conflicting implementations for trait `core::marker::Send`\n //~^^ ERROR conflicting implementations for trait `core::marker::Send`\n \n impl<T: MyTrait> !Send for TestType<T> {}\n //~^ ERROR conflicting implementations for trait `core::marker::Send`\n \n-unsafe impl<T> Send for TestType<T> {}\n+unsafe impl<T:'static> Send for TestType<T> {}\n //~^ ERROR error: conflicting implementations for trait `core::marker::Send`\n \n impl !Send for TestType<i32> {}"}, {"sha": "897cb083f849d41d25a88a8cb530424098a63aa6", "filename": "src/test/compile-fail/coherence-subtyping.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fcoherence-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fcoherence-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-subtyping.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that two distinct impls which match subtypes of one another\n+// yield coherence errors (or not) depending on the variance.\n+\n+trait Contravariant {\n+    fn foo(&self) { }\n+}\n+\n+impl Contravariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+    //~^ ERROR E0119\n+}\n+\n+impl Contravariant for for<'a> fn(&'a u8, &'a u8) {\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+trait Covariant {\n+    fn foo(&self) { }\n+}\n+\n+impl Covariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+    //~^ ERROR E0119\n+}\n+\n+impl Covariant for for<'a> fn(&'a u8, &'a u8) {\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+trait Invariant {\n+    fn foo(&self) -> Self { }\n+}\n+\n+impl Invariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+}\n+\n+impl Invariant for for<'a> fn(&'a u8, &'a u8) {\n+}\n+\n+fn main() { }"}, {"sha": "c97a9950d78d0ba6569dba1c89e4dc29dc7e445e", "filename": "src/test/compile-fail/cross-borrow-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,7 +14,7 @@\n #![feature(box_syntax)]\n \n struct Foo;\n-trait Trait {}\n+trait Trait : ::std::marker::MarkerTrait {}\n impl Trait for Foo {}\n \n pub fn main() {"}, {"sha": "d8b3f297a1123cb14372239888d2f75d03001cab", "filename": "src/test/compile-fail/destructure-trait-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,7 +14,7 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n \n-trait T {}\n+trait T : ::std::marker::MarkerTrait {}\n impl T for isize {}\n \n fn main() {"}, {"sha": "6d9ba8d44c089cead9ed0e1d687788448abd6994", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,7 +15,7 @@ struct Fat<T: ?Sized> {\n }\n \n struct Foo;\n-trait Bar {}\n+trait Bar : ::std::marker::MarkerTrait {}\n \n pub fn main() {\n     // With a vec of isize."}, {"sha": "aa687266acb8f701c9bae3461bb8b71c1c63c3e8", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,7 +15,7 @@ struct Fat<T: ?Sized> {\n }\n \n struct Foo;\n-trait Bar {}\n+trait Bar : ::std::marker::MarkerTrait {}\n impl Bar for Foo {}\n \n pub fn main() {"}, {"sha": "46b89e1122a2c0ddc7ada5caada90a2a87232d75", "filename": "src/test/compile-fail/dst-bad-coerce3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,7 +15,7 @@ struct Fat<T: ?Sized> {\n }\n \n struct Foo;\n-trait Bar {}\n+trait Bar : ::std::marker::MarkerTrait {}\n impl Bar for Foo {}\n \n fn baz<'a>() {"}, {"sha": "8ec1034bc4d28abda4abda17968fad6296a7f160", "filename": "src/test/compile-fail/dst-bad-coercions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,8 +10,10 @@\n \n // Test implicit coercions involving DSTs and raw pointers.\n \n+use std::marker::MarkerTrait;\n+\n struct S;\n-trait T {}\n+trait T : MarkerTrait {}\n impl T for S {}\n \n struct Foo<T: ?Sized> {"}, {"sha": "a1f0dda671e7de9b8b1d9a586d4696a2867f84e7", "filename": "src/test/compile-fail/dst-object-from-unsized-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,7 @@\n \n // Test that we cannot create objects from unsized types.\n \n-trait Foo {}\n+trait Foo : ::std::marker::MarkerTrait {}\n impl Foo for str {}\n \n fn test1<T: ?Sized + Foo>(t: &T) {"}, {"sha": "f47f14d587992f83c2a95790130da77cf6651fdc", "filename": "src/test/compile-fail/exclusive-drop-and-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fexclusive-drop-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fexclusive-drop-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexclusive-drop-and-copy.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -20,7 +20,7 @@ impl Drop for Foo {\n }\n \n #[derive(Copy)] //~ ERROR the trait `Copy` may not be implemented\n-struct Bar<T>;\n+struct Bar<T>(::std::marker::PhantomData<T>);\n \n #[unsafe_destructor]\n impl<T> Drop for Bar<T> {"}, {"sha": "9fea5e609d1f4807812476ea8b2e53c5da09fcdf", "filename": "src/test/compile-fail/generic-impl-less-params-with-defaults.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Foo<A, B, C = (A, B)>;\n+use std::marker;\n+\n+struct Foo<A, B, C = (A, B)>(\n+    marker::PhantomData<(A,B,C)>);\n \n impl<A, B, C = (A, B)> Foo<A, B, C> {\n-    fn new() -> Foo<A, B, C> {Foo}\n+    fn new() -> Foo<A, B, C> {Foo(marker::PhantomData)}\n }\n \n fn main() {"}, {"sha": "73c19aa012dcf67dd0d39d97f8a748f9cb1a436c", "filename": "src/test/compile-fail/generic-impl-more-params-with-defaults.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::marker;\n+\n struct Heap;\n \n-struct Vec<T, A = Heap>;\n+struct Vec<T, A = Heap>(\n+    marker::PhantomData<(T,A)>);\n \n impl<T, A = Heap> Vec<T, A> {\n-    fn new() -> Vec<T, A> {Vec}\n+    fn new() -> Vec<T, A> {Vec(marker::PhantomData)}\n }\n \n fn main() {"}, {"sha": "9b9f09f47775741bc19a7cd3855678833983c8b6", "filename": "src/test/compile-fail/generic-lifetime-trait-impl.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -16,9 +16,12 @@\n //\n // Regression test for issue #16218.\n \n-trait Bar<'a> {}\n+trait Bar<'a> {\n+    fn dummy(&'a self);\n+}\n \n trait Foo<'a> {\n+    fn dummy(&'a self) { }\n     fn bar<'b, T: Bar<'b>>(self) -> &'b str;\n }\n "}, {"sha": "37737fda4749e5004ce1e666560e0da343143158", "filename": "src/test/compile-fail/generic-type-less-params-with-defaults.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-type-less-params-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-type-less-params-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-type-less-params-with-defaults.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::marker;\n+\n struct Heap;\n \n-struct Vec<T, A = Heap>;\n+struct Vec<T, A = Heap>(\n+    marker::PhantomData<(T,A)>);\n \n fn main() {\n     let _: Vec; //~ ERROR wrong number of type arguments: expected at least 1, found 0"}, {"sha": "ad7e4f190c5b9df7fe358c88f9b51461e8024479", "filename": "src/test/compile-fail/generic-type-more-params-with-defaults.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-type-more-params-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-type-more-params-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-type-more-params-with-defaults.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::marker;\n+\n struct Heap;\n \n-struct Vec<T, A = Heap>;\n+struct Vec<T, A = Heap>(\n+    marker::PhantomData<(T,A)>);\n \n fn main() {\n     let _: Vec<isize, Heap, bool>;"}, {"sha": "a452cd35f943fc4484b588d121e2ca9cb5538f29", "filename": "src/test/compile-fail/generic-type-params-name-repr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::marker;\n+\n struct A;\n struct B;\n struct C;\n-struct Foo<T = A, U = B, V = C>;\n+struct Foo<T = A, U = B, V = C>(marker::PhantomData<(T,U,V)>);\n \n-struct Hash<T>;\n-struct HashMap<K, V, H = Hash<K>>;\n+struct Hash<T>(marker::PhantomData<T>);\n+struct HashMap<K, V, H = Hash<K>>(marker::PhantomData<(K,V,H)>);\n \n fn main() {\n     // Ensure that the printed type doesn't include the default type params..."}, {"sha": "4ff574e939df649794a2b31bdd4f49a374ed3c05", "filename": "src/test/compile-fail/issue-11515.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-struct Test<'s> {\n+struct Test {\n     func: Box<FnMut()+'static>\n }\n "}, {"sha": "dc697e4784f854e1cc113e75d91ae1d3362bb818", "filename": "src/test/compile-fail/issue-13853-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait FromStructReader<'a> { }\n+use std::marker::PhantomFn;\n+\n+trait FromStructReader<'a> : PhantomFn<(Self,&'a ())> { }\n trait ResponseHook {\n      fn get<'a, T: FromStructReader<'a>>(&'a self);\n }"}, {"sha": "7ca158c3e32045c31cbe5cb70ebaf94e1709845d", "filename": "src/test/compile-fail/issue-13853-3.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-13853-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-13853-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853-3.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,6 +10,8 @@\n \n #![crate_type = \"lib\"]\n \n+use std::marker::PhantomData;\n+\n enum NodeContents<'a> {\n     Children(Vec<Node<'a>>),\n }\n@@ -22,11 +24,12 @@ impl<'a> Drop for NodeContents<'a> {\n \n struct Node<'a> {\n     contents: NodeContents<'a>,\n+    marker: PhantomData<&'a ()>,\n }\n \n impl<'a> Node<'a> {\n     fn noName(contents: NodeContents<'a>) -> Node<'a> {\n-        Node{  contents: contents,}\n+        Node { contents: contents, marker: PhantomData }\n     }\n }\n "}, {"sha": "cd3f337c4ab658e2194dc2ab8686eaaac2105eb7", "filename": "src/test/compile-fail/issue-13853.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Node {\n+use std::marker::MarkerTrait;\n+\n+trait Node : MarkerTrait {\n     fn zomg();\n }\n "}, {"sha": "3a5df9e805bdb7e3c066ea9123f96fb55afca95f", "filename": "src/test/compile-fail/issue-14285.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-14285.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-14285.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14285.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {}\n+trait Foo {\n+    fn dummy(&self) { }\n+}\n \n struct A;\n "}, {"sha": "0b846651acf46dbf0e51056e8d31742859ddeb4c", "filename": "src/test/compile-fail/issue-14853.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n use std::fmt::Debug;\n+use std::marker::MarkerTrait;\n \n-trait Str {}\n+trait Str : MarkerTrait {}\n \n trait Something {\n     fn yay<T: Debug>(_: Option<Self>, thing: &[T]);"}, {"sha": "a213234b89b0ff247c73f9ac27cf1fc0dfce01d3", "filename": "src/test/compile-fail/issue-16747.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait ListItem<'a> {\n+use std::marker::MarkerTrait;\n+\n+trait ListItem<'a> : MarkerTrait {\n     fn list_name() -> &'a str;\n }\n "}, {"sha": "22aaa796ad0f4a0d62186527181140e6d98c7f60", "filename": "src/test/compile-fail/issue-17431-4.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Foo<T> { foo: Option<Option<Foo<T>>> }\n+use std::marker;\n+\n+struct Foo<T> { foo: Option<Option<Foo<T>>>, marker: marker::PhantomData<T> }\n //~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n \n impl<T> Foo<T> { fn bar(&self) {} }"}, {"sha": "cc9cc2e3c035c7ae6e4adb14e7ad9be7bb08414d", "filename": "src/test/compile-fail/issue-17431-5.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::marker;\n+\n struct Foo { foo: Bar<Foo> }\n-struct Bar<T> { x: Bar<Foo> }\n+struct Bar<T> { x: Bar<Foo> , marker: marker::PhantomData<T> }\n //~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n \n impl Foo { fn foo(&self) {} }"}, {"sha": "5781cb74117438b628b074ca5a8a5a428733957b", "filename": "src/test/compile-fail/issue-17551.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,9 +10,11 @@\n \n #![feature(unboxed_closures)]\n \n-struct B<T>;\n+use std::marker;\n+\n+struct B<T>(marker::PhantomData<T>);\n \n fn main() {\n-    let foo = B; //~ ERROR: unable to infer enough type information\n+    let foo = B(marker::PhantomData); //~ ERROR unable to infer enough type information\n     let closure = || foo;\n }"}, {"sha": "a33ec23a16a51e592bd11bc14fcea980f09b0576", "filename": "src/test/compile-fail/issue-17904-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-17904-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-17904-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17904-2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can parse a unit struct with a where clause, even if\n+// it leads to a error later on since `T` is unused.\n+\n+struct Foo<T> where T: Copy; //~ ERROR parameter `T` is never used\n+\n+fn main() {}"}, {"sha": "d5fb22bdebdb477d5c03cb68f3abdf80e40aaf01", "filename": "src/test/compile-fail/issue-18107.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-18107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-18107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18107.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::marker::MarkerTrait;\n \n-\n-pub trait AbstractRenderer {}\n+pub trait AbstractRenderer : MarkerTrait {}\n \n fn _create_render(_: &()) ->\n     AbstractRenderer"}, {"sha": "e81a576fa63d50d9267acf4e1eb82d70ba183fd0", "filename": "src/test/compile-fail/issue-18611.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::marker::MarkerTrait;\n+\n fn add_state(op: <isize as HasState>::State) {\n //~^ ERROR the trait `HasState` is not implemented for the type `isize`\n }\n \n-trait HasState {\n+trait HasState : MarkerTrait {\n     type State;\n }\n "}, {"sha": "13908bda9d83bf1e2d61f8d3304cc8144db12f97", "filename": "src/test/compile-fail/issue-18783.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -26,6 +26,7 @@ fn ufcs() {\n \n     Push::push(&c, box || y = 0);\n     Push::push(&c, box || y = 0);\n+//~^ ERROR cannot borrow `y` as mutable more than once at a time\n }\n \n trait Push<'c> {"}, {"sha": "951d78410b814602391a7e0376bc1c20e83388c4", "filename": "src/test/compile-fail/issue-18819.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {\n+use std::marker::MarkerTrait;\n+\n+trait Foo : MarkerTrait {\n     type Item;\n }\n "}, {"sha": "77aba7335bdf996cc9165263e73c13d2073254cf", "filename": "src/test/compile-fail/issue-19660.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-19660.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-19660.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19660.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,8 +13,12 @@\n #![feature(lang_items, start, no_std)]\n #![no_std]\n \n+#[lang=\"phantom_fn\"]\n+trait PhantomFn<A:?Sized,R:?Sized=()> { }\n+impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n+\n #[lang = \"sized\"]\n-trait Sized {}\n+trait Sized : PhantomFn<Self> {}\n \n #[start]\n fn main(_: int, _: *const *const u8) -> int {"}, {"sha": "aed395d17ea9ce803da2803395b76ec21549c098", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,10 +12,11 @@\n // cause compiler to loop.  Note that no instances\n // of such a type could ever be constructed.\n \n+use std::marker::MarkerTrait;\n \n struct t(Box<t>); //~ ERROR this type cannot be instantiated\n \n-trait to_str_2 {\n+trait to_str_2 : MarkerTrait {\n     fn my_to_string() -> String;\n }\n "}, {"sha": "5b623ac377b21260948f9ddbbb34a95dab1998f5", "filename": "src/test/compile-fail/issue-20831-debruijn.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,10 +13,11 @@\n // below. Note that changing to a named lifetime made the problem go\n // away.\n \n-use std::ops::{Shl, Shr};\n use std::cell::RefCell;\n+use std::marker::MarkerTrait;\n+use std::ops::{Shl, Shr};\n \n-pub trait Subscriber {\n+pub trait Subscriber : MarkerTrait {\n     type Input;\n }\n "}, {"sha": "24cc0099b89a522a1b7ae2441dabc6663ba3ce1d", "filename": "src/test/compile-fail/issue-2611-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,15 +12,15 @@\n // than the trait method it's implementing\n \n trait A {\n-  fn b<C,D>(x: C) -> C;\n+  fn b<C,D>(&self, x: C) -> C;\n }\n \n struct E {\n  f: isize\n }\n \n impl A for E {\n-    fn b<F: Sync, G>(_x: F) -> F { panic!() }\n+    fn b<F: Sync, G>(&self, _x: F) -> F { panic!() }\n     //~^ ERROR `F : core::marker::Sync` appears on the impl method\n }\n "}, {"sha": "af6cee1f10749f4aeb366fdfb7f6f6a04fedaed4", "filename": "src/test/compile-fail/issue-3008-3.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::marker;\n+\n enum E1 { V1(E2<E1>), }\n-enum E2<T> { V2(E2<E1>), }\n+enum E2<T> { V2(E2<E1>, marker::PhantomData<T>), }\n //~^ ERROR illegal recursive enum type; wrap the inner value in a box to make it representable\n \n impl E1 { fn foo(&self) {} }"}, {"sha": "f384dba7c9e3d69d2738df91b8bd5809713edcf7", "filename": "src/test/compile-fail/issue-4972.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,9 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n \n-trait MyTrait { }\n+trait MyTrait {\n+    fn dummy(&self) {}\n+}\n \n pub enum TraitWrapper {\n     A(Box<MyTrait+'static>),"}, {"sha": "d316b44794ad6e38c1a6749aad984e84060b8ace", "filename": "src/test/compile-fail/issue-5035-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait I {}\n+use std::marker::MarkerTrait;\n+\n+trait I : MarkerTrait {}\n type K = I+'static;\n \n fn foo(_x: K) {} //~ ERROR: the trait `core::marker::Sized` is not implemented"}, {"sha": "eccbc7896605e13106a72aaa467c9539254dca5f", "filename": "src/test/compile-fail/issue-5543.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,9 @@\n \n #![feature(box_syntax)]\n \n-trait Foo {}\n+use std::marker::MarkerTrait;\n+\n+trait Foo : MarkerTrait {}\n impl Foo for u8 {}\n \n fn main() {"}, {"sha": "b0db990619535534dc4bf8b7c5baebef9bab6203", "filename": "src/test/compile-fail/issue-5883.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait A {}\n+use std::marker::MarkerTrait;\n+\n+trait A : MarkerTrait {}\n \n struct Struct {\n     r: A+'static\n@@ -20,6 +22,6 @@ fn new_struct(r: A+'static)\n     Struct { r: r }\n }\n \n-trait Curve {}\n+trait Curve : MarkerTrait {}\n enum E {X(Curve+'static)}\n fn main() {}"}, {"sha": "0bf9a3c2d4867e365bd57b9d560383f10c6d5406", "filename": "src/test/compile-fail/issue-6458.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct TypeWithState<State>;\n+use std::marker;\n+\n+pub struct TypeWithState<State>(marker::PhantomData<State>);\n pub struct MyState;\n \n pub fn foo<State>(_: TypeWithState<State>) {}\n \n pub fn bar() {\n-   foo(TypeWithState);  //~ ERROR type annotations required\n+   foo(TypeWithState(marker::PhantomData));  //~ ERROR type annotations required\n }\n \n fn main() {"}, {"sha": "b6643f439529b2a76c6b62a73ea4676dce30dc17", "filename": "src/test/compile-fail/issue-7575.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,12 +10,14 @@\n \n // Test the mechanism for warning about possible missing `self` declarations.\n \n+use std::marker::MarkerTrait;\n+\n trait CtxtFn {\n     fn f8(self, usize) -> usize;\n     fn f9(usize) -> usize; //~ NOTE candidate\n }\n \n-trait OtherTrait {\n+trait OtherTrait : MarkerTrait {\n     fn f9(usize) -> usize; //~ NOTE candidate\n }\n \n@@ -24,7 +26,7 @@ trait OtherTrait {\n // declaration to match against, so we wind up prisizeing it as a\n // candidate. This seems not unreasonable -- perhaps the user meant to\n // implement it, after all.\n-trait UnusedTrait {\n+trait UnusedTrait : MarkerTrait {\n     fn f9(usize) -> usize; //~ NOTE candidate\n }\n \n@@ -52,7 +54,7 @@ impl Myisize {\n     }\n }\n \n-trait ManyImplTrait {\n+trait ManyImplTrait : MarkerTrait {\n     fn is_str() -> bool { //~ NOTE candidate\n         false\n     }"}, {"sha": "72da6dcaa6c45a22e76a62a97282c958d6273838", "filename": "src/test/compile-fail/issue-8727.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,16 +13,12 @@\n // Verify the compiler fails with an error on infinite function\n // recursions.\n \n-struct Data(Box<Option<Data>>);\n-\n-fn generic<T>( _ : Vec<(Data,T)> ) {\n-    let rec : Vec<(Data,(bool,T))> = Vec::new();\n-    generic( rec );\n+fn generic<T>() {\n+    generic::<Option<T>>();\n }\n \n \n fn main () {\n     // Use generic<T> at least once to trigger instantiation.\n-    let input : Vec<(Data,())> = Vec::new();\n-    generic(input);\n+    generic::<i32>();\n }"}, {"sha": "74e372e41eb0a1100821ef7fcaa9667a66932971", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,12 +10,12 @@\n \n // Test which of the builtin types are considered POD.\n \n-\n+use std::marker::MarkerTrait;\n use std::rc::Rc;\n \n fn assert_copy<T:Copy>() { }\n \n-trait Dummy { }\n+trait Dummy : MarkerTrait { }\n \n #[derive(Copy)]\n struct MyStruct {"}, {"sha": "b575144f637f1e73629df653cb0ae1ea8a3974c2", "filename": "src/test/compile-fail/kindck-impl-type-params-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,9 @@\n \n #![feature(box_syntax)]\n \n-trait Foo {\n+use std::marker::MarkerTrait;\n+\n+trait Foo : MarkerTrait {\n }\n \n impl<T:Copy> Foo for T {"}, {"sha": "dffc8fa2abd70d95def12e4df2eb40fdf247cea3", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,40 +13,44 @@\n \n #![feature(box_syntax)]\n \n-struct S<T>;\n+use std::marker;\n \n-trait Gettable<T> {}\n+struct S<T>(marker::PhantomData<T>);\n+\n+trait Gettable<T> {\n+    fn get(&self) -> T { panic!() }\n+}\n \n impl<T: Send + Copy + 'static> Gettable<T> for S<T> {}\n \n fn f<T>(val: T) {\n-    let t: S<T> = S;\n+    let t: S<T> = S(marker::PhantomData);\n     let a = &t as &Gettable<T>;\n     //~^ ERROR the trait `core::marker::Send` is not implemented\n     //~^^ ERROR the trait `core::marker::Copy` is not implemented\n }\n \n fn g<T>(val: T) {\n-    let t: S<T> = S;\n+    let t: S<T> = S(marker::PhantomData);\n     let a: &Gettable<T> = &t;\n     //~^ ERROR the trait `core::marker::Send` is not implemented\n     //~^^ ERROR the trait `core::marker::Copy` is not implemented\n }\n \n fn foo<'a>() {\n-    let t: S<&'a isize> = S;\n+    let t: S<&'a isize> = S(marker::PhantomData);\n     let a = &t as &Gettable<&'a isize>;\n-    //~^ ERROR the type `&'a isize` does not fulfill the required lifetime\n+    //~^ ERROR cannot infer\n }\n \n fn foo2<'a>() {\n-    let t: Box<S<String>> = box S;\n+    let t: Box<S<String>> = box S(marker::PhantomData);\n     let a = t as Box<Gettable<String>>;\n     //~^ ERROR the trait `core::marker::Copy` is not implemented\n }\n \n fn foo3<'a>() {\n-    let t: Box<S<String>> = box S;\n+    let t: Box<S<String>> = box S(marker::PhantomData);\n     let a: Box<Gettable<String>> = t;\n     //~^ ERROR the trait `core::marker::Copy` is not implemented\n }"}, {"sha": "0c68401bb2b955222bbd712a92ee02f8603ae50e", "filename": "src/test/compile-fail/kindck-send-object.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,8 +12,10 @@\n // in this file all test the \"kind\" violates detected during kindck.\n // See all `regions-bounded-by-send.rs`\n \n+use std::marker::MarkerTrait;\n+\n fn assert_send<T:Send>() { }\n-trait Dummy { }\n+trait Dummy : MarkerTrait { }\n trait Message : Send { }\n \n // careful with object types, who knows what they close over..."}, {"sha": "f86eac8b16bd2bcfdb158fbb58315b6dd1d4c2d8", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,8 +12,10 @@\n // is broken into two parts because some errors occur in distinct\n // phases in the compiler. See kindck-send-object2.rs as well!\n \n+use std::marker::MarkerTrait;\n+\n fn assert_send<T:Send+'static>() { }\n-trait Dummy { }\n+trait Dummy : MarkerTrait { }\n \n // careful with object types, who knows what they close over...\n fn test51<'a>() {"}, {"sha": "08516e67318ce2b5ff0e31efd4a9ef16a0eb8445", "filename": "src/test/compile-fail/kindck-send-object2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,8 +10,10 @@\n \n // Continue kindck-send-object1.rs.\n \n+use std::marker::MarkerTrait;\n+\n fn assert_send<T:Send>() { }\n-trait Dummy { }\n+trait Dummy : MarkerTrait { }\n \n fn test50() {\n     assert_send::<&'static Dummy>(); //~ ERROR the trait `core::marker::Sync` is not implemented"}, {"sha": "66d8927ee51b7096b6cfa3826d1b6202dfe6b723", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-3.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,9 @@\n \n // ignore-tidy-linelength\n \n-struct Bar<'x, 'y, 'z> { bar: &'y i32, baz: i32 }\n+use std::marker::PhantomData;\n+\n+struct Bar<'x, 'y, 'z> { bar: &'y i32, baz: i32, marker: PhantomData<(&'x(),&'y(),&'z())> }\n fn bar1<'a>(x: &Bar) -> (&'a i32, &'a i32, &'a i32) {\n //~^ HELP: consider using an explicit lifetime parameter as shown: fn bar1<'b, 'c, 'a>(x: &'a Bar<'b, 'a, 'c>) -> (&'a i32, &'a i32, &'a i32)\n     (x.bar, &x.baz, &x.baz)"}, {"sha": "a85776a938b44f189ab62db91ba6c9980175899d", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,9 @@\n \n // ignore-tidy-linelength\n \n-struct Foo<'x> { bar: isize }\n+use std::marker::PhantomData;\n+\n+struct Foo<'x> { bar: isize, marker: PhantomData<&'x ()> }\n fn foo1<'a>(x: &Foo) -> &'a isize {\n //~^ HELP: consider using an explicit lifetime parameter as shown: fn foo1<'a>(x: &'a Foo) -> &'a isize\n     &x.bar //~ ERROR: cannot infer"}, {"sha": "73a58741bbbbc42ddbcf7efa384d9d578f86fed4", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -47,20 +47,26 @@ fn foo3() {}\n /// dox\n pub trait A {\n     /// dox\n-    fn foo();\n+    fn foo(&self);\n     /// dox\n-    fn foo_with_impl() {}\n+    fn foo_with_impl(&self) {}\n }\n+\n #[allow(missing_docs)]\n trait B {\n-    fn foo();\n-    fn foo_with_impl() {}\n+    fn foo(&self);\n+    fn foo_with_impl(&self) {}\n }\n+\n pub trait C { //~ ERROR: missing documentation\n-    fn foo(); //~ ERROR: missing documentation\n-    fn foo_with_impl() {} //~ ERROR: missing documentation\n+    fn foo(&self); //~ ERROR: missing documentation\n+    fn foo_with_impl(&self) {} //~ ERROR: missing documentation\n+}\n+\n+#[allow(missing_docs)]\n+pub trait D {\n+    fn dummy(&self) { }\n }\n-#[allow(missing_docs)] pub trait D {}\n \n impl Foo {\n     pub fn foo() {}"}, {"sha": "9f58d5791cb0bcbb07e14ad3ad0a2c1c93cc87e8", "filename": "src/test/compile-fail/lint-non-camel-case-types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flint-non-camel-case-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flint-non-camel-case-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-non-camel-case-types.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -30,6 +30,7 @@ enum Foo5 {\n }\n \n trait foo6 { //~ ERROR trait `foo6` should have a camel case name such as `Foo6`\n+    fn dummy(&self) { }\n }\n \n fn f<ty>(_: ty) {} //~ ERROR type parameter `ty` should have a camel case name such as `Ty`"}, {"sha": "88f2cbdea6d7bf81332f15efb3caf5e1dc4e6d47", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -341,7 +341,9 @@ mod this_crate {\n \n     #[unstable(feature = \"test_feature\")]\n     #[deprecated(since = \"1.0.0\")]\n-    pub trait DeprecatedTrait {}\n+    pub trait DeprecatedTrait {\n+        fn dummy(&self) { }\n+    }\n \n     struct S;\n "}, {"sha": "918b4ee209ca7ac6106a3fcd18d3b7d17e7185ea", "filename": "src/test/compile-fail/lint-visible-private-types.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,8 +12,10 @@\n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n-struct Private<T>;\n-pub struct Public<T>;\n+use std::marker;\n+\n+struct Private<T>(marker::PhantomData<T>);\n+pub struct Public<T>(marker::PhantomData<T>);\n \n impl Private<Public<isize>> {\n     pub fn a(&self) -> Private<isize> { panic!() }\n@@ -103,7 +105,7 @@ impl PrivTrait for (Private<isize>,) {\n     fn bar(&self) -> Private<isize> { panic!() }\n }\n \n-pub trait ParamTrait<T> {\n+pub trait ParamTrait<T> : marker::MarkerTrait {\n     fn foo() -> T;\n }\n "}, {"sha": "03d8d62e0b4d5c24aae817a0b9691dfb62b22de1", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::marker;\n+\n fn send<T:Send + std::fmt::Debug>(ch: _chan<T>, data: T) {\n     println!(\"{:?}\", ch);\n     println!(\"{:?}\", data);\n     panic!();\n }\n \n #[derive(Debug)]\n-struct _chan<T>(isize);\n+struct _chan<T>(isize, marker::PhantomData<T>);\n \n // Tests that \"log(debug, message);\" is flagged as using\n // message after the send deinitializes it"}, {"sha": "6e8719eeaceda58e6ffce825b5805468cdc8f542", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,7 +14,10 @@ extern crate collections;\n \n use std::collections::HashMap;\n \n-trait Map<K, V> {}\n+trait Map<K, V>\n+{\n+    fn get(&self, k: K) -> V { panic!() }\n+}\n \n impl<K, V> Map<K, V> for HashMap<K, V> {}\n "}, {"sha": "cb5da4bb547725789cf8b45a56bf5b3b1e63093e", "filename": "src/test/compile-fail/method-ambig-one-trait-coerce.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs?ref=3e7a04cb3cac2b803dc8188d9a55ba1836404ea3", "patch": "@@ -1,50 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that when we pick a trait based on coercion, versus subtyping,\n-// we consider all possible coercions equivalent and don't try to pick\n-// a best one.\n-\n-trait Object { }\n-\n-trait foo {\n-    fn foo(self) -> isize;\n-}\n-\n-impl foo for Box<Object+'static> {\n-    fn foo(self) -> isize {1}\n-}\n-\n-impl foo for Box<Object+Send> {\n-    fn foo(self) -> isize {2}\n-}\n-\n-fn test1(x: Box<Object+Send+Sync>) {\n-    // FIXME(#18737) -- we ought to consider this to be ambiguous,\n-    // since we could coerce to either impl. However, what actually\n-    // happens is that we consider both impls applicable because of\n-    // incorrect subtyping relation. We then decide to call this a\n-    // call to the `foo` trait, leading to the following error\n-    // message.\n-\n-    x.foo(); //~ ERROR `foo` is not implemented\n-}\n-\n-fn test2(x: Box<Object+Send>) {\n-    // Not ambiguous because it is a precise match:\n-    x.foo();\n-}\n-\n-fn test3(x: Box<Object+'static>) {\n-    // Not ambiguous because it is a precise match:\n-    x.foo();\n-}\n-\n-fn main() { }"}, {"sha": "607ab13d122015d6f8ff42e92c56a5a3d5ed8062", "filename": "src/test/compile-fail/object-does-not-impl-trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,8 +11,9 @@\n // Test that an object type `Box<Foo>` is not considered to implement the\n // trait `Foo`. Issue #5087.\n \n+use std::marker::MarkerTrait;\n \n-trait Foo {}\n+trait Foo : MarkerTrait {}\n fn take_foo<F:Foo>(f: F) {}\n fn take_object(f: Box<Foo>) { take_foo(f); }\n //~^ ERROR the trait `Foo` is not implemented"}, {"sha": "23ddea4499a728c51b1fa08bb416cb6a0de71b2c", "filename": "src/test/compile-fail/object-lifetime-default-mybox.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -37,7 +37,6 @@ fn load1<'a,'b>(a: &'a MyBox<SomeTrait>,\n     a\n       //~^ ERROR cannot infer\n       //~| ERROR mismatched types\n-      //~| ERROR mismatched types\n }\n \n fn main() {"}, {"sha": "aae829ec7b5636c124b55bd953b59f78cbcff1fe", "filename": "src/test/compile-fail/object-safety-no-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,7 @@\n // Check that we correctly prevent users from making trait objects\n // from traits with static methods.\n \n-trait Foo {\n+trait Foo : ::std::marker::MarkerTrait {\n     fn foo();\n }\n "}, {"sha": "7538b1c85e533fe610462dbf172433b8ef90442d", "filename": "src/test/compile-fail/on-unimplemented-bad-anno.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fon-unimplemented-bad-anno.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fon-unimplemented-bad-anno.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented-bad-anno.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,8 +13,12 @@\n \n #![allow(unused)]\n \n+use std::marker;\n+\n #[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}` `{Baz}` `{Quux}`\"]\n-trait Foo<Bar, Baz, Quux>{}\n+trait Foo<Bar, Baz, Quux>\n+    : marker::PhantomFn<(Self,Bar,Baz,Quux)>\n+{}\n \n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be built from an iterator over elements of type `{A}`\"]\n trait MyFromIterator<A> {\n@@ -23,15 +27,21 @@ trait MyFromIterator<A> {\n }\n \n #[rustc_on_unimplemented] //~ ERROR this attribute must have a value\n-trait BadAnnotation1 {}\n+trait BadAnnotation1\n+    : marker::MarkerTrait\n+{}\n \n #[rustc_on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{C}>`\"]\n //~^ ERROR there is no type parameter C on trait BadAnnotation2\n-trait BadAnnotation2<A,B> {}\n+trait BadAnnotation2<A,B>\n+    : marker::PhantomFn<(Self,A,B)>\n+{}\n \n #[rustc_on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{}>`\"]\n //~^ only named substitution parameters are allowed\n-trait BadAnnotation3<A,B> {}\n+trait BadAnnotation3<A,B>\n+    : marker::PhantomFn<(Self,A,B)>\n+{}\n \n pub fn main() {\n }"}, {"sha": "2447d0864226aee75dd0decae2bf692b5032104e", "filename": "src/test/compile-fail/on-unimplemented.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,8 +11,12 @@\n \n #![feature(on_unimplemented)]\n \n+use std::marker;\n+\n #[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}` `{Baz}` `{Quux}`\"]\n-trait Foo<Bar, Baz, Quux>{}\n+trait Foo<Bar, Baz, Quux>\n+    : marker::PhantomFn<(Self,Bar,Baz,Quux)>\n+{}\n \n fn foobar<U: Clone, T: Foo<u8, U, u32>>() -> T {\n "}, {"sha": "8201565c3318dce282c41bbb57dcc458f34836b9", "filename": "src/test/compile-fail/orphan-check-diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Forphan-check-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Forphan-check-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Forphan-check-diagnostics.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,7 +15,7 @@ extern crate orphan_check_diagnostics;\n \n use orphan_check_diagnostics::RemoteTrait;\n \n-trait LocalTrait {}\n+trait LocalTrait { fn dummy(&self) { } }\n \n impl<T> RemoteTrait for T where T: LocalTrait {}\n //~^ ERROR type parameter `T` must be used as the type parameter for some local type"}, {"sha": "43d112b8aa0043aee7937ee05d0ecebc23d185e3", "filename": "src/test/compile-fail/priv-in-bad-locations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fpriv-in-bad-locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fpriv-in-bad-locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpriv-in-bad-locations.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,15 +14,15 @@ pub extern {\n }\n \n trait A {\n-    fn foo() {}\n+    fn foo(&self) {}\n }\n \n struct B;\n \n pub impl B {} //~ ERROR: unnecessary visibility\n \n pub impl A for B { //~ ERROR: unnecessary visibility\n-    pub fn foo() {} //~ ERROR: unnecessary visibility\n+    pub fn foo(&self) {} //~ ERROR: unnecessary visibility\n }\n \n pub fn main() {}"}, {"sha": "67bb566ea682c07b1568202a6c213156d3a92d46", "filename": "src/test/compile-fail/privacy-ns2.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -17,7 +17,9 @@\n \n // public type, private value\n pub mod foo1 {\n-    pub trait Bar {\n+    use std::marker::MarkerTrait;\n+\n+    pub trait Bar : MarkerTrait {\n     }\n     pub struct Baz;\n \n@@ -39,7 +41,7 @@ fn test_list1() {\n \n // private type, public value\n pub mod foo2 {\n-    trait Bar {\n+    trait Bar : ::std::marker::MarkerTrait {\n     }\n     pub struct Baz;\n \n@@ -60,7 +62,7 @@ fn test_list2() {\n \n // neither public\n pub mod foo3 {\n-    trait Bar {\n+    trait Bar : ::std::marker::MarkerTrait {\n     }\n     pub struct Baz;\n "}, {"sha": "1ae79adbad76ae953da4cf7aa0045da158c03de5", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,11 +11,15 @@\n #![feature(lang_items, start, no_std)]\n #![no_std] // makes debugging this test *a lot* easier (during resolve)\n \n+#[lang=\"phantom_fn\"]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n+impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n+\n #[lang=\"sized\"]\n-pub trait Sized {}\n+pub trait Sized : PhantomFn<Self> {}\n \n #[lang=\"copy\"]\n-pub trait Copy {}\n+pub trait Copy : PhantomFn<Self> {}\n \n mod bar {\n     // shouldn't bring in too much"}, {"sha": "adce93af0794f9a0f5d8cf0eae6aa95f6ec5f467", "filename": "src/test/compile-fail/privacy4.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,8 +11,12 @@\n #![feature(lang_items, start, no_std)]\n #![no_std] // makes debugging this test *a lot* easier (during resolve)\n \n-#[lang = \"sized\"] pub trait Sized {}\n-#[lang=\"copy\"] pub trait Copy {}\n+#[lang=\"phantom_fn\"]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n+impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n+\n+#[lang = \"sized\"] pub trait Sized : PhantomFn<Self> {}\n+#[lang=\"copy\"] pub trait Copy : PhantomFn<Self> {}\n \n // Test to make sure that private items imported through globs remain private\n // when  they're used."}, {"sha": "2da414befd8979312cc7b1c3e18466197d5f9f7a", "filename": "src/test/compile-fail/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,7 +13,7 @@\n \n #![feature(box_syntax)]\n \n-trait Foo {}\n+trait Foo : ::std::marker::MarkerTrait {}\n impl<'a> Foo for &'a [u8] {}\n \n fn a(v: &[u8]) -> Box<Foo + 'static> {"}, {"sha": "f921eccef1f8cdc713d340b54f15251f4dadb40f", "filename": "src/test/compile-fail/regions-assoc-type-region-bound-in-trait-not-met.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-region-bound-in-trait-not-met.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-region-bound-in-trait-not-met.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-region-bound-in-trait-not-met.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,10 @@\n // Test that the compiler checks that arbitrary region bounds declared\n // in the trait must be satisfied on the impl. Issue #20890.\n \n-trait Foo<'a> { type Value: 'a; }\n+trait Foo<'a> {\n+    type Value: 'a;\n+    fn dummy(&'a self) { }\n+}\n \n impl<'a> Foo<'a> for &'a i16 {\n     // OK."}, {"sha": "1cf83b8ac585f75f2833480bb0535eb975fa4d54", "filename": "src/test/compile-fail/regions-assoc-type-static-bound-in-trait-not-met.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-static-bound-in-trait-not-met.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-static-bound-in-trait-not-met.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-static-bound-in-trait-not-met.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,10 @@\n // Test that the compiler checks that the 'static bound declared in\n // the trait must be satisfied on the impl. Issue #20890.\n \n-trait Foo { type Value: 'static; }\n+trait Foo {\n+    type Value: 'static;\n+    fn dummy(&self) { }\n+}\n \n impl<'a> Foo for &'a i32 {\n     //~^ ERROR cannot infer"}, {"sha": "278ccd3c11936f3b931d0cd2ce64912ec55cc0c5", "filename": "src/test/compile-fail/regions-bound-missing-bound-in-impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -21,10 +21,9 @@ pub trait Foo<'a, 't> {\n     fn has_bound<'b:'a>(self, b: Inv<'b>);\n     fn wrong_bound1<'b,'c,'d:'a+'b>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>);\n     fn okay_bound<'b,'c,'d:'a+'b+'c>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>);\n-    fn another_bound<'x: 'a>(self, x: Inv<'x>);\n+    fn another_bound<'x: 'a>(self, x: Inv<'x>, y: Inv<'t>);\n }\n \n-\n impl<'a, 't> Foo<'a, 't> for &'a isize {\n     fn no_bound<'b:'a>(self, b: Inv<'b>) {\n         //~^ ERROR lifetime parameters or bounds on method `no_bound` do not match\n@@ -51,7 +50,7 @@ impl<'a, 't> Foo<'a, 't> for &'a isize {\n     fn okay_bound<'b,'c,'e:'b+'c>(self, b: Inv<'b>, c: Inv<'c>, e: Inv<'e>) {\n     }\n \n-    fn another_bound<'x: 't>(self, x: Inv<'x>) {}\n+    fn another_bound<'x: 't>(self, x: Inv<'x>, y: Inv<'t>) {}\n }\n \n fn main() { }"}, {"sha": "f13d8a60894cb6b7ae9e3f4162cd52b427e49167", "filename": "src/test/compile-fail/regions-bounded-method-type-parameters-trait-bound.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-trait-bound.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,16 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(lang_items, no_std)]\n-#![no_std]\n-\n // Check that explicit region bounds are allowed on the various\n // nominal types (but not on other types) and that they are type\n // checked.\n \n-#[lang=\"sized\"]\n-trait Sized { }\n-\n struct Inv<'a> { // invariant w/r/t 'a\n     x: &'a mut &'a isize\n }"}, {"sha": "979c1e997d03c8b694c2bcb78605f5fcade1e610", "filename": "src/test/compile-fail/regions-close-associated-type-into-object.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,9 @@\n \n #![feature(box_syntax)]\n \n-trait X {}\n+use std::marker::MarkerTrait;\n+\n+trait X : MarkerTrait {}\n \n trait Iter {\n     type Item: X;"}, {"sha": "7bbce7dad530db4fc9a21ab9a947009c486d8b8a", "filename": "src/test/compile-fail/regions-close-object-into-object-1.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,13 +11,16 @@\n #![feature(box_syntax)]\n #![allow(warnings)]\n \n-trait A<T> {}\n+use std::marker::PhantomFn;\n+\n+trait A<T> : PhantomFn<(Self,T)> { }\n struct B<'a, T>(&'a (A<T>+'a));\n \n-trait X {}\n+trait X : ::std::marker::MarkerTrait {}\n+\n impl<'a, T> X for B<'a, T> {}\n \n-fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n+fn f<'a, T:'static, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n     box B(&*v) as Box<X> //~ ERROR `*v` does not live long enough\n }\n "}, {"sha": "6de49020a6fbbaff0d6b2b0d584d28deffcd5512", "filename": "src/test/compile-fail/regions-close-object-into-object-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,10 +10,12 @@\n \n #![feature(box_syntax)]\n \n-trait A<T> {}\n+use std::marker::PhantomFn;\n+\n+trait A<T> : PhantomFn<(Self,T)> { }\n struct B<'a, T>(&'a (A<T>+'a));\n \n-trait X {}\n+trait X : PhantomFn<Self> {}\n impl<'a, T> X for B<'a, T> {}\n \n fn g<'a, T: 'static>(v: Box<A<T>+'a>) -> Box<X+'static> {"}, {"sha": "e22d0c7d0a4f51bc9b14f95c53c90d077c3609b2", "filename": "src/test/compile-fail/regions-close-object-into-object-3.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,10 +11,12 @@\n #![feature(box_syntax)]\n #![allow(warnings)]\n \n-trait A<T> {}\n+use std::marker::PhantomFn;\n+\n+trait A<T> : PhantomFn<(Self,T)> {}\n struct B<'a, T>(&'a (A<T>+'a));\n \n-trait X {}\n+trait X : PhantomFn<Self> {}\n impl<'a, T> X for B<'a, T> {}\n \n fn h<'a, T, U>(v: Box<A<U>+'static>) -> Box<X+'static> {"}, {"sha": "147a575d38caca1ce10c1e18d4925efa308b7236", "filename": "src/test/compile-fail/regions-close-object-into-object-4.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,10 +10,12 @@\n \n #![feature(box_syntax)]\n \n-trait A<T> {}\n+use std::marker::PhantomFn;\n+\n+trait A<T> : PhantomFn<(Self,T)> {}\n struct B<'a, T>(&'a (A<T>+'a));\n \n-trait X {}\n+trait X : PhantomFn<Self> {}\n impl<'a, T> X for B<'a, T> {}\n \n fn i<'a, T, U>(v: Box<A<U>+'a>) -> Box<X+'static> {"}, {"sha": "05c6c6d9f9e02dddde174e0241d411a22fb0d0d1", "filename": "src/test/compile-fail/regions-close-object-into-object-5.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+#![allow(warnings)]\n+\n+use std::marker::MarkerTrait;\n+\n+trait A<T>\n+{\n+    fn get(&self) -> T { panic!() }\n+}\n+\n+struct B<'a, T>(&'a (A<T>+'a));\n+\n+trait X : MarkerTrait {}\n+\n+impl<'a, T> X for B<'a, T> {}\n+\n+fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n+    box B(&*v) as Box<X> //~ ERROR the parameter type `T` may not live long enough\n+}\n+\n+fn main() {}\n+"}, {"sha": "2341d2397c9b04d5f635fe6ade7e86c675ae5853", "filename": "src/test/compile-fail/regions-close-over-borrowed-ref-in-obj.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,9 @@\n \n #![feature(box_syntax)]\n \n-trait Foo { }\n+use std::marker::MarkerTrait;\n+\n+trait Foo : MarkerTrait { }\n \n impl<'a> Foo for &'a isize { }\n "}, {"sha": "9ad49a6703ee3abc939afb4cabb84eba2b67d4c5", "filename": "src/test/compile-fail/regions-close-param-into-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-trait X {}\n+trait X : ::std::marker::MarkerTrait {}\n \n fn p1<T>(v: T) -> Box<X+'static>\n     where T : X"}, {"sha": "b7ef19d1e3bfc11be9c557cfc157ace2b5c160f8", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-decl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -20,7 +20,7 @@ use std::marker;\n // Contravariant<'foo> <: Contravariant<'static> because\n // 'foo <= 'static\n struct Contravariant<'a> {\n-    marker: marker::ContravariantLifetime<'a>\n+    marker: marker::PhantomData<&'a()>\n }\n \n fn use_<'short,'long>(c: Contravariant<'short>,"}, {"sha": "0d3d9dacbd6f6c0a3517aed2045a09155c1b1931", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-decl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -17,7 +17,7 @@\n use std::marker;\n \n struct Covariant<'a> {\n-    marker: marker::CovariantLifetime<'a>\n+    marker: marker::PhantomData<fn(&'a ())>\n }\n \n fn use_<'short,'long>(c: Covariant<'long>,"}, {"sha": "8c191fbd5bbe7ea86b0be74ae4e4d1403bd659d0", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-decl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-decl.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,7 @@\n use std::marker;\n \n struct invariant<'a> {\n-    marker: marker::InvariantLifetime<'a>\n+    marker: marker::PhantomData<*mut &'a()>\n }\n \n fn to_same_lifetime<'r>(b_isize: invariant<'r>) {"}, {"sha": "1b749faf1b8b92a50b0f86af687899ddceb4f40f", "filename": "src/test/compile-fail/required-lang-item.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,11 @@\n #![feature(lang_items, no_std)]\n #![no_std]\n \n-#[lang=\"sized\"] pub trait Sized {}\n+#[lang=\"phantom_fn\"]\n+pub trait PhantomFn<T:?Sized> { }\n+impl<T:?Sized, U:?Sized> PhantomFn<T> for U { }\n+\n+#[lang=\"sized\"] pub trait Sized : PhantomFn<Self> {}\n \n // error-pattern:requires `start` lang_item\n "}, {"sha": "1f72db1e894faa3d081728bc7505f3d6f10e0070", "filename": "src/test/compile-fail/shadowed-type-parameter.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fshadowed-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fshadowed-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadowed-type-parameter.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,19 +12,21 @@\n \n #![feature(box_syntax)]\n \n-struct Foo<T>;\n+struct Foo<T>(T);\n \n impl<T> Foo<T> {\n     fn shadow_in_method<T>(&self) {}\n     //~^ ERROR type parameter `T` shadows another type parameter\n \n     fn not_shadow_in_item<U>(&self) {\n-        struct Bar<T, U>; // not a shadow, separate item\n+        struct Bar<T, U>(T,U); // not a shadow, separate item\n         fn foo<T, U>() {} // same\n     }\n }\n \n trait Bar<T> {\n+    fn dummy(&self) -> T;\n+\n     fn shadow_in_required<T>(&self);\n     //~^ ERROR type parameter `T` shadows another type parameter\n "}, {"sha": "3c1c3796a246f172baef08c48c056dc541f0a923", "filename": "src/test/compile-fail/slightly-nice-generic-literal-messages.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fslightly-nice-generic-literal-messages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fslightly-nice-generic-literal-messages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslightly-nice-generic-literal-messages.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Foo<T,U>(T);\n+use std::marker;\n+\n+struct Foo<T,U>(T, marker::PhantomData<U>);\n \n fn main() {\n-    match Foo(1.1) {\n+    match Foo(1.1, marker::PhantomData) {\n         1 => {}\n     //~^ ERROR mismatched types\n     //~| expected `Foo<_, _>`"}, {"sha": "2dfc9b79ee20aca1e9a01a7b7307ed1cbb94634c", "filename": "src/test/compile-fail/staticness-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n trait foo {\n+    fn dummy(&self) { }\n     fn bar();\n }\n "}, {"sha": "fff144140947a11307157513cc8d4900e26444a0", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait TraitNotAStruct { }\n+trait TraitNotAStruct : ::std::marker::MarkerTrait { }\n \n fn main() {\n     TraitNotAStruct{ value: 0 };"}, {"sha": "3129dceffbb664c3d2471ba61e3a38b7df2562b1", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,6 +10,7 @@\n \n \n trait Foo {\n+    fn dummy(&self) { }\n }\n \n fn a(_x: Box<Foo+Send>) {"}, {"sha": "34e06cc93658aedd3b0d4e4f22bfa79158710ef5", "filename": "src/test/compile-fail/trait-bounds-impl-comparison-1.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,10 @@\n // Make sure rustc checks the type parameter bounds in implementations of traits,\n // see #2687\n \n-trait A {}\n+use std::marker;\n+\n+trait A : marker::PhantomFn<Self> {\n+}\n \n trait B: A {}\n \n@@ -62,15 +65,16 @@ impl Foo for isize {\n     //~^ ERROR the requirement `T : C` appears on the impl\n }\n \n-\n-trait Getter<T> { }\n+trait Getter<T> {\n+    fn get(&self) -> T { loop { } }\n+}\n \n trait Trait {\n-    fn method<G:Getter<isize>>();\n+    fn method<G:Getter<isize>>(&self);\n }\n \n impl Trait for usize {\n-    fn method<G: Getter<usize>>() {}\n+    fn method<G: Getter<usize>>(&self) {}\n     //~^ G : Getter<usize>` appears on the impl method but not on the corresponding trait method\n }\n "}, {"sha": "284c4fac953f2302b81fcc9b9efa6a0ba7d9ead5", "filename": "src/test/compile-fail/trait-bounds-impl-comparison-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,7 +14,9 @@ trait Iterator<A> {\n     fn next(&mut self) -> Option<A>;\n }\n \n-trait IteratorUtil<A> {\n+trait IteratorUtil<A>\n+    : ::std::marker::PhantomFn<(),A>\n+{\n     fn zip<B, U: Iterator<U>>(self, other: U) -> ZipIterator<Self, U>;\n }\n "}, {"sha": "448b186f6a5c6de1cff16451a9ff6db965d8cb7e", "filename": "src/test/compile-fail/trait-bounds-not-on-bare-trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n trait Foo {\n+    fn dummy(&self) { }\n }\n \n // This should emit the less confusing error, not the more confusing one."}, {"sha": "df44e847c50fd5ffca5d96fbad2edc875444fd8c", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-locals.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Trait {}\n+trait Trait {\n+    fn dummy(&self) { }\n+}\n \n struct Foo<T:Trait> {\n     x: T,"}, {"sha": "18871d0d386d77ec178838299a0861bbb8e7e338", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-static.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Trait {}\n+trait Trait {\n+    fn dummy(&self) { }\n+}\n \n struct Foo<T:Trait> {\n     x: T,"}, {"sha": "8dfdb2f205d6f27d7e423e7ea2cb471485d812f7", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Trait {}\n+use std::marker::MarkerTrait;\n+\n+trait Trait : MarkerTrait {}\n \n struct Foo<T:Trait> {\n     x: T,\n@@ -51,15 +53,15 @@ enum MoreBadness<V> {\n     EvenMoreBadness(Bar<V>),\n }\n \n-trait PolyTrait<T> {\n-    fn whatever() {}\n+trait PolyTrait<T>\n+{\n+    fn whatever(&self, t: T) {}\n }\n \n struct Struct;\n \n impl PolyTrait<Foo<usize>> for Struct {\n //~^ ERROR not implemented\n-    fn whatever() {}\n }\n \n fn main() {"}, {"sha": "e4058a0943aadb770f92e4edfe031b2fd91c18f7", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,8 +10,9 @@\n \n // Tests for \"default\" bounds inferred for traits with no bounds list.\n \n+use std::marker::MarkerTrait;\n \n-trait Foo {}\n+trait Foo : MarkerTrait {}\n \n fn a(_x: Box<Foo+Send>) {\n }"}, {"sha": "2f4793b4d888f094ea5eaf8fa4594608d640def9", "filename": "src/test/compile-fail/trait-impl-1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,7 +12,9 @@\n // trait impl is only applied to a trait object, not concrete types which implement\n // the trait.\n \n-trait T {}\n+use std::marker::MarkerTrait;\n+\n+trait T : MarkerTrait {}\n \n impl<'a> T+'a {\n     fn foo(&self) {}"}, {"sha": "d45d13556e12188b91d70f2a21cca6aa1a057c5b", "filename": "src/test/compile-fail/trait-object-safety.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-object-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-object-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-object-safety.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,6 +12,7 @@\n \n trait Tr {\n     fn foo();\n+    fn bar(&self) { }\n }\n \n struct St;"}, {"sha": "0e357d9d4d53147a0b3037fe8adc66cca0be36b8", "filename": "src/test/compile-fail/trait-static-method-generic-inference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-static-method-generic-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftrait-static-method-generic-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-static-method-generic-inference.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -16,6 +16,7 @@\n mod base {\n     pub trait HasNew<T> {\n         fn new() -> T;\n+        fn dummy(&self) { }\n     }\n \n     pub struct Foo {"}, {"sha": "557fb2f4f8833ff18f775a5c654841ebf9760fcf", "filename": "src/test/compile-fail/typeck-negative-impls-builtin.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,7 +12,9 @@\n \n struct TestType;\n \n-trait TestTrait {}\n+trait TestTrait {\n+    fn dummy(&self) { }\n+}\n \n impl !TestTrait for TestType {}\n //~^ ERROR  negative impls are currently allowed just for `Send` and `Sync`"}, {"sha": "1daea8f915b3f192000223342b02f915492c35f3", "filename": "src/test/compile-fail/typeck_type_placeholder_mismatch.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_mismatch.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,14 +11,16 @@\n // This test checks that genuine type errors with partial\n // type hints are understandable.\n \n-struct Foo<T>;\n-struct Bar<U>;\n+use std::marker::PhantomData;\n+\n+struct Foo<T>(PhantomData<T>);\n+struct Bar<U>(PhantomData<U>);\n \n pub fn main() {\n }\n \n fn test1() {\n-    let x: Foo<_> = Bar::<usize>;\n+    let x: Foo<_> = Bar::<usize>(PhantomData);\n     //~^ ERROR mismatched types\n     //~| expected `Foo<_>`\n     //~| found `Bar<usize>`\n@@ -28,7 +30,7 @@ fn test1() {\n }\n \n fn test2() {\n-    let x: Foo<_> = Bar::<usize>;\n+    let x: Foo<_> = Bar::<usize>(PhantomData);\n     //~^ ERROR mismatched types\n     //~| expected `Foo<_>`\n     //~| found `Bar<usize>`"}, {"sha": "74a6f869f63fb78850c834566b6d9f3c26bd6e83", "filename": "src/test/compile-fail/unboxed-closure-feature-gate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,8 +11,12 @@\n // Check that parenthetical notation is feature-gated except with the\n // `Fn` traits.\n \n+use std::marker;\n+\n trait Foo<A> {\n     type Output;\n+\n+    fn dummy(&self, a: A) { }\n }\n \n fn main() {"}, {"sha": "831db98941c6dc2ac9165eab6e987b3168dfdcd1", "filename": "src/test/compile-fail/unboxed-closure-sugar-default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -19,7 +19,7 @@ trait Foo<T,V=T> {\n     fn dummy(&self, t: T, v: V);\n }\n \n-trait Eq<X: ?Sized> { }\n+trait Eq<X: ?Sized> { fn same_types(&self, x: &X) -> bool { true } }\n impl<X: ?Sized> Eq<X> for X { }\n fn eq<A: ?Sized,B: ?Sized>() where A : Eq<B> { }\n "}, {"sha": "6d315c1b7a99617828fe1fe084202f00944fccef", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -16,12 +16,14 @@\n #![feature(unboxed_closures)]\n #![allow(dead_code)]\n \n+use std::marker::PhantomFn;\n+\n trait Foo<T> {\n     type Output;\n     fn dummy(&self, t: T, u: Self::Output);\n }\n \n-trait Eq<X: ?Sized> { }\n+trait Eq<X: ?Sized> : PhantomFn<(Self,X)> { }\n impl<X: ?Sized> Eq<X> for X { }\n fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n "}, {"sha": "bd3530e6e3026414b6df8b46c3c4361a47e2f15b", "filename": "src/test/compile-fail/unboxed-closure-sugar-lifetime-elision.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -16,12 +16,14 @@\n #![feature(unboxed_closures)]\n #![allow(dead_code)]\n \n+use std::marker;\n+\n trait Foo<T> {\n     type Output;\n     fn dummy(&self, t: T);\n }\n \n-trait Eq<X: ?Sized> { }\n+trait Eq<X: ?Sized> : marker::PhantomFn<(Self, X)> { }\n impl<X: ?Sized> Eq<X> for X { }\n fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n "}, {"sha": "057b496bd43ebead9d4f321fd67692275a10cdd7", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -22,7 +22,7 @@ trait Foo<'a,T> {\n     fn dummy(&'a self) -> &'a (T,Self::Output);\n }\n \n-trait Eq<X: ?Sized> { }\n+trait Eq<X: ?Sized> { fn is_of_eq_type(&self, x: &X) -> bool { true } }\n impl<X: ?Sized> Eq<X> for X { }\n fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n "}, {"sha": "713b64b1349fcc5893ac455a2755aa9449a203ef", "filename": "src/test/compile-fail/unboxed-closures-recursive-fn-using-fn-mut.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,20 +10,20 @@\n \n #![feature(core,unboxed_closures)]\n \n-use std::marker::CovariantType;\n+use std::marker::PhantomData;\n \n // A erroneous variant of `run-pass/unboxed_closures-infer-recursive-fn.rs`\n // where we attempt to perform mutation in the recursive function. This fails to compile\n // because it winds up requiring `FnMut` which enforces linearity.\n \n struct YCombinator<F,A,R> {\n     func: F,\n-    marker: CovariantType<(A,R)>,\n+    marker: PhantomData<(A,R)>,\n }\n \n impl<F,A,R> YCombinator<F,A,R> {\n     fn new(f: F) -> YCombinator<F,A,R> {\n-        YCombinator { func: f, marker: CovariantType }\n+        YCombinator { func: f, marker: PhantomData }\n     }\n }\n "}, {"sha": "964db6e9a4546bfb8b8ad18cfd80dc5af26110eb", "filename": "src/test/compile-fail/unnecessary-private.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,10 +13,10 @@ fn main() {\n     pub struct A; //~ ERROR: visibility has no effect\n     pub enum B {} //~ ERROR: visibility has no effect\n     pub trait C { //~ ERROR: visibility has no effect\n-        pub fn foo() {} //~ ERROR: visibility has no effect\n+        pub fn foo(&self) {} //~ ERROR: visibility has no effect\n     }\n     impl A {\n-        pub fn foo() {} //~ ERROR: visibility has no effect\n+        pub fn foo(&self) {} //~ ERROR: visibility has no effect\n     }\n \n     struct D {"}, {"sha": "a03c76b12dd8ea141dce5ddd1171b815590c3157", "filename": "src/test/compile-fail/unsized-inherent-impl-self-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,7 +12,7 @@\n \n // impl - struct\n \n-struct S5<Y>;\n+struct S5<Y>(Y);\n \n impl<X: ?Sized> S5<X> { //~ ERROR not implemented\n }"}, {"sha": "08df1d9b7b8fb8a384912f0258e7bcbdfadb2b53", "filename": "src/test/compile-fail/unsized-trait-impl-self-type.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,9 +12,10 @@\n \n // impl - struct\n trait T3<Z: ?Sized> {\n+    fn foo(&self, z: &Z);\n }\n \n-struct S5<Y>;\n+struct S5<Y>(Y);\n \n impl<X: ?Sized> T3<X> for S5<X> { //~ ERROR not implemented\n }"}, {"sha": "4723dfeaeb988393150e30af3cc515eef3806778", "filename": "src/test/compile-fail/unsized-trait-impl-trait-arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,8 +12,9 @@\n \n // impl - unbounded\n trait T2<Z> {\n+    fn foo(&self, z: Z);\n }\n-struct S4<Y: ?Sized>;\n+struct S4<Y: ?Sized>(Box<Y>);\n impl<X: ?Sized> T2<X> for S4<X> {\n     //~^ ERROR `core::marker::Sized` is not implemented for the type `X`\n }"}, {"sha": "de1cbab82b281e373002a1b2d4177a1ab1cd6791", "filename": "src/test/compile-fail/unsized3.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized3.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,6 +10,7 @@\n \n // Test sized-ness checking in substitution within fn bodies..\n \n+use std::marker;\n \n // Unbounded.\n fn f1<X: ?Sized>(x: &X) {\n@@ -20,7 +21,9 @@ fn f2<X>(x: &X) {\n }\n \n // Bounded.\n-trait T {}\n+trait T {\n+    fn foo(&self) { }\n+}\n fn f3<X: ?Sized + T>(x: &X) {\n     f4::<X>(x);\n     //~^ ERROR the trait `core::marker::Sized` is not implemented"}, {"sha": "f31a6ffdc0d7caed0084f23af4f661bd4df45f64", "filename": "src/test/compile-fail/unsized6.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized6.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,8 +10,9 @@\n \n // Test `?Sized` local variables.\n \n+use std::marker;\n \n-trait T {}\n+trait T : marker::MarkerTrait { }\n \n fn f1<X: ?Sized>(x: &X) {\n     let _: X; // <-- this is OK, no bindings created, no initializer."}, {"sha": "6ea3d0720eeeb716e3ae07325963865ce5d70b0e", "filename": "src/test/compile-fail/unsized7.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized7.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,13 +10,17 @@\n \n // Test sized-ness checking in substitution in impls.\n \n-trait T {}\n+use std::marker::MarkerTrait;\n+\n+trait T : MarkerTrait {}\n \n // I would like these to fail eventually.\n // impl - bounded\n trait T1<Z: T> {\n+    fn dummy(&self) -> Z;\n }\n-struct S3<Y: ?Sized>;\n+\n+struct S3<Y: ?Sized>(Box<Y>);\n impl<X: ?Sized + T> T1<X> for S3<X> {\n     //~^ ERROR `core::marker::Sized` is not implemented for the type `X`\n }"}, {"sha": "af242b96a84a160d464c01a5176a3c4e6c2f0393", "filename": "src/test/compile-fail/unused-attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-attr.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -52,9 +52,9 @@ struct Foo {\n #[foo] //~ ERROR unused attribute\n trait Baz {\n     #[foo] //~ ERROR unused attribute\n-    fn blah();\n+    fn blah(&self);\n     #[foo] //~ ERROR unused attribute\n-    fn blah2() {}\n+    fn blah2(&self) {}\n }\n \n fn main() {}"}, {"sha": "b1120e54434eb1861c96d8459b449e7d49ddf708", "filename": "src/test/compile-fail/useless-priv.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fuseless-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fuseless-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuseless-priv.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,12 +12,14 @@ struct A { pub i: isize }\n pub enum C { pub Variant }      //~ ERROR: unnecessary `pub`\n \n pub trait E {\n-    pub fn foo() {}             //~ ERROR: unnecessary visibility\n+    pub fn foo(&self) {}         //~ ERROR: unnecessary visibility\n+}\n+trait F {\n+    pub fn foo(&self) {}     //~ ERROR: unnecessary visibility\n }\n-trait F { pub fn foo() {} }     //~ ERROR: unnecessary visibility\n \n impl E for A {\n-    pub fn foo() {}             //~ ERROR: unnecessary visibility\n+    pub fn foo(&self) {}             //~ ERROR: unnecessary visibility\n }\n \n fn main() {}"}, {"sha": "a404d09248f0192a8ed54268f3c960df4636b8e4", "filename": "src/test/compile-fail/useless-priv2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fuseless-priv2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fuseless-priv2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuseless-priv2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -9,8 +9,10 @@\n // except according to those terms.\n \n pub trait E {\n-    pub fn foo();               //~ ERROR: unnecessary visibility\n+    pub fn foo(&self);               //~ ERROR: unnecessary visibility\n+}\n+trait F {\n+    pub fn foo(&self);               //~ ERROR: unnecessary visibility\n }\n-trait F { pub fn foo(); }       //~ ERROR: unnecessary visibility\n \n fn main() {}"}, {"sha": "3330e1d0d51b036273edf2e797bdc1cc3b924c40", "filename": "src/test/compile-fail/variance-contravariant-arg-object.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> : 'static {\n+    fn get(&self, t: T);\n+}\n+\n+fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n+                                -> Box<Get<&'min i32>>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n+                                   -> Box<Get<&'max i32>>\n+    where 'max : 'min\n+{\n+    v\n+}\n+\n+fn main() { }"}, {"sha": "caaad4014adfa73f301ce8ca16753e9658a61960", "filename": "src/test/compile-fail/variance-contravariant-arg-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> {\n+    fn get(&self, t: T);\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'max i32>\n+{\n+    impls_get::<G,&'min i32>() //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'min i32>\n+{\n+    impls_get::<G,&'max i32>()\n+}\n+\n+fn impls_get<G,T>() where G : Get<T> { }\n+\n+fn main() { }"}, {"sha": "013511ed517a87cd4f1f4d915e320c9316310c0e", "filename": "src/test/compile-fail/variance-contravariant-self-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get {\n+    fn get(&self);\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, G : 'max, &'max G : Get\n+{\n+    impls_get::<&'min G>(); //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, G : 'max, &'min G : Get\n+{\n+    impls_get::<&'max G>();\n+}\n+\n+fn impls_get<G>() where G : Get { }\n+\n+fn main() { }"}, {"sha": "828c987c0821226720bce8c24b0ae92df5ae2228", "filename": "src/test/compile-fail/variance-covariant-arg-object.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> : 'static {\n+    fn get(&self) -> T;\n+}\n+\n+fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n+                                -> Box<Get<&'min i32>>\n+    where 'max : 'min\n+{\n+    v\n+}\n+\n+fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n+                                   -> Box<Get<&'max i32>>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "17761b9c0b19e7bf13d8092e0074cd73fb7ca78c", "filename": "src/test/compile-fail/variance-covariant-arg-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> {\n+    fn get(&self) -> T;\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'max i32>\n+{\n+    impls_get::<G,&'min i32>()\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'min i32>\n+{\n+    impls_get::<G,&'max i32>() //~ ERROR mismatched types\n+}\n+\n+fn impls_get<G,T>() where G : Get<T> { }\n+\n+fn main() { }"}, {"sha": "4e94a3eeb46e6de5295ed4647182a3c3da9491a8", "filename": "src/test/compile-fail/variance-covariant-self-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get {\n+    fn get() -> Self;\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, G : 'max, &'max G : Get\n+{\n+    impls_get::<&'min G>();\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, G : 'max, &'min G : Get\n+{\n+    impls_get::<&'max G>(); //~ ERROR mismatched types\n+}\n+\n+fn impls_get<G>() where G : Get { }\n+\n+fn main() { }"}, {"sha": "8f9d24cb132c2e4f2a475a4a540338ac5079b2ad", "filename": "src/test/compile-fail/variance-deprecated-markers.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-deprecated-markers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-deprecated-markers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-deprecated-markers.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the deprecated markers still have their old effect.\n+\n+#![feature(rustc_attrs)]\n+\n+use std::marker;\n+\n+#[rustc_variance]\n+struct A<T>(marker::CovariantType<T>); //~ ERROR types=[[+];[];[]]\n+\n+#[rustc_variance]\n+struct B<T>(marker::ContravariantType<T>); //~ ERROR types=[[-];[];[]]\n+\n+#[rustc_variance]\n+struct C<T>(marker::InvariantType<T>); //~ ERROR types=[[o];[];[]]\n+\n+#[rustc_variance]\n+struct D<'a>(marker::CovariantLifetime<'a>); //~ ERROR regions=[[+];[];[]]\n+\n+#[rustc_variance]\n+struct E<'a>(marker::ContravariantLifetime<'a>); //~ ERROR regions=[[-];[];[]]\n+\n+#[rustc_variance]\n+struct F<'a>(marker::InvariantLifetime<'a>); //~ ERROR regions=[[o];[];[]]\n+\n+fn main() { }"}, {"sha": "9edb510b826a12df92df2fe2ea40966ca9ac98fa", "filename": "src/test/compile-fail/variance-invariant-arg-object.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> : 'static {\n+    fn get(&self, t: T) -> T;\n+}\n+\n+fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n+                                -> Box<Get<&'min i32>>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n+                                   -> Box<Get<&'max i32>>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "45fed0b083dc1d47cfd83ef49688e00d8568a680", "filename": "src/test/compile-fail/variance-invariant-arg-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-trait-match.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> {\n+    fn get(&self, t: T) -> T;\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'max i32>\n+{\n+    impls_get::<G,&'min i32>() //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'min i32>\n+{\n+    impls_get::<G,&'max i32>() //~ ERROR mismatched types\n+}\n+\n+fn impls_get<G,T>() where G : Get<T> { }\n+\n+fn main() { }"}, {"sha": "b46cd302ae5ea83ce1b6d2546295c358001aa148", "filename": "src/test/compile-fail/variance-invariant-self-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-self-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-self-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-self-trait-match.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get {\n+    fn get(&self) -> Self;\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, &'max G : Get\n+{\n+    impls_get::<&'min G>(); //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, &'min G : Get\n+{\n+    impls_get::<&'max G>(); //~ ERROR mismatched types\n+}\n+\n+fn impls_get<G>() where G : Get { }\n+\n+fn main() { }"}, {"sha": "0254f56bd1a944b86b1e8db2f55722105416c7d9", "filename": "src/test/compile-fail/variance-issue-20533.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-issue-20533.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-issue-20533.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-issue-20533.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #20533. At some point, only 1 out of the\n+// 3 errors below were being reported.\n+\n+use std::marker::PhantomData;\n+\n+fn foo<'a, T>(_x: &'a T) -> PhantomData<&'a ()> {\n+    PhantomData\n+}\n+\n+struct Wrap<T>(T);\n+\n+fn bar<'a, T>(_x: &'a T) -> Wrap<PhantomData<&'a ()>> {\n+    Wrap(PhantomData)\n+}\n+\n+struct Baked<'a>(PhantomData<&'a ()>);\n+\n+fn baz<'a, T>(_x: &'a T) -> Baked<'a> {\n+    Baked(PhantomData)\n+}\n+\n+struct AffineU32(u32);\n+\n+fn main() {\n+    {\n+        let a = AffineU32(1_u32);\n+        let x = foo(&a);\n+        drop(a); //~ ERROR cannot move out of `a`\n+        drop(x);\n+    }\n+    {\n+        let a = AffineU32(1_u32);\n+        let x = bar(&a);\n+        drop(a); //~ ERROR cannot move out of `a`\n+        drop(x);\n+    }\n+    {\n+        let a = AffineU32(1_u32);\n+        let x = baz(&a);\n+        drop(a); //~ ERROR cannot move out of `a`\n+        drop(x);\n+    }\n+}\n+"}, {"sha": "da4d6c75227fc609bba453dd222f52638b945fe2", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -60,6 +60,7 @@ struct Test6<'a, 'b> { //~ ERROR regions=[[-, o];[];[]]\n \n #[rustc_variance]\n struct Test7<'a> { //~ ERROR regions=[[*];[];[]]\n+    //~^ ERROR parameter `'a` is never used\n     x: isize\n }\n "}, {"sha": "9beb90d0b24835777550fc03adbda379e34faf9f", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -16,23 +16,27 @@\n \n #[rustc_variance]\n enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[]]\n+    //~^ ERROR parameter `'d` is never used\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[]]\n+    //~^ ERROR parameter `'w` is never used\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[];[]]\n+    //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[]]\n+    //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'b, 'a, 'c>\n }\n "}, {"sha": "396e77652067d5c10c91b4c910285f34fceefbb5", "filename": "src/test/compile-fail/variance-regions-unused-direct.rs", "status": "renamed", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-direct.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,21 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that a type whose lifetime parameters is never used is\n-// inferred to be bivariant.\n+// Test that disallow lifetime parameters that are unused.\n \n use std::marker;\n \n-struct Bivariant<'a>;\n+struct Bivariant<'a>; //~ ERROR parameter `'a` is never used\n \n-fn use1<'short,'long>(c: Bivariant<'short>,\n-                      _where:Option<&'short &'long ()>) {\n-    let _: Bivariant<'long> = c;\n+struct Struct<'a, 'd> { //~ ERROR parameter `'d` is never used\n+    field: &'a [i32]\n }\n \n-fn use2<'short,'long>(c: Bivariant<'long>,\n-                      _where:Option<&'short &'long ()>) {\n-    let _: Bivariant<'short> = c;\n+trait Trait<'a, 'd> { //~ ERROR parameter `'d` is never used\n+    fn method(&'a self);\n }\n \n-pub fn main() {}\n+fn main() {}", "previous_filename": "src/test/run-pass/regions-infer-bivariance.rs"}, {"sha": "2d234ed7b57812ef0b7dfa1a9ab5519bd0d7fe69", "filename": "src/test/compile-fail/variance-regions-unused-indirect.rs", "status": "renamed", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-indirect.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that disallow lifetime parameters that are unused.\n \n-enum list_cell<T> { cons(Box<list_cell<T>>), nil }\n+enum Foo<'a> { //~ ERROR parameter `'a` is never used\n+    Foo1(Bar<'a>)\n+}\n \n-pub fn main() { }\n+enum Bar<'a> { //~ ERROR parameter `'a` is never used\n+    Bar1(Foo<'a>)\n+}\n+\n+fn main() {}", "previous_filename": "src/test/run-pass/export-non-interference.rs"}, {"sha": "88b50058b6580d81bf5a8c98e2683bb1a9e0e5b2", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(bivariance)]\n+#![allow(dead_code)]\n+#![feature(rustc_attrs)]\n+\n+// Check that bounds on type parameters (other than `Self`) do not\n+// influence variance.\n+\n+#[rustc_variance]\n+trait Getter<T> { //~ ERROR types=[[+];[-];[]]\n+    fn get(&self) -> T;\n+}\n+\n+#[rustc_variance]\n+trait Setter<T> { //~ ERROR types=[[-];[-];[]]\n+    fn get(&self, T);\n+}\n+\n+#[rustc_variance]\n+struct TestStruct<U,T:Setter<U>> { //~ ERROR types=[[+, +];[];[]]\n+    t: T, u: U\n+}\n+\n+#[rustc_variance]\n+enum TestEnum<U,T:Setter<U>> {//~ ERROR types=[[*, +];[];[]]\n+    //~^ ERROR parameter `U` is never used\n+    Foo(T)\n+}\n+\n+#[rustc_variance]\n+trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[[-, +];[-];[]]\n+    fn getter(&self, u: U) -> T;\n+}\n+\n+#[rustc_variance]\n+trait TestTrait2<U> : Getter<U> { //~ ERROR types=[[+];[-];[]]\n+}\n+\n+#[rustc_variance]\n+trait TestTrait3<U> { //~ ERROR types=[[-];[-];[]]\n+    fn getter<T:Getter<U>>(&self);\n+}\n+\n+#[rustc_variance]\n+struct TestContraStruct<U,T:Setter<U>> { //~ ERROR types=[[*, +];[];[]]\n+    //~^ ERROR parameter `U` is never used\n+    t: T\n+}\n+\n+#[rustc_variance]\n+struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR types=[[*, +];[];[]]\n+    //~^ ERROR parameter `U` is never used\n+    t: T\n+}\n+\n+pub fn main() { }"}, {"sha": "f0ca1edd5638718c50ace55b5dfb97571f520f39", "filename": "src/test/compile-fail/variance-trait-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -18,7 +18,7 @@\n \n use std::mem;\n \n-trait T { fn foo(); }\n+trait T { fn foo(&self); }\n \n #[rustc_variance]\n struct TOption<'a> { //~ ERROR regions=[[-];[];[]]"}, {"sha": "d53e4cd76105b9f6b6c96388117971c497f6a730", "filename": "src/test/compile-fail/variance-types-bounds.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly infer variance for type parameters in\n+// various types and traits.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_variance]\n+struct TestImm<A, B> { //~ ERROR types=[[+, +];[];[]]\n+    x: A,\n+    y: B,\n+}\n+\n+#[rustc_variance]\n+struct TestMut<A, B:'static> { //~ ERROR types=[[+, o];[];[]]\n+    x: A,\n+    y: &'static mut B,\n+}\n+\n+#[rustc_variance]\n+struct TestIndirect<A:'static, B:'static> { //~ ERROR types=[[+, o];[];[]]\n+    m: TestMut<A, B>\n+}\n+\n+#[rustc_variance]\n+struct TestIndirect2<A:'static, B:'static> { //~ ERROR types=[[o, o];[];[]]\n+    n: TestMut<A, B>,\n+    m: TestMut<B, A>\n+}\n+\n+#[rustc_variance]\n+trait Getter<A> { //~ ERROR types=[[+];[-];[]]\n+    fn get(&self) -> A;\n+}\n+\n+#[rustc_variance]\n+trait Setter<A> { //~ ERROR types=[[-];[o];[]]\n+    fn set(&mut self, a: A);\n+}\n+\n+#[rustc_variance]\n+trait GetterSetter<A> { //~ ERROR types=[[o];[o];[]]\n+    fn get(&self) -> A;\n+    fn set(&mut self, a: A);\n+}\n+\n+#[rustc_variance]\n+trait GetterInTypeBound<A> { //~ ERROR types=[[-];[-];[]]\n+    // Here, the use of `A` in the method bound *does* affect\n+    // variance.  Think of it as if the method requested a dictionary\n+    // for `T:Getter<A>`.  Since this dictionary is an input, it is\n+    // contravariant, and the Getter is covariant w/r/t A, yielding an\n+    // overall contravariant result.\n+    fn do_it<T:Getter<A>>(&self);\n+}\n+\n+#[rustc_variance]\n+trait SetterInTypeBound<A> { //~ ERROR types=[[+];[-];[]]\n+    fn do_it<T:Setter<A>>(&self);\n+}\n+\n+#[rustc_variance]\n+struct TestObject<A, R> { //~ ERROR types=[[-, +];[];[]]\n+    n: Box<Setter<A>+Send>,\n+    m: Box<Getter<R>+Send>,\n+}\n+\n+fn main() {}"}, {"sha": "e407ebe345a5b2e5f3ac6e21989b52803c991832", "filename": "src/test/compile-fail/variance-types.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(bivariance)]\n+#![allow(dead_code)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+// Check that a type parameter which is only used in a trait bound is\n+// not considered bivariant.\n+\n+#[rustc_variance]\n+struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR types=[[o, o];[];[]], regions=[[-];[];[]]\n+    t: &'a mut (A,B)\n+}\n+\n+#[rustc_variance]\n+struct InvariantCell<A> { //~ ERROR types=[[o];[];[]]\n+    t: Cell<A>\n+}\n+\n+#[rustc_variance]\n+struct InvariantIndirect<A> { //~ ERROR types=[[o];[];[]]\n+    t: InvariantCell<A>\n+}\n+\n+#[rustc_variance]\n+struct Covariant<A> { //~ ERROR types=[[+];[];[]]\n+    t: A, u: fn() -> A\n+}\n+\n+#[rustc_variance]\n+struct Contravariant<A> { //~ ERROR types=[[-];[];[]]\n+    t: fn(A)\n+}\n+\n+#[rustc_variance]\n+enum Enum<A,B,C> { //~ ERROR types=[[+, -, o];[];[]]\n+    Foo(Covariant<A>),\n+    Bar(Contravariant<B>),\n+    Zed(Covariant<C>,Contravariant<C>)\n+}\n+\n+pub fn main() { }"}, {"sha": "5f504226370a45cff2b3fa55e3f81184a14935fb", "filename": "src/test/compile-fail/variance-unused-region-param.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-unused-region-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-unused-region-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-unused-region-param.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we report an error for unused type parameters in types.\n+\n+struct SomeStruct<'a> { x: u32 } //~ ERROR parameter `'a` is never used\n+enum SomeEnum<'a> { Nothing } //~ ERROR parameter `'a` is never used\n+trait SomeTrait<'a> { fn foo(&self); } //~ ERROR parameter `'a` is never used\n+\n+fn main() {}"}, {"sha": "2e867ec3c9384892a7aa5dbf6442eaadff55eb9d", "filename": "src/test/compile-fail/variance-unused-type-param.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// Test that we report an error for unused type parameters in types and traits,\n+// and that we offer a helpful suggestion.\n+\n+struct SomeStruct<A> { x: u32 }\n+//~^ ERROR parameter `A` is never used\n+//~| HELP PhantomData\n+\n+enum SomeEnum<A> { Nothing }\n+//~^ ERROR parameter `A` is never used\n+//~| HELP PhantomData\n+\n+trait SomeTrait<A> { fn foo(&self); }\n+//~^ ERROR parameter `A` is never used\n+//~| HELP PhantomFn\n+\n+// Here T might *appear* used, but in fact it isn't.\n+enum ListCell<T> {\n+//~^ ERROR parameter `T` is never used\n+//~| HELP PhantomData\n+    Cons(Box<ListCell<T>>),\n+    Nil\n+}\n+\n+fn main() {}"}, {"sha": "d2fd2978750e7c922b26f139ee8bd27bec982c9d", "filename": "src/test/compile-fail/variance-use-contravariant-struct-1.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-1.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various uses of structs with distint variances to make sure\n+// they permit lifetimes to be approximated as expected.\n+\n+#![feature(rustc_attrs)]\n+\n+struct SomeStruct<T>(fn(T));\n+\n+fn foo<'min,'max>(v: SomeStruct<&'max ()>)\n+                  -> SomeStruct<&'min ()>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "b38fd0e9ffcc6e8882093e95245648f58fe438b9", "filename": "src/test/compile-fail/variance-use-contravariant-struct-2.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various uses of structs with distint variances to make sure\n+// they permit lifetimes to be approximated as expected.\n+\n+#![allow(dead_code)]\n+#![feature(rustc_attrs)]\n+\n+struct SomeStruct<T>(fn(T));\n+\n+fn bar<'min,'max>(v: SomeStruct<&'min ()>)\n+                  -> SomeStruct<&'max ()>\n+    where 'max : 'min\n+{\n+    v\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "2631cfc05e81de646f2c245ae69834e688c3b166", "filename": "src/test/compile-fail/variance-use-covariant-struct-1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-1.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a covariant struct does not permit the lifetime of a\n+// reference to be enlarged.\n+\n+struct SomeStruct<T>(T);\n+\n+fn foo<'min,'max>(v: SomeStruct<&'min ()>)\n+                  -> SomeStruct<&'max ()>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "d8e1a5f5f1c54f127282d3c4e02aff0c41ce4c7c", "filename": "src/test/compile-fail/variance-use-covariant-struct-2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-2.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a covariant struct permits the lifetime of a reference to\n+// be shortened.\n+\n+#![allow(dead_code)]\n+#![feature(rustc_attrs)]\n+\n+struct SomeStruct<T>(T);\n+\n+fn foo<'min,'max>(v: SomeStruct<&'max ()>)\n+                  -> SomeStruct<&'min ()>\n+    where 'max : 'min\n+{\n+    v\n+}\n+\n+#[rustc_error] fn main() { } //~ ERROR compilation successful"}, {"sha": "c89436b20949c571a260c11e937ab7ebb74ef1d8", "filename": "src/test/compile-fail/variance-use-invariant-struct-1.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-use-invariant-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvariance-use-invariant-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-use-invariant-struct-1.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various uses of structs with distint variances to make sure\n+// they permit lifetimes to be approximated as expected.\n+\n+#![feature(rustc_attrs)]\n+\n+struct SomeStruct<T>(*mut T);\n+\n+fn foo<'min,'max>(v: SomeStruct<&'max ()>)\n+                  -> SomeStruct<&'min ()>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn bar<'min,'max>(v: SomeStruct<&'min ()>)\n+                  -> SomeStruct<&'max ()>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "1f2205b5c71983ee67a847d32b053c8365d15779", "filename": "src/test/compile-fail/visible-private-types-generics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvisible-private-types-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvisible-private-types-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvisible-private-types-generics.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {}\n+trait Foo {\n+    fn dummy(&self) { }\n+}\n \n pub fn f<\n     T"}, {"sha": "9d9eae4a0759bb7bdbcaa311e85e6e2614c2378f", "filename": "src/test/compile-fail/visible-private-types-supertrait.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvisible-private-types-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fvisible-private-types-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvisible-private-types-supertrait.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {}\n+trait Foo {\n+    fn dummy(&self) { }\n+}\n \n pub trait Bar : Foo {} //~ ERROR private trait in exported type\n "}, {"sha": "bf614e6eb512bab429c2c5530e833fdc1f464c35", "filename": "src/test/compile-fail/where-clause-method-substituion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fwhere-clause-method-substituion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fwhere-clause-method-substituion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clause-method-substituion.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo<T> {}\n+trait Foo<T> {\n+    fn dummy(&self, t: T) { }\n+}\n \n trait Bar<A> {\n     fn method<B>(&self) where A: Foo<B>;"}, {"sha": "7968cc37090acffe1d09cc411bdd1c2fe813c5af", "filename": "src/test/compile-fail/where-clauses-not-parameter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -21,7 +21,7 @@ fn test2() -> bool where Option<isize> : Eq {}\n \n #[derive(PartialEq)]\n //~^ ERROR cannot bound type `isize`, where clause bounds\n-enum Foo<T> where isize : Eq { MkFoo }\n+enum Foo<T> where isize : Eq { MkFoo(T) }\n //~^ ERROR cannot bound type `isize`, where clause bounds\n \n fn test3<T: Eq>() -> bool where Option<Foo<T>> : Eq {}\n@@ -31,7 +31,7 @@ fn test4() -> bool where Option<Foo<isize>> : Eq {}\n \n trait Baz<T> where isize : Eq {\n     //~^ ERROR cannot bound type `isize`, where clause bounds may only\n-    fn baz() where String : Eq; //~ ERROR cannot bound type `collections::string::String`\n+    fn baz(&self, t: T) where String : Eq; //~ ERROR cannot bound type `collections::string::String`\n     //~^ ERROR cannot bound type `isize`, where clause\n }\n "}, {"sha": "bf26fc23d3c16a1607af005ebe04e6cb26aad378", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -177,10 +177,11 @@\n #![omit_gdb_pretty_printer_section]\n \n use self::Enum1::{Variant1_1, Variant1_2};\n+use std::marker::PhantomData;\n use std::ptr;\n \n struct Struct1;\n-struct GenericStruct<T1, T2>;\n+struct GenericStruct<T1, T2>(PhantomData<(T1,T2)>);\n \n enum Enum1 {\n     Variant1_1,\n@@ -207,8 +208,8 @@ mod Mod1 {\n     }\n }\n \n-trait Trait1 { }\n-trait Trait2<T1, T2> { }\n+trait Trait1 { fn dummy(&self) { } }\n+trait Trait2<T1, T2> { fn dummy(&self, _: T1, _:T2) { } }\n \n impl Trait1 for isize {}\n impl<T1, T2> Trait2<T1, T2> for isize {}\n@@ -240,8 +241,10 @@ fn main() {\n \n     // Structs\n     let simple_struct = Struct1;\n-    let generic_struct1: GenericStruct<Mod1::Struct2, Mod1::Mod2::Struct3> = GenericStruct;\n-    let generic_struct2: GenericStruct<Struct1, extern \"fastcall\" fn(isize) -> usize> = GenericStruct;\n+    let generic_struct1: GenericStruct<Mod1::Struct2, Mod1::Mod2::Struct3> =\n+        GenericStruct(PhantomData);\n+    let generic_struct2: GenericStruct<Struct1, extern \"fastcall\" fn(isize) -> usize> =\n+        GenericStruct(PhantomData);\n     let mod_struct = Mod1::Struct2;\n \n     // Enums\n@@ -262,10 +265,10 @@ fn main() {\n \n     // References\n     let ref1 = (&Struct1, 0i32);\n-    let ref2 = (&GenericStruct::<char, Struct1>, 0i32);\n+    let ref2 = (&GenericStruct::<char, Struct1>(PhantomData), 0i32);\n \n     let mut mut_struct1 = Struct1;\n-    let mut mut_generic_struct = GenericStruct::<Mod1::Enum2, f64>;\n+    let mut mut_generic_struct = GenericStruct::<Mod1::Enum2, f64>(PhantomData);\n     let mut_ref1 = (&mut mut_struct1, 0i32);\n     let mut_ref2 = (&mut mut_generic_struct, 0i32);\n "}, {"sha": "f5205de5c1fcd3ee32661b60d821915bbd10efb7", "filename": "src/test/pretty/empty-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fpretty%2Fempty-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fpretty%2Fempty-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fempty-impl.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait X { }\n+trait X { fn dummy(&self) { } }\n impl X for uint { }\n \n-trait Y { }\n+trait Y { fn dummy(&self) { } }\n impl Y for uint { }"}, {"sha": "9e1f2aa8bfe01e7729e5e71c30f76908082b918b", "filename": "src/test/pretty/path-type-bounds.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,9 @@\n // pp-exact\n \n \n-trait Tr { }\n+trait Tr {\n+    fn dummy(&self) { }\n+}\n impl Tr for int { }\n \n fn foo<'a>(x: Box<Tr+ Sync + 'a>) -> Box<Tr+ Sync + 'a> { x }"}, {"sha": "4ad81197286bb992734e8d8f24ae04fa74ad50c7", "filename": "src/test/run-fail/bug-811.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -9,6 +9,9 @@\n // except according to those terms.\n \n // error-pattern:quux\n+\n+use std::marker::PhantomData;\n+\n fn test00_start(ch: chan_t<int>, message: int) { send(ch, message); }\n \n type task_id = int;\n@@ -17,6 +20,7 @@ type port_id = int;\n struct chan_t<T> {\n     task: task_id,\n     port: port_id,\n+    marker: PhantomData<*mut T>,\n }\n \n fn send<T:Send>(_ch: chan_t<T>, _data: T) { panic!(); }"}, {"sha": "3bd56c14193a8524d7e4dc25cf2e474779e5181f", "filename": "src/test/run-make/rustdoc-json/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -21,5 +21,5 @@ pub mod bar {\n     }\n \n     /// *wow*\n-    pub trait Doge { }\n+    pub trait Doge { fn dummy(&self) { } }\n }"}, {"sha": "6c56bcc9be67bc0a4817cd307e092facc44b48cd", "filename": "src/test/run-make/rustdoc-negative-impl/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-negative-impl%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-negative-impl%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-negative-impl%2Ffoo.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,7 +13,7 @@\n // @matches foo/struct.Alpha.html '//pre' \"pub struct Alpha\"\n pub struct Alpha;\n // @matches foo/struct.Bravo.html '//pre' \"pub struct Bravo<B>\"\n-pub struct Bravo<B>;\n+pub struct Bravo<B>(B);\n \n // @matches foo/struct.Alpha.html '//*[@class=\"impl\"]//code' \"impl !Send for Alpha\"\n impl !Send for Alpha {}"}, {"sha": "42469a21f22d0abbf25f3bfc31e5c76e396efde7", "filename": "src/test/run-make/rustdoc-search-index/index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-search-index%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-search-index%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-search-index%2Findex.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -21,6 +21,6 @@ mod private {\n     }\n \n     pub trait PrivateTrait {\n-        fn trait_method() {} // @!has - priv_method\n+        fn trait_method(&self) {} // @!has - priv_method\n     }\n }"}, {"sha": "f6b73021bebdfb0ffc70941642062208c65a8a9b", "filename": "src/test/run-make/rustdoc-smoke/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -26,7 +26,7 @@ pub mod bar {\n \n     /// *wow*\n     // @has foo/bar/trait.Doge.html\n-    pub trait Doge { }\n+    pub trait Doge { fn dummy(&self) { } }\n \n     // @has foo/bar/struct.Foo.html\n     pub struct Foo { x: int, y: uint }"}, {"sha": "6fd47d84c30fee93646688ba1bc1732003c46213", "filename": "src/test/run-make/rustdoc-viewpath-self/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-viewpath-self%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-viewpath-self%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-viewpath-self%2Ffoo.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub mod io {\n-    pub trait Reader { }\n+    pub trait Reader { fn dummy(&self) { } }\n }\n \n pub enum Maybe<A> {"}, {"sha": "91a7e1c9fd4aeb4554cdef802909b12cb4df35bb", "filename": "src/test/run-make/rustdoc-where/foo.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-where%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Frustdoc-where%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-where%2Ffoo.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,30 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait MyTrait {}\n+pub trait MyTrait { fn dummy(&self) { } }\n \n // @has foo/struct.Alpha.html '//pre' \"pub struct Alpha<A> where A: MyTrait\"\n-pub struct Alpha<A> where A: MyTrait;\n+pub struct Alpha<A>(A) where A: MyTrait;\n // @has foo/trait.Bravo.html '//pre' \"pub trait Bravo<B> where B: MyTrait\"\n-pub trait Bravo<B> where B: MyTrait {}\n+pub trait Bravo<B> where B: MyTrait { fn get(&self, B: B); }\n // @has foo/fn.charlie.html '//pre' \"pub fn charlie<C>() where C: MyTrait\"\n pub fn charlie<C>() where C: MyTrait {}\n \n-pub struct Delta<D>;\n+pub struct Delta<D>(D);\n+\n // @has foo/struct.Delta.html '//*[@class=\"impl\"]//code' \\\n //          \"impl<D> Delta<D> where D: MyTrait\"\n impl<D> Delta<D> where D: MyTrait {\n     pub fn delta() {}\n }\n \n-pub struct Echo<E>;\n+pub struct Echo<E>(E);\n+\n // @has foo/struct.Echo.html '//*[@class=\"impl\"]//code' \\\n //          \"impl<E> MyTrait for Echo<E> where E: MyTrait\"\n // @has foo/trait.MyTrait.html '//*[@id=\"implementors-list\"]//code' \\\n //          \"impl<E> MyTrait for Echo<E> where E: MyTrait\"\n impl<E> MyTrait for Echo<E> where E: MyTrait {}\n \n-pub enum Foxtrot<F> {}\n+pub enum Foxtrot<F> { Foxtrot1(F) }\n+\n // @has foo/enum.Foxtrot.html '//*[@class=\"impl\"]//code' \\\n //          \"impl<F> MyTrait for Foxtrot<F> where F: MyTrait\"\n // @has foo/trait.MyTrait.html '//*[@id=\"implementors-list\"]//code' \\"}, {"sha": "b6366ad67375a6b9bbecbaa8dc927a2646915ca1", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -99,6 +99,7 @@ struct some_fields {\n type SF = some_fields;\n \n trait SuperTrait {\n+    fn dummy(&self) { }\n }\n \n trait SomeTrait: SuperTrait {"}, {"sha": "f418d5d1fb74f1435110ea0378df3f9e48ffa8ca", "filename": "src/test/run-make/simd-ffi/simd.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -70,10 +70,14 @@ pub fn bar(a: i32x4, b: i32x4) -> i32x4 {\n }\n \n #[lang = \"sized\"]\n-trait Sized {}\n+pub trait Sized : PhantomFn<Self> {}\n \n #[lang = \"copy\"]\n-trait Copy {}\n+pub trait Copy : PhantomFn<Self> {}\n+\n+#[lang=\"phantom_fn\"]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n+impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n \n mod core {\n     pub mod marker {"}, {"sha": "e1f36ecda53e83c5daaf73456b44b6c886688baa", "filename": "src/test/run-make/symbols-are-reasonable/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2Flib.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,7 @@\n pub static X: &'static str = \"foobarbaz\";\n pub static Y: &'static [u8] = include_bytes!(\"lib.rs\");\n \n-trait Foo {}\n+trait Foo { fn dummy(&self) { } }\n impl Foo for uint {}\n \n pub fn dummy() {"}, {"sha": "acda8705b19e30e22ad6b2cb662f9e74bb59d34c", "filename": "src/test/run-make/target-specs/foo.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,11 +11,15 @@\n #![feature(lang_items, no_std)]\n #![no_std]\n \n+#[lang=\"phantom_fn\"]\n+trait PhantomFn<A:?Sized,R:?Sized=()> { }\n+impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n+\n #[lang=\"copy\"]\n-trait Copy { }\n+trait Copy : PhantomFn<Self> { }\n \n #[lang=\"sized\"]\n-trait Sized { }\n+trait Sized : PhantomFn<Self>  { }\n \n #[lang=\"start\"]\n fn start(_main: *const u8, _argc: int, _argv: *const *const u8) -> int { 0 }"}, {"sha": "aecec44f6fd3df0e4cd6cbdec45dbbd5dcff17b9", "filename": "src/test/run-pass-valgrind/cleanup-auto-borrow-obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-auto-borrow-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-auto-borrow-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-auto-borrow-obj.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -25,7 +25,7 @@ impl Drop for Foo {\n }\n \n \n-trait Trait {}\n+trait Trait { fn dummy(&self) { } }\n impl Trait for Foo {}\n \n pub fn main() {"}, {"sha": "c49a684de945df046b3015e2cd5b0a35488b865e", "filename": "src/test/run-pass-valgrind/dst-dtor-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -19,7 +19,7 @@ impl Drop for Foo {\n     }\n }\n \n-trait Trait {}\n+trait Trait { fn dummy(&self) { } }\n impl Trait for Foo {}\n \n struct Fat<T: ?Sized> {"}, {"sha": "f5521f7da853bd025b017cac1cf7a3a4d8c463fd", "filename": "src/test/run-pass/associated-types-basic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {\n+use std::marker::MarkerTrait;\n+\n+trait Foo : MarkerTrait {\n     type T;\n }\n "}, {"sha": "aa65b0ed10bafe93e5521d26a074cbf801a9f25d", "filename": "src/test/run-pass/associated-types-conditional-dispatch.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,6 +14,7 @@\n // `Target=[A]`, then the impl marked with `(*)` is seen to conflict\n // with all the others.\n \n+use std::marker::PhantomData;\n use std::ops::Deref;\n \n pub trait MyEq<U: ?Sized=Self> {\n@@ -41,7 +42,8 @@ impl<'a, A, B, Lhs> MyEq<[B; 0]> for Lhs\n }\n \n struct DerefWithHelper<H, T> {\n-    pub helper: H\n+    pub helper: H,\n+    pub marker: PhantomData<T>,\n }\n \n trait Helper<T> {\n@@ -63,7 +65,8 @@ impl<T, H: Helper<T>> Deref for DerefWithHelper<H, T> {\n }\n \n pub fn check<T: MyEq>(x: T, y: T) -> bool {\n-    let d: DerefWithHelper<Option<T>, T> = DerefWithHelper { helper: Some(x) };\n+    let d: DerefWithHelper<Option<T>, T> = DerefWithHelper { helper: Some(x),\n+                                                             marker: PhantomData };\n     d.eq(&y)\n }\n "}, {"sha": "40ef7f3531cb5caf17247568f52fbc1ccd8a1de0", "filename": "src/test/run-pass/associated-types-issue-20371.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20371.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,6 +11,8 @@\n // Test that we are able to have an impl that defines an associated type\n // before the actual trait.\n \n+use std::marker::MarkerTrait;\n+\n impl X for f64 { type Y = int; }\n-trait X {type Y; }\n+trait X : MarkerTrait { type Y; }\n fn main() {}"}, {"sha": "3c91577362a7d4a27657ff5ebb20a72fa4990478", "filename": "src/test/run-pass/associated-types-issue-21212.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-issue-21212.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-issue-21212.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-issue-21212.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -20,7 +20,8 @@ pub trait Parser {\n         panic!()\n     }\n }\n-impl <P> Parser for P  {\n+\n+impl <P> Parser for P {\n     type Input = ();\n }\n "}, {"sha": "2ee8ef0d3ddac5a51267efcc4226697cf639bb28", "filename": "src/test/run-pass/associated-types-nested-projections.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-nested-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-nested-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-nested-projections.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,11 +10,12 @@\n \n // Test that we can resolve nested projection types. Issue #20666.\n \n+use std::marker::MarkerTrait;\n use std::slice;\n \n-trait Bound {}\n+trait Bound : MarkerTrait {}\n \n-impl<'a> Bound for &'a int {}\n+impl<'a> Bound for &'a i32 {}\n \n trait IntoIterator {\n     type Iter: Iterator;"}, {"sha": "de96af83f59171e040223af451d43f71d59b8f0d", "filename": "src/test/run-pass/associated-types-normalize-in-bounds-binding.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,7 +13,9 @@\n \n #![allow(dead_code)]\n \n-pub trait Integral {\n+use std::marker::MarkerTrait;\n+\n+pub trait Integral : MarkerTrait {\n     type Opposite;\n }\n \n@@ -27,6 +29,8 @@ impl Integral for u32 {\n \n pub trait FnLike<A> {\n     type R;\n+\n+    fn dummy(&self, a: A) -> Self::R { loop { } }\n }\n \n fn foo<T>()"}, {"sha": "8617750ca538ea02472b33bd0e77781960fba9df", "filename": "src/test/run-pass/associated-types-normalize-in-bounds-ufcs.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-ufcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-ufcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-ufcs.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,15 +11,17 @@\n // Test that we normalize associated types that appear in bounds; if\n // we didn't, the call to `self.split2()` fails to type check.\n \n-struct Splits<'a, T, P>;\n-struct SplitsN<I>;\n+use std::marker::PhantomData;\n+\n+struct Splits<'a, T:'a, P>(PhantomData<(&'a T, P)>);\n+struct SplitsN<I>(PhantomData<I>);\n \n trait SliceExt2 {\n     type Item;\n \n     fn split2<'a, P>(&'a self, pred: P) -> Splits<'a, Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n-    fn splitn2<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, Self::Item, P>>\n+    fn splitn2<'a, P>(&'a self, n: u32, pred: P) -> SplitsN<Splits<'a, Self::Item, P>>\n         where P: FnMut(&Self::Item) -> bool;\n }\n \n@@ -30,7 +32,7 @@ impl<T> SliceExt2 for [T] {\n         loop {}\n     }\n \n-    fn splitn2<P>(&self, n: uint, pred: P) -> SplitsN<Splits<T, P>> where P: FnMut(&T) -> bool {\n+    fn splitn2<P>(&self, n: u32, pred: P) -> SplitsN<Splits<T, P>> where P: FnMut(&T) -> bool {\n         SliceExt2::split2(self, pred);\n         loop {}\n     }"}, {"sha": "94cfcb83653812347657560b6d6654cf16b65116", "filename": "src/test/run-pass/associated-types-normalize-in-bounds.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,15 +11,17 @@\n // Test that we normalize associated types that appear in bounds; if\n // we didn't, the call to `self.split2()` fails to type check.\n \n-struct Splits<'a, T, P>;\n-struct SplitsN<I>;\n+use std::marker::PhantomData;\n+\n+struct Splits<'a, T, P>(PhantomData<(&'a(),T,P)>);\n+struct SplitsN<I>(PhantomData<I>);\n \n trait SliceExt2 {\n     type Item;\n \n     fn split2<'a, P>(&'a self, pred: P) -> Splits<'a, Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n-    fn splitn2<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, Self::Item, P>>\n+    fn splitn2<'a, P>(&'a self, n: usize, pred: P) -> SplitsN<Splits<'a, Self::Item, P>>\n         where P: FnMut(&Self::Item) -> bool;\n }\n \n@@ -30,7 +32,7 @@ impl<T> SliceExt2 for [T] {\n         loop {}\n     }\n \n-    fn splitn2<P>(&self, n: uint, pred: P) -> SplitsN<Splits<T, P>> where P: FnMut(&T) -> bool {\n+    fn splitn2<P>(&self, n: usize, pred: P) -> SplitsN<Splits<T, P>> where P: FnMut(&T) -> bool {\n         self.split2(pred);\n         loop {}\n     }"}, {"sha": "2288e19aae0bceaaa59131547736cc9cc3653fc9", "filename": "src/test/run-pass/associated-types-normalize-unifield-struct.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,7 +13,10 @@\n \n \n pub trait OffsetState: Sized {}\n-pub trait Offset { type State: OffsetState; }\n+pub trait Offset {\n+    type State: OffsetState;\n+    fn dummy(&self) { }\n+}\n \n #[derive(Copy)] pub struct X;\n impl Offset for X { type State = Y; }"}, {"sha": "c65d2db9b0cf0f3125849028aae506a4680827af", "filename": "src/test/run-pass/associated-types-projection-from-known-type-in-impl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-projection-from-known-type-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-projection-from-known-type-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-projection-from-known-type-in-impl.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,6 +13,8 @@\n trait Int\n {\n     type T;\n+\n+    fn dummy(&self) { }\n }\n \n trait NonZero"}, {"sha": "a9c34a605ce163a5f2cfb842929ad6a3a7ce249d", "filename": "src/test/run-pass/associated-types-projection-in-object-type.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-object-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-object-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-object-type.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -18,6 +18,8 @@ use std::cell::RefCell;\n \n pub trait Subscriber {\n     type Input;\n+\n+    fn dummy(&self) { }\n }\n \n pub trait Publisher<'a> {"}, {"sha": "4d2358fae27b183f3440d83020b21563e4ee9139", "filename": "src/test/run-pass/associated-types-projection-in-supertrait.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-supertrait.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,6 +14,8 @@\n trait A\n {\n     type TA;\n+\n+    fn dummy(&self) { }\n }\n \n trait B<TB>"}, {"sha": "3f3f4fbd1d628f46489096157ad484eb17cc8642", "filename": "src/test/run-pass/associated-types-projection-in-where-clause.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-where-clause.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,6 +13,8 @@\n trait Int\n {\n     type T;\n+\n+    fn dummy(&self) { }\n }\n \n trait NonZero"}, {"sha": "67fe11d8feddec9cb3bd23833826746d2ce2b96b", "filename": "src/test/run-pass/associated-types-ref-in-struct-literal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-ref-in-struct-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-ref-in-struct-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-ref-in-struct-literal.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,6 +12,8 @@\n \n pub trait Foo {\n     type Bar;\n+\n+    fn dummy(&self) { }\n }\n \n impl Foo for int {"}, {"sha": "a4b0b1a6e03af4281e88164f7b91e238250438e3", "filename": "src/test/run-pass/associated-types-resolve-lifetime.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-resolve-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-resolve-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-resolve-lifetime.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,6 +15,8 @@ trait Get<T> {\n trait Trait<'a> {\n     type T: 'static;\n     type U: Get<&'a int>;\n+\n+    fn dummy(&'a self) { }\n }\n \n fn main() {}"}, {"sha": "8667f6c8430aba03c706a9ae8d61bf273e920a5e", "filename": "src/test/run-pass/associated-types-struct-field-named.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-struct-field-named.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-struct-field-named.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-struct-field-named.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,6 +13,8 @@\n \n pub trait UnifyKey {\n     type Value;\n+\n+    fn dummy(&self) { }\n }\n \n pub struct Node<K:UnifyKey> {"}, {"sha": "9503f78a71b908ed469cfc109a4a11f89f9151b6", "filename": "src/test/run-pass/associated-types-struct-field-numbered.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-struct-field-numbered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-struct-field-numbered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-struct-field-numbered.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,6 +13,8 @@\n \n pub trait UnifyKey {\n     type Value;\n+\n+    fn dummy(&self) { }\n }\n \n pub struct Node<K:UnifyKey>(K, K::Value);"}, {"sha": "c068065ac6ae7e2167636a4ae336398c1bec9b8a", "filename": "src/test/run-pass/associated-types-sugar-path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -31,8 +31,9 @@ pub fn bar<T: Foo>(a: T, x: T::A) -> T::A {\n // Using a type via an impl.\n trait C {\n     fn f();\n+    fn g(&self) { }\n }\n-struct B<X>;\n+struct B<X>(X);\n impl<T: Foo> C for B<T> {\n     fn f() {\n         let x: T::A = panic!();"}, {"sha": "be0c88f557cc7e87bd01c3cc4efbbc9b1e4262d1", "filename": "src/test/run-pass/borrowck-trait-lifetime.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fborrowck-trait-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fborrowck-trait-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-trait-lifetime.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,8 +12,11 @@\n // to the same lifetime on a trait succeeds. See issue #10766.\n \n #![allow(dead_code)]\n+\n+use std::marker;\n+\n fn main() {\n-    trait T {}\n+    trait T : marker::MarkerTrait {}\n \n     fn f<'a, V: T>(v: &'a V) -> &'a T {\n         v as &'a T"}, {"sha": "143ebfdabfacefd6ce8cd1fdc05c430860e7f5a2", "filename": "src/test/run-pass/bug-7295.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fbug-7295.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fbug-7295.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbug-7295.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n pub trait Foo<T> {\n-    fn func1<U>(&self, t: U);\n+    fn func1<U>(&self, t: U, w: T);\n \n-    fn func2<U>(&self, t: U) {\n-        self.func1(t);\n+    fn func2<U>(&self, t: U, w: T) {\n+        self.func1(t, w);\n     }\n }\n "}, {"sha": "7eaed910124d91ea2b31a1134f9ceb481e1d1994", "filename": "src/test/run-pass/builtin-superkinds-in-metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -16,6 +16,7 @@\n extern crate trait_superkinds_in_metadata;\n use trait_superkinds_in_metadata::{RequiresRequiresShareAndSend, RequiresShare};\n use trait_superkinds_in_metadata::{RequiresCopy};\n+use std::marker;\n \n #[derive(Copy)]\n struct X<T>(T);"}, {"sha": "964c28dc94517a1d5da90bee404dcf02b0e4e236", "filename": "src/test/run-pass/builtin-superkinds-phantom-typaram.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-phantom-typaram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-phantom-typaram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-phantom-typaram.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,10 +12,12 @@\n // super-builtin-kind of a trait, if the type parameter is never used,\n // the type can implement the trait anyway.\n \n+use std::marker;\n+\n trait Foo : Send { }\n \n-struct X<T>(());\n+struct X<T> { marker: marker::PhantomData<T> }\n \n-impl <T> Foo for X<T> { }\n+impl<T:Send> Foo for X<T> { }\n \n pub fn main() { }"}, {"sha": "b56a749d33bb85d9fef9501a9f777ce55b7e81da", "filename": "src/test/run-pass/class-typarams.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fclass-typarams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fclass-typarams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-typarams.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::marker::PhantomData;\n+\n struct cat<U> {\n     meows : uint,\n-\n     how_hungry : int,\n+    m: PhantomData<U>\n }\n \n impl<U> cat<U> {\n@@ -22,7 +24,8 @@ impl<U> cat<U> {\n fn cat<U>(in_x : uint, in_y : int) -> cat<U> {\n     cat {\n         meows: in_x,\n-        how_hungry: in_y\n+        how_hungry: in_y,\n+        m: PhantomData\n     }\n }\n "}, {"sha": "30ed0b8e4024581b9f2c360208b4fb581bcd9cd2", "filename": "src/test/run-pass/dst-coercions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fdst-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fdst-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-coercions.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -11,7 +11,7 @@\n // Test coercions involving DST and/or raw pointers\n \n struct S;\n-trait T {}\n+trait T { fn dummy(&self) { } }\n impl T for S {}\n \n pub fn main() {"}, {"sha": "023376ce4736ee6833e205314e4017e885cd023e", "filename": "src/test/run-pass/enum-null-pointer-opt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -16,7 +16,7 @@ use std::mem::size_of;\n use std::rc::Rc;\n use std::sync::Arc;\n \n-trait Trait {}\n+trait Trait { fn dummy(&self) { } }\n \n fn main() {\n     // Functions"}, {"sha": "382c5c58e92ee70adfde48df8f9c2c248706f94b", "filename": "src/test/run-pass/explicit-self-generic.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -15,21 +15,19 @@\n struct LM { resize_at: uint, size: uint }\n \n enum HashMap<K,V> {\n-    HashMap_(LM)\n+    HashMap_(LM, Vec<(K,V)>)\n }\n \n-impl<K,V> Copy for HashMap<K,V> {}\n-\n fn linear_map<K,V>() -> HashMap<K,V> {\n     HashMap::HashMap_(LM{\n         resize_at: 32,\n-        size: 0})\n+        size: 0}, Vec::new())\n }\n \n impl<K,V> HashMap<K,V> {\n     pub fn len(&mut self) -> uint {\n         match *self {\n-            HashMap::HashMap_(l) => l.size\n+            HashMap::HashMap_(ref l, _) => l.size\n         }\n     }\n }"}, {"sha": "bf02b82d1a0754d5fbc8678965a4652417296aea", "filename": "src/test/run-pass/generic-default-type-params-cross-crate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params-cross-crate.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,13 +12,13 @@\n \n extern crate default_type_params_xc;\n \n-struct Vec<T, A = default_type_params_xc::Heap>;\n+struct Vec<T, A = default_type_params_xc::Heap>(Option<(T,A)>);\n \n struct Foo;\n \n fn main() {\n-    let _a = Vec::<int>;\n-    let _b = Vec::<int, default_type_params_xc::FakeHeap>;\n-    let _c = default_type_params_xc::FakeVec::<int>;\n-    let _d = default_type_params_xc::FakeVec::<int, Foo>;\n+    let _a = Vec::<int>(None);\n+    let _b = Vec::<int, default_type_params_xc::FakeHeap>(None);\n+    let _c = default_type_params_xc::FakeVec::<int> { f: None };\n+    let _d = default_type_params_xc::FakeVec::<int, Foo> { f: None };\n }"}, {"sha": "7b16bb867e79c30004a1ac777e9a0c8fc2efe591", "filename": "src/test/run-pass/hrtb-opt-in-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -18,15 +18,15 @@\n \n #![allow(dead_code)]\n \n-use std::marker;\n+use std::marker::PhantomData;\n \n #[derive(Copy)]\n struct Foo<T> { x: T }\n \n type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n enum TyS<'tcx> {\n-    Boop(marker::InvariantLifetime<'tcx>)\n+    Boop(PhantomData<*mut &'tcx ()>)\n }\n \n #[derive(Copy)]"}, {"sha": "e4026a8fd0118a7fd5ea44920cabf0072ddb4548", "filename": "src/test/run-pass/inner-static.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Finner-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Finner-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finner-static.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -13,9 +13,9 @@\n extern crate inner_static;\n \n pub fn main() {\n-    let a = inner_static::A::<()>;\n-    let b = inner_static::B::<()>;\n-    let c = inner_static::test::A::<()>;\n+    let a = inner_static::A::<()> { v: () };\n+    let b = inner_static::B::<()> { v: () };\n+    let c = inner_static::test::A::<()> { v: () };\n     assert_eq!(a.bar(), 2);\n     assert_eq!(b.bar(), 4);\n     assert_eq!(c.bar(), 6);"}, {"sha": "da73c4b27ac4420e8b2145fc0b0a49c0e0f108c4", "filename": "src/test/run-pass/issue-10456.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-10456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-10456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10456.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,7 +14,9 @@ pub trait Bar {\n     fn bar(&self);\n }\n \n-pub trait Baz {}\n+pub trait Baz {\n+    fn baz(&self) { }\n+}\n \n impl<T: Baz> Bar for T {\n     fn bar(&self) {}"}, {"sha": "174a69e1135cdf7a766ada2f71a70984dd537e7d", "filename": "src/test/run-pass/issue-10802.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-10802.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-10802.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10802.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -29,7 +29,7 @@ impl Drop for DroppableEnum {\n     }\n }\n \n-trait MyTrait { }\n+trait MyTrait { fn dummy(&self) { } }\n impl MyTrait for Box<DroppableStruct> {}\n impl MyTrait for Box<DroppableEnum> {}\n "}, {"sha": "7fab6662ee01c3d3ee02d3bca9b5e9cf55228654", "filename": "src/test/run-pass/issue-10902.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-10902.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-10902.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10902.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n pub mod two_tuple {\n-    pub trait T {}\n+    pub trait T { fn dummy(&self) { } }\n     pub struct P<'a>(&'a (T + 'a), &'a (T + 'a));\n     pub fn f<'a>(car: &'a T, cdr: &'a T) -> P<'a> {\n         P(car, cdr)\n     }\n }\n \n pub mod two_fields {\n-    pub trait T {}\n+    pub trait T { fn dummy(&self) { } }\n     pub struct P<'a> { car: &'a (T + 'a), cdr: &'a (T + 'a) }\n     pub fn f<'a>(car: &'a T, cdr: &'a T) -> P<'a> {\n         P{ car: car, cdr: cdr }"}, {"sha": "1325b51a54ff2b6a4380f38bb7d64f8d9420846f", "filename": "src/test/run-pass/issue-11205.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11205.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,7 +12,7 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-trait Foo {}\n+trait Foo { fn dummy(&self) { } }\n impl Foo for int {}\n fn foo(_: [&Foo; 2]) {}\n fn foos(_: &[&Foo]) {}"}, {"sha": "26634fabf5a1542f51726873c768f0689c67057b", "filename": "src/test/run-pass/issue-11384.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-11384.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-11384.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11384.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Common {}\n+trait Common { fn dummy(&self) { } }\n \n impl<'t, T> Common for (T, &'t T) {}\n "}, {"sha": "3c69377b375c6597cd865aa23f5af8cdb3ef1125", "filename": "src/test/run-pass/issue-11612.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-11612.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-11612.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11612.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -12,7 +12,7 @@\n // We weren't updating the auto adjustments with all the resolved\n // type information after type check.\n \n-trait A {}\n+trait A { fn dummy(&self) { } }\n \n struct B<'a, T:'a> {\n     f: &'a T"}, {"sha": "7cccac4483d49da1edfed2dd0c397493dc45c16d", "filename": "src/test/run-pass/issue-11677.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-11677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-11677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11677.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -14,13 +14,18 @@\n \n // this code used to cause an ICE\n \n-trait X<T> {}\n+use std::marker;\n+\n+trait X<T> {\n+    fn dummy(&self) -> T { panic!() }\n+}\n \n struct S<T> {f: Box<X<T>+'static>,\n              g: Box<X<T>+'static>}\n \n struct F;\n-impl X<int> for F {}\n+impl X<int> for F {\n+}\n \n fn main() {\n   S {f: box F, g: box F};"}, {"sha": "64807dc44e061002632daecc7ade4bcb8a94eb7c", "filename": "src/test/run-pass/issue-13105.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-13105.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-13105.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13105.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {\n+use std::marker::MarkerTrait;\n+\n+trait Foo : MarkerTrait {\n     fn quux(u8) {}\n }\n "}, {"sha": "4f3db1352bbd234d66b6ab0380cc91fe50aaf991", "filename": "src/test/run-pass/issue-14399.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-14399.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-14399.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14399.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -19,7 +19,7 @@\n #[derive(Clone)]\n struct B1;\n \n-trait A {}\n+trait A : std::marker::MarkerTrait {}\n impl A for B1 {}\n \n fn main() {"}, {"sha": "71d88ee6215103a991f81a0a2ea904f45ad3cf16", "filename": "src/test/run-pass/issue-14589.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-14589.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-14589.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14589.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -17,17 +17,18 @@\n fn main() {\n     send::<Box<Foo>>(box Output(0));\n     Test::<Box<Foo>>::foo(box Output(0));\n-    Test::<Box<Foo>>.send(box Output(0));\n+    Test::<Box<Foo>>::new().send(box Output(0));\n }\n \n fn send<T>(_: T) {}\n \n-struct Test<T>;\n+struct Test<T> { marker: std::marker::PhantomData<T> }\n impl<T> Test<T> {\n+    fn new() -> Test<T> { Test { marker: ::std::marker::PhantomData } }\n     fn foo(_: T) {}\n     fn send(&self, _: T) {}\n }\n \n-trait Foo {}\n+trait Foo { fn dummy(&self) { }}\n struct Output(int);\n impl Foo for Output {}"}, {"sha": "6335f79be6c7aae7b547f67e33baa240f352fce9", "filename": "src/test/run-pass/issue-14958.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b34e0c52b098158541d2ba9e334df1ce4812/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14958.rs?ref=1506b34e0c52b098158541d2ba9e334df1ce4812", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(unboxed_closures)]\n \n-trait Foo {}\n+trait Foo { fn dummy(&self) { }}\n \n struct Bar;\n "}]}