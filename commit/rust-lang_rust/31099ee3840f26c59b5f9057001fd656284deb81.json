{"sha": "31099ee3840f26c59b5f9057001fd656284deb81", "node_id": "C_kwDOAAsO6NoAKDMxMDk5ZWUzODQwZjI2YzU5YjVmOTA1NzAwMWZkNjU2Mjg0ZGViODE", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-09T16:13:14Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-09T16:16:12Z"}, "message": "update test for inductive canonical cycles", "tree": {"sha": "3f2c3edb7db2bb356ca0241ee26e8720a2dfc880", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f2c3edb7db2bb356ca0241ee26e8720a2dfc880"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31099ee3840f26c59b5f9057001fd656284deb81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31099ee3840f26c59b5f9057001fd656284deb81", "html_url": "https://github.com/rust-lang/rust/commit/31099ee3840f26c59b5f9057001fd656284deb81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31099ee3840f26c59b5f9057001fd656284deb81/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89e0576bd3aec2f1acf935b353900bd75742860b", "url": "https://api.github.com/repos/rust-lang/rust/commits/89e0576bd3aec2f1acf935b353900bd75742860b", "html_url": "https://github.com/rust-lang/rust/commit/89e0576bd3aec2f1acf935b353900bd75742860b"}], "stats": {"total": 101, "additions": 58, "deletions": 43}, "files": [{"sha": "5449f5f00d52a8699d7132f7b7e86ce3bf5f8cc7", "filename": "src/test/ui/traits/solver-cycles/inductive-canonical-cycle.rs", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/31099ee3840f26c59b5f9057001fd656284deb81/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31099ee3840f26c59b5f9057001fd656284deb81/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.rs?ref=31099ee3840f26c59b5f9057001fd656284deb81", "patch": "@@ -1,28 +1,69 @@\n-// known-bug\n+// check-pass\n+\n+// This test checks that we're correctly dealing with inductive cycles\n+// with canonical inference variables.\n \n-// This should compile but fails with the current solver.\n-//\n-// This checks that the new solver uses `Ambiguous` when hitting the\n-// inductive cycle here when proving `exists<^0, ^1> (): Trait<^0, ^1>`\n-// which requires proving `Trait<?1, ?0>` but that has the same\n-// canonical representation.\n trait Trait<T, U> {}\n \n-impl<T, U> Trait<T, U> for ()\n+trait IsNotU32 {}\n+impl IsNotU32 for i32 {}\n+impl<T: IsNotU32, U> Trait<T, U> for () // impl 1\n where\n-    (): Trait<U, T>,\n-    T: OtherTrait,\n+    (): Trait<U, T>\n {}\n \n-trait OtherTrait {}\n-impl OtherTrait for u32 {}\n+impl<T> Trait<u32, T> for () {} // impl 2\n+\n+// If we now check whether `(): Trait<?0, ?1>` holds this has to\n+// result in ambiguity as both `for<T> (): Trait<u32, T>` and `(): Trait<i32, u32>`\n+// applies. The remainder of this test asserts that.\n+\n+// If we were to error on inductive cycles with canonical inference variables\n+// this would be wrong:\n \n-fn require_trait<T, U>()\n+// (): Trait<?0, ?1>\n+//  - impl 1\n+//      - ?0: IsNotU32 // ambig\n+//      - (): Trait<?1, ?0> // canonical cycle -> err\n+//      - ERR\n+//  - impl 2\n+//      - OK ?0 == u32\n+//\n+// Result: OK ?0 == u32.\n+\n+// (): Trait<i32, u32>\n+//  - impl 1\n+//      - i32: IsNotU32 // ok\n+//      - (): Trait<u32, i32>\n+//          - impl 1\n+//              - u32: IsNotU32 // err\n+//              - ERR\n+//          - impl 2\n+//              - OK\n+//      - OK\n+//  - impl 2 (trivial ERR)\n+//\n+// Result OK\n+\n+// This would mean that `(): Trait<?0, ?1>` is not complete,\n+// which is unsound if we're in coherence.\n+\n+fn implements_trait<T, U>() -> (T, U)\n where\n-    (): Trait<T, U>\n-{}\n+    (): Trait<T, U>,\n+{\n+    todo!()\n+}\n+\n+// A hack to only constrain the infer vars after first checking\n+// the `(): Trait<_, _>`.\n+trait Constrain<T> {}\n+impl<T> Constrain<T> for  T {}\n+fn constrain<T: Constrain<U>, U>(_: U) {}\n \n fn main() {\n-    require_trait::<_, _>();\n-    //~^ ERROR overflow evaluating\n+    let (x, y) = implements_trait::<_, _>();\n+\n+    constrain::<i32, _>(x);\n+    constrain::<u32, _>(y);\n }"}, {"sha": "e4b84e07822d28c784896071f43f19244aff4da6", "filename": "src/test/ui/traits/solver-cycles/inductive-canonical-cycle.stderr", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/89e0576bd3aec2f1acf935b353900bd75742860b/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89e0576bd3aec2f1acf935b353900bd75742860b/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.stderr?ref=89e0576bd3aec2f1acf935b353900bd75742860b", "patch": "@@ -1,26 +0,0 @@\n-error[E0275]: overflow evaluating the requirement `_: Sized`\n-  --> $DIR/inductive-canonical-cycle.rs:26:5\n-   |\n-LL |     require_trait::<_, _>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`inductive_canonical_cycle`)\n-note: required for `()` to implement `Trait<_, _>`\n-  --> $DIR/inductive-canonical-cycle.rs:11:12\n-   |\n-LL | impl<T, U> Trait<T, U> for ()\n-   |            ^^^^^^^^^^^     ^^\n-   = note: 128 redundant requirements hidden\n-   = note: required for `()` to implement `Trait<_, _>`\n-note: required by a bound in `require_trait`\n-  --> $DIR/inductive-canonical-cycle.rs:22:9\n-   |\n-LL | fn require_trait<T, U>()\n-   |    ------------- required by a bound in this\n-LL | where\n-LL |     (): Trait<T, U>\n-   |         ^^^^^^^^^^^ required by this bound in `require_trait`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0275`."}]}