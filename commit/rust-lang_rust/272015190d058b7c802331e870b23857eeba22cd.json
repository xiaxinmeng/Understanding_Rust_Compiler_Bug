{"sha": "272015190d058b7c802331e870b23857eeba22cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MjAxNTE5MGQwNThiN2M4MDIzMzFlODcwYjIzODU3ZWViYTIyY2Q=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-04-15T23:25:01Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-04-27T16:46:33Z"}, "message": "Add [TRACKED_NO_CRATE_HASH] and [SUBSTRUCT] directives\n\nThis is necessary for options that should invalidate the incremental\nhash but *not* affect the crate hash (e.g. --remap-path-prefix).\n\nThis doesn't add `for_crate_hash` to the trait directly because it's not\nrelevant for *types*, only for *options*, which are fields on a larger\nstruct. Instead, it adds a new `SUBSTRUCT` directive for options, which\ndoes take a `for_crate_hash` parameter.\n\n- Use TRACKED_NO_CRATE_HASH for --remap-path-prefix\n- Add test that `remap_path_prefix` is tracked\n- Reduce duplication in the test suite to avoid future churn", "tree": {"sha": "a927ab1798e297958c4052f39b0ae3ae21ada48e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a927ab1798e297958c4052f39b0ae3ae21ada48e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/272015190d058b7c802331e870b23857eeba22cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/272015190d058b7c802331e870b23857eeba22cd", "html_url": "https://github.com/rust-lang/rust/commit/272015190d058b7c802331e870b23857eeba22cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/272015190d058b7c802331e870b23857eeba22cd/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb7018b41e66aa2edfaf2d4fbb8fe260cb411ac2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb7018b41e66aa2edfaf2d4fbb8fe260cb411ac2", "html_url": "https://github.com/rust-lang/rust/commit/fb7018b41e66aa2edfaf2d4fbb8fe260cb411ac2"}], "stats": {"total": 223, "additions": 133, "deletions": 90}, "files": [{"sha": "2661afd7ffc3b32d5a72d88043863cd5664224da", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=272015190d058b7c802331e870b23857eeba22cd", "patch": "@@ -104,7 +104,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     // Fortunately, we just checked that this isn't the case.\n     let path = dep_graph_path_from(&sess.incr_comp_session_dir());\n     let report_incremental_info = sess.opts.debugging_opts.incremental_info;\n-    let expected_hash = sess.opts.dep_tracking_hash();\n+    let expected_hash = sess.opts.dep_tracking_hash(false);\n \n     let mut prev_work_products = FxHashMap::default();\n     let nightly_build = sess.is_nightly_build();"}, {"sha": "1484088837a4be1cf03c61a5e8fc9bbb46b2c54e", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=272015190d058b7c802331e870b23857eeba22cd", "patch": "@@ -219,7 +219,7 @@ pub fn build_dep_graph(\n     }\n \n     // First encode the commandline arguments hash\n-    if let Err(err) = sess.opts.dep_tracking_hash().encode(&mut encoder) {\n+    if let Err(err) = sess.opts.dep_tracking_hash(false).encode(&mut encoder) {\n         sess.err(&format!(\n             \"failed to write dependency graph hash `{}`: {}\",\n             path_buf.display(),"}, {"sha": "62c2d3c722f5aa584a1cacf3cc9ad4f81bb10757", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 68, "deletions": 63, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=272015190d058b7c802331e870b23857eeba22cd", "patch": "@@ -19,6 +19,7 @@ use rustc_span::symbol::sym;\n use rustc_span::SourceFileHashAlgorithm;\n use rustc_target::spec::{CodeModel, LinkerFlavor, MergeFunctions, PanicStrategy};\n use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo, TlsModel};\n+\n use std::collections::{BTreeMap, BTreeSet};\n use std::iter::FromIterator;\n use std::num::NonZeroUsize;\n@@ -74,6 +75,27 @@ fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n     BTreeMap::from_iter(entries.into_iter())\n }\n \n+fn assert_same_clone(x: &Options) {\n+    assert_eq!(x.dep_tracking_hash(true), x.clone().dep_tracking_hash(true));\n+    assert_eq!(x.dep_tracking_hash(false), x.clone().dep_tracking_hash(false));\n+}\n+\n+fn assert_same_hash(x: &Options, y: &Options) {\n+    assert_eq!(x.dep_tracking_hash(true), y.dep_tracking_hash(true));\n+    assert_eq!(x.dep_tracking_hash(false), y.dep_tracking_hash(false));\n+    // Check clone\n+    assert_same_clone(x);\n+    assert_same_clone(y);\n+}\n+\n+fn assert_different_hash(x: &Options, y: &Options) {\n+    assert_ne!(x.dep_tracking_hash(true), y.dep_tracking_hash(true));\n+    assert_ne!(x.dep_tracking_hash(false), y.dep_tracking_hash(false));\n+    // Check clone\n+    assert_same_clone(x);\n+    assert_same_clone(y);\n+}\n+\n // When the user supplies --test we should implicitly supply --cfg test\n #[test]\n fn test_switch_implies_cfg_test() {\n@@ -130,14 +152,9 @@ fn test_output_types_tracking_hash_different_paths() {\n     v2.output_types = OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"/some/thing\")))]);\n     v3.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n \n-    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-    assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_different_hash(&v1, &v2);\n+    assert_different_hash(&v1, &v3);\n+    assert_different_hash(&v2, &v3);\n }\n \n #[test]\n@@ -155,10 +172,7 @@ fn test_output_types_tracking_hash_different_construction_order() {\n         (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n     ]);\n \n-    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_same_hash(&v1, &v2);\n }\n \n #[test]\n@@ -182,14 +196,9 @@ fn test_externs_tracking_hash_different_construction_order() {\n         (String::from(\"d\"), new_public_extern_entry(vec![\"f\", \"e\"])),\n     ]));\n \n-    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-    assert_eq!(v1.dep_tracking_hash(), v3.dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v3.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_same_hash(&v1, &v2);\n+    assert_same_hash(&v1, &v3);\n+    assert_same_hash(&v2, &v3);\n }\n \n #[test]\n@@ -219,14 +228,9 @@ fn test_lints_tracking_hash_different_values() {\n         (String::from(\"d\"), Level::Deny),\n     ];\n \n-    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-    assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_different_hash(&v1, &v2);\n+    assert_different_hash(&v1, &v3);\n+    assert_different_hash(&v2, &v3);\n }\n \n #[test]\n@@ -248,11 +252,7 @@ fn test_lints_tracking_hash_different_construction_order() {\n         (String::from(\"d\"), Level::Forbid),\n     ];\n \n-    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_same_hash(&v1, &v2);\n }\n \n #[test]\n@@ -292,15 +292,9 @@ fn test_search_paths_tracking_hash_different_order() {\n     v4.search_paths.push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n     v4.search_paths.push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n \n-    assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() == v4.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+    assert_same_hash(&v1, &v2);\n+    assert_same_hash(&v1, &v3);\n+    assert_same_hash(&v1, &v4);\n }\n \n #[test]\n@@ -338,15 +332,9 @@ fn test_native_libs_tracking_hash_different_values() {\n         (String::from(\"c\"), None, NativeLibKind::Unspecified),\n     ];\n \n-    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() != v4.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+    assert_different_hash(&v1, &v2);\n+    assert_different_hash(&v1, &v3);\n+    assert_different_hash(&v1, &v4);\n }\n \n #[test]\n@@ -374,14 +362,9 @@ fn test_native_libs_tracking_hash_different_order() {\n         (String::from(\"b\"), None, NativeLibKind::Framework),\n     ];\n \n-    assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n-    assert!(v2.dep_tracking_hash() == v3.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_same_hash(&v1, &v2);\n+    assert_same_hash(&v1, &v3);\n+    assert_same_hash(&v2, &v3);\n }\n \n #[test]\n@@ -393,7 +376,7 @@ fn test_codegen_options_tracking_hash() {\n         ($name: ident, $non_default_value: expr) => {\n             assert_ne!(opts.cg.$name, $non_default_value);\n             opts.cg.$name = $non_default_value;\n-            assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+            assert_same_hash(&reference, &opts);\n         };\n     }\n \n@@ -419,7 +402,7 @@ fn test_codegen_options_tracking_hash() {\n             opts = reference.clone();\n             assert_ne!(opts.cg.$name, $non_default_value);\n             opts.cg.$name = $non_default_value;\n-            assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+            assert_different_hash(&reference, &opts);\n         };\n     }\n \n@@ -456,6 +439,28 @@ fn test_codegen_options_tracking_hash() {\n     tracked!(target_feature, String::from(\"all the features, all of them\"));\n }\n \n+#[test]\n+fn test_top_level_options_tracked_no_crate() {\n+    let reference = Options::default();\n+    let mut opts;\n+\n+    macro_rules! tracked {\n+        ($name: ident, $non_default_value: expr) => {\n+            opts = reference.clone();\n+            assert_ne!(opts.$name, $non_default_value);\n+            opts.$name = $non_default_value;\n+            // The crate hash should be the same\n+            assert_eq!(reference.dep_tracking_hash(true), opts.dep_tracking_hash(true));\n+            // The incremental hash should be different\n+            assert_ne!(reference.dep_tracking_hash(false), opts.dep_tracking_hash(false));\n+        };\n+    }\n+\n+    // Make sure that changing a [TRACKED_NO_CRATE_HASH] option leaves the crate hash unchanged but changes the incremental hash.\n+    // This list is in alphabetical order.\n+    tracked!(remap_path_prefix, vec![(\"/home/bors/rust\".into(), \"src\".into())]);\n+}\n+\n #[test]\n fn test_debugging_options_tracking_hash() {\n     let reference = Options::default();\n@@ -465,7 +470,7 @@ fn test_debugging_options_tracking_hash() {\n         ($name: ident, $non_default_value: expr) => {\n             assert_ne!(opts.debugging_opts.$name, $non_default_value);\n             opts.debugging_opts.$name = $non_default_value;\n-            assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+            assert_same_hash(&reference, &opts);\n         };\n     }\n \n@@ -537,7 +542,7 @@ fn test_debugging_options_tracking_hash() {\n             opts = reference.clone();\n             assert_ne!(opts.debugging_opts.$name, $non_default_value);\n             opts.debugging_opts.$name = $non_default_value;\n-            assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+            assert_different_hash(&reference, &opts);\n         };\n     }\n "}, {"sha": "4cd126988f91f3aec5bad20945f7a7e4c06fb587", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=272015190d058b7c802331e870b23857eeba22cd", "patch": "@@ -943,7 +943,7 @@ pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> &'tcx Indexe\n         intravisit::walk_crate(&mut collector, tcx.untracked_crate);\n \n         let crate_disambiguator = tcx.sess.local_crate_disambiguator();\n-        let cmdline_args = tcx.sess.opts.dep_tracking_hash();\n+        let cmdline_args = tcx.sess.opts.dep_tracking_hash(true);\n         collector.finalize_and_compute_crate_hash(crate_disambiguator, &*tcx.cstore, cmdline_args)\n     };\n "}, {"sha": "5d588ad1be2d0a54118bb4418e401eca577651c7", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=272015190d058b7c802331e870b23857eeba22cd", "patch": "@@ -2374,6 +2374,7 @@ crate mod dep_tracking {\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n+    impl_dep_tracking_hash_for_sortable_vec_of!((PathBuf, PathBuf));\n     impl_dep_tracking_hash_for_sortable_vec_of!(CrateType);\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, lint::Level));\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, Option<String>, NativeLibKind));"}, {"sha": "226c7bda0522f6cc9d65afab9f611a4f97797240", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272015190d058b7c802331e870b23857eeba22cd/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=272015190d058b7c802331e870b23857eeba22cd", "patch": "@@ -20,42 +20,69 @@ use std::num::NonZeroUsize;\n use std::path::PathBuf;\n use std::str;\n \n-macro_rules! hash_option {\n-    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [UNTRACKED]) => {{}};\n-    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => {{\n+macro_rules! insert {\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr) => {\n         if $sub_hashes\n             .insert(stringify!($opt_name), $opt_expr as &dyn dep_tracking::DepTrackingHash)\n             .is_some()\n         {\n             panic!(\"duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n         }\n+    };\n+}\n+\n+macro_rules! hash_opt {\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, $_for_crate_hash: ident, [UNTRACKED]) => {{}};\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, $_for_crate_hash: ident, [TRACKED]) => {{ insert!($opt_name, $opt_expr, $sub_hashes) }};\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, $for_crate_hash: ident, [TRACKED_NO_CRATE_HASH]) => {{\n+        if !$for_crate_hash {\n+            insert!($opt_name, $opt_expr, $sub_hashes)\n+        }\n     }};\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, $_for_crate_hash: ident, [SUBSTRUCT]) => {{}};\n+}\n+\n+macro_rules! hash_substruct {\n+    ($opt_name:ident, $opt_expr:expr, $error_format:expr, $for_crate_hash:expr, $hasher:expr, [UNTRACKED]) => {{}};\n+    ($opt_name:ident, $opt_expr:expr, $error_format:expr, $for_crate_hash:expr, $hasher:expr, [TRACKED]) => {{}};\n+    ($opt_name:ident, $opt_expr:expr, $error_format:expr, $for_crate_hash:expr, $hasher:expr, [TRACKED_NO_CRATE_HASH]) => {{}};\n+    ($opt_name:ident, $opt_expr:expr, $error_format:expr, $for_crate_hash:expr, $hasher:expr, [SUBSTRUCT]) => {\n+        use crate::config::dep_tracking::DepTrackingHash;\n+        $opt_expr.dep_tracking_hash($for_crate_hash, $error_format).hash($hasher, $error_format);\n+    };\n }\n \n macro_rules! top_level_options {\n     (pub struct Options { $(\n-        $opt:ident : $t:ty [$dep_tracking_marker:ident $($warn_val:expr, $warn_text:expr)*],\n+        $opt:ident : $t:ty [$dep_tracking_marker:ident],\n     )* } ) => (\n         #[derive(Clone)]\n         pub struct Options {\n             $(pub $opt: $t),*\n         }\n \n         impl Options {\n-            pub fn dep_tracking_hash(&self) -> u64 {\n+            pub fn dep_tracking_hash(&self, for_crate_hash: bool) -> u64 {\n                 let mut sub_hashes = BTreeMap::new();\n                 $({\n-                    hash_option!($opt,\n-                                 &self.$opt,\n-                                 &mut sub_hashes,\n-                                 [$dep_tracking_marker $($warn_val,\n-                                                         $warn_text,\n-                                                         self.error_format)*]);\n+                    hash_opt!($opt,\n+                                &self.$opt,\n+                                &mut sub_hashes,\n+                                for_crate_hash,\n+                                [$dep_tracking_marker]);\n                 })*\n                 let mut hasher = DefaultHasher::new();\n                 dep_tracking::stable_hash(sub_hashes,\n                                           &mut hasher,\n                                           self.error_format);\n+                $({\n+                    hash_substruct!($opt,\n+                        &self.$opt,\n+                        self.error_format,\n+                        for_crate_hash,\n+                        &mut hasher,\n+                        [$dep_tracking_marker]);\n+                })*\n                 hasher.finish()\n             }\n         }\n@@ -72,9 +99,16 @@ macro_rules! top_level_options {\n // A change in the given field will cause the compiler to completely clear the\n // incremental compilation cache before proceeding.\n //\n+// [TRACKED_NO_CRATE_HASH]\n+// Same as [TRACKED], but will not affect the crate hash. This is useful for options that only\n+// affect the incremental cache.\n+//\n // [UNTRACKED]\n // Incremental compilation is not influenced by this option.\n //\n+// [SUBSTRUCT]\n+// Second-level sub-structs containing more options.\n+//\n // If you add a new option to this struct or one of the sub-structs like\n // `CodegenOptions`, think about how it influences incremental compilation. If in\n // doubt, specify [TRACKED], which is always \"correct\" but might lead to\n@@ -106,12 +140,12 @@ top_level_options!(\n         // directory to store intermediate results.\n         incremental: Option<PathBuf> [UNTRACKED],\n \n-        debugging_opts: DebuggingOptions [TRACKED],\n+        debugging_opts: DebuggingOptions [SUBSTRUCT],\n         prints: Vec<PrintRequest> [UNTRACKED],\n         // Determines which borrow checker(s) to run. This is the parsed, sanitized\n         // version of `debugging_opts.borrowck`, which is just a plain string.\n         borrowck_mode: BorrowckMode [UNTRACKED],\n-        cg: CodegenOptions [TRACKED],\n+        cg: CodegenOptions [SUBSTRUCT],\n         externs: Externs [UNTRACKED],\n         extern_dep_specs: ExternDepSpecs [UNTRACKED],\n         crate_name: Option<String> [TRACKED],\n@@ -139,7 +173,7 @@ top_level_options!(\n         cli_forced_thinlto_off: bool [UNTRACKED],\n \n         // Remap source path prefixes in all output (messages, object files, debug, etc.).\n-        remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n+        remap_path_prefix: Vec<(PathBuf, PathBuf)> [TRACKED_NO_CRATE_HASH],\n \n         edition: Edition [TRACKED],\n \n@@ -169,7 +203,7 @@ macro_rules! options {\n      $($opt:ident : $t:ty = (\n         $init:expr,\n         $parse:ident,\n-        [$dep_tracking_marker:ident $(($dep_warn_val:expr, $dep_warn_text:expr))*],\n+        [$dep_tracking_marker:ident],\n         $desc:expr)\n      ),* ,) =>\n (\n@@ -219,18 +253,21 @@ macro_rules! options {\n         return op;\n     }\n \n-    impl dep_tracking::DepTrackingHash for $struct_name {\n-        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n+    impl $struct_name {\n+        fn dep_tracking_hash(&self, for_crate_hash: bool, error_format: ErrorOutputType) -> u64 {\n             let mut sub_hashes = BTreeMap::new();\n             $({\n-                hash_option!($opt,\n-                             &self.$opt,\n-                             &mut sub_hashes,\n-                             [$dep_tracking_marker $($dep_warn_val,\n-                                                     $dep_warn_text,\n-                                                     error_format)*]);\n+                hash_opt!($opt,\n+                            &self.$opt,\n+                            &mut sub_hashes,\n+                            for_crate_hash,\n+                            [$dep_tracking_marker]);\n             })*\n-            dep_tracking::stable_hash(sub_hashes, hasher, error_format);\n+            let mut hasher = DefaultHasher::new();\n+            dep_tracking::stable_hash(sub_hashes,\n+                                        &mut hasher,\n+                                        error_format);\n+            hasher.finish()\n         }\n     }\n "}]}