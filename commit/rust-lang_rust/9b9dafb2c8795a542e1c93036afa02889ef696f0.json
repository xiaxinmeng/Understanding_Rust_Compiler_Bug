{"sha": "9b9dafb2c8795a542e1c93036afa02889ef696f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliOWRhZmIyYzg3OTVhNTQyZTFjOTMwMzZhZmEwMjg4OWVmNjk2ZjA=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-01-11T20:30:42Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-03T19:42:15Z"}, "message": "Make use of `Place: Copy`", "tree": {"sha": "6f68e648e03358a135f87be2856d9685910fece7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f68e648e03358a135f87be2856d9685910fece7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b9dafb2c8795a542e1c93036afa02889ef696f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9dafb2c8795a542e1c93036afa02889ef696f0", "html_url": "https://github.com/rust-lang/rust/commit/9b9dafb2c8795a542e1c93036afa02889ef696f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b9dafb2c8795a542e1c93036afa02889ef696f0/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d90ed6370df81cb6e30816cb655c5a90af824a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d90ed6370df81cb6e30816cb655c5a90af824a6", "html_url": "https://github.com/rust-lang/rust/commit/1d90ed6370df81cb6e30816cb655c5a90af824a6"}], "stats": {"total": 76, "additions": 34, "deletions": 42}, "files": [{"sha": "7ab91293989754d89713e40592934ddf695522b3", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9b9dafb2c8795a542e1c93036afa02889ef696f0/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9dafb2c8795a542e1c93036afa02889ef696f0/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=9b9dafb2c8795a542e1c93036afa02889ef696f0", "patch": "@@ -93,7 +93,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let scrutinee_place =\n             unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span,));\n \n-        let mut arm_candidates = self.create_match_candidates(&scrutinee_place, &arms);\n+        let mut arm_candidates = self.create_match_candidates(scrutinee_place, &arms);\n \n         let match_has_guard = arms.iter().any(|arm| arm.guard.is_some());\n         let mut candidates =\n@@ -103,7 +103,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.lower_match_tree(block, scrutinee_span, match_has_guard, &mut candidates);\n \n         self.lower_match_arms(\n-            &destination,\n+            destination,\n             scrutinee_place,\n             scrutinee_span,\n             arm_candidates,\n@@ -137,23 +137,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // check safety.\n         let cause_matched_place = FakeReadCause::ForMatchedPlace;\n         let source_info = self.source_info(scrutinee_span);\n-        self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place.clone());\n+        self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n \n         block.and(scrutinee_place)\n     }\n \n     /// Create the initial `Candidate`s for a `match` expression.\n     fn create_match_candidates<'pat>(\n         &mut self,\n-        scrutinee: &Place<'tcx>,\n+        scrutinee: Place<'tcx>,\n         arms: &'pat [Arm<'tcx>],\n     ) -> Vec<(&'pat Arm<'tcx>, Candidate<'pat, 'tcx>)> {\n         // Assemble a list of candidates: there is one candidate per pattern,\n         // which means there may be more than one candidate *per arm*.\n         arms.iter()\n             .map(|arm| {\n                 let arm_has_guard = arm.guard.is_some();\n-                let arm_candidate = Candidate::new(*scrutinee, &arm.pattern, arm_has_guard);\n+                let arm_candidate = Candidate::new(scrutinee, &arm.pattern, arm_has_guard);\n                 (arm, arm_candidate)\n             })\n             .collect()\n@@ -391,7 +391,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let pattern_source_info = self.source_info(irrefutable_pat.span);\n                 let cause_let = FakeReadCause::ForLet;\n-                self.cfg.push_fake_read(block, pattern_source_info, cause_let, place.clone());\n+                self.cfg.push_fake_read(block, pattern_source_info, cause_let, place);\n \n                 let ty_source_info = self.source_info(user_ty_span);\n                 let user_ty = pat_ascription_ty.user_ty(\n@@ -430,7 +430,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             _ => {\n                 let place = unpack!(block = self.as_place(block, initializer));\n-                self.place_into_pattern(block, irrefutable_pat, &place, true)\n+                self.place_into_pattern(block, irrefutable_pat, place, true)\n             }\n         }\n     }\n@@ -439,10 +439,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         block: BasicBlock,\n         irrefutable_pat: Pat<'tcx>,\n-        initializer: &Place<'tcx>,\n+        initializer: Place<'tcx>,\n         set_match_place: bool,\n     ) -> BlockAnd<()> {\n-        let mut candidate = Candidate::new(*initializer, &irrefutable_pat, false);\n+        let mut candidate = Candidate::new(initializer, &irrefutable_pat, false);\n \n         let fake_borrow_temps =\n             self.lower_match_tree(block, irrefutable_pat.span, false, &mut [&mut candidate]);\n@@ -461,7 +461,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n                     ))) = self.local_decls[local].local_info\n                     {\n-                        *match_place = Some(*initializer);\n+                        *match_place = Some(initializer);\n                     } else {\n                         bug!(\"Let binding to non-user variable.\")\n                     }\n@@ -897,7 +897,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span: Span,\n         start_block: BasicBlock,\n         otherwise_block: &mut Option<BasicBlock>,\n-        candidates: &mut [&mut Candidate<_, 'tcx>],\n+        candidates: &mut [&mut Candidate<'_, 'tcx>],\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) {\n         // The candidates are sorted by priority. Check to see whether the\n@@ -1121,7 +1121,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         for match_pair in match_pairs {\n             if let PatKind::Or { ref pats } = *match_pair.pattern.kind {\n                 let or_span = match_pair.pattern.span;\n-                let place = &match_pair.place;\n+                let place = match_pair.place;\n \n                 first_candidate.visit_leaves(|leaf_candidate| {\n                     self.test_or_pattern(\n@@ -1155,14 +1155,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         otherwise: &mut Option<BasicBlock>,\n         pats: &'pat [Pat<'tcx>],\n         or_span: Span,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) {\n         debug!(\"test_or_pattern:\\ncandidate={:#?}\\npats={:#?}\", candidate, pats);\n-        let mut or_candidates: Vec<_> = pats\n-            .iter()\n-            .map(|pat| Candidate::new(place.clone(), pat, candidate.has_guard))\n-            .collect();\n+        let mut or_candidates: Vec<_> =\n+            pats.iter().map(|pat| Candidate::new(place, pat, candidate.has_guard)).collect();\n         let mut or_candidate_refs: Vec<_> = or_candidates.iter_mut().collect();\n         let otherwise = if candidate.otherwise_block.is_some() {\n             &mut candidate.otherwise_block\n@@ -1368,7 +1366,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         // Insert a Shallow borrow of any places that is switched on.\n-        fake_borrows.as_mut().map(|fb| fb.insert(match_place.clone()));\n+        fake_borrows.as_mut().map(|fb| fb.insert(match_place));\n \n         // perform the test, branching to one of N blocks. For each of\n         // those N possible outcomes, create a (initially empty)\n@@ -1448,7 +1446,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             target_blocks\n         };\n \n-        self.perform_test(block, &match_place, &test, make_target_blocks);\n+        self.perform_test(block, match_place, &test, make_target_blocks);\n     }\n \n     /// Determine the fake borrows that are needed from a set of places that\n@@ -1669,9 +1667,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             let re_erased = tcx.lifetimes.re_erased;\n             let scrutinee_source_info = self.source_info(scrutinee_span);\n-            for (place, temp) in fake_borrows {\n-                let borrow = Rvalue::Ref(re_erased, BorrowKind::Shallow, *place);\n-                self.cfg.push_assign(block, scrutinee_source_info, &Place::from(*temp), borrow);\n+            for &(place, temp) in fake_borrows {\n+                let borrow = Rvalue::Ref(re_erased, BorrowKind::Shallow, place);\n+                self.cfg.push_assign(block, scrutinee_source_info, &Place::from(temp), borrow);\n             }\n \n             // the block to branch to if the guard fails; if there is no"}, {"sha": "4213a30f2d8c14d8f4f0ef38a4d75cfa03767c40", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9dafb2c8795a542e1c93036afa02889ef696f0/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9dafb2c8795a542e1c93036afa02889ef696f0/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=9b9dafb2c8795a542e1c93036afa02889ef696f0", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         loop {\n             let match_pairs = mem::take(&mut candidate.match_pairs);\n \n-            if let [MatchPair { pattern: Pat { kind: box PatKind::Or { pats }, .. }, ref place }] =\n+            if let [MatchPair { pattern: Pat { kind: box PatKind::Or { pats }, .. }, place }] =\n                 *match_pairs\n             {\n                 candidate.subcandidates = self.create_or_subcandidates(candidate, place, pats);\n@@ -78,12 +78,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn create_or_subcandidates<'pat>(\n         &mut self,\n         candidate: &Candidate<'pat, 'tcx>,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         pats: &'pat [Pat<'tcx>],\n     ) -> Vec<Candidate<'pat, 'tcx>> {\n         pats.iter()\n             .map(|pat| {\n-                let mut candidate = Candidate::new(place.clone(), pat, candidate.has_guard);\n+                let mut candidate = Candidate::new(place, pat, candidate.has_guard);\n                 self.simplify_candidate(&mut candidate);\n                 candidate\n             })"}, {"sha": "1acfa7dddbe1f7822729c6d1b58021a6b68f8bfb", "filename": "src/librustc_mir_build/build/matches/test.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b9dafb2c8795a542e1c93036afa02889ef696f0/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9dafb2c8795a542e1c93036afa02889ef696f0/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs?ref=9b9dafb2c8795a542e1c93036afa02889ef696f0", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub(super) fn perform_test(\n         &mut self,\n         block: BasicBlock,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         test: &Test<'tcx>,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 );\n                 let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n                 let discr = self.temp(discr_ty, test.span);\n-                self.cfg.push_assign(block, source_info, &discr, Rvalue::Discriminant(*place));\n+                self.cfg.push_assign(block, source_info, &discr, Rvalue::Discriminant(place));\n                 assert_eq!(values.len() + 1, targets.len());\n                 self.cfg.terminate(\n                     block,\n@@ -229,20 +229,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             0 => (second_bb, first_bb),\n                             v => span_bug!(test.span, \"expected boolean value but got {:?}\", v),\n                         };\n-                        TerminatorKind::if_(\n-                            self.hir.tcx(),\n-                            Operand::Copy(*place),\n-                            true_bb,\n-                            false_bb,\n-                        )\n+                        TerminatorKind::if_(self.hir.tcx(), Operand::Copy(place), true_bb, false_bb)\n                     } else {\n                         bug!(\"`TestKind::SwitchInt` on `bool` should have two targets\")\n                     }\n                 } else {\n                     // The switch may be inexhaustive so we have a catch all block\n                     debug_assert_eq!(options.len() + 1, target_blocks.len());\n                     TerminatorKind::SwitchInt {\n-                        discr: Operand::Copy(*place),\n+                        discr: Operand::Copy(place),\n                         switch_ty,\n                         values: options.clone().into(),\n                         targets: target_blocks,\n@@ -267,7 +262,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     if let [success, fail] = *make_target_blocks(self) {\n                         assert_eq!(value.ty, ty);\n                         let expect = self.literal_operand(test.span, value);\n-                        let val = Operand::Copy(*place);\n+                        let val = Operand::Copy(place);\n                         self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n                     } else {\n                         bug!(\"`TestKind::Eq` should have two target blocks\");\n@@ -282,7 +277,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n                 let lo = self.literal_operand(test.span, lo);\n                 let hi = self.literal_operand(test.span, hi);\n-                let val = Operand::Copy(*place);\n+                let val = Operand::Copy(place);\n \n                 if let [success, fail] = *target_blocks {\n                     self.compare(\n@@ -311,7 +306,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let actual = self.temp(usize_ty, test.span);\n \n                 // actual = len(place)\n-                self.cfg.push_assign(block, source_info, &actual, Rvalue::Len(*place));\n+                self.cfg.push_assign(block, source_info, &actual, Rvalue::Len(place));\n \n                 // expected = <N>\n                 let expected = self.push_usize(block, source_info, len);\n@@ -367,13 +362,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n         source_info: SourceInfo,\n         value: &'tcx ty::Const<'tcx>,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         mut ty: Ty<'tcx>,\n     ) {\n         use rustc::middle::lang_items::EqTraitLangItem;\n \n         let mut expect = self.literal_operand(source_info.span, value);\n-        let mut val = Operand::Copy(*place);\n+        let mut val = Operand::Copy(place);\n \n         // If we're using `b\"...\"` as a pattern, we need to insert an\n         // unsizing coercion, as the byte string has the type `&[u8; N]`.\n@@ -751,8 +746,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let downcast_place = tcx.mk_place_elem(match_pair.place, elem); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n-            let place =\n-                tcx.mk_place_field(downcast_place.clone(), subpattern.field, subpattern.pattern.ty);\n+            let place = tcx.mk_place_field(downcast_place, subpattern.field, subpattern.pattern.ty);\n             // e.g., `(x as Variant).0 @ P1`\n             MatchPair::new(place, &subpattern.pattern)\n         });"}, {"sha": "7e51f7aafe4b336fb3ba63ce335e21eceec2c600", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9dafb2c8795a542e1c93036afa02889ef696f0/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9dafb2c8795a542e1c93036afa02889ef696f0/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=9b9dafb2c8795a542e1c93036afa02889ef696f0", "patch": "@@ -899,7 +899,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             matches::ArmHasGuard(false),\n                             Some((Some(&place), span)),\n                         );\n-                        unpack!(block = self.place_into_pattern(block, pattern, &place, false));\n+                        unpack!(block = self.place_into_pattern(block, pattern, place, false));\n                     }\n                 }\n                 self.source_scope = original_source_scope;"}]}