{"sha": "fe1f651e4c28bb39da739f1433d94c6ed6caec82", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMWY2NTFlNGMyOGJiMzlkYTczOWYxNDMzZDk0YzZlZDZjYWVjODI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-11T00:56:05Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-15T13:21:32Z"}, "message": "Review refactoring", "tree": {"sha": "c52eaf3a72c08ba99519159660ddac5710c2ed30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c52eaf3a72c08ba99519159660ddac5710c2ed30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe1f651e4c28bb39da739f1433d94c6ed6caec82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe1f651e4c28bb39da739f1433d94c6ed6caec82", "html_url": "https://github.com/rust-lang/rust/commit/fe1f651e4c28bb39da739f1433d94c6ed6caec82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe1f651e4c28bb39da739f1433d94c6ed6caec82/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd8e284a206a35e4247a04f909a0960d89331ab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd8e284a206a35e4247a04f909a0960d89331ab0", "html_url": "https://github.com/rust-lang/rust/commit/fd8e284a206a35e4247a04f909a0960d89331ab0"}], "stats": {"total": 100, "additions": 48, "deletions": 52}, "files": [{"sha": "18c0020a2b49b77f60ef96b6c92737940b1cc4c3", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe1f651e4c28bb39da739f1433d94c6ed6caec82/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1f651e4c28bb39da739f1433d94c6ed6caec82/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fe1f651e4c28bb39da739f1433d94c6ed6caec82", "patch": "@@ -380,14 +380,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         for param in generics.params.iter() {\n-            let name = param.name.to_string();\n             let value = match param.kind {\n                 GenericParamDefKind::Type(_) => {\n                     let ty = trait_ref.substs.type_for_def(&param);\n                     ty.to_string()\n                 },\n                 GenericParamDefKind::Lifetime => continue,\n             };\n+            let name = param.name.to_string();\n             flags.push((name.clone(), Some(value.clone())));\n         }\n "}, {"sha": "bc558c2933cdc43f07cc43499e757fe380b469da", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe1f651e4c28bb39da739f1433d94c6ed6caec82/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1f651e4c28bb39da739f1433d94c6ed6caec82/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=fe1f651e4c28bb39da739f1433d94c6ed6caec82", "patch": "@@ -288,13 +288,14 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         let trait_str = tcx.item_path_str(trait_ref.def_id);\n         let generics = tcx.generics_of(trait_ref.def_id);\n         let generic_map = generics.params.iter().filter_map(|param| {\n-            match param.kind {\n+            let value = match param.kind {\n                 GenericParamDefKind::Type(_) => {\n-                    Some((param.name.to_string(),\n-                         trait_ref.substs.type_for_def(&param).to_string()))\n+                    trait_ref.substs.type_for_def(&param).to_string()\n                 },\n-                GenericParamDefKind::Lifetime => None\n-            }\n+                GenericParamDefKind::Lifetime => return None\n+            };\n+            let name = param.name.to_string();\n+            Some((name, value))\n         }).collect::<FxHashMap<String, String>>();\n \n         let parser = Parser::new(&self.0);"}, {"sha": "eaae874635f62772a1795aa4571a60445b62abad", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe1f651e4c28bb39da739f1433d94c6ed6caec82/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1f651e4c28bb39da739f1433d94c6ed6caec82/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fe1f651e4c28bb39da739f1433d94c6ed6caec82", "patch": "@@ -25,7 +25,6 @@ use util::nodemap::FxHashSet;\n use std::cell::Cell;\n use std::fmt;\n use std::usize;\n-use std::iter;\n \n use rustc_data_structures::indexed_vec::Idx;\n use rustc_target::spec::abi::Abi;\n@@ -342,23 +341,22 @@ impl PrintContext {\n                             GenericParamDefKind::Type(ty) => Some((param.def_id, ty.has_default)),\n                             GenericParamDefKind::Lifetime => None,\n                         }\n-                    });\n-                if let Some(last_ty) = type_params.next() {\n-                    let (_, has_default) = last_ty;\n-                    if has_default {\n-                        if let Some(substs) = tcx.lift(&substs) {\n-                            let mut types = substs.types().rev().skip(child_types);\n-                            let zipped = iter::once((last_ty, types.next().unwrap()))\n-                                              .chain(type_params.zip(types));\n-                            for ((def_id, has_default), actual) in zipped {\n-                                if !has_default {\n-                                    break;\n-                                }\n-                                if tcx.type_of(def_id).subst(tcx, substs) != actual {\n-                                    break;\n-                                }\n-                                num_supplied_defaults += 1;\n+                    }).peekable();\n+                let has_default = {\n+                    let has_default = type_params.peek().map(|(_, has_default)| has_default);\n+                    *has_default.unwrap_or(&false)\n+                };\n+                if has_default {\n+                    if let Some(substs) = tcx.lift(&substs) {\n+                        let mut types = substs.types().rev().skip(child_types);\n+                        for ((def_id, has_default), actual) in type_params.zip(types) {\n+                            if !has_default {\n+                                break;\n+                            }\n+                            if tcx.type_of(def_id).subst(tcx, substs) != actual {\n+                                break;\n                             }\n+                            num_supplied_defaults += 1;\n                         }\n                     }\n                 }"}, {"sha": "4ddbe584846784b1e156b4a6e13002c11406edda", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe1f651e4c28bb39da739f1433d94c6ed6caec82/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1f651e4c28bb39da739f1433d94c6ed6caec82/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fe1f651e4c28bb39da739f1433d94c6ed6caec82", "patch": "@@ -886,23 +886,25 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         generics.parent_count + generics.params.len()\n     });\n \n+    let mut params: Vec<_> = opt_self.into_iter().collect();\n+\n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n-    let lifetimes = early_lifetimes.enumerate().map(|(i, l)| {\n+    params.extend(early_lifetimes.enumerate().map(|(i, l)| {\n         ty::GenericParamDef {\n             name: l.lifetime.name.name().as_interned_str(),\n             index: own_start + i as u32,\n             def_id: tcx.hir.local_def_id(l.lifetime.id),\n             pure_wrt_drop: l.pure_wrt_drop,\n             kind: ty::GenericParamDefKind::Lifetime,\n         }\n-    }).collect::<Vec<_>>();\n+    }));\n \n     let hir_id = tcx.hir.node_to_hir_id(node_id);\n     let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id);\n \n     // Now create the real type parameters.\n-    let type_start = own_start + lifetimes.len() as u32;\n-    let mut types: Vec<_> = ast_generics.ty_params().enumerate().map(|(i, p)| {\n+    let type_start = params.len() as u32;\n+    params.extend(ast_generics.ty_params().enumerate().map(|(i, p)| {\n         if p.name == keywords::SelfType.name() {\n             span_bug!(p.span, \"`Self` should not be the name of a regular parameter\");\n         }\n@@ -930,7 +932,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 synthetic: p.synthetic,\n             }),\n         }\n-    }).collect();\n+    }));\n \n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n@@ -943,7 +945,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n \n         for (i, &arg) in dummy_args.iter().enumerate() {\n-            types.push(ty::GenericParamDef {\n+            params.push(ty::GenericParamDef {\n                 index: type_start + i as u32,\n                 name: Symbol::intern(arg).as_interned_str(),\n                 def_id,\n@@ -957,7 +959,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         tcx.with_freevars(node_id, |fv| {\n-            types.extend(fv.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n+            params.extend(fv.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n                 ty::GenericParamDef {\n                     index: type_start + i,\n                     name: Symbol::intern(\"<upvar>\").as_interned_str(),\n@@ -973,11 +975,6 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         });\n     }\n \n-    let params: Vec<_> = opt_self.into_iter()\n-                                 .chain(lifetimes)\n-                                 .chain(types)\n-                                 .collect();\n-\n     let param_def_id_to_index = params.iter()\n                                       .map(|param| (param.def_id, param.index))\n                                       .collect();"}, {"sha": "1ba967ce4b0644b7c9d331d1360fbad95b424a84", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe1f651e4c28bb39da739f1433d94c6ed6caec82/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1f651e4c28bb39da739f1433d94c6ed6caec82/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=fe1f651e4c28bb39da739f1433d94c6ed6caec82", "patch": "@@ -72,10 +72,9 @@ struct ImplWfCheck<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemImpl(.., ref generics, _, _, ref impl_item_refs) => {\n+            hir::ItemImpl(.., _, _, _, ref impl_item_refs) => {\n                 let impl_def_id = self.tcx.hir.local_def_id(item.id);\n                 enforce_impl_params_are_constrained(self.tcx,\n-                                                    generics,\n                                                     impl_def_id,\n                                                     impl_item_refs);\n                 enforce_impl_items_are_distinct(self.tcx, impl_item_refs);\n@@ -90,7 +89,6 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n }\n \n fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 impl_hir_generics: &hir::Generics,\n                                                  impl_def_id: DefId,\n                                                  impl_item_refs: &[hir::ImplItemRef])\n {\n@@ -115,26 +113,28 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ctp::parameters_for(&tcx.type_of(def_id), true)\n         }).collect();\n \n-    for (ty_param, hir_param) in impl_generics.params.iter()\n-                                              .zip(impl_hir_generics.params.iter()) {\n-        match (&ty_param.kind, hir_param) {\n+    for param in &impl_generics.params {\n+        match param.kind {\n             // Disallow ANY unconstrained type parameters.\n-            (&ty::GenericParamDefKind::Type(_), hir::GenericParam::Type(hir_ty)) => {\n-                let param_ty = ty::ParamTy::for_def(ty_param);\n+            ty::GenericParamDefKind::Type(_) => {\n+                let param_ty = ty::ParamTy::for_def(param);\n                 if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n-                    report_unused_parameter(tcx, hir_ty.span, \"type\", &param_ty.to_string());\n+                    report_unused_parameter(tcx,\n+                                            tcx.def_span(param.def_id),\n+                                            \"type\",\n+                                            &param_ty.to_string());\n                 }\n             }\n-            (&ty::GenericParamDefKind::Lifetime, hir::GenericParam::Lifetime(hir_lt)) => {\n-                let param = ctp::Parameter::from(ty_param.to_early_bound_region_data());\n-                if lifetimes_in_associated_types.contains(&param) && // (*)\n-                    !input_parameters.contains(&param) {\n-                    report_unused_parameter(tcx, hir_lt.lifetime.span,\n-                                            \"lifetime\", &hir_lt.lifetime.name.name().to_string());\n+            ty::GenericParamDefKind::Lifetime => {\n+                let param_lt = ctp::Parameter::from(param.to_early_bound_region_data());\n+                if lifetimes_in_associated_types.contains(&param_lt) && // (*)\n+                    !input_parameters.contains(&param_lt) {\n+                    report_unused_parameter(tcx,\n+                                            tcx.def_span(param.def_id),\n+                                            \"lifetime\",\n+                                            &param.name.to_string());\n                 }\n             }\n-            (&ty::GenericParamDefKind::Type(_), _) => continue,\n-            (&ty::GenericParamDefKind::Lifetime, _) => continue,\n         }\n     }\n "}]}