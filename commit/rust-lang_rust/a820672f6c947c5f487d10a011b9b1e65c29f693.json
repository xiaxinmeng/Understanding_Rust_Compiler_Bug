{"sha": "a820672f6c947c5f487d10a011b9b1e65c29f693", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MjA2NzJmNmM5NDdjNWY0ODdkMTBhMDExYjliMWU2NWMyOWY2OTM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-26T04:18:37Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-29T19:25:25Z"}, "message": "Avoid the popping loop at the end of `compress()`.\n\nBy collecting the done obligations (when necessary) in the main loop.\nThis makes the code cleaner.\n\nThe commit also changes the order in which successful obligations are\nreturned -- they are now returned in the registered order, rather than\nreversed. Because this order doesn't actually matter, being only used by\ntests, the commit uses `sort()` to make the test agnostic w.r.t. the\norder.", "tree": {"sha": "0587112f8a49a83f6a7473de185e4004358d8158", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0587112f8a49a83f6a7473de185e4004358d8158"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a820672f6c947c5f487d10a011b9b1e65c29f693", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a820672f6c947c5f487d10a011b9b1e65c29f693", "html_url": "https://github.com/rust-lang/rust/commit/a820672f6c947c5f487d10a011b9b1e65c29f693", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a820672f6c947c5f487d10a011b9b1e65c29f693/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2883c258f1a6dd82f6acd174b71d74e04e645f6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2883c258f1a6dd82f6acd174b71d74e04e645f6d", "html_url": "https://github.com/rust-lang/rust/commit/2883c258f1a6dd82f6acd174b71d74e04e645f6d"}], "stats": {"total": 74, "additions": 40, "deletions": 34}, "files": [{"sha": "68e9be5e06575d0d93ff9ef8d0040543931e7e74", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a820672f6c947c5f487d10a011b9b1e65c29f693/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a820672f6c947c5f487d10a011b9b1e65c29f693/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=a820672f6c947c5f487d10a011b9b1e65c29f693", "patch": "@@ -600,10 +600,13 @@ impl<O: ForestObligation> ObligationForest<O> {\n     fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n         let orig_nodes_len = self.nodes.len();\n         let mut node_rewrites: Vec<_> = self.node_rewrites.replace(vec![]);\n+        debug_assert!(node_rewrites.is_empty());\n         node_rewrites.extend(0..orig_nodes_len);\n         let mut dead_nodes = 0;\n+        let mut removed_done_obligations: Vec<O> = vec![];\n \n-        // Now move all popped nodes to the end. Try to keep the order.\n+        // Now move all Done/Error nodes to the end, preserving the order of\n+        // the Pending/Waiting nodes.\n         //\n         // LOOP INVARIANT:\n         //     self.nodes[0..index - dead_nodes] are the first remaining nodes\n@@ -620,7 +623,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 }\n                 NodeState::Done => {\n                     // This lookup can fail because the contents of\n-                    // `self.active_cache` is not guaranteed to match those of\n+                    // `self.active_cache` are not guaranteed to match those of\n                     // `self.nodes`. See the comment in `process_obligation`\n                     // for more details.\n                     if let Some((predicate, _)) =\n@@ -630,6 +633,10 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     } else {\n                         self.done_cache.insert(node.obligation.as_predicate().clone());\n                     }\n+                    if do_completed == DoCompleted::Yes {\n+                        // Extract the success stories.\n+                        removed_done_obligations.push(node.obligation.clone());\n+                    }\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;\n                 }\n@@ -638,43 +645,28 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     // tests must come up with a different type on every type error they\n                     // check against.\n                     self.active_cache.remove(node.obligation.as_predicate());\n+                    self.insert_into_error_cache(index);\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;\n-                    self.insert_into_error_cache(index);\n                 }\n                 NodeState::Success => unreachable!()\n             }\n         }\n \n-        // No compression needed.\n-        if dead_nodes == 0 {\n-            node_rewrites.truncate(0);\n-            self.node_rewrites.replace(node_rewrites);\n-            return if do_completed == DoCompleted::Yes { Some(vec![]) } else { None };\n-        }\n-\n-        // Pop off all the nodes we killed and extract the success stories.\n-        let successful = if do_completed == DoCompleted::Yes {\n-            Some((0..dead_nodes)\n-                .map(|_| self.nodes.pop().unwrap())\n-                .flat_map(|node| {\n-                    match node.state.get() {\n-                        NodeState::Error => None,\n-                        NodeState::Done => Some(node.obligation),\n-                        _ => unreachable!()\n-                    }\n-                })\n-                .collect())\n-        } else {\n+        if dead_nodes > 0 {\n+            // Remove the dead nodes and rewrite indices.\n             self.nodes.truncate(orig_nodes_len - dead_nodes);\n-            None\n-        };\n-        self.apply_rewrites(&node_rewrites);\n+            self.apply_rewrites(&node_rewrites);\n+        }\n \n         node_rewrites.truncate(0);\n         self.node_rewrites.replace(node_rewrites);\n \n-        successful\n+        if do_completed == DoCompleted::Yes {\n+            Some(removed_done_obligations)\n+        } else {\n+            None\n+        }\n     }\n \n     fn apply_rewrites(&mut self, node_rewrites: &[usize]) {"}, {"sha": "54b6f6d0adc6cd2a1b01400263e075faeef6347a", "filename": "src/librustc_data_structures/obligation_forest/tests.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a820672f6c947c5f487d10a011b9b1e65c29f693/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a820672f6c947c5f487d10a011b9b1e65c29f693/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs?ref=a820672f6c947c5f487d10a011b9b1e65c29f693", "patch": "@@ -116,7 +116,9 @@ fn push_pop() {\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"A.3\", \"A.1\", \"A.3.i\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"A.1\", \"A.3\", \"A.3.i\"]);\n     assert_eq!(err,\n                vec![Error {\n                         error: \"A is for apple\",\n@@ -132,7 +134,9 @@ fn push_pop() {\n                 _ => panic!(\"unexpected obligation {:?}\", obligation),\n             }\n         }, |_| {}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"D.2.i\", \"D.2\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"D.2\", \"D.2.i\"]);\n     assert_eq!(err,\n                vec![Error {\n                         error: \"D is for dumb\",\n@@ -172,7 +176,9 @@ fn success_in_grandchildren() {\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"A.3\", \"A.1\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"A.1\", \"A.3\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -193,7 +199,9 @@ fn success_in_grandchildren() {\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"A.2.i.a\", \"A.2.i\", \"A.2\", \"A\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"A\", \"A.2\", \"A.2.i\", \"A.2.i.a\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -261,7 +269,9 @@ fn diamond() {\n             }\n         }, |_|{}), DoCompleted::Yes);\n     assert_eq!(d_count, 1);\n-    assert_eq!(ok.unwrap(), vec![\"D\", \"A.2\", \"A.1\", \"A\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"A\", \"A.1\", \"A.2\", \"D\"]);\n     assert_eq!(err.len(), 0);\n \n     let errors = forest.to_errors(());\n@@ -323,7 +333,9 @@ fn done_dependency() {\n                 _ => unreachable!(),\n             }\n         }, |_|{}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"C: Sized\", \"B: Sized\", \"A: Sized\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"A: Sized\", \"B: Sized\", \"C: Sized\"]);\n     assert_eq!(err.len(), 0);\n \n     forest.register_obligation(\"(A,B,C): Sized\");\n@@ -361,7 +373,9 @@ fn orphan() {\n                 _ => unreachable!(),\n             }\n         }, |_|{}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"C2\", \"C1\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"C1\", \"C2\"]);\n     assert_eq!(err.len(), 0);\n \n     let Outcome { completed: ok, errors: err, .. } ="}]}