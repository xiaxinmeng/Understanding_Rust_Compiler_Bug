{"sha": "b0941165384364d637c5d99698c9663e9cab8152", "node_id": "C_kwDOAAsO6NoAKGIwOTQxMTY1Mzg0MzY0ZDYzN2M1ZDk5Njk4Yzk2NjNlOWNhYjgxNTI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-27T02:49:38Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-27T02:49:40Z"}, "message": "interpret: refactor allocation info query\n\nWe now have an infallible function that also tells us which kind of allocation we are talking about.\nAlso we do longer have to distinguish between data and function allocations for liveness.", "tree": {"sha": "3374b829bfd238124ae1db89c17877950584e5f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3374b829bfd238124ae1db89c17877950584e5f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0941165384364d637c5d99698c9663e9cab8152", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0941165384364d637c5d99698c9663e9cab8152", "html_url": "https://github.com/rust-lang/rust/commit/b0941165384364d637c5d99698c9663e9cab8152", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0941165384364d637c5d99698c9663e9cab8152/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "url": "https://api.github.com/repos/rust-lang/rust/commits/1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "html_url": "https://github.com/rust-lang/rust/commit/1aabd8a4a6e1871f14e804302bd60dfcbffd5761"}], "stats": {"total": 85, "additions": 34, "deletions": 51}, "files": [{"sha": "d5e68dbd5b7a9d43d5da0686ea6ec1a839df95a9", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 33, "deletions": 50, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b0941165384364d637c5d99698c9663e9cab8152/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0941165384364d637c5d99698c9663e9cab8152/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=b0941165384364d637c5d99698c9663e9cab8152", "patch": "@@ -56,15 +56,14 @@ impl<T: fmt::Display> fmt::Display for MemoryKind<T> {\n     }\n }\n \n-/// Used by `get_size_and_align` to indicate whether the allocation needs to be live.\n-#[derive(Debug, Copy, Clone)]\n-pub enum AllocCheck {\n-    /// Allocation must be live and not a function pointer.\n-    Dereferenceable,\n-    /// Allocations needs to be live, but may be a function pointer.\n-    Live,\n-    /// Allocation may be dead.\n-    MaybeDead,\n+/// The return value of `get_alloc_info` indicates the \"kind\" of the allocation.\n+pub enum AllocKind {\n+    /// A regular live data allocation.\n+    LiveData,\n+    /// A function allocation (that fn ptrs point to).\n+    Function,\n+    /// A dead allocation.\n+    Dead,\n }\n \n /// The value of a function pointer.\n@@ -360,8 +359,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n             |alloc_id, offset, tag| {\n-                let (size, align) =\n-                    self.get_alloc_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n+                let (size, align) = self.get_live_alloc_size_and_align(alloc_id)?;\n                 Ok((size, align, (alloc_id, offset, tag)))\n             },\n         )\n@@ -379,15 +377,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx> {\n         self.check_and_deref_ptr(ptr, size, Some(align), msg, |alloc_id, _, _| {\n-            let check = match msg {\n-                CheckInAllocMsg::DerefTest | CheckInAllocMsg::MemoryAccessTest => {\n-                    AllocCheck::Dereferenceable\n-                }\n-                CheckInAllocMsg::PointerArithmeticTest\n-                | CheckInAllocMsg::OffsetFromTest\n-                | CheckInAllocMsg::InboundsTest => AllocCheck::Live,\n-            };\n-            let (size, align) = self.get_alloc_size_and_align(alloc_id, check)?;\n+            let (size, align) = self.get_live_alloc_size_and_align(alloc_id)?;\n             Ok((size, align, ()))\n         })?;\n         Ok(())\n@@ -655,30 +645,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Obtain the size and alignment of an allocation, even if that allocation has\n     /// been deallocated.\n-    ///\n-    /// If `liveness` is `AllocCheck::MaybeDead`, this function always returns `Ok`.\n-    pub fn get_alloc_size_and_align(\n-        &self,\n-        id: AllocId,\n-        liveness: AllocCheck,\n-    ) -> InterpResult<'tcx, (Size, Align)> {\n+    pub fn get_alloc_info(&self, id: AllocId) -> (Size, Align, AllocKind) {\n         // # Regular allocations\n         // Don't use `self.get_raw` here as that will\n         // a) cause cycles in case `id` refers to a static\n         // b) duplicate a global's allocation in miri\n         if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n-            return Ok((alloc.size(), alloc.align));\n+            return (alloc.size(), alloc.align, AllocKind::LiveData);\n         }\n \n         // # Function pointers\n         // (both global from `alloc_map` and local from `extra_fn_ptr_map`)\n         if self.get_fn_alloc(id).is_some() {\n-            return if let AllocCheck::Dereferenceable = liveness {\n-                // The caller requested no function pointers.\n-                throw_ub!(DerefFunctionPointer(id))\n-            } else {\n-                Ok((Size::ZERO, Align::ONE))\n-            };\n+            return (Size::ZERO, Align::ONE, AllocKind::Function);\n         }\n \n         // # Statics\n@@ -690,32 +669,38 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Use size and align of the type.\n                 let ty = self.tcx.type_of(did);\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                Ok((layout.size, layout.align.abi))\n+                (layout.size, layout.align.abi, AllocKind::LiveData)\n             }\n             Some(GlobalAlloc::Memory(alloc)) => {\n                 // Need to duplicate the logic here, because the global allocations have\n                 // different associated types than the interpreter-local ones.\n                 let alloc = alloc.inner();\n-                Ok((alloc.size(), alloc.align))\n+                (alloc.size(), alloc.align, AllocKind::LiveData)\n             }\n             Some(GlobalAlloc::Function(_)) => bug!(\"We already checked function pointers above\"),\n             // The rest must be dead.\n             None => {\n-                if let AllocCheck::MaybeDead = liveness {\n-                    // Deallocated pointers are allowed, we should be able to find\n-                    // them in the map.\n-                    Ok(*self\n-                        .memory\n-                        .dead_alloc_map\n-                        .get(&id)\n-                        .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n-                } else {\n-                    throw_ub!(PointerUseAfterFree(id))\n-                }\n+                // Deallocated pointers are allowed, we should be able to find\n+                // them in the map.\n+                let (size, align) = *self\n+                    .memory\n+                    .dead_alloc_map\n+                    .get(&id)\n+                    .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\");\n+                (size, align, AllocKind::Dead)\n             }\n         }\n     }\n \n+    /// Obtain the size and alignment of a live allocation.\n+    pub fn get_live_alloc_size_and_align(&self, id: AllocId) -> InterpResult<'tcx, (Size, Align)> {\n+        let (size, align, kind) = self.get_alloc_info(id);\n+        if matches!(kind, AllocKind::Dead) {\n+            throw_ub!(PointerUseAfterFree(id))\n+        }\n+        Ok((size, align))\n+    }\n+\n     fn get_fn_alloc(&self, id: AllocId) -> Option<FnVal<'tcx, M::ExtraFnVal>> {\n         if let Some(extra) = self.memory.extra_fn_ptr_map.get(&id) {\n             Some(FnVal::Other(*extra))\n@@ -1187,9 +1172,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let ptr = self.scalar_to_ptr(scalar)?;\n                 match self.ptr_try_get_alloc_id(ptr) {\n                     Ok((alloc_id, offset, _)) => {\n-                        let (size, _align) = self\n-                            .get_alloc_size_and_align(alloc_id, AllocCheck::MaybeDead)\n-                            .expect(\"alloc info with MaybeDead cannot fail\");\n+                        let (size, _align, _kind) = self.get_alloc_info(alloc_id);\n                         // If the pointer is out-of-bounds, it may be null.\n                         // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n                         offset > size"}, {"sha": "9d78a2e48430c9507f6c61a617a9b6c4a65ba393", "filename": "compiler/rustc_const_eval/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0941165384364d637c5d99698c9663e9cab8152/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0941165384364d637c5d99698c9663e9cab8152/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs?ref=b0941165384364d637c5d99698c9663e9cab8152", "patch": "@@ -23,7 +23,7 @@ pub use self::eval_context::{\n };\n pub use self::intern::{intern_const_alloc_recursive, InternKind};\n pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackPopJump};\n-pub use self::memory::{AllocCheck, AllocRef, AllocRefMut, FnVal, Memory, MemoryKind};\n+pub use self::memory::{AllocRef, AllocRefMut, FnVal, Memory, MemoryKind};\n pub use self::operand::{ImmTy, Immediate, OpTy, Operand};\n pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n pub use self::validity::{CtfeValidationMode, RefTracking};"}]}