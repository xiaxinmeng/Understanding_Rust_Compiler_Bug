{"sha": "b47fcb8375921f6bc198fe38a397a79609933e8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0N2ZjYjgzNzU5MjFmNmJjMTk4ZmUzOGEzOTdhNzk2MDk5MzNlOGU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-18T17:49:45Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T15:51:58Z"}, "message": "trans: Use fmt::Debug for debugging instead of ad-hoc methods.", "tree": {"sha": "4d375c72f9824076ef04ae3a375ef3f3ffd52024", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d375c72f9824076ef04ae3a375ef3f3ffd52024"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b47fcb8375921f6bc198fe38a397a79609933e8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b47fcb8375921f6bc198fe38a397a79609933e8e", "html_url": "https://github.com/rust-lang/rust/commit/b47fcb8375921f6bc198fe38a397a79609933e8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b47fcb8375921f6bc198fe38a397a79609933e8e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abb1515c53d209be3e8c1e9e73c1a98bc86b8692", "url": "https://api.github.com/repos/rust-lang/rust/commits/abb1515c53d209be3e8c1e9e73c1a98bc86b8692", "html_url": "https://github.com/rust-lang/rust/commit/abb1515c53d209be3e8c1e9e73c1a98bc86b8692"}], "stats": {"total": 672, "additions": 280, "deletions": 392}, "files": [{"sha": "e216dcd1c9746c15ebe323ecdf6c23f7b31a6394", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -133,6 +133,7 @@ pub enum DLLStorageClassTypes {\n }\n \n bitflags! {\n+    #[derive(Debug)]\n     flags Attribute : u64 {\n         const ZExt            = 1 << 0,\n         const SExt            = 1 << 1,"}, {"sha": "e277a53502863cb7be1d081b57dc3d53fba1eb4c", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -216,6 +216,7 @@ use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n use trans::Disr;\n+use trans::value::Value;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::traits::ProjectionMode;\n use session::config::NoDebugInfo;\n@@ -448,6 +449,12 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n     }\n }\n \n+impl fmt::Debug for MatchInput {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&Value(self.val), f)\n+    }\n+}\n+\n impl MatchInput {\n     fn from_val(val: ValueRef) -> MatchInput {\n         MatchInput {\n@@ -466,11 +473,8 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               col: usize,\n                                               val: MatchInput)\n                                               -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"expand_nested_bindings(bcx={}, m={:?}, col={}, val={})\",\n-           bcx.to_str(),\n-           m,\n-           col,\n-           bcx.val_to_string(val.val));\n+    debug!(\"expand_nested_bindings(bcx={}, m={:?}, col={}, val={:?})\",\n+           bcx.to_str(), m, col, val);\n     let _indenter = indenter();\n \n     m.iter().map(|br| {\n@@ -506,11 +510,8 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                           -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n     F: FnMut(&[&'p hir::Pat]) -> Option<Vec<&'p hir::Pat>>,\n {\n-    debug!(\"enter_match(bcx={}, m={:?}, col={}, val={})\",\n-           bcx.to_str(),\n-           m,\n-           col,\n-           bcx.val_to_string(val.val));\n+    debug!(\"enter_match(bcx={}, m={:?}, col={}, val={:?})\",\n+           bcx.to_str(), m, col, val);\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n@@ -549,11 +550,8 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      col: usize,\n                                      val: MatchInput)\n                                      -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_default(bcx={}, m={:?}, col={}, val={})\",\n-           bcx.to_str(),\n-           m,\n-           col,\n-           bcx.val_to_string(val.val));\n+    debug!(\"enter_default(bcx={}, m={:?}, col={}, val={:?})\",\n+           bcx.to_str(), m, col, val);\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n@@ -606,12 +604,8 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              variant_size: usize,\n              val: MatchInput)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_opt(bcx={}, m={:?}, opt={:?}, col={}, val={})\",\n-           bcx.to_str(),\n-           m,\n-           *opt,\n-           col,\n-           bcx.val_to_string(val.val));\n+    debug!(\"enter_opt(bcx={}, m={:?}, opt={:?}, col={}, val={:?})\",\n+           bcx.to_str(), m, *opt, col, val);\n     let _indenter = indenter();\n \n     let ctor = match opt {\n@@ -1032,7 +1026,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             bcx.fcx.schedule_drop_and_fill_mem(cs, llval, binding_info.ty, opt_datum);\n         }\n \n-        debug!(\"binding {} to {}\", binding_info.id, bcx.val_to_string(llval));\n+        debug!(\"binding {} to {:?}\", binding_info.id, Value(llval));\n         bcx.fcx.lllocals.borrow_mut().insert(binding_info.id, datum);\n         debuginfo::create_match_binding_metadata(bcx, name, binding_info);\n     }\n@@ -1047,11 +1041,8 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      chk: &FailureHandler,\n                                      has_genuine_default: bool)\n                                      -> Block<'blk, 'tcx> {\n-    debug!(\"compile_guard(bcx={}, guard_expr={:?}, m={:?}, vals=[{}])\",\n-           bcx.to_str(),\n-           guard_expr,\n-           m,\n-           vals.iter().map(|v| bcx.val_to_string(v.val)).collect::<Vec<_>>().join(\", \"));\n+    debug!(\"compile_guard(bcx={}, guard_expr={:?}, m={:?}, vals={:?})\",\n+           bcx.to_str(), guard_expr, m, vals);\n     let _indenter = indenter();\n \n     let mut bcx = insert_lllocals(bcx, &data.bindings_map, None);\n@@ -1093,10 +1084,8 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         vals: &[MatchInput],\n                                         chk: &FailureHandler,\n                                         has_genuine_default: bool) {\n-    debug!(\"compile_submatch(bcx={}, m={:?}, vals=[{}])\",\n-           bcx.to_str(),\n-           m,\n-           vals.iter().map(|v| bcx.val_to_string(v.val)).collect::<Vec<_>>().join(\", \"));\n+    debug!(\"compile_submatch(bcx={}, m={:?}, vals=[{:?}])\",\n+           bcx.to_str(), m, vals);\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n@@ -1256,7 +1245,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     debug!(\"options={:?}\", opts);\n     let mut kind = NoBranch;\n     let mut test_val = val.val;\n-    debug!(\"test_val={}\", bcx.val_to_string(test_val));\n+    debug!(\"test_val={:?}\", Value(test_val));\n     if !opts.is_empty() {\n         match opts[0] {\n             ConstantValue(..) | ConstantRange(..) => {\n@@ -1761,8 +1750,8 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let lvalue = Lvalue::new_with_hint(caller_name, bcx, p_id, HintKind::DontZeroJustUse);\n     let datum = Datum::new(llval, var_ty, lvalue);\n \n-    debug!(\"mk_binding_alloca cleanup_scope={:?} llval={} var_ty={:?}\",\n-           cleanup_scope, bcx.ccx().tn().val_to_string(llval), var_ty);\n+    debug!(\"mk_binding_alloca cleanup_scope={:?} llval={:?} var_ty={:?}\",\n+           cleanup_scope, Value(llval), var_ty);\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1794,10 +1783,8 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     val: MatchInput,\n                                     cleanup_scope: cleanup::ScopeId)\n                                     -> Block<'blk, 'tcx> {\n-    debug!(\"bind_irrefutable_pat(bcx={}, pat={:?}, val={})\",\n-           bcx.to_str(),\n-           pat,\n-           bcx.val_to_string(val.val));\n+    debug!(\"bind_irrefutable_pat(bcx={}, pat={:?}, val={:?})\",\n+           bcx.to_str(), pat, val);\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={:?})\",\n@@ -1923,7 +1910,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // a regular one\n                 if !type_is_sized(tcx, fty) {\n                     let scratch = alloc_ty(bcx, fty, \"__struct_field_fat_ptr\");\n-                    debug!(\"Creating fat pointer {}\", bcx.val_to_string(scratch));\n+                    debug!(\"Creating fat pointer {:?}\", Value(scratch));\n                     Store(bcx, fldptr, expr::get_dataptr(bcx, scratch));\n                     Store(bcx, val.meta, expr::get_meta(bcx, scratch));\n                     fldptr = scratch;"}, {"sha": "c6c19a2a6c7b25fb262ed3ddd870c40807d058c2", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -67,6 +67,7 @@ use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n+use trans::value::Value;\n \n type Hint = attr::ReprAttr;\n \n@@ -88,11 +89,6 @@ impl TypeContext {\n     fn may_need_drop_flag(t: Type, needs_drop_flag: bool) -> TypeContext {\n         TypeContext { prefix: t, needs_drop_flag: needs_drop_flag }\n     }\n-    pub fn to_string(self) -> String {\n-        let TypeContext { prefix, needs_drop_flag } = self;\n-        format!(\"TypeContext {{ prefix: {}, needs_drop_flag: {} }}\",\n-                prefix.to_string(), needs_drop_flag)\n-    }\n }\n \n /// Representations.\n@@ -1139,9 +1135,8 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n \n     // There's no metadata available, log the case and just do the GEP.\n     if !val.has_meta() {\n-        debug!(\"Unsized field `{}`, of `{}` has no metadata for adjustment\",\n-               ix,\n-               bcx.val_to_string(ptr_val));\n+        debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n+               ix, Value(ptr_val));\n         return StructGEP(bcx, ptr_val, ix);\n     }\n \n@@ -1189,16 +1184,15 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n                      Neg(bcx, align, dbloc),\n                      dbloc);\n \n-    debug!(\"struct_field_ptr: DST field offset: {}\",\n-           bcx.val_to_string(offset));\n+    debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n     // Cast and adjust pointer\n     let byte_ptr = PointerCast(bcx, ptr_val, Type::i8p(bcx.ccx()));\n     let byte_ptr = GEP(bcx, byte_ptr, &[offset]);\n \n     // Finally, cast back to the type expected\n     let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n-    debug!(\"struct_field_ptr: Field type is {}\", ll_fty.to_string());\n+    debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n     PointerCast(bcx, byte_ptr, ll_fty.ptr_to())\n }\n \n@@ -1442,7 +1436,7 @@ fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.\n-pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef) -> Disr {\n+pub fn const_get_discrim(r: &Repr, val: ValueRef) -> Disr {\n     match *r {\n         CEnum(ity, _, _) => {\n             match ity {\n@@ -1452,13 +1446,13 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef) -> Disr {\n         }\n         General(ity, _, _) => {\n             match ity {\n-                attr::SignedInt(..) => Disr(const_to_int(const_get_elt(ccx, val, &[0])) as u64),\n-                attr::UnsignedInt(..) => Disr(const_to_uint(const_get_elt(ccx, val, &[0])))\n+                attr::SignedInt(..) => Disr(const_to_int(const_get_elt(val, &[0])) as u64),\n+                attr::UnsignedInt(..) => Disr(const_to_uint(const_get_elt(val, &[0])))\n             }\n         }\n         Univariant(..) => Disr(0),\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n-            ccx.sess().bug(\"const discrim access of non c-like enum\")\n+            unreachable!(\"const discrim access of non c-like enum\")\n         }\n     }\n }\n@@ -1472,25 +1466,25 @@ pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: usize) -> ValueRef {\n     match *r {\n         CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n-        Univariant(..) => const_struct_field(ccx, val, ix),\n-        General(..) => const_struct_field(ccx, val, ix + 1),\n+        Univariant(..) => const_struct_field(val, ix),\n+        General(..) => const_struct_field(val, ix + 1),\n         RawNullablePointer { .. } => {\n             assert_eq!(ix, 0);\n             val\n         },\n-        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix)\n+        StructWrappedNullablePointer{ .. } => const_struct_field(val, ix)\n     }\n }\n \n /// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: usize) -> ValueRef {\n+fn const_struct_field(val: ValueRef, ix: usize) -> ValueRef {\n     // Get the ix-th non-undef element of the struct.\n     let mut real_ix = 0; // actual position in the struct\n     let mut ix = ix; // logical index relative to real_ix\n     let mut field;\n     loop {\n         loop {\n-            field = const_get_elt(ccx, val, &[real_ix]);\n+            field = const_get_elt(val, &[real_ix]);\n             if !is_undef(field) {\n                 break;\n             }"}, {"sha": "03f3671a6b1b295efd6f27ba988c393f59377b33", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -948,9 +948,9 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     if need_invoke(bcx) {\n-        debug!(\"invoking {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n+        debug!(\"invoking {:?} at {:?}\", Value(llfn), bcx.llbb);\n         for &llarg in llargs {\n-            debug!(\"arg: {}\", bcx.val_to_string(llarg));\n+            debug!(\"arg: {:?}\", Value(llarg));\n         }\n         let normal_bcx = bcx.fcx.new_temp_block(\"normal-return\");\n         let landing_pad = bcx.fcx.get_landing_pad();\n@@ -964,9 +964,9 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               debug_loc);\n         return (llresult, normal_bcx);\n     } else {\n-        debug!(\"calling {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n+        debug!(\"calling {:?} at {:?}\", Value(llfn), bcx.llbb);\n         for &llarg in llargs {\n-            debug!(\"arg: {}\", bcx.val_to_string(llarg));\n+            debug!(\"arg: {:?}\", Value(llarg));\n         }\n \n         let llresult = Call(bcx, llfn, &llargs[..], Some(attributes), debug_loc);\n@@ -1058,10 +1058,7 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n         return;\n     }\n \n-    debug!(\"store_ty: {} : {:?} <- {}\",\n-           cx.val_to_string(dst),\n-           t,\n-           cx.val_to_string(v));\n+    debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n     if common::type_is_fat_ptr(cx.tcx(), t) {\n         Store(cx,\n@@ -2030,8 +2027,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"trans_closure: monomorphized_arg_type: {:?}\",\n                monomorphized_arg_type);\n     }\n-    debug!(\"trans_closure: function lltype: {}\",\n-           bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n+    debug!(\"trans_closure: function lltype: {:?}\", Value(bcx.fcx.llfn));\n \n     let has_tupled_arg = match closure_env {\n         closure::ClosureEnv::NotClosure => abi == Abi::RustCall,"}, {"sha": "2289cdcc8a371314fb1a0e81e198ce788f5f5ce9", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -20,6 +20,7 @@ use syntax::codemap::Span;\n \n use trans::builder::Builder;\n use trans::type_::Type;\n+use trans::value::Value;\n use trans::debuginfo::DebugLoc;\n \n use libc::{c_uint, c_char};\n@@ -146,9 +147,11 @@ pub fn Invoke(cx: Block,\n     }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n-    debug!(\"Invoke({} with arguments ({}))\",\n-           cx.val_to_string(fn_),\n-           args.iter().map(|a| cx.val_to_string(*a)).collect::<Vec<String>>().join(\", \"));\n+    debug!(\"Invoke({:?} with arguments ({}))\",\n+           Value(fn_),\n+           args.iter().map(|a| {\n+                format!(\"{:?}\", Value(*a))\n+           }).collect::<Vec<String>>().join(\", \"));\n     debug_loc.apply(cx.fcx);\n     let bundle = cx.lpad().and_then(|b| b.bundle());\n     B(cx).invoke(fn_, args, then, catch, bundle, attributes)"}, {"sha": "fad797f14edf01f2072c2a00e5748870e222e731", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -18,6 +18,7 @@ use trans::base;\n use trans::common::*;\n use trans::machine::llalign_of_pref;\n use trans::type_::Type;\n+use trans::value::Value;\n use util::nodemap::FnvHashMap;\n use libc::{c_uint, c_char};\n \n@@ -169,10 +170,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                   -> ValueRef {\n         self.count_insn(\"invoke\");\n \n-        debug!(\"Invoke {} with args ({})\",\n-               self.ccx.tn().val_to_string(llfn),\n+        debug!(\"Invoke {:?} with args ({})\",\n+               Value(llfn),\n                args.iter()\n-                   .map(|&v| self.ccx.tn().val_to_string(v))\n+                   .map(|&v| format!(\"{:?}\", Value(v)))\n                    .collect::<Vec<String>>()\n                    .join(\", \"));\n \n@@ -497,9 +498,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n-        debug!(\"Store {} -> {}\",\n-               self.ccx.tn().val_to_string(val),\n-               self.ccx.tn().val_to_string(ptr));\n+        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         unsafe {\n@@ -508,9 +507,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn volatile_store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n-        debug!(\"Store {} -> {}\",\n-               self.ccx.tn().val_to_string(val),\n-               self.ccx.tn().val_to_string(ptr));\n+        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store.volatile\");\n         unsafe {\n@@ -521,9 +518,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n-        debug!(\"Store {} -> {}\",\n-               self.ccx.tn().val_to_string(val),\n-               self.ccx.tn().val_to_string(ptr));\n+        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         self.count_insn(\"store.atomic\");\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n@@ -796,11 +791,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                          else          { llvm::False };\n \n         let argtys = inputs.iter().map(|v| {\n-            debug!(\"Asm Input Type: {}\", self.ccx.tn().val_to_string(*v));\n+            debug!(\"Asm Input Type: {:?}\", Value(*v));\n             val_ty(*v)\n         }).collect::<Vec<_>>();\n \n-        debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n+        debug!(\"Asm Output Type: {:?}\", output);\n         let fty = Type::func(&argtys[..], &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n@@ -814,10 +809,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 attributes: Option<AttrBuilder>) -> ValueRef {\n         self.count_insn(\"call\");\n \n-        debug!(\"Call {} with args ({})\",\n-               self.ccx.tn().val_to_string(llfn),\n+        debug!(\"Call {:?} with args ({})\",\n+               Value(llfn),\n                args.iter()\n-                   .map(|&v| self.ccx.tn().val_to_string(v))\n+                   .map(|&v| format!(\"{:?}\", Value(v)))\n                    .collect::<Vec<String>>()\n                    .join(\", \"));\n \n@@ -838,11 +833,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if expected_ty != actual_ty {\n                 self.ccx.sess().bug(\n                     &format!(\n-                        \"Type mismatch in function call of {}.  Expected {} for param {}, got {}\",\n-                        self.ccx.tn().val_to_string(llfn),\n-                        self.ccx.tn().type_to_string(expected_ty),\n-                        i,\n-                        self.ccx.tn().type_to_string(actual_ty)));\n+                        \"Type mismatch in function call of {:?}. \\\n+                         Expected {:?} for param {}, got {:?}\",\n+                        Value(llfn),\n+                        expected_ty, i, actual_ty));\n \n             }\n         }"}, {"sha": "b2275171687fa6069546257f358605a992a8c9f3", "filename": "src/librustc_trans/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -24,7 +24,7 @@ use trans::cabi_mips;\n use trans::cabi_asmjs;\n use trans::type_::Type;\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n pub enum ArgKind {\n     /// Pass the argument directly using the normal converted\n     /// LLVM type or by coercing to another specified type\n@@ -39,7 +39,7 @@ pub enum ArgKind {\n /// should be passed to or returned from a function\n ///\n /// This is borrowed from clang's ABIInfo.h\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n pub struct ArgType {\n     pub kind: ArgKind,\n     /// Original LLVM type"}, {"sha": "7e0e01c3150624b11bed58c2823275e80ff29240", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -47,6 +47,7 @@ use trans::meth;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n+use trans::value::Value;\n use trans::Disr;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_front::hir;\n@@ -615,8 +616,8 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 let llret_ty = common::val_ty(llretslot);\n                 if llformal_ret_ty != llret_ty {\n                     // this could happen due to e.g. subtyping\n-                    debug!(\"casting actual return type ({}) to match formal ({})\",\n-                        bcx.llty_str(llret_ty), bcx.llty_str(llformal_ret_ty));\n+                    debug!(\"casting actual return type ({:?}) to match formal ({:?})\",\n+                        llret_ty, llformal_ret_ty);\n                     llretslot = PointerCast(bcx, llretslot, llformal_ret_ty);\n                 }\n                 llargs.push(llretslot);\n@@ -926,12 +927,11 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_datum({:?})\",\n-           formal_arg_ty);\n+    debug!(\"trans_arg_datum({:?})\", formal_arg_ty);\n \n     let arg_datum_ty = arg_datum.ty;\n \n-    debug!(\"   arg datum: {}\", arg_datum.to_string(bcx.ccx()));\n+    debug!(\"   arg datum: {:?}\", arg_datum);\n \n     let mut val = if common::type_is_fat_ptr(bcx.tcx(), arg_datum_ty) &&\n                      !bcx.fcx.type_needs_drop(arg_datum_ty) {\n@@ -956,14 +956,14 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     if type_of::arg_is_indirect(ccx, formal_arg_ty) && formal_arg_ty != arg_datum_ty {\n         // this could happen due to e.g. subtyping\n         let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n-        debug!(\"casting actual type ({}) to match formal ({})\",\n-               bcx.val_to_string(val), bcx.llty_str(llformal_arg_ty));\n+        debug!(\"casting actual type ({:?}) to match formal ({:?})\",\n+               Value(val), llformal_arg_ty);\n         debug!(\"Rust types: {:?}; {:?}\", arg_datum_ty,\n                                      formal_arg_ty);\n         val = PointerCast(bcx, val, llformal_arg_ty);\n     }\n \n-    debug!(\"--- trans_arg_datum passing {}\", bcx.val_to_string(val));\n+    debug!(\"--- trans_arg_datum passing {:?}\", Value(val));\n \n     if common::type_is_fat_ptr(bcx.tcx(), formal_arg_ty) {\n         llargs.push(Load(bcx, expr::get_dataptr(bcx, val)));"}, {"sha": "89a126e79321be2ab76c15d574b3b5e77c677dcd", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -129,7 +129,9 @@ use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::glue;\n use middle::region;\n use trans::type_::Type;\n+use trans::value::Value;\n use middle::ty::{Ty, TyCtxt};\n+\n use std::fmt;\n use syntax::ast;\n \n@@ -401,9 +403,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             ptr: val,\n         };\n \n-        debug!(\"schedule_lifetime_end({:?}, val={})\",\n-               cleanup_scope,\n-               self.ccx.tn().val_to_string(val));\n+        debug!(\"schedule_lifetime_end({:?}, val={:?})\",\n+               cleanup_scope, Value(val));\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -426,9 +427,9 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             drop_hint: drop_hint,\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_mem({:?}, val={:?}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n-               self.ccx.tn().val_to_string(val),\n+               Value(val),\n                ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n@@ -454,10 +455,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             drop_hint: drop_hint,\n         };\n \n-        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={:?},\n+        debug!(\"schedule_drop_and_fill_mem({:?}, val={:?}, ty={:?},\n                 fill_on_drop={}, skip_dtor={}, has_drop_hint={})\",\n                cleanup_scope,\n-               self.ccx.tn().val_to_string(val),\n+               Value(val),\n                ty,\n                drop.fill_on_drop,\n                drop.skip_dtor,\n@@ -488,9 +489,9 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             drop_hint: None,\n         };\n \n-        debug!(\"schedule_drop_adt_contents({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_adt_contents({:?}, val={:?}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n-               self.ccx.tn().val_to_string(val),\n+               Value(val),\n                ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n@@ -514,9 +515,9 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             drop_hint: None,\n         });\n \n-        debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_immediate({:?}, val={:?}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n-               self.ccx.tn().val_to_string(val),\n+               Value(val),\n                ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n@@ -532,10 +533,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                            content_ty: Ty<'tcx>) {\n         let drop = box FreeValue { ptr: val, heap: heap, content_ty: content_ty };\n \n-        debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n-               cleanup_scope,\n-               self.ccx.tn().val_to_string(val),\n-               heap);\n+        debug!(\"schedule_free_value({:?}, val={:?}, heap={:?})\",\n+               cleanup_scope, Value(val), heap);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }"}, {"sha": "0eb4def89e846d520204ec53cc761df9d0f35e88", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -27,6 +27,7 @@ use trans::declare;\n use trans::expr;\n use trans::monomorphize::{MonoId};\n use trans::type_of::*;\n+use trans::value::Value;\n use trans::Disr;\n use middle::ty;\n use session::config::FullDebugInfo;\n@@ -146,7 +147,7 @@ pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     if let Some(&llfn) = ccx.closure_vals().borrow().get(&mono_id) {\n         debug!(\"get_or_create_closure_declaration(): found closure {:?}: {:?}\",\n-               mono_id, ccx.tn().val_to_string(llfn));\n+               mono_id, Value(llfn));\n         return llfn;\n     }\n \n@@ -160,10 +161,8 @@ pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     attributes::inline(llfn, attributes::InlineAttr::Hint);\n \n     debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n-            closure {:?} (type {}): {:?}\",\n-           mono_id,\n-           ccx.tn().type_to_string(val_ty(llfn)),\n-           ccx.tn().val_to_string(llfn));\n+            closure {:?}: {:?}\",\n+           mono_id, Value(llfn));\n     ccx.closure_vals().borrow_mut().insert(mono_id, llfn);\n \n     llfn\n@@ -278,11 +277,8 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let tcx = ccx.tcx();\n \n     debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n-           trait_closure_kind={:?}, \\\n-           llfn={})\",\n-           llfn_closure_kind,\n-           trait_closure_kind,\n-           ccx.tn().val_to_string(llfn));\n+           trait_closure_kind={:?}, llfn={:?})\",\n+           llfn_closure_kind, trait_closure_kind, Value(llfn));\n \n     match (llfn_closure_kind, trait_closure_kind) {\n         (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n@@ -324,10 +320,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     llreffn: ValueRef)\n     -> ValueRef\n {\n-    debug!(\"trans_fn_once_adapter_shim(closure_def_id={:?}, substs={:?}, llreffn={})\",\n-           closure_def_id,\n-           substs,\n-           ccx.tn().val_to_string(llreffn));\n+    debug!(\"trans_fn_once_adapter_shim(closure_def_id={:?}, substs={:?}, llreffn={:?})\",\n+           closure_def_id, substs, Value(llreffn));\n \n     let tcx = ccx.tcx();\n     let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables, ProjectionMode::Any);\n@@ -391,8 +385,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n                                   env_datum.to_lvalue_datum_in_scope(bcx, \"self\",\n                                                                      self_scope_id));\n \n-    debug!(\"trans_fn_once_adapter_shim: env_datum={}\",\n-           bcx.val_to_string(env_datum.val));\n+    debug!(\"trans_fn_once_adapter_shim: env_datum={:?}\",\n+           Value(env_datum.val));\n     llargs[self_idx] = env_datum.val;\n \n     let dest ="}, {"sha": "ec24242a0101bf853d3e1a40e0ff7dcbeb3947e3", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -37,6 +37,7 @@ use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n+use trans::value::Value;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::traits::{self, SelectionContext, ProjectionMode};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n@@ -652,14 +653,6 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         }\n     }\n \n-    pub fn val_to_string(&self, val: ValueRef) -> String {\n-        self.ccx().tn().val_to_string(val)\n-    }\n-\n-    pub fn llty_str(&self, ty: Type) -> String {\n-        self.ccx().tn().type_to_string(ty)\n-    }\n-\n     pub fn to_str(&self) -> String {\n         format!(\"[block {:p}]\", self)\n     }\n@@ -767,10 +760,6 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n         self.bcx.mir()\n     }\n \n-    pub fn val_to_string(&self, val: ValueRef) -> String {\n-        self.bcx.val_to_string(val)\n-    }\n-\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n@@ -1028,15 +1017,15 @@ pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n+pub fn const_get_elt(v: ValueRef, us: &[c_uint])\n               -> ValueRef {\n     unsafe {\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n-        debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n-               cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n+        debug!(\"const_get_elt(v={:?}, us={:?}, r={:?})\",\n+               Value(v), us, Value(r));\n \n-        return r;\n+        r\n     }\n }\n "}, {"sha": "66fdc2056a3c6921f61a42190b8d2dfda4d8d873", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -30,6 +30,7 @@ use trans::declare;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n+use trans::value::Value;\n use trans::Disr;\n use middle::subst::Substs;\n use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n@@ -405,8 +406,8 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     // to use a different vtable. In that case, we want to\n                     // load out the original data pointer so we can repackage\n                     // it.\n-                    (const_get_elt(cx, llconst, &[abi::FAT_PTR_ADDR as u32]),\n-                     Some(const_get_elt(cx, llconst, &[abi::FAT_PTR_EXTRA as u32])))\n+                    (const_get_elt(llconst, &[abi::FAT_PTR_ADDR as u32]),\n+                     Some(const_get_elt(llconst, &[abi::FAT_PTR_EXTRA as u32])))\n                 } else {\n                     (llconst, None)\n                 };\n@@ -595,17 +596,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n             let (te1, ty) = try!(const_expr(cx, &e1, param_substs, fn_args, trueconst));\n-            debug!(\"const_expr_unadjusted: te1={}, ty={:?}\",\n-                   cx.tn().val_to_string(te1),\n-                   ty);\n+            debug!(\"const_expr_unadjusted: te1={:?}, ty={:?}\",\n+                   Value(te1), ty);\n             assert!(!ty.is_simd());\n             let is_float = ty.is_fp();\n             let signed = ty.is_signed();\n \n             let (te2, ty2) = try!(const_expr(cx, &e2, param_substs, fn_args, trueconst));\n-            debug!(\"const_expr_unadjusted: te2={}, ty={:?}\",\n-                   cx.tn().val_to_string(te2),\n-                   ty2);\n+            debug!(\"const_expr_unadjusted: te2={:?}, ty={:?}\",\n+                   Value(te2), ty2);\n \n             try!(check_binary_expr_validity(cx, e, ty, te1, te2, trueconst));\n \n@@ -689,8 +688,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let (arr, len) = match bt.sty {\n                 ty::TyArray(_, u) => (bv, C_uint(cx, u)),\n                 ty::TySlice(..) | ty::TyStr => {\n-                    let e1 = const_get_elt(cx, bv, &[0]);\n-                    (load_const(cx, e1, bt), const_get_elt(cx, bv, &[1]))\n+                    let e1 = const_get_elt(bv, &[0]);\n+                    (load_const(cx, e1, bt), const_get_elt(bv, &[1]))\n                 },\n                 ty::TyRef(_, mt) => match mt.ty.sty {\n                     ty::TyArray(_, u) => {\n@@ -725,7 +724,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                           \"const index-expr is out of bounds\");\n                 C_undef(val_ty(arr).element_type())\n             } else {\n-                const_get_elt(cx, arr, &[iv as c_uint])\n+                const_get_elt(arr, &[iv as c_uint])\n             }\n         },\n         hir::ExprCast(ref base, _) => {\n@@ -741,10 +740,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let t_cast_inner =\n                     t_cast.builtin_deref(true, ty::NoPreference).expect(\"cast to non-pointer\").ty;\n                 let ptr_ty = type_of::in_memory_type_of(cx, t_cast_inner).ptr_to();\n-                let addr = ptrcast(const_get_elt(cx, v, &[abi::FAT_PTR_ADDR as u32]),\n+                let addr = ptrcast(const_get_elt(v, &[abi::FAT_PTR_ADDR as u32]),\n                                    ptr_ty);\n                 if type_is_fat_ptr(cx.tcx(), t_cast) {\n-                    let info = const_get_elt(cx, v, &[abi::FAT_PTR_EXTRA as u32]);\n+                    let info = const_get_elt(v, &[abi::FAT_PTR_EXTRA as u32]);\n                     return Ok(C_struct(cx, &[addr, info], false))\n                 } else {\n                     return Ok(addr);\n@@ -756,7 +755,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             ) {\n                 (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n                     let repr = adt::represent_type(cx, t_expr);\n-                    let discr = adt::const_get_discrim(cx, &repr, v);\n+                    let discr = adt::const_get_discrim(&repr, v);\n                     let iv = C_integral(cx.int_type(), discr.0, false);\n                     let s = adt::is_discr_signed(&repr) as Bool;\n                     llvm::LLVMConstIntCast(iv, llty.to_ref(), s)"}, {"sha": "805c138862726c11bfc8e39937ce3fffe6663482", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -152,9 +152,8 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             els: Option<&hir::Expr>,\n                             dest: expr::Dest)\n                             -> Block<'blk, 'tcx> {\n-    debug!(\"trans_if(bcx={}, if_id={}, cond={:?}, thn={}, dest={})\",\n-           bcx.to_str(), if_id, cond, thn.id,\n-           dest.to_string(bcx.ccx()));\n+    debug!(\"trans_if(bcx={}, if_id={}, cond={:?}, thn={}, dest={:?})\",\n+           bcx.to_str(), if_id, cond, thn.id, dest);\n     let _icx = push_ctxt(\"trans_if\");\n \n     if bcx.unreachable.get() {"}, {"sha": "c1353b4f681ea29ffe20b8d32048f6aab036b693", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -101,6 +101,7 @@ use trans::cleanup;\n use trans::cleanup::{CleanupMethods, DropHintDatum, DropHintMethods};\n use trans::expr;\n use trans::tvec;\n+use trans::value::Value;\n use middle::ty::Ty;\n \n use std::fmt;\n@@ -111,7 +112,7 @@ use syntax::codemap::DUMMY_SP;\n /// describes where the value is stored, what Rust type the value has,\n /// whether it is addressed by reference, and so forth. Please refer\n /// the section on datums in `README.md` for more details.\n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy)]\n pub struct Datum<'tcx, K> {\n     /// The llvm value.  This is either a pointer to the Rust value or\n     /// the value itself, depending on `kind` below.\n@@ -124,6 +125,13 @@ pub struct Datum<'tcx, K> {\n     pub kind: K,\n }\n \n+impl<'tcx, K: fmt::Debug> fmt::Debug for Datum<'tcx, K> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Datum({:?}, {:?}, {:?})\",\n+               Value(self.val), self.ty, self.kind)\n+    }\n+}\n+\n pub struct DatumBlock<'blk, 'tcx: 'blk, K> {\n     pub bcx: Block<'blk, 'tcx>,\n     pub datum: Datum<'tcx, K>,\n@@ -311,8 +319,8 @@ pub fn lvalue_scratch_datum<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     // Very subtle: potentially initialize the scratch memory at point where it is alloca'ed.\n     // (See discussion at Issue 30530.)\n     let scratch = alloc_ty_init(bcx, ty, zero, name);\n-    debug!(\"lvalue_scratch_datum scope={:?} scratch={} ty={:?}\",\n-           scope, bcx.ccx().tn().val_to_string(scratch), ty);\n+    debug!(\"lvalue_scratch_datum scope={:?} scratch={:?} ty={:?}\",\n+           scope, Value(scratch), ty);\n \n     // Subtle. Populate the scratch memory *before* scheduling cleanup.\n     let bcx = populate(arg, bcx, scratch);\n@@ -351,8 +359,8 @@ fn add_rvalue_clean<'a, 'tcx>(mode: RvalueMode,\n                               scope: cleanup::ScopeId,\n                               val: ValueRef,\n                               ty: Ty<'tcx>) {\n-    debug!(\"add_rvalue_clean scope={:?} val={} ty={:?}\",\n-           scope, fcx.ccx.tn().val_to_string(val), ty);\n+    debug!(\"add_rvalue_clean scope={:?} val={:?} ty={:?}\",\n+           scope, Value(val), ty);\n     match mode {\n         ByValue => { fcx.schedule_drop_immediate(scope, val, ty); }\n         ByRef => {\n@@ -617,7 +625,7 @@ impl<'tcx> Datum<'tcx, Expr> {\n                                  name: &str,\n                                  expr_id: ast::NodeId)\n                                  -> DatumBlock<'blk, 'tcx, Lvalue> {\n-        debug!(\"to_lvalue_datum self: {}\", self.to_string(bcx.ccx()));\n+        debug!(\"to_lvalue_datum self: {:?}\", self);\n \n         self.match_kind(\n             |l| DatumBlock::new(bcx, l),\n@@ -767,14 +775,6 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n         self.shallow_copy_raw(bcx, dst)\n     }\n \n-    #[allow(dead_code)] // useful for debugging\n-    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"Datum({}, {:?}, {:?})\",\n-                ccx.tn().val_to_string(self.val),\n-                self.ty,\n-                self.kind)\n-    }\n-\n     /// See the `appropriate_rvalue_mode()` function\n     pub fn appropriate_rvalue_mode<'a>(&self, ccx: &CrateContext<'a, 'tcx>)\n                                        -> RvalueMode {"}, {"sha": "ddfceee6d4ac948a9fbf97dc4590b046793e046a", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -129,7 +129,7 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n     let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n-    debug!(\"declare_rust_fn llfty={}\", ccx.tn().type_to_string(llfty));\n+    debug!(\"declare_rust_fn llfty={:?}\", llfty);\n \n     // it is ok to directly access sig.0.output because we erased all\n     // late-bound-regions above"}, {"sha": "beae363f9684ed0b13141f0adeddb55e8bb1cc9d", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -69,6 +69,7 @@ use trans::glue;\n use trans::machine;\n use trans::tvec;\n use trans::type_of;\n+use trans::value::Value;\n use trans::Disr;\n use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n use middle::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n@@ -85,6 +86,7 @@ use rustc_front::hir;\n \n use syntax::{ast, codemap};\n use syntax::parse::token::InternedString;\n+use std::fmt;\n use std::mem;\n \n // Destinations\n@@ -98,11 +100,11 @@ pub enum Dest {\n     Ignore,\n }\n \n-impl Dest {\n-    pub fn to_string(&self, ccx: &CrateContext) -> String {\n+impl fmt::Debug for Dest {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            SaveIn(v) => format!(\"SaveIn({})\", ccx.tn().val_to_string(v)),\n-            Ignore => \"Ignore\".to_string()\n+            SaveIn(v) => write!(f, \"SaveIn({:?})\", Value(v)),\n+            Ignore => f.write_str(\"Ignore\")\n         }\n     }\n }\n@@ -377,10 +379,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         Some(adj) => { adj }\n     };\n-    debug!(\"unadjusted datum for expr {:?}: {} adjustment={:?}\",\n-           expr,\n-           datum.to_string(bcx.ccx()),\n-           adjustment);\n+    debug!(\"unadjusted datum for expr {:?}: {:?} adjustment={:?}\",\n+           expr, datum, adjustment);\n     match adjustment {\n         AdjustReifyFnPointer => {\n             match datum.ty.sty {\n@@ -452,7 +452,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n     }\n-    debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n+    debug!(\"after adjustments, datum={:?}\", datum);\n     DatumBlock::new(bcx, datum)\n }\n \n@@ -462,9 +462,7 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               target: Datum<'tcx, Rvalue>)\n                               -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;\n-    debug!(\"coerce_unsized({} -> {})\",\n-           source.to_string(bcx.ccx()),\n-           target.to_string(bcx.ccx()));\n+    debug!(\"coerce_unsized({:?} -> {:?})\", source, target);\n \n     match (&source.ty.sty, &target.ty.sty) {\n         (&ty::TyBox(a), &ty::TyBox(b)) |\n@@ -854,8 +852,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let (base, len) = base_datum.get_vec_base_and_len(bcx);\n \n-            debug!(\"trans_index: base {}\", bcx.val_to_string(base));\n-            debug!(\"trans_index: len {}\", bcx.val_to_string(len));\n+            debug!(\"trans_index: base {:?}\", Value(base));\n+            debug!(\"trans_index: len {:?}\", Value(len));\n \n             let bounds_check = ICmp(bcx,\n                                     llvm::IntUGE,\n@@ -1279,8 +1277,8 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         nid));\n                 }\n             };\n-            debug!(\"take_local(nid={}, v={}, ty={})\",\n-                   nid, bcx.val_to_string(datum.val), datum.ty);\n+            debug!(\"take_local(nid={}, v={:?}, ty={})\",\n+                   nid, Value(datum.val), datum.ty);\n             datum\n         }\n         _ => {\n@@ -1829,12 +1827,10 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let lhs = unpack_datum!(bcx, trans(bcx, lhs));\n             let lhs = unpack_datum!(bcx, lhs.to_rvalue_datum(bcx, \"binop_lhs\"));\n-            debug!(\"trans_binary (expr {}): lhs={}\",\n-                   expr.id, lhs.to_string(ccx));\n+            debug!(\"trans_binary (expr {}): lhs={:?}\", expr.id, lhs);\n             let rhs = unpack_datum!(bcx, trans(bcx, rhs));\n             let rhs = unpack_datum!(bcx, rhs.to_rvalue_datum(bcx, \"binop_rhs\"));\n-            debug!(\"trans_binary (expr {}): rhs={}\",\n-                   expr.id, rhs.to_string(ccx));\n+            debug!(\"trans_binary (expr {}): rhs={:?}\", expr.id, rhs);\n \n             if type_is_fat_ptr(ccx.tcx(), lhs.ty) {\n                 assert!(type_is_fat_ptr(ccx.tcx(), rhs.ty),\n@@ -2085,10 +2081,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           -> DatumBlock<'blk, 'tcx, Expr> {\n     let ccx = bcx.ccx();\n \n-    debug!(\"deref_once(expr={:?}, datum={}, method_call={:?})\",\n-           expr,\n-           datum.to_string(ccx),\n-           method_call);\n+    debug!(\"deref_once(expr={:?}, datum={:?}, method_call={:?})\",\n+           expr, datum, method_call);\n \n     let mut bcx = bcx;\n \n@@ -2175,8 +2169,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    debug!(\"deref_once(expr={}, method_call={:?}, result={})\",\n-           expr.id, method_call, r.datum.to_string(ccx));\n+    debug!(\"deref_once(expr={}, method_call={:?}, result={:?})\",\n+           expr.id, method_call, r.datum);\n \n     return r;\n }"}, {"sha": "8e728ca808ccbcb42a8d24e173c3bf37f1af4b28", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -27,6 +27,7 @@ use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n use trans::type_of;\n+use trans::value::Value;\n use middle::infer;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::subst::Substs;\n@@ -254,12 +255,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n {\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_native_call(callee_ty={:?}, \\\n-            llfn={}, \\\n-            llretptr={})\",\n-           callee_ty,\n-           ccx.tn().val_to_string(llfn),\n-           ccx.tn().val_to_string(llretptr));\n+    debug!(\"trans_native_call(callee_ty={:?}, llfn={:?}, llretptr={:?})\",\n+           callee_ty, Value(llfn), Value(llretptr));\n \n     let (fn_abi, fn_sig) = match callee_ty.sty {\n         ty::TyFnDef(_, _, ref fn_ty) |\n@@ -306,11 +303,11 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // Does Rust pass this argument by pointer?\n         let rust_indirect = type_of::arg_is_indirect(ccx, passed_arg_tys[i]);\n \n-        debug!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n+        debug!(\"argument {}, llarg_rust={:?}, rust_indirect={}, arg_ty={:?}\",\n                i,\n-               ccx.tn().val_to_string(llarg_rust),\n+               Value(llarg_rust),\n                rust_indirect,\n-               ccx.tn().type_to_string(arg_ty.ty));\n+               arg_ty.ty);\n \n         // Ensure that we always have the Rust value indirectly,\n         // because it makes bitcasting easier.\n@@ -326,17 +323,17 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             llarg_rust = scratch;\n         }\n \n-        debug!(\"llarg_rust={} (after indirection)\",\n-               ccx.tn().val_to_string(llarg_rust));\n+        debug!(\"llarg_rust={:?} (after indirection)\",\n+               Value(llarg_rust));\n \n         // Check whether we need to do any casting\n         match arg_ty.cast {\n             Some(ty) => llarg_rust = BitCast(bcx, llarg_rust, ty.ptr_to()),\n             None => ()\n         }\n \n-        debug!(\"llarg_rust={} (after casting)\",\n-               ccx.tn().val_to_string(llarg_rust));\n+        debug!(\"llarg_rust={:?} (after casting)\",\n+               Value(llarg_rust));\n \n         // Finally, load the value if needed for the foreign ABI\n         let foreign_indirect = arg_ty.is_indirect();\n@@ -351,8 +348,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         };\n \n-        debug!(\"argument {}, llarg_foreign={}\",\n-               i, ccx.tn().val_to_string(llarg_foreign));\n+        debug!(\"argument {}, llarg_foreign={:?}\",\n+               i, Value(llarg_foreign));\n \n         // fill padding with undef value\n         match arg_ty.pad {\n@@ -421,10 +418,10 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             None => fn_type.ret_ty.ty\n         };\n \n-        debug!(\"llretptr={}\", ccx.tn().val_to_string(llretptr));\n-        debug!(\"llforeign_retval={}\", ccx.tn().val_to_string(llforeign_retval));\n-        debug!(\"llrust_ret_ty={}\", ccx.tn().type_to_string(llrust_ret_ty));\n-        debug!(\"llforeign_ret_ty={}\", ccx.tn().type_to_string(llforeign_ret_ty));\n+        debug!(\"llretptr={:?}\", Value(llretptr));\n+        debug!(\"llforeign_retval={:?}\", Value(llforeign_retval));\n+        debug!(\"llrust_ret_ty={:?}\", llrust_ret_ty);\n+        debug!(\"llforeign_ret_ty={:?}\", llforeign_ret_ty);\n \n         if llrust_ret_ty == llforeign_ret_ty {\n             match fn_sig.output {\n@@ -562,8 +559,8 @@ pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let llfn = declare::declare_fn(ccx, name, cconv, llfn_ty,\n                                    ty::FnConverging(ccx.tcx().mk_nil()));\n     add_argument_attributes(&tys, llfn);\n-    debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={}, llfn={})\",\n-           ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n+    debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={:?}, llfn={:?})\",\n+           llfn_ty, Value(llfn));\n     llfn\n }\n \n@@ -585,8 +582,8 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let llfn = base::register_fn_llvmty(ccx, sp, sym, node_id, cconv, llfn_ty);\n     add_argument_attributes(&tys, llfn);\n-    debug!(\"register_rust_fn_with_foreign_abi(node_id={}, llfn_ty={}, llfn={})\",\n-           node_id, ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n+    debug!(\"register_rust_fn_with_foreign_abi(node_id={}, llfn_ty={:?}, llfn={:?})\",\n+           node_id, llfn_ty, Value(llfn));\n     llfn\n }\n \n@@ -667,9 +664,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let _icx = push_ctxt(\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n \n-        debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={}, t={:?})\",\n-               ccx.tn().val_to_string(llrustfn),\n-               ccx.tn().val_to_string(llwrapfn),\n+        debug!(\"build_wrap_fn(llrustfn={:?}, llwrapfn={:?}, t={:?})\",\n+               Value(llrustfn),\n+               Value(llwrapfn),\n                t);\n \n         // Avoid all the Rust generation stuff and just generate raw\n@@ -737,24 +734,24 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // alloca some scratch space on the stack.\n             match foreign_outptr {\n                 Some(llforeign_outptr) => {\n-                    debug!(\"out pointer, foreign={}\",\n-                           ccx.tn().val_to_string(llforeign_outptr));\n+                    debug!(\"out pointer, foreign={:?}\",\n+                           Value(llforeign_outptr));\n                     let llrust_retptr =\n                         builder.bitcast(llforeign_outptr, llrust_ret_ty.ptr_to());\n-                    debug!(\"out pointer, foreign={} (casted)\",\n-                           ccx.tn().val_to_string(llrust_retptr));\n+                    debug!(\"out pointer, foreign={:?} (casted)\",\n+                           Value(llrust_retptr));\n                     llrust_args.push(llrust_retptr);\n                     return_alloca = None;\n                 }\n \n                 None => {\n                     let slot = builder.alloca(llrust_ret_ty, \"return_alloca\");\n                     debug!(\"out pointer, \\\n-                            allocad={}, \\\n-                            llrust_ret_ty={}, \\\n+                            allocad={:?}, \\\n+                            llrust_ret_ty={:?}, \\\n                             return_ty={:?}\",\n-                           ccx.tn().val_to_string(slot),\n-                           ccx.tn().type_to_string(llrust_ret_ty),\n+                           Value(slot),\n+                           llrust_ret_ty,\n                            tys.fn_sig.output);\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n@@ -792,8 +789,8 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let foreign_index = next_foreign_arg(llforeign_arg_ty.pad.is_some());\n             let mut llforeign_arg = get_param(llwrapfn, foreign_index);\n \n-            debug!(\"llforeign_arg {}{}: {}\", \"#\",\n-                   i, ccx.tn().val_to_string(llforeign_arg));\n+            debug!(\"llforeign_arg {}{}: {:?}\", \"#\",\n+                   i, Value(llforeign_arg));\n             debug!(\"rust_indirect = {}, foreign_indirect = {}\",\n                    rust_indirect, foreign_indirect);\n \n@@ -840,8 +837,8 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 }\n             };\n \n-            debug!(\"llrust_arg {}{}: {}\", \"#\",\n-                   i, ccx.tn().val_to_string(llrust_arg));\n+            debug!(\"llrust_arg {}{}: {:?}\", \"#\",\n+                   i, Value(llrust_arg));\n             if type_is_fat_ptr(ccx.tcx(), rust_ty) {\n                 let next_llrust_ty = rust_param_tys.next().expect(\"Not enough parameter types!\");\n                 llrust_args.push(builder.load(builder.bitcast(builder.struct_gep(\n@@ -854,8 +851,8 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n \n         // Perform the call itself\n-        debug!(\"calling llrustfn = {}, t = {:?}\",\n-               ccx.tn().val_to_string(llrustfn), t);\n+        debug!(\"calling llrustfn = {:?}, t = {:?}\",\n+               Value(llrustfn), t);\n         let attributes = attributes::from_fn_type(ccx, t);\n         let llrust_ret_val = builder.call(llrustfn, &llrust_args,\n                                           None, Some(attributes));\n@@ -971,14 +968,14 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                        llsig.ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n            ty={:?}, \\\n-           llsig={} -> {}, \\\n-           fn_ty={} -> {}, \\\n+           llsig={:?} -> {:?}, \\\n+           fn_ty={:?} -> {:?}, \\\n            ret_def={}\",\n            ty,\n-           ccx.tn().types_to_str(&llsig.llarg_tys),\n-           ccx.tn().type_to_string(llsig.llret_ty),\n-           ccx.tn().types_to_str(&fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>()),\n-           ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n+           llsig.llarg_tys,\n+           llsig.llret_ty,\n+           fn_ty.arg_tys,\n+           fn_ty.ret_ty,\n            llsig.ret_def);\n \n     ForeignTypes {"}, {"sha": "b899dbe47ca516c46c0c1a83cfbf35639e1bd397", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -37,6 +37,7 @@ use trans::machine::*;\n use trans::monomorphize;\n use trans::type_of::{type_of, sizing_type_of, align_of};\n use trans::type_::Type;\n+use trans::value::Value;\n \n use arena::TypedArena;\n use libc::c_uint;\n@@ -374,14 +375,14 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                          -> (ValueRef, ValueRef) {\n-    debug!(\"calculate size of DST: {}; with lost info: {}\",\n-           t, bcx.val_to_string(info));\n+    debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n+           t, Value(info));\n     if type_is_sized(bcx.tcx(), t) {\n         let sizing_type = sizing_type_of(bcx.ccx(), t);\n         let size = llsize_of_alloc(bcx.ccx(), sizing_type);\n         let align = align_of(bcx.ccx(), t);\n-        debug!(\"size_and_align_of_dst t={} info={} size: {} align: {}\",\n-               t, bcx.val_to_string(info), size, align);\n+        debug!(\"size_and_align_of_dst t={} info={:?} size: {} align: {}\",\n+               t, Value(info), size, align);\n         let size = C_uint(bcx.ccx(), size);\n         let align = C_uint(bcx.ccx(), align);\n         return (size, align);\n@@ -394,7 +395,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             assert!(!t.is_simd());\n             let repr = adt::represent_type(ccx, t);\n             let sizing_type = adt::sizing_type_context_of(ccx, &repr, true);\n-            debug!(\"DST {} sizing_type: {}\", t, sizing_type.to_string());\n+            debug!(\"DST {} sizing_type: {:?}\", t, sizing_type);\n             let sized_size = llsize_of_alloc(ccx, sizing_type.prefix());\n             let sized_align = llalign_of_min(ccx, sizing_type.prefix());\n             debug!(\"DST {} statically sized prefix size: {} align: {}\","}, {"sha": "d246208ec1db2330fc1aaccf05c1e28b9f4ebc17", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -1552,7 +1552,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n-                let val = const_get_elt(bcx.ccx(), vector, &[i as libc::c_uint]);\n+                let val = const_get_elt(vector, &[i as libc::c_uint]);\n                 let c = const_to_opt_uint(val);\n                 match c {\n                     None => {"}, {"sha": "6b785e7edfd6a1568a38e2b589089f91e129b831", "filename": "src/librustc_trans/trans/llrepr.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/abb1515c53d209be3e8c1e9e73c1a98bc86b8692/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abb1515c53d209be3e8c1e9e73c1a98bc86b8692/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs?ref=abb1515c53d209be3e8c1e9e73c1a98bc86b8692", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use trans::context::CrateContext;\n-use trans::type_::Type;\n-use llvm::ValueRef;\n-\n-pub trait LlvmRepr {\n-    fn llrepr(&self, ccx: &CrateContext) -> String;\n-}\n-\n-impl<T:LlvmRepr> LlvmRepr for [T] {\n-    fn llrepr(&self, ccx: &CrateContext) -> String {\n-        let reprs: Vec<String> = self.iter().map(|t| t.llrepr(ccx)).collect();\n-        format!(\"[{}]\", reprs.join(\",\"))\n-    }\n-}\n-\n-impl LlvmRepr for Type {\n-    fn llrepr(&self, ccx: &CrateContext) -> String {\n-        ccx.tn().type_to_string(*self)\n-    }\n-}\n-\n-impl LlvmRepr for ValueRef {\n-    fn llrepr(&self, ccx: &CrateContext) -> String {\n-        ccx.tn().val_to_string(*self)\n-    }\n-}"}, {"sha": "da07a02bd3a165d2722cded169659ffafca24174", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -33,6 +33,7 @@ use trans::glue;\n use trans::machine;\n use trans::type_::Type;\n use trans::type_of::*;\n+use trans::value::Value;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use syntax::ast::{self, Name};\n@@ -171,10 +172,8 @@ pub fn get_virtual_method<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n-    debug!(\"get_virtual_method(callee_ty={}, vtable_index={}, llvtable={})\",\n-           method_ty,\n-           vtable_index,\n-           bcx.val_to_string(llvtable));\n+    debug!(\"get_virtual_method(callee_ty={}, vtable_index={}, llvtable={:?})\",\n+           method_ty, vtable_index, Value(llvtable));\n \n     let mptr = Load(bcx, GEPi(bcx, llvtable, &[vtable_index + VTABLE_OFFSET]));\n \n@@ -250,8 +249,8 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let llself = llargs[self_idx];\n     let llvtable = llargs[self_idx + 1];\n \n-    debug!(\"trans_object_shim: llself={}, llvtable={}\",\n-           bcx.val_to_string(llself), bcx.val_to_string(llvtable));\n+    debug!(\"trans_object_shim: llself={:?}, llvtable={:?}\",\n+           Value(llself), Value(llvtable));\n \n     assert!(!fcx.needs_ret_allocas);\n "}, {"sha": "52a4995f594c872e70924128caa05994989750a7", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -38,8 +38,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let val = if common::type_is_immediate(ccx, ty) {\n             OperandValue::Immediate(val)\n         } else if common::type_is_fat_ptr(bcx.tcx(), ty) {\n-            let data = common::const_get_elt(ccx, val, &[abi::FAT_PTR_ADDR as u32]);\n-            let extra = common::const_get_elt(ccx, val, &[abi::FAT_PTR_EXTRA as u32]);\n+            let data = common::const_get_elt(val, &[abi::FAT_PTR_ADDR as u32]);\n+            let extra = common::const_get_elt(val, &[abi::FAT_PTR_EXTRA as u32]);\n             OperandValue::FatPtr(data, extra)\n         } else {\n             OperandValue::Ref(val)"}, {"sha": "0cc21ded6f9be2faf697fea88752ffeb7c870ab9", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -15,9 +15,12 @@ use trans::adt;\n use trans::base;\n use trans::common::{self, Block, BlockAndBuilder};\n use trans::datum;\n+use trans::value::Value;\n use trans::Disr;\n use trans::glue;\n \n+use std::fmt;\n+\n use super::{MirContext, TempRef, drop};\n use super::lvalue::LvalueRef;\n \n@@ -53,34 +56,34 @@ pub struct OperandRef<'tcx> {\n     pub ty: Ty<'tcx>\n }\n \n-impl<'tcx> OperandRef<'tcx> {\n-    /// Asserts that this operand refers to a scalar and returns\n-    /// a reference to its value.\n-    pub fn immediate(self) -> ValueRef {\n-        match self.val {\n-            OperandValue::Immediate(s) => s,\n-            _ => unreachable!()\n-        }\n-    }\n-\n-    pub fn repr<'bcx>(self, bcx: &BlockAndBuilder<'bcx, 'tcx>) -> String {\n+impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.val {\n             OperandValue::Ref(r) => {\n-                format!(\"OperandRef(Ref({}) @ {:?})\",\n-                        bcx.val_to_string(r), self.ty)\n+                write!(f, \"OperandRef(Ref({:?}) @ {:?})\",\n+                       Value(r), self.ty)\n             }\n             OperandValue::Immediate(i) => {\n-                format!(\"OperandRef(Immediate({}) @ {:?})\",\n-                        bcx.val_to_string(i), self.ty)\n+                write!(f, \"OperandRef(Immediate({:?}) @ {:?})\",\n+                       Value(i), self.ty)\n             }\n             OperandValue::FatPtr(a, d) => {\n-                format!(\"OperandRef(FatPtr({}, {}) @ {:?})\",\n-                        bcx.val_to_string(a),\n-                        bcx.val_to_string(d),\n-                        self.ty)\n+                write!(f, \"OperandRef(FatPtr({:?}, {:?}) @ {:?})\",\n+                       Value(a), Value(d), self.ty)\n             }\n         }\n     }\n+}\n+\n+impl<'tcx> OperandRef<'tcx> {\n+    /// Asserts that this operand refers to a scalar and returns\n+    /// a reference to its value.\n+    pub fn immediate(self) -> ValueRef {\n+        match self.val {\n+            OperandValue::Immediate(s) => s,\n+            _ => unreachable!()\n+        }\n+    }\n \n     pub fn from_rvalue_datum(datum: datum::Datum<'tcx, datum::Rvalue>) -> OperandRef {\n         OperandRef {\n@@ -100,7 +103,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                       ty: Ty<'tcx>)\n                       -> OperandRef<'tcx>\n     {\n-        debug!(\"trans_load: {} @ {:?}\", bcx.val_to_string(llval), ty);\n+        debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n \n         let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n             datum::ByValue => {\n@@ -164,7 +167,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                          lldest: ValueRef,\n                          operand: OperandRef<'tcx>)\n     {\n-        debug!(\"store_operand: operand={}\", operand.repr(bcx));\n+        debug!(\"store_operand: operand={:?}\", operand);\n         bcx.with_block(|bcx| self.store_operand_direct(bcx, lldest, operand))\n     }\n "}, {"sha": "4b5f1566380a88a0abd3a5e5391fe135072e4b2b", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -27,6 +27,7 @@ use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n use trans::tvec;\n+use trans::value::Value;\n use trans::Disr;\n \n use super::MirContext;\n@@ -40,9 +41,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         rvalue: &mir::Rvalue<'tcx>)\n                         -> BlockAndBuilder<'bcx, 'tcx>\n     {\n-        debug!(\"trans_rvalue(dest.llval={}, rvalue={:?})\",\n-               bcx.val_to_string(dest.llval),\n-               rvalue);\n+        debug!(\"trans_rvalue(dest.llval={:?}, rvalue={:?})\",\n+               Value(dest.llval), rvalue);\n \n         match *rvalue {\n            mir::Rvalue::Use(ref operand) => {\n@@ -193,7 +193,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         match *rvalue {\n             mir::Rvalue::Cast(ref kind, ref operand, cast_ty) => {\n                 let operand = self.trans_operand(&bcx, operand);\n-                debug!(\"cast operand is {}\", operand.repr(&bcx));\n+                debug!(\"cast operand is {:?}\", operand);\n                 let cast_ty = bcx.monomorphize(&cast_ty);\n \n                 let val = match *kind {\n@@ -237,8 +237,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             }\n                             OperandValue::Ref(_) => {\n                                 bcx.sess().bug(\n-                                    &format!(\"by-ref operand {} in trans_rvalue_operand\",\n-                                             operand.repr(&bcx)));\n+                                    &format!(\"by-ref operand {:?} in trans_rvalue_operand\",\n+                                             operand));\n                             }\n                         }\n                     }"}, {"sha": "9d197742c1be37c0a2cf2c72d51b8f235620de2d", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -53,7 +53,6 @@ mod foreign;\n mod glue;\n mod inline;\n mod intrinsic;\n-mod llrepr;\n mod machine;\n mod _match;\n mod meth;"}, {"sha": "6c48525abe0652ce188600708d37f436019d4f1e", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -26,27 +26,20 @@ use trans::expr;\n use trans::machine::llsize_of_alloc;\n use trans::type_::Type;\n use trans::type_of;\n+use trans::value::Value;\n use middle::ty::{self, Ty};\n \n use rustc_front::hir;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n struct VecTypes<'tcx> {\n     unit_ty: Ty<'tcx>,\n     llunit_ty: Type\n }\n \n-impl<'tcx> VecTypes<'tcx> {\n-    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"VecTypes {{unit_ty={}, llunit_ty={}}}\",\n-                self.unit_ty,\n-                ccx.tn().type_to_string(self.llunit_ty))\n-    }\n-}\n-\n pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       expr: &hir::Expr,\n                                       dest: expr::Dest)\n@@ -58,8 +51,7 @@ pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // to store the array of the suitable size, so all we have to do is\n     // generate the content.\n \n-    debug!(\"trans_fixed_vstore(expr={:?}, dest={})\",\n-           expr, dest.to_string(bcx.ccx()));\n+    debug!(\"trans_fixed_vstore(expr={:?}, dest={:?})\", expr, dest);\n \n     let vt = vec_types_from_expr(bcx, expr);\n \n@@ -82,7 +74,6 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    content_expr: &hir::Expr)\n                                    -> DatumBlock<'blk, 'tcx, Expr> {\n     let fcx = bcx.fcx;\n-    let ccx = fcx.ccx;\n     let mut bcx = bcx;\n \n     debug!(\"trans_slice_vec(slice_expr={:?})\",\n@@ -105,7 +96,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Handle the &[...] case:\n     let vt = vec_types_from_expr(bcx, content_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug!(\"    vt={}, count={}\", vt.to_string(ccx), count);\n+    debug!(\"    vt={:?}, count={}\", vt, count);\n \n     let fixed_ty = bcx.tcx().mk_array(vt.unit_ty, count);\n \n@@ -144,9 +135,7 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  str_lit: InternedString,\n                                  dest: Dest)\n                                  -> Block<'blk, 'tcx> {\n-    debug!(\"trans_lit_str(lit_expr={:?}, dest={})\",\n-           lit_expr,\n-           dest.to_string(bcx.ccx()));\n+    debug!(\"trans_lit_str(lit_expr={:?}, dest={:?})\", lit_expr, dest);\n \n     match dest {\n         Ignore => bcx,\n@@ -172,10 +161,8 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n \n-    debug!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n-           vt.to_string(bcx.ccx()),\n-           dest.to_string(bcx.ccx()),\n-           vstore_expr);\n+    debug!(\"write_content(vt={:?}, dest={:?}, vstore_expr={:?})\",\n+           vt, dest, vstore_expr);\n \n     match content_expr.node {\n         hir::ExprLit(ref lit) => {\n@@ -214,8 +201,8 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let temp_scope = fcx.push_custom_cleanup_scope();\n                     for (i, element) in elements.iter().enumerate() {\n                         let lleltptr = GEPi(bcx, lldest, &[i]);\n-                        debug!(\"writing index {} with lleltptr={}\",\n-                               i, bcx.val_to_string(lleltptr));\n+                        debug!(\"writing index {} with lleltptr={:?}\",\n+                               i, Value(lleltptr));\n                         bcx = expr::trans_into(bcx, &element,\n                                                SaveIn(lleltptr));\n                         let scope = cleanup::CustomScope(temp_scope);"}, {"sha": "c1461693598413a1834bbc35246ebb60ac81b537", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm;\n-use llvm::{TypeRef, Bool, False, True, TypeKind, ValueRef};\n+use llvm::{TypeRef, Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use trans::context::CrateContext;\n@@ -20,18 +20,27 @@ use util::nodemap::FnvHashMap;\n use syntax::ast;\n \n use std::ffi::CString;\n+use std::fmt;\n use std::mem;\n use std::ptr;\n use std::cell::RefCell;\n \n use libc::c_uint;\n \n-#[derive(Clone, Copy, PartialEq, Debug)]\n+#[derive(Clone, Copy, PartialEq)]\n #[repr(C)]\n pub struct Type {\n     rf: TypeRef\n }\n \n+impl fmt::Debug for Type {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(&llvm::build_string(|s| unsafe {\n+            llvm::LLVMWriteTypeToString(self.to_ref(), s);\n+        }).expect(\"non-UTF8 type description from LLVM\"))\n+    }\n+}\n+\n macro_rules! ty {\n     ($e:expr) => ( Type::from_ref(unsafe { $e }))\n }\n@@ -50,12 +59,6 @@ impl Type {\n         self.rf\n     }\n \n-    pub fn to_string(self: Type) -> String {\n-        llvm::build_string(|s| unsafe {\n-            llvm::LLVMWriteTypeToString(self.to_ref(), s);\n-        }).expect(\"non-UTF8 type description from LLVM\")\n-    }\n-\n     pub fn to_ref_slice(slice: &[Type]) -> &[TypeRef] {\n         unsafe { mem::transmute(slice) }\n     }\n@@ -301,7 +304,6 @@ impl Type {\n     }\n }\n \n-\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n@@ -323,19 +325,4 @@ impl TypeNames {\n     pub fn find_type(&self, s: &str) -> Option<Type> {\n         self.named_types.borrow().get(s).map(|x| Type::from_ref(*x))\n     }\n-\n-    pub fn type_to_string(&self, ty: Type) -> String {\n-        ty.to_string()\n-    }\n-\n-    pub fn types_to_str(&self, tys: &[Type]) -> String {\n-        let strs: Vec<String> = tys.iter().map(|t| self.type_to_string(*t)).collect();\n-        format!(\"[{}]\", strs.join(\",\"))\n-    }\n-\n-    pub fn val_to_string(&self, val: ValueRef) -> String {\n-        llvm::build_string(|s| unsafe {\n-                llvm::LLVMWriteValueToString(val, s);\n-            }).expect(\"nun-UTF8 value description from LLVM\")\n-    }\n }"}, {"sha": "d6eb3769d182a6652bf3190cc55e045259e2b694", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -234,9 +234,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => unreachable!()\n     };\n \n-    debug!(\"--> mapped t={:?} to llsizingty={}\",\n-            t,\n-            cx.tn().type_to_string(llsizingty));\n+    debug!(\"--> mapped t={:?} to llsizingty={:?}\", t, llsizingty);\n \n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n     llsizingty\n@@ -314,12 +312,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     if t != t_norm {\n         let llty = in_memory_type_of(cx, t_norm);\n-        debug!(\"--> normalized {:?} {:?} to {:?} {:?} llty={}\",\n-                t,\n-                t,\n-                t_norm,\n-                t_norm,\n-                cx.tn().type_to_string(llty));\n+        debug!(\"--> normalized {:?} to {:?} llty={:?}\", t, t_norm, llty);\n         cx.lltypes().borrow_mut().insert(t, llty);\n         return llty;\n     }\n@@ -440,9 +433,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyError => cx.sess().bug(\"type_of with TyError\"),\n     };\n \n-    debug!(\"--> mapped t={:?} to llty={}\",\n-            t,\n-            cx.tn().type_to_string(llty));\n+    debug!(\"--> mapped t={:?} to llty={:?}\", t, llty);\n \n     cx.lltypes().borrow_mut().insert(t, llty);\n "}, {"sha": "a33b7d62d2dcefd17efaa3263ff3cddc9ffeaa13", "filename": "src/librustc_trans/trans/value.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47fcb8375921f6bc198fe38a397a79609933e8e/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs?ref=b47fcb8375921f6bc198fe38a397a79609933e8e", "patch": "@@ -12,11 +12,22 @@ use llvm;\n use llvm::{UseRef, ValueRef};\n use trans::basic_block::BasicBlock;\n use trans::common::Block;\n+\n+use std::fmt;\n+\n use libc::c_uint;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq)]\n pub struct Value(pub ValueRef);\n \n+impl fmt::Debug for Value {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(&llvm::build_string(|s| unsafe {\n+            llvm::LLVMWriteValueToString(self.0, s);\n+        }).expect(\"nun-UTF8 value description from LLVM\"))\n+    }\n+}\n+\n macro_rules! opt_val { ($e:expr) => (\n     unsafe {\n         match $e {"}]}