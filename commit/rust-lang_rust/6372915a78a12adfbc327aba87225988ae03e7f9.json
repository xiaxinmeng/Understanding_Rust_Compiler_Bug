{"sha": "6372915a78a12adfbc327aba87225988ae03e7f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNzI5MTVhNzhhMTJhZGZiYzMyN2FiYTg3MjI1OTg4YWUwM2U3Zjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-10T05:16:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-10T05:16:28Z"}, "message": "auto merge of #15561 : huonw/rust/must-use-iterators, r=alexcrichton\n\nSimilar to the stability attributes, a type annotated with `#[must_use =\r\n\"informative snippet\"]` will print the normal warning message along with\r\n\"informative snippet\". This allows the type author to provide some\r\nguidance about why the type should be used.\r\n\r\n---\r\n\r\nIt can be a little unintuitive that something like `v.iter().map(|x|\r\nprintln!(\"{}\", x));` does nothing: the majority of the iterator adaptors\r\nare lazy and do not execute anything until something calls `next`, e.g.\r\na `for` loop, `collect`, `fold`, etc.\r\n\r\nThe majority of such errors can be seen by someone writing something\r\nlike the above, i.e. just calling an iterator adaptor and doing nothing\r\nwith it (and doing this is certainly useless), so we can co-opt the\r\n`must_use` lint, using the message functionality to give a hint to the\r\nreason why.\r\n\r\nFixes #14666.", "tree": {"sha": "cf15cd9d1465fed21dca567a382a3320a8b5affc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf15cd9d1465fed21dca567a382a3320a8b5affc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6372915a78a12adfbc327aba87225988ae03e7f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6372915a78a12adfbc327aba87225988ae03e7f9", "html_url": "https://github.com/rust-lang/rust/commit/6372915a78a12adfbc327aba87225988ae03e7f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6372915a78a12adfbc327aba87225988ae03e7f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "898701cb35833b2ecea8bc7f3902a35b7eccc219", "url": "https://api.github.com/repos/rust-lang/rust/commits/898701cb35833b2ecea8bc7f3902a35b7eccc219", "html_url": "https://github.com/rust-lang/rust/commit/898701cb35833b2ecea8bc7f3902a35b7eccc219"}, {"sha": "27d18fbe41665eef798eb29660c1883bb8600502", "url": "https://api.github.com/repos/rust-lang/rust/commits/27d18fbe41665eef798eb29660c1883bb8600502", "html_url": "https://github.com/rust-lang/rust/commit/27d18fbe41665eef798eb29660c1883bb8600502"}], "stats": {"total": 59, "additions": 47, "deletions": 12}, "files": [{"sha": "80b784250f0ecf58ea90f540789074d6d0de9d6a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6372915a78a12adfbc327aba87225988ae03e7f9/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6372915a78a12adfbc327aba87225988ae03e7f9/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=6372915a78a12adfbc327aba87225988ae03e7f9", "patch": "@@ -751,6 +751,7 @@ impl<A, B, T: ExactSize<A>, U: ExactSize<B>> ExactSize<(A, B)> for Zip<T, U> {}\n \n /// An double-ended iterator with the direction inverted\n #[deriving(Clone)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Rev<T> {\n     iter: T\n }\n@@ -779,6 +780,7 @@ impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterato\n }\n \n /// A mutable reference to an iterator\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct ByRef<'a, T> {\n     iter: &'a mut T\n }\n@@ -1039,6 +1041,7 @@ impl<A, T: Clone + Iterator<A>> CloneableIterator for T {\n \n /// An iterator that repeats endlessly\n #[deriving(Clone)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Cycle<T> {\n     orig: T,\n     iter: T,\n@@ -1090,6 +1093,7 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n \n /// An iterator which strings two iterators together\n #[deriving(Clone)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Chain<T, U> {\n     a: T,\n     b: U,\n@@ -1159,6 +1163,7 @@ for Chain<T, U> {\n \n /// An iterator which iterates two other iterators simultaneously\n #[deriving(Clone)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Zip<T, U> {\n     a: T,\n     b: U\n@@ -1237,6 +1242,7 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n }\n \n /// An iterator which maps the values of `iter` with `f`\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Map<'a, A, B, T> {\n     iter: T,\n     f: |A|: 'a -> B\n@@ -1287,6 +1293,7 @@ impl<'a, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'a, A\n }\n \n /// An iterator which filters the elements of `iter` with `predicate`\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Filter<'a, A, T> {\n     iter: T,\n     predicate: |&A|: 'a -> bool\n@@ -1331,6 +1338,7 @@ impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Filter<'a, A,\n }\n \n /// An iterator which uses `f` to both filter and map elements from `iter`\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct FilterMap<'a, A, B, T> {\n     iter: T,\n     f: |A|: 'a -> Option<B>\n@@ -1375,6 +1383,7 @@ for FilterMap<'a, A, B, T> {\n \n /// An iterator which yields the current count and the element during iteration\n #[deriving(Clone)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Enumerate<T> {\n     iter: T,\n     count: uint\n@@ -1429,6 +1438,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerat\n }\n \n /// An iterator with a `peek()` that returns an optional reference to the next element.\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Peekable<A, T> {\n     iter: T,\n     peeked: Option<A>,\n@@ -1479,6 +1489,7 @@ impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n }\n \n /// An iterator which rejects elements while `predicate` is true\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct SkipWhile<'a, A, T> {\n     iter: T,\n     flag: bool,\n@@ -1517,6 +1528,7 @@ impl<'a, A, T: Iterator<A>> Iterator<A> for SkipWhile<'a, A, T> {\n }\n \n /// An iterator which only accepts elements while `predicate` is true\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct TakeWhile<'a, A, T> {\n     iter: T,\n     flag: bool,\n@@ -1552,6 +1564,7 @@ impl<'a, A, T: Iterator<A>> Iterator<A> for TakeWhile<'a, A, T> {\n \n /// An iterator which skips over `n` elements of `iter`.\n #[deriving(Clone)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Skip<T> {\n     iter: T,\n     n: uint\n@@ -1616,6 +1629,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n \n /// An iterator which only iterates over the first `n` iterations of `iter`.\n #[deriving(Clone)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Take<T> {\n     iter: T,\n     n: uint\n@@ -1665,6 +1679,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n \n \n /// An iterator to maintain state while iterating another iterator\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Scan<'a, A, B, T, St> {\n     iter: T,\n     f: |&mut St, A|: 'a -> Option<B>,\n@@ -1689,6 +1704,7 @@ impl<'a, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'a, A, B, T, St> {\n /// An iterator that maps each element to an iterator,\n /// and yields the elements of the produced iterators\n ///\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct FlatMap<'a, A, T, U> {\n     iter: T,\n     f: |A|: 'a -> U,\n@@ -1748,6 +1764,7 @@ impl<'a,\n /// An iterator that yields `None` forever after the underlying iterator\n /// yields `None` once.\n #[deriving(Clone)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Fuse<T> {\n     iter: T,\n     done: bool\n@@ -1820,6 +1837,7 @@ impl<T> Fuse<T> {\n \n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n pub struct Inspect<'a, A, T> {\n     iter: T,\n     f: |&A|: 'a\n@@ -2299,4 +2317,3 @@ pub mod order {\n         }\n     }\n }\n-"}, {"sha": "481187f7c2ce74b499592b24d761a729de28186b", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6372915a78a12adfbc327aba87225988ae03e7f9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6372915a78a12adfbc327aba87225988ae03e7f9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=6372915a78a12adfbc327aba87225988ae03e7f9", "patch": "@@ -669,22 +669,13 @@ impl LintPass for UnusedResult {\n                 if ast_util::is_local(did) {\n                     match cx.tcx.map.get(did.node) {\n                         ast_map::NodeItem(it) => {\n-                            if attr::contains_name(it.attrs.as_slice(),\n-                                                   \"must_use\") {\n-                                cx.span_lint(UNUSED_MUST_USE, s.span,\n-                                             \"unused result which must be used\");\n-                                warned = true;\n-                            }\n+                            warned |= check_must_use(cx, it.attrs.as_slice(), s.span);\n                         }\n                         _ => {}\n                     }\n                 } else {\n                     csearch::get_item_attrs(&cx.sess().cstore, did, |attrs| {\n-                        if attr::contains_name(attrs.as_slice(), \"must_use\") {\n-                            cx.span_lint(UNUSED_MUST_USE, s.span,\n-                                         \"unused result which must be used\");\n-                            warned = true;\n-                        }\n+                        warned |= check_must_use(cx, attrs.as_slice(), s.span);\n                     });\n                 }\n             }\n@@ -693,6 +684,25 @@ impl LintPass for UnusedResult {\n         if !warned {\n             cx.span_lint(UNUSED_RESULT, s.span, \"unused result\");\n         }\n+\n+        fn check_must_use(cx: &Context, attrs: &[ast::Attribute], sp: Span) -> bool {\n+            for attr in attrs.iter() {\n+                if attr.check_name(\"must_use\") {\n+                    let mut msg = \"unused result which must be used\".to_string();\n+                    // check for #[must_use=\"...\"]\n+                    match attr.value_str() {\n+                        None => {}\n+                        Some(s) => {\n+                            msg.push_str(\": \");\n+                            msg.push_str(s.get());\n+                        }\n+                    }\n+                    cx.span_lint(UNUSED_MUST_USE, sp, msg.as_slice());\n+                    return true;\n+                }\n+            }\n+            false\n+        }\n     }\n }\n "}, {"sha": "ecc52c0ee7d58491b5f59f2d063b0ca078bcf7d4", "filename": "src/test/compile-fail/unused-result.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6372915a78a12adfbc327aba87225988ae03e7f9/src%2Ftest%2Fcompile-fail%2Funused-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6372915a78a12adfbc327aba87225988ae03e7f9/src%2Ftest%2Fcompile-fail%2Funused-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-result.rs?ref=6372915a78a12adfbc327aba87225988ae03e7f9", "patch": "@@ -14,27 +14,35 @@\n #[must_use]\n enum MustUse { Test }\n \n+#[must_use = \"some message\"]\n+enum MustUseMsg { Test2 }\n+\n fn foo<T>() -> T { fail!() }\n \n fn bar() -> int { return foo::<int>(); }\n fn baz() -> MustUse { return foo::<MustUse>(); }\n+fn qux() -> MustUseMsg { return foo::<MustUseMsg>(); }\n \n #[allow(unused_result)]\n fn test() {\n     foo::<int>();\n     foo::<MustUse>(); //~ ERROR: unused result which must be used\n+    foo::<MustUseMsg>(); //~ ERROR: unused result which must be used: some message\n }\n \n #[allow(unused_result, unused_must_use)]\n fn test2() {\n     foo::<int>();\n     foo::<MustUse>();\n+    foo::<MustUseMsg>();\n }\n \n fn main() {\n     foo::<int>(); //~ ERROR: unused result\n     foo::<MustUse>(); //~ ERROR: unused result which must be used\n+    foo::<MustUseMsg>(); //~ ERROR: unused result which must be used: some message\n \n     let _ = foo::<int>();\n     let _ = foo::<MustUse>();\n+    let _ = foo::<MustUseMsg>();\n }"}]}