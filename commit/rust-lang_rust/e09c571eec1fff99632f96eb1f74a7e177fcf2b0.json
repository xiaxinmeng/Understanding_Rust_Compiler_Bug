{"sha": "e09c571eec1fff99632f96eb1f74a7e177fcf2b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwOWM1NzFlZWMxZmZmOTk2MzJmOTZlYjFmNzRhN2UxNzdmY2YyYjA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-23T09:00:25Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-23T16:04:13Z"}, "message": "avoid some borrow_mut calls in data_race", "tree": {"sha": "2e586d9cd81fbc2b7813c5607211b54695dcf735", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e586d9cd81fbc2b7813c5607211b54695dcf735"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e09c571eec1fff99632f96eb1f74a7e177fcf2b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e09c571eec1fff99632f96eb1f74a7e177fcf2b0", "html_url": "https://github.com/rust-lang/rust/commit/e09c571eec1fff99632f96eb1f74a7e177fcf2b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e09c571eec1fff99632f96eb1f74a7e177fcf2b0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "543777acbd9797118c5992e308335ab21dcd1fbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/543777acbd9797118c5992e308335ab21dcd1fbb", "html_url": "https://github.com/rust-lang/rust/commit/543777acbd9797118c5992e308335ab21dcd1fbb"}], "stats": {"total": 78, "additions": 41, "deletions": 37}, "files": [{"sha": "45159ef4c07c371c26e0a5651cc9e35f9c93cbbd", "filename": "src/data_race.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e09c571eec1fff99632f96eb1f74a7e177fcf2b0/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09c571eec1fff99632f96eb1f74a7e177fcf2b0/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=e09c571eec1fff99632f96eb1f74a7e177fcf2b0", "patch": "@@ -598,7 +598,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         // of the time, based on `rate`.\n         let rate = this.memory.extra.cmpxchg_weak_failure_rate;\n         let cmpxchg_success = eq.to_bool()?\n-            && (!can_fail_spuriously || this.memory.extra.rng.borrow_mut().gen::<f64>() < rate);\n+            && (!can_fail_spuriously || this.memory.extra.rng.get_mut().gen::<f64>() < rate);\n         let res = Immediate::ScalarPair(\n             old.to_scalar_or_uninit(),\n             Scalar::from_bool(cmpxchg_success).into(),\n@@ -647,7 +647,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         place: &MPlaceTy<'tcx, Tag>,\n         atomic: AtomicWriteOp,\n     ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_ref();\n+        let this = self.eval_context_mut();\n         this.validate_atomic_op(\n             place,\n             atomic,\n@@ -672,7 +672,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         use AtomicRwOp::*;\n         let acquire = matches!(atomic, Acquire | AcqRel | SeqCst);\n         let release = matches!(atomic, Release | AcqRel | SeqCst);\n-        let this = self.eval_context_ref();\n+        let this = self.eval_context_mut();\n         this.validate_atomic_op(place, atomic, \"Atomic RMW\", move |memory, clocks, index, _| {\n             if acquire {\n                 memory.load_acquire(clocks, index)?;\n@@ -690,7 +690,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// Update the data-race detector for an atomic fence on the current thread.\n     fn validate_atomic_fence(&mut self, atomic: AtomicFenceOp) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &mut this.memory.extra.data_race {\n             data_race.maybe_perform_sync_operation(move |index, mut clocks| {\n                 log::trace!(\"Atomic fence on {:?} with ordering {:?}\", index, atomic);\n \n@@ -771,7 +771,7 @@ impl VClockAlloc {\n     }\n \n     fn reset_clocks(&mut self, offset: Size, len: Size) {\n-        let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n+        let alloc_ranges = self.alloc_ranges.get_mut();\n         for (_, range) in alloc_ranges.iter_mut(offset, len) {\n             // Reset the portion of the range\n             *range = MemoryCellClocks::new(0, VectorIdx::MAX_INDEX);\n@@ -1025,6 +1025,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         if let Some(data_race) = &this.memory.extra.data_race {\n             if data_race.multi_threaded.get() {\n                 // Load and log the atomic operation.\n+                // Note that atomic loads are possible even from read-only allocations, so `get_alloc_extra_mut` is not an option.\n                 let place_ptr = place.ptr.assert_ptr();\n                 let size = place.layout.size;\n                 let alloc_meta =\n@@ -1105,6 +1106,7 @@ struct ThreadExtraState {\n /// Global data-race detection state, contains the currently\n /// executing thread as well as the vector-clocks associated\n /// with each of the threads.\n+// FIXME: it is probably better to have one large RefCell, than to have so many small ones.\n #[derive(Debug, Clone)]\n pub struct GlobalState {\n     /// Set to true once the first additional\n@@ -1158,7 +1160,7 @@ impl GlobalState {\n     /// Create a new global state, setup with just thread-id=0\n     /// advanced to timestamp = 1.\n     pub fn new() -> Self {\n-        let global_state = GlobalState {\n+        let mut global_state = GlobalState {\n             multi_threaded: Cell::new(false),\n             vector_clocks: RefCell::new(IndexVec::new()),\n             vector_info: RefCell::new(IndexVec::new()),\n@@ -1172,9 +1174,9 @@ impl GlobalState {\n         // Setup the main-thread since it is not explicitly created:\n         // uses vector index and thread-id 0, also the rust runtime gives\n         // the main-thread a name of \"main\".\n-        let index = global_state.vector_clocks.borrow_mut().push(ThreadClockSet::default());\n-        global_state.vector_info.borrow_mut().push(ThreadId::new(0));\n-        global_state.thread_info.borrow_mut().push(ThreadExtraState {\n+        let index = global_state.vector_clocks.get_mut().push(ThreadClockSet::default());\n+        global_state.vector_info.get_mut().push(ThreadId::new(0));\n+        global_state.thread_info.get_mut().push(ThreadExtraState {\n             vector_index: Some(index),\n             thread_name: Some(\"main\".to_string().into_boxed_str()),\n             termination_vector_clock: None,\n@@ -1221,7 +1223,7 @@ impl GlobalState {\n     // Hook for thread creation, enabled multi-threaded execution and marks\n     // the current thread timestamp as happening-before the current thread.\n     #[inline]\n-    pub fn thread_created(&self, thread: ThreadId) {\n+    pub fn thread_created(&mut self, thread: ThreadId) {\n         let current_index = self.current_index();\n \n         // Increment the number of active threads.\n@@ -1241,12 +1243,12 @@ impl GlobalState {\n         let created_index = if let Some(reuse_index) = self.find_vector_index_reuse_candidate() {\n             // Now re-configure the re-use candidate, increment the clock\n             // for the new sync use of the vector.\n-            let mut vector_clocks = self.vector_clocks.borrow_mut();\n+            let vector_clocks = self.vector_clocks.get_mut();\n             vector_clocks[reuse_index].increment_clock(reuse_index);\n \n             // Locate the old thread the vector was associated with and update\n             // it to represent the new thread instead.\n-            let mut vector_info = self.vector_info.borrow_mut();\n+            let vector_info = self.vector_info.get_mut();\n             let old_thread = vector_info[reuse_index];\n             vector_info[reuse_index] = thread;\n \n@@ -1258,7 +1260,7 @@ impl GlobalState {\n         } else {\n             // No vector re-use candidates available, instead create\n             // a new vector index.\n-            let mut vector_info = self.vector_info.borrow_mut();\n+            let vector_info = self.vector_info.get_mut();\n             vector_info.push(thread)\n         };\n \n@@ -1268,7 +1270,7 @@ impl GlobalState {\n         thread_info[thread].vector_index = Some(created_index);\n \n         // Create a thread clock set if applicable.\n-        let mut vector_clocks = self.vector_clocks.borrow_mut();\n+        let vector_clocks = self.vector_clocks.get_mut();\n         if created_index == vector_clocks.next_index() {\n             vector_clocks.push(ThreadClockSet::default());\n         }\n@@ -1289,9 +1291,9 @@ impl GlobalState {\n     /// Hook on a thread join to update the implicit happens-before relation\n     /// between the joined thread and the current thread.\n     #[inline]\n-    pub fn thread_joined(&self, current_thread: ThreadId, join_thread: ThreadId) {\n-        let mut clocks_vec = self.vector_clocks.borrow_mut();\n-        let thread_info = self.thread_info.borrow();\n+    pub fn thread_joined(&mut self, current_thread: ThreadId, join_thread: ThreadId) {\n+        let clocks_vec = self.vector_clocks.get_mut();\n+        let thread_info = self.thread_info.get_mut();\n \n         // Load the vector clock of the current thread.\n         let current_index = thread_info[current_thread]\n@@ -1329,9 +1331,9 @@ impl GlobalState {\n \n         // If the thread is marked as terminated but not joined\n         // then move the thread to the re-use set.\n-        let mut termination = self.terminated_threads.borrow_mut();\n+        let termination = self.terminated_threads.get_mut();\n         if let Some(index) = termination.remove(&join_thread) {\n-            let mut reuse = self.reuse_candidates.borrow_mut();\n+            let reuse = self.reuse_candidates.get_mut();\n             reuse.insert(index);\n         }\n     }\n@@ -1344,28 +1346,28 @@ impl GlobalState {\n     /// This should be called strictly before any calls to\n     /// `thread_joined`.\n     #[inline]\n-    pub fn thread_terminated(&self) {\n+    pub fn thread_terminated(&mut self) {\n         let current_index = self.current_index();\n \n         // Increment the clock to a unique termination timestamp.\n-        let mut vector_clocks = self.vector_clocks.borrow_mut();\n+        let vector_clocks = self.vector_clocks.get_mut();\n         let current_clocks = &mut vector_clocks[current_index];\n         current_clocks.increment_clock(current_index);\n \n         // Load the current thread id for the executing vector.\n-        let vector_info = self.vector_info.borrow();\n+        let vector_info = self.vector_info.get_mut();\n         let current_thread = vector_info[current_index];\n \n         // Load the current thread metadata, and move to a terminated\n         // vector state. Setting up the vector clock all join operations\n         // will use.\n-        let mut thread_info = self.thread_info.borrow_mut();\n+        let thread_info = self.thread_info.get_mut();\n         let current = &mut thread_info[current_thread];\n         current.termination_vector_clock = Some(current_clocks.clock.clone());\n \n         // Add this thread as a candidate for re-use after a thread join\n         // occurs.\n-        let mut termination = self.terminated_threads.borrow_mut();\n+        let termination = self.terminated_threads.get_mut();\n         termination.insert(current_thread, current_index);\n \n         // Reduce the number of active threads, now that a thread has\n@@ -1392,9 +1394,9 @@ impl GlobalState {\n     /// the thread name is used for improved diagnostics\n     /// during a data-race.\n     #[inline]\n-    pub fn thread_set_name(&self, thread: ThreadId, name: String) {\n+    pub fn thread_set_name(&mut self, thread: ThreadId, name: String) {\n         let name = name.into_boxed_str();\n-        let mut thread_info = self.thread_info.borrow_mut();\n+        let thread_info = self.thread_info.get_mut();\n         thread_info[thread].thread_name = Some(name);\n     }\n "}, {"sha": "4725cd9fc3c813feec5f0579e096a98519580e84", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e09c571eec1fff99632f96eb1f74a7e177fcf2b0/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09c571eec1fff99632f96eb1f74a7e177fcf2b0/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=e09c571eec1fff99632f96eb1f74a7e177fcf2b0", "patch": "@@ -58,7 +58,7 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n // (the kind has to be at its offset for compatibility with static initializer macros)\n \n fn mutex_get_kind<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };"}, {"sha": "7ee18bb7f80e28ce8cdcb02ca20fcd091c0d5a91", "filename": "src/thread.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e09c571eec1fff99632f96eb1f74a7e177fcf2b0/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09c571eec1fff99632f96eb1f74a7e177fcf2b0/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=e09c571eec1fff99632f96eb1f74a7e177fcf2b0", "patch": "@@ -332,7 +332,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     fn join_thread(\n         &mut self,\n         joined_thread_id: ThreadId,\n-        data_race: &Option<data_race::GlobalState>,\n+        data_race: Option<&mut data_race::GlobalState>,\n     ) -> InterpResult<'tcx> {\n         if self.threads[joined_thread_id].join_status != ThreadJoinStatus::Joinable {\n             throw_ub_format!(\"trying to join a detached or already joined thread\");\n@@ -436,7 +436,10 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Wakes up threads joining on the active one and deallocates thread-local statics.\n     /// The `AllocId` that can now be freed is returned.\n-    fn thread_terminated(&mut self, data_race: &Option<data_race::GlobalState>) -> Vec<AllocId> {\n+    fn thread_terminated(\n+        &mut self,\n+        mut data_race: Option<&mut data_race::GlobalState>,\n+    ) -> Vec<AllocId> {\n         let mut free_tls_statics = Vec::new();\n         {\n             let mut thread_local_statics = self.thread_local_alloc_ids.borrow_mut();\n@@ -452,14 +455,14 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             });\n         }\n         // Set the thread into a terminated state in the data-race detector\n-        if let Some(data_race) = data_race {\n+        if let Some(ref mut data_race) = data_race {\n             data_race.thread_terminated();\n         }\n         // Check if we need to unblock any threads.\n         for (i, thread) in self.threads.iter_enumerated_mut() {\n             if thread.state == ThreadState::BlockedOnJoin(self.active_thread) {\n                 // The thread has terminated, mark happens-before edge to joining thread\n-                if let Some(data_race) = data_race {\n+                if let Some(ref mut data_race) = data_race {\n                     data_race.thread_joined(i, self.active_thread);\n                 }\n                 trace!(\"unblocking {:?} because {:?} terminated\", i, self.active_thread);\n@@ -584,7 +587,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn create_thread(&mut self) -> ThreadId {\n         let this = self.eval_context_mut();\n         let id = this.machine.threads.create_thread();\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &mut this.memory.extra.data_race {\n             data_race.thread_created(id);\n         }\n         id\n@@ -599,8 +602,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn join_thread(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let data_race = &this.memory.extra.data_race;\n-        this.machine.threads.join_thread(joined_thread_id, data_race)?;\n+        this.machine.threads.join_thread(joined_thread_id, this.memory.extra.data_race.as_mut())?;\n         Ok(())\n     }\n \n@@ -664,7 +666,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) {\n         let this = self.eval_context_mut();\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &mut this.memory.extra.data_race {\n             if let Ok(string) = String::from_utf8(new_thread_name.clone()) {\n                 data_race.thread_set_name(this.machine.threads.active_thread, string);\n             }\n@@ -759,8 +761,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn thread_terminated(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let data_race = &this.memory.extra.data_race;\n-        for alloc_id in this.machine.threads.thread_terminated(data_race) {\n+        for alloc_id in this.machine.threads.thread_terminated(this.memory.extra.data_race.as_mut())\n+        {\n             let ptr = this.memory.global_base_pointer(alloc_id.into())?;\n             this.memory.deallocate(ptr, None, MiriMemoryKind::Tls.into())?;\n         }"}]}