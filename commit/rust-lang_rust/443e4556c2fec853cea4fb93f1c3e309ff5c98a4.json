{"sha": "443e4556c2fec853cea4fb93f1c3e309ff5c98a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0M2U0NTU2YzJmZWM4NTNjZWE0ZmI5M2YxYzNlMzA5ZmY1Yzk4YTQ=", "commit": {"author": {"name": "Devon Hollowood", "email": "devonhollowood@gmail.com", "date": "2015-11-23T05:48:19Z"}, "committer": {"name": "Devon Hollowood", "email": "devonhollowood@gmail.com", "date": "2015-11-26T07:56:45Z"}, "message": "Add lints suggesting map_or() and map_or_else()\n\nIn accordance with the latter lint, replace map().unwrap_or_else() in\nsrc/mut_mut.rs with map_or_else()", "tree": {"sha": "748cafe40427bebfc304373473b144a2b435ef3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/748cafe40427bebfc304373473b144a2b435ef3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/443e4556c2fec853cea4fb93f1c3e309ff5c98a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/443e4556c2fec853cea4fb93f1c3e309ff5c98a4", "html_url": "https://github.com/rust-lang/rust/commit/443e4556c2fec853cea4fb93f1c3e309ff5c98a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/443e4556c2fec853cea4fb93f1c3e309ff5c98a4/comments", "author": {"login": "devonhollowood", "id": 7864326, "node_id": "MDQ6VXNlcjc4NjQzMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/7864326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/devonhollowood", "html_url": "https://github.com/devonhollowood", "followers_url": "https://api.github.com/users/devonhollowood/followers", "following_url": "https://api.github.com/users/devonhollowood/following{/other_user}", "gists_url": "https://api.github.com/users/devonhollowood/gists{/gist_id}", "starred_url": "https://api.github.com/users/devonhollowood/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/devonhollowood/subscriptions", "organizations_url": "https://api.github.com/users/devonhollowood/orgs", "repos_url": "https://api.github.com/users/devonhollowood/repos", "events_url": "https://api.github.com/users/devonhollowood/events{/privacy}", "received_events_url": "https://api.github.com/users/devonhollowood/received_events", "type": "User", "site_admin": false}, "committer": {"login": "devonhollowood", "id": 7864326, "node_id": "MDQ6VXNlcjc4NjQzMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/7864326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/devonhollowood", "html_url": "https://github.com/devonhollowood", "followers_url": "https://api.github.com/users/devonhollowood/followers", "following_url": "https://api.github.com/users/devonhollowood/following{/other_user}", "gists_url": "https://api.github.com/users/devonhollowood/gists{/gist_id}", "starred_url": "https://api.github.com/users/devonhollowood/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/devonhollowood/subscriptions", "organizations_url": "https://api.github.com/users/devonhollowood/orgs", "repos_url": "https://api.github.com/users/devonhollowood/repos", "events_url": "https://api.github.com/users/devonhollowood/events{/privacy}", "received_events_url": "https://api.github.com/users/devonhollowood/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84ad2be1dfdc21ee64e1481b91ade1192c477847", "url": "https://api.github.com/repos/rust-lang/rust/commits/84ad2be1dfdc21ee64e1481b91ade1192c477847", "html_url": "https://github.com/rust-lang/rust/commit/84ad2be1dfdc21ee64e1481b91ade1192c477847"}], "stats": {"total": 150, "additions": 136, "deletions": 14}, "files": [{"sha": "0a10c849ca7756070627a14cf5e8629e46131edf", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/443e4556c2fec853cea4fb93f1c3e309ff5c98a4/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/443e4556c2fec853cea4fb93f1c3e309ff5c98a4/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=443e4556c2fec853cea4fb93f1c3e309ff5c98a4", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 77 lints included in this crate:\n+There are 79 lints included in this crate:\n \n name                                                                                                     | default | meaning\n ---------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -53,6 +53,8 @@ name\n [non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                   | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n [nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)     | warn    | nonsensical combination of options for opening a file\n [ok_expect](https://github.com/Manishearth/rust-clippy/wiki#ok_expect)                                   | warn    | using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\n+[option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)             | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`)\n+[option_map_unwrap_or_else](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else)   | warn    | using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`)\n [option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)                 | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n [precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                                 | warn    | catches operations where precedence may be unclear. See the wiki for a list of cases caught\n [ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                       | warn    | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively"}, {"sha": "12cb14f73554cc7aeb3507d9a90e6f3e9d2b050f", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/443e4556c2fec853cea4fb93f1c3e309ff5c98a4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/443e4556c2fec853cea4fb93f1c3e309ff5c98a4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=443e4556c2fec853cea4fb93f1c3e309ff5c98a4", "patch": "@@ -156,6 +156,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n         methods::OK_EXPECT,\n+        methods::OPTION_MAP_UNWRAP_OR,\n+        methods::OPTION_MAP_UNWRAP_OR_ELSE,\n         methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::STR_TO_STRING,\n         methods::STRING_TO_STRING,"}, {"sha": "f1b610c6211e9b71d70541ad8cc9ad2ac3481092", "filename": "src/methods.rs", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/443e4556c2fec853cea4fb93f1c3e309ff5c98a4/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/443e4556c2fec853cea4fb93f1c3e309ff5c98a4/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=443e4556c2fec853cea4fb93f1c3e309ff5c98a4", "patch": "@@ -5,7 +5,7 @@ use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n \n-use utils::{snippet, span_lint, match_path, match_type, walk_ptrs_ty_depth,\n+use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, walk_ptrs_ty_depth,\n     walk_ptrs_ty};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n@@ -34,12 +34,18 @@ declare_lint!(pub WRONG_PUB_SELF_CONVENTION, Allow,\n declare_lint!(pub OK_EXPECT, Warn,\n               \"using `ok().expect()`, which gives worse error messages than \\\n                calling `expect` directly on the Result\");\n-\n+declare_lint!(pub OPTION_MAP_UNWRAP_OR, Warn,\n+              \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as \\\n+               `map_or(a, f)`)\");\n+declare_lint!(pub OPTION_MAP_UNWRAP_OR_ELSE, Warn,\n+              \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as \\\n+               `map_or_else(g, f)`)\");\n \n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING,\n-                    SHOULD_IMPLEMENT_TRAIT, WRONG_SELF_CONVENTION, OK_EXPECT)\n+                    SHOULD_IMPLEMENT_TRAIT, WRONG_SELF_CONVENTION, OK_EXPECT, OPTION_MAP_UNWRAP_OR,\n+                    OPTION_MAP_UNWRAP_OR_ELSE)\n     }\n }\n \n@@ -92,6 +98,66 @@ impl LateLintPass for MethodsPass {\n                     }\n                 }\n             }\n+            // check Option.map(_).unwrap_or(_)\n+            else if name.node.as_str() == \"unwrap_or\" {\n+                if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n+                    if inner_name.node.as_str() == \"map\"\n+                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &OPTION_PATH) {\n+                        // lint message\n+                        let msg =\n+                            \"called `map(f).unwrap_or(a)` on an Option value. This can be done \\\n+                             more directly by calling `map_or(a, f)` instead\";\n+                        // get args to map() and unwrap_or()\n+                        let map_arg = snippet(cx, inner_args[1].span, \"..\");\n+                        let unwrap_arg = snippet(cx, args[1].span, \"..\");\n+                        // lint, with note if neither arg is > 1 line and both map() and\n+                        // unwrap_or() have the same span\n+                        let multiline = map_arg.lines().count() > 1\n+                                        || unwrap_arg.lines().count() > 1;\n+                        let same_span = inner_args[1].span.expn_id == args[1].span.expn_id;\n+                        if same_span && !multiline {\n+                            span_note_and_lint(\n+                                cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span,\n+                                &format!(\"replace this with map_or({1}, {0})\",\n+                                         map_arg, unwrap_arg)\n+                            );\n+                        }\n+                        else if same_span && multiline {\n+                            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n+                        };\n+                    }\n+                }\n+            }\n+            // check Option.map(_).unwrap_or_else(_)\n+            else if name.node.as_str() == \"unwrap_or_else\" {\n+                if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n+                    if inner_name.node.as_str() == \"map\"\n+                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &OPTION_PATH) {\n+                        // lint message\n+                        let msg =\n+                            \"called `map(f).unwrap_or_else(g)` on an Option value. This can be \\\n+                             done more directly by calling `map_or_else(g, f)` instead\";\n+                        // get args to map() and unwrap_or_else()\n+                        let map_arg = snippet(cx, inner_args[1].span, \"..\");\n+                        let unwrap_arg = snippet(cx, args[1].span, \"..\");\n+                        // lint, with note if neither arg is > 1 line and both map() and\n+                        // unwrap_or_else() have the same span\n+                        let multiline = map_arg.lines().count() > 1\n+                                        || unwrap_arg.lines().count() > 1;\n+                        let same_span = inner_args[1].span.expn_id == args[1].span.expn_id;\n+                        if same_span && !multiline {\n+                            span_note_and_lint(\n+                                cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg, expr.span,\n+                                &format!(\"replace this with map_or_else({1}, {0})\",\n+                                         map_arg, unwrap_arg)\n+                            );\n+                        }\n+                        else if same_span && multiline {\n+                            span_lint(cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg);\n+                        };\n+                    }\n+                }\n+            }\n         }\n     }\n "}, {"sha": "09ba7d781a26635f272baff68c2af001b6f7d8f0", "filename": "src/mut_mut.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/443e4556c2fec853cea4fb93f1c3e309ff5c98a4/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/443e4556c2fec853cea4fb93f1c3e309ff5c98a4/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=443e4556c2fec853cea4fb93f1c3e309ff5c98a4", "patch": "@@ -39,17 +39,20 @@ fn check_expr_mut(cx: &LateContext, expr: &Expr) {\n     }\n \n     unwrap_addr(expr).map_or((), |e| {\n-        unwrap_addr(e).map(|_| {\n-            span_lint(cx, MUT_MUT, expr.span,\n-                      \"generally you want to avoid `&mut &mut _` if possible\")\n-        }).unwrap_or_else(|| {\n-            if let TyRef(_, TypeAndMut{ty: _, mutbl: MutMutable}) =\n-                cx.tcx.expr_ty(e).sty {\n-                    span_lint(cx, MUT_MUT, expr.span,\n-                              \"this expression mutably borrows a mutable reference. \\\n-                               Consider reborrowing\")\n+        unwrap_addr(e).map_or_else(\n+            || {\n+                if let TyRef(_, TypeAndMut{ty: _, mutbl: MutMutable}) =\n+                    cx.tcx.expr_ty(e).sty {\n+                        span_lint(cx, MUT_MUT, expr.span,\n+                                  \"this expression mutably borrows a mutable reference. \\\n+                                   Consider reborrowing\")\n                 }\n-        })\n+            },\n+            |_| {\n+                span_lint(cx, MUT_MUT, expr.span,\n+                          \"generally you want to avoid `&mut &mut _` if possible\")\n+            }\n+        )\n     })\n }\n "}, {"sha": "9078a78d6fe13c7f239087dd71d93edd1ce5b969", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/443e4556c2fec853cea4fb93f1c3e309ff5c98a4/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/443e4556c2fec853cea4fb93f1c3e309ff5c98a4/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=443e4556c2fec853cea4fb93f1c3e309ff5c98a4", "patch": "@@ -34,6 +34,55 @@ impl Mul<T> for T {\n     fn mul(self, other: T) -> T { self } // no error, obviously\n }\n \n+/// Utility macro to test linting behavior in `option_methods()`\n+/// The lints included in `option_methods()` should not lint if the call to map is partially\n+/// within a macro\n+macro_rules! opt_map {\n+    ($opt:expr, $map:expr) => {($opt).map($map)};\n+}\n+\n+/// Checks implementation of the following lints:\n+/// OPTION_MAP_UNWRAP_OR\n+/// OPTION_MAP_UNWRAP_OR_ELSE\n+fn option_methods() {\n+    let opt = Some(1);\n+\n+    // Check OPTION_MAP_UNWRAP_OR\n+    // single line case\n+    let _ = opt.map(|x| x + 1) //~  ERROR called `map(f).unwrap_or(a)`\n+                               //~| NOTE replace this\n+               .unwrap_or(0); // should lint even though this call is on a separate line\n+    // multi line cases\n+    let _ = opt.map(|x| { //~ ERROR called `map(f).unwrap_or(a)`\n+                        x + 1\n+                    }\n+              ).unwrap_or(0);\n+    let _ = opt.map(|x| x + 1) //~ ERROR called `map(f).unwrap_or(a)`\n+               .unwrap_or({\n+                    0\n+                });\n+    // macro case\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or(0); // should not lint\n+\n+    // Check OPTION_MAP_UNWRAP_OR_ELSE\n+    // single line case\n+    let _ = opt.map(|x| x + 1) //~  ERROR called `map(f).unwrap_or_else(g)`\n+                               //~| NOTE replace this\n+               .unwrap_or_else(|| 0); // should lint even though this call is on a separate line\n+    // multi line cases\n+    let _ = opt.map(|x| { //~ ERROR called `map(f).unwrap_or_else(g)`\n+                        x + 1\n+                    }\n+              ).unwrap_or_else(|| 0);\n+    let _ = opt.map(|x| x + 1) //~ ERROR called `map(f).unwrap_or_else(g)`\n+               .unwrap_or_else(||\n+                    0\n+                );\n+    // macro case\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0); // should not lint\n+\n+}\n+\n fn main() {\n     use std::io;\n "}]}