{"sha": "7abab8aee09cdc8d23ec8fae5b5ec7675486aef0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYmFiOGFlZTA5Y2RjOGQyM2VjOGZhZTViNWVjNzY3NTQ4NmFlZjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-03T17:42:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-03T17:42:18Z"}, "message": "add a comment about optimality that somehow got removed", "tree": {"sha": "01d36e3888e850bb9226e18228391da327d13c6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01d36e3888e850bb9226e18228391da327d13c6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7abab8aee09cdc8d23ec8fae5b5ec7675486aef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7abab8aee09cdc8d23ec8fae5b5ec7675486aef0", "html_url": "https://github.com/rust-lang/rust/commit/7abab8aee09cdc8d23ec8fae5b5ec7675486aef0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7abab8aee09cdc8d23ec8fae5b5ec7675486aef0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afbf6c82464b6cf0e0b77d3f8458ae31ac38fd6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/afbf6c82464b6cf0e0b77d3f8458ae31ac38fd6e", "html_url": "https://github.com/rust-lang/rust/commit/afbf6c82464b6cf0e0b77d3f8458ae31ac38fd6e"}], "stats": {"total": 134, "additions": 76, "deletions": 58}, "files": [{"sha": "965c773597ede4b20144fbc56c320e3b5b11fb87", "filename": "src/librustc_incremental/persist/preds/compress/construct.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7abab8aee09cdc8d23ec8fae5b5ec7675486aef0/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abab8aee09cdc8d23ec8fae5b5ec7675486aef0/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fconstruct.rs?ref=7abab8aee09cdc8d23ec8fae5b5ec7675486aef0", "patch": "@@ -78,6 +78,18 @@ pub(super) fn construct_graph<'g, N, I, O>(r: &mut GraphReduce<'g, N, I, O>, dag\n     //\n     // Now if we were to remove Y, we would have a total of 8 edges: both WP0 and WP1\n     // depend on INPUT0...INPUT3. As it is, we have 6 edges.\n+    //\n+    // NB: The current rules are not optimal. For example, given this\n+    // input graph:\n+    //\n+    //     OUT0 -rf-> X\n+    //     OUT1 -rf-> X\n+    //     X -rf -> INPUT0\n+    //\n+    // we will preserve X because it has two \"consumers\" (OUT0 and\n+    // OUT1).  We could as easily skip it, but we'd have to tally up\n+    // the number of input nodes that it (transitively) reaches, and I\n+    // was too lazy to do so. This is the unit test `suboptimal`.\n \n     let mut retain_map = FxHashMap();\n     let mut new_graph = Graph::new();"}, {"sha": "be91677f4d14bf98c29d1d082b99f864b904066b", "filename": "src/librustc_incremental/persist/preds/compress/test.rs", "status": "modified", "additions": 64, "deletions": 58, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/7abab8aee09cdc8d23ec8fae5b5ec7675486aef0/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abab8aee09cdc8d23ec8fae5b5ec7675486aef0/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest.rs?ref=7abab8aee09cdc8d23ec8fae5b5ec7675486aef0", "patch": "@@ -151,62 +151,69 @@ fn test3() {\n     ]);\n }\n \n-//#[test]\n-//fn test_cached_dfs_cyclic() {\n-//\n-//    //    0       1 <---- 2       3\n-//    //    ^       |       ^       ^\n-//    //    |       v       |       |\n-//    //    4 ----> 5 ----> 6 ----> 7\n-//    //    ^       ^       ^       ^\n-//    //    |       |       |       |\n-//    //    8       9      10      11\n-//\n-//\n-//    let mut g: Graph<bool, ()> = Graph::new();\n-//    g.add_node(false);\n-//    g.add_node(false);\n-//    g.add_node(false);\n-//    g.add_node(false);\n-//    g.add_node(false);\n-//    g.add_node(false);\n-//    g.add_node(false);\n-//    g.add_node(false);\n-//    g.add_node(true);\n-//    g.add_node(true);\n-//    g.add_node(true);\n-//    g.add_node(true);\n-//\n-//    g.add_edge(NodeIndex( 4), NodeIndex(0), ());\n-//    g.add_edge(NodeIndex( 8), NodeIndex(4), ());\n-//    g.add_edge(NodeIndex( 4), NodeIndex(5), ());\n-//    g.add_edge(NodeIndex( 1), NodeIndex(5), ());\n-//    g.add_edge(NodeIndex( 9), NodeIndex(5), ());\n-//    g.add_edge(NodeIndex( 5), NodeIndex(6), ());\n-//    g.add_edge(NodeIndex( 6), NodeIndex(2), ());\n-//    g.add_edge(NodeIndex( 2), NodeIndex(1), ());\n-//    g.add_edge(NodeIndex(10), NodeIndex(6), ());\n-//    g.add_edge(NodeIndex( 6), NodeIndex(7), ());\n-//    g.add_edge(NodeIndex(11), NodeIndex(7), ());\n-//    g.add_edge(NodeIndex( 7), NodeIndex(3), ());\n-//\n-//    let mut ws1 = DfsWorkspace::new(g.len_nodes());\n-//    let mut ws2 = DfsWorkspace::new(g.len_nodes());\n-//    let mut visit_counts: Vec<_> = g.all_nodes().iter().map(|_| 0u32).collect();\n-//    let mut cache: Vec<Option<Box<[u32]>>> = g.all_nodes().iter().map(|_| None).collect();\n-//\n-//    fn is_root(x: &bool) -> bool { *x }\n-//\n-//    for _ in 0 .. CACHING_THRESHOLD + 1 {\n-//        find_roots(&g, 2, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n-//        ws1.output.nodes.sort();\n-//        assert_eq!(ws1.output.nodes, vec![8, 9, 10]);\n-//\n-//        find_roots(&g, 3, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n-//        ws1.output.nodes.sort();\n-//        assert_eq!(ws1.output.nodes, vec![8, 9, 10, 11]);\n-//    }\n-//}\n+#[test]\n+fn test_cached_dfs_cyclic() {\n+\n+    //    0       1 <---- 2       3\n+    //    ^       |       ^       ^\n+    //    |       v       |       |\n+    //    4 ----> 5 ----> 6 ----> 7\n+    //    ^       ^       ^       ^\n+    //    |       |       |       |\n+    //    8       9      10      11\n+\n+    let (graph, _nodes) = graph! {\n+        // edges from above diagram, in columns, top-to-bottom:\n+        n4 -> n0,\n+        n8 -> n4,\n+        n4 -> n5,\n+        n1 -> n5,\n+        n9 -> n5,\n+        n2 -> n1,\n+        n5 -> n6,\n+        n6 -> n2,\n+        n10 -> n6,\n+        n6 -> n7,\n+        n7 -> n3,\n+        n11 -> n7,\n+    };\n+\n+    //    0       1  2            3\n+    //    ^       ^ /             ^\n+    //    |       |/              |\n+    //    4 ----> 5 --------------+\n+    //    ^       ^ \\             |\n+    //    |       |  \\            |\n+    //    8       9   10         11\n+\n+    reduce(&graph, &[\"n8\", \"n9\", \"n10\", \"n11\"], &[\"n0\", \"n1\", \"n2\", \"n3\"], &[\n+        \"n10 -> n5\",\n+        \"n11 -> n3\",\n+        \"n4 -> n0\",\n+        \"n4 -> n5\",\n+        \"n5 -> n1\",\n+        \"n5 -> n2\",\n+        \"n5 -> n3\",\n+        \"n8 -> n4\",\n+        \"n9 -> n5\"\n+    ]);\n+}\n+\n+/// Demonstrates the case where we don't reduce as much as we could.\n+#[test]\n+fn suboptimal() {\n+    let (graph, _nodes) = graph! {\n+        INPUT0 -> X,\n+        X -> OUTPUT0,\n+        X -> OUTPUT1,\n+    };\n+\n+    reduce(&graph, &[\"INPUT0\"], &[\"OUTPUT0\", \"OUTPUT1\"], &[\n+        \"INPUT0 -> X\",\n+        \"X -> OUTPUT0\",\n+        \"X -> OUTPUT1\"\n+    ]);\n+}\n \n #[test]\n fn test_cycle_output() {\n@@ -229,7 +236,7 @@ fn test_cycle_output() {\n         D -> C1,\n     };\n \n-    // [A] -> [C0] <-> [D]\n+    // [A] -> [C0] --> [D]\n     //          +----> [E]\n     //                  ^\n     // [B] -------------+\n@@ -238,6 +245,5 @@ fn test_cycle_output() {\n         \"B -> E\",\n         \"C0 -> D\",\n         \"C0 -> E\",\n-        \"D -> C0\"\n     ]);\n }"}]}