{"sha": "d1b28b75d25d5f4c3d1769822a1b106b95b106f1", "node_id": "C_kwDOAAsO6NoAKGQxYjI4Yjc1ZDI1ZDVmNGMzZDE3Njk4MjJhMWIxMDZiOTViMTA2ZjE", "commit": {"author": {"name": "Trevor Gross", "email": "tmgross@umich.edu", "date": "2022-12-12T09:16:18Z"}, "committer": {"name": "Trevor Gross", "email": "tgross@intrepidcs.com", "date": "2023-03-29T22:04:44Z"}, "message": "Documentation updates to better share the purpose of OnceCell/OnceLock", "tree": {"sha": "917ab1932c5a35be335614d943a9ed7c3a6ab7c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/917ab1932c5a35be335614d943a9ed7c3a6ab7c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1b28b75d25d5f4c3d1769822a1b106b95b106f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1b28b75d25d5f4c3d1769822a1b106b95b106f1", "html_url": "https://github.com/rust-lang/rust/commit/d1b28b75d25d5f4c3d1769822a1b106b95b106f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1b28b75d25d5f4c3d1769822a1b106b95b106f1/comments", "author": {"login": "tgross35", "id": 13724985, "node_id": "MDQ6VXNlcjEzNzI0OTg1", "avatar_url": "https://avatars.githubusercontent.com/u/13724985?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgross35", "html_url": "https://github.com/tgross35", "followers_url": "https://api.github.com/users/tgross35/followers", "following_url": "https://api.github.com/users/tgross35/following{/other_user}", "gists_url": "https://api.github.com/users/tgross35/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgross35/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgross35/subscriptions", "organizations_url": "https://api.github.com/users/tgross35/orgs", "repos_url": "https://api.github.com/users/tgross35/repos", "events_url": "https://api.github.com/users/tgross35/events{/privacy}", "received_events_url": "https://api.github.com/users/tgross35/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgross35", "id": 13724985, "node_id": "MDQ6VXNlcjEzNzI0OTg1", "avatar_url": "https://avatars.githubusercontent.com/u/13724985?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgross35", "html_url": "https://github.com/tgross35", "followers_url": "https://api.github.com/users/tgross35/followers", "following_url": "https://api.github.com/users/tgross35/following{/other_user}", "gists_url": "https://api.github.com/users/tgross35/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgross35/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgross35/subscriptions", "organizations_url": "https://api.github.com/users/tgross35/orgs", "repos_url": "https://api.github.com/users/tgross35/repos", "events_url": "https://api.github.com/users/tgross35/events{/privacy}", "received_events_url": "https://api.github.com/users/tgross35/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc4ba57566acac492df2c2074d2d7144566dc7df", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4ba57566acac492df2c2074d2d7144566dc7df", "html_url": "https://github.com/rust-lang/rust/commit/dc4ba57566acac492df2c2074d2d7144566dc7df"}], "stats": {"total": 104, "additions": 76, "deletions": 28}, "files": [{"sha": "d378b0b3b977f4aa7175eb5029438f3e2a4751a6", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 68, "deletions": 25, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d1b28b75d25d5f4c3d1769822a1b106b95b106f1/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1b28b75d25d5f4c3d1769822a1b106b95b106f1/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=d1b28b75d25d5f4c3d1769822a1b106b95b106f1", "patch": "@@ -11,36 +11,77 @@\n //! mutate it.\n //!\n //! Shareable mutable containers exist to permit mutability in a controlled manner, even in the\n-//! presence of aliasing. Both [`Cell<T>`] and [`RefCell<T>`] allow doing this in a single-threaded\n-//! way. However, neither `Cell<T>` nor `RefCell<T>` are thread safe (they do not implement\n-//! [`Sync`]). If you need to do aliasing and mutation between multiple threads it is possible to\n-//! use [`Mutex<T>`], [`RwLock<T>`] or [`atomic`] types.\n+//! presence of aliasing. [`Cell<T>`], [`RefCell<T>`], and [`OnceCell<T>`] allow doing this in\n+//! a single-threaded way - they do not implement [`Sync`]. (If you need to do aliasing and\n+//! mutation among multiple threads, [`Mutex<T>`], [`RwLock<T>`], [`OnceLock<T>`] or [`atomic`]\n+//! types are the correct data structures to do so).\n //!\n-//! Values of the `Cell<T>` and `RefCell<T>` types may be mutated through shared references (i.e.\n-//! the common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`)\n-//! references. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast\n-//! with typical Rust types that exhibit 'inherited mutability'.\n+//! Values of the `Cell<T>`, `RefCell<T>`, and `OnceCell<T>` types may be mutated through shared\n+//! references (i.e. the common `&T` type), whereas most Rust types can only be mutated through\n+//! unique (`&mut T`) references. We say these cell types provide 'interior mutability'\n+//! (mutable via `&T`), in contrast with typical Rust types that exhibit 'inherited mutability'\n+//! (mutable only via `&mut T`).\n //!\n-//! Cell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` implements interior\n-//! mutability by moving values in and out of the `Cell<T>`. To use references instead of values,\n-//! one must use the `RefCell<T>` type, acquiring a write lock before mutating. `Cell<T>` provides\n-//! methods to retrieve and change the current interior value:\n+//! Cell types come in three flavors: `Cell<T>`, `RefCell<T>`, and `OnceCell<T>`. Each provides\n+//! a different way of providing safe interior mutability.\n+//!\n+//! ## `Cell<T>`\n+//!\n+//! [`Cell<T>`] implements interior mutability by moving values in and out of the cell. That is, an\n+//! `&mut T` to the inner value can never be obtained, and the value itself cannot be directly\n+//! obtained without replacing it with something else. Both of these rules ensure that there is\n+//! never more than one reference pointing to the inner value. This type provides the following\n+//! methods:\n //!\n //!  - For types that implement [`Copy`], the [`get`](Cell::get) method retrieves the current\n-//!    interior value.\n+//!    interior value by duplicating it.\n //!  - For types that implement [`Default`], the [`take`](Cell::take) method replaces the current\n //!    interior value with [`Default::default()`] and returns the replaced value.\n-//!  - For all types, the [`replace`](Cell::replace) method replaces the current interior value and\n-//!    returns the replaced value and the [`into_inner`](Cell::into_inner) method consumes the\n-//!    `Cell<T>` and returns the interior value. Additionally, the [`set`](Cell::set) method\n-//!    replaces the interior value, dropping the replaced value.\n+//!  - All types have:\n+//!    - [`replace`](Cell::replace): replaces the current interior value and returns the replaced\n+//!      value.\n+//!    - [`into_inner`](Cell::into_inner): this method consumes the `Cell<T>` and returns the\n+//!      interior value.\n+//!    - [`set`](Cell::set): this method replaces the interior value, dropping the replaced value.\n+//!\n+//! `Cell<T>` is typically used for more simple types where copying or moving values isn't too\n+//! resource intensive (e.g. numbers), and should usually be preferred over other cell types when\n+//! possible. For larger and non-copy types, `RefCell` provides some advantages.\n //!\n-//! `RefCell<T>` uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can\n+//! ## `RefCell<T>`\n+//!\n+//! [`RefCell<T>`] uses Rust's lifetimes to implement \"dynamic borrowing\", a process whereby one can\n //! claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are\n-//! tracked 'at runtime', unlike Rust's native reference types which are entirely tracked\n-//! statically, at compile time. Because `RefCell<T>` borrows are dynamic it is possible to attempt\n-//! to borrow a value that is already mutably borrowed; when this happens it results in thread\n-//! panic.\n+//! tracked at _runtime_, unlike Rust's native reference types which are entirely tracked\n+//! statically, at compile time.\n+//!\n+//! An immutable reference to a `RefCell`'s inner value (`&T`) can be obtained with\n+//! [`borrow`](`RefCell::borrow`), and a mutable borrow (`&mut T`) can be obtained with\n+//! [`borrow_mut`](`RefCell::borrow_mut`). When these functions are called, they first verify that\n+//! Rust's borrow rules will be satisfied: any number of immutable borrows are allowed or a\n+//! single immutable borrow is allowed, but never both. If a borrow is attempted that would violate\n+//! these rules, the thread will panic.\n+//!\n+//! The corresponding [`Sync`] version of `RefCell<T>` is [`RwLock<T>`].\n+//!\n+//! ## `OnceCell<T>`\n+//!\n+//! [`OnceCell<T>`] is somewhat of a hybrid of `Cell` and `RefCell` that works for values that\n+//! typically only need to be set once. This means that a reference `&T` can be obtained without\n+//! moving or copying the inner value (unlike `Cell`) but also without runtime checks (unlike\n+//! `RefCell`). However, its value can also not be updated once set unless you have a mutable\n+//! reference to the `OnceCell`.\n+//!\n+//! `OnceCell` provides the following methods:\n+//!\n+//! - [`get`](OnceCell::get): obtain a reference to the inner value\n+//! - [`set`](OnceCell::set): set the inner value if it is unset (returns a `Result`)\n+//! - [`get_or_init`](OnceCell::get_or_init): return the inner value, initializing it if needed\n+//! - [`get_mut`](OnceCell::get_mut): provide a mutable reference to the inner value, only available\n+//!   if you have a mutable reference to the cell itself.\n+//!\n+//! The corresponding [`Sync`] version of `OnceCell<T>` is [`OnceLock<T>`].\n+//!\n //!\n //! # When to choose interior mutability\n //!\n@@ -188,6 +229,8 @@\n //! [`Rc<T>`]: ../../std/rc/struct.Rc.html\n //! [`RwLock<T>`]: ../../std/sync/struct.RwLock.html\n //! [`Mutex<T>`]: ../../std/sync/struct.Mutex.html\n+//! [`OnceLock<T>`]: ../../std/sync/struct.OnceLock.html\n+//! [`Sync`]: ../../std/marker/trait.Sync.html\n //! [`atomic`]: crate::sync::atomic\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -419,7 +462,7 @@ impl<T> Cell<T> {\n         mem::replace(unsafe { &mut *self.value.get() }, val)\n     }\n \n-    /// Unwraps the value.\n+    /// Unwraps the value, consuming the cell.\n     ///\n     /// # Examples\n     ///\n@@ -1969,7 +2012,7 @@ impl<T> UnsafeCell<T> {\n         UnsafeCell { value }\n     }\n \n-    /// Unwraps the value.\n+    /// Unwraps the value, consuming the cell.\n     ///\n     /// # Examples\n     ///\n@@ -2133,7 +2176,7 @@ impl<T> SyncUnsafeCell<T> {\n         Self { value: UnsafeCell { value } }\n     }\n \n-    /// Unwraps the value.\n+    /// Unwraps the value, consuming the cell.\n     #[inline]\n     pub const fn into_inner(self) -> T {\n         self.value.into_inner()"}, {"sha": "5dc2d523198001716965ff28154486f3c561c182", "filename": "library/core/src/cell/once.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1b28b75d25d5f4c3d1769822a1b106b95b106f1/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1b28b75d25d5f4c3d1769822a1b106b95b106f1/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs?ref=d1b28b75d25d5f4c3d1769822a1b106b95b106f1", "patch": "@@ -4,8 +4,10 @@ use crate::mem;\n \n /// A cell which can be written to only once.\n ///\n-/// Unlike [`RefCell`], a `OnceCell` only provides shared `&T` references to its value.\n-/// Unlike [`Cell`], a `OnceCell` doesn't require copying or replacing the value to access it.\n+/// This allows obtaining a shared `&T` reference to its inner value without copying or replacing\n+/// it (unlike [`Cell`]), and without runtime borrow checks (unlike [`RefCell`]). However,\n+/// only immutable references can be obtained unless one has a mutable reference to the cell\n+/// itself.\n ///\n /// For a thread-safe version of this struct, see [`std::sync::OnceLock`].\n ///"}, {"sha": "19641753ffe1dcec8b397cdeab5e5c7784a48380", "filename": "library/std/src/sync/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1b28b75d25d5f4c3d1769822a1b106b95b106f1/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1b28b75d25d5f4c3d1769822a1b106b95b106f1/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs?ref=d1b28b75d25d5f4c3d1769822a1b106b95b106f1", "patch": "@@ -133,7 +133,9 @@\n //! - [`Mutex`]: Mutual Exclusion mechanism, which ensures that at\n //!   most one thread at a time is able to access some data.\n //!\n-//! - [`Once`]: Used for thread-safe, one-time initialization of a\n+//! - [`Once`]: Used for a thread-safe, one-time global initialization routine\n+//!\n+//! - [`OnceLock`]: Used for thread-safe, one-time initialization of a\n //!   global variable.\n //!\n //! - [`RwLock`]: Provides a mutual exclusion mechanism which allows\n@@ -147,6 +149,7 @@\n //! [`mpsc`]: crate::sync::mpsc\n //! [`Mutex`]: crate::sync::Mutex\n //! [`Once`]: crate::sync::Once\n+//! [`OnceLock`]: crate::sync::OnceLock\n //! [`RwLock`]: crate::sync::RwLock\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}]}