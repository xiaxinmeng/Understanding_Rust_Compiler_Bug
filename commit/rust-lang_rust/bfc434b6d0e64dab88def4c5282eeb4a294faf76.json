{"sha": "bfc434b6d0e64dab88def4c5282eeb4a294faf76", "node_id": "C_kwDOAAsO6NoAKGJmYzQzNGI2ZDBlNjRkYWI4OGRlZjRjNTI4MmVlYjRhMjk0ZmFmNzY", "commit": {"author": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2021-12-01T00:55:57Z"}, "committer": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2021-12-02T16:14:16Z"}, "message": "Reduce boilerplate around infallible folders", "tree": {"sha": "82df3c0e564f6e72abdc13b32b39c8a768dbd513", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82df3c0e564f6e72abdc13b32b39c8a768dbd513"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfc434b6d0e64dab88def4c5282eeb4a294faf76", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEm/Nz5g9hEBdpmKVOB8rDzKfgZD8FAmGo8NgACgkQB8rDzKfg\nZD/W2hAAghgbI66Okpzo4z1JhJfEKoqXGlxvFFHFlF6jM+A7CuX8XyHeOMr2eRz1\nuHU+VHlb5qFKyloE3OpN3vM32x7wAPkAxxA71pITnkLdpMq00X0QeyEqsOHR2rPc\nEduKM7KEhTbgvqauok4GdiuCkQtS+afNuhrJEsNt9xJaB2FnXuc5ahkRYFoUS9BQ\nQa57FvnJZAJCJyOlwm6s41l1Zrg3SHDAT0UJ2NjWa/8ib7f9nd5L1Jbxq0s69tjq\nwZqIitb7QsRbqgRNIY5q29mgTcVbtbHg3iqZGE090Oj4TKjrMp4Y9BkkuWiDY9Jc\ntAa4oLbsfzTHFIteQbrcHAFjmElIHOSyYtnjEFxoesXhr900n2Q+HxRqg9JPXxop\na7ZfpfNRw8UklyIOvprol61Y8KITDTBJFekIvGdkuHcA9tWE5mjSyxfQ8X1M7fy9\n3pappfOGP5KgF+/JJeHsAFuTP2lAi+akt/YretDcPqxrfRw7DBq+qCx71swxN9FB\nducxhb1MKjD3WCLknW6nmyA8HF0x0b5n4IR03ht5UA0BpLBmr82is7988B+SVUng\nMXZ04hYv78TwETzDRDi8lyZYe+nO37P4wpmJ7Z8ao3yFOI9FNhzpBUydouUUHxVJ\n8JEmKGcBEyFVRaq2GFDq/Ws8gAWW+c0xQohmCkUcVrOOAOYOZeE=\n=m82W\n-----END PGP SIGNATURE-----", "payload": "tree 82df3c0e564f6e72abdc13b32b39c8a768dbd513\nparent db7295fa960a729a4577e0e206f7a3a5a472addb\nauthor Alan Egerton <eggyal@gmail.com> 1638320157 +0000\ncommitter Alan Egerton <eggyal@gmail.com> 1638461656 +0000\n\nReduce boilerplate around infallible folders\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfc434b6d0e64dab88def4c5282eeb4a294faf76", "html_url": "https://github.com/rust-lang/rust/commit/bfc434b6d0e64dab88def4c5282eeb4a294faf76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfc434b6d0e64dab88def4c5282eeb4a294faf76/comments", "author": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db7295fa960a729a4577e0e206f7a3a5a472addb", "url": "https://api.github.com/repos/rust-lang/rust/commits/db7295fa960a729a4577e0e206f7a3a5a472addb", "html_url": "https://github.com/rust-lang/rust/commit/db7295fa960a729a4577e0e206f7a3a5a472addb"}], "stats": {"total": 1615, "additions": 893, "deletions": 722}, "files": [{"sha": "f308e764e861d0422e76464c39014aea20b59d09", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -23,7 +23,6 @@ Rust MIR: a lowered representation of Rust.\n #![feature(trusted_len)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n-#![feature(unwrap_infallible)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "b4bb6390db4860b69748b70b374314f98566c333", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -94,8 +94,7 @@ pub fn equal_up_to_regions(\n                 // Leave consts and types unchanged.\n                 ct_op: |ct| ct,\n                 ty_op: |ty| ty,\n-            })\n-            .into_ok(),\n+            }),\n         )\n     };\n     tcx.infer_ctxt().enter(|infcx| infcx.can_eq(param_env, normalize(src), normalize(dest)).is_ok())"}, {"sha": "934ada9932e71ad91d9b737b0ed38ff145696d17", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -278,7 +278,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> Result<ty::Binder<'tcx, T>, Self::Error>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -288,13 +288,13 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(index, ..) => {\n                 if index >= self.binder_index {\n                     bug!(\"escaping late-bound region during canonicalization\");\n                 } else {\n-                    Ok(r)\n+                    r\n                 }\n             }\n \n@@ -311,19 +311,19 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     vid, r\n                 );\n                 let r = self.tcx.reuse_or_mk_region(r, ty::ReVar(resolved_vid));\n-                Ok(self.canonicalize_region_mode.canonicalize_free_region(self, r))\n+                self.canonicalize_region_mode.canonicalize_free_region(self, r)\n             }\n \n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReErased => Ok(self.canonicalize_region_mode.canonicalize_free_region(self, r)),\n+            | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n             ty::Infer(ty::TyVar(vid)) => {\n                 debug!(\"canonical: type var found with vid {:?}\", vid);\n@@ -339,40 +339,40 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     Err(mut ui) => {\n                         // FIXME: perf problem described in #55921.\n                         ui = ty::UniverseIndex::ROOT;\n-                        Ok(self.canonicalize_ty_var(\n+                        self.canonicalize_ty_var(\n                             CanonicalVarInfo {\n                                 kind: CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n                             },\n                             t,\n-                        ))\n+                        )\n                     }\n                 }\n             }\n \n-            ty::Infer(ty::IntVar(_)) => Ok(self.canonicalize_ty_var(\n+            ty::Infer(ty::IntVar(_)) => self.canonicalize_ty_var(\n                 CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Int) },\n                 t,\n-            )),\n+            ),\n \n-            ty::Infer(ty::FloatVar(_)) => Ok(self.canonicalize_ty_var(\n+            ty::Infer(ty::FloatVar(_)) => self.canonicalize_ty_var(\n                 CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Float) },\n                 t,\n-            )),\n+            ),\n \n             ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"encountered a fresh type during canonicalization\")\n             }\n \n-            ty::Placeholder(placeholder) => Ok(self.canonicalize_ty_var(\n+            ty::Placeholder(placeholder) => self.canonicalize_ty_var(\n                 CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderTy(placeholder) },\n                 t,\n-            )),\n+            ),\n \n             ty::Bound(debruijn, _) => {\n                 if debruijn >= self.binder_index {\n                     bug!(\"escaping bound type during canonicalization\")\n                 } else {\n-                    Ok(t)\n+                    t\n                 }\n             }\n \n@@ -403,16 +403,13 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 if t.flags().intersects(self.needs_canonical_flags) {\n                     t.super_fold_with(self)\n                 } else {\n-                    Ok(t)\n+                    t\n                 }\n             }\n         }\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match ct.val {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                 debug!(\"canonical: const var found with vid {:?}\", vid);\n@@ -427,10 +424,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     Err(mut ui) => {\n                         // FIXME: perf problem described in #55921.\n                         ui = ty::UniverseIndex::ROOT;\n-                        return Ok(self.canonicalize_const_var(\n+                        return self.canonicalize_const_var(\n                             CanonicalVarInfo { kind: CanonicalVarKind::Const(ui) },\n                             ct,\n-                        ));\n+                        );\n                     }\n                 }\n             }\n@@ -441,20 +438,20 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 if debruijn >= self.binder_index {\n                     bug!(\"escaping bound type during canonicalization\")\n                 } else {\n-                    return Ok(ct);\n+                    return ct;\n                 }\n             }\n             ty::ConstKind::Placeholder(placeholder) => {\n-                return Ok(self.canonicalize_const_var(\n+                return self.canonicalize_const_var(\n                     CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderConst(placeholder) },\n                     ct,\n-                ));\n+                );\n             }\n             _ => {}\n         }\n \n         let flags = FlagComputation::for_const(ct);\n-        if flags.intersects(self.needs_canonical_flags) { ct.super_fold_with(self) } else { Ok(ct) }\n+        if flags.intersects(self.needs_canonical_flags) { ct.super_fold_with(self) } else { ct }\n     }\n }\n \n@@ -503,7 +500,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n             indices: FxHashMap::default(),\n             binder_index: ty::INNERMOST,\n         };\n-        let out_value = value.fold_with(&mut canonicalizer).into_ok();\n+        let out_value = value.fold_with(&mut canonicalizer);\n \n         // Once we have canonicalized `out_value`, it should not\n         // contain anything that ties it to this inference context\n@@ -621,7 +618,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         let infcx = self.infcx;\n         let bound_to = infcx.shallow_resolve(ty_var);\n         if bound_to != ty_var {\n-            self.fold_ty(bound_to).into_ok()\n+            self.fold_ty(bound_to)\n         } else {\n             let var = self.canonical_var(info, ty_var.into());\n             self.tcx().mk_ty(ty::Bound(self.binder_index, var.into()))\n@@ -640,12 +637,12 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         let infcx = self.infcx;\n         let bound_to = infcx.shallow_resolve(const_var);\n         if bound_to != const_var {\n-            self.fold_const(bound_to).into_ok()\n+            self.fold_const(bound_to)\n         } else {\n             let var = self.canonical_var(info, const_var.into());\n             self.tcx().mk_const(ty::Const {\n                 val: ty::ConstKind::Bound(self.binder_index, var),\n-                ty: self.fold_ty(const_var.ty).into_ok(),\n+                ty: self.fold_ty(const_var.ty),\n             })\n         }\n     }"}, {"sha": "c40e409891bc25cb76a7612fbab231493c67de98", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n         F: FnOnce(u32) -> ty::InferTy,\n     {\n         if let Some(ty) = opt_ty {\n-            return ty.fold_with(self).into_ok();\n+            return ty.fold_with(self);\n         }\n \n         match self.ty_freshen_map.entry(key) {\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n         F: FnOnce(u32) -> ty::InferConst<'tcx>,\n     {\n         if let Some(ct) = opt_ct {\n-            return ct.fold_with(self).into_ok();\n+            return ct.fold_with(self);\n         }\n \n         match self.const_freshen_map.entry(key) {\n@@ -119,11 +119,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(..) => {\n                 // leave bound regions alone\n-                Ok(r)\n+                r\n             }\n \n             ty::ReEarlyBound(..)\n@@ -133,32 +133,32 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // replace all free regions with 'erased\n-                Ok(self.tcx().lifetimes.re_erased)\n+                self.tcx().lifetimes.re_erased\n             }\n             ty::ReStatic => {\n                 if self.keep_static {\n-                    Ok(r)\n+                    r\n                 } else {\n-                    Ok(self.tcx().lifetimes.re_erased)\n+                    self.tcx().lifetimes.re_erased\n                 }\n             }\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !t.needs_infer() && !t.has_erasable_regions(self.tcx()) {\n-            return Ok(t);\n+            return t;\n         }\n \n         let tcx = self.infcx.tcx;\n \n         match *t.kind() {\n             ty::Infer(ty::TyVar(v)) => {\n                 let opt_ty = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n-                Ok(self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy))\n+                self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy)\n             }\n \n-            ty::Infer(ty::IntVar(v)) => Ok(self.freshen_ty(\n+            ty::Infer(ty::IntVar(v)) => self.freshen_ty(\n                 self.infcx\n                     .inner\n                     .borrow_mut()\n@@ -167,9 +167,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     .map(|v| v.to_type(tcx)),\n                 ty::IntVar(v),\n                 ty::FreshIntTy,\n-            )),\n+            ),\n \n-            ty::Infer(ty::FloatVar(v)) => Ok(self.freshen_ty(\n+            ty::Infer(ty::FloatVar(v)) => self.freshen_ty(\n                 self.infcx\n                     .inner\n                     .borrow_mut()\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     .map(|v| v.to_type(tcx)),\n                 ty::FloatVar(v),\n                 ty::FreshFloatTy,\n-            )),\n+            ),\n \n             ty::Infer(ty::FreshTy(ct) | ty::FreshIntTy(ct) | ty::FreshFloatTy(ct)) => {\n                 if ct >= self.ty_freshen_count {\n@@ -189,7 +189,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                         self.ty_freshen_count\n                     );\n                 }\n-                Ok(t)\n+                t\n             }\n \n             ty::Generator(..)\n@@ -221,10 +221,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match ct.val {\n             ty::ConstKind::Infer(ty::InferConst::Var(v)) => {\n                 let opt_ct = self\n@@ -235,12 +232,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     .probe_value(v)\n                     .val\n                     .known();\n-                return Ok(self.freshen_const(\n+                return self.freshen_const(\n                     opt_ct,\n                     ty::InferConst::Var(v),\n                     ty::InferConst::Fresh,\n                     ct.ty,\n-                ));\n+                );\n             }\n             ty::ConstKind::Infer(ty::InferConst::Fresh(i)) => {\n                 if i >= self.const_freshen_count {\n@@ -251,7 +248,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                         self.const_freshen_count,\n                     );\n                 }\n-                return Ok(ct);\n+                return ct;\n             }\n \n             ty::ConstKind::Bound(..) | ty::ConstKind::Placeholder(_) => {"}, {"sha": "773753a0363264400be63ce562bae19850ffa3e8", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -161,7 +161,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         {\n             Ok(value)\n         } else {\n-            Ok(value.fold_with(&mut fudger).into_ok())\n+            Ok(value.fold_with(&mut fudger))\n         }\n     }\n }\n@@ -180,15 +180,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match *ty.kind() {\n             ty::Infer(ty::InferTy::TyVar(vid)) => {\n                 if self.type_vars.0.contains(&vid) {\n                     // This variable was created during the fudging.\n                     // Recreate it with a fresh variable here.\n                     let idx = (vid.as_usize() - self.type_vars.0.start.as_usize()) as usize;\n                     let origin = self.type_vars.1[idx];\n-                    Ok(self.infcx.next_ty_var(origin))\n+                    self.infcx.next_ty_var(origin)\n                 } else {\n                     // This variable was created before the\n                     // \"fudging\". Since we refresh all type\n@@ -198,43 +198,48 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n                     debug_assert!(\n                         self.infcx.inner.borrow_mut().type_variables().probe(vid).is_unknown()\n                     );\n-                    Ok(ty)\n+                    ty\n                 }\n             }\n             ty::Infer(ty::InferTy::IntVar(vid)) => {\n-                Ok(if self.int_vars.contains(&vid) { self.infcx.next_int_var() } else { ty })\n+                if self.int_vars.contains(&vid) {\n+                    self.infcx.next_int_var()\n+                } else {\n+                    ty\n+                }\n             }\n             ty::Infer(ty::InferTy::FloatVar(vid)) => {\n-                Ok(if self.float_vars.contains(&vid) { self.infcx.next_float_var() } else { ty })\n+                if self.float_vars.contains(&vid) {\n+                    self.infcx.next_float_var()\n+                } else {\n+                    ty\n+                }\n             }\n             _ => ty.super_fold_with(self),\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         if let ty::ReVar(vid) = *r {\n             if self.region_vars.0.contains(&vid) {\n                 let idx = vid.index() - self.region_vars.0.start.index();\n                 let origin = self.region_vars.1[idx];\n-                return Ok(self.infcx.next_region_var(origin));\n+                return self.infcx.next_region_var(origin);\n             }\n         }\n-        Ok(r)\n+        r\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ty::Const { val: ty::ConstKind::Infer(ty::InferConst::Var(vid)), ty } = ct {\n             if self.const_vars.0.contains(&vid) {\n                 // This variable was created during the fudging.\n                 // Recreate it with a fresh variable here.\n                 let idx = (vid.index - self.const_vars.0.start.index) as usize;\n                 let origin = self.const_vars.1[idx];\n-                Ok(self.infcx.next_const_var(ty, origin))\n+                self.infcx.next_const_var(ty, origin)\n             } else {\n-                Ok(ct)\n+                ct\n             }\n         } else {\n             ct.super_fold_with(self)"}, {"sha": "2fd01c2d595fabe187d8019f1ad04f757b093976", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -681,7 +681,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n-        t.fold_with(&mut self.freshener()).into_ok()\n+        t.fold_with(&mut self.freshener())\n     }\n \n     /// Returns the origin of the type variable identified by `vid`, or `None`\n@@ -1381,7 +1381,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        value.fold_with(&mut ShallowResolver { infcx: self }).into_ok()\n+        value.fold_with(&mut ShallowResolver { infcx: self })\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n@@ -1402,7 +1402,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return value; // Avoid duplicated subst-folding.\n         }\n         let mut r = resolve::OpportunisticVarResolver::new(self);\n-        value.fold_with(&mut r).into_ok()\n+        value.fold_with(&mut r)\n     }\n \n     /// Returns the first unresolved variable contained in `T`. In the\n@@ -1745,15 +1745,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n-        Ok(self.infcx.shallow_resolve_ty(ty))\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.infcx.shallow_resolve_ty(ty)\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-        Ok(if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n             self.infcx\n                 .inner\n                 .borrow_mut()\n@@ -1764,7 +1761,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n                 .unwrap_or(ct)\n         } else {\n             ct\n-        })\n+        }\n     }\n }\n "}, {"sha": "89c14bcc2ce2bd76beac8d879eddfac2f3e73afa", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 94, "deletions": 99, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -418,94 +418,91 @@ struct Instantiator<'a, 'tcx> {\n impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n     fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n         let tcx = self.infcx.tcx;\n-        value\n-            .fold_with(&mut BottomUpFolder {\n-                tcx,\n-                ty_op: |ty| {\n-                    if ty.references_error() {\n-                        return tcx.ty_error();\n-                    } else if let ty::Opaque(def_id, substs) = ty.kind() {\n-                        // Check that this is `impl Trait` type is\n-                        // declared by `parent_def_id` -- i.e., one whose\n-                        // value we are inferring.  At present, this is\n-                        // always true during the first phase of\n-                        // type-check, but not always true later on during\n-                        // NLL. Once we support named opaque types more fully,\n-                        // this same scenario will be able to arise during all phases.\n-                        //\n-                        // Here is an example using type alias `impl Trait`\n-                        // that indicates the distinction we are checking for:\n-                        //\n-                        // ```rust\n-                        // mod a {\n-                        //   pub type Foo = impl Iterator;\n-                        //   pub fn make_foo() -> Foo { .. }\n-                        // }\n-                        //\n-                        // mod b {\n-                        //   fn foo() -> a::Foo { a::make_foo() }\n-                        // }\n-                        // ```\n-                        //\n-                        // Here, the return type of `foo` references an\n-                        // `Opaque` indeed, but not one whose value is\n-                        // presently being inferred. You can get into a\n-                        // similar situation with closure return types\n-                        // today:\n-                        //\n-                        // ```rust\n-                        // fn foo() -> impl Iterator { .. }\n-                        // fn bar() {\n-                        //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                        // }\n-                        // ```\n-                        if let Some(def_id) = def_id.as_local() {\n-                            let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                            let parent_def_id = self.infcx.defining_use_anchor;\n-                            let def_scope_default = || {\n-                                let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                                parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n-                            };\n-                            let (in_definition_scope, origin) =\n-                                match tcx.hir().expect_item(def_id).kind {\n-                                    // Anonymous `impl Trait`\n-                                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                        impl_trait_fn: Some(parent),\n-                                        origin,\n-                                        ..\n-                                    }) => (parent == parent_def_id.to_def_id(), origin),\n-                                    // Named `type Foo = impl Bar;`\n-                                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                        impl_trait_fn: None,\n-                                        origin,\n-                                        ..\n-                                    }) => (\n-                                        may_define_opaque_type(tcx, parent_def_id, opaque_hir_id),\n-                                        origin,\n-                                    ),\n-                                    _ => (def_scope_default(), hir::OpaqueTyOrigin::TyAlias),\n-                                };\n-                            if in_definition_scope {\n-                                let opaque_type_key =\n-                                    OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                                return self.fold_opaque_ty(ty, opaque_type_key, origin);\n+        value.fold_with(&mut BottomUpFolder {\n+            tcx,\n+            ty_op: |ty| {\n+                if ty.references_error() {\n+                    return tcx.ty_error();\n+                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n+                    // Check that this is `impl Trait` type is\n+                    // declared by `parent_def_id` -- i.e., one whose\n+                    // value we are inferring.  At present, this is\n+                    // always true during the first phase of\n+                    // type-check, but not always true later on during\n+                    // NLL. Once we support named opaque types more fully,\n+                    // this same scenario will be able to arise during all phases.\n+                    //\n+                    // Here is an example using type alias `impl Trait`\n+                    // that indicates the distinction we are checking for:\n+                    //\n+                    // ```rust\n+                    // mod a {\n+                    //   pub type Foo = impl Iterator;\n+                    //   pub fn make_foo() -> Foo { .. }\n+                    // }\n+                    //\n+                    // mod b {\n+                    //   fn foo() -> a::Foo { a::make_foo() }\n+                    // }\n+                    // ```\n+                    //\n+                    // Here, the return type of `foo` references an\n+                    // `Opaque` indeed, but not one whose value is\n+                    // presently being inferred. You can get into a\n+                    // similar situation with closure return types\n+                    // today:\n+                    //\n+                    // ```rust\n+                    // fn foo() -> impl Iterator { .. }\n+                    // fn bar() {\n+                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                    // }\n+                    // ```\n+                    if let Some(def_id) = def_id.as_local() {\n+                        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+                        let parent_def_id = self.infcx.defining_use_anchor;\n+                        let def_scope_default = || {\n+                            let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n+                            parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n+                        };\n+                        let (in_definition_scope, origin) = match tcx.hir().expect_item(def_id).kind\n+                        {\n+                            // Anonymous `impl Trait`\n+                            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                                impl_trait_fn: Some(parent),\n+                                origin,\n+                                ..\n+                            }) => (parent == parent_def_id.to_def_id(), origin),\n+                            // Named `type Foo = impl Bar;`\n+                            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                                impl_trait_fn: None,\n+                                origin,\n+                                ..\n+                            }) => {\n+                                (may_define_opaque_type(tcx, parent_def_id, opaque_hir_id), origin)\n                             }\n+                            _ => (def_scope_default(), hir::OpaqueTyOrigin::TyAlias),\n+                        };\n+                        if in_definition_scope {\n+                            let opaque_type_key =\n+                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n+                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n+                        }\n \n-                            debug!(\n-                                \"instantiate_opaque_types_in_map: \\\n+                        debug!(\n+                            \"instantiate_opaque_types_in_map: \\\n                              encountered opaque outside its definition scope \\\n                              def_id={:?}\",\n-                                def_id,\n-                            );\n-                        }\n+                            def_id,\n+                        );\n                     }\n+                }\n \n-                    ty\n-                },\n-                lt_op: |lt| lt,\n-                ct_op: |ct| ct,\n-            })\n-            .into_ok()\n+                ty\n+            },\n+            lt_op: |lt| lt,\n+            ct_op: |ct| ct,\n+        })\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -558,23 +555,21 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             debug!(?predicate);\n \n             // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n-            let predicate = predicate\n-                .fold_with(&mut BottomUpFolder {\n-                    tcx,\n-                    ty_op: |ty| match ty.kind() {\n-                        ty::Projection(projection_ty) => infcx.infer_projection(\n-                            self.param_env,\n-                            *projection_ty,\n-                            traits::ObligationCause::misc(self.value_span, self.body_id),\n-                            0,\n-                            &mut self.obligations,\n-                        ),\n-                        _ => ty,\n-                    },\n-                    lt_op: |lt| lt,\n-                    ct_op: |ct| ct,\n-                })\n-                .into_ok();\n+            let predicate = predicate.fold_with(&mut BottomUpFolder {\n+                tcx,\n+                ty_op: |ty| match ty.kind() {\n+                    ty::Projection(projection_ty) => infcx.infer_projection(\n+                        self.param_env,\n+                        *projection_ty,\n+                        traits::ObligationCause::misc(self.value_span, self.body_id),\n+                        0,\n+                        &mut self.obligations,\n+                    ),\n+                    _ => ty,\n+                },\n+                lt_op: |lt| lt,\n+                ct_op: |ct| ct,\n+            });\n             debug!(?predicate);\n \n             if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {"}, {"sha": "141e3353fb9847c8f4c071f9d09ddda7243ec5dd", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -1,7 +1,7 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::{FixupError, FixupResult, InferCtxt, Span};\n use rustc_middle::mir;\n-use rustc_middle::ty::fold::{TypeFolder, TypeVisitor};\n+use rustc_middle::ty::fold::{TypeFolder, TypeFolderFallible, TypeVisitor};\n use rustc_middle::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable};\n \n use std::ops::ControlFlow;\n@@ -30,28 +30,25 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !t.has_infer_types_or_consts() {\n-            Ok(t) // micro-optimize -- if there is nothing in this type that this fold affects...\n+            t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             t.super_fold_with(self)\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> Result<&'tcx Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> &'tcx Const<'tcx> {\n         if !ct.has_infer_types_or_consts() {\n-            Ok(ct) // micro-optimize -- if there is nothing in this const that this fold affects...\n+            ct // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let ct = self.infcx.shallow_resolve(ct);\n             ct.super_fold_with(self)\n         }\n     }\n \n-    fn fold_mir_const(\n-        &mut self,\n-        constant: mir::ConstantKind<'tcx>,\n-    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n+    fn fold_mir_const(&mut self, constant: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n         constant.super_fold_with(self)\n     }\n }\n@@ -78,16 +75,16 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticRegionResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !t.has_infer_regions() {\n-            Ok(t) // micro-optimize -- if there is nothing in this type that this fold affects...\n+            t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             t.super_fold_with(self)\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n-        Ok(match *r {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n             ty::ReVar(rid) => {\n                 let resolved = self\n                     .infcx\n@@ -98,15 +95,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticRegionResolver<'a, 'tcx> {\n                 self.tcx().reuse_or_mk_region(r, ty::ReVar(resolved))\n             }\n             _ => r,\n-        })\n+        }\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if !ct.has_infer_regions() {\n-            Ok(ct) // micro-optimize -- if there is nothing in this const that this fold affects...\n+            ct // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             ct.super_fold_with(self)\n         }\n@@ -181,7 +175,7 @@ pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>, value: T) -> Fixu\n where\n     T: TypeFoldable<'tcx>,\n {\n-    value.fold_with(&mut FullTypeResolver { infcx })\n+    value.try_fold_with(&mut FullTypeResolver { infcx })\n }\n \n // N.B. This type is not public because the protocol around checking the\n@@ -196,8 +190,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n+}\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+impl<'a, 'tcx> TypeFolderFallible<'tcx> for FullTypeResolver<'a, 'tcx> {\n+    fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !t.needs_infer() {\n             Ok(t) // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n@@ -209,12 +205,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                 ty::Infer(_) => {\n                     bug!(\"Unexpected type in full type resolver: {:?}\", t);\n                 }\n-                _ => t.super_fold_with(self),\n+                _ => t.try_super_fold_with(self),\n             }\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReVar(rid) => Ok(self\n                 .infcx\n@@ -227,7 +223,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_const(\n+    fn try_fold_const(\n         &mut self,\n         c: &'tcx ty::Const<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n@@ -244,7 +240,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                 }\n                 _ => {}\n             }\n-            c.super_fold_with(self)\n+            c.try_super_fold_with(self)\n         }\n     }\n }"}, {"sha": "e4b407e7c112d838057df364b0d4de3c1f13e5d3", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -24,7 +24,6 @@\n #![feature(control_flow_enum)]\n #![feature(min_specialization)]\n #![feature(label_break_value)]\n-#![feature(unwrap_infallible)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "821901dad2b5b7aa7ab44c337c6c8ce72d62892a", "filename": "compiler/rustc_infer/src/traits/structural_impls.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -1,7 +1,7 @@\n use crate::traits;\n use crate::traits::project::Normalized;\n use rustc_middle::ty;\n-use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolderFallible, TypeVisitor};\n \n use std::fmt;\n use std::ops::ControlFlow;\n@@ -60,12 +60,15 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n // TypeFoldable implementations.\n \n impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(traits::Obligation {\n             cause: self.cause,\n             recursion_depth: self.recursion_depth,\n-            predicate: self.predicate.fold_with(folder)?,\n-            param_env: self.param_env.fold_with(folder)?,\n+            predicate: self.predicate.try_fold_with(folder)?,\n+            param_env: self.param_env.try_fold_with(folder)?,\n         })\n     }\n "}, {"sha": "6a117a09597ce06e471579a01199166a51eb71b1", "filename": "compiler/rustc_macros/src/type_foldable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -17,15 +17,15 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n         vi.construct(|_, index| {\n             let bind = &bindings[index];\n             quote! {\n-                ::rustc_middle::ty::fold::TypeFoldable::fold_with(#bind, __folder)?\n+                ::rustc_middle::ty::fold::TypeFoldable::try_fold_with(#bind, __folder)?\n             }\n         })\n     });\n \n     s.bound_impl(\n         quote!(::rustc_middle::ty::fold::TypeFoldable<'tcx>),\n         quote! {\n-            fn super_fold_with<__F: ::rustc_middle::ty::fold::TypeFolder<'tcx>>(\n+            fn try_super_fold_with<__F: ::rustc_middle::ty::fold::TypeFolderFallible<'tcx>>(\n                 self,\n                 __folder: &mut __F\n             ) -> Result<Self, __F::Error> {"}, {"sha": "a2f1218650b566b97451628887400fd22bd44277", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -52,7 +52,7 @@ macro_rules! TrivialTypeFoldableImpls {\n     (for <$tcx:lifetime> { $($ty:ty,)+ }) => {\n         $(\n             impl<$tcx> $crate::ty::fold::TypeFoldable<$tcx> for $ty {\n-                fn super_fold_with<F: $crate::ty::fold::TypeFolder<$tcx>>(\n+                fn try_super_fold_with<F: $crate::ty::fold::TypeFolderFallible<$tcx>>(\n                     self,\n                     _: &mut F\n                 ) -> ::std::result::Result<$ty, F::Error> {\n@@ -95,7 +95,7 @@ macro_rules! EnumTypeFoldableImpl {\n         impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n             $(where $($wc)*)*\n         {\n-            fn super_fold_with<V: $crate::ty::fold::TypeFolder<$tcx>>(\n+            fn try_super_fold_with<V: $crate::ty::fold::TypeFolderFallible<$tcx>>(\n                 self,\n                 folder: &mut V,\n             ) -> ::std::result::Result<Self, V::Error> {\n@@ -126,7 +126,7 @@ macro_rules! EnumTypeFoldableImpl {\n                 output(\n                     $variant ( $($variant_arg),* ) => {\n                         $variant (\n-                            $($crate::ty::fold::TypeFoldable::fold_with($variant_arg, $folder)?),*\n+                            $($crate::ty::fold::TypeFoldable::try_fold_with($variant_arg, $folder)?),*\n                         )\n                     }\n                     $($output)*"}, {"sha": "ac129559c8e62f0f2e36d2dc64e8d05b26174ec4", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -7,7 +7,7 @@ use crate::mir::interpret::{Allocation, ConstValue, GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n-use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::fold::{TypeFoldable, TypeFolderFallible, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{self, List, Ty, TyCtxt};\n@@ -2760,10 +2760,13 @@ impl UserTypeProjection {\n TrivialTypeFoldableAndLiftImpls! { ProjectionKind, }\n \n impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(UserTypeProjection {\n-            base: self.base.fold_with(folder)?,\n-            projs: self.projs.fold_with(folder)?,\n+            base: self.base.try_fold_with(folder)?,\n+            projs: self.projs.try_fold_with(folder)?,\n         })\n     }\n "}, {"sha": "4f38be54f2f78395c437544c88f67b281340eea7", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 96, "deletions": 64, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -16,39 +16,42 @@ TrivialTypeFoldableAndLiftImpls! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         use crate::mir::TerminatorKind::*;\n \n         let kind = match self.kind {\n             Goto { target } => Goto { target },\n             SwitchInt { discr, switch_ty, targets } => SwitchInt {\n-                discr: discr.fold_with(folder)?,\n-                switch_ty: switch_ty.fold_with(folder)?,\n+                discr: discr.try_fold_with(folder)?,\n+                switch_ty: switch_ty.try_fold_with(folder)?,\n                 targets,\n             },\n             Drop { place, target, unwind } => {\n-                Drop { place: place.fold_with(folder)?, target, unwind }\n+                Drop { place: place.try_fold_with(folder)?, target, unwind }\n             }\n             DropAndReplace { place, value, target, unwind } => DropAndReplace {\n-                place: place.fold_with(folder)?,\n-                value: value.fold_with(folder)?,\n+                place: place.try_fold_with(folder)?,\n+                value: value.try_fold_with(folder)?,\n                 target,\n                 unwind,\n             },\n             Yield { value, resume, resume_arg, drop } => Yield {\n-                value: value.fold_with(folder)?,\n+                value: value.try_fold_with(folder)?,\n                 resume,\n-                resume_arg: resume_arg.fold_with(folder)?,\n+                resume_arg: resume_arg.try_fold_with(folder)?,\n                 drop,\n             },\n             Call { func, args, destination, cleanup, from_hir_call, fn_span } => {\n                 let dest = destination\n-                    .map(|(loc, dest)| (loc.fold_with(folder).map(|loc| (loc, dest))))\n+                    .map(|(loc, dest)| (loc.try_fold_with(folder).map(|loc| (loc, dest))))\n                     .transpose()?;\n \n                 Call {\n-                    func: func.fold_with(folder)?,\n-                    args: args.fold_with(folder)?,\n+                    func: func.try_fold_with(folder)?,\n+                    args: args.try_fold_with(folder)?,\n                     destination: dest,\n                     cleanup,\n                     from_hir_call,\n@@ -58,16 +61,19 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             Assert { cond, expected, msg, target, cleanup } => {\n                 use AssertKind::*;\n                 let msg = match msg {\n-                    BoundsCheck { len, index } => {\n-                        BoundsCheck { len: len.fold_with(folder)?, index: index.fold_with(folder)? }\n+                    BoundsCheck { len, index } => BoundsCheck {\n+                        len: len.try_fold_with(folder)?,\n+                        index: index.try_fold_with(folder)?,\n+                    },\n+                    Overflow(op, l, r) => {\n+                        Overflow(op, l.try_fold_with(folder)?, r.try_fold_with(folder)?)\n                     }\n-                    Overflow(op, l, r) => Overflow(op, l.fold_with(folder)?, r.fold_with(folder)?),\n-                    OverflowNeg(op) => OverflowNeg(op.fold_with(folder)?),\n-                    DivisionByZero(op) => DivisionByZero(op.fold_with(folder)?),\n-                    RemainderByZero(op) => RemainderByZero(op.fold_with(folder)?),\n+                    OverflowNeg(op) => OverflowNeg(op.try_fold_with(folder)?),\n+                    DivisionByZero(op) => DivisionByZero(op.try_fold_with(folder)?),\n+                    RemainderByZero(op) => RemainderByZero(op.try_fold_with(folder)?),\n                     ResumedAfterReturn(_) | ResumedAfterPanic(_) => msg,\n                 };\n-                Assert { cond: cond.fold_with(folder)?, expected, msg, target, cleanup }\n+                Assert { cond: cond.try_fold_with(folder)?, expected, msg, target, cleanup }\n             }\n             GeneratorDrop => GeneratorDrop,\n             Resume => Resume,\n@@ -80,7 +86,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n             InlineAsm { template, operands, options, line_spans, destination } => InlineAsm {\n                 template,\n-                operands: operands.fold_with(folder)?,\n+                operands: operands.try_fold_with(folder)?,\n                 options,\n                 line_spans,\n                 destination,\n@@ -142,7 +148,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n \n@@ -152,10 +158,13 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(Place {\n-            local: self.local.fold_with(folder)?,\n-            projection: self.projection.fold_with(folder)?,\n+            local: self.local.try_fold_with(folder)?,\n+            projection: self.projection.try_fold_with(folder)?,\n         })\n     }\n \n@@ -166,7 +175,10 @@ impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_place_elems(v))\n     }\n \n@@ -176,48 +188,56 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         use crate::mir::Rvalue::*;\n         Ok(match self {\n-            Use(op) => Use(op.fold_with(folder)?),\n-            Repeat(op, len) => Repeat(op.fold_with(folder)?, len.fold_with(folder)?),\n-            ThreadLocalRef(did) => ThreadLocalRef(did.fold_with(folder)?),\n-            Ref(region, bk, place) => Ref(region.fold_with(folder)?, bk, place.fold_with(folder)?),\n-            AddressOf(mutability, place) => AddressOf(mutability, place.fold_with(folder)?),\n-            Len(place) => Len(place.fold_with(folder)?),\n-            Cast(kind, op, ty) => Cast(kind, op.fold_with(folder)?, ty.fold_with(folder)?),\n-            BinaryOp(op, box (rhs, lhs)) => {\n-                BinaryOp(op, Box::new((rhs.fold_with(folder)?, lhs.fold_with(folder)?)))\n+            Use(op) => Use(op.try_fold_with(folder)?),\n+            Repeat(op, len) => Repeat(op.try_fold_with(folder)?, len.try_fold_with(folder)?),\n+            ThreadLocalRef(did) => ThreadLocalRef(did.try_fold_with(folder)?),\n+            Ref(region, bk, place) => {\n+                Ref(region.try_fold_with(folder)?, bk, place.try_fold_with(folder)?)\n             }\n-            CheckedBinaryOp(op, box (rhs, lhs)) => {\n-                CheckedBinaryOp(op, Box::new((rhs.fold_with(folder)?, lhs.fold_with(folder)?)))\n+            AddressOf(mutability, place) => AddressOf(mutability, place.try_fold_with(folder)?),\n+            Len(place) => Len(place.try_fold_with(folder)?),\n+            Cast(kind, op, ty) => Cast(kind, op.try_fold_with(folder)?, ty.try_fold_with(folder)?),\n+            BinaryOp(op, box (rhs, lhs)) => {\n+                BinaryOp(op, Box::new((rhs.try_fold_with(folder)?, lhs.try_fold_with(folder)?)))\n             }\n-            UnaryOp(op, val) => UnaryOp(op, val.fold_with(folder)?),\n-            Discriminant(place) => Discriminant(place.fold_with(folder)?),\n-            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)?),\n+            CheckedBinaryOp(op, box (rhs, lhs)) => CheckedBinaryOp(\n+                op,\n+                Box::new((rhs.try_fold_with(folder)?, lhs.try_fold_with(folder)?)),\n+            ),\n+            UnaryOp(op, val) => UnaryOp(op, val.try_fold_with(folder)?),\n+            Discriminant(place) => Discriminant(place.try_fold_with(folder)?),\n+            NullaryOp(op, ty) => NullaryOp(op, ty.try_fold_with(folder)?),\n             Aggregate(kind, fields) => {\n                 let kind = kind.try_map_id(|kind| {\n                     Ok(match kind {\n-                        AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)?),\n+                        AggregateKind::Array(ty) => AggregateKind::Array(ty.try_fold_with(folder)?),\n                         AggregateKind::Tuple => AggregateKind::Tuple,\n                         AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n                             def,\n                             v,\n-                            substs.fold_with(folder)?,\n-                            user_ty.fold_with(folder)?,\n+                            substs.try_fold_with(folder)?,\n+                            user_ty.try_fold_with(folder)?,\n                             n,\n                         ),\n                         AggregateKind::Closure(id, substs) => {\n-                            AggregateKind::Closure(id, substs.fold_with(folder)?)\n+                            AggregateKind::Closure(id, substs.try_fold_with(folder)?)\n                         }\n                         AggregateKind::Generator(id, substs, movablity) => {\n-                            AggregateKind::Generator(id, substs.fold_with(folder)?, movablity)\n+                            AggregateKind::Generator(id, substs.try_fold_with(folder)?, movablity)\n                         }\n                     })\n                 })?;\n-                Aggregate(kind, fields.fold_with(folder)?)\n+                Aggregate(kind, fields.try_fold_with(folder)?)\n+            }\n+            ShallowInitBox(op, ty) => {\n+                ShallowInitBox(op.try_fold_with(folder)?, ty.try_fold_with(folder)?)\n             }\n-            ShallowInitBox(op, ty) => ShallowInitBox(op.fold_with(folder)?, ty.fold_with(folder)?),\n         })\n     }\n \n@@ -272,11 +292,14 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(match self {\n-            Operand::Copy(place) => Operand::Copy(place.fold_with(folder)?),\n-            Operand::Move(place) => Operand::Move(place.fold_with(folder)?),\n-            Operand::Constant(c) => Operand::Constant(c.fold_with(folder)?),\n+            Operand::Copy(place) => Operand::Copy(place.try_fold_with(folder)?),\n+            Operand::Move(place) => Operand::Move(place.try_fold_with(folder)?),\n+            Operand::Constant(c) => Operand::Constant(c.try_fold_with(folder)?),\n         })\n     }\n \n@@ -289,13 +312,16 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         use crate::mir::ProjectionElem::*;\n \n         Ok(match self {\n             Deref => Deref,\n-            Field(f, ty) => Field(f, ty.fold_with(folder)?),\n-            Index(v) => Index(v.fold_with(folder)?),\n+            Field(f, ty) => Field(f, ty.try_fold_with(folder)?),\n+            Index(v) => Index(v.try_fold_with(folder)?),\n             Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n             ConstantIndex { offset, min_length, from_end } => {\n                 ConstantIndex { offset, min_length, from_end }\n@@ -319,7 +345,7 @@ impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Field {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -328,7 +354,7 @@ impl<'tcx> TypeFoldable<'tcx> for Field {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -337,7 +363,7 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n }\n \n impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -346,11 +372,14 @@ impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(Constant {\n             span: self.span,\n-            user_ty: self.user_ty.fold_with(folder)?,\n-            literal: self.literal.fold_with(folder)?,\n+            user_ty: self.user_ty.try_fold_with(folder)?,\n+            literal: self.literal.try_fold_with(folder)?,\n         })\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -361,14 +390,17 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ConstantKind<'tcx> {\n     #[inline(always)]\n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        folder.fold_mir_const(self)\n+    fn try_fold_with<F: TypeFolderFallible<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        folder.try_fold_mir_const(self)\n     }\n \n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         match self {\n-            ConstantKind::Ty(c) => Ok(ConstantKind::Ty(c.fold_with(folder)?)),\n-            ConstantKind::Val(v, t) => Ok(ConstantKind::Val(v, t.fold_with(folder)?)),\n+            ConstantKind::Ty(c) => Ok(ConstantKind::Ty(c.try_fold_with(folder)?)),\n+            ConstantKind::Val(v, t) => Ok(ConstantKind::Val(v, t.try_fold_with(folder)?)),\n         }\n     }\n "}, {"sha": "63eb55ed1a6208121d0e479810ae80209b0bce03", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -9,7 +9,7 @@ pub(super) fn provide(providers: &mut ty::query::Providers) {\n fn erase_regions_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     // N.B., use `super_fold_with` here. If we used `fold_with`, it\n     // could invoke the `erase_regions_ty` query recursively.\n-    ty.super_fold_with(&mut RegionEraserVisitor { tcx }).into_ok()\n+    ty.super_fold_with(&mut RegionEraserVisitor { tcx })\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -27,7 +27,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             return value;\n         }\n         debug!(\"erase_regions({:?})\", value);\n-        let value1 = value.fold_with(&mut RegionEraserVisitor { tcx: self }).into_ok();\n+        let value1 = value.fold_with(&mut RegionEraserVisitor { tcx: self });\n         debug!(\"erase_regions = {:?}\", value1);\n         value1\n     }\n@@ -42,19 +42,19 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n-        if ty.needs_infer() { ty.super_fold_with(self) } else { Ok(self.tcx.erase_regions_ty(ty)) }\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if ty.needs_infer() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n     }\n \n-    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> Result<ty::Binder<'tcx, T>, Self::Error>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         let u = self.tcx.anonymize_late_bound_regions(t);\n         u.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         // because late-bound regions affect subtyping, we can't\n         // erase the bound/free distinction, but we can replace\n         // all free regions with 'erased.\n@@ -64,15 +64,12 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n         // away. In codegen, they will always be erased to 'erased\n         // whenever a substitution occurs.\n         match *r {\n-            ty::ReLateBound(..) => Ok(r),\n-            _ => Ok(self.tcx.lifetimes.re_erased),\n+            ty::ReLateBound(..) => r,\n+            _ => self.tcx.lifetimes.re_erased,\n         }\n     }\n \n-    fn fold_mir_const(\n-        &mut self,\n-        c: mir::ConstantKind<'tcx>,\n-    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n+    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n         c.super_fold_with(self)\n     }\n }"}, {"sha": "4039577df88b86887d8eb4bea78bbbde84bd0539", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 179, "deletions": 70, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -46,9 +46,28 @@ use std::ops::ControlFlow;\n ///\n /// To implement this conveniently, use the derive macro located in `rustc_macros`.\n pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error>;\n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.super_fold_with(folder)\n+    /// Consumers may find this more convenient to use with infallible folders than\n+    /// [`try_super_fold_with`][`TypeFoldable::try_super_fold_with`], to which the\n+    /// provided default definition delegates.  Implementors **should not** override\n+    /// this provided default definition, to ensure that the two methods are coherent\n+    /// (provide a definition of `try_super_fold_with` instead).\n+    fn super_fold_with<F: TypeFolder<'tcx, Error = !>>(self, folder: &mut F) -> Self {\n+        self.try_super_fold_with(folder).into_ok()\n+    }\n+    /// Consumers may find this more convenient to use with infallible folders than\n+    /// [`try_fold_with`][`TypeFoldable::try_fold_with`], to which the provided\n+    /// default definition delegates.  Implementors **should not** override this\n+    /// provided default definition, to ensure that the two methods are coherent\n+    /// (provide a definition of `try_fold_with` instead).\n+    fn fold_with<F: TypeFolder<'tcx, Error = !>>(self, folder: &mut F) -> Self {\n+        self.try_fold_with(folder).into_ok()\n+    }\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error>;\n+    fn try_fold_with<F: TypeFolderFallible<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_super_fold_with(folder)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n@@ -179,7 +198,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n }\n \n impl TypeFoldable<'tcx> for hir::Constness {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -192,48 +211,152 @@ impl TypeFoldable<'tcx> for hir::Constness {\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n+///\n+/// If this folder is fallible (and therefore its [`Error`][`TypeFolder::Error`]\n+/// associated type is something other than the default, never),\n+/// [`TypeFolderFallible`] should be implemented manually; otherwise,\n+/// a blanket implementation of [`TypeFolderFallible`] will defer to\n+/// the infallible methods of this trait to ensure that the two APIs\n+/// are coherent.\n pub trait TypeFolder<'tcx>: Sized {\n     type Error = !;\n \n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n-    fn fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, Self::Error>\n+    fn fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n+        Self: TypeFolder<'tcx, Error = !>,\n     {\n         t.super_fold_with(self)\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx>\n+    where\n+        Self: TypeFolder<'tcx, Error = !>,\n+    {\n         t.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx>\n+    where\n+        Self: TypeFolder<'tcx, Error = !>,\n+    {\n         r.super_fold_with(self)\n     }\n \n-    fn fold_const(\n+    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>\n+    where\n+        Self: TypeFolder<'tcx, Error = !>,\n+    {\n+        c.super_fold_with(self)\n+    }\n+\n+    fn fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> ty::Predicate<'tcx>\n+    where\n+        Self: TypeFolder<'tcx, Error = !>,\n+    {\n+        p.super_fold_with(self)\n+    }\n+\n+    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx>\n+    where\n+        Self: TypeFolder<'tcx, Error = !>,\n+    {\n+        bug!(\"most type folders should not be folding MIR datastructures: {:?}\", c)\n+    }\n+}\n+\n+/// The `TypeFolderFallible` trait defines the actual *folding*. There is a\n+/// method defined for every foldable type. Each of these has a\n+/// default implementation that does an \"identity\" fold. Within each\n+/// identity fold, it should invoke `foo.try_fold_with(self)` to fold each\n+/// sub-item.\n+///\n+/// A blanket implementation of this trait (that defers to the relevant\n+/// method of [`TypeFolder`]) is provided for all infallible folders in\n+/// order to ensure the two APIs are coherent.\n+pub trait TypeFolderFallible<'tcx>: TypeFolder<'tcx> {\n+    fn try_fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, Self::Error>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        t.try_super_fold_with(self)\n+    }\n+\n+    fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        t.try_super_fold_with(self)\n+    }\n+\n+    fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        r.try_super_fold_with(self)\n+    }\n+\n+    fn try_fold_const(\n         &mut self,\n         c: &'tcx ty::Const<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-        c.super_fold_with(self)\n+        c.try_super_fold_with(self)\n     }\n \n-    fn fold_predicate(\n+    fn try_fold_predicate(\n         &mut self,\n         p: ty::Predicate<'tcx>,\n     ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n-        p.super_fold_with(self)\n+        p.try_super_fold_with(self)\n     }\n \n-    fn fold_mir_const(\n+    fn try_fold_mir_const(\n         &mut self,\n         c: mir::ConstantKind<'tcx>,\n     ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         bug!(\"most type folders should not be folding MIR datastructures: {:?}\", c)\n     }\n }\n \n+// Blanket implementation of fallible trait for infallible folders\n+// delegates to infallible methods to prevent incoherence\n+impl<'tcx, F> TypeFolderFallible<'tcx> for F\n+where\n+    F: TypeFolder<'tcx, Error = !>,\n+{\n+    fn try_fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, Self::Error>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        Ok(self.fold_binder(t))\n+    }\n+\n+    fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        Ok(self.fold_ty(t))\n+    }\n+\n+    fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        Ok(self.fold_region(r))\n+    }\n+\n+    fn try_fold_const(\n+        &mut self,\n+        c: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        Ok(self.fold_const(c))\n+    }\n+\n+    fn try_fold_predicate(\n+        &mut self,\n+        p: ty::Predicate<'tcx>,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n+        Ok(self.fold_predicate(p))\n+    }\n+\n+    fn try_fold_mir_const(\n+        &mut self,\n+        c: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n+        Ok(self.fold_mir_const(c))\n+    }\n+}\n+\n pub trait TypeVisitor<'tcx>: Sized {\n     type BreakTy = !;\n     /// Supplies the `tcx` for an unevaluated anonymous constant in case its default substs\n@@ -301,22 +424,19 @@ where\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n-        let t = ty.super_fold_with(self)?;\n-        Ok((self.ty_op)(t))\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let t = ty.super_fold_with(self);\n+        (self.ty_op)(t)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n-        let r = r.super_fold_with(self)?;\n-        Ok((self.lt_op)(r))\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        let r = r.super_fold_with(self);\n+        (self.lt_op)(r)\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-        let ct = ct.super_fold_with(self)?;\n-        Ok((self.ct_op)(ct))\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        let ct = ct.super_fold_with(self);\n+        (self.ct_op)(ct)\n     }\n }\n \n@@ -336,7 +456,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f)).into_ok()\n+        value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n     }\n \n     /// Invoke `callback` on every region appearing free in `value`.\n@@ -484,24 +604,24 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n+    ) -> ty::Binder<'tcx, T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, _) if debruijn < self.current_index => {\n                 debug!(?self.current_index, \"skipped bound region\");\n                 *self.skipped_regions = true;\n-                Ok(r)\n+                r\n             }\n             _ => {\n                 debug!(?self.current_index, \"folding free region\");\n-                Ok((self.fold_region_fn)(r, self.current_index))\n+                (self.fold_region_fn)(r, self.current_index)\n             }\n         }\n     }\n@@ -542,30 +662,30 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n+    ) -> ty::Binder<'tcx, T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.current_index => {\n                 if let Some(fld_t) = self.fld_t.as_mut() {\n                     let ty = fld_t(bound_ty);\n-                    return Ok(ty::fold::shift_vars(self.tcx, &ty, self.current_index.as_u32()));\n+                    return ty::fold::shift_vars(self.tcx, &ty, self.current_index.as_u32());\n                 }\n             }\n             _ if t.has_vars_bound_at_or_above(self.current_index) => {\n                 return t.super_fold_with(self);\n             }\n             _ => {}\n         }\n-        Ok(t)\n+        t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n                 if let Some(fld_r) = self.fld_r.as_mut() {\n@@ -576,36 +696,33 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n                         // debruijn index. Then we adjust it to the\n                         // correct depth.\n                         assert_eq!(debruijn1, ty::INNERMOST);\n-                        Ok(self.tcx.mk_region(ty::ReLateBound(debruijn, br)))\n+                        self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n                     } else {\n-                        Ok(region)\n+                        region\n                     };\n                 }\n             }\n             _ => {}\n         }\n-        Ok(r)\n+        r\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match *ct {\n             ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty }\n                 if debruijn == self.current_index =>\n             {\n                 if let Some(fld_c) = self.fld_c.as_mut() {\n                     let ct = fld_c(bound_const, ty);\n-                    return Ok(ty::fold::shift_vars(self.tcx, &ct, self.current_index.as_u32()));\n+                    return ty::fold::shift_vars(self.tcx, &ct, self.current_index.as_u32());\n                 }\n             }\n             _ if ct.has_vars_bound_at_or_above(self.current_index) => {\n                 return ct.super_fold_with(self);\n             }\n             _ => {}\n         }\n-        Ok(ct)\n+        ct\n     }\n }\n \n@@ -638,7 +755,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             value\n         } else {\n             let mut replacer = BoundVarReplacer::new(self, Some(&mut real_fld_r), None, None);\n-            value.fold_with(&mut replacer).into_ok()\n+            value.fold_with(&mut replacer)\n         };\n         (value, region_map)\n     }\n@@ -664,7 +781,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         } else {\n             let mut replacer =\n                 BoundVarReplacer::new(self, Some(&mut fld_r), Some(&mut fld_t), Some(&mut fld_c));\n-            value.fold_with(&mut replacer).into_ok()\n+            value.fold_with(&mut replacer)\n         }\n     }\n \n@@ -955,55 +1072,50 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n+    ) -> ty::Binder<'tcx, T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, br) => {\n                 if self.amount == 0 || debruijn < self.current_index {\n-                    Ok(r)\n+                    r\n                 } else {\n                     let debruijn = debruijn.shifted_in(self.amount);\n                     let shifted = ty::ReLateBound(debruijn, br);\n-                    Ok(self.tcx.mk_region(shifted))\n+                    self.tcx.mk_region(shifted)\n                 }\n             }\n-            _ => Ok(r),\n+            _ => r,\n         }\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match *ty.kind() {\n             ty::Bound(debruijn, bound_ty) => {\n                 if self.amount == 0 || debruijn < self.current_index {\n-                    Ok(ty)\n+                    ty\n                 } else {\n                     let debruijn = debruijn.shifted_in(self.amount);\n-                    Ok(self.tcx.mk_ty(ty::Bound(debruijn, bound_ty)))\n+                    self.tcx.mk_ty(ty::Bound(debruijn, bound_ty))\n                 }\n             }\n \n             _ => ty.super_fold_with(self),\n         }\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty } = *ct {\n             if self.amount == 0 || debruijn < self.current_index {\n-                Ok(ct)\n+                ct\n             } else {\n                 let debruijn = debruijn.shifted_in(self.amount);\n-                Ok(self\n-                    .tcx\n-                    .mk_const(ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty }))\n+                self.tcx.mk_const(ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty })\n             }\n         } else {\n             ct.super_fold_with(self)\n@@ -1030,7 +1142,7 @@ where\n {\n     debug!(\"shift_vars(value={:?}, amount={})\", value, amount);\n \n-    value.fold_with(&mut Shifter::new(tcx, amount)).into_ok()\n+    value.fold_with(&mut Shifter::new(tcx, amount))\n }\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n@@ -1293,7 +1405,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ///\n     /// FIXME(@lcnr): explain this function a bit more\n     pub fn expose_default_const_substs<T: TypeFoldable<'tcx>>(self, v: T) -> T {\n-        v.fold_with(&mut ExposeDefaultConstSubstsFolder { tcx: self }).into_ok()\n+        v.fold_with(&mut ExposeDefaultConstSubstsFolder { tcx: self })\n     }\n }\n \n@@ -1306,22 +1418,19 @@ impl<'tcx> TypeFolder<'tcx> for ExposeDefaultConstSubstsFolder<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         if ty.flags().intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n             ty.super_fold_with(self)\n         } else {\n-            Ok(ty)\n+            ty\n         }\n     }\n \n-    fn fold_predicate(\n-        &mut self,\n-        pred: ty::Predicate<'tcx>,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n+    fn fold_predicate(&mut self, pred: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n         if pred.inner.flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n             pred.super_fold_with(self)\n         } else {\n-            Ok(pred)\n+            pred\n         }\n     }\n }"}, {"sha": "4b38105e44717e52300e5b6f9e789e58f8093d12", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -622,7 +622,7 @@ fn polymorphize<'tcx>(\n             self.tcx\n         }\n \n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n             debug!(\"fold_ty: ty={:?}\", ty);\n             match ty.kind {\n                 ty::Closure(def_id, substs) => {\n@@ -631,23 +631,23 @@ fn polymorphize<'tcx>(\n                         ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n                         substs,\n                     );\n-                    Ok(if substs == polymorphized_substs {\n+                    if substs == polymorphized_substs {\n                         ty\n                     } else {\n                         self.tcx.mk_closure(def_id, polymorphized_substs)\n-                    })\n+                    }\n                 }\n                 ty::Generator(def_id, substs, movability) => {\n                     let polymorphized_substs = polymorphize(\n                         self.tcx,\n                         ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n                         substs,\n                     );\n-                    Ok(if substs == polymorphized_substs {\n+                    if substs == polymorphized_substs {\n                         ty\n                     } else {\n                         self.tcx.mk_generator(def_id, polymorphized_substs, movability)\n-                    })\n+                    }\n                 }\n                 _ => ty.super_fold_with(self),\n             }\n@@ -669,7 +669,7 @@ fn polymorphize<'tcx>(\n                     // ..and polymorphize any closures/generators captured as upvars.\n                     let upvars_ty = upvars_ty.unwrap();\n                     let polymorphized_upvars_ty = upvars_ty.fold_with(\n-                        &mut PolymorphizationFolder { tcx }).into_ok();\n+                        &mut PolymorphizationFolder { tcx });\n                     debug!(\"polymorphize: polymorphized_upvars_ty={:?}\", polymorphized_upvars_ty);\n                     ty::GenericArg::from(polymorphized_upvars_ty)\n                 },"}, {"sha": "f18ea9dac31a56cb6999404a9f16e470cdb63a70", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -9,7 +9,7 @@\n //!\n //! [\"The `ty` module: representing types\"]: https://rustc-dev-guide.rust-lang.org/ty.html\n \n-pub use self::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+pub use self::fold::{TypeFoldable, TypeFolder, TypeFolderFallible, TypeVisitor};\n pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n@@ -1269,14 +1269,14 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ParamEnv<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ParamEnv<'tcx> {\n-    fn super_fold_with<F: ty::fold::TypeFolder<'tcx>>(\n+    fn try_super_fold_with<F: ty::fold::TypeFolderFallible<'tcx>>(\n         self,\n         folder: &mut F,\n     ) -> Result<Self, F::Error> {\n         Ok(ParamEnv::new(\n-            self.caller_bounds().fold_with(folder)?,\n-            self.reveal().fold_with(folder)?,\n-            self.constness().fold_with(folder)?,\n+            self.caller_bounds().try_fold_with(folder)?,\n+            self.reveal().try_fold_with(folder)?,\n+            self.constness().try_fold_with(folder)?,\n         ))\n     }\n "}, {"sha": "c0e1360640fd2647227c8a9946ef0d0d1eecdfbc", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -9,7 +9,7 @@\n \n use crate::mir;\n use crate::traits::query::NoSolution;\n-use crate::ty::fold::{TypeFoldable, TypeFolder};\n+use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeFolder};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt};\n \n@@ -55,9 +55,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if !value.has_projections() {\n             value\n         } else {\n-            value\n-                .fold_with(&mut NormalizeAfterErasingRegionsFolder { tcx: self, param_env })\n-                .into_ok()\n+            value.fold_with(&mut NormalizeAfterErasingRegionsFolder { tcx: self, param_env })\n         }\n     }\n \n@@ -90,7 +88,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             Ok(value)\n         } else {\n             let mut folder = TryNormalizeAfterErasingRegionsFolder::new(self, param_env);\n-            value.fold_with(&mut folder)\n+            value.try_fold_with(&mut folder)\n         }\n     }\n \n@@ -161,25 +159,19 @@ impl TypeFolder<'tcx> for NormalizeAfterErasingRegionsFolder<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n-        Ok(self.normalize_generic_arg_after_erasing_regions(ty.into()).expect_ty())\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.normalize_generic_arg_after_erasing_regions(ty.into()).expect_ty()\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        c: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-        Ok(self.normalize_generic_arg_after_erasing_regions(c.into()).expect_const())\n+    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        self.normalize_generic_arg_after_erasing_regions(c.into()).expect_const()\n     }\n \n     #[inline]\n-    fn fold_mir_const(\n-        &mut self,\n-        c: mir::ConstantKind<'tcx>,\n-    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n+    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n         // FIXME: This *probably* needs canonicalization too!\n         let arg = self.param_env.and(c);\n-        Ok(self.tcx.normalize_mir_const_after_erasing_regions(arg))\n+        self.tcx.normalize_mir_const_after_erasing_regions(arg)\n     }\n }\n \n@@ -211,15 +203,17 @@ impl TypeFolder<'tcx> for TryNormalizeAfterErasingRegionsFolder<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n+}\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+impl FallibleTypeFolder<'tcx> for TryNormalizeAfterErasingRegionsFolder<'tcx> {\n+    fn try_fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match self.try_normalize_generic_arg_after_erasing_regions(ty.into()) {\n             Ok(t) => Ok(t.expect_ty()),\n             Err(_) => Err(NormalizationError::Type(ty)),\n         }\n     }\n \n-    fn fold_const(\n+    fn try_fold_const(\n         &mut self,\n         c: &'tcx ty::Const<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n@@ -229,7 +223,7 @@ impl TypeFolder<'tcx> for TryNormalizeAfterErasingRegionsFolder<'tcx> {\n         }\n     }\n \n-    fn fold_mir_const(\n+    fn try_fold_mir_const(\n         &mut self,\n         c: mir::ConstantKind<'tcx>,\n     ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {"}, {"sha": "175295b3199e8e2e2c1bf0cc5115ba53133d8657", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -2016,24 +2016,24 @@ impl<'a, 'tcx> ty::TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n+    ) -> ty::Binder<'tcx, T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n             _ if t.has_vars_bound_at_or_above(self.current_index) || t.has_placeholders() => {\n                 return t.super_fold_with(self);\n             }\n             _ => {}\n         }\n-        Ok(t)\n+        t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         let name = &mut self.name;\n         let region = match *r {\n             ty::ReLateBound(_, br) => self.region_map.entry(br).or_insert_with(|| name(br)),\n@@ -2049,13 +2049,13 @@ impl<'a, 'tcx> ty::TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n                     }\n                 }\n             }\n-            _ => return Ok(r),\n+            _ => return r,\n         };\n         if let ty::ReLateBound(debruijn1, br) = *region {\n             assert_eq!(debruijn1, ty::INNERMOST);\n-            Ok(self.tcx.mk_region(ty::ReLateBound(self.current_index, br)))\n+            self.tcx.mk_region(ty::ReLateBound(self.current_index, br))\n         } else {\n-            Ok(region)\n+            region\n         }\n     }\n }\n@@ -2193,7 +2193,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n                 name: &mut name,\n                 region_map: BTreeMap::new(),\n             };\n-            let new_value = value.clone().skip_binder().fold_with(&mut folder).into_ok();\n+            let new_value = value.clone().skip_binder().fold_with(&mut folder);\n             let region_map = folder.region_map;\n             start_or_continue(&mut self, \"\", \"> \");\n             (new_value, region_map)"}, {"sha": "0782a100e3166b06b683c8aa4f597838036f611d", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 161, "deletions": 77, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -4,7 +4,7 @@\n \n use crate::mir::interpret;\n use crate::mir::ProjectionKind;\n-use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::fold::{TypeFoldable, TypeFolderFallible, TypeVisitor};\n use crate::ty::print::{with_no_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::{self, InferConst, Lift, Ty, TyCtxt};\n use rustc_data_structures::functor::IdFunctor;\n@@ -669,7 +669,10 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n \n /// AdtDefs are basically the same as a DefId.\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        _folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n \n@@ -679,8 +682,11 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>, U: TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<(T, U), F::Error> {\n-        Ok((self.0.fold_with(folder)?, self.1.fold_with(folder)?))\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<(T, U), F::Error> {\n+        Ok((self.0.try_fold_with(folder)?, self.1.try_fold_with(folder)?))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -692,8 +698,15 @@ impl<'tcx, T: TypeFoldable<'tcx>, U: TypeFoldable<'tcx>> TypeFoldable<'tcx> for\n impl<'tcx, A: TypeFoldable<'tcx>, B: TypeFoldable<'tcx>, C: TypeFoldable<'tcx>> TypeFoldable<'tcx>\n     for (A, B, C)\n {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<(A, B, C), F::Error> {\n-        Ok((self.0.fold_with(folder)?, self.1.fold_with(folder)?, self.2.fold_with(folder)?))\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<(A, B, C), F::Error> {\n+        Ok((\n+            self.0.try_fold_with(folder)?,\n+            self.1.try_fold_with(folder)?,\n+            self.2.try_fold_with(folder)?,\n+        ))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -718,9 +731,12 @@ EnumTypeFoldableImpl! {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         // FIXME: Reuse the `Rc` here.\n-        Ok(Rc::new((*self).clone().fold_with(folder)?))\n+        (*self).clone().try_fold_with(folder).map(Rc::new)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -729,9 +745,12 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         // FIXME: Reuse the `Arc` here.\n-        Ok(Arc::new((*self).clone().fold_with(folder)?))\n+        (*self).clone().try_fold_with(folder).map(Arc::new)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -740,8 +759,11 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_map_id(|value| value.fold_with(folder))\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        self.try_map_id(|value| value.try_fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -750,8 +772,11 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_map_id(|t| t.fold_with(folder))\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        self.try_map_id(|t| t.try_fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -760,8 +785,11 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_map_id(|t| t.fold_with(folder))\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        self.try_map_id(|t| t.try_fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -770,12 +798,15 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<'tcx, T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_map_bound(|ty| ty.fold_with(folder))\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        self.try_map_bound(|ty| ty.try_fold_with(folder))\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        folder.fold_binder(self)\n+    fn try_fold_with<F: TypeFolderFallible<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        folder.try_fold_binder(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -788,7 +819,10 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<'tcx, T> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_poly_existential_predicates(v))\n     }\n \n@@ -798,7 +832,10 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::Existentia\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_type_list(v))\n     }\n \n@@ -808,7 +845,10 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_projs(v))\n     }\n \n@@ -818,22 +858,31 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         use crate::ty::InstanceDef::*;\n         Ok(Self {\n-            substs: self.substs.fold_with(folder)?,\n+            substs: self.substs.try_fold_with(folder)?,\n             def: match self.def {\n-                Item(def) => Item(def.fold_with(folder)?),\n-                VtableShim(did) => VtableShim(did.fold_with(folder)?),\n-                ReifyShim(did) => ReifyShim(did.fold_with(folder)?),\n-                Intrinsic(did) => Intrinsic(did.fold_with(folder)?),\n-                FnPtrShim(did, ty) => FnPtrShim(did.fold_with(folder)?, ty.fold_with(folder)?),\n-                Virtual(did, i) => Virtual(did.fold_with(folder)?, i),\n+                Item(def) => Item(def.try_fold_with(folder)?),\n+                VtableShim(did) => VtableShim(did.try_fold_with(folder)?),\n+                ReifyShim(did) => ReifyShim(did.try_fold_with(folder)?),\n+                Intrinsic(did) => Intrinsic(did.try_fold_with(folder)?),\n+                FnPtrShim(did, ty) => {\n+                    FnPtrShim(did.try_fold_with(folder)?, ty.try_fold_with(folder)?)\n+                }\n+                Virtual(did, i) => Virtual(did.try_fold_with(folder)?, i),\n                 ClosureOnceShim { call_once, track_caller } => {\n-                    ClosureOnceShim { call_once: call_once.fold_with(folder)?, track_caller }\n+                    ClosureOnceShim { call_once: call_once.try_fold_with(folder)?, track_caller }\n+                }\n+                DropGlue(did, ty) => {\n+                    DropGlue(did.try_fold_with(folder)?, ty.try_fold_with(folder)?)\n+                }\n+                CloneShim(did, ty) => {\n+                    CloneShim(did.try_fold_with(folder)?, ty.try_fold_with(folder)?)\n                 }\n-                DropGlue(did, ty) => DropGlue(did.fold_with(folder)?, ty.fold_with(folder)?),\n-                CloneShim(did, ty) => CloneShim(did.fold_with(folder)?, ty.fold_with(folder)?),\n             },\n         })\n     }\n@@ -860,8 +909,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        Ok(Self { instance: self.instance.fold_with(folder)?, promoted: self.promoted })\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        Ok(Self { instance: self.instance.try_fold_with(folder)?, promoted: self.promoted })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -870,26 +922,31 @@ impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         let kind = match *self.kind() {\n-            ty::RawPtr(tm) => ty::RawPtr(tm.fold_with(folder)?),\n-            ty::Array(typ, sz) => ty::Array(typ.fold_with(folder)?, sz.fold_with(folder)?),\n-            ty::Slice(typ) => ty::Slice(typ.fold_with(folder)?),\n-            ty::Adt(tid, substs) => ty::Adt(tid, substs.fold_with(folder)?),\n+            ty::RawPtr(tm) => ty::RawPtr(tm.try_fold_with(folder)?),\n+            ty::Array(typ, sz) => ty::Array(typ.try_fold_with(folder)?, sz.try_fold_with(folder)?),\n+            ty::Slice(typ) => ty::Slice(typ.try_fold_with(folder)?),\n+            ty::Adt(tid, substs) => ty::Adt(tid, substs.try_fold_with(folder)?),\n             ty::Dynamic(trait_ty, region) => {\n-                ty::Dynamic(trait_ty.fold_with(folder)?, region.fold_with(folder)?)\n+                ty::Dynamic(trait_ty.try_fold_with(folder)?, region.try_fold_with(folder)?)\n+            }\n+            ty::Tuple(ts) => ty::Tuple(ts.try_fold_with(folder)?),\n+            ty::FnDef(def_id, substs) => ty::FnDef(def_id, substs.try_fold_with(folder)?),\n+            ty::FnPtr(f) => ty::FnPtr(f.try_fold_with(folder)?),\n+            ty::Ref(r, ty, mutbl) => {\n+                ty::Ref(r.try_fold_with(folder)?, ty.try_fold_with(folder)?, mutbl)\n             }\n-            ty::Tuple(ts) => ty::Tuple(ts.fold_with(folder)?),\n-            ty::FnDef(def_id, substs) => ty::FnDef(def_id, substs.fold_with(folder)?),\n-            ty::FnPtr(f) => ty::FnPtr(f.fold_with(folder)?),\n-            ty::Ref(r, ty, mutbl) => ty::Ref(r.fold_with(folder)?, ty.fold_with(folder)?, mutbl),\n             ty::Generator(did, substs, movability) => {\n-                ty::Generator(did, substs.fold_with(folder)?, movability)\n+                ty::Generator(did, substs.try_fold_with(folder)?, movability)\n             }\n-            ty::GeneratorWitness(types) => ty::GeneratorWitness(types.fold_with(folder)?),\n-            ty::Closure(did, substs) => ty::Closure(did, substs.fold_with(folder)?),\n-            ty::Projection(data) => ty::Projection(data.fold_with(folder)?),\n-            ty::Opaque(did, substs) => ty::Opaque(did, substs.fold_with(folder)?),\n+            ty::GeneratorWitness(types) => ty::GeneratorWitness(types.try_fold_with(folder)?),\n+            ty::Closure(did, substs) => ty::Closure(did, substs.try_fold_with(folder)?),\n+            ty::Projection(data) => ty::Projection(data.try_fold_with(folder)?),\n+            ty::Opaque(did, substs) => ty::Opaque(did, substs.try_fold_with(folder)?),\n \n             ty::Bool\n             | ty::Char\n@@ -909,8 +966,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n         Ok(if *self.kind() == kind { self } else { folder.tcx().mk_ty(kind) })\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        folder.fold_ty(self)\n+    fn try_fold_with<F: TypeFolderFallible<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        folder.try_fold_ty(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -961,12 +1018,15 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        _folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        folder.fold_region(self)\n+    fn try_fold_with<F: TypeFolderFallible<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        folder.try_fold_region(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -979,12 +1039,15 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        folder.fold_predicate(self)\n+    fn try_fold_with<F: TypeFolderFallible<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        folder.try_fold_predicate(self)\n     }\n \n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        let new = self.inner.kind.fold_with(folder)?;\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        let new = self.inner.kind.try_fold_with(folder)?;\n         Ok(folder.tcx().reuse_or_mk_predicate(self, new))\n     }\n \n@@ -1006,7 +1069,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_predicates(v))\n     }\n \n@@ -1016,8 +1082,11 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_map_id(|x| x.fold_with(folder))\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        self.try_map_id(|x| x.try_fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1026,18 +1095,21 @@ impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T>\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        let ty = self.ty.fold_with(folder)?;\n-        let val = self.val.fold_with(folder)?;\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        let ty = self.ty.try_fold_with(folder)?;\n+        let val = self.val.try_fold_with(folder)?;\n         if ty != self.ty || val != self.val {\n             Ok(folder.tcx().mk_const(ty::Const { ty, val }))\n         } else {\n             Ok(self)\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        folder.fold_const(self)\n+    fn try_fold_with<F: TypeFolderFallible<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        folder.try_fold_const(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1051,11 +1123,14 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(match self {\n-            ty::ConstKind::Infer(ic) => ty::ConstKind::Infer(ic.fold_with(folder)?),\n-            ty::ConstKind::Param(p) => ty::ConstKind::Param(p.fold_with(folder)?),\n-            ty::ConstKind::Unevaluated(uv) => ty::ConstKind::Unevaluated(uv.fold_with(folder)?),\n+            ty::ConstKind::Infer(ic) => ty::ConstKind::Infer(ic.try_fold_with(folder)?),\n+            ty::ConstKind::Param(p) => ty::ConstKind::Param(p.try_fold_with(folder)?),\n+            ty::ConstKind::Unevaluated(uv) => ty::ConstKind::Unevaluated(uv.try_fold_with(folder)?),\n             ty::ConstKind::Value(_)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(..)\n@@ -1077,7 +1152,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        _folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n \n@@ -1087,10 +1165,13 @@ impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(ty::Unevaluated {\n             def: self.def,\n-            substs_: Some(self.substs(folder.tcx()).fold_with(folder)?),\n+            substs_: Some(self.substs(folder.tcx()).try_fold_with(folder)?),\n             promoted: self.promoted,\n         })\n     }\n@@ -1112,10 +1193,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx, ()> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         Ok(ty::Unevaluated {\n             def: self.def,\n-            substs_: Some(self.substs(folder.tcx()).fold_with(folder)?),\n+            substs_: Some(self.substs(folder.tcx()).try_fold_with(folder)?),\n             promoted: self.promoted,\n         })\n     }"}, {"sha": "a0f0e06435d437413d46932eae0623e41d1efbb3", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -2,7 +2,7 @@\n \n use crate::mir;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n-use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::fold::{TypeFoldable, TypeFolder, TypeFolderFallible, TypeVisitor};\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts, InlineConstSubsts};\n use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n@@ -153,11 +153,14 @@ impl<'a, 'tcx> Lift<'tcx> for GenericArg<'a> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         match self.unpack() {\n-            GenericArgKind::Lifetime(lt) => lt.fold_with(folder).map(Into::into),\n-            GenericArgKind::Type(ty) => ty.fold_with(folder).map(Into::into),\n-            GenericArgKind::Const(ct) => ct.fold_with(folder).map(Into::into),\n+            GenericArgKind::Lifetime(lt) => lt.try_fold_with(folder).map(Into::into),\n+            GenericArgKind::Type(ty) => ty.try_fold_with(folder).map(Into::into),\n+            GenericArgKind::Const(ct) => ct.try_fold_with(folder).map(Into::into),\n         }\n     }\n \n@@ -372,7 +375,10 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+    fn try_super_fold_with<F: TypeFolderFallible<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n         // This code is hot enough that it's worth specializing for the most\n         // common length lists, to avoid the overhead of `SmallVec` creation.\n         // The match arms are in order of frequency. The 1, 2, and 0 cases are\n@@ -381,12 +387,12 @@ impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n         // calling `intern_substs`.\n         match self.len() {\n             1 => {\n-                let param0 = self[0].fold_with(folder)?;\n+                let param0 = self[0].try_fold_with(folder)?;\n                 if param0 == self[0] { Ok(self) } else { Ok(folder.tcx().intern_substs(&[param0])) }\n             }\n             2 => {\n-                let param0 = self[0].fold_with(folder)?;\n-                let param1 = self[1].fold_with(folder)?;\n+                let param0 = self[0].try_fold_with(folder)?;\n+                let param1 = self[1].try_fold_with(folder)?;\n                 if param0 == self[0] && param1 == self[1] {\n                     Ok(self)\n                 } else {\n@@ -396,7 +402,7 @@ impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n             0 => Ok(self),\n             _ => {\n                 let params: SmallVec<[_; 8]> =\n-                    self.iter().map(|k| k.fold_with(folder)).collect::<Result<_, _>>()?;\n+                    self.iter().map(|k| k.try_fold_with(folder)).collect::<Result<_, _>>()?;\n                 if params[..] == self[..] {\n                     Ok(self)\n                 } else {\n@@ -439,7 +445,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n         span: Option<Span>,\n     ) -> T {\n         let mut folder = SubstFolder { tcx, substs, span, binders_passed: 0 };\n-        self.fold_with(&mut folder).into_ok()\n+        self.fold_with(&mut folder)\n     }\n }\n \n@@ -465,14 +471,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n+    ) -> ty::Binder<'tcx, T> {\n         self.binders_passed += 1;\n-        let t = t.super_fold_with(self)?;\n+        let t = t.super_fold_with(self);\n         self.binders_passed -= 1;\n-        Ok(t)\n+        t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         // Note: This routine only handles regions that are bound on\n         // type declarations and other outer declarations, not those\n         // bound in *fn types*. Region substitution of the bound\n@@ -482,7 +488,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n             ty::ReEarlyBound(data) => {\n                 let rk = self.substs.get(data.index as usize).map(|k| k.unpack());\n                 match rk {\n-                    Some(GenericArgKind::Lifetime(lt)) => Ok(self.shift_region_through_binders(lt)),\n+                    Some(GenericArgKind::Lifetime(lt)) => self.shift_region_through_binders(lt),\n                     _ => {\n                         let span = self.span.unwrap_or(DUMMY_SP);\n                         let msg = format!(\n@@ -494,37 +500,31 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                     }\n                 }\n             }\n-            _ => Ok(r),\n+            _ => r,\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !t.potentially_needs_subst() {\n-            return Ok(t);\n+            return t;\n         }\n \n         match *t.kind() {\n-            ty::Param(p) => Ok(self.ty_for_param(p, t)),\n+            ty::Param(p) => self.ty_for_param(p, t),\n             _ => t.super_fold_with(self),\n         }\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        c: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ty::ConstKind::Param(p) = c.val {\n-            Ok(self.const_for_param(p, c))\n+            self.const_for_param(p, c)\n         } else {\n             c.super_fold_with(self)\n         }\n     }\n \n     #[inline]\n-    fn fold_mir_const(\n-        &mut self,\n-        c: mir::ConstantKind<'tcx>,\n-    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n+    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n         c.super_fold_with(self)\n     }\n }"}, {"sha": "8537ef7ccb50bdc0f5d62c0094d544010cdc96a0", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -1,7 +1,7 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use crate::ty::fold::TypeFolder;\n+use crate::ty::fold::{TypeFolder, TypeFolderFallible};\n use crate::ty::layout::IntegerExt;\n use crate::ty::query::TyCtxtAt;\n use crate::ty::subst::{GenericArgKind, Subst, SubstsRef};\n@@ -574,14 +574,14 @@ impl<'tcx> OpaqueTypeExpander<'tcx> {\n         if self.found_any_recursion {\n             return None;\n         }\n-        let substs = substs.fold_with(self).into_ok();\n+        let substs = substs.fold_with(self);\n         if !self.check_recursion || self.seen_opaque_tys.insert(def_id) {\n             let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n                 Some(expanded_ty) => expanded_ty,\n                 None => {\n                     let generic_ty = self.tcx.type_of(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx, substs);\n-                    let expanded_ty = self.fold_ty(concrete_ty).into_ok();\n+                    let expanded_ty = self.fold_ty(concrete_ty);\n                     self.expanded_cache.insert((def_id, substs), expanded_ty);\n                     expanded_ty\n                 }\n@@ -605,13 +605,13 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if let ty::Opaque(def_id, substs) = t.kind {\n-            Ok(self.expand_opaque_ty(def_id, substs).unwrap_or(t))\n+            self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n         } else if t.has_opaque_types() {\n             t.super_fold_with(self)\n         } else {\n-            Ok(t)\n+            t\n         }\n     }\n }\n@@ -1048,12 +1048,12 @@ pub fn fold_list<'tcx, F, T>(\n     intern: impl FnOnce(TyCtxt<'tcx>, &[T]) -> &'tcx ty::List<T>,\n ) -> Result<&'tcx ty::List<T>, F::Error>\n where\n-    F: TypeFolder<'tcx>,\n+    F: TypeFolderFallible<'tcx>,\n     T: TypeFoldable<'tcx> + PartialEq + Copy,\n {\n     let mut iter = list.iter();\n     // Look for the first element that changed\n-    match iter.by_ref().enumerate().find_map(|(i, t)| match t.fold_with(folder) {\n+    match iter.by_ref().enumerate().find_map(|(i, t)| match t.try_fold_with(folder) {\n         Ok(new_t) if new_t == t => None,\n         new_t => Some((i, new_t)),\n     }) {\n@@ -1063,7 +1063,7 @@ where\n             new_list.extend_from_slice(&list[..i]);\n             new_list.push(new_t);\n             for t in iter {\n-                new_list.push(t.fold_with(folder)?)\n+                new_list.push(t.try_fold_with(folder)?)\n             }\n             Ok(intern(folder.tcx(), &new_list))\n         }\n@@ -1092,7 +1092,7 @@ pub fn normalize_opaque_types(\n         check_recursion: false,\n         tcx,\n     };\n-    val.fold_with(&mut visitor).into_ok()\n+    val.fold_with(&mut visitor)\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "1820e33b19bf4fc0ae332bc78aeb3ab8e6359d23", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -22,7 +22,6 @@\n #![feature(never_type)]\n #![feature(crate_visibility_modifier)]\n #![feature(control_flow_enum)]\n-#![feature(unwrap_infallible)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "75d57d78e3b0294be8d2138590248c775ddb6048", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -65,16 +65,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n         // after producing an error for each of them.\n-        let definition_ty = instantiated_ty\n-            .fold_with(&mut ReverseMapper::new(\n-                self.tcx,\n-                self.is_tainted_by_errors(),\n-                def_id,\n-                map,\n-                instantiated_ty,\n-                span,\n-            ))\n-            .into_ok();\n+        let definition_ty = instantiated_ty.fold_with(&mut ReverseMapper::new(\n+            self.tcx,\n+            self.is_tainted_by_errors(),\n+            def_id,\n+            map,\n+            instantiated_ty,\n+            span,\n+        ));\n         debug!(?definition_ty);\n \n         definition_ty\n@@ -125,14 +123,14 @@ impl ReverseMapper<'tcx> {\n     ) -> GenericArg<'tcx> {\n         assert!(!self.map_missing_regions_to_empty);\n         self.map_missing_regions_to_empty = true;\n-        let kind = kind.fold_with(self).into_ok();\n+        let kind = kind.fold_with(self);\n         self.map_missing_regions_to_empty = false;\n         kind\n     }\n \n     fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n         assert!(!self.map_missing_regions_to_empty);\n-        kind.fold_with(self).into_ok()\n+        kind.fold_with(self)\n     }\n }\n \n@@ -142,17 +140,17 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match r {\n             // Ignore bound regions and `'static` regions that appear in the\n             // type, we only need to remap regions that reference lifetimes\n             // from the function declaraion.\n             // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-            ty::ReLateBound(..) | ty::ReStatic => return Ok(r),\n+            ty::ReLateBound(..) | ty::ReStatic => return r,\n \n             // If regions have been erased (by writeback), don't try to unerase\n             // them.\n-            ty::ReErased => return Ok(r),\n+            ty::ReErased => return r,\n \n             // The regions that we expect from borrow checking.\n             ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n@@ -167,10 +165,10 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n \n         let generics = self.tcx().generics_of(self.opaque_type_def_id);\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n-            Some(GenericArgKind::Lifetime(r1)) => Ok(r1),\n+            Some(GenericArgKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n             None if self.map_missing_regions_to_empty || self.tainted_by_errors => {\n-                Ok(self.tcx.lifetimes.re_root_empty)\n+                self.tcx.lifetimes.re_root_empty\n             }\n             None if generics.parent.is_some() => {\n                 if let Some(hidden_ty) = self.hidden_ty.take() {\n@@ -182,7 +180,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n                 }\n-                Ok(self.tcx.lifetimes.re_root_empty)\n+                self.tcx.lifetimes.re_root_empty\n             }\n             None => {\n                 self.tcx\n@@ -198,12 +196,12 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n \n-                Ok(self.tcx().lifetimes.re_static)\n+                self.tcx().lifetimes.re_static\n             }\n         }\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match *ty.kind() {\n             ty::Closure(def_id, substs) => {\n                 // I am a horrible monster and I pray for death. When\n@@ -241,7 +239,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     }\n                 }));\n \n-                Ok(self.tcx.mk_closure(def_id, substs))\n+                self.tcx.mk_closure(def_id, substs)\n             }\n \n             ty::Generator(def_id, substs, movability) => {\n@@ -256,15 +254,15 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     }\n                 }));\n \n-                Ok(self.tcx.mk_generator(def_id, substs, movability))\n+                self.tcx.mk_generator(def_id, substs, movability)\n             }\n \n             ty::Param(param) => {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ty.into()).map(|k| k.unpack()) {\n                     // Found it in the substitution list; replace with the parameter from the\n                     // opaque type.\n-                    Some(GenericArgKind::Type(t1)) => Ok(t1),\n+                    Some(GenericArgKind::Type(t1)) => t1,\n                     Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n                     None => {\n                         debug!(?param, ?self.map);\n@@ -280,7 +278,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                             )\n                             .emit();\n \n-                        Ok(self.tcx().ty_error())\n+                        self.tcx().ty_error()\n                     }\n                 }\n             }\n@@ -289,13 +287,10 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         }\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         trace!(\"checking const {:?}\", ct);\n         // Find a const parameter\n-        Ok(match ct.val {\n+        match ct.val {\n             ty::ConstKind::Param(..) => {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ct.into()).map(|k| k.unpack()) {\n@@ -322,7 +317,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             }\n \n             _ => ct,\n-        })\n+        }\n     }\n }\n "}, {"sha": "3642aebaec2fb50245fabc556a8ee08ee48c10fc", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -865,11 +865,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n-        Ok((match r {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        (match r {\n             ty::ReVar(vid) => self.vid_to_region.get(vid).cloned(),\n             _ => None,\n         })\n-        .unwrap_or_else(|| r.super_fold_with(self).into_ok()))\n+        .unwrap_or_else(|| r.super_fold_with(self))\n     }\n }"}, {"sha": "4ac02890fce503d4ac503e4fbd3064e7b1de9070", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -1898,15 +1898,15 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.infcx.tcx\n             }\n \n-            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::Param(ty::ParamTy { name, .. }) = *ty.kind() {\n                     let infcx = self.infcx;\n-                    Ok(self.var_map.entry(ty).or_insert_with(|| {\n+                    self.var_map.entry(ty).or_insert_with(|| {\n                         infcx.next_ty_var(TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n                             span: DUMMY_SP,\n                         })\n-                    }))\n+                    })\n                 } else {\n                     ty.super_fold_with(self)\n                 }\n@@ -1916,9 +1916,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         self.probe(|_| {\n             let mut selcx = SelectionContext::new(self);\n \n-            let cleaned_pred = pred\n-                .fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() })\n-                .into_ok();\n+            let cleaned_pred =\n+                pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n \n             let cleaned_pred = super::project::normalize(\n                 &mut selcx,"}, {"sha": "79ed6656819517be45657913fce23d3036349fac", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 50, "deletions": 63, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -339,7 +339,7 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n         if !needs_normalization(&value, self.param_env.reveal()) {\n             value\n         } else {\n-            value.fold_with(self).into_ok()\n+            value.fold_with(self)\n         }\n     }\n }\n@@ -352,16 +352,16 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n+    ) -> ty::Binder<'tcx, T> {\n         self.universes.push(None);\n         let t = t.super_fold_with(self);\n         self.universes.pop();\n         t\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         if !needs_normalization(&ty, self.param_env.reveal()) {\n-            return Ok(ty);\n+            return ty;\n         }\n \n         // We try to be a little clever here as a performance optimization in\n@@ -387,14 +387,14 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n         // replace bound vars if the current type is a `Projection` and we need\n         // to make sure we don't forget to fold the substs regardless.\n \n-        Ok(match *ty.kind() {\n+        match *ty.kind() {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n             ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal() {\n-                    Reveal::UserFacing => ty.super_fold_with(self)?,\n+                    Reveal::UserFacing => ty.super_fold_with(self),\n \n                     Reveal::All => {\n                         let recursion_limit = self.tcx().recursion_limit();\n@@ -408,11 +408,11 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                             self.selcx.infcx().report_overflow_error(&obligation, true);\n                         }\n \n-                        let substs = substs.super_fold_with(self)?;\n+                        let substs = substs.super_fold_with(self);\n                         let generic_ty = self.tcx().type_of(def_id);\n                         let concrete_ty = generic_ty.subst(self.tcx(), substs);\n                         self.depth += 1;\n-                        let folded_ty = self.fold_ty(concrete_ty)?;\n+                        let folded_ty = self.fold_ty(concrete_ty);\n                         self.depth -= 1;\n                         folded_ty\n                     }\n@@ -426,7 +426,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 // register an obligation to *later* project, since we know\n                 // there won't be bound vars there.\n \n-                let data = data.super_fold_with(self)?;\n+                let data = data.super_fold_with(self);\n                 let normalized_ty = normalize_projection_type(\n                     self.selcx,\n                     self.param_env,\n@@ -461,7 +461,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 let infcx = self.selcx.infcx();\n                 let (data, mapped_regions, mapped_types, mapped_consts) =\n                     BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n-                let data = data.super_fold_with(self)?;\n+                let data = data.super_fold_with(self);\n                 let normalized_ty = opt_normalize_projection_type(\n                     self.selcx,\n                     self.param_env,\n@@ -473,18 +473,16 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 .ok()\n                 .flatten()\n                 .map(|normalized_ty| {\n-                    Ok({\n-                        PlaceholderReplacer::replace_placeholders(\n-                            infcx,\n-                            mapped_regions,\n-                            mapped_types,\n-                            mapped_consts,\n-                            &self.universes,\n-                            normalized_ty,\n-                        )\n-                    })\n+                    PlaceholderReplacer::replace_placeholders(\n+                        infcx,\n+                        mapped_regions,\n+                        mapped_types,\n+                        mapped_consts,\n+                        &self.universes,\n+                        normalized_ty,\n+                    )\n                 })\n-                .unwrap_or_else(|| ty.super_fold_with(self))?;\n+                .unwrap_or_else(|| ty.super_fold_with(self));\n \n                 debug!(\n                     ?self.depth,\n@@ -496,19 +494,16 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 normalized_ty\n             }\n \n-            _ => ty.super_fold_with(self)?,\n-        })\n+            _ => ty.super_fold_with(self),\n+        }\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        constant: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if self.selcx.tcx().lazy_normalization() {\n-            Ok(constant)\n+            constant\n         } else {\n-            let constant = constant.super_fold_with(self)?;\n-            Ok(constant.eval(self.selcx.tcx(), self.param_env))\n+            let constant = constant.super_fold_with(self);\n+            constant.eval(self.selcx.tcx(), self.param_env)\n         }\n     }\n }\n@@ -555,7 +550,7 @@ impl<'me, 'tcx> BoundVarReplacer<'me, 'tcx> {\n             universe_indices,\n         };\n \n-        let value = value.super_fold_with(&mut replacer).into_ok();\n+        let value = value.super_fold_with(&mut replacer);\n \n         (value, replacer.mapped_regions, replacer.mapped_types, replacer.mapped_consts)\n     }\n@@ -582,14 +577,14 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n+    ) -> ty::Binder<'tcx, T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, _)\n                 if debruijn.as_usize() + 1\n@@ -601,13 +596,13 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                 let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderRegion { universe, name: br.kind };\n                 self.mapped_regions.insert(p, br);\n-                Ok(self.infcx.tcx.mk_region(ty::RePlaceholder(p)))\n+                self.infcx.tcx.mk_region(ty::RePlaceholder(p))\n             }\n-            _ => Ok(r),\n+            _ => r,\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n             ty::Bound(debruijn, _)\n                 if debruijn.as_usize() + 1\n@@ -619,17 +614,14 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                 let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderType { universe, name: bound_ty.var };\n                 self.mapped_types.insert(p, bound_ty);\n-                Ok(self.infcx.tcx.mk_ty(ty::Placeholder(p)))\n+                self.infcx.tcx.mk_ty(ty::Placeholder(p))\n             }\n             _ if t.has_vars_bound_at_or_above(self.current_index) => t.super_fold_with(self),\n-            _ => Ok(t),\n+            _ => t,\n         }\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match *ct {\n             ty::Const { val: ty::ConstKind::Bound(debruijn, _), ty: _ }\n                 if debruijn.as_usize() + 1\n@@ -646,10 +638,10 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                     name: ty::BoundConst { var: bound_const, ty },\n                 };\n                 self.mapped_consts.insert(p, bound_const);\n-                Ok(self.infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Placeholder(p), ty }))\n+                self.infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Placeholder(p), ty })\n             }\n             _ if ct.has_vars_bound_at_or_above(self.current_index) => ct.super_fold_with(self),\n-            _ => Ok(ct),\n+            _ => ct,\n         }\n     }\n }\n@@ -681,7 +673,7 @@ impl<'me, 'tcx> PlaceholderReplacer<'me, 'tcx> {\n             universe_indices,\n             current_index: ty::INNERMOST,\n         };\n-        value.super_fold_with(&mut replacer).into_ok()\n+        value.super_fold_with(&mut replacer)\n     }\n }\n \n@@ -693,17 +685,17 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n+    ) -> ty::Binder<'tcx, T> {\n         if !t.has_placeholders() && !t.has_infer_regions() {\n-            return Ok(t);\n+            return t;\n         }\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_region(&mut self, r0: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r0: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         let r1 = match r0 {\n             ty::ReVar(_) => self\n                 .infcx\n@@ -737,10 +729,10 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n \n         debug!(?r0, ?r1, ?r2, \"fold_region\");\n \n-        Ok(r2)\n+        r2\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match *ty.kind() {\n             ty::Placeholder(p) => {\n                 let replace_var = self.mapped_types.get(&p);\n@@ -754,21 +746,18 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n                         let db = ty::DebruijnIndex::from_usize(\n                             self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n                         );\n-                        Ok(self.tcx().mk_ty(ty::Bound(db, *replace_var)))\n+                        self.tcx().mk_ty(ty::Bound(db, *replace_var))\n                     }\n-                    None => Ok(ty),\n+                    None => ty,\n                 }\n             }\n \n             _ if ty.has_placeholders() || ty.has_infer_regions() => ty.super_fold_with(self),\n-            _ => Ok(ty),\n+            _ => ty,\n         }\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ty::Const { val: ty::ConstKind::Placeholder(p), ty } = *ct {\n             let replace_var = self.mapped_consts.get(&p);\n             match replace_var {\n@@ -781,11 +770,10 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n                     let db = ty::DebruijnIndex::from_usize(\n                         self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n                     );\n-                    Ok(self\n-                        .tcx()\n-                        .mk_const(ty::Const { val: ty::ConstKind::Bound(db, *replace_var), ty }))\n+                    self.tcx()\n+                        .mk_const(ty::Const { val: ty::ConstKind::Bound(db, *replace_var), ty })\n                 }\n-                None => Ok(ct),\n+                None => ct,\n             }\n         } else {\n             ct.super_fold_with(self)\n@@ -1546,8 +1534,7 @@ fn confirm_candidate<'cx, 'tcx>(\n     // when possible for this to work. See `auto-trait-projection-recursion.rs`\n     // for a case where this matters.\n     if progress.ty.has_infer_regions() {\n-        progress.ty =\n-            OpportunisticRegionResolver::new(selcx.infcx()).fold_ty(progress.ty).into_ok();\n+        progress.ty = OpportunisticRegionResolver::new(selcx.infcx()).fold_ty(progress.ty);\n     }\n     progress\n }"}, {"sha": "d63bef8b8b98fc234e817e8c49a7bcee0e06db37", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::sso::SsoHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_infer::traits::Normalized;\n use rustc_middle::mir;\n-use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeFolderFallible};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitor};\n \n@@ -87,7 +87,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n                 normalizer.universes.extend((0..max_visitor.escaping).map(|_| None));\n             }\n         }\n-        let result = value.fold_with(&mut normalizer);\n+        let result = value.try_fold_with(&mut normalizer);\n         info!(\n             \"normalize::<{}>: result={:?} with {} obligations\",\n             std::any::type_name::<T>(),\n@@ -176,19 +176,21 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     fn tcx<'c>(&'c self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n+}\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(\n+impl<'cx, 'tcx> TypeFolderFallible<'tcx> for QueryNormalizer<'cx, 'tcx> {\n+    fn try_fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n     ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.universes.push(None);\n-        let t = t.super_fold_with(self);\n+        let t = t.try_super_fold_with(self);\n         self.universes.pop();\n         t\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn try_fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !needs_normalization(&ty, self.param_env.reveal()) {\n             return Ok(ty);\n         }\n@@ -208,10 +210,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n             ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal() {\n-                    Reveal::UserFacing => ty.super_fold_with(self),\n+                    Reveal::UserFacing => ty.try_super_fold_with(self),\n \n                     Reveal::All => {\n-                        let substs = substs.super_fold_with(self)?;\n+                        let substs = substs.try_super_fold_with(self)?;\n                         let recursion_limit = self.tcx().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.anon_depth) {\n                             let obligation = Obligation::with_depth(\n@@ -236,7 +238,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                                 ty\n                             );\n                         }\n-                        let folded_ty = ensure_sufficient_stack(|| self.fold_ty(concrete_ty));\n+                        let folded_ty = ensure_sufficient_stack(|| self.try_fold_ty(concrete_ty));\n                         self.anon_depth -= 1;\n                         folded_ty\n                     }\n@@ -248,7 +250,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // we don't need to replace them with placeholders (see branch below).\n \n                 let tcx = self.infcx.tcx;\n-                let data = data.super_fold_with(self)?;\n+                let data = data.try_super_fold_with(self)?;\n \n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n@@ -287,7 +289,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         &mut self.universes,\n                         data,\n                     );\n-                let data = data.super_fold_with(self)?;\n+                let data = data.try_super_fold_with(self)?;\n \n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n@@ -322,24 +324,24 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 ))\n             }\n \n-            _ => ty.super_fold_with(self),\n+            _ => ty.try_super_fold_with(self),\n         })()?;\n         self.cache.insert(ty, res);\n         Ok(res)\n     }\n \n-    fn fold_const(\n+    fn try_fold_const(\n         &mut self,\n         constant: &'tcx ty::Const<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-        let constant = constant.super_fold_with(self)?;\n+        let constant = constant.try_super_fold_with(self)?;\n         Ok(constant.eval(self.infcx.tcx, self.param_env))\n     }\n \n-    fn fold_mir_const(\n+    fn try_fold_mir_const(\n         &mut self,\n         constant: mir::ConstantKind<'tcx>,\n     ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n-        constant.super_fold_with(self)\n+        constant.try_super_fold_with(self)\n     }\n }"}, {"sha": "57f90d4827584e3c5c9673f06dd98c58934bfbb4", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -2154,7 +2154,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n         obligation: &'o TraitObligation<'tcx>,\n     ) -> TraitObligationStack<'o, 'tcx> {\n-        let fresh_trait_pred = obligation.predicate.fold_with(&mut self.freshener).into_ok();\n+        let fresh_trait_pred = obligation.predicate.fold_with(&mut self.freshener);\n \n         let dfn = previous_stack.cache.next_dfn();\n         let depth = previous_stack.depth() + 1;"}, {"sha": "1d457d6761fd084c1e0c7bab1c98ba5f0746921b", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -45,7 +45,7 @@ impl<'tcx> RustIrDatabase<'tcx> {\n         predicates\n             .iter()\n             .map(|(wc, _)| wc.subst(self.interner.tcx, bound_vars))\n-            .map(|wc| wc.fold_with(&mut regions_substitutor).into_ok())\n+            .map(|wc| wc.fold_with(&mut regions_substitutor))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect()\n     }\n \n@@ -287,7 +287,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let trait_ref = trait_ref.subst(self.interner.tcx, bound_vars);\n         let mut regions_substitutor =\n             lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n-        let trait_ref = trait_ref.fold_with(&mut regions_substitutor).into_ok();\n+        let trait_ref = trait_ref.fold_with(&mut regions_substitutor);\n \n         let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n@@ -335,7 +335,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             let self_ty = self_ty.subst(self.interner.tcx, bound_vars);\n             let mut regions_substitutor =\n                 lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n-            let self_ty = self_ty.fold_with(&mut regions_substitutor).into_ok();\n+            let self_ty = self_ty.fold_with(&mut regions_substitutor);\n             let lowered_ty = self_ty.lower_into(&self.interner);\n \n             parameters[0].assert_ty_ref(&self.interner).could_match(\n@@ -501,24 +501,22 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 .iter()\n                 .map(|(bound, _)| bound.subst(self.interner.tcx, &bound_vars))\n                 .map(|bound| {\n-                    bound\n-                        .fold_with(&mut ty::fold::BottomUpFolder {\n-                            tcx: self.interner.tcx,\n-                            ty_op: |ty| {\n-                                if let ty::Opaque(def_id, substs) = *ty.kind() {\n-                                    if def_id == opaque_ty_id.0 && substs == identity_substs {\n-                                        return self.interner.tcx.mk_ty(ty::Bound(\n-                                            ty::INNERMOST,\n-                                            ty::BoundTy::from(ty::BoundVar::from_u32(0)),\n-                                        ));\n-                                    }\n+                    bound.fold_with(&mut ty::fold::BottomUpFolder {\n+                        tcx: self.interner.tcx,\n+                        ty_op: |ty| {\n+                            if let ty::Opaque(def_id, substs) = *ty.kind() {\n+                                if def_id == opaque_ty_id.0 && substs == identity_substs {\n+                                    return self.interner.tcx.mk_ty(ty::Bound(\n+                                        ty::INNERMOST,\n+                                        ty::BoundTy::from(ty::BoundVar::from_u32(0)),\n+                                    ));\n                                 }\n-                                ty\n-                            },\n-                            lt_op: |lt| lt,\n-                            ct_op: |ct| ct,\n-                        })\n-                        .into_ok()\n+                            }\n+                            ty\n+                        },\n+                        lt_op: |lt| lt,\n+                        ct_op: |ct| ct,\n+                    })\n                 })\n                 .filter_map(|bound| {\n                     LowerInto::<"}, {"sha": "e24f699adf6b398d9ec8ee263fa037f6a532752f", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -817,7 +817,7 @@ crate fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n         .collect();\n \n     let mut bound_var_substitutor = NamedBoundVarSubstitutor::new(tcx, &named_parameters);\n-    let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor).into_ok();\n+    let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor);\n \n     for var in named_parameters.values() {\n         parameters.insert(*var, chalk_ir::VariableKind::Lifetime);\n@@ -943,23 +943,20 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(\n-        &mut self,\n-        t: Binder<'tcx, T>,\n-    ) -> Result<Binder<'tcx, T>, Self::Error> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T> {\n         self.binder_index.shift_in(1);\n         let result = t.super_fold_with(self);\n         self.binder_index.shift_out(1);\n         result\n     }\n \n-    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n         match r {\n             ty::ReLateBound(index, br) if *index == self.binder_index => match br.kind {\n                 ty::BrNamed(def_id, _name) => match self.named_parameters.get(&def_id) {\n                     Some(idx) => {\n                         let new_br = ty::BoundRegion { var: br.var, kind: ty::BrAnon(*idx) };\n-                        return Ok(self.tcx.mk_region(RegionKind::ReLateBound(*index, new_br)));\n+                        return self.tcx.mk_region(RegionKind::ReLateBound(*index, new_br));\n                     }\n                     None => panic!(\"Missing `BrNamed`.\"),\n                 },\n@@ -1002,43 +999,40 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(\n-        &mut self,\n-        t: Binder<'tcx, T>,\n-    ) -> Result<Binder<'tcx, T>, Self::Error> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T> {\n         self.binder_index.shift_in(1);\n         let result = t.super_fold_with(self);\n         self.binder_index.shift_out(1);\n         result\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n             // FIXME(chalk): currently we convert params to placeholders starting at\n             // index `0`. To support placeholders, we'll actually need to do a\n             // first pass to collect placeholders. Then we can insert params after.\n             ty::Placeholder(_) => unimplemented!(),\n             ty::Param(param) => match self.list.iter().position(|r| r == &param) {\n-                Some(idx) => Ok(self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                Some(idx) => self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::from_usize(0),\n                     name: ty::BoundVar::from_usize(idx),\n-                }))),\n+                })),\n                 None => {\n                     self.list.push(param);\n                     let idx = self.list.len() - 1 + self.next_ty_placeholder;\n                     self.params.insert(idx, param);\n-                    Ok(self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                    self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                         universe: ty::UniverseIndex::from_usize(0),\n                         name: ty::BoundVar::from_usize(idx),\n-                    })))\n+                    }))\n                 }\n             },\n \n             _ => t.super_fold_with(self),\n         }\n     }\n \n-    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n         match r {\n             // FIXME(chalk) - jackh726 - this currently isn't hit in any tests.\n             // This covers any region variables in a goal, right?\n@@ -1048,14 +1042,14 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n                         var: ty::BoundVar::from_u32(*idx),\n                         kind: ty::BrAnon(*idx),\n                     };\n-                    Ok(self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br)))\n+                    self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n                 }\n                 None => {\n                     let idx = self.named_regions.len() as u32;\n                     let br =\n                         ty::BoundRegion { var: ty::BoundVar::from_u32(idx), kind: ty::BrAnon(idx) };\n                     self.named_regions.insert(_re.def_id, idx);\n-                    Ok(self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br)))\n+                    self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n                 }\n             },\n \n@@ -1131,11 +1125,11 @@ impl<'tcx> TypeFolder<'tcx> for RegionsSubstitutor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n         match r {\n             ty::ReEmpty(ui) => {\n                 assert_eq!(ui.as_usize(), 0);\n-                Ok(self.reempty_placeholder)\n+                self.reempty_placeholder\n             }\n \n             _ => r.super_fold_with(self),"}, {"sha": "b7275bac19048f701feeae31fb0f31654a51bf7a", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -49,12 +49,12 @@ crate fn evaluate_goal<'tcx>(\n \n     let mut params_substitutor =\n         ParamsSubstitutor::new(tcx, placeholders_collector.next_ty_placeholder);\n-    let obligation = obligation.fold_with(&mut params_substitutor).into_ok();\n+    let obligation = obligation.fold_with(&mut params_substitutor);\n     // FIXME(chalk): we really should be substituting these back in the solution\n     let _params: FxHashMap<usize, ParamTy> = params_substitutor.params;\n \n     let mut regions_substitutor = RegionsSubstitutor::new(tcx, reempty_placeholder);\n-    let obligation = obligation.fold_with(&mut regions_substitutor).into_ok();\n+    let obligation = obligation.fold_with(&mut regions_substitutor);\n \n     let max_universe = obligation.max_universe.index();\n "}, {"sha": "8612499623be628ea17c66230ed0cc2af5b3dd0a", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -4,7 +4,6 @@\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n-#![feature(unwrap_infallible)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "f83209f57a897cf54145fd76295746c45faa4e65", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -442,8 +442,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let mut eraser = TypeParamEraser(self, expr.span);\n                             let needs_bound = self\n                                 .lookup_op_method(\n-                                    eraser.fold_ty(lhs_ty).into_ok(),\n-                                    &[eraser.fold_ty(rhs_ty).into_ok()],\n+                                    eraser.fold_ty(lhs_ty),\n+                                    &[eraser.fold_ty(rhs_ty)],\n                                     Op::Binary(op, is_assign),\n                                 )\n                                 .is_ok();\n@@ -1015,12 +1015,12 @@ impl TypeFolder<'tcx> for TypeParamEraser<'_, 'tcx> {\n         self.0.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match ty.kind() {\n-            ty::Param(_) => Ok(self.0.next_ty_var(TypeVariableOrigin {\n+            ty::Param(_) => self.0.next_ty_var(TypeVariableOrigin {\n                 kind: TypeVariableOriginKind::MiscVariable,\n                 span: self.1,\n-            })),\n+            }),\n             _ => ty.super_fold_with(self),\n         }\n     }"}, {"sha": "fdc8b6b5e64519d57642ad6549ec858d880fcc89", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -658,7 +658,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         let mut resolver = Resolver::new(self.fcx, span, self.body);\n-        let x = x.fold_with(&mut resolver).into_ok();\n+        let x = x.fold_with(&mut resolver);\n         if cfg!(debug_assertions) && x.needs_infer() {\n             span_bug!(span.to_span(self.fcx.tcx), \"writeback: `{:?}` has inference variables\", x);\n         }\n@@ -749,15 +749,15 @@ impl<'tcx> TypeFolder<'tcx> for EraseEarlyRegions<'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         if ty.has_type_flags(ty::TypeFlags::HAS_POTENTIAL_FREE_REGIONS) {\n             ty.super_fold_with(self)\n         } else {\n-            Ok(ty)\n+            ty\n         }\n     }\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n-        Ok(if let ty::ReLateBound(..) = r { r } else { self.tcx.lifetimes.re_erased })\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        if let ty::ReLateBound(..) = r { r } else { self.tcx.lifetimes.re_erased }\n     }\n }\n \n@@ -766,7 +766,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match self.infcx.fully_resolve(t) {\n             Ok(t) => {\n                 // Do not anonymize late-bound regions\n@@ -779,29 +779,26 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n                 self.report_type_error(t);\n                 self.replaced_with_error = true;\n-                Ok(self.tcx().ty_error())\n+                self.tcx().ty_error()\n             }\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         debug_assert!(!r.is_late_bound(), \"Should not be resolving bound region.\");\n-        Ok(self.tcx.lifetimes.re_erased)\n+        self.tcx.lifetimes.re_erased\n     }\n \n-    fn fold_const(\n-        &mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-        Ok(match self.infcx.fully_resolve(ct) {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        match self.infcx.fully_resolve(ct) {\n             Ok(ct) => self.infcx.tcx.erase_regions(ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 self.report_const_error(ct);\n                 self.replaced_with_error = true;\n                 self.tcx().const_error(ct.ty)\n             }\n-        })\n+        }\n     }\n }\n "}, {"sha": "04a68250ced0cd0a44387b6fa7d3abf868b03351", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -729,17 +729,17 @@ fn infer_placeholder_type<'a>(\n             self.tcx\n         }\n \n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n             if !self.success {\n-                return Ok(ty);\n+                return ty;\n             }\n \n             match ty.kind() {\n-                ty::FnDef(def_id, _) => Ok(self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id))),\n+                ty::FnDef(def_id, _) => self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id)),\n                 // FIXME: non-capturing closures should also suggest a function pointer\n                 ty::Closure(..) | ty::Generator(..) => {\n                     self.success = false;\n-                    Ok(ty)\n+                    ty\n                 }\n                 _ => ty.super_fold_with(self),\n             }\n@@ -761,7 +761,7 @@ fn infer_placeholder_type<'a>(\n \n                 // Suggesting unnameable types won't help.\n                 let mut mk_nameable = MakeNameable::new(tcx);\n-                let ty = mk_nameable.fold_ty(ty).into_ok();\n+                let ty = mk_nameable.fold_ty(ty);\n                 let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n                 if let Some(sugg_ty) = sugg_ty {\n                     err.span_suggestion(\n@@ -785,7 +785,7 @@ fn infer_placeholder_type<'a>(\n \n             if !ty.references_error() {\n                 let mut mk_nameable = MakeNameable::new(tcx);\n-                let ty = mk_nameable.fold_ty(ty).into_ok();\n+                let ty = mk_nameable.fold_ty(ty);\n                 let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n                 if let Some(sugg_ty) = sugg_ty {\n                     diag.span_suggestion("}, {"sha": "a49eda6572de2cb3cf3248d6a5e317a3ab8ee893", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -71,11 +71,8 @@ fn diagnostic_hir_wf_check<'tcx>(\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n             self.tcx.infer_ctxt().enter(|infcx| {\n                 let mut fulfill = traits::FulfillmentContext::new();\n-                let tcx_ty = self\n-                    .icx\n-                    .to_ty(ty)\n-                    .fold_with(&mut EraseAllBoundRegions { tcx: self.tcx })\n-                    .into_ok();\n+                let tcx_ty =\n+                    self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n                 let cause = traits::ObligationCause::new(\n                     ty.span,\n                     self.hir_id,\n@@ -186,7 +183,7 @@ impl<'tcx> TypeFolder<'tcx> for EraseAllBoundRegions<'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n-    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n-        if let ty::ReLateBound(..) = r { Ok(&ty::ReErased) } else { Ok(r) }\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+        if let ty::ReLateBound(..) = r { &ty::ReErased } else { r }\n     }\n }"}, {"sha": "0881cf07586b367b88210919adef6be38f15c779", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -71,7 +71,6 @@ This API is completely unstable and subject to change.\n #![feature(slice_partition_dedup)]\n #![feature(control_flow_enum)]\n #![feature(hash_drain_filter)]\n-#![feature(unwrap_infallible)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "2ccf17387d1c701febec22a676ea264bd07bb845", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         _ => false,\n                     }\n             })\n-            .map(|p| p.fold_with(&mut replacer).into_ok());\n+            .map(|p| p.fold_with(&mut replacer));\n \n         let mut generic_params =\n             (tcx.generics_of(item_def_id), tcx.explicit_predicates_of(item_def_id))\n@@ -714,11 +714,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n-        Ok((match *r {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        (match *r {\n             ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n             _ => None,\n         })\n-        .unwrap_or_else(|| r.super_fold_with(self).into_ok()))\n+        .unwrap_or_else(|| r.super_fold_with(self))\n     }\n }"}, {"sha": "b6311abb5c3e821f053aa79b1832fa3012bf716e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfc434b6d0e64dab88def4c5282eeb4a294faf76/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc434b6d0e64dab88def4c5282eeb4a294faf76/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=bfc434b6d0e64dab88def4c5282eeb4a294faf76", "patch": "@@ -18,7 +18,6 @@\n #![feature(type_ascription)]\n #![feature(iter_intersperse)]\n #![recursion_limit = \"256\"]\n-#![feature(unwrap_infallible)]\n #![warn(rustc::internal)]\n \n #[macro_use]"}]}