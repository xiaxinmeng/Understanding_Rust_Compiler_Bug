{"sha": "06aef339f11091f178957350b5159081e7b4534a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YWVmMzM5ZjExMDkxZjE3ODk1NzM1MGI1MTU5MDgxZTdiNDUzNGE=", "commit": {"author": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2015-05-14T03:32:52Z"}, "committer": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2015-05-14T07:04:51Z"}, "message": "Add error explanations for E0053, E0251, E0252, E0255, E0256, E0368.", "tree": {"sha": "e7998e5833420d15bb50ee32712cdd41aa465fd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7998e5833420d15bb50ee32712cdd41aa465fd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06aef339f11091f178957350b5159081e7b4534a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06aef339f11091f178957350b5159081e7b4534a", "html_url": "https://github.com/rust-lang/rust/commit/06aef339f11091f178957350b5159081e7b4534a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06aef339f11091f178957350b5159081e7b4534a/comments", "author": null, "committer": null, "parents": [{"sha": "a4444aa78079665658b0d656c6d243d88a9ac5cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4444aa78079665658b0d656c6d243d88a9ac5cc", "html_url": "https://github.com/rust-lang/rust/commit/a4444aa78079665658b0d656c6d243d88a9ac5cc"}], "stats": {"total": 172, "additions": 164, "deletions": 8}, "files": [{"sha": "cd941c65b9da31e174422c2fc008b407bd6b0a59", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 84, "deletions": 6, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/06aef339f11091f178957350b5159081e7b4534a/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06aef339f11091f178957350b5159081e7b4534a/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=06aef339f11091f178957350b5159081e7b4534a", "patch": "@@ -49,6 +49,88 @@ about what constitutes an Item declaration and what does not:\n http://doc.rust-lang.org/reference.html#statements\n \"##,\n \n+E0251: r##\"\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+An example of this error:\n+\n+```\n+use foo::baz;\n+use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\"##,\n+\n+E0252: r##\"\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+An example of this error:\n+\n+```\n+use foo::baz;\n+use bar::baz; // error, do `use bar::baz as quux` instead\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\"##,\n+\n+E0255: r##\"\n+You can't import a value whose name is the same as another value defined in the\n+module.\n+\n+An example of this error:\n+\n+```\n+use foo::FOO; // error, do `use foo::FOO as BAR` instead\n+\n+fn FOO() {}\n+\n+mod foo {\n+    pub const FOO: bool = true;\n+}\n+\n+fn main() {}\n+```\n+\"##,\n+\n+E0256: r##\"\n+You can't import a type or module when the name of the item being imported is\n+the same as another type or submodule defined in the module.\n+\n+An example of this error:\n+\n+```\n+use foo::Bar; // error\n+\n+struct Bar;\n+\n+mod foo {\n+    pub mod Bar { }\n+}\n+\n+fn main() {}\n+```\n+\"##,\n+\n E0259: r##\"\n The name chosen for an external crate conflicts with another external crate that\n has been imported into the current module.\n@@ -122,14 +204,10 @@ http://doc.rust-lang.org/reference.html#types\n register_diagnostics! {\n     E0157,\n     E0153,\n-    E0251, // a named type or value has already been imported in this module\n-    E0252, // a named type or value has already been imported in this module\n     E0253, // not directly importable\n     E0254, // import conflicts with imported crate in this module\n-    E0255, // import conflicts with value in this module\n-    E0256, // import conflicts with type in this module\n-    E0257, // inherent implementations are only allowed on types defined in the current module\n-    E0258, // import conflicts with existing submodule\n+    E0257,\n+    E0258,\n     E0364, // item is private\n     E0365  // item is private\n }"}, {"sha": "d19bb859c775086727e94f504d1391bf45ba84a6", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/06aef339f11091f178957350b5159081e7b4534a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06aef339f11091f178957350b5159081e7b4534a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=06aef339f11091f178957350b5159081e7b4534a", "patch": "@@ -64,6 +64,44 @@ impl Foo for Bar {\n ```\n \"##,\n \n+E0053: r##\"\n+In a trait method implementation, the function signature must match exactly.\n+This error indicates a mutability mismatch between a trait method signature\n+and the signature of the implementation.\n+\n+Here's an example where the mutability of the `self` parameter is wrong:\n+\n+```\n+trait Foo { fn foo(&self); }\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, the signature should be `fn foo(&self)` instead\n+    fn foo(&mut self) { }\n+}\n+\n+fn main() {}\n+```\n+\n+Here's another example, this time for a non-`self` parameter:\n+\n+```\n+trait Foo { fn foo(x: &mut bool) -> bool; }\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, the type of `x` should be `&mut bool` instead\n+    fn foo(x: &bool) -> bool { *x }\n+}\n+\n+fn main() {}\n+```\n+\n+\n+\"##,\n+\n E0054: r##\"\n It is not allowed to cast to a bool. If you are trying to cast a numeric type\n to a bool, you can compare it with zero instead:\n@@ -483,6 +521,48 @@ The `Sized` trait is a special trait built-in to the compiler for types with a\n constant size known at compile-time. This trait is automatically implemented\n for types as needed by the compiler, and it is currently disallowed to\n explicitly implement it for a type.\n+\"##,\n+\n+E0368: r##\"\n+This error indicates that a binary assignment operator like `+=` or `^=` was\n+applied to the wrong types.\n+\n+A couple examples of this are as follows:\n+\n+```\n+let mut x: u16 = 5;\n+x ^= true; // error, `^=` cannot be applied to types `u16` and `bool`\n+x += ();   // error, `+=` cannot be applied to types `u16` and `()`\n+```\n+\n+Another problem you might be facing is this: suppose you've overloaded the `+`\n+operator for some type `Foo` by implementing the `std::ops::Add` trait for\n+`Foo`, but you find that using `+=` does not work, as in this example:\n+\n+```\n+use std::ops::Add;\n+\n+struct Foo(u32);\n+\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, rhs: Foo) -> Foo {\n+        Foo(self.0 + rhs.0)\n+    }\n+}\n+\n+fn main() {\n+    let mut x: Foo = Foo(5);\n+    x += Foo(7); // error, `+= cannot be applied to types `Foo` and `Foo`\n+}\n+```\n+\n+This is because the binary assignment operators currently do not work off of\n+traits, so it is not possible to overload them. See [RFC 953] for a proposal\n+to change this.\n+\n+[RFC 953]: https://github.com/rust-lang/rfcs/pull/953\n \"##\n \n }\n@@ -503,7 +583,6 @@ register_diagnostics! {\n     E0040, // explicit use of destructor method\n     E0044, // foreign items may not have type parameters\n     E0045, // variadic function must have C calling convention\n-    E0053,\n     E0055, // method has an incompatible type for trait\n     E0057, // method has an incompatible type for trait\n     E0059,\n@@ -629,7 +708,6 @@ register_diagnostics! {\n     E0328, // cannot implement Unsize explicitly\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n-    E0368, // binary operation `<op>=` cannot be applied to types\n     E0369, // binary operation `<op>` cannot be applied to types\n     E0371, // impl Trait for Trait is illegal\n     E0372, // impl Trait for Trait where Trait is not object safe"}]}