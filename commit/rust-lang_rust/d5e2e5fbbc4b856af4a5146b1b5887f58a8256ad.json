{"sha": "d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZTJlNWZiYmM0Yjg1NmFmNGE1MTQ2YjFiNTg4N2Y1OGE4MjU2YWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-19T10:58:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-19T10:58:53Z"}, "message": "Auto merge of #31738 - seanmonstar:sys-rand, r=alexcrichton", "tree": {"sha": "c4dbb8bedacfa45974f9ccece93a26cd5c493ed7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4dbb8bedacfa45974f9ccece93a26cd5c493ed7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad", "html_url": "https://github.com/rust-lang/rust/commit/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15611f75ca49bd6c40ecbe84caa44cb74a9781f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/15611f75ca49bd6c40ecbe84caa44cb74a9781f4", "html_url": "https://github.com/rust-lang/rust/commit/15611f75ca49bd6c40ecbe84caa44cb74a9781f4"}, {"sha": "34dfc3991db26a363657f0bd56db1669032468b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/34dfc3991db26a363657f0bd56db1669032468b3", "html_url": "https://github.com/rust-lang/rust/commit/34dfc3991db26a363657f0bd56db1669032468b3"}], "stats": {"total": 335, "additions": 167, "deletions": 168}, "files": [{"sha": "3f14fcd239f1d0ceb2d6d36f32da74a3a845c345", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 93, "deletions": 2, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad", "patch": "@@ -62,6 +62,7 @@ use cell::RefCell;\n use io;\n use mem;\n use rc::Rc;\n+use sys;\n \n #[cfg(target_pointer_width = \"32\")]\n use core_rand::IsaacRng as IsaacWordRng;\n@@ -71,9 +72,7 @@ use core_rand::Isaac64Rng as IsaacWordRng;\n pub use core_rand::{Rand, Rng, SeedableRng};\n pub use core_rand::{XorShiftRng, IsaacRng, Isaac64Rng};\n pub use core_rand::reseeding;\n-pub use rand::os::OsRng;\n \n-pub mod os;\n pub mod reader;\n \n /// The standard RNG. This is designed to be efficient on the current\n@@ -185,3 +184,95 @@ impl Rng for ThreadRng {\n         self.rng.borrow_mut().fill_bytes(bytes)\n     }\n }\n+\n+/// A random number generator that retrieves randomness straight from\n+/// the operating system. Platform sources:\n+///\n+/// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n+/// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+///   service provider with the `PROV_RSA_FULL` type.\n+/// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n+/// - OpenBSD: uses the `getentropy(2)` system call.\n+///\n+/// This does not block.\n+pub struct OsRng(sys::rand::OsRng);\n+\n+impl OsRng {\n+    /// Create a new `OsRng`.\n+    pub fn new() -> io::Result<OsRng> {\n+        sys::rand::OsRng::new().map(OsRng)\n+    }\n+}\n+\n+impl Rng for OsRng {\n+    #[inline]\n+    fn next_u32(&mut self) -> u32 {\n+        self.0.next_u32()\n+    }\n+\n+    #[inline]\n+    fn next_u64(&mut self) -> u64 {\n+        self.0.next_u64()\n+    }\n+\n+    #[inline]\n+    fn fill_bytes(&mut self, bytes: &mut [u8]) {\n+        self.0.fill_bytes(bytes)\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use sync::mpsc::channel;\n+    use rand::Rng;\n+    use super::OsRng;\n+    use thread;\n+\n+    #[test]\n+    fn test_os_rng() {\n+        let mut r = OsRng::new().unwrap();\n+\n+        r.next_u32();\n+        r.next_u64();\n+\n+        let mut v = [0; 1000];\n+        r.fill_bytes(&mut v);\n+    }\n+\n+    #[test]\n+    fn test_os_rng_tasks() {\n+\n+        let mut txs = vec!();\n+        for _ in 0..20 {\n+            let (tx, rx) = channel();\n+            txs.push(tx);\n+\n+            thread::spawn(move|| {\n+                // wait until all the threads are ready to go.\n+                rx.recv().unwrap();\n+\n+                // deschedule to attempt to interleave things as much\n+                // as possible (XXX: is this a good test?)\n+                let mut r = OsRng::new().unwrap();\n+                thread::yield_now();\n+                let mut v = [0; 1000];\n+\n+                for _ in 0..100 {\n+                    r.next_u32();\n+                    thread::yield_now();\n+                    r.next_u64();\n+                    thread::yield_now();\n+                    r.fill_bytes(&mut v);\n+                    thread::yield_now();\n+                }\n+            });\n+        }\n+\n+        // start all the threads\n+        for tx in &txs {\n+            tx.send(()).unwrap();\n+        }\n+    }\n+}"}, {"sha": "c332d6035ee8d8d789ccf681bbae8c754cdd55a8", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad", "patch": "@@ -42,6 +42,7 @@ pub mod os;\n pub mod os_str;\n pub mod pipe;\n pub mod process;\n+pub mod rand;\n pub mod rwlock;\n pub mod stack_overflow;\n pub mod thread;"}, {"sha": "fa504ade084fc3f3b4d043f318d09df9342625e6", "filename": "src/libstd/sys/unix/rand.rs", "status": "renamed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Interfaces to the operating system provided random number\n-//! generators.\n-\n pub use self::imp::OsRng;\n \n #[cfg(all(unix, not(target_os = \"ios\"), not(target_os = \"openbsd\")))]\n@@ -125,17 +122,6 @@ mod imp {\n                       target_arch = \"powerpc64\"))))]\n     fn is_getrandom_available() -> bool { false }\n \n-    /// A random number generator that retrieves randomness straight from\n-    /// the operating system. Platform sources:\n-    ///\n-    /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-    ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n-    /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n-    ///   service provider with the `PROV_RSA_FULL` type.\n-    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n-    /// - OpenBSD: uses the `getentropy(2)` system call.\n-    ///\n-    /// This does not block.\n     pub struct OsRng {\n         inner: OsRngInner,\n     }\n@@ -189,17 +175,6 @@ mod imp {\n     use sys::os::errno;\n     use rand::Rng;\n \n-    /// A random number generator that retrieves randomness straight from\n-    /// the operating system. Platform sources:\n-    ///\n-    /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-    ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n-    /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n-    ///   service provider with the `PROV_RSA_FULL` type.\n-    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n-    /// - OpenBSD: uses the `getentropy(2)` system call.\n-    ///\n-    /// This does not block.\n     pub struct OsRng {\n         // dummy field to ensure that this struct cannot be constructed outside\n         // of this module\n@@ -246,17 +221,6 @@ mod imp {\n     use rand::Rng;\n     use libc::{c_int, size_t};\n \n-    /// A random number generator that retrieves randomness straight from\n-    /// the operating system. Platform sources:\n-    ///\n-    /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-    ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n-    /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n-    ///   service provider with the `PROV_RSA_FULL` type.\n-    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n-    /// - OpenBSD: uses the `getentropy(2)` system call.\n-    ///\n-    /// This does not block.\n     pub struct OsRng {\n         // dummy field to ensure that this struct cannot be constructed outside\n         // of this module\n@@ -307,133 +271,3 @@ mod imp {\n         }\n     }\n }\n-\n-#[cfg(windows)]\n-mod imp {\n-    use io;\n-    use mem;\n-    use rand::Rng;\n-    use sys::c;\n-\n-    /// A random number generator that retrieves randomness straight from\n-    /// the operating system. Platform sources:\n-    ///\n-    /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-    ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n-    /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n-    ///   service provider with the `PROV_RSA_FULL` type.\n-    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n-    /// - OpenBSD: uses the `getentropy(2)` system call.\n-    ///\n-    /// This does not block.\n-    pub struct OsRng {\n-        hcryptprov: c::HCRYPTPROV\n-    }\n-\n-    impl OsRng {\n-        /// Create a new `OsRng`.\n-        pub fn new() -> io::Result<OsRng> {\n-            let mut hcp = 0;\n-            let ret = unsafe {\n-                c::CryptAcquireContextA(&mut hcp, 0 as c::LPCSTR, 0 as c::LPCSTR,\n-                                        c::PROV_RSA_FULL,\n-                                        c::CRYPT_VERIFYCONTEXT | c::CRYPT_SILENT)\n-            };\n-\n-            if ret == 0 {\n-                Err(io::Error::last_os_error())\n-            } else {\n-                Ok(OsRng { hcryptprov: hcp })\n-            }\n-        }\n-    }\n-\n-    impl Rng for OsRng {\n-        fn next_u32(&mut self) -> u32 {\n-            let mut v = [0; 4];\n-            self.fill_bytes(&mut v);\n-            unsafe { mem::transmute(v) }\n-        }\n-        fn next_u64(&mut self) -> u64 {\n-            let mut v = [0; 8];\n-            self.fill_bytes(&mut v);\n-            unsafe { mem::transmute(v) }\n-        }\n-        fn fill_bytes(&mut self, v: &mut [u8]) {\n-            let ret = unsafe {\n-                c::CryptGenRandom(self.hcryptprov, v.len() as c::DWORD,\n-                                  v.as_mut_ptr())\n-            };\n-            if ret == 0 {\n-                panic!(\"couldn't generate random bytes: {}\",\n-                       io::Error::last_os_error());\n-            }\n-        }\n-    }\n-\n-    impl Drop for OsRng {\n-        fn drop(&mut self) {\n-            let ret = unsafe {\n-                c::CryptReleaseContext(self.hcryptprov, 0)\n-            };\n-            if ret == 0 {\n-                panic!(\"couldn't release context: {}\",\n-                       io::Error::last_os_error());\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use sync::mpsc::channel;\n-    use rand::Rng;\n-    use super::OsRng;\n-    use thread;\n-\n-    #[test]\n-    fn test_os_rng() {\n-        let mut r = OsRng::new().unwrap();\n-\n-        r.next_u32();\n-        r.next_u64();\n-\n-        let mut v = [0; 1000];\n-        r.fill_bytes(&mut v);\n-    }\n-\n-    #[test]\n-    fn test_os_rng_tasks() {\n-\n-        let mut txs = vec!();\n-        for _ in 0..20 {\n-            let (tx, rx) = channel();\n-            txs.push(tx);\n-\n-            thread::spawn(move|| {\n-                // wait until all the threads are ready to go.\n-                rx.recv().unwrap();\n-\n-                // deschedule to attempt to interleave things as much\n-                // as possible (XXX: is this a good test?)\n-                let mut r = OsRng::new().unwrap();\n-                thread::yield_now();\n-                let mut v = [0; 1000];\n-\n-                for _ in 0..100 {\n-                    r.next_u32();\n-                    thread::yield_now();\n-                    r.next_u64();\n-                    thread::yield_now();\n-                    r.fill_bytes(&mut v);\n-                    thread::yield_now();\n-                }\n-            });\n-        }\n-\n-        // start all the threads\n-        for tx in &txs {\n-            tx.send(()).unwrap();\n-        }\n-    }\n-}", "previous_filename": "src/libstd/rand/os.rs"}, {"sha": "765e6e09427641cc127e38fc30a02409be033bed", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad", "patch": "@@ -33,6 +33,7 @@ pub mod os;\n pub mod os_str;\n pub mod pipe;\n pub mod process;\n+pub mod rand;\n pub mod rwlock;\n pub mod stack_overflow;\n pub mod thread;"}, {"sha": "fdd260b6e28844959fed6fd2860fde4a4194c410", "filename": "src/libstd/sys/windows/rand.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs?ref=d5e2e5fbbc4b856af4a5146b1b5887f58a8256ad", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use io;\n+use mem;\n+use rand::Rng;\n+use sys::c;\n+\n+pub struct OsRng {\n+    hcryptprov: c::HCRYPTPROV\n+}\n+\n+impl OsRng {\n+    /// Create a new `OsRng`.\n+    pub fn new() -> io::Result<OsRng> {\n+        let mut hcp = 0;\n+        let ret = unsafe {\n+            c::CryptAcquireContextA(&mut hcp, 0 as c::LPCSTR, 0 as c::LPCSTR,\n+                                    c::PROV_RSA_FULL,\n+                                    c::CRYPT_VERIFYCONTEXT | c::CRYPT_SILENT)\n+        };\n+\n+        if ret == 0 {\n+            Err(io::Error::last_os_error())\n+        } else {\n+            Ok(OsRng { hcryptprov: hcp })\n+        }\n+    }\n+}\n+\n+impl Rng for OsRng {\n+    fn next_u32(&mut self) -> u32 {\n+        let mut v = [0; 4];\n+        self.fill_bytes(&mut v);\n+        unsafe { mem::transmute(v) }\n+    }\n+    fn next_u64(&mut self) -> u64 {\n+        let mut v = [0; 8];\n+        self.fill_bytes(&mut v);\n+        unsafe { mem::transmute(v) }\n+    }\n+    fn fill_bytes(&mut self, v: &mut [u8]) {\n+        let ret = unsafe {\n+            c::CryptGenRandom(self.hcryptprov, v.len() as c::DWORD,\n+                              v.as_mut_ptr())\n+        };\n+        if ret == 0 {\n+            panic!(\"couldn't generate random bytes: {}\",\n+                   io::Error::last_os_error());\n+        }\n+    }\n+}\n+\n+impl Drop for OsRng {\n+    fn drop(&mut self) {\n+        let ret = unsafe {\n+            c::CryptReleaseContext(self.hcryptprov, 0)\n+        };\n+        if ret == 0 {\n+            panic!(\"couldn't release context: {}\",\n+                   io::Error::last_os_error());\n+        }\n+    }\n+}"}]}