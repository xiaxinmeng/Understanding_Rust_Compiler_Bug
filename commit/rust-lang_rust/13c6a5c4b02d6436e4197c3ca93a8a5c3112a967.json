{"sha": "13c6a5c4b02d6436e4197c3ca93a8a5c3112a967", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzYzZhNWM0YjAyZDY0MzZlNDE5N2MzY2E5M2E4YTVjMzExMmE5Njc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-07-29T13:19:16Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-07-29T13:19:16Z"}, "message": "Avoid optimizing trivia for now", "tree": {"sha": "efaeaedca21c1727976a1aa67e2c76b13feccd18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efaeaedca21c1727976a1aa67e2c76b13feccd18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967", "html_url": "https://github.com/rust-lang/rust/commit/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "415c891d641fa305e7ddbbbcc78db990dd5d3564", "url": "https://api.github.com/repos/rust-lang/rust/commits/415c891d641fa305e7ddbbbcc78db990dd5d3564", "html_url": "https://github.com/rust-lang/rust/commit/415c891d641fa305e7ddbbbcc78db990dd5d3564"}], "stats": {"total": 368, "additions": 143, "deletions": 225}, "files": [{"sha": "73b4b5ff9e0154ebd6dab18b18f99f317a572abd", "filename": "src/yellow/builder.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967/src%2Fyellow%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967/src%2Fyellow%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fbuilder.rs?ref=13c6a5c4b02d6436e4197c3ca93a8a5c3112a967", "patch": "@@ -1,13 +1,12 @@\n-use std::sync::Arc;\n use {\n     SyntaxKind, TextRange, TextUnit,\n-    yellow::{SyntaxNode, GreenNode, SyntaxError},\n+    yellow::{SyntaxNode, GreenNode, GreenNodeBuilder, SyntaxError},\n     parser::Sink\n };\n \n pub(crate) struct GreenBuilder {\n     text: String,\n-    stack: Vec<GreenNode>,\n+    stack: Vec<GreenNodeBuilder>,\n     pos: TextUnit,\n     root: Option<GreenNode>,\n     errors: Vec<SyntaxError>,\n@@ -33,24 +32,21 @@ impl Sink for GreenBuilder {\n     fn leaf(&mut self, kind: SyntaxKind, len: TextUnit) {\n         let range = TextRange::offset_len(self.pos, len);\n         self.pos += len;\n-        let text = self.text[range].to_owned();\n+        let text = &self.text[range];\n+        let leaf = GreenNodeBuilder::new_leaf(kind, text);\n         let parent = self.stack.last_mut().unwrap();\n-        if kind.is_trivia() {\n-            parent.push_trivia(kind, text);\n-        } else {\n-            let node = GreenNode::new_leaf(kind, text);\n-            parent.push_child(Arc::new(node));\n-        }\n+        parent.push_child(leaf)\n     }\n \n     fn start_internal(&mut self, kind: SyntaxKind) {\n-        self.stack.push(GreenNode::new_branch(kind))\n+        self.stack.push(GreenNodeBuilder::new_internal(kind))\n     }\n \n     fn finish_internal(&mut self) {\n-        let node = self.stack.pop().unwrap();\n+        let builder = self.stack.pop().unwrap();\n+        let node = builder.build();\n         if let Some(parent) = self.stack.last_mut() {\n-            parent.push_child(Arc::new(node))\n+            parent.push_child(node);\n         } else {\n             self.root = Some(node);\n         }\n@@ -61,7 +57,7 @@ impl Sink for GreenBuilder {\n     }\n \n     fn finish(self) -> SyntaxNode {\n-        SyntaxNode::new(Arc::new(self.root.unwrap()), self.errors)\n+        SyntaxNode::new(self.root.unwrap(), self.errors)\n     }\n }\n "}, {"sha": "cb9dff128c552dee1cd32616ed440642e92ff00c", "filename": "src/yellow/green.rs", "status": "modified", "additions": 104, "deletions": 132, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967/src%2Fyellow%2Fgreen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967/src%2Fyellow%2Fgreen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fgreen.rs?ref=13c6a5c4b02d6436e4197c3ca93a8a5c3112a967", "patch": "@@ -1,187 +1,159 @@\n use std::sync::Arc;\n-use text_unit::TextUnit;\n-use SyntaxKind;\n+use {SyntaxKind::{self, *}, TextUnit};\n \n-type TokenText = String;\n-\n-#[derive(Debug)]\n-pub(crate) struct GreenNode {\n-    kind: SyntaxKind,\n-    data: GreenNodeData,\n+#[derive(Clone, Debug)]\n+pub(crate) enum GreenNode {\n+    Leaf(GreenLeaf),\n+    Branch(Arc<GreenBranch>),\n }\n \n impl GreenNode {\n-    pub(crate) fn new_leaf(kind: SyntaxKind, text: TokenText) -> GreenNode {\n-        GreenNode {\n-            kind,\n-            data: GreenNodeData::Leaf(GreenLeaf { text }),\n+    pub fn kind(&self) -> SyntaxKind {\n+        match self {\n+            GreenNode::Leaf(l) => l.kind(),\n+            GreenNode::Branch(b) => b.kind(),\n         }\n     }\n \n-    pub(crate) fn new_branch(\n-        kind: SyntaxKind,\n-    ) -> GreenNode {\n-        let branch = GreenBranch {\n-            text_len: 0.into(),\n-            leading_trivia: Trivias::default(),\n-            children: Vec::new(),\n-        };\n-        GreenNode {\n-            kind,\n-            data: GreenNodeData::Branch(branch),\n+    pub fn text_len(&self) -> TextUnit {\n+        match self {\n+            GreenNode::Leaf(l) => l.text_len(),\n+            GreenNode::Branch(b) => b.text_len(),\n         }\n     }\n \n-    pub(crate) fn push_trivia(&mut self, kind: SyntaxKind, text: TokenText) {\n-        let branch = match &mut self.data {\n-            GreenNodeData::Branch(branch) => branch,\n-            _ => panic!()\n-        };\n-        branch.text_len += TextUnit::of_str(&text);\n-        let leading = &mut branch.leading_trivia;\n-        branch.children.last_mut().map(|(_, t)| t).unwrap_or(leading)\n-            .push(Arc::new(GreenTrivia { kind, text }));\n-    }\n-\n-    pub(crate) fn push_child(&mut self, node: Arc<GreenNode>) {\n-        let branch = match &mut self.data {\n-            GreenNodeData::Branch(branch) => branch,\n-            _ => panic!()\n-        };\n-        branch.text_len += node.text_len();\n-        branch.children.push((node, Trivias::default()));\n-    }\n-\n-    pub(crate) fn kind(&self) -> SyntaxKind {\n-        self.kind\n-    }\n-\n-    pub(crate) fn text_len(&self) -> TextUnit {\n-        match &self.data {\n-            GreenNodeData::Leaf(l) => l.text_len(),\n-            GreenNodeData::Branch(b) => b.text_len(),\n+    pub fn children(&self) -> &[GreenNode] {\n+        match self {\n+            GreenNode::Leaf(_) => &[],\n+            GreenNode::Branch(b) => b.children(),\n         }\n     }\n \n-    pub(crate) fn text(&self) -> String {\n+    pub fn text(&self) -> String {\n         let mut buff = String::new();\n         go(self, &mut buff);\n         return buff;\n         fn go(node: &GreenNode, buff: &mut String) {\n-            match &node.data {\n-                GreenNodeData::Leaf(l) => buff.push_str(&l.text),\n-                GreenNodeData::Branch(branch) => {\n-                    add_trivia(&branch.leading_trivia, buff);\n-                    branch.children.iter().for_each(|(child, trivias)| {\n-                        go(child, buff);\n-                        add_trivia(trivias, buff);\n-                    })\n+            match node {\n+                GreenNode::Leaf(l) => buff.push_str(&l.text()),\n+                GreenNode::Branch(b) => {\n+                    b.children().iter().for_each(|child| go(child, buff))\n                 }\n             }\n         }\n-\n-        fn add_trivia(trivias: &Trivias, buff: &mut String) {\n-            trivias.iter().for_each(|t| buff.push_str(&t.text))\n-        }\n     }\n+}\n \n-    pub(crate) fn n_children(&self) -> usize {\n-        match &self.data {\n-            GreenNodeData::Leaf(_) => 0,\n-            GreenNodeData::Branch(branch) => branch.children.len(),\n-        }\n-    }\n+pub(crate) struct GreenNodeBuilder {\n+    kind: SyntaxKind,\n+    children: Vec<GreenNode>,\n+}\n \n-    pub(crate) fn nth_child(&self, idx: usize) -> &Arc<GreenNode> {\n-        match &self.data {\n-            GreenNodeData::Leaf(_) => panic!(\"leaf nodes have no children\"),\n-            GreenNodeData::Branch(branch) => &branch.children[idx].0,\n-        }\n+impl GreenNodeBuilder {\n+    pub(crate) fn new_leaf(kind: SyntaxKind, text: &str) -> GreenNode {\n+        GreenNode::Leaf(GreenLeaf::new(kind, text))\n     }\n \n-    pub(crate) fn nth_trivias(&self, idx: usize) -> &Trivias {\n-        match &self.data {\n-            GreenNodeData::Leaf(_) => panic!(\"leaf nodes have no children\"),\n-            GreenNodeData::Branch(branch) => if idx == 0 {\n-                &branch.leading_trivia\n-            } else {\n-                &branch.children[idx - 1].1\n-            },\n+    pub(crate) fn new_internal(kind: SyntaxKind) -> GreenNodeBuilder {\n+        GreenNodeBuilder {\n+            kind,\n+            children: Vec::new(),\n         }\n     }\n \n-    pub(crate) fn is_leaf(&self) -> bool {\n-        match self.data {\n-            GreenNodeData::Leaf(_) => true,\n-            GreenNodeData::Branch(_) => false\n-        }\n+    pub(crate) fn push_child(&mut self, node: GreenNode) {\n+        self.children.push(node)\n     }\n-}\n \n-#[derive(Debug)]\n-enum GreenNodeData {\n-    Leaf(GreenLeaf),\n-    Branch(GreenBranch),\n+    pub(crate) fn build(self) -> GreenNode {\n+        let branch = GreenBranch::new(self.kind, self.children);\n+        GreenNode::Branch(Arc::new(branch))\n+    }\n }\n \n-#[derive(Debug)]\n-struct GreenLeaf {\n-    text: TokenText\n-}\n \n-#[derive(Debug)]\n-struct GreenBranch {\n-    text_len: TextUnit,\n-    leading_trivia: Trivias,\n-    children: Vec<(Arc<GreenNode>, Trivias)>,\n+#[test]\n+fn assert_send_sync() {\n+    fn f<T: Send + Sync>() {}\n+    f::<GreenNode>();\n }\n \n-#[derive(Debug)]\n-pub(crate) struct GreenTrivia {\n-    pub(crate) kind: SyntaxKind,\n-    pub(crate) text: TokenText,\n+#[derive(Clone, Debug)]\n+pub(crate) enum GreenLeaf {\n+    Whitespace {\n+        newlines: u8,\n+        spaces: u8,\n+    },\n+    Token {\n+        kind: SyntaxKind,\n+        text: Arc<str>,\n+    },\n }\n \n-type Trivias = Vec<Arc<GreenTrivia>>;\n+impl GreenLeaf {\n+    fn new(kind: SyntaxKind, text: &str) -> Self {\n+        if kind == WHITESPACE {\n+            let newlines = text.bytes().take_while(|&b| b == b'\\n').count();\n+            let spaces = text[newlines..].bytes().take_while(|&b| b == b' ').count();\n+            if newlines + spaces == text.len() && newlines <= N_NEWLINES && spaces <= N_SPACES {\n+                return GreenLeaf::Whitespace { newlines: newlines as u8, spaces: spaces as u8 };\n+            }\n+        }\n+        GreenLeaf::Token { kind, text: text.to_owned().into_boxed_str().into() }\n+    }\n \n+    pub(crate) fn kind(&self) -> SyntaxKind {\n+        match self {\n+            GreenLeaf::Whitespace { .. } => WHITESPACE,\n+            GreenLeaf::Token { kind, .. } => *kind,\n+        }\n+    }\n \n-pub(crate) trait TextLen {\n-    fn text_len(&self) -> TextUnit;\n-}\n+    pub(crate) fn text(&self) -> &str {\n+        match self {\n+            &GreenLeaf::Whitespace { newlines, spaces } => {\n+                let newlines = newlines as usize;\n+                let spaces = spaces as usize;\n+                assert!(newlines <= N_NEWLINES && spaces <= N_SPACES);\n+                &WS[N_NEWLINES - newlines..N_NEWLINES + spaces]\n+            }\n+            GreenLeaf::Token { text, .. } => text,\n+        }\n+    }\n \n-impl TextLen for GreenTrivia {\n-    fn text_len(&self) -> TextUnit {\n-        TextUnit::of_str(&self.text)\n+    pub(crate) fn text_len(&self) -> TextUnit {\n+        TextUnit::of_str(self.text())\n     }\n }\n \n-impl<T: TextLen> TextLen for Arc<T> {\n-    fn text_len(&self) -> TextUnit {\n-        let this: &T = self;\n-        this.text_len()\n-    }\n+const N_NEWLINES: usize = 16;\n+const N_SPACES: usize = 64;\n+const WS: &str =\n+    \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n                                                                \";\n+\n+#[derive(Clone, Debug)]\n+pub(crate) struct GreenBranch {\n+    text_len: TextUnit,\n+    kind: SyntaxKind,\n+    children: Vec<GreenNode>,\n }\n \n-impl TextLen for GreenNode {\n-    fn text_len(&self) -> TextUnit {\n-        self.text_len()\n+impl GreenBranch {\n+    fn new(kind: SyntaxKind, children: Vec<GreenNode>) -> GreenBranch {\n+        let text_len = children.iter().map(|x| x.text_len()).sum::<TextUnit>();\n+        GreenBranch { text_len, kind, children }\n     }\n-}\n \n-impl TextLen for GreenLeaf {\n-    fn text_len(&self) -> TextUnit {\n-        TextUnit::of_str(&self.text)\n+    pub fn kind(&self) -> SyntaxKind {\n+        self.kind\n     }\n-}\n \n-impl TextLen for GreenBranch {\n-    fn text_len(&self) -> TextUnit {\n+    pub fn text_len(&self) -> TextUnit {\n         self.text_len\n     }\n-}\n \n-impl<T: TextLen> TextLen for [T] {\n-    fn text_len(&self) -> TextUnit {\n-        self.iter().map(TextLen::text_len).sum()\n+    pub fn children(&self) -> &[GreenNode] {\n+        self.children.as_slice()\n     }\n }\n+"}, {"sha": "9a6203cc1874263886df2c35980bb3521e3e62b9", "filename": "src/yellow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967/src%2Fyellow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967/src%2Fyellow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fmod.rs?ref=13c6a5c4b02d6436e4197c3ca93a8a5c3112a967", "patch": "@@ -8,7 +8,7 @@ use std::{\n     mem\n };\n pub(crate) use self::{\n-    green::{GreenNode, TextLen},\n+    green::{GreenNode, GreenNodeBuilder},\n     red::RedNode,\n     syntax::SyntaxError,\n     builder::GreenBuilder,"}, {"sha": "e2dbceeaea58d8b528bbcc93c5f8ea41921bab3c", "filename": "src/yellow/red.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967/src%2Fyellow%2Fred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967/src%2Fyellow%2Fred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fred.rs?ref=13c6a5c4b02d6436e4197c3ca93a8a5c3112a967", "patch": "@@ -1,12 +1,12 @@\n use std::sync::{Arc, RwLock};\n use {\n     TextUnit,\n-    yellow::{Ptr, GreenNode, TextLen}\n+    yellow::{Ptr, GreenNode},\n };\n \n #[derive(Debug)]\n pub(crate) struct RedNode {\n-    green: Arc<GreenNode>,\n+    green: GreenNode,\n     parent: Option<ParentData>,\n     children: RwLock<Vec<Option<Arc<RedNode>>>>,\n }\n@@ -20,30 +20,30 @@ struct ParentData {\n \n impl RedNode {\n     pub fn new_root(\n-        green: Arc<GreenNode>,\n+        green: GreenNode,\n     ) -> RedNode {\n         RedNode::new(green, None)\n     }\n \n     fn new_child(\n-        green: Arc<GreenNode>,\n+        green: GreenNode,\n         parent: Ptr<RedNode>,\n         start_offset: TextUnit,\n-        index_in_parent: usize\n+        index_in_parent: usize,\n     ) -> RedNode {\n         let parent_data = ParentData {\n             parent,\n             start_offset,\n-            index_in_parent\n+            index_in_parent,\n         };\n         RedNode::new(green, Some(parent_data))\n     }\n \n     fn new(\n-        green: Arc<GreenNode>,\n+        green: GreenNode,\n         parent: Option<ParentData>,\n     ) -> RedNode {\n-        let children = vec![None; green.n_children()];\n+        let children = vec![None; green.children().len()];\n         RedNode { green, parent, children: RwLock::new(children) }\n     }\n \n@@ -59,29 +59,22 @@ impl RedNode {\n     }\n \n     pub(crate) fn n_children(&self) -> usize {\n-        self.green.n_children()\n+        self.green.children().len()\n     }\n \n-    pub(crate) fn nth_child(&self, me: Ptr<RedNode>, n: usize) -> Arc<RedNode> {\n-        match &self.children.read().unwrap()[n] {\n+    pub(crate) fn nth_child(&self, me: Ptr<RedNode>, idx: usize) -> Arc<RedNode> {\n+        match &self.children.read().unwrap()[idx] {\n             Some(child) => return child.clone(),\n             None => (),\n         }\n         let mut children = self.children.write().unwrap();\n-        if children[n].is_none() {\n-            let start_offset = {\n-                let mut acc = self.start_offset();\n-                for i in 0..n {\n-                    acc += self.green.nth_trivias(i).text_len();\n-                    acc += self.green.nth_child(i).text_len();\n-                }\n-                acc += self.green.nth_trivias(n).text_len();\n-                acc\n-            };\n-            let green = self.green.nth_child(n).clone();\n-            let child = RedNode::new_child(green, me, start_offset, n);\n-            children[n] = Some(Arc::new(child))\n+        if children[idx].is_none() {\n+            let green_children = self.green.children();\n+            let start_offset = self.start_offset()\n+                + green_children[..idx].iter().map(|x| x.text_len()).sum::<TextUnit>();\n+            let child = RedNode::new_child(green_children[idx].clone(), me, start_offset, idx);\n+            children[idx] = Some(Arc::new(child))\n         }\n-        children[n].as_ref().unwrap().clone()\n+        children[idx].as_ref().unwrap().clone()\n     }\n }"}, {"sha": "53d8c82b99521375cc51940628dfd905578eb136", "filename": "src/yellow/syntax.rs", "status": "modified", "additions": 10, "deletions": 53, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967/src%2Fyellow%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13c6a5c4b02d6436e4197c3ca93a8a5c3112a967/src%2Fyellow%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fsyntax.rs?ref=13c6a5c4b02d6436e4197c3ca93a8a5c3112a967", "patch": "@@ -6,14 +6,13 @@ use std::{\n use {\n     TextRange, TextUnit,\n     SyntaxKind::{self, *},\n-    yellow::{Ptr, RedNode, GreenNode, TextLen},\n+    yellow::{Ptr, RedNode, GreenNode},\n };\n \n #[derive(Clone)]\n pub struct SyntaxNode {\n     pub(crate) root: SyntaxRoot,\n     red: Ptr<RedNode>,\n-    trivia_pos: Option<(usize, usize)>,\n }\n \n #[derive(Clone)]\n@@ -29,80 +28,38 @@ pub(crate) struct SyntaxError {\n }\n \n impl SyntaxNode {\n-    pub(crate) fn new(root: Arc<GreenNode>, errors: Vec<SyntaxError>) -> SyntaxNode {\n+    pub(crate) fn new(root: GreenNode, errors: Vec<SyntaxError>) -> SyntaxNode {\n         let root = Arc::new(RedNode::new_root(root));\n         let red = Ptr::new(&root);\n         let root = SyntaxRoot { red: root, errors: Arc::new(errors) };\n-        SyntaxNode { root, red, trivia_pos: None }\n+        SyntaxNode { root, red }\n     }\n \n     pub fn kind(&self) -> SyntaxKind {\n-        let green = self.red().green();\n-        match self.trivia_pos {\n-            None => green.kind(),\n-            Some((i, j)) => green.nth_trivias(i)[j].kind\n-        }\n+        self.red().green().kind()\n     }\n \n     pub fn range(&self) -> TextRange {\n         let red = self.red();\n-        let green = red.green();\n-        match self.trivia_pos {\n-            None => TextRange::offset_len(red.start_offset(), red.green().text_len()),\n-            Some((i, j)) => {\n-                let trivias = green.nth_trivias(i);\n-                let offset = if i == 0 {\n-                    red.start_offset()\n-                } else {\n-                    let prev_child = red.nth_child(Ptr::clone(&self.red), i - 1);\n-                    let mut offset = prev_child.start_offset() + prev_child.green().text_len();\n-                    for k in 0..j {\n-                        offset += &trivias[k].text_len();\n-                    }\n-                    offset\n-                };\n-                TextRange::offset_len(offset, trivias[j].text_len())\n-            }\n-        }\n+        TextRange::offset_len(\n+            red.start_offset(),\n+            red.green().text_len(),\n+        )\n     }\n \n     pub fn text(&self) -> String {\n-        let green = self.red().green();\n-        match self.trivia_pos {\n-            None => green.text(),\n-            Some((i, j)) => green.nth_trivias(i)[j].text.clone()\n-        }\n+        self.red().green().text()\n     }\n \n     pub fn children(&self) -> Vec<SyntaxNode> {\n-        let mut res = Vec::new();\n         let red = self.red();\n-        let green = red.green();\n-        if green.is_leaf() || self.trivia_pos.is_some() {\n-            return Vec::new();\n-        }\n-        for (j, _) in green.nth_trivias(0).iter().enumerate() {\n-            res.push(SyntaxNode {\n-                root: self.root.clone(),\n-                red: Ptr::clone(&self.red),\n-                trivia_pos: Some((0, j)),\n-            })\n-        }\n-\n         let n_children = red.n_children();\n+        let mut res = Vec::with_capacity(n_children);\n         for i in 0..n_children {\n             res.push(SyntaxNode {\n                 root: self.root.clone(),\n                 red: Ptr::new(&red.nth_child(Ptr::clone(&self.red), i)),\n-                trivia_pos: None,\n             });\n-            for (j, _) in green.nth_trivias(i + 1).iter().enumerate() {\n-                res.push(SyntaxNode {\n-                    root: self.root.clone(),\n-                    red: self.red.clone(),\n-                    trivia_pos: Some((i + 1, j)),\n-                })\n-            }\n         }\n         res\n     }"}]}