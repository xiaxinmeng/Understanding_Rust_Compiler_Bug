{"sha": "0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYjg3ZWQ1NWZhNzZlMTE3NzcyNTRjNzdmZjdmMTFjNzRhYTJiZmE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-23T16:57:24Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:18:45Z"}, "message": "Rename projection_predicates to item_bounds", "tree": {"sha": "46ee3d77fd33282b8891bd6329157551b8b7ef69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46ee3d77fd33282b8891bd6329157551b8b7ef69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "html_url": "https://github.com/rust-lang/rust/commit/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ded394553296d56bb66e925d7001ab3271979ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ded394553296d56bb66e925d7001ab3271979ce", "html_url": "https://github.com/rust-lang/rust/commit/5ded394553296d56bb66e925d7001ab3271979ce"}], "stats": {"total": 53, "additions": 21, "deletions": 32}, "files": [{"sha": "2b827f4f4eddc43411296d763d75c4cd3995b1cc", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "patch": "@@ -328,8 +328,8 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         assoc_item_def_id: DefId,\n     ) -> impl Iterator<Item = ty::Region<'tcx>> {\n         let tcx = self.tcx;\n-        let predicates = tcx.projection_predicates(assoc_item_def_id);\n-        predicates\n+        let bounds = tcx.item_bounds(assoc_item_def_id);\n+        bounds\n             .into_iter()\n             .filter_map(|p| p.to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())"}, {"sha": "fadc7621785afb52944086465d8f1398523fe3d0", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "patch": "@@ -156,7 +156,7 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n-        /// Returns the list of predicates that can be used for\n+        /// Returns the list of bounds that can be used for\n         /// `SelectionCandidate::ProjectionCandidate` and\n         /// `ProjectionTyCandidate::TraitDef`.\n         /// Specifically this is the bounds (equivalent to) those\n@@ -169,7 +169,7 @@ rustc_queries! {\n         ///      ^^^^^^^^^^^^^^^\n         ///\n         /// `key` is the `DefId` of the associated type or opaque type.\n-        query projection_predicates(key: DefId) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n+        query item_bounds(key: DefId) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n             desc { |tcx| \"finding projection predicates for `{}`\", tcx.def_path_str(key) }\n         }\n "}, {"sha": "71e34d2dcd05f37ffb6349e676340a9450d98551", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "patch": "@@ -909,10 +909,8 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     // Check whether the self-type is itself a projection.\n     // If so, extract what we know from the trait and try to come up with a good answer.\n     let bounds = match *obligation_trait_ref.self_ty().kind() {\n-        ty::Projection(ref data) => {\n-            tcx.projection_predicates(data.item_def_id).subst(tcx, data.substs)\n-        }\n-        ty::Opaque(def_id, substs) => tcx.projection_predicates(def_id).subst(tcx, substs),\n+        ty::Projection(ref data) => tcx.item_bounds(data.item_def_id).subst(tcx, data.substs),\n+        ty::Opaque(def_id, substs) => tcx.item_bounds(def_id).subst(tcx, substs),\n         ty::Infer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity."}, {"sha": "9bebf8d90c21e903e7a8c82a96daf16a08cc4669", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "patch": "@@ -1171,10 +1171,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let tcx = self.infcx.tcx;\n         let predicates = match *placeholder_trait_predicate.trait_ref.self_ty().kind() {\n-            ty::Projection(ref data) => {\n-                tcx.projection_predicates(data.item_def_id).subst(tcx, data.substs)\n-            }\n-            ty::Opaque(def_id, substs) => tcx.projection_predicates(def_id).subst(tcx, substs),\n+            ty::Projection(ref data) => tcx.item_bounds(data.item_def_id).subst(tcx, data.substs),\n+            ty::Opaque(def_id, substs) => tcx.item_bounds(def_id).subst(tcx, substs),\n             _ => {\n                 span_bug!(\n                     obligation.cause.span,"}, {"sha": "2be466bf773480e72a8ff90d397cbb28344d95a2", "filename": "compiler/rustc_ty/src/ty.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Fty.rs?ref=0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "patch": "@@ -500,7 +500,7 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n /// simplify checking that these bounds are met in impls. This means that\n /// a bound such as `for<'b> <Self as X<'b>>::U: Clone` can't be used, as in\n /// `hr-associated-type-bound-1.rs`.\n-fn associated_type_projection_predicates(\n+fn associated_type_bounds(\n     tcx: TyCtxt<'_>,\n     assoc_item_def_id: DefId,\n ) -> &'_ ty::List<ty::Predicate<'_>> {\n@@ -545,21 +545,14 @@ fn associated_type_projection_predicates(\n     });\n \n     let result = tcx.mk_predicates(predicates);\n-    debug!(\n-        \"associated_type_projection_predicates({}) = {:?}\",\n-        tcx.def_path_str(assoc_item_def_id),\n-        result\n-    );\n+    debug!(\"associated_type_bounds({}) = {:?}\", tcx.def_path_str(assoc_item_def_id), result);\n     result\n }\n \n /// Opaque types don't have the same issues as associated types: the only\n /// predicates on an opaque type (excluding those it inherits from its parent\n /// item) should be of the form we're expecting.\n-fn opaque_type_projection_predicates(\n-    tcx: TyCtxt<'_>,\n-    def_id: DefId,\n-) -> &'_ ty::List<ty::Predicate<'_>> {\n+fn opaque_type_bounds(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n \n     let bounds = tcx.predicates_of(def_id);\n@@ -607,15 +600,15 @@ fn opaque_type_projection_predicates(\n     });\n \n     let result = tcx.mk_predicates(filtered_predicates);\n-    debug!(\"opaque_type_projection_predicates({}) = {:?}\", tcx.def_path_str(def_id), result);\n+    debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(def_id), result);\n     result\n }\n \n-fn projection_predicates(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n+fn item_bounds(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n     match tcx.def_kind(def_id) {\n-        DefKind::AssocTy => associated_type_projection_predicates(tcx, def_id),\n-        DefKind::OpaqueTy => opaque_type_projection_predicates(tcx, def_id),\n-        k => bug!(\"projection_predicates called on {}\", k.descr(def_id)),\n+        DefKind::AssocTy => associated_type_bounds(tcx, def_id),\n+        DefKind::OpaqueTy => opaque_type_bounds(tcx, def_id),\n+        k => bug!(\"item_bounds called on {}\", k.descr(def_id)),\n     }\n }\n \n@@ -636,7 +629,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         instance_def_size_estimate,\n         issue33140_self_ty,\n         impl_defaultness,\n-        projection_predicates,\n+        item_bounds,\n         ..*providers\n     };\n }"}, {"sha": "8111a0bad9fbf2cf98259edf4dba45f53040c663", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb87ed55fa76e11777254c77ff7f11c74aa2bfa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=0eb87ed55fa76e11777254c77ff7f11c74aa2bfa", "patch": "@@ -1052,7 +1052,7 @@ crate fn compare_ty_impl<'tcx>(\n \n         compare_type_predicate_entailment(tcx, impl_ty, impl_ty_span, trait_ty, impl_trait_ref)?;\n \n-        compare_projection_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)\n+        check_type_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)\n     })();\n }\n \n@@ -1170,7 +1170,7 @@ fn compare_type_predicate_entailment<'tcx>(\n /// For default associated types the normalization is not possible (the value\n /// from the impl could be overridden). We also can't normalize generic\n /// associated types (yet) because they contain bound parameters.\n-fn compare_projection_bounds<'tcx>(\n+fn check_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ty: &ty::AssocItem,\n     impl_ty: &ty::AssocItem,\n@@ -1237,8 +1237,8 @@ fn compare_projection_bounds<'tcx>(\n             ObligationCauseCode::ItemObligation(trait_ty.def_id),\n         );\n \n-        let predicates = tcx.projection_predicates(trait_ty.def_id);\n-        debug!(\"compare_projection_bounds: projection_predicates={:?}\", predicates);\n+        let predicates = tcx.item_bounds(trait_ty.def_id);\n+        debug!(\"check_type_bounds: item_bounds={:?}\", predicates);\n \n         for predicate in predicates {\n             let concrete_ty_predicate = predicate.subst(tcx, rebased_substs);"}]}