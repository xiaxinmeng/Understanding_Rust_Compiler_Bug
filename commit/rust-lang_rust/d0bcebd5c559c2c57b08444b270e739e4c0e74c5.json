{"sha": "d0bcebd5c559c2c57b08444b270e739e4c0e74c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYmNlYmQ1YzU1OWMyYzU3YjA4NDQ0YjI3MGU3MzllNGMwZTc0YzU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-11T18:13:11Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-18T10:42:44Z"}, "message": "resolve: Move some diagnostic code into `diagnostics.rs`", "tree": {"sha": "d6fab82cba1a41e7c4fd62ced1a5ab6d4b6a3b67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6fab82cba1a41e7c4fd62ced1a5ab6d4b6a3b67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0bcebd5c559c2c57b08444b270e739e4c0e74c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0bcebd5c559c2c57b08444b270e739e4c0e74c5", "html_url": "https://github.com/rust-lang/rust/commit/d0bcebd5c559c2c57b08444b270e739e4c0e74c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0bcebd5c559c2c57b08444b270e739e4c0e74c5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c3b05d90d4dee879a0d9f33e721c930b087d7d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c3b05d90d4dee879a0d9f33e721c930b087d7d1", "html_url": "https://github.com/rust-lang/rust/commit/2c3b05d90d4dee879a0d9f33e721c930b087d7d1"}], "stats": {"total": 1195, "additions": 600, "deletions": 595}, "files": [{"sha": "ef7248efda8a844df838dcb6f0a7e38698611c67", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 593, "deletions": 7, "changes": 600, "blob_url": "https://github.com/rust-lang/rust/blob/d0bcebd5c559c2c57b08444b270e739e4c0e74c5/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0bcebd5c559c2c57b08444b270e739e4c0e74c5/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=d0bcebd5c559c2c57b08444b270e739e4c0e74c5", "patch": "@@ -2,21 +2,53 @@ use std::cmp::Reverse;\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n-use rustc::hir::def::{self, DefKind, CtorKind, Namespace::*};\n+use rustc::hir::def::{self, DefKind, CtorKind};\n+use rustc::hir::def::Namespace::{self, *};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::PrimTy;\n use rustc::session::{Session, config::nightly_options};\n-use syntax::ast::{self, Expr, ExprKind, Ident};\n+use rustc::ty::{self, DefIdTree};\n+use rustc::util::nodemap::FxHashSet;\n+use syntax::ast::{self, Expr, ExprKind, Ident, NodeId, Path, Ty, TyKind};\n use syntax::ext::base::MacroKind;\n+use syntax::feature_gate::{feature_err, AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES};\n use syntax::symbol::{Symbol, kw};\n+use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{BytePos, Span};\n \n-type Res = def::Res<ast::NodeId>;\n-\n use crate::macros::ParentScope;\n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n-use crate::{import_candidate_to_enum_paths, is_self_type, is_self_value, path_names_to_string};\n-use crate::{AssocSuggestion, CrateLint, ImportSuggestion, ModuleOrUniformRoot, PathResult,\n-            PathSource, Resolver, Segment, Suggestion};\n+use crate::{is_self_type, is_self_value, path_names_to_string};\n+use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{PathResult, PathSource, Resolver, RibKind, Segment};\n+\n+type Res = def::Res<ast::NodeId>;\n+\n+/// A vector of spans and replacements, a message and applicability.\n+crate type Suggestion = (Vec<(Span, String)>, String, Applicability);\n+\n+/// A field or associated item from self type suggested in case of resolution failure.\n+enum AssocSuggestion {\n+    Field,\n+    MethodWithSelf,\n+    AssocItem,\n+}\n+\n+struct TypoSuggestion {\n+    candidate: Symbol,\n+\n+    /// The kind of the binding (\"crate\", \"module\", etc.)\n+    kind: &'static str,\n+\n+    /// An appropriate article to refer to the binding (\"a\", \"an\", etc.)\n+    article: &'static str,\n+}\n+\n+/// A free importable items suggested in case of resolution failure.\n+crate struct ImportSuggestion {\n+    did: Option<DefId>,\n+    pub path: Path,\n+}\n \n impl<'a> Resolver<'a> {\n     /// Handles error reporting for `smart_resolve_path_fragment` function.\n@@ -439,6 +471,493 @@ impl<'a> Resolver<'a> {\n         }\n         true\n     }\n+\n+    fn lookup_assoc_candidate<FilterFn>(&mut self,\n+                                        ident: Ident,\n+                                        ns: Namespace,\n+                                        filter_fn: FilterFn)\n+                                        -> Option<AssocSuggestion>\n+        where FilterFn: Fn(Res) -> bool\n+    {\n+        fn extract_node_id(t: &Ty) -> Option<NodeId> {\n+            match t.node {\n+                TyKind::Path(None, _) => Some(t.id),\n+                TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n+                // This doesn't handle the remaining `Ty` variants as they are not\n+                // that commonly the self_type, it might be interesting to provide\n+                // support for those in future.\n+                _ => None,\n+            }\n+        }\n+\n+        // Fields are generally expected in the same contexts as locals.\n+        if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n+            if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n+                // Look for a field with the same name in the current self_type.\n+                if let Some(resolution) = self.partial_res_map.get(&node_id) {\n+                    match resolution.base_res() {\n+                        Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n+                                if resolution.unresolved_segments() == 0 => {\n+                            if let Some(field_names) = self.field_names.get(&did) {\n+                                if field_names.iter().any(|&field_name| ident.name == field_name) {\n+                                    return Some(AssocSuggestion::Field);\n+                                }\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }\n+\n+        for assoc_type_ident in &self.current_trait_assoc_types {\n+            if *assoc_type_ident == ident {\n+                return Some(AssocSuggestion::AssocItem);\n+            }\n+        }\n+\n+        // Look for associated items in the current trait.\n+        if let Some((module, _)) = self.current_trait_ref {\n+            if let Ok(binding) = self.resolve_ident_in_module(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    ns,\n+                    None,\n+                    false,\n+                    module.span,\n+                ) {\n+                let res = binding.res();\n+                if filter_fn(res) {\n+                    return Some(if self.has_self.contains(&res.def_id()) {\n+                        AssocSuggestion::MethodWithSelf\n+                    } else {\n+                        AssocSuggestion::AssocItem\n+                    });\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn lookup_typo_candidate<FilterFn>(\n+        &mut self,\n+        path: &[Segment],\n+        ns: Namespace,\n+        filter_fn: FilterFn,\n+        span: Span,\n+    ) -> Option<TypoSuggestion>\n+    where\n+        FilterFn: Fn(Res) -> bool,\n+    {\n+        let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n+            for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n+                if let Some(binding) = resolution.borrow().binding {\n+                    if filter_fn(binding.res()) {\n+                        names.push(TypoSuggestion {\n+                            candidate: ident.name,\n+                            article: binding.res().article(),\n+                            kind: binding.res().descr(),\n+                        });\n+                    }\n+                }\n+            }\n+        };\n+\n+        let mut names = Vec::new();\n+        if path.len() == 1 {\n+            // Search in lexical scope.\n+            // Walk backwards up the ribs in scope and collect candidates.\n+            for rib in self.ribs[ns].iter().rev() {\n+                // Locals and type parameters\n+                for (ident, &res) in &rib.bindings {\n+                    if filter_fn(res) {\n+                        names.push(TypoSuggestion {\n+                            candidate: ident.name,\n+                            article: res.article(),\n+                            kind: res.descr(),\n+                        });\n+                    }\n+                }\n+                // Items in scope\n+                if let RibKind::ModuleRibKind(module) = rib.kind {\n+                    // Items from this module\n+                    add_module_candidates(module, &mut names);\n+\n+                    if let ModuleKind::Block(..) = module.kind {\n+                        // We can see through blocks\n+                    } else {\n+                        // Items from the prelude\n+                        if !module.no_implicit_prelude {\n+                            names.extend(self.extern_prelude.clone().iter().flat_map(|(ident, _)| {\n+                                self.crate_loader\n+                                    .maybe_process_path_extern(ident.name, ident.span)\n+                                    .and_then(|crate_id| {\n+                                        let crate_mod = Res::Def(\n+                                            DefKind::Mod,\n+                                            DefId {\n+                                                krate: crate_id,\n+                                                index: CRATE_DEF_INDEX,\n+                                            },\n+                                        );\n+\n+                                        if filter_fn(crate_mod) {\n+                                            Some(TypoSuggestion {\n+                                                candidate: ident.name,\n+                                                article: \"a\",\n+                                                kind: \"crate\",\n+                                            })\n+                                        } else {\n+                                            None\n+                                        }\n+                                    })\n+                            }));\n+\n+                            if let Some(prelude) = self.prelude {\n+                                add_module_candidates(prelude, &mut names);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            // Add primitive types to the mix\n+            if filter_fn(Res::PrimTy(PrimTy::Bool)) {\n+                names.extend(\n+                    self.primitive_type_table.primitive_types.iter().map(|(name, _)| {\n+                        TypoSuggestion {\n+                            candidate: *name,\n+                            article: \"a\",\n+                            kind: \"primitive type\",\n+                        }\n+                    })\n+                )\n+            }\n+        } else {\n+            // Search in module.\n+            let mod_path = &path[..path.len() - 1];\n+            if let PathResult::Module(module) = self.resolve_path_without_parent_scope(\n+                mod_path, Some(TypeNS), false, span, CrateLint::No\n+            ) {\n+                if let ModuleOrUniformRoot::Module(module) = module {\n+                    add_module_candidates(module, &mut names);\n+                }\n+            }\n+        }\n+\n+        let name = path[path.len() - 1].ident.name;\n+        // Make sure error reporting is deterministic.\n+        names.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n+\n+        match find_best_match_for_name(\n+            names.iter().map(|suggestion| &suggestion.candidate),\n+            &name.as_str(),\n+            None,\n+        ) {\n+            Some(found) if found != name => names\n+                .into_iter()\n+                .find(|suggestion| suggestion.candidate == found),\n+            _ => None,\n+        }\n+    }\n+\n+    fn lookup_import_candidates_from_module<FilterFn>(&mut self,\n+                                          lookup_ident: Ident,\n+                                          namespace: Namespace,\n+                                          start_module: Module<'a>,\n+                                          crate_name: Ident,\n+                                          filter_fn: FilterFn)\n+                                          -> Vec<ImportSuggestion>\n+        where FilterFn: Fn(Res) -> bool\n+    {\n+        let mut candidates = Vec::new();\n+        let mut seen_modules = FxHashSet::default();\n+        let not_local_module = crate_name.name != kw::Crate;\n+        let mut worklist = vec![(start_module, Vec::<ast::PathSegment>::new(), not_local_module)];\n+\n+        while let Some((in_module,\n+                        path_segments,\n+                        in_module_is_extern)) = worklist.pop() {\n+            self.populate_module_if_necessary(in_module);\n+\n+            // We have to visit module children in deterministic order to avoid\n+            // instabilities in reported imports (#43552).\n+            in_module.for_each_child_stable(|ident, ns, name_binding| {\n+                // avoid imports entirely\n+                if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n+                // avoid non-importable candidates as well\n+                if !name_binding.is_importable() { return; }\n+\n+                // collect results based on the filter function\n+                if ident.name == lookup_ident.name && ns == namespace {\n+                    let res = name_binding.res();\n+                    if filter_fn(res) {\n+                        // create the path\n+                        let mut segms = path_segments.clone();\n+                        if lookup_ident.span.rust_2018() {\n+                            // crate-local absolute paths start with `crate::` in edition 2018\n+                            // FIXME: may also be stabilized for Rust 2015 (Issues #45477, #44660)\n+                            segms.insert(\n+                                0, ast::PathSegment::from_ident(crate_name)\n+                            );\n+                        }\n+\n+                        segms.push(ast::PathSegment::from_ident(ident));\n+                        let path = Path {\n+                            span: name_binding.span,\n+                            segments: segms,\n+                        };\n+                        // the entity is accessible in the following cases:\n+                        // 1. if it's defined in the same crate, it's always\n+                        // accessible (since private entities can be made public)\n+                        // 2. if it's defined in another crate, it's accessible\n+                        // only if both the module is public and the entity is\n+                        // declared as public (due to pruning, we don't explore\n+                        // outside crate private modules => no need to check this)\n+                        if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n+                            let did = match res {\n+                                Res::Def(DefKind::Ctor(..), did) => self.parent(did),\n+                                _ => res.opt_def_id(),\n+                            };\n+                            candidates.push(ImportSuggestion { did, path });\n+                        }\n+                    }\n+                }\n+\n+                // collect submodules to explore\n+                if let Some(module) = name_binding.module() {\n+                    // form the path\n+                    let mut path_segments = path_segments.clone();\n+                    path_segments.push(ast::PathSegment::from_ident(ident));\n+\n+                    let is_extern_crate_that_also_appears_in_prelude =\n+                        name_binding.is_extern_crate() &&\n+                        lookup_ident.span.rust_2018();\n+\n+                    let is_visible_to_user =\n+                        !in_module_is_extern || name_binding.vis == ty::Visibility::Public;\n+\n+                    if !is_extern_crate_that_also_appears_in_prelude && is_visible_to_user {\n+                        // add the module to the lookup\n+                        let is_extern = in_module_is_extern || name_binding.is_extern_crate();\n+                        if seen_modules.insert(module.def_id().unwrap()) {\n+                            worklist.push((module, path_segments, is_extern));\n+                        }\n+                    }\n+                }\n+            })\n+        }\n+\n+        candidates\n+    }\n+\n+    /// When name resolution fails, this method can be used to look up candidate\n+    /// entities with the expected name. It allows filtering them using the\n+    /// supplied predicate (which should be used to only accept the types of\n+    /// definitions expected, e.g., traits). The lookup spans across all crates.\n+    ///\n+    /// N.B., the method does not look into imports, but this is not a problem,\n+    /// since we report the definitions (thus, the de-aliased imports).\n+    crate fn lookup_import_candidates<FilterFn>(\n+        &mut self, lookup_ident: Ident, namespace: Namespace, filter_fn: FilterFn\n+    ) -> Vec<ImportSuggestion>\n+        where FilterFn: Fn(Res) -> bool\n+    {\n+        let mut suggestions = self.lookup_import_candidates_from_module(\n+            lookup_ident, namespace, self.graph_root, Ident::with_empty_ctxt(kw::Crate), &filter_fn\n+        );\n+\n+        if lookup_ident.span.rust_2018() {\n+            let extern_prelude_names = self.extern_prelude.clone();\n+            for (ident, _) in extern_prelude_names.into_iter() {\n+                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name,\n+                                                                                    ident.span) {\n+                    let crate_root = self.get_module(DefId {\n+                        krate: crate_id,\n+                        index: CRATE_DEF_INDEX,\n+                    });\n+                    self.populate_module_if_necessary(&crate_root);\n+\n+                    suggestions.extend(self.lookup_import_candidates_from_module(\n+                        lookup_ident, namespace, crate_root, ident, &filter_fn));\n+                }\n+            }\n+        }\n+\n+        suggestions\n+    }\n+\n+    fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n+        let mut result = None;\n+        let mut seen_modules = FxHashSet::default();\n+        let mut worklist = vec![(self.graph_root, Vec::new())];\n+\n+        while let Some((in_module, path_segments)) = worklist.pop() {\n+            // abort if the module is already found\n+            if result.is_some() { break; }\n+\n+            self.populate_module_if_necessary(in_module);\n+\n+            in_module.for_each_child_stable(|ident, _, name_binding| {\n+                // abort if the module is already found or if name_binding is private external\n+                if result.is_some() || !name_binding.vis.is_visible_locally() {\n+                    return\n+                }\n+                if let Some(module) = name_binding.module() {\n+                    // form the path\n+                    let mut path_segments = path_segments.clone();\n+                    path_segments.push(ast::PathSegment::from_ident(ident));\n+                    let module_def_id = module.def_id().unwrap();\n+                    if module_def_id == def_id {\n+                        let path = Path {\n+                            span: name_binding.span,\n+                            segments: path_segments,\n+                        };\n+                        result = Some((module, ImportSuggestion { did: Some(def_id), path }));\n+                    } else {\n+                        // add the module to the lookup\n+                        if seen_modules.insert(module_def_id) {\n+                            worklist.push((module, path_segments));\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+\n+        result\n+    }\n+\n+    fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n+        self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n+            self.populate_module_if_necessary(enum_module);\n+\n+            let mut variants = Vec::new();\n+            enum_module.for_each_child_stable(|ident, _, name_binding| {\n+                if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n+                    let mut segms = enum_import_suggestion.path.segments.clone();\n+                    segms.push(ast::PathSegment::from_ident(ident));\n+                    variants.push(Path {\n+                        span: name_binding.span,\n+                        segments: segms,\n+                    });\n+                }\n+            });\n+            variants\n+        })\n+    }\n+\n+    crate fn suggest_macro_name(\n+        &mut self, name: Symbol, kind: MacroKind, err: &mut DiagnosticBuilder<'a>, span: Span\n+    ) {\n+        if kind == MacroKind::Derive && (name.as_str() == \"Send\" || name.as_str() == \"Sync\") {\n+            let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", name);\n+            err.span_note(span, &msg);\n+            return;\n+        }\n+\n+        // First check if this is a locally-defined bang macro.\n+        let suggestion = if let MacroKind::Bang = kind {\n+            find_best_match_for_name(\n+                self.macro_names.iter().map(|ident| &ident.name), &name.as_str(), None)\n+        } else {\n+            None\n+        // Then check global macros.\n+        }.or_else(|| {\n+            let names = self.builtin_macros.iter().chain(self.macro_use_prelude.iter())\n+                                                  .filter_map(|(name, binding)| {\n+                if binding.macro_kind() == Some(kind) { Some(name) } else { None }\n+            });\n+            find_best_match_for_name(names, &name.as_str(), None)\n+        // Then check modules.\n+        }).or_else(|| {\n+            let is_macro = |res| {\n+                if let Res::Def(DefKind::Macro(def_kind), _) = res {\n+                    def_kind == kind\n+                } else {\n+                    false\n+                }\n+            };\n+            let ident = Ident::new(name, span);\n+            self.lookup_typo_candidate(&[Segment::from_ident(ident)], MacroNS, is_macro, span)\n+                .map(|suggestion| suggestion.candidate)\n+        });\n+\n+        if let Some(suggestion) = suggestion {\n+            if suggestion != name {\n+                if let MacroKind::Bang = kind {\n+                    err.span_suggestion(\n+                        span,\n+                        \"you could try the macro\",\n+                        suggestion.to_string(),\n+                        Applicability::MaybeIncorrect\n+                    );\n+                } else {\n+                    err.span_suggestion(\n+                        span,\n+                        \"try\",\n+                        suggestion.to_string(),\n+                        Applicability::MaybeIncorrect\n+                    );\n+                }\n+            } else {\n+                err.help(\"have you added the `#[macro_use]` on the module/import?\");\n+            }\n+        }\n+    }\n+\n+    crate fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: Symbol) {\n+        let mut err = feature_err(\n+            &self.session.parse_sess,\n+            feature,\n+            span,\n+            GateIssue::Language,\n+            &msg,\n+        );\n+\n+        let features = self.session.features_untracked();\n+\n+        let attr_candidates = BUILTIN_ATTRIBUTES\n+            .iter()\n+            .filter_map(|&(name, _, _, ref gate)| {\n+                if name.as_str().starts_with(\"rustc_\") && !features.rustc_attrs {\n+                    return None;\n+                }\n+\n+                match gate {\n+                    AttributeGate::Gated(Stability::Unstable, ..)\n+                        if self.session.opts.unstable_features.is_nightly_build() =>\n+                    {\n+                        Some(name)\n+                    }\n+                    AttributeGate::Gated(Stability::Deprecated(..), ..) => Some(name),\n+                    AttributeGate::Ungated => Some(name),\n+                    _ => None,\n+                }\n+            })\n+            .chain(\n+                // Add built-in macro attributes as well.\n+                self.builtin_macros.iter().filter_map(|(name, binding)| {\n+                    match binding.macro_kind() {\n+                        Some(MacroKind::Attr) => Some(*name),\n+                        _ => None,\n+                    }\n+                }),\n+            )\n+            .collect::<Vec<_>>();\n+\n+        let lev_suggestion = find_best_match_for_name(attr_candidates.iter(), &name, None);\n+\n+        if let Some(suggestion) = lev_suggestion {\n+            err.span_suggestion(\n+                span,\n+                \"a built-in attribute with a similar name exists\",\n+                suggestion.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+\n+        err.emit();\n+    }\n }\n \n impl<'a, 'b> ImportResolver<'a, 'b> {\n@@ -871,3 +1390,70 @@ fn find_span_immediately_after_crate_name(\n \n     (next_left_bracket == after_second_colon, from_second_colon)\n }\n+\n+/// Gets the stringified path for an enum from an `ImportSuggestion` for an enum variant.\n+fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, String) {\n+    let variant_path = &suggestion.path;\n+    let variant_path_string = path_names_to_string(variant_path);\n+\n+    let path_len = suggestion.path.segments.len();\n+    let enum_path = ast::Path {\n+        span: suggestion.path.span,\n+        segments: suggestion.path.segments[0..path_len - 1].to_vec(),\n+    };\n+    let enum_path_string = path_names_to_string(&enum_path);\n+\n+    (variant_path_string, enum_path_string)\n+}\n+\n+/// When an entity with a given name is not available in scope, we search for\n+/// entities with that name in all crates. This method allows outputting the\n+/// results of this search in a programmer-friendly way\n+crate fn show_candidates(\n+    err: &mut DiagnosticBuilder<'_>,\n+    // This is `None` if all placement locations are inside expansions\n+    span: Option<Span>,\n+    candidates: &[ImportSuggestion],\n+    better: bool,\n+    found_use: bool,\n+) {\n+    // we want consistent results across executions, but candidates are produced\n+    // by iterating through a hash map, so make sure they are ordered:\n+    let mut path_strings: Vec<_> =\n+        candidates.into_iter().map(|c| path_names_to_string(&c.path)).collect();\n+    path_strings.sort();\n+\n+    let better = if better { \"better \" } else { \"\" };\n+    let msg_diff = match path_strings.len() {\n+        1 => \" is found in another module, you can import it\",\n+        _ => \"s are found in other modules, you can import them\",\n+    };\n+    let msg = format!(\"possible {}candidate{} into scope\", better, msg_diff);\n+\n+    if let Some(span) = span {\n+        for candidate in &mut path_strings {\n+            // produce an additional newline to separate the new use statement\n+            // from the directly following item.\n+            let additional_newline = if found_use {\n+                \"\"\n+            } else {\n+                \"\\n\"\n+            };\n+            *candidate = format!(\"use {};\\n{}\", candidate, additional_newline);\n+        }\n+\n+        err.span_suggestions(\n+            span,\n+            &msg,\n+            path_strings.into_iter(),\n+            Applicability::Unspecified,\n+        );\n+    } else {\n+        let mut msg = msg;\n+        msg.push(':');\n+        for candidate in path_strings {\n+            msg.push('\\n');\n+            msg.push_str(&candidate);\n+        }\n+    }\n+}"}, {"sha": "edb1a4fdd432e7e0b315623b0394b035b2a7f3b3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 470, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/d0bcebd5c559c2c57b08444b270e739e4c0e74c5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0bcebd5c559c2c57b08444b270e739e4c0e74c5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d0bcebd5c559c2c57b08444b270e739e4c0e74c5", "patch": "@@ -31,7 +31,7 @@ use rustc::hir::def::{\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::hir::{TraitCandidate, TraitMap, GlobMap};\n-use rustc::ty::{self, DefIdTree};\n+use rustc::ty;\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::{bug, span_bug};\n \n@@ -69,6 +69,7 @@ use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::Lrc;\n use smallvec::SmallVec;\n \n+use diagnostics::{Suggestion, ImportSuggestion};\n use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{InvocationData, LegacyBinding, ParentScope};\n@@ -112,36 +113,13 @@ enum ScopeSet {\n     Module,\n }\n \n-/// A free importable items suggested in case of resolution failure.\n-struct ImportSuggestion {\n-    did: Option<DefId>,\n-    path: Path,\n-}\n-\n-/// A field or associated item from self type suggested in case of resolution failure.\n-enum AssocSuggestion {\n-    Field,\n-    MethodWithSelf,\n-    AssocItem,\n-}\n-\n #[derive(Eq)]\n struct BindingError {\n     name: Name,\n     origin: BTreeSet<Span>,\n     target: BTreeSet<Span>,\n }\n \n-struct TypoSuggestion {\n-    candidate: Symbol,\n-\n-    /// The kind of the binding (\"crate\", \"module\", etc.)\n-    kind: &'static str,\n-\n-    /// An appropriate article to refer to the binding (\"a\", \"an\", etc.)\n-    article: &'static str,\n-}\n-\n impl PartialOrd for BindingError {\n     fn partial_cmp(&self, other: &BindingError) -> Option<cmp::Ordering> {\n         Some(self.cmp(other))\n@@ -160,9 +138,6 @@ impl Ord for BindingError {\n     }\n }\n \n-/// A vector of spans and replacements, a message and applicability.\n-type Suggestion = (Vec<(Span, String)>, String, Applicability);\n-\n enum ResolutionError<'a> {\n     /// Error E0401: can't use type or const parameters from outer function.\n     GenericParamsFromOuterFunction(Res),\n@@ -4124,195 +4099,6 @@ impl<'a> Resolver<'a> {\n         res\n     }\n \n-    fn lookup_assoc_candidate<FilterFn: Fn(Res) -> bool>(\n-        &mut self,\n-        ident: Ident,\n-        ns: Namespace,\n-        filter_fn: FilterFn,\n-    ) -> Option<AssocSuggestion> {\n-        fn extract_node_id(t: &Ty) -> Option<NodeId> {\n-            match t.node {\n-                TyKind::Path(None, _) => Some(t.id),\n-                TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n-                // This doesn't handle the remaining `Ty` variants as they are not\n-                // that commonly the self_type, it might be interesting to provide\n-                // support for those in future.\n-                _ => None,\n-            }\n-        }\n-\n-        // Fields are generally expected in the same contexts as locals.\n-        if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n-            if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n-                // Look for a field with the same name in the current self_type.\n-                if let Some(resolution) = self.partial_res_map.get(&node_id) {\n-                    match resolution.base_res() {\n-                        Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n-                                if resolution.unresolved_segments() == 0 => {\n-                            if let Some(field_names) = self.field_names.get(&did) {\n-                                if field_names.iter().any(|&field_name| ident.name == field_name) {\n-                                    return Some(AssocSuggestion::Field);\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-        }\n-\n-        for assoc_type_ident in &self.current_trait_assoc_types {\n-            if *assoc_type_ident == ident {\n-                return Some(AssocSuggestion::AssocItem);\n-            }\n-        }\n-\n-        // Look for associated items in the current trait.\n-        if let Some((module, _)) = self.current_trait_ref {\n-            if let Ok(binding) = self.resolve_ident_in_module(\n-                    ModuleOrUniformRoot::Module(module),\n-                    ident,\n-                    ns,\n-                    None,\n-                    false,\n-                    module.span,\n-                ) {\n-                let res = binding.res();\n-                if filter_fn(res) {\n-                    debug!(\"extract_node_id res not filtered\");\n-                    return Some(if self.has_self.contains(&res.def_id()) {\n-                        AssocSuggestion::MethodWithSelf\n-                    } else {\n-                        AssocSuggestion::AssocItem\n-                    });\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn lookup_typo_candidate<FilterFn>(\n-        &mut self,\n-        path: &[Segment],\n-        ns: Namespace,\n-        filter_fn: FilterFn,\n-        span: Span,\n-    ) -> Option<TypoSuggestion>\n-    where\n-        FilterFn: Fn(Res) -> bool,\n-    {\n-        let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n-            for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n-                if let Some(binding) = resolution.borrow().binding {\n-                    if filter_fn(binding.res()) {\n-                        names.push(TypoSuggestion {\n-                            candidate: ident.name,\n-                            article: binding.res().article(),\n-                            kind: binding.res().descr(),\n-                        });\n-                    }\n-                }\n-            }\n-        };\n-\n-        let mut names = Vec::new();\n-        if path.len() == 1 {\n-            // Search in lexical scope.\n-            // Walk backwards up the ribs in scope and collect candidates.\n-            for rib in self.ribs[ns].iter().rev() {\n-                // Locals and type parameters\n-                for (ident, &res) in &rib.bindings {\n-                    if filter_fn(res) {\n-                        names.push(TypoSuggestion {\n-                            candidate: ident.name,\n-                            article: res.article(),\n-                            kind: res.descr(),\n-                        });\n-                    }\n-                }\n-                // Items in scope\n-                if let ModuleRibKind(module) = rib.kind {\n-                    // Items from this module\n-                    add_module_candidates(module, &mut names);\n-\n-                    if let ModuleKind::Block(..) = module.kind {\n-                        // We can see through blocks\n-                    } else {\n-                        // Items from the prelude\n-                        if !module.no_implicit_prelude {\n-                            names.extend(self.extern_prelude.clone().iter().flat_map(|(ident, _)| {\n-                                self.crate_loader\n-                                    .maybe_process_path_extern(ident.name, ident.span)\n-                                    .and_then(|crate_id| {\n-                                        let crate_mod = Res::Def(\n-                                            DefKind::Mod,\n-                                            DefId {\n-                                                krate: crate_id,\n-                                                index: CRATE_DEF_INDEX,\n-                                            },\n-                                        );\n-\n-                                        if filter_fn(crate_mod) {\n-                                            Some(TypoSuggestion {\n-                                                candidate: ident.name,\n-                                                article: \"a\",\n-                                                kind: \"crate\",\n-                                            })\n-                                        } else {\n-                                            None\n-                                        }\n-                                    })\n-                            }));\n-\n-                            if let Some(prelude) = self.prelude {\n-                                add_module_candidates(prelude, &mut names);\n-                            }\n-                        }\n-                        break;\n-                    }\n-                }\n-            }\n-            // Add primitive types to the mix\n-            if filter_fn(Res::PrimTy(Bool)) {\n-                names.extend(\n-                    self.primitive_type_table.primitive_types.iter().map(|(name, _)| {\n-                        TypoSuggestion {\n-                            candidate: *name,\n-                            article: \"a\",\n-                            kind: \"primitive type\",\n-                        }\n-                    })\n-                )\n-            }\n-        } else {\n-            // Search in module.\n-            let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path_without_parent_scope(\n-                mod_path, Some(TypeNS), false, span, CrateLint::No\n-            ) {\n-                if let ModuleOrUniformRoot::Module(module) = module {\n-                    add_module_candidates(module, &mut names);\n-                }\n-            }\n-        }\n-\n-        let name = path[path.len() - 1].ident.name;\n-        // Make sure error reporting is deterministic.\n-        names.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n-\n-        match find_best_match_for_name(\n-            names.iter().map(|suggestion| &suggestion.candidate),\n-            &name.as_str(),\n-            None,\n-        ) {\n-            Some(found) if found != name => names\n-                .into_iter()\n-                .find(|suggestion| suggestion.candidate == found),\n-            _ => None,\n-        }\n-    }\n-\n     fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n         where F: FnOnce(&mut Resolver<'_>)\n     {\n@@ -4606,193 +4392,6 @@ impl<'a> Resolver<'a> {\n         import_ids\n     }\n \n-    fn lookup_import_candidates_from_module<FilterFn>(&mut self,\n-                                          lookup_ident: Ident,\n-                                          namespace: Namespace,\n-                                          start_module: &'a ModuleData<'a>,\n-                                          crate_name: Ident,\n-                                          filter_fn: FilterFn)\n-                                          -> Vec<ImportSuggestion>\n-        where FilterFn: Fn(Res) -> bool\n-    {\n-        let mut candidates = Vec::new();\n-        let mut seen_modules = FxHashSet::default();\n-        let not_local_module = crate_name.name != kw::Crate;\n-        let mut worklist = vec![(start_module, Vec::<ast::PathSegment>::new(), not_local_module)];\n-\n-        while let Some((in_module,\n-                        path_segments,\n-                        in_module_is_extern)) = worklist.pop() {\n-            self.populate_module_if_necessary(in_module);\n-\n-            // We have to visit module children in deterministic order to avoid\n-            // instabilities in reported imports (#43552).\n-            in_module.for_each_child_stable(|ident, ns, name_binding| {\n-                // avoid imports entirely\n-                if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n-                // avoid non-importable candidates as well\n-                if !name_binding.is_importable() { return; }\n-\n-                // collect results based on the filter function\n-                if ident.name == lookup_ident.name && ns == namespace {\n-                    let res = name_binding.res();\n-                    if filter_fn(res) {\n-                        // create the path\n-                        let mut segms = path_segments.clone();\n-                        if lookup_ident.span.rust_2018() {\n-                            // crate-local absolute paths start with `crate::` in edition 2018\n-                            // FIXME: may also be stabilized for Rust 2015 (Issues #45477, #44660)\n-                            segms.insert(\n-                                0, ast::PathSegment::from_ident(crate_name)\n-                            );\n-                        }\n-\n-                        segms.push(ast::PathSegment::from_ident(ident));\n-                        let path = Path {\n-                            span: name_binding.span,\n-                            segments: segms,\n-                        };\n-                        // the entity is accessible in the following cases:\n-                        // 1. if it's defined in the same crate, it's always\n-                        // accessible (since private entities can be made public)\n-                        // 2. if it's defined in another crate, it's accessible\n-                        // only if both the module is public and the entity is\n-                        // declared as public (due to pruning, we don't explore\n-                        // outside crate private modules => no need to check this)\n-                        if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n-                            let did = match res {\n-                                Res::Def(DefKind::Ctor(..), did) => self.parent(did),\n-                                _ => res.opt_def_id(),\n-                            };\n-                            candidates.push(ImportSuggestion { did, path });\n-                        }\n-                    }\n-                }\n-\n-                // collect submodules to explore\n-                if let Some(module) = name_binding.module() {\n-                    // form the path\n-                    let mut path_segments = path_segments.clone();\n-                    path_segments.push(ast::PathSegment::from_ident(ident));\n-\n-                    let is_extern_crate_that_also_appears_in_prelude =\n-                        name_binding.is_extern_crate() &&\n-                        lookup_ident.span.rust_2018();\n-\n-                    let is_visible_to_user =\n-                        !in_module_is_extern || name_binding.vis == ty::Visibility::Public;\n-\n-                    if !is_extern_crate_that_also_appears_in_prelude && is_visible_to_user {\n-                        // add the module to the lookup\n-                        let is_extern = in_module_is_extern || name_binding.is_extern_crate();\n-                        if seen_modules.insert(module.def_id().unwrap()) {\n-                            worklist.push((module, path_segments, is_extern));\n-                        }\n-                    }\n-                }\n-            })\n-        }\n-\n-        candidates\n-    }\n-\n-    /// When name resolution fails, this method can be used to look up candidate\n-    /// entities with the expected name. It allows filtering them using the\n-    /// supplied predicate (which should be used to only accept the types of\n-    /// definitions expected, e.g., traits). The lookup spans across all crates.\n-    ///\n-    /// N.B., the method does not look into imports, but this is not a problem,\n-    /// since we report the definitions (thus, the de-aliased imports).\n-    fn lookup_import_candidates<FilterFn>(&mut self,\n-                                          lookup_ident: Ident,\n-                                          namespace: Namespace,\n-                                          filter_fn: FilterFn)\n-                                          -> Vec<ImportSuggestion>\n-        where FilterFn: Fn(Res) -> bool\n-    {\n-        let mut suggestions = self.lookup_import_candidates_from_module(\n-            lookup_ident, namespace, self.graph_root, Ident::with_empty_ctxt(kw::Crate), &filter_fn\n-        );\n-\n-        if lookup_ident.span.rust_2018() {\n-            let extern_prelude_names = self.extern_prelude.clone();\n-            for (ident, _) in extern_prelude_names.into_iter() {\n-                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name,\n-                                                                                    ident.span) {\n-                    let crate_root = self.get_module(DefId {\n-                        krate: crate_id,\n-                        index: CRATE_DEF_INDEX,\n-                    });\n-                    self.populate_module_if_necessary(&crate_root);\n-\n-                    suggestions.extend(self.lookup_import_candidates_from_module(\n-                        lookup_ident, namespace, crate_root, ident, &filter_fn));\n-                }\n-            }\n-        }\n-\n-        suggestions\n-    }\n-\n-    fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n-        let mut result = None;\n-        let mut seen_modules = FxHashSet::default();\n-        let mut worklist = vec![(self.graph_root, Vec::new())];\n-\n-        while let Some((in_module, path_segments)) = worklist.pop() {\n-            // abort if the module is already found\n-            if result.is_some() { break; }\n-\n-            self.populate_module_if_necessary(in_module);\n-\n-            in_module.for_each_child_stable(|ident, _, name_binding| {\n-                // abort if the module is already found or if name_binding is private external\n-                if result.is_some() || !name_binding.vis.is_visible_locally() {\n-                    return\n-                }\n-                if let Some(module) = name_binding.module() {\n-                    // form the path\n-                    let mut path_segments = path_segments.clone();\n-                    path_segments.push(ast::PathSegment::from_ident(ident));\n-                    let module_def_id = module.def_id().unwrap();\n-                    if module_def_id == def_id {\n-                        let path = Path {\n-                            span: name_binding.span,\n-                            segments: path_segments,\n-                        };\n-                        result = Some((module, ImportSuggestion { did: Some(def_id), path }));\n-                    } else {\n-                        // add the module to the lookup\n-                        if seen_modules.insert(module_def_id) {\n-                            worklist.push((module, path_segments));\n-                        }\n-                    }\n-                }\n-            });\n-        }\n-\n-        result\n-    }\n-\n-    fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n-        self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n-            self.populate_module_if_necessary(enum_module);\n-\n-            let mut variants = Vec::new();\n-            enum_module.for_each_child_stable(|ident, _, name_binding| {\n-                if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n-                    let mut segms = enum_import_suggestion.path.segments.clone();\n-                    segms.push(ast::PathSegment::from_ident(ident));\n-                    variants.push(Path {\n-                        span: name_binding.span,\n-                        segments: segms,\n-                    });\n-                }\n-            });\n-            variants\n-        })\n-    }\n-\n     fn record_partial_res(&mut self, node_id: NodeId, resolution: PartialRes) {\n         debug!(\"(recording res) recording {:?} for {}\", resolution, node_id);\n         if let Some(prev_res) = self.partial_res_map.insert(node_id, resolution) {\n@@ -5010,7 +4609,7 @@ impl<'a> Resolver<'a> {\n         for UseError { mut err, candidates, node_id, better } in self.use_injections.drain(..) {\n             let (span, found_use) = UsePlacementFinder::check(krate, node_id);\n             if !candidates.is_empty() {\n-                show_candidates(&mut err, span, &candidates, better, found_use);\n+                diagnostics::show_candidates(&mut err, span, &candidates, better, found_use);\n             }\n             err.emit();\n         }\n@@ -5326,72 +4925,6 @@ fn path_names_to_string(path: &Path) -> String {\n                         .collect::<Vec<_>>())\n }\n \n-/// Gets the stringified path for an enum from an `ImportSuggestion` for an enum variant.\n-fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, String) {\n-    let variant_path = &suggestion.path;\n-    let variant_path_string = path_names_to_string(variant_path);\n-\n-    let path_len = suggestion.path.segments.len();\n-    let enum_path = ast::Path {\n-        span: suggestion.path.span,\n-        segments: suggestion.path.segments[0..path_len - 1].to_vec(),\n-    };\n-    let enum_path_string = path_names_to_string(&enum_path);\n-\n-    (variant_path_string, enum_path_string)\n-}\n-\n-/// When an entity with a given name is not available in scope, we search for\n-/// entities with that name in all crates. This method allows outputting the\n-/// results of this search in a programmer-friendly way\n-fn show_candidates(err: &mut DiagnosticBuilder<'_>,\n-                   // This is `None` if all placement locations are inside expansions\n-                   span: Option<Span>,\n-                   candidates: &[ImportSuggestion],\n-                   better: bool,\n-                   found_use: bool) {\n-\n-    // we want consistent results across executions, but candidates are produced\n-    // by iterating through a hash map, so make sure they are ordered:\n-    let mut path_strings: Vec<_> =\n-        candidates.into_iter().map(|c| path_names_to_string(&c.path)).collect();\n-    path_strings.sort();\n-\n-    let better = if better { \"better \" } else { \"\" };\n-    let msg_diff = match path_strings.len() {\n-        1 => \" is found in another module, you can import it\",\n-        _ => \"s are found in other modules, you can import them\",\n-    };\n-    let msg = format!(\"possible {}candidate{} into scope\", better, msg_diff);\n-\n-    if let Some(span) = span {\n-        for candidate in &mut path_strings {\n-            // produce an additional newline to separate the new use statement\n-            // from the directly following item.\n-            let additional_newline = if found_use {\n-                \"\"\n-            } else {\n-                \"\\n\"\n-            };\n-            *candidate = format!(\"use {};\\n{}\", candidate, additional_newline);\n-        }\n-\n-        err.span_suggestions(\n-            span,\n-            &msg,\n-            path_strings.into_iter(),\n-            Applicability::Unspecified,\n-        );\n-    } else {\n-        let mut msg = msg;\n-        msg.push(':');\n-        for candidate in path_strings {\n-            msg.push('\\n');\n-            msg.push_str(&candidate);\n-        }\n-    }\n-}\n-\n /// A somewhat inefficient routine to obtain the name of a module.\n fn module_to_string(module: Module<'_>) -> Option<String> {\n     let mut names = Vec::new();"}, {"sha": "1a4066e7a7dd298fc804de5a0bb881c6dd4c54dd", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 117, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/d0bcebd5c559c2c57b08444b270e739e4c0e74c5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0bcebd5c559c2c57b08444b270e739e4c0e74c5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=d0bcebd5c559c2c57b08444b270e739e4c0e74c5", "patch": "@@ -13,18 +13,15 @@ use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, Ident, ItemKind};\n use syntax::attr::{self, StabilityLevel};\n-use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Indeterminate};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, Mark, ExpnInfo, ExpnKind};\n use syntax::ext::tt::macro_rules;\n-use syntax::feature_gate::{feature_err, emit_feature_err, is_builtin_attr_name};\n-use syntax::feature_gate::{AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES};\n+use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n+use syntax::feature_gate::GateIssue;\n use syntax::symbol::{Symbol, kw, sym};\n-use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n-use errors::Applicability;\n \n use std::cell::Cell;\n use std::{mem, ptr};\n@@ -359,60 +356,6 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: Symbol) {\n-        let mut err = feature_err(\n-            &self.session.parse_sess,\n-            feature,\n-            span,\n-            GateIssue::Language,\n-            &msg,\n-        );\n-\n-        let features = self.session.features_untracked();\n-\n-        let attr_candidates = BUILTIN_ATTRIBUTES\n-            .iter()\n-            .filter_map(|&(name, _, _, ref gate)| {\n-                if name.as_str().starts_with(\"rustc_\") && !features.rustc_attrs {\n-                    return None;\n-                }\n-\n-                match gate {\n-                    AttributeGate::Gated(Stability::Unstable, ..)\n-                        if self.session.opts.unstable_features.is_nightly_build() =>\n-                    {\n-                        Some(name)\n-                    }\n-                    AttributeGate::Gated(Stability::Deprecated(..), ..) => Some(name),\n-                    AttributeGate::Ungated => Some(name),\n-                    _ => None,\n-                }\n-            })\n-            .chain(\n-                // Add built-in macro attributes as well.\n-                self.builtin_macros.iter().filter_map(|(name, binding)| {\n-                    match binding.macro_kind() {\n-                        Some(MacroKind::Attr) => Some(*name),\n-                        _ => None,\n-                    }\n-                }),\n-            )\n-            .collect::<Vec<_>>();\n-\n-        let lev_suggestion = find_best_match_for_name(attr_candidates.iter(), &name, None);\n-\n-        if let Some(suggestion) = lev_suggestion {\n-            err.span_suggestion(\n-                span,\n-                \"a built-in attribute with a similar name exists\",\n-                suggestion.to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-\n-        err.emit();\n-    }\n-\n     pub fn resolve_macro_path(\n         &mut self,\n         path: &ast::Path,\n@@ -1042,64 +985,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn suggest_macro_name(&mut self, name: Symbol, kind: MacroKind,\n-                          err: &mut DiagnosticBuilder<'a>, span: Span) {\n-        if kind == MacroKind::Derive && (name.as_str() == \"Send\" || name.as_str() == \"Sync\") {\n-            let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", name);\n-            err.span_note(span, &msg);\n-            return;\n-        }\n-\n-        // First check if this is a locally-defined bang macro.\n-        let suggestion = if let MacroKind::Bang = kind {\n-            find_best_match_for_name(\n-                self.macro_names.iter().map(|ident| &ident.name), &name.as_str(), None)\n-        } else {\n-            None\n-        // Then check global macros.\n-        }.or_else(|| {\n-            let names = self.builtin_macros.iter().chain(self.macro_use_prelude.iter())\n-                                                  .filter_map(|(name, binding)| {\n-                if binding.macro_kind() == Some(kind) { Some(name) } else { None }\n-            });\n-            find_best_match_for_name(names, &name.as_str(), None)\n-        // Then check modules.\n-        }).or_else(|| {\n-            let is_macro = |res| {\n-                if let Res::Def(DefKind::Macro(def_kind), _) = res {\n-                    def_kind == kind\n-                } else {\n-                    false\n-                }\n-            };\n-            let ident = Ident::new(name, span);\n-            self.lookup_typo_candidate(&[Segment::from_ident(ident)], MacroNS, is_macro, span)\n-                .map(|suggestion| suggestion.candidate)\n-        });\n-\n-        if let Some(suggestion) = suggestion {\n-            if suggestion != name {\n-                if let MacroKind::Bang = kind {\n-                    err.span_suggestion(\n-                        span,\n-                        \"you could try the macro\",\n-                        suggestion.to_string(),\n-                        Applicability::MaybeIncorrect\n-                    );\n-                } else {\n-                    err.span_suggestion(\n-                        span,\n-                        \"try\",\n-                        suggestion.to_string(),\n-                        Applicability::MaybeIncorrect\n-                    );\n-                }\n-            } else {\n-                err.help(\"have you added the `#[macro_use]` on the module/import?\");\n-            }\n-        }\n-    }\n-\n     crate fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n         // Reserve some names that are not quite covered by the general check\n         // performed on `Resolver::builtin_attrs`."}, {"sha": "fb8f97d81a3aed08e11283847cb91c3c4c66a90b", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0bcebd5c559c2c57b08444b270e739e4c0e74c5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0bcebd5c559c2c57b08444b270e739e4c0e74c5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=d0bcebd5c559c2c57b08444b270e739e4c0e74c5", "patch": "@@ -7,8 +7,9 @@ use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use crate::{Resolver, Segment};\n use crate::{names_to_string, module_to_string};\n-use crate::{resolve_error, ResolutionError, Suggestion};\n+use crate::{resolve_error, ResolutionError};\n use crate::ModuleKind;\n+use crate::diagnostics::Suggestion;\n use crate::macros::ParentScope;\n \n use errors::Applicability;"}]}