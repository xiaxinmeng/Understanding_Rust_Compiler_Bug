{"sha": "c7656f67ad6c6ee687332f613a6074f76107c1b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NjU2ZjY3YWQ2YzZlZTY4NzMzMmY2MTNhNjA3NGY3NjEwN2MxYjg=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-21T16:58:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:17Z"}, "message": "std:: adding tcp::read fn as simple, blocking read operation, akin to write\n\nalso: read_future ala write_future .. woooooohooooooooo", "tree": {"sha": "f003ac7e271180912a365b3cd2f4e212a61d60bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f003ac7e271180912a365b3cd2f4e212a61d60bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7656f67ad6c6ee687332f613a6074f76107c1b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7656f67ad6c6ee687332f613a6074f76107c1b8", "html_url": "https://github.com/rust-lang/rust/commit/c7656f67ad6c6ee687332f613a6074f76107c1b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7656f67ad6c6ee687332f613a6074f76107c1b8/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2ae062e90105b4230981211f2979d3b093c3bcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ae062e90105b4230981211f2979d3b093c3bcb", "html_url": "https://github.com/rust-lang/rust/commit/c2ae062e90105b4230981211f2979d3b093c3bcb"}], "stats": {"total": 309, "additions": 219, "deletions": 90}, "files": [{"sha": "806fe6944aaa688892cddeb995019d9f211a4122", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 219, "deletions": 90, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/c7656f67ad6c6ee687332f613a6074f76107c1b8/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7656f67ad6c6ee687332f613a6074f76107c1b8/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=c7656f67ad6c6ee687332f613a6074f76107c1b8", "patch": "@@ -217,7 +217,7 @@ Write binary data to tcp stream; Returns a `future::future` value immediately\n This function can produce unsafe results if the call to `write_future` is\n made, the `future::future` value returned is never resolved via\n `future::get`, and then the `tcp_socket` passed in to `write_future` leaves\n-scope and is destructured before the task that runs the libuv write\n+scope and is destructed before the task that runs the libuv write\n operation completes.\n \n As such: If using `write_future`, always be sure to resolve the returned\n@@ -261,34 +261,7 @@ fn read_start(sock: tcp_socket)\n     -> result::result<comm::port<\n         result::result<[u8], tcp_err_data>>, tcp_err_data> unsafe {\n     let socket_data = ptr::addr_of(**sock);\n-    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n-    let start_ch = comm::chan(start_po);\n-    log(debug, \"in tcp::read_start before interact loop\");\n-    uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n-        log(debug, #fmt(\"in tcp::read_start interact cb %?\", loop_ptr));\n-        alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n-                               on_alloc_cb,\n-                               on_tcp_read_cb) {\n-          0i32 {\n-            log(debug, \"success doing uv_read_start\");\n-            comm::send(start_ch, none);\n-          }\n-          _ {\n-            log(debug, \"error attempting uv_read_start\");\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            comm::send(start_ch, some(err_data));\n-          }\n-        }\n-    };\n-    alt comm::recv(start_po) {\n-      some(err_data) {\n-        result::err(err_data.to_tcp_err())\n-      }\n-      none {\n-        result::ok((*socket_data).reader_po)\n-      }\n-    }\n+    read_start_common_impl(socket_data)\n }\n \n #[doc=\"\n@@ -301,30 +274,62 @@ Stop reading from an open TCP connection; used with `read_start`\n fn read_stop(sock: tcp_socket) ->\n     result::result<(), tcp_err_data> unsafe {\n     let socket_data = ptr::addr_of(**sock);\n-    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    let stop_po = comm::port::<option<tcp_err_data>>();\n-    let stop_ch = comm::chan(stop_po);\n-    uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n-        log(debug, \"in interact cb for tcp::read_stop\");\n-        alt uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n-          0i32 {\n-            log(debug, \"successfully called uv_read_stop\");\n-            comm::send(stop_ch, none);\n-          }\n-          _ {\n-            log(debug, \"failure in calling uv_read_stop\");\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            comm::send(stop_ch, some(err_data.to_tcp_err()));\n-          }\n-        }\n-    };\n-    alt comm::recv(stop_po) {\n-      some(err_data) {\n-        result::err(err_data.to_tcp_err())\n-      }\n-      none {\n-        result::ok(())\n-      }\n+    read_stop_common_impl(socket_data)\n+}\n+\n+#[doc=\"\n+Reads a single chunk of data from `tcp_socket`; block until data/error recv'd\n+\n+Does a blocking read operation for a single chunk of data from a `tcp_socket`\n+until a data arrives or an error is received. The provided `timeout_msecs`\n+value is used to raise an error if the timeout period passes without any\n+data received.\n+\n+# Arguments\n+\n+* `sock` - a `net::tcp::tcp_socket` that you wish to read from\n+* `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n+read attempt. Pass `0u` to wait indefinitely\n+\"]\n+fn read(sock: tcp_socket, timeout_msecs: uint)\n+    -> result::result<[u8],tcp_err_data> {\n+    let socket_data = ptr::addr_of(**sock);\n+    read_common_impl(socket_data, timeout_msecs)\n+}\n+\n+#[doc=\"\n+Reads a single chunk of data; returns a `future::future<[u8]>` immediately\n+\n+Does a non-blocking read operation for a single chunk of data from a\n+`tcp_socket` and immediately returns a `future` value representing the\n+result. When resolving the returned `future`, it will block until data\n+arrives or an error is received. The provided `timeout_msecs`\n+value is used to raise an error if the timeout period passes without any\n+data received.\n+\n+# Safety\n+\n+This function can produce unsafe results if the call to `read_future` is\n+made, the `future::future` value returned is never resolved via\n+`future::get`, and then the `tcp_socket` passed in to `read_future` leaves\n+scope and is destructed before the task that runs the libuv read\n+operation completes.\n+\n+As such: If using `read_future`, always be sure to resolve the returned\n+`future` so as to ensure libuv doesn't try to access a released read handle.\n+Otherwise, use the blocking `tcp::read` function instead.\n+\n+# Arguments\n+\n+* `sock` - a `net::tcp::tcp_socket` that you wish to read from\n+* `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n+read attempt. Pass `0u` to wait indefinitely\n+\"]\n+fn read_future(sock: tcp_socket, timeout_msecs: uint)\n+    -> future::future<result::result<[u8],tcp_err_data>> {\n+    let socket_data = ptr::addr_of(**sock);\n+    future::spawn {||\n+        read_common_impl(socket_data, timeout_msecs)\n     }\n }\n \n@@ -778,13 +783,166 @@ impl sock_methods for tcp_socket {\n         result::result<(), tcp_err_data> {\n         read_stop(self)\n     }\n-    fn write(raw_write_data: [[u8]])\n+    fn read(timeout_msecs: uint) ->\n+        result::result<[u8], tcp_err_data> {\n+        read(self, timeout_msecs)\n+    }\n+    fn read_future(timeout_msecs: uint) ->\n+        future::future<result::result<[u8], tcp_err_data>> {\n+        read_future(self, timeout_msecs)\n+    }\n+    fn write(raw_write_data: [u8])\n         -> result::result<(), tcp_err_data> {\n         write(self, raw_write_data)\n     }\n+    fn write_future(raw_write_data: [u8])\n+        -> future::future<result::result<(), tcp_err_data>> {\n+        write_future(self, raw_write_data)\n+    }\n }\n // INTERNAL API\n \n+// shared implementation for tcp::read\n+fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n+    -> result::result<[u8],tcp_err_data> {\n+    log(debug, \"starting tcp::read\");\n+    let rs_result = read_start_common_impl(socket_data);\n+    if result::is_failure(rs_result) {\n+        let err_data = result::get_err(rs_result);\n+        result::err(err_data)\n+    }\n+    else {\n+        log(debug, \"tcp::read before recv_timeout\");\n+        let read_result = if timeout_msecs > 0u {\n+            timer::recv_timeout(\n+                timeout_msecs, result::get(rs_result))\n+        } else {\n+            some(comm::recv(result::get(rs_result)))\n+        };\n+        log(debug, \"tcp::read after recv_timeout\");\n+        alt read_result {\n+          none {\n+            log(debug, \"tcp::read: timed out..\");\n+            let err_data = {\n+                err_name: \"TIMEOUT\",\n+                err_msg: \"req timed out\"\n+            };\n+            read_stop_common_impl(socket_data);\n+            result::err(err_data)\n+          }\n+          some(data_result) {\n+            log(debug, \"tcp::read got data\");\n+            read_stop_common_impl(socket_data);\n+            data_result\n+          }\n+        }\n+    }\n+}\n+\n+// shared impl for read_stop\n+fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n+    result::result<(), tcp_err_data> unsafe {\n+    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n+    let stop_po = comm::port::<option<tcp_err_data>>();\n+    let stop_ch = comm::chan(stop_po);\n+    uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n+        log(debug, \"in interact cb for tcp::read_stop\");\n+        alt uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n+          0i32 {\n+            log(debug, \"successfully called uv_read_stop\");\n+            comm::send(stop_ch, none);\n+          }\n+          _ {\n+            log(debug, \"failure in calling uv_read_stop\");\n+            let err_data = uv::ll::get_last_err_data(loop_ptr);\n+            comm::send(stop_ch, some(err_data.to_tcp_err()));\n+          }\n+        }\n+    };\n+    alt comm::recv(stop_po) {\n+      some(err_data) {\n+        result::err(err_data.to_tcp_err())\n+      }\n+      none {\n+        result::ok(())\n+      }\n+    }\n+}\n+\n+// shared impl for read_start\n+fn read_start_common_impl(socket_data: *tcp_socket_data)\n+    -> result::result<comm::port<\n+        result::result<[u8], tcp_err_data>>, tcp_err_data> unsafe {\n+    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n+    let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n+    let start_ch = comm::chan(start_po);\n+    log(debug, \"in tcp::read_start before interact loop\");\n+    uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n+        log(debug, #fmt(\"in tcp::read_start interact cb %?\", loop_ptr));\n+        alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n+                               on_alloc_cb,\n+                               on_tcp_read_cb) {\n+          0i32 {\n+            log(debug, \"success doing uv_read_start\");\n+            comm::send(start_ch, none);\n+          }\n+          _ {\n+            log(debug, \"error attempting uv_read_start\");\n+            let err_data = uv::ll::get_last_err_data(loop_ptr);\n+            comm::send(start_ch, some(err_data));\n+          }\n+        }\n+    };\n+    alt comm::recv(start_po) {\n+      some(err_data) {\n+        result::err(err_data.to_tcp_err())\n+      }\n+      none {\n+        result::ok((*socket_data).reader_po)\n+      }\n+    }\n+}\n+\n+// shared implementation used by write and write_future\n+fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n+                     raw_write_data: [u8])\n+    -> result::result<(), tcp_err_data> unsafe {\n+    let write_req_ptr = ptr::addr_of((*socket_data_ptr).write_req);\n+    let stream_handle_ptr =\n+        (*socket_data_ptr).stream_handle_ptr;\n+    let write_buf_vec =  [ uv::ll::buf_init(\n+        vec::unsafe::to_ptr(raw_write_data),\n+        vec::len(raw_write_data)) ];\n+    let write_buf_vec_ptr = ptr::addr_of(write_buf_vec);\n+    let result_po = comm::port::<tcp_write_result>();\n+    let write_data = {\n+        result_ch: comm::chan(result_po)\n+    };\n+    let write_data_ptr = ptr::addr_of(write_data);\n+    uv::hl::interact((*socket_data_ptr).hl_loop) {|loop_ptr|\n+        log(debug, #fmt(\"in interact cb for tcp::write %?\", loop_ptr));\n+        alt uv::ll::write(write_req_ptr,\n+                          stream_handle_ptr,\n+                          write_buf_vec_ptr,\n+                          tcp_write_complete_cb) {\n+          0i32 {\n+            log(debug, \"uv_write() invoked successfully\");\n+            uv::ll::set_data_for_req(write_req_ptr, write_data_ptr);\n+          }\n+          _ {\n+            log(debug, \"error invoking uv_write()\");\n+            let err_data = uv::ll::get_last_err_data(loop_ptr);\n+            comm::send((*write_data_ptr).result_ch,\n+                       tcp_write_error(err_data.to_tcp_err()));\n+          }\n+        }\n+    };\n+    alt comm::recv(result_po) {\n+      tcp_write_success { result::ok(()) }\n+      tcp_write_error(err_data) { result::err(err_data.to_tcp_err()) }\n+    }\n+}\n+\n // various recv_* can use a tcp_conn_port can re-use this..\n fn conn_port_new_tcp_socket(\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n@@ -1266,8 +1424,7 @@ mod test {\n                             let sock = result::unwrap(accept_result);\n                             log(debug, \"SERVER: successfully accepted\"+\n                                 \"connection!\");\n-                            let received_req_bytes =\n-                                tcp_read_single(sock);\n+                            let received_req_bytes = sock.read(2000u);\n                             alt received_req_bytes {\n                               result::ok(data) {\n                                 server_ch.send(\n@@ -1278,6 +1435,8 @@ mod test {\n                                 comm::send(kill_ch, none);\n                               }\n                               result::err(err_data) {\n+                                log(debug, #fmt(\"SERVER: error recvd: %s %s\",\n+                                    err_data.err_name, err_data.err_msg));\n                                 comm::send(kill_ch, some(err_data));\n                                 server_ch.send(\"\");\n                               }\n@@ -1333,7 +1492,7 @@ mod test {\n             log(debug, \"SERVER: successfully accepted\"+\n                 \"connection!\");\n             let received_req_bytes =\n-                tcp_read_single(sock);\n+                sock.read(2000u);\n             alt received_req_bytes {\n               result::ok(data) {\n                 server_ch.send(\n@@ -1370,7 +1529,7 @@ mod test {\n             let sock = result::unwrap(connect_result);\n             let resp_bytes = str::bytes(resp);\n             tcp_write_single(sock, resp_bytes);\n-            let read_result = tcp_read_single(sock);\n+            let read_result = sock.read(2000u);\n             if read_result.is_failure() {\n                 log(debug, \"CLIENT: failure to read\");\n                 \"\"\n@@ -1385,39 +1544,9 @@ mod test {\n         }\n     }\n \n-    fn tcp_read_single(sock: tcp_socket)\n-        -> result::result<[u8],tcp_err_data> {\n-        log(debug, \"starting tcp_read_single\");\n-        let rs_result = sock.read_start();\n-        if result::is_failure(rs_result) {\n-            let err_data = result::get_err(rs_result);\n-            result::err(err_data)\n-        }\n-        else {\n-            log(debug, \"before recv_timeout\");\n-            let read_result = timer::recv_timeout(\n-                2000u, result::get(rs_result));\n-            log(debug, \"after recv_timeout\");\n-            alt read_result {\n-              none {\n-                log(debug, \"tcp_read_single: timed out..\");\n-                let err_data = {\n-                    err_name: \"TIMEOUT\",\n-                    err_msg: \"req timed out\"\n-                };\n-                result::err(err_data)\n-              }\n-              some(data_result) {\n-                log(debug, \"tcp_read_single: got data\");\n-                sock.read_stop();\n-                data_result\n-              }\n-            }\n-        }\n-    }\n-\n     fn tcp_write_single(sock: tcp_socket, val: [u8]) {\n-        let write_result = sock.write([val]);\n+        let write_result_future = sock.write_future(val);\n+        let write_result = write_result_future.get();\n         if result::is_failure(write_result) {\n             log(debug, \"tcp_write_single: write failed!\");\n             let err_data = result::get_err(write_result);"}]}