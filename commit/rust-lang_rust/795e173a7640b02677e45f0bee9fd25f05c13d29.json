{"sha": "795e173a7640b02677e45f0bee9fd25f05c13d29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NWUxNzNhNzY0MGIwMjY3N2U0NWYwYmVlOWZkMjVmMDVjMTNkMjk=", "commit": {"author": {"name": "Ed Schouten", "email": "ed@nuxi.nl", "date": "2018-01-08T09:49:18Z"}, "committer": {"name": "Ed Schouten", "email": "ed@nuxi.nl", "date": "2018-01-11T10:21:51Z"}, "message": "Import the CloudABI system call bindings into the libstd tree.\n\nThese automatically generated Rust source files allow us to invoke\nsystem calls within CloudABI processes. These will be used by libstd to\nimplement primitives for I/O, threading, etc.\n\nThese source files are normally part of the 'cloudabi' crate. In the\ncase of libstd, we'd better copy them into the source tree, as having\nexternal dependencies in libstd is a bit messy. Original source files\ncan be found here:\n\n    https://github.com/NuxiNL/cloudabi/tree/master/rust", "tree": {"sha": "dd9fa3dfc212f49d60ee0f5d2820c35057523b32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd9fa3dfc212f49d60ee0f5d2820c35057523b32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/795e173a7640b02677e45f0bee9fd25f05c13d29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/795e173a7640b02677e45f0bee9fd25f05c13d29", "html_url": "https://github.com/rust-lang/rust/commit/795e173a7640b02677e45f0bee9fd25f05c13d29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/795e173a7640b02677e45f0bee9fd25f05c13d29/comments", "author": {"login": "EdSchouten", "id": 736085, "node_id": "MDQ6VXNlcjczNjA4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/736085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EdSchouten", "html_url": "https://github.com/EdSchouten", "followers_url": "https://api.github.com/users/EdSchouten/followers", "following_url": "https://api.github.com/users/EdSchouten/following{/other_user}", "gists_url": "https://api.github.com/users/EdSchouten/gists{/gist_id}", "starred_url": "https://api.github.com/users/EdSchouten/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EdSchouten/subscriptions", "organizations_url": "https://api.github.com/users/EdSchouten/orgs", "repos_url": "https://api.github.com/users/EdSchouten/repos", "events_url": "https://api.github.com/users/EdSchouten/events{/privacy}", "received_events_url": "https://api.github.com/users/EdSchouten/received_events", "type": "User", "site_admin": false}, "committer": {"login": "EdSchouten", "id": 736085, "node_id": "MDQ6VXNlcjczNjA4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/736085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EdSchouten", "html_url": "https://github.com/EdSchouten", "followers_url": "https://api.github.com/users/EdSchouten/followers", "following_url": "https://api.github.com/users/EdSchouten/following{/other_user}", "gists_url": "https://api.github.com/users/EdSchouten/gists{/gist_id}", "starred_url": "https://api.github.com/users/EdSchouten/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EdSchouten/subscriptions", "organizations_url": "https://api.github.com/users/EdSchouten/orgs", "repos_url": "https://api.github.com/users/EdSchouten/repos", "events_url": "https://api.github.com/users/EdSchouten/events{/privacy}", "received_events_url": "https://api.github.com/users/EdSchouten/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "619ced057842a25f8700237a9c22a6f5c318a954", "url": "https://api.github.com/repos/rust-lang/rust/commits/619ced057842a25f8700237a9c22a6f5c318a954", "html_url": "https://github.com/rust-lang/rust/commit/619ced057842a25f8700237a9c22a6f5c318a954"}], "stats": {"total": 2898, "additions": 2898, "deletions": 0}, "files": [{"sha": "f764cc1df5a5c2384dbb2e756ca8603fe9feb79e", "filename": "src/libstd/sys/cloudabi/abi/bitflags.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/795e173a7640b02677e45f0bee9fd25f05c13d29/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/795e173a7640b02677e45f0bee9fd25f05c13d29/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fbitflags.rs?ref=795e173a7640b02677e45f0bee9fd25f05c13d29", "patch": "@@ -0,0 +1,51 @@\n+// Copyright (c) 2018 Nuxi (https://nuxi.nl/) and contributors.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions\n+// are met:\n+// 1. Redistributions of source code must retain the above copyright\n+//    notice, this list of conditions and the following disclaimer.\n+// 2. Redistributions in binary form must reproduce the above copyright\n+//    notice, this list of conditions and the following disclaimer in the\n+//    documentation and/or other materials provided with the distribution.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+// SUCH DAMAGE.\n+\n+// Appease Rust's tidy.\n+// ignore-license\n+\n+#[cfg(feature = \"bitflags\")]\n+#[macro_use]\n+extern crate bitflags;\n+\n+// Minimal implementation of bitflags! in case we can't depend on the bitflags\n+// crate. Only implements `bits()` and a `from_bits_truncate()` that doesn't\n+// actually truncate.\n+#[cfg(not(feature = \"bitflags\"))]\n+macro_rules! bitflags {\n+  (\n+    $(#[$attr:meta])*\n+    pub struct $name:ident: $type:ty {\n+      $($(#[$const_attr:meta])* const $const:ident = $val:expr;)*\n+    }\n+  ) => {\n+    $(#[$attr])*\n+    #[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+    pub struct $name { bits: $type }\n+    impl $name {\n+      $($(#[$const_attr])* pub const $const: $name = $name{ bits: $val };)*\n+      pub fn bits(&self) -> $type { self.bits }\n+      pub fn from_bits_truncate(bits: $type) -> Self { $name{ bits } }\n+    }\n+  }\n+}"}, {"sha": "2909db5098e58f58860d1c4ad4f1a6569706112a", "filename": "src/libstd/sys/cloudabi/abi/cloudabi.rs", "status": "added", "additions": 2847, "deletions": 0, "changes": 2847, "blob_url": "https://github.com/rust-lang/rust/blob/795e173a7640b02677e45f0bee9fd25f05c13d29/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/795e173a7640b02677e45f0bee9fd25f05c13d29/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs?ref=795e173a7640b02677e45f0bee9fd25f05c13d29", "patch": "@@ -0,0 +1,2847 @@\n+// Copyright (c) 2016-2017 Nuxi (https://nuxi.nl/) and contributors.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions\n+// are met:\n+// 1. Redistributions of source code must retain the above copyright\n+//    notice, this list of conditions and the following disclaimer.\n+// 2. Redistributions in binary form must reproduce the above copyright\n+//    notice, this list of conditions and the following disclaimer in the\n+//    documentation and/or other materials provided with the distribution.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+// SUCH DAMAGE.\n+//\n+// This file is automatically generated. Do not edit.\n+//\n+// Source: https://github.com/NuxiNL/cloudabi\n+\n+// Appease Rust's tidy.\n+// ignore-license\n+// ignore-tidy-linelength\n+\n+//! **PLEASE NOTE: This entire crate including this\n+//! documentation is automatically generated from\n+//! [`cloudabi.txt`](https://github.com/NuxiNL/cloudabi/blob/master/cloudabi.txt)**\n+//!\n+//! # Nuxi CloudABI\n+//!\n+//! CloudABI is what you get if you take POSIX, add capability-based\n+//! security, and remove everything that's incompatible with that. The\n+//! result is a minimal ABI consisting of only 49 syscalls.\n+//!\n+//! CloudABI doesn't have its own kernel, but instead is implemented in existing\n+//! kernels: FreeBSD has CloudABI support for x86-64 and arm64, and [a patch-set\n+//! for NetBSD](https://github.com/NuxiNL/netbsd) and [a patch-set for\n+//! Linux](https://github.com/NuxiNL/linux) are available as well. This means that\n+//! CloudABI binaries can be executed on different operating systems, without any\n+//! modification.\n+//!\n+//! ## Capability-Based Security\n+//!\n+//! Capability-based security means that processes can only perform\n+//! actions that have no global impact. Processes cannot open files by\n+//! their absolute path, cannot open network connections, and cannot\n+//! observe global system state such as the process table.\n+//!\n+//! The capabilities of a process are fully determined by its set of open\n+//! file descriptors (fds). For example, files can only be opened if the\n+//! process already has a file descriptor to a directory the file is in.\n+//!\n+//! Unlike in POSIX, where processes are normally started with file\n+//! descriptors 0, 1, and 2 reserved for standard input, output, and\n+//! error, CloudABI does not reserve any file descriptor numbers for\n+//! specific purposes.\n+//!\n+//! In CloudABI, a process depends on its parent process to launch it with\n+//! the right set of resources, since the process will not be able to open\n+//! any new resources. For example, a simple static web server would need\n+//! to be started with a file descriptor to a [TCP\n+//! listener](https://github.com/NuxiNL/flower), and a file descriptor to\n+//! the directory for which to serve files. The web server will then be\n+//! unable to do anything other than reading files in that directory, and\n+//! process incoming network connections.\n+//!\n+//! So, unknown CloudABI binaries can safely be executed without the need\n+//! for containers, virtual machines, or other sandboxing technologies.\n+//!\n+//! Watch [Ed Schouten's Talk at\n+//! 32C3](https://www.youtube.com/watch?v=3N29vrPoDv8) for more\n+//! information about what capability-based security for UNIX means.\n+//!\n+//! ## Cloudlibc\n+//!\n+//! [Cloudlibc](https://github.com/NuxiNL/cloudlibc) is an implementation\n+//! of the C standard library, without all CloudABI-incompatible\n+//! functions. For example, Cloudlibc does not have `printf`, but does\n+//! have `fprintf`. It does not have `open`, but does have `openat`.\n+//!\n+//! ## CloudABI-Ports\n+//!\n+//! [CloudABI-Ports](https://github.com/NuxiNL/cloudabi-ports) is a\n+//! collection of ports of commonly used libraries and applications to\n+//! CloudABI. It contains software such as `zlib`, `libpng`, `boost`,\n+//! `memcached`, and much more. The software is patched to not depend on\n+//! any global state, such as files in `/etc` or `/dev`, using `open()`,\n+//! etc.\n+//!\n+//! ## Using CloudABI\n+//!\n+//! Instructions for using CloudABI (including kernel modules/patches,\n+//! toolchain, and ports) are available for several operating systems:\n+//!\n+//! - [Arch Linux](https://nuxi.nl/cloudabi/archlinux/)\n+//! - [Debian, Ubuntu, and other Debian derivatives](https://nuxi.nl/cloudabi/debian/)\n+//! - [FreeBSD, PC-BSD and DragonFly BSD](https://nuxi.nl/cloudabi/freebsd/)\n+//! - [Mac OS X](https://nuxi.nl/cloudabi/mac/)\n+//! - [NetBSD](https://nuxi.nl/cloudabi/netbsd/)\n+//!\n+//! ## Specification of the ABI\n+//!\n+//! The entire ABI is specified in a a file called\n+//! [`cloudabi.txt`](https://github.com/NuxiNL/cloudabi/blob/master/cloudabi.txt),\n+//! from which all\n+//! [headers](https://github.com/NuxiNL/cloudabi/tree/master/headers)\n+//! and documentation (including the one you're reading now) is generated.\n+\n+#![no_std]\n+#![allow(non_camel_case_types)]\n+\n+include!(\"bitflags.rs\");\n+\n+/// File or memory access pattern advisory information.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum advice {\n+  /// The application expects that it will not access the\n+  /// specified data in the near future.\n+  DONTNEED   = 1,\n+  /// The application expects to access the specified data\n+  /// once and then not reuse it thereafter.\n+  NOREUSE    = 2,\n+  /// The application has no advice to give on its behavior\n+  /// with respect to the specified data.\n+  NORMAL     = 3,\n+  /// The application expects to access the specified data\n+  /// in a random order.\n+  RANDOM     = 4,\n+  /// The application expects to access the specified data\n+  /// sequentially from lower offsets to higher offsets.\n+  SEQUENTIAL = 5,\n+  /// The application expects to access the specified data\n+  /// in the near future.\n+  WILLNEED   = 6,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+/// Enumeration describing the kind of value stored in [`auxv`](struct.auxv.html).\n+#[repr(u32)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum auxtype {\n+  /// Base address of the binary argument data provided to\n+  /// [`proc_exec()`](fn.proc_exec.html).\n+  ARGDATA      = 256,\n+  /// Length of the binary argument data provided to\n+  /// [`proc_exec()`](fn.proc_exec.html).\n+  ARGDATALEN   = 257,\n+  /// Base address at which the executable is placed in\n+  /// memory.\n+  BASE         =   7,\n+  /// Base address of a buffer of random data that may be\n+  /// used for non-cryptographic purposes, for example as a\n+  /// canary for stack smashing protection.\n+  CANARY       = 258,\n+  /// Length of a buffer of random data that may be used\n+  /// for non-cryptographic purposes, for example as a\n+  /// canary for stack smashing protection.\n+  CANARYLEN    = 259,\n+  /// Number of CPUs that the system this process is running\n+  /// on has.\n+  NCPUS        = 260,\n+  /// Terminator of the auxiliary vector.\n+  NULL         =   0,\n+  /// Smallest memory object size for which individual\n+  /// memory protection controls can be configured.\n+  PAGESZ       =   6,\n+  /// Address of the first ELF program header of the\n+  /// executable.\n+  PHDR         =   3,\n+  /// Number of ELF program headers of the executable.\n+  PHNUM        =   4,\n+  /// Identifier of the process.\n+  ///\n+  /// This environment does not provide any simple numerical\n+  /// process identifiers, for the reason that these are not\n+  /// useful in distributed contexts. Instead, processes are\n+  /// identified by a UUID.\n+  ///\n+  /// This record should point to sixteen bytes of binary\n+  /// data, containing a version 4 UUID (fully random).\n+  PID          = 263,\n+  /// Address of the ELF header of the vDSO.\n+  ///\n+  /// The vDSO is a shared library that is mapped in the\n+  /// address space of the process. It provides entry points\n+  /// for every system call supported by the environment,\n+  /// all having a corresponding symbol that is prefixed\n+  /// with `cloudabi_sys_`. System calls should be invoked\n+  /// through these entry points.\n+  ///\n+  /// The first advantage of letting processes call into a\n+  /// vDSO to perform system calls instead of raising\n+  /// hardware traps is that it allows for easy emulation of\n+  /// executables on top of existing operating systems. The\n+  /// second advantage is that in cases where an operating\n+  /// system provides native support for CloudABI executables,\n+  /// it may still implement partial userspace\n+  /// implementations of these system calls to improve\n+  /// performance (e.g., [`clock_time_get()`](fn.clock_time_get.html)). It also provides\n+  /// a more dynamic way of adding, removing or replacing\n+  /// system calls.\n+  SYSINFO_EHDR = 262,\n+  /// Thread ID of the initial thread of the process.\n+  TID          = 261,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u32,\n+}\n+\n+/// Identifiers for clocks.\n+#[repr(u32)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum clockid {\n+  /// The system-wide monotonic clock, which is defined as a\n+  /// clock measuring real time, whose value cannot be\n+  /// adjusted and which cannot have negative clock jumps.\n+  ///\n+  /// The epoch of this clock is undefined. The absolute\n+  /// time value of this clock therefore has no meaning.\n+  MONOTONIC          = 1,\n+  /// The CPU-time clock associated with the current\n+  /// process.\n+  PROCESS_CPUTIME_ID = 2,\n+  /// The system-wide clock measuring real time. Time value\n+  /// zero corresponds with 1970-01-01T00:00:00Z.\n+  REALTIME           = 3,\n+  /// The CPU-time clock associated with the current thread.\n+  THREAD_CPUTIME_ID  = 4,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u32,\n+}\n+\n+/// A userspace condition variable.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct condvar(pub u32);\n+/// The condition variable is in its initial state. There\n+/// are no threads waiting to be woken up. If the\n+/// condition variable has any other value, the kernel\n+/// must be called to wake up any sleeping threads.\n+pub const CONDVAR_HAS_NO_WAITERS: condvar = condvar(0);\n+\n+/// Identifier for a device containing a file system. Can be used\n+/// in combination with [`inode`](struct.inode.html) to uniquely identify a file on the\n+/// local system.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct device(pub u64);\n+\n+/// A reference to the offset of a directory entry.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct dircookie(pub u64);\n+/// Permanent reference to the first directory entry\n+/// within a directory.\n+pub const DIRCOOKIE_START: dircookie = dircookie(0);\n+\n+/// Error codes returned by system calls.\n+///\n+/// Not all of these error codes are returned by the system calls\n+/// provided by this environment, but are either used in userspace\n+/// exclusively or merely provided for alignment with POSIX.\n+#[repr(u16)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum errno {\n+  /// No error occurred. System call completed successfully.\n+  SUCCESS        =  0,\n+  /// Argument list too long.\n+  TOOBIG         =  1,\n+  /// Permission denied.\n+  ACCES          =  2,\n+  /// Address in use.\n+  ADDRINUSE      =  3,\n+  /// Address not available.\n+  ADDRNOTAVAIL   =  4,\n+  /// Address family not supported.\n+  AFNOSUPPORT    =  5,\n+  /// Resource unavailable, or operation would block.\n+  AGAIN          =  6,\n+  /// Connection already in progress.\n+  ALREADY        =  7,\n+  /// Bad file descriptor.\n+  BADF           =  8,\n+  /// Bad message.\n+  BADMSG         =  9,\n+  /// Device or resource busy.\n+  BUSY           = 10,\n+  /// Operation canceled.\n+  CANCELED       = 11,\n+  /// No child processes.\n+  CHILD          = 12,\n+  /// Connection aborted.\n+  CONNABORTED    = 13,\n+  /// Connection refused.\n+  CONNREFUSED    = 14,\n+  /// Connection reset.\n+  CONNRESET      = 15,\n+  /// Resource deadlock would occur.\n+  DEADLK         = 16,\n+  /// Destination address required.\n+  DESTADDRREQ    = 17,\n+  /// Mathematics argument out of domain of function.\n+  DOM            = 18,\n+  /// Reserved.\n+  DQUOT          = 19,\n+  /// File exists.\n+  EXIST          = 20,\n+  /// Bad address.\n+  FAULT          = 21,\n+  /// File too large.\n+  FBIG           = 22,\n+  /// Host is unreachable.\n+  HOSTUNREACH    = 23,\n+  /// Identifier removed.\n+  IDRM           = 24,\n+  /// Illegal byte sequence.\n+  ILSEQ          = 25,\n+  /// Operation in progress.\n+  INPROGRESS     = 26,\n+  /// Interrupted function.\n+  INTR           = 27,\n+  /// Invalid argument.\n+  INVAL          = 28,\n+  /// I/O error.\n+  IO             = 29,\n+  /// Socket is connected.\n+  ISCONN         = 30,\n+  /// Is a directory.\n+  ISDIR          = 31,\n+  /// Too many levels of symbolic links.\n+  LOOP           = 32,\n+  /// File descriptor value too large.\n+  MFILE          = 33,\n+  /// Too many links.\n+  MLINK          = 34,\n+  /// Message too large.\n+  MSGSIZE        = 35,\n+  /// Reserved.\n+  MULTIHOP       = 36,\n+  /// Filename too long.\n+  NAMETOOLONG    = 37,\n+  /// Network is down.\n+  NETDOWN        = 38,\n+  /// Connection aborted by network.\n+  NETRESET       = 39,\n+  /// Network unreachable.\n+  NETUNREACH     = 40,\n+  /// Too many files open in system.\n+  NFILE          = 41,\n+  /// No buffer space available.\n+  NOBUFS         = 42,\n+  /// No such device.\n+  NODEV          = 43,\n+  /// No such file or directory.\n+  NOENT          = 44,\n+  /// Executable file format error.\n+  NOEXEC         = 45,\n+  /// No locks available.\n+  NOLCK          = 46,\n+  /// Reserved.\n+  NOLINK         = 47,\n+  /// Not enough space.\n+  NOMEM          = 48,\n+  /// No message of the desired type.\n+  NOMSG          = 49,\n+  /// Protocol not available.\n+  NOPROTOOPT     = 50,\n+  /// No space left on device.\n+  NOSPC          = 51,\n+  /// Function not supported.\n+  NOSYS          = 52,\n+  /// The socket is not connected.\n+  NOTCONN        = 53,\n+  /// Not a directory or a symbolic link to a directory.\n+  NOTDIR         = 54,\n+  /// Directory not empty.\n+  NOTEMPTY       = 55,\n+  /// State not recoverable.\n+  NOTRECOVERABLE = 56,\n+  /// Not a socket.\n+  NOTSOCK        = 57,\n+  /// Not supported, or operation not supported on socket.\n+  NOTSUP         = 58,\n+  /// Inappropriate I/O control operation.\n+  NOTTY          = 59,\n+  /// No such device or address.\n+  NXIO           = 60,\n+  /// Value too large to be stored in data type.\n+  OVERFLOW       = 61,\n+  /// Previous owner died.\n+  OWNERDEAD      = 62,\n+  /// Operation not permitted.\n+  PERM           = 63,\n+  /// Broken pipe.\n+  PIPE           = 64,\n+  /// Protocol error.\n+  PROTO          = 65,\n+  /// Protocol not supported.\n+  PROTONOSUPPORT = 66,\n+  /// Protocol wrong type for socket.\n+  PROTOTYPE      = 67,\n+  /// Result too large.\n+  RANGE          = 68,\n+  /// Read-only file system.\n+  ROFS           = 69,\n+  /// Invalid seek.\n+  SPIPE          = 70,\n+  /// No such process.\n+  SRCH           = 71,\n+  /// Reserved.\n+  STALE          = 72,\n+  /// Connection timed out.\n+  TIMEDOUT       = 73,\n+  /// Text file busy.\n+  TXTBSY         = 74,\n+  /// Cross-device link.\n+  XDEV           = 75,\n+  /// Extension: Capabilities insufficient.\n+  NOTCAPABLE     = 76,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u16,\n+}\n+\n+bitflags! {\n+  /// The state of the file descriptor subscribed to with\n+  /// [`FD_READ`](enum.eventtype.html#variant.FD_READ) or [`FD_WRITE`](enum.eventtype.html#variant.FD_WRITE).\n+  #[repr(C)]\n+  pub struct eventrwflags: u16 {\n+    /// The peer of this socket has closed or disconnected.\n+    const HANGUP = 0x0001;\n+  }\n+}\n+\n+/// Type of a subscription to an event or its occurrence.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum eventtype {\n+  /// The time value of clock [`subscription.union.clock.clock_id`](struct.subscription_clock.html#structfield.clock_id)\n+  /// has reached timestamp [`subscription.union.clock.timeout`](struct.subscription_clock.html#structfield.timeout).\n+  CLOCK          = 1,\n+  /// Condition variable [`subscription.union.condvar.condvar`](struct.subscription_condvar.html#structfield.condvar) has\n+  /// been woken up and [`subscription.union.condvar.lock`](struct.subscription_condvar.html#structfield.lock) has been\n+  /// acquired for writing.\n+  CONDVAR        = 2,\n+  /// File descriptor [`subscription.union.fd_readwrite.fd`](struct.subscription_fd_readwrite.html#structfield.fd) has\n+  /// data available for reading. This event always triggers\n+  /// for regular files.\n+  FD_READ        = 3,\n+  /// File descriptor [`subscription.union.fd_readwrite.fd`](struct.subscription_fd_readwrite.html#structfield.fd) has\n+  /// capacity available for writing. This event always\n+  /// triggers for regular files.\n+  FD_WRITE       = 4,\n+  /// Lock [`subscription.union.lock.lock`](struct.subscription_lock.html#structfield.lock) has been acquired for\n+  /// reading.\n+  LOCK_RDLOCK    = 5,\n+  /// Lock [`subscription.union.lock.lock`](struct.subscription_lock.html#structfield.lock) has been acquired for\n+  /// writing.\n+  LOCK_WRLOCK    = 6,\n+  /// The process associated with process descriptor\n+  /// [`subscription.union.proc_terminate.fd`](struct.subscription_proc_terminate.html#structfield.fd) has terminated.\n+  PROC_TERMINATE = 7,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+/// Exit code generated by a process when exiting.\n+pub type exitcode = u32;\n+\n+/// A file descriptor number.\n+///\n+/// Unlike on POSIX-compliant systems, none of the file descriptor\n+/// numbers are reserved for a purpose (e.g., stdin, stdout,\n+/// stderr). Operating systems are not required to allocate new\n+/// file descriptors in ascending order.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct fd(pub u32);\n+/// Returned to the child process by [`proc_fork()`](fn.proc_fork.html).\n+pub const PROCESS_CHILD: fd = fd(0xffffffff);\n+/// Passed to [`mem_map()`](fn.mem_map.html) when creating a mapping to\n+/// anonymous memory.\n+pub const MAP_ANON_FD  : fd = fd(0xffffffff);\n+\n+bitflags! {\n+  /// File descriptor flags.\n+  #[repr(C)]\n+  pub struct fdflags: u16 {\n+    /// Append mode: Data written to the file is always\n+    /// appended to the file's end.\n+    const APPEND   = 0x0001;\n+    /// Write according to synchronized I/O data integrity\n+    /// completion. Only the data stored in the file is\n+    /// synchronized.\n+    const DSYNC    = 0x0002;\n+    /// Non-blocking mode.\n+    const NONBLOCK = 0x0004;\n+    /// Synchronized read I/O operations.\n+    const RSYNC    = 0x0008;\n+    /// Write according to synchronized I/O file integrity\n+    /// completion. In addition to synchronizing the data\n+    /// stored in the file, the system may also synchronously\n+    /// update the file's metadata.\n+    const SYNC     = 0x0010;\n+  }\n+}\n+\n+bitflags! {\n+  /// Which file descriptor attributes to adjust.\n+  #[repr(C)]\n+  pub struct fdsflags: u16 {\n+    /// Adjust the file descriptor flags stored in\n+    /// [`fdstat.fs_flags`](struct.fdstat.html#structfield.fs_flags).\n+    const FLAGS  = 0x0001;\n+    /// Restrict the rights of the file descriptor to the\n+    /// rights stored in [`fdstat.fs_rights_base`](struct.fdstat.html#structfield.fs_rights_base) and\n+    /// [`fdstat.fs_rights_inheriting`](struct.fdstat.html#structfield.fs_rights_inheriting).\n+    const RIGHTS = 0x0002;\n+  }\n+}\n+\n+/// Relative offset within a file.\n+pub type filedelta = i64;\n+\n+/// Non-negative file size or length of a region within a file.\n+pub type filesize = u64;\n+\n+/// The type of a file descriptor or file.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum filetype {\n+  /// The type of the file descriptor or file is unknown or\n+  /// is different from any of the other types specified.\n+  UNKNOWN          =   0,\n+  /// The file descriptor or file refers to a block device\n+  /// inode.\n+  BLOCK_DEVICE     =  16,\n+  /// The file descriptor or file refers to a character\n+  /// device inode.\n+  CHARACTER_DEVICE =  17,\n+  /// The file descriptor or file refers to a directory\n+  /// inode.\n+  DIRECTORY        =  32,\n+  /// The file descriptor refers to a process handle.\n+  PROCESS          =  80,\n+  /// The file descriptor or file refers to a regular file\n+  /// inode.\n+  REGULAR_FILE     =  96,\n+  /// The file descriptor refers to a shared memory object.\n+  SHARED_MEMORY    = 112,\n+  /// The file descriptor or file refers to a datagram\n+  /// socket.\n+  SOCKET_DGRAM     = 128,\n+  /// The file descriptor or file refers to a byte-stream\n+  /// socket.\n+  SOCKET_STREAM    = 130,\n+  /// The file refers to a symbolic link inode.\n+  SYMBOLIC_LINK    = 144,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+bitflags! {\n+  /// Which file attributes to adjust.\n+  #[repr(C)]\n+  pub struct fsflags: u16 {\n+    /// Adjust the last data access timestamp to the value\n+    /// stored in [`filestat.st_atim`](struct.filestat.html#structfield.st_atim).\n+    const ATIM     = 0x0001;\n+    /// Adjust the last data access timestamp to the time\n+    /// of clock [`REALTIME`](enum.clockid.html#variant.REALTIME).\n+    const ATIM_NOW = 0x0002;\n+    /// Adjust the last data modification timestamp to the\n+    /// value stored in [`filestat.st_mtim`](struct.filestat.html#structfield.st_mtim).\n+    const MTIM     = 0x0004;\n+    /// Adjust the last data modification timestamp to the\n+    /// time of clock [`REALTIME`](enum.clockid.html#variant.REALTIME).\n+    const MTIM_NOW = 0x0008;\n+    /// Truncate or extend the file to the size stored in\n+    /// [`filestat.st_size`](struct.filestat.html#structfield.st_size).\n+    const SIZE     = 0x0010;\n+  }\n+}\n+\n+/// File serial number that is unique within its file system.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct inode(pub u64);\n+\n+/// Number of hard links to an inode.\n+pub type linkcount = u32;\n+\n+/// A userspace read-recursive readers-writer lock, similar to a\n+/// Linux futex or a FreeBSD umtx.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct lock(pub u32);\n+/// Value indicating that the lock is in its initial\n+/// unlocked state.\n+pub const LOCK_UNLOCKED      : lock = lock(0x00000000);\n+/// Bitmask indicating that the lock is write-locked. If\n+/// set, the lower 30 bits of the lock contain the\n+/// identifier of the thread that owns the write lock.\n+/// Otherwise, the lower 30 bits of the lock contain the\n+/// number of acquired read locks.\n+pub const LOCK_WRLOCKED      : lock = lock(0x40000000);\n+/// Bitmask indicating that the lock is either read locked\n+/// or write locked, and that one or more threads have\n+/// their execution suspended, waiting to acquire the\n+/// lock. The last owner of the lock must call the\n+/// kernel to unlock.\n+///\n+/// When the lock is acquired for reading and this bit is\n+/// set, it means that one or more threads are attempting\n+/// to acquire this lock for writing. In that case, other\n+/// threads should only acquire additional read locks if\n+/// suspending execution would cause a deadlock. It is\n+/// preferred to suspend execution, as this prevents\n+/// starvation of writers.\n+pub const LOCK_KERNEL_MANAGED: lock = lock(0x80000000);\n+/// Value indicating that the lock is in an incorrect\n+/// state. A lock cannot be in its initial unlocked state,\n+/// while also managed by the kernel.\n+pub const LOCK_BOGUS         : lock = lock(0x80000000);\n+\n+bitflags! {\n+  /// Flags determining the method of how paths are resolved.\n+  #[repr(C)]\n+  pub struct lookupflags: u32 {\n+    /// As long as the resolved path corresponds to a symbolic\n+    /// link, it is expanded.\n+    const SYMLINK_FOLLOW = 0x00000001;\n+  }\n+}\n+\n+bitflags! {\n+  /// Memory mapping flags.\n+  #[repr(C)]\n+  pub struct mflags: u8 {\n+    /// Instead of mapping the contents of the file provided,\n+    /// create a mapping to anonymous memory. The file\n+    /// descriptor argument must be set to [`MAP_ANON_FD`](constant.MAP_ANON_FD.html),\n+    /// and the offset must be set to zero.\n+    const ANON    = 0x01;\n+    /// Require that the mapping is performed at the base\n+    /// address provided.\n+    const FIXED   = 0x02;\n+    /// Changes are private.\n+    const PRIVATE = 0x04;\n+    /// Changes are shared.\n+    const SHARED  = 0x08;\n+  }\n+}\n+\n+bitflags! {\n+  /// Memory page protection options.\n+  ///\n+  /// This implementation enforces the `W^X` property: Pages cannot be\n+  /// mapped for execution while also mapped for writing.\n+  #[repr(C)]\n+  pub struct mprot: u8 {\n+    /// Page can be executed.\n+    const EXEC  = 0x01;\n+    /// Page can be written.\n+    const WRITE = 0x02;\n+    /// Page can be read.\n+    const READ  = 0x04;\n+  }\n+}\n+\n+bitflags! {\n+  /// Methods of synchronizing memory with physical storage.\n+  #[repr(C)]\n+  pub struct msflags: u8 {\n+    /// Perform asynchronous writes.\n+    const ASYNC      = 0x01;\n+    /// Invalidate cached data.\n+    const INVALIDATE = 0x02;\n+    /// Perform synchronous writes.\n+    const SYNC       = 0x04;\n+  }\n+}\n+\n+/// Specifies the number of threads sleeping on a condition\n+/// variable that should be woken up.\n+pub type nthreads = u32;\n+\n+bitflags! {\n+  /// Open flags used by [`file_open()`](fn.file_open.html).\n+  #[repr(C)]\n+  pub struct oflags: u16 {\n+    /// Create file if it does not exist.\n+    const CREAT     = 0x0001;\n+    /// Fail if not a directory.\n+    const DIRECTORY = 0x0002;\n+    /// Fail if file already exists.\n+    const EXCL      = 0x0004;\n+    /// Truncate file to size 0.\n+    const TRUNC     = 0x0008;\n+  }\n+}\n+\n+bitflags! {\n+  /// Flags provided to [`sock_recv()`](fn.sock_recv.html).\n+  #[repr(C)]\n+  pub struct riflags: u16 {\n+    /// Returns the message without removing it from the\n+    /// socket's receive queue.\n+    const PEEK    = 0x0004;\n+    /// On byte-stream sockets, block until the full amount\n+    /// of data can be returned.\n+    const WAITALL = 0x0010;\n+  }\n+}\n+\n+bitflags! {\n+  /// File descriptor rights, determining which actions may be\n+  /// performed.\n+  #[repr(C)]\n+  pub struct rights: u64 {\n+    /// The right to invoke [`fd_datasync()`](fn.fd_datasync.html).\n+    ///\n+    /// If [`FILE_OPEN`](struct.rights.html#associatedconstant.FILE_OPEN) is set, includes the right to\n+    /// invoke [`file_open()`](fn.file_open.html) with [`DSYNC`](struct.fdflags.html#associatedconstant.DSYNC).\n+    const FD_DATASYNC           = 0x0000000000000001;\n+    /// The right to invoke [`fd_read()`](fn.fd_read.html) and [`sock_recv()`](fn.sock_recv.html).\n+    ///\n+    /// If [`MEM_MAP`](struct.rights.html#associatedconstant.MEM_MAP) is set, includes the right to\n+    /// invoke [`mem_map()`](fn.mem_map.html) with memory protection option\n+    /// [`READ`](struct.mprot.html#associatedconstant.READ).\n+    ///\n+    /// If [`FD_SEEK`](struct.rights.html#associatedconstant.FD_SEEK) is set, includes the right to invoke\n+    /// [`fd_pread()`](fn.fd_pread.html).\n+    const FD_READ               = 0x0000000000000002;\n+    /// The right to invoke [`fd_seek()`](fn.fd_seek.html). This flag implies\n+    /// [`FD_TELL`](struct.rights.html#associatedconstant.FD_TELL).\n+    const FD_SEEK               = 0x0000000000000004;\n+    /// The right to invoke [`fd_stat_put()`](fn.fd_stat_put.html) with\n+    /// [`FLAGS`](struct.fdsflags.html#associatedconstant.FLAGS).\n+    const FD_STAT_PUT_FLAGS     = 0x0000000000000008;\n+    /// The right to invoke [`fd_sync()`](fn.fd_sync.html).\n+    ///\n+    /// If [`FILE_OPEN`](struct.rights.html#associatedconstant.FILE_OPEN) is set, includes the right to\n+    /// invoke [`file_open()`](fn.file_open.html) with [`RSYNC`](struct.fdflags.html#associatedconstant.RSYNC) and\n+    /// [`DSYNC`](struct.fdflags.html#associatedconstant.DSYNC).\n+    const FD_SYNC               = 0x0000000000000010;\n+    /// The right to invoke [`fd_seek()`](fn.fd_seek.html) in such a way that the\n+    /// file offset remains unaltered (i.e., [`CUR`](enum.whence.html#variant.CUR) with\n+    /// offset zero).\n+    const FD_TELL               = 0x0000000000000020;\n+    /// The right to invoke [`fd_write()`](fn.fd_write.html) and [`sock_send()`](fn.sock_send.html).\n+    ///\n+    /// If [`MEM_MAP`](struct.rights.html#associatedconstant.MEM_MAP) is set, includes the right to\n+    /// invoke [`mem_map()`](fn.mem_map.html) with memory protection option\n+    /// [`WRITE`](struct.mprot.html#associatedconstant.WRITE).\n+    ///\n+    /// If [`FD_SEEK`](struct.rights.html#associatedconstant.FD_SEEK) is set, includes the right to\n+    /// invoke [`fd_pwrite()`](fn.fd_pwrite.html).\n+    const FD_WRITE              = 0x0000000000000040;\n+    /// The right to invoke [`file_advise()`](fn.file_advise.html).\n+    const FILE_ADVISE           = 0x0000000000000080;\n+    /// The right to invoke [`file_allocate()`](fn.file_allocate.html).\n+    const FILE_ALLOCATE         = 0x0000000000000100;\n+    /// The right to invoke [`file_create()`](fn.file_create.html) with\n+    /// [`DIRECTORY`](enum.filetype.html#variant.DIRECTORY).\n+    const FILE_CREATE_DIRECTORY = 0x0000000000000200;\n+    /// If [`FILE_OPEN`](struct.rights.html#associatedconstant.FILE_OPEN) is set, the right to invoke\n+    /// [`file_open()`](fn.file_open.html) with [`CREAT`](struct.oflags.html#associatedconstant.CREAT).\n+    const FILE_CREATE_FILE      = 0x0000000000000400;\n+    /// The right to invoke [`file_link()`](fn.file_link.html) with the file\n+    /// descriptor as the source directory.\n+    const FILE_LINK_SOURCE      = 0x0000000000001000;\n+    /// The right to invoke [`file_link()`](fn.file_link.html) with the file\n+    /// descriptor as the target directory.\n+    const FILE_LINK_TARGET      = 0x0000000000002000;\n+    /// The right to invoke [`file_open()`](fn.file_open.html).\n+    const FILE_OPEN             = 0x0000000000004000;\n+    /// The right to invoke [`file_readdir()`](fn.file_readdir.html).\n+    const FILE_READDIR          = 0x0000000000008000;\n+    /// The right to invoke [`file_readlink()`](fn.file_readlink.html).\n+    const FILE_READLINK         = 0x0000000000010000;\n+    /// The right to invoke [`file_rename()`](fn.file_rename.html) with the file\n+    /// descriptor as the source directory.\n+    const FILE_RENAME_SOURCE    = 0x0000000000020000;\n+    /// The right to invoke [`file_rename()`](fn.file_rename.html) with the file\n+    /// descriptor as the target directory.\n+    const FILE_RENAME_TARGET    = 0x0000000000040000;\n+    /// The right to invoke [`file_stat_fget()`](fn.file_stat_fget.html).\n+    const FILE_STAT_FGET        = 0x0000000000080000;\n+    /// The right to invoke [`file_stat_fput()`](fn.file_stat_fput.html) with\n+    /// [`SIZE`](struct.fsflags.html#associatedconstant.SIZE).\n+    ///\n+    /// If [`FILE_OPEN`](struct.rights.html#associatedconstant.FILE_OPEN) is set, includes the right to\n+    /// invoke [`file_open()`](fn.file_open.html) with [`TRUNC`](struct.oflags.html#associatedconstant.TRUNC).\n+    const FILE_STAT_FPUT_SIZE   = 0x0000000000100000;\n+    /// The right to invoke [`file_stat_fput()`](fn.file_stat_fput.html) with\n+    /// [`ATIM`](struct.fsflags.html#associatedconstant.ATIM), [`ATIM_NOW`](struct.fsflags.html#associatedconstant.ATIM_NOW), [`MTIM`](struct.fsflags.html#associatedconstant.MTIM),\n+    /// and [`MTIM_NOW`](struct.fsflags.html#associatedconstant.MTIM_NOW).\n+    const FILE_STAT_FPUT_TIMES  = 0x0000000000200000;\n+    /// The right to invoke [`file_stat_get()`](fn.file_stat_get.html).\n+    const FILE_STAT_GET         = 0x0000000000400000;\n+    /// The right to invoke [`file_stat_put()`](fn.file_stat_put.html) with\n+    /// [`ATIM`](struct.fsflags.html#associatedconstant.ATIM), [`ATIM_NOW`](struct.fsflags.html#associatedconstant.ATIM_NOW), [`MTIM`](struct.fsflags.html#associatedconstant.MTIM),\n+    /// and [`MTIM_NOW`](struct.fsflags.html#associatedconstant.MTIM_NOW).\n+    const FILE_STAT_PUT_TIMES   = 0x0000000000800000;\n+    /// The right to invoke [`file_symlink()`](fn.file_symlink.html).\n+    const FILE_SYMLINK          = 0x0000000001000000;\n+    /// The right to invoke [`file_unlink()`](fn.file_unlink.html).\n+    const FILE_UNLINK           = 0x0000000002000000;\n+    /// The right to invoke [`mem_map()`](fn.mem_map.html) with [`mprot`](struct.mprot.html) set to\n+    /// zero.\n+    const MEM_MAP               = 0x0000000004000000;\n+    /// If [`MEM_MAP`](struct.rights.html#associatedconstant.MEM_MAP) is set, the right to invoke\n+    /// [`mem_map()`](fn.mem_map.html) with [`EXEC`](struct.mprot.html#associatedconstant.EXEC).\n+    const MEM_MAP_EXEC          = 0x0000000008000000;\n+    /// If [`FD_READ`](struct.rights.html#associatedconstant.FD_READ) is set, includes the right to\n+    /// invoke [`poll()`](fn.poll.html) to subscribe to [`FD_READ`](enum.eventtype.html#variant.FD_READ).\n+    ///\n+    /// If [`FD_WRITE`](struct.rights.html#associatedconstant.FD_WRITE) is set, includes the right to\n+    /// invoke [`poll()`](fn.poll.html) to subscribe to [`FD_WRITE`](enum.eventtype.html#variant.FD_WRITE).\n+    const POLL_FD_READWRITE     = 0x0000000010000000;\n+    /// The right to invoke [`poll()`](fn.poll.html) to subscribe to\n+    /// [`PROC_TERMINATE`](enum.eventtype.html#variant.PROC_TERMINATE).\n+    const POLL_PROC_TERMINATE   = 0x0000000040000000;\n+    /// The right to invoke [`proc_exec()`](fn.proc_exec.html).\n+    const PROC_EXEC             = 0x0000000100000000;\n+    /// The right to invoke [`sock_shutdown()`](fn.sock_shutdown.html).\n+    const SOCK_SHUTDOWN         = 0x0000008000000000;\n+  }\n+}\n+\n+bitflags! {\n+  /// Flags returned by [`sock_recv()`](fn.sock_recv.html).\n+  #[repr(C)]\n+  pub struct roflags: u16 {\n+    /// Returned by [`sock_recv()`](fn.sock_recv.html): List of file descriptors\n+    /// has been truncated.\n+    const FDS_TRUNCATED  = 0x0001;\n+    /// Returned by [`sock_recv()`](fn.sock_recv.html): Message data has been\n+    /// truncated.\n+    const DATA_TRUNCATED = 0x0008;\n+  }\n+}\n+\n+/// Indicates whether an object is stored in private or shared\n+/// memory.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum scope {\n+  /// The object is stored in private memory.\n+  PRIVATE = 4,\n+  /// The object is stored in shared memory.\n+  SHARED  = 8,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+bitflags! {\n+  /// Which channels on a socket need to be shut down.\n+  #[repr(C)]\n+  pub struct sdflags: u8 {\n+    /// Disables further receive operations.\n+    const RD = 0x01;\n+    /// Disables further send operations.\n+    const WR = 0x02;\n+  }\n+}\n+\n+bitflags! {\n+  /// Flags provided to [`sock_send()`](fn.sock_send.html). As there are currently no flags\n+  /// defined, it must be set to zero.\n+  #[repr(C)]\n+  pub struct siflags: u16 {\n+    const DEFAULT = 0;\n+  }\n+}\n+\n+/// Signal condition.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum signal {\n+  /// Process abort signal.\n+  ///\n+  /// Action: Terminates the process.\n+  ABRT   =  1,\n+  /// Alarm clock.\n+  ///\n+  /// Action: Terminates the process.\n+  ALRM   =  2,\n+  /// Access to an undefined portion of a memory object.\n+  ///\n+  /// Action: Terminates the process.\n+  BUS    =  3,\n+  /// Child process terminated, stopped, or continued.\n+  ///\n+  /// Action: Ignored.\n+  CHLD   =  4,\n+  /// Continue executing, if stopped.\n+  ///\n+  /// Action: Continues executing, if stopped.\n+  CONT   =  5,\n+  /// Erroneous arithmetic operation.\n+  ///\n+  /// Action: Terminates the process.\n+  FPE    =  6,\n+  /// Hangup.\n+  ///\n+  /// Action: Terminates the process.\n+  HUP    =  7,\n+  /// Illegal instruction.\n+  ///\n+  /// Action: Terminates the process.\n+  ILL    =  8,\n+  /// Terminate interrupt signal.\n+  ///\n+  /// Action: Terminates the process.\n+  INT    =  9,\n+  /// Kill.\n+  ///\n+  /// Action: Terminates the process.\n+  KILL   = 10,\n+  /// Write on a pipe with no one to read it.\n+  ///\n+  /// Action: Ignored.\n+  PIPE   = 11,\n+  /// Terminal quit signal.\n+  ///\n+  /// Action: Terminates the process.\n+  QUIT   = 12,\n+  /// Invalid memory reference.\n+  ///\n+  /// Action: Terminates the process.\n+  SEGV   = 13,\n+  /// Stop executing.\n+  ///\n+  /// Action: Stops executing.\n+  STOP   = 14,\n+  /// Bad system call.\n+  ///\n+  /// Action: Terminates the process.\n+  SYS    = 15,\n+  /// Termination signal.\n+  ///\n+  /// Action: Terminates the process.\n+  TERM   = 16,\n+  /// Trace/breakpoint trap.\n+  ///\n+  /// Action: Terminates the process.\n+  TRAP   = 17,\n+  /// Terminal stop signal.\n+  ///\n+  /// Action: Stops executing.\n+  TSTP   = 18,\n+  /// Background process attempting read.\n+  ///\n+  /// Action: Stops executing.\n+  TTIN   = 19,\n+  /// Background process attempting write.\n+  ///\n+  /// Action: Stops executing.\n+  TTOU   = 20,\n+  /// High bandwidth data is available at a socket.\n+  ///\n+  /// Action: Ignored.\n+  URG    = 21,\n+  /// User-defined signal 1.\n+  ///\n+  /// Action: Terminates the process.\n+  USR1   = 22,\n+  /// User-defined signal 2.\n+  ///\n+  /// Action: Terminates the process.\n+  USR2   = 23,\n+  /// Virtual timer expired.\n+  ///\n+  /// Action: Terminates the process.\n+  VTALRM = 24,\n+  /// CPU time limit exceeded.\n+  ///\n+  /// Action: Terminates the process.\n+  XCPU   = 25,\n+  /// File size limit exceeded.\n+  ///\n+  /// Action: Terminates the process.\n+  XFSZ   = 26,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+bitflags! {\n+  /// Flags determining how the timestamp provided in\n+  /// [`subscription.union.clock.timeout`](struct.subscription_clock.html#structfield.timeout) should be interpreted.\n+  #[repr(C)]\n+  pub struct subclockflags: u16 {\n+    /// If set, treat the timestamp provided in\n+    /// [`subscription.union.clock.timeout`](struct.subscription_clock.html#structfield.timeout) as an absolute timestamp\n+    /// of clock [`subscription.union.clock.clock_id`](struct.subscription_clock.html#structfield.clock_id).\n+    ///\n+    /// If clear, treat the timestamp provided in\n+    /// [`subscription.union.clock.timeout`](struct.subscription_clock.html#structfield.timeout) relative to the current\n+    /// time value of clock [`subscription.union.clock.clock_id`](struct.subscription_clock.html#structfield.clock_id).\n+    const ABSTIME = 0x0001;\n+  }\n+}\n+\n+bitflags! {\n+  /// Flags influencing the method of polling for read or writing on\n+  /// a file descriptor.\n+  #[repr(C)]\n+  pub struct subrwflags: u16 {\n+    /// Deprecated. Must be set by callers and ignored by\n+    /// implementations.\n+    const POLL = 0x0001;\n+  }\n+}\n+\n+/// Unique system-local identifier of a thread. This identifier is\n+/// only valid during the lifetime of the thread.\n+///\n+/// Threads must be aware of their thread identifier, as it is\n+/// written it into locks when acquiring them for writing. It is\n+/// not advised to use these identifiers for any other purpose.\n+///\n+/// As the thread identifier is also stored in [`lock`](struct.lock.html) when\n+/// [`LOCK_WRLOCKED`](constant.LOCK_WRLOCKED.html) is set, the top two bits of the thread\n+/// must always be set to zero.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct tid(pub u32);\n+\n+/// Timestamp in nanoseconds.\n+pub type timestamp = u64;\n+\n+bitflags! {\n+  /// Specifies whether files are unlinked or directories are\n+  /// removed.\n+  #[repr(C)]\n+  pub struct ulflags: u8 {\n+    /// If set, removes a directory. Otherwise, unlinks any\n+    /// non-directory file.\n+    const REMOVEDIR = 0x01;\n+  }\n+}\n+\n+/// User-provided value that can be attached to objects that is\n+/// retained when extracted from the kernel.\n+pub type userdata = u64;\n+\n+/// Relative to which position the offset of the file descriptor\n+/// should be set.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum whence {\n+  /// Seek relative to current position.\n+  CUR = 1,\n+  /// Seek relative to end-of-file.\n+  END = 2,\n+  /// Seek relative to start-of-file.\n+  SET = 3,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+/// Auxiliary vector entry.\n+///\n+/// The auxiliary vector is a list of key-value pairs that is\n+/// provided to the process on startup. Unlike structures, it is\n+/// extensible, as it is possible to add new records later on.\n+/// The auxiliary vector is always terminated by an entry having\n+/// type [`NULL`](enum.auxtype.html#variant.NULL).\n+///\n+/// The auxiliary vector is part of the x86-64 ABI, but is used by\n+/// this environment on all architectures.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct auxv {\n+  /// The type of the auxiliary vector entry.\n+  pub a_type: auxtype,\n+  pub union: auxv_union\n+}\n+/// A union inside `auxv`.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub union auxv_union {\n+  /// Used when `a_type` is [`ARGDATALEN`](enum.auxtype.html#variant.ARGDATALEN), [`CANARYLEN`](enum.auxtype.html#variant.CANARYLEN), [`NCPUS`](enum.auxtype.html#variant.NCPUS), [`PAGESZ`](enum.auxtype.html#variant.PAGESZ), [`PHNUM`](enum.auxtype.html#variant.PHNUM), or [`TID`](enum.auxtype.html#variant.TID).\n+/// A numerical value.\n+  pub a_val: usize,\n+  /// Used when `a_type` is [`ARGDATA`](enum.auxtype.html#variant.ARGDATA), [`BASE`](enum.auxtype.html#variant.BASE), [`CANARY`](enum.auxtype.html#variant.CANARY), [`PHDR`](enum.auxtype.html#variant.PHDR), [`PID`](enum.auxtype.html#variant.PID), or [`SYSINFO_EHDR`](enum.auxtype.html#variant.SYSINFO_EHDR).\n+/// A pointer value.\n+  pub a_ptr: *mut (),\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn auxv_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<auxv>(), 8);\n+  assert_eq!(::core::mem::align_of::<auxv>(), 4);\n+  unsafe {\n+    let obj: auxv = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.a_type as *const _ as usize - base, 0);\n+    assert_eq!(&obj.union.a_val as *const _ as usize - base, 4);\n+    assert_eq!(&obj.union.a_ptr as *const _ as usize - base, 4);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn auxv_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<auxv>(), 16);\n+  assert_eq!(::core::mem::align_of::<auxv>(), 8);\n+  unsafe {\n+    let obj: auxv = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.a_type as *const _ as usize - base, 0);\n+    assert_eq!(&obj.union.a_val as *const _ as usize - base, 8);\n+    assert_eq!(&obj.union.a_ptr as *const _ as usize - base, 8);\n+  }\n+}\n+\n+/// A region of memory for scatter/gather writes.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct ciovec {\n+  /// The address and length of the buffer to be written.\n+  pub buf: (*const (), usize),\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn ciovec_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<ciovec>(), 8);\n+  assert_eq!(::core::mem::align_of::<ciovec>(), 4);\n+  unsafe {\n+    let obj: ciovec = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.buf.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.buf.1 as *const _ as usize - base, 4);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn ciovec_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<ciovec>(), 16);\n+  assert_eq!(::core::mem::align_of::<ciovec>(), 8);\n+  unsafe {\n+    let obj: ciovec = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.buf.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.buf.1 as *const _ as usize - base, 8);\n+  }\n+}\n+\n+/// A directory entry.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct dirent {\n+  /// The offset of the next directory entry stored in this\n+  /// directory.\n+  pub d_next: dircookie,\n+  /// The serial number of the file referred to by this\n+  /// directory entry.\n+  pub d_ino: inode,\n+  /// The length of the name of the directory entry.\n+  pub d_namlen: u32,\n+  /// The type of the file referred to by this directory\n+  /// entry.\n+  pub d_type: filetype,\n+}\n+#[test]\n+fn dirent_layout_test() {\n+  assert_eq!(::core::mem::size_of::<dirent>(), 24);\n+  assert_eq!(::core::mem::align_of::<dirent>(), 8);\n+  unsafe {\n+    let obj: dirent = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.d_next as *const _ as usize - base, 0);\n+    assert_eq!(&obj.d_ino as *const _ as usize - base, 8);\n+    assert_eq!(&obj.d_namlen as *const _ as usize - base, 16);\n+    assert_eq!(&obj.d_type as *const _ as usize - base, 20);\n+  }\n+}\n+\n+/// An event that occurred.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct event {\n+  /// User-provided value that got attached to\n+  /// [`subscription.userdata`](struct.subscription.html#structfield.userdata).\n+  pub userdata: userdata,\n+  /// If non-zero, an error that occurred while processing\n+  /// the subscription request.\n+  pub error: errno,\n+  /// The type of the event that occurred.\n+  pub type_: eventtype,\n+  pub union: event_union\n+}\n+/// A union inside `event`.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub union event_union {\n+  /// Used when `type_` is [`FD_READ`](enum.eventtype.html#variant.FD_READ) or [`FD_WRITE`](enum.eventtype.html#variant.FD_WRITE).\n+  pub fd_readwrite: event_fd_readwrite,\n+  /// Used when `type_` is [`PROC_TERMINATE`](enum.eventtype.html#variant.PROC_TERMINATE).\n+  pub proc_terminate: event_proc_terminate,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct event_fd_readwrite {\n+  /// The number of bytes available\n+  /// for reading or writing.\n+  pub nbytes: filesize,\n+  /// Obsolete.\n+  pub unused: [u8; 4],\n+  /// The state of the file\n+  /// descriptor.\n+  pub flags: eventrwflags,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct event_proc_terminate {\n+  /// Obsolete.\n+  pub unused: [u8; 4],\n+  /// If zero, the process has\n+  /// exited.\n+  /// Otherwise, the signal\n+  /// condition causing it to\n+  /// terminated.\n+  pub signal: signal,\n+  /// If exited, the exit code of\n+  /// the process.\n+  pub exitcode: exitcode,\n+}\n+#[test]\n+fn event_layout_test() {\n+  assert_eq!(::core::mem::size_of::<event>(), 32);\n+  assert_eq!(::core::mem::align_of::<event>(), 8);\n+  unsafe {\n+    let obj: event = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.userdata as *const _ as usize - base, 0);\n+    assert_eq!(&obj.error as *const _ as usize - base, 8);\n+    assert_eq!(&obj.type_ as *const _ as usize - base, 10);\n+    assert_eq!(&obj.union.fd_readwrite.nbytes as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.fd_readwrite.unused as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.fd_readwrite.flags as *const _ as usize - base, 28);\n+    assert_eq!(&obj.union.proc_terminate.unused as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.proc_terminate.signal as *const _ as usize - base, 20);\n+    assert_eq!(&obj.union.proc_terminate.exitcode as *const _ as usize - base, 24);\n+  }\n+}\n+\n+/// File descriptor attributes.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct fdstat {\n+  /// File type.\n+  pub fs_filetype: filetype,\n+  /// File descriptor flags.\n+  pub fs_flags: fdflags,\n+  /// Rights that apply to this file descriptor.\n+  pub fs_rights_base: rights,\n+  /// Maximum set of rights that can be installed on new\n+  /// file descriptors that are created through this file\n+  /// descriptor, e.g., through [`file_open()`](fn.file_open.html).\n+  pub fs_rights_inheriting: rights,\n+}\n+#[test]\n+fn fdstat_layout_test() {\n+  assert_eq!(::core::mem::size_of::<fdstat>(), 24);\n+  assert_eq!(::core::mem::align_of::<fdstat>(), 8);\n+  unsafe {\n+    let obj: fdstat = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.fs_filetype as *const _ as usize - base, 0);\n+    assert_eq!(&obj.fs_flags as *const _ as usize - base, 2);\n+    assert_eq!(&obj.fs_rights_base as *const _ as usize - base, 8);\n+    assert_eq!(&obj.fs_rights_inheriting as *const _ as usize - base, 16);\n+  }\n+}\n+\n+/// File attributes.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct filestat {\n+  /// Device ID of device containing the file.\n+  pub st_dev: device,\n+  /// File serial number.\n+  pub st_ino: inode,\n+  /// File type.\n+  pub st_filetype: filetype,\n+  /// Number of hard links to the file.\n+  pub st_nlink: linkcount,\n+  /// For regular files, the file size in bytes. For\n+  /// symbolic links, the length in bytes of the pathname\n+  /// contained in the symbolic link.\n+  pub st_size: filesize,\n+  /// Last data access timestamp.\n+  pub st_atim: timestamp,\n+  /// Last data modification timestamp.\n+  pub st_mtim: timestamp,\n+  /// Last file status change timestamp.\n+  pub st_ctim: timestamp,\n+}\n+#[test]\n+fn filestat_layout_test() {\n+  assert_eq!(::core::mem::size_of::<filestat>(), 56);\n+  assert_eq!(::core::mem::align_of::<filestat>(), 8);\n+  unsafe {\n+    let obj: filestat = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.st_dev as *const _ as usize - base, 0);\n+    assert_eq!(&obj.st_ino as *const _ as usize - base, 8);\n+    assert_eq!(&obj.st_filetype as *const _ as usize - base, 16);\n+    assert_eq!(&obj.st_nlink as *const _ as usize - base, 20);\n+    assert_eq!(&obj.st_size as *const _ as usize - base, 24);\n+    assert_eq!(&obj.st_atim as *const _ as usize - base, 32);\n+    assert_eq!(&obj.st_mtim as *const _ as usize - base, 40);\n+    assert_eq!(&obj.st_ctim as *const _ as usize - base, 48);\n+  }\n+}\n+\n+/// A region of memory for scatter/gather reads.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct iovec {\n+  /// The address and length of the buffer to be filled.\n+  pub buf: (*mut (), usize),\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn iovec_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<iovec>(), 8);\n+  assert_eq!(::core::mem::align_of::<iovec>(), 4);\n+  unsafe {\n+    let obj: iovec = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.buf.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.buf.1 as *const _ as usize - base, 4);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn iovec_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<iovec>(), 16);\n+  assert_eq!(::core::mem::align_of::<iovec>(), 8);\n+  unsafe {\n+    let obj: iovec = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.buf.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.buf.1 as *const _ as usize - base, 8);\n+  }\n+}\n+\n+/// Path lookup properties.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct lookup {\n+  /// The working directory at which the resolution of the\n+  /// path starts.\n+  pub fd: fd,\n+  /// Flags determining the method of how the path is\n+  /// resolved.\n+  pub flags: lookupflags,\n+}\n+#[test]\n+fn lookup_layout_test() {\n+  assert_eq!(::core::mem::size_of::<lookup>(), 8);\n+  assert_eq!(::core::mem::align_of::<lookup>(), 4);\n+  unsafe {\n+    let obj: lookup = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.fd as *const _ as usize - base, 0);\n+    assert_eq!(&obj.flags as *const _ as usize - base, 4);\n+  }\n+}\n+\n+/// Entry point for a process (`_start`).\n+///\n+/// **auxv**:\n+/// The auxiliary vector. See [`auxv`](struct.auxv.html).\n+pub type processentry = unsafe extern \"C\" fn(\n+  auxv: *const auxv,\n+) -> ();\n+\n+/// Arguments of [`sock_recv()`](fn.sock_recv.html).\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct recv_in {\n+  /// List of scatter/gather vectors where message data\n+  /// should be stored.\n+  pub ri_data: (*const iovec, usize),\n+  /// Buffer where numbers of incoming file descriptors\n+  /// should be stored.\n+  pub ri_fds: (*mut fd, usize),\n+  /// Message flags.\n+  pub ri_flags: riflags,\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn recv_in_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<recv_in>(), 20);\n+  assert_eq!(::core::mem::align_of::<recv_in>(), 4);\n+  unsafe {\n+    let obj: recv_in = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.ri_data.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.ri_data.1 as *const _ as usize - base, 4);\n+    assert_eq!(&obj.ri_fds.0 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.ri_fds.1 as *const _ as usize - base, 12);\n+    assert_eq!(&obj.ri_flags as *const _ as usize - base, 16);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn recv_in_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<recv_in>(), 40);\n+  assert_eq!(::core::mem::align_of::<recv_in>(), 8);\n+  unsafe {\n+    let obj: recv_in = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.ri_data.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.ri_data.1 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.ri_fds.0 as *const _ as usize - base, 16);\n+    assert_eq!(&obj.ri_fds.1 as *const _ as usize - base, 24);\n+    assert_eq!(&obj.ri_flags as *const _ as usize - base, 32);\n+  }\n+}\n+\n+/// Results of [`sock_recv()`](fn.sock_recv.html).\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct recv_out {\n+  /// Number of bytes stored in [`recv_in.ri_data`](struct.recv_in.html#structfield.ri_data).\n+  pub ro_datalen: usize,\n+  /// Number of file descriptors stored in [`recv_in.ri_fds`](struct.recv_in.html#structfield.ri_fds).\n+  pub ro_fdslen: usize,\n+  /// Fields that were used by previous implementations.\n+  pub ro_unused: [u8; 40],\n+  /// Message flags.\n+  pub ro_flags: roflags,\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn recv_out_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<recv_out>(), 52);\n+  assert_eq!(::core::mem::align_of::<recv_out>(), 4);\n+  unsafe {\n+    let obj: recv_out = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.ro_datalen as *const _ as usize - base, 0);\n+    assert_eq!(&obj.ro_fdslen as *const _ as usize - base, 4);\n+    assert_eq!(&obj.ro_unused as *const _ as usize - base, 8);\n+    assert_eq!(&obj.ro_flags as *const _ as usize - base, 48);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn recv_out_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<recv_out>(), 64);\n+  assert_eq!(::core::mem::align_of::<recv_out>(), 8);\n+  unsafe {\n+    let obj: recv_out = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.ro_datalen as *const _ as usize - base, 0);\n+    assert_eq!(&obj.ro_fdslen as *const _ as usize - base, 8);\n+    assert_eq!(&obj.ro_unused as *const _ as usize - base, 16);\n+    assert_eq!(&obj.ro_flags as *const _ as usize - base, 56);\n+  }\n+}\n+\n+/// Arguments of [`sock_send()`](fn.sock_send.html).\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct send_in {\n+  /// List of scatter/gather vectors where message data\n+  /// should be retrieved.\n+  pub si_data: (*const ciovec, usize),\n+  /// File descriptors that need to be attached to the\n+  /// message.\n+  pub si_fds: (*const fd, usize),\n+  /// Message flags.\n+  pub si_flags: siflags,\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn send_in_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<send_in>(), 20);\n+  assert_eq!(::core::mem::align_of::<send_in>(), 4);\n+  unsafe {\n+    let obj: send_in = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.si_data.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.si_data.1 as *const _ as usize - base, 4);\n+    assert_eq!(&obj.si_fds.0 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.si_fds.1 as *const _ as usize - base, 12);\n+    assert_eq!(&obj.si_flags as *const _ as usize - base, 16);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn send_in_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<send_in>(), 40);\n+  assert_eq!(::core::mem::align_of::<send_in>(), 8);\n+  unsafe {\n+    let obj: send_in = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.si_data.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.si_data.1 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.si_fds.0 as *const _ as usize - base, 16);\n+    assert_eq!(&obj.si_fds.1 as *const _ as usize - base, 24);\n+    assert_eq!(&obj.si_flags as *const _ as usize - base, 32);\n+  }\n+}\n+\n+/// Results of [`sock_send()`](fn.sock_send.html).\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct send_out {\n+  /// Number of bytes transmitted.\n+  pub so_datalen: usize,\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn send_out_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<send_out>(), 4);\n+  assert_eq!(::core::mem::align_of::<send_out>(), 4);\n+  unsafe {\n+    let obj: send_out = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.so_datalen as *const _ as usize - base, 0);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn send_out_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<send_out>(), 8);\n+  assert_eq!(::core::mem::align_of::<send_out>(), 8);\n+  unsafe {\n+    let obj: send_out = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.so_datalen as *const _ as usize - base, 0);\n+  }\n+}\n+\n+/// Subscription to an event.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription {\n+  /// User-provided value that is attached to the\n+  /// subscription in the kernel and returned through\n+  /// [`event.userdata`](struct.event.html#structfield.userdata).\n+  pub userdata: userdata,\n+  /// Used by previous implementations. Ignored.\n+  pub unused: u16,\n+  /// The type of the event to which to subscribe.\n+  ///\n+  /// Currently, [`CONDVAR`](enum.eventtype.html#variant.CONDVAR),\n+  /// [`LOCK_RDLOCK`](enum.eventtype.html#variant.LOCK_RDLOCK), and [`LOCK_WRLOCK`](enum.eventtype.html#variant.LOCK_WRLOCK)\n+  /// must be provided as the first subscription and may\n+  /// only be followed by up to one other subscription,\n+  /// having type [`CLOCK`](enum.eventtype.html#variant.CLOCK).\n+  pub type_: eventtype,\n+  pub union: subscription_union\n+}\n+/// A union inside `subscription`.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub union subscription_union {\n+  /// Used when `type_` is [`CLOCK`](enum.eventtype.html#variant.CLOCK).\n+  pub clock: subscription_clock,\n+  /// Used when `type_` is [`CONDVAR`](enum.eventtype.html#variant.CONDVAR).\n+  pub condvar: subscription_condvar,\n+  /// Used when `type_` is [`FD_READ`](enum.eventtype.html#variant.FD_READ) or [`FD_WRITE`](enum.eventtype.html#variant.FD_WRITE).\n+  pub fd_readwrite: subscription_fd_readwrite,\n+  /// Used when `type_` is [`LOCK_RDLOCK`](enum.eventtype.html#variant.LOCK_RDLOCK) or [`LOCK_WRLOCK`](enum.eventtype.html#variant.LOCK_WRLOCK).\n+  pub lock: subscription_lock,\n+  /// Used when `type_` is [`PROC_TERMINATE`](enum.eventtype.html#variant.PROC_TERMINATE).\n+  pub proc_terminate: subscription_proc_terminate,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription_clock {\n+  /// The user-defined unique\n+  /// identifier of the clock.\n+  pub identifier: userdata,\n+  /// The clock against which the\n+  /// timestamp should be compared.\n+  pub clock_id: clockid,\n+  /// The absolute or relative\n+  /// timestamp.\n+  pub timeout: timestamp,\n+  /// The amount of time that the\n+  /// kernel may wait additionally\n+  /// to coalesce with other events.\n+  pub precision: timestamp,\n+  /// Flags specifying whether the\n+  /// timeout is absolute or\n+  /// relative.\n+  pub flags: subclockflags,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription_condvar {\n+  /// The condition variable on\n+  /// which to wait to be woken up.\n+  pub condvar: *mut condvar,\n+  /// The lock that will be\n+  /// released while waiting.\n+  ///\n+  /// The lock will be reacquired\n+  /// for writing when the condition\n+  /// variable triggers.\n+  pub lock: *mut lock,\n+  /// Whether the condition variable\n+  /// is stored in private or shared\n+  /// memory.\n+  pub condvar_scope: scope,\n+  /// Whether the lock is stored in\n+  /// private or shared memory.\n+  pub lock_scope: scope,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription_fd_readwrite {\n+  /// The file descriptor on which\n+  /// to wait for it to become ready\n+  /// for reading or writing.\n+  pub fd: fd,\n+  /// Under which conditions to\n+  /// trigger.\n+  pub flags: subrwflags,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription_lock {\n+  /// The lock that will be acquired\n+  /// for reading or writing.\n+  pub lock: *mut lock,\n+  /// Whether the lock is stored in\n+  /// private or shared memory.\n+  pub lock_scope: scope,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription_proc_terminate {\n+  /// The process descriptor on\n+  /// which to wait for process\n+  /// termination.\n+  pub fd: fd,\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn subscription_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<subscription>(), 56);\n+  assert_eq!(::core::mem::align_of::<subscription>(), 8);\n+  unsafe {\n+    let obj: subscription = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.userdata as *const _ as usize - base, 0);\n+    assert_eq!(&obj.unused as *const _ as usize - base, 8);\n+    assert_eq!(&obj.type_ as *const _ as usize - base, 10);\n+    assert_eq!(&obj.union.clock.identifier as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.clock.clock_id as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.clock.timeout as *const _ as usize - base, 32);\n+    assert_eq!(&obj.union.clock.precision as *const _ as usize - base, 40);\n+    assert_eq!(&obj.union.clock.flags as *const _ as usize - base, 48);\n+    assert_eq!(&obj.union.condvar.condvar as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.condvar.lock as *const _ as usize - base, 20);\n+    assert_eq!(&obj.union.condvar.condvar_scope as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.condvar.lock_scope as *const _ as usize - base, 25);\n+    assert_eq!(&obj.union.fd_readwrite.fd as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.fd_readwrite.flags as *const _ as usize - base, 20);\n+    assert_eq!(&obj.union.lock.lock as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.lock.lock_scope as *const _ as usize - base, 20);\n+    assert_eq!(&obj.union.proc_terminate.fd as *const _ as usize - base, 16);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn subscription_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<subscription>(), 56);\n+  assert_eq!(::core::mem::align_of::<subscription>(), 8);\n+  unsafe {\n+    let obj: subscription = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.userdata as *const _ as usize - base, 0);\n+    assert_eq!(&obj.unused as *const _ as usize - base, 8);\n+    assert_eq!(&obj.type_ as *const _ as usize - base, 10);\n+    assert_eq!(&obj.union.clock.identifier as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.clock.clock_id as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.clock.timeout as *const _ as usize - base, 32);\n+    assert_eq!(&obj.union.clock.precision as *const _ as usize - base, 40);\n+    assert_eq!(&obj.union.clock.flags as *const _ as usize - base, 48);\n+    assert_eq!(&obj.union.condvar.condvar as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.condvar.lock as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.condvar.condvar_scope as *const _ as usize - base, 32);\n+    assert_eq!(&obj.union.condvar.lock_scope as *const _ as usize - base, 33);\n+    assert_eq!(&obj.union.fd_readwrite.fd as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.fd_readwrite.flags as *const _ as usize - base, 20);\n+    assert_eq!(&obj.union.lock.lock as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.lock.lock_scope as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.proc_terminate.fd as *const _ as usize - base, 16);\n+  }\n+}\n+\n+/// The Thread Control Block (TCB).\n+///\n+/// After a thread begins execution (at program startup or when\n+/// created through [`thread_create()`](fn.thread_create.html)), the CPU's registers\n+/// controlling Thread-Local Storage (TLS) will already be\n+/// initialized. They will point to an area only containing the\n+/// TCB.\n+///\n+/// If the thread needs space for storing thread-specific\n+/// variables, the thread may allocate a larger area and adjust\n+/// the CPU's registers to point to that area instead. However, it\n+/// does need to make sure that the TCB is copied over to the new\n+/// TLS area.\n+///\n+/// The purpose of the TCB is that it allows light-weight\n+/// emulators to store information related to individual threads.\n+/// For example, it may be used to store a copy of the CPU\n+/// registers prior emulation, so that TLS for the host system\n+/// can be restored if needed.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct tcb {\n+  /// Pointer that may be freely assigned by the system. Its\n+  /// value cannot be interpreted by the application.\n+  pub parent: *mut (),\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn tcb_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<tcb>(), 4);\n+  assert_eq!(::core::mem::align_of::<tcb>(), 4);\n+  unsafe {\n+    let obj: tcb = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.parent as *const _ as usize - base, 0);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn tcb_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<tcb>(), 8);\n+  assert_eq!(::core::mem::align_of::<tcb>(), 8);\n+  unsafe {\n+    let obj: tcb = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.parent as *const _ as usize - base, 0);\n+  }\n+}\n+\n+/// Entry point for additionally created threads.\n+///\n+/// **tid**:\n+/// Thread ID of the current thread.\n+///\n+/// **aux**:\n+/// Copy of the value stored in\n+/// [`threadattr.argument`](struct.threadattr.html#structfield.argument).\n+pub type threadentry = unsafe extern \"C\" fn(\n+  tid: tid,\n+  aux: *mut (),\n+) -> ();\n+\n+/// Attributes for thread creation.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct threadattr {\n+  /// Initial program counter value.\n+  pub entry_point: threadentry,\n+  /// Region allocated to serve as stack space.\n+  pub stack: (*mut (), usize),\n+  /// Argument to be forwarded to the entry point function.\n+  pub argument: *mut (),\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn threadattr_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<threadattr>(), 16);\n+  assert_eq!(::core::mem::align_of::<threadattr>(), 4);\n+  unsafe {\n+    let obj: threadattr = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.entry_point as *const _ as usize - base, 0);\n+    assert_eq!(&obj.stack.0 as *const _ as usize - base, 4);\n+    assert_eq!(&obj.stack.1 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.argument as *const _ as usize - base, 12);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn threadattr_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<threadattr>(), 32);\n+  assert_eq!(::core::mem::align_of::<threadattr>(), 8);\n+  unsafe {\n+    let obj: threadattr = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.entry_point as *const _ as usize - base, 0);\n+    assert_eq!(&obj.stack.0 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.stack.1 as *const _ as usize - base, 16);\n+    assert_eq!(&obj.argument as *const _ as usize - base, 24);\n+  }\n+}\n+\n+/// The table with pointers to all syscall implementations.\n+#[allow(improper_ctypes)]\n+extern \"C\" {\n+  fn cloudabi_sys_clock_res_get(_: clockid, _: *mut timestamp) -> errno;\n+  fn cloudabi_sys_clock_time_get(_: clockid, _: timestamp, _: *mut timestamp) -> errno;\n+  fn cloudabi_sys_condvar_signal(_: *mut condvar, _: scope, _: nthreads) -> errno;\n+  fn cloudabi_sys_fd_close(_: fd) -> errno;\n+  fn cloudabi_sys_fd_create1(_: filetype, _: *mut fd) -> errno;\n+  fn cloudabi_sys_fd_create2(_: filetype, _: *mut fd, _: *mut fd) -> errno;\n+  fn cloudabi_sys_fd_datasync(_: fd) -> errno;\n+  fn cloudabi_sys_fd_dup(_: fd, _: *mut fd) -> errno;\n+  fn cloudabi_sys_fd_pread(_: fd, _: *const iovec, _: usize, _: filesize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_fd_pwrite(_: fd, _: *const ciovec, _: usize, _: filesize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_fd_read(_: fd, _: *const iovec, _: usize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_fd_replace(_: fd, _: fd) -> errno;\n+  fn cloudabi_sys_fd_seek(_: fd, _: filedelta, _: whence, _: *mut filesize) -> errno;\n+  fn cloudabi_sys_fd_stat_get(_: fd, _: *mut fdstat) -> errno;\n+  fn cloudabi_sys_fd_stat_put(_: fd, _: *const fdstat, _: fdsflags) -> errno;\n+  fn cloudabi_sys_fd_sync(_: fd) -> errno;\n+  fn cloudabi_sys_fd_write(_: fd, _: *const ciovec, _: usize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_file_advise(_: fd, _: filesize, _: filesize, _: advice) -> errno;\n+  fn cloudabi_sys_file_allocate(_: fd, _: filesize, _: filesize) -> errno;\n+  fn cloudabi_sys_file_create(_: fd, _: *const u8, _: usize, _: filetype) -> errno;\n+  fn cloudabi_sys_file_link(_: lookup, _: *const u8, _: usize, _: fd, _: *const u8, _: usize) -> errno;\n+  fn cloudabi_sys_file_open(_: lookup, _: *const u8, _: usize, _: oflags, _: *const fdstat, _: *mut fd) -> errno;\n+  fn cloudabi_sys_file_readdir(_: fd, _: *mut (), _: usize, _: dircookie, _: *mut usize) -> errno;\n+  fn cloudabi_sys_file_readlink(_: fd, _: *const u8, _: usize, _: *mut u8, _: usize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_file_rename(_: fd, _: *const u8, _: usize, _: fd, _: *const u8, _: usize) -> errno;\n+  fn cloudabi_sys_file_stat_fget(_: fd, _: *mut filestat) -> errno;\n+  fn cloudabi_sys_file_stat_fput(_: fd, _: *const filestat, _: fsflags) -> errno;\n+  fn cloudabi_sys_file_stat_get(_: lookup, _: *const u8, _: usize, _: *mut filestat) -> errno;\n+  fn cloudabi_sys_file_stat_put(_: lookup, _: *const u8, _: usize, _: *const filestat, _: fsflags) -> errno;\n+  fn cloudabi_sys_file_symlink(_: *const u8, _: usize, _: fd, _: *const u8, _: usize) -> errno;\n+  fn cloudabi_sys_file_unlink(_: fd, _: *const u8, _: usize, _: ulflags) -> errno;\n+  fn cloudabi_sys_lock_unlock(_: *mut lock, _: scope) -> errno;\n+  fn cloudabi_sys_mem_advise(_: *mut (), _: usize, _: advice) -> errno;\n+  fn cloudabi_sys_mem_map(_: *mut (), _: usize, _: mprot, _: mflags, _: fd, _: filesize, _: *mut *mut ()) -> errno;\n+  fn cloudabi_sys_mem_protect(_: *mut (), _: usize, _: mprot) -> errno;\n+  fn cloudabi_sys_mem_sync(_: *mut (), _: usize, _: msflags) -> errno;\n+  fn cloudabi_sys_mem_unmap(_: *mut (), _: usize) -> errno;\n+  fn cloudabi_sys_poll(_: *const subscription, _: *mut event, _: usize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_proc_exec(_: fd, _: *const (), _: usize, _: *const fd, _: usize) -> errno;\n+  fn cloudabi_sys_proc_exit(_: exitcode) -> !;\n+  fn cloudabi_sys_proc_fork(_: *mut fd, _: *mut tid) -> errno;\n+  fn cloudabi_sys_proc_raise(_: signal) -> errno;\n+  fn cloudabi_sys_random_get(_: *mut (), _: usize) -> errno;\n+  fn cloudabi_sys_sock_recv(_: fd, _: *const recv_in, _: *mut recv_out) -> errno;\n+  fn cloudabi_sys_sock_send(_: fd, _: *const send_in, _: *mut send_out) -> errno;\n+  fn cloudabi_sys_sock_shutdown(_: fd, _: sdflags) -> errno;\n+  fn cloudabi_sys_thread_create(_: *mut threadattr, _: *mut tid) -> errno;\n+  fn cloudabi_sys_thread_exit(_: *mut lock, _: scope) -> !;\n+  fn cloudabi_sys_thread_yield() -> errno;\n+}\n+\n+/// Obtains the resolution of a clock.\n+///\n+/// ## Parameters\n+///\n+/// **clock_id**:\n+/// The clock for which the resolution needs to be\n+/// returned.\n+///\n+/// **resolution**:\n+/// The resolution of the clock.\n+#[inline]\n+pub unsafe fn clock_res_get(clock_id_: clockid, resolution_: &mut timestamp) -> errno {\n+  cloudabi_sys_clock_res_get(clock_id_, resolution_)\n+}\n+\n+/// Obtains the time value of a clock.\n+///\n+/// ## Parameters\n+///\n+/// **clock_id**:\n+/// The clock for which the time needs to be\n+/// returned.\n+///\n+/// **precision**:\n+/// The maximum lag (exclusive) that the returned\n+/// time value may have, compared to its actual\n+/// value.\n+///\n+/// **time**:\n+/// The time value of the clock.\n+#[inline]\n+pub unsafe fn clock_time_get(clock_id_: clockid, precision_: timestamp, time_: &mut timestamp) -> errno {\n+  cloudabi_sys_clock_time_get(clock_id_, precision_, time_)\n+}\n+\n+/// Wakes up threads waiting on a userspace condition variable.\n+///\n+/// If an invocation of this system call causes all waiting\n+/// threads to be woken up, the value of the condition variable\n+/// is set to [`CONDVAR_HAS_NO_WAITERS`](constant.CONDVAR_HAS_NO_WAITERS.html). As long as the condition\n+/// variable is set to this value, it is not needed to invoke this\n+/// system call.\n+///\n+/// ## Parameters\n+///\n+/// **condvar**:\n+/// The userspace condition variable that has\n+/// waiting threads.\n+///\n+/// **scope**:\n+/// Whether the condition variable is stored in\n+/// private or shared memory.\n+///\n+/// **nwaiters**:\n+/// The number of threads that need to be woken\n+/// up. If it exceeds the number of waiting\n+/// threads, all threads are woken up.\n+#[inline]\n+pub unsafe fn condvar_signal(condvar_: *mut condvar, scope_: scope, nwaiters_: nthreads) -> errno {\n+  cloudabi_sys_condvar_signal(condvar_, scope_, nwaiters_)\n+}\n+\n+/// Closes a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor that needs to be closed.\n+#[inline]\n+pub unsafe fn fd_close(fd_: fd) -> errno {\n+  cloudabi_sys_fd_close(fd_)\n+}\n+\n+/// Creates a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **type**:\n+/// Possible values:\n+///\n+///   - [`SHARED_MEMORY`](enum.filetype.html#variant.SHARED_MEMORY):\n+///     Creates an anonymous shared memory\n+///     object.\n+///\n+/// **fd**:\n+/// The file descriptor that has been created.\n+#[inline]\n+pub unsafe fn fd_create1(type_: filetype, fd_: &mut fd) -> errno {\n+  cloudabi_sys_fd_create1(type_, fd_)\n+}\n+\n+/// Creates a pair of file descriptors.\n+///\n+/// ## Parameters\n+///\n+/// **type**:\n+/// Possible values:\n+///\n+///   - [`SOCKET_DGRAM`](enum.filetype.html#variant.SOCKET_DGRAM):\n+///     Creates a UNIX datagram socket pair.\n+///   - [`SOCKET_STREAM`](enum.filetype.html#variant.SOCKET_STREAM):\n+///     Creates a UNIX byte-stream socket\n+///     pair.\n+///\n+/// **fd1**:\n+/// The first file descriptor of the pair.\n+///\n+/// **fd2**:\n+/// The second file descriptor of the pair.\n+#[inline]\n+pub unsafe fn fd_create2(type_: filetype, fd1_: &mut fd, fd2_: &mut fd) -> errno {\n+  cloudabi_sys_fd_create2(type_, fd1_, fd2_)\n+}\n+\n+/// Synchronizes the data of a file to disk.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor of the file whose data\n+/// needs to be synchronized to disk.\n+#[inline]\n+pub unsafe fn fd_datasync(fd_: fd) -> errno {\n+  cloudabi_sys_fd_datasync(fd_)\n+}\n+\n+/// Duplicates a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **from**:\n+/// The file descriptor that needs to be\n+/// duplicated.\n+///\n+/// **fd**:\n+/// The new file descriptor.\n+#[inline]\n+pub unsafe fn fd_dup(from_: fd, fd_: &mut fd) -> errno {\n+  cloudabi_sys_fd_dup(from_, fd_)\n+}\n+\n+/// Reads from a file descriptor, without using and updating the\n+/// file descriptor's offset.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor from which data should be\n+/// read.\n+///\n+/// **iovs**:\n+/// List of scatter/gather vectors where data\n+/// should be stored.\n+///\n+/// **offset**:\n+/// The offset within the file at which reading\n+/// should start.\n+///\n+/// **nread**:\n+/// The number of bytes read.\n+#[inline]\n+pub unsafe fn fd_pread(fd_: fd, iovs_: &[iovec], offset_: filesize, nread_: &mut usize) -> errno {\n+  cloudabi_sys_fd_pread(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nread_)\n+}\n+\n+/// Writes to a file descriptor, without using and updating the\n+/// file descriptor's offset.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor to which data should be\n+/// written.\n+///\n+/// **iovs**:\n+/// List of scatter/gather vectors where data\n+/// should be retrieved.\n+///\n+/// **offset**:\n+/// The offset within the file at which writing\n+/// should start.\n+///\n+/// **nwritten**:\n+/// The number of bytes written.\n+#[inline]\n+pub unsafe fn fd_pwrite(fd_: fd, iovs_: &[ciovec], offset_: filesize, nwritten_: &mut usize) -> errno {\n+  cloudabi_sys_fd_pwrite(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nwritten_)\n+}\n+\n+/// Reads from a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor from which data should be\n+/// read.\n+///\n+/// **iovs**:\n+/// List of scatter/gather vectors where data\n+/// should be stored.\n+///\n+/// **nread**:\n+/// The number of bytes read.\n+#[inline]\n+pub unsafe fn fd_read(fd_: fd, iovs_: &[iovec], nread_: &mut usize) -> errno {\n+  cloudabi_sys_fd_read(fd_, iovs_.as_ptr(), iovs_.len(), nread_)\n+}\n+\n+/// Atomically replaces a file descriptor by a copy of another\n+/// file descriptor.\n+///\n+/// Due to the strong focus on thread safety, this environment\n+/// does not provide a mechanism to duplicate a file descriptor to\n+/// an arbitrary number, like dup2(). This would be prone to race\n+/// conditions, as an actual file descriptor with the same number\n+/// could be allocated by a different thread at the same time.\n+///\n+/// This system call provides a way to atomically replace file\n+/// descriptors, which would disappear if dup2() were to be\n+/// removed entirely.\n+///\n+/// ## Parameters\n+///\n+/// **from**:\n+/// The file descriptor that needs to be copied.\n+///\n+/// **to**:\n+/// The file descriptor that needs to be\n+/// overwritten.\n+#[inline]\n+pub unsafe fn fd_replace(from_: fd, to_: fd) -> errno {\n+  cloudabi_sys_fd_replace(from_, to_)\n+}\n+\n+/// Moves the offset of the file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor whose offset has to be\n+/// moved.\n+///\n+/// **offset**:\n+/// The number of bytes to move.\n+///\n+/// **whence**:\n+/// Relative to which position the move should\n+/// take place.\n+///\n+/// **newoffset**:\n+/// The new offset of the file descriptor,\n+/// relative to the start of the file.\n+#[inline]\n+pub unsafe fn fd_seek(fd_: fd, offset_: filedelta, whence_: whence, newoffset_: &mut filesize) -> errno {\n+  cloudabi_sys_fd_seek(fd_, offset_, whence_, newoffset_)\n+}\n+\n+/// Gets attributes of a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor whose attributes have to\n+/// be obtained.\n+///\n+/// **buf**:\n+/// The buffer where the file descriptor's\n+/// attributes are stored.\n+#[inline]\n+pub unsafe fn fd_stat_get(fd_: fd, buf_: *mut fdstat) -> errno {\n+  cloudabi_sys_fd_stat_get(fd_, buf_)\n+}\n+\n+/// Adjusts attributes of a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor whose attributes have to\n+/// be adjusted.\n+///\n+/// **buf**:\n+/// The desired values of the file descriptor\n+/// attributes that are adjusted.\n+///\n+/// **flags**:\n+/// A bitmask indicating which attributes have to\n+/// be adjusted.\n+#[inline]\n+pub unsafe fn fd_stat_put(fd_: fd, buf_: *const fdstat, flags_: fdsflags) -> errno {\n+  cloudabi_sys_fd_stat_put(fd_, buf_, flags_)\n+}\n+\n+/// Synchronizes the data and metadata of a file to disk.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor of the file whose data\n+/// and metadata needs to be synchronized to disk.\n+#[inline]\n+pub unsafe fn fd_sync(fd_: fd) -> errno {\n+  cloudabi_sys_fd_sync(fd_)\n+}\n+\n+/// Writes to a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor to which data should be\n+/// written.\n+///\n+/// **iovs**:\n+/// List of scatter/gather vectors where data\n+/// should be retrieved.\n+///\n+/// **nwritten**:\n+/// The number of bytes written.\n+#[inline]\n+pub unsafe fn fd_write(fd_: fd, iovs_: &[ciovec], nwritten_: &mut usize) -> errno {\n+  cloudabi_sys_fd_write(fd_, iovs_.as_ptr(), iovs_.len(), nwritten_)\n+}\n+\n+/// Provides file advisory information on a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor for which to provide file\n+/// advisory information.\n+///\n+/// **offset**:\n+/// The offset within the file to which the\n+/// advisory applies.\n+///\n+/// **len**:\n+/// The length of the region to which the advisory\n+/// applies.\n+///\n+/// **advice**:\n+/// The advice.\n+#[inline]\n+pub unsafe fn file_advise(fd_: fd, offset_: filesize, len_: filesize, advice_: advice) -> errno {\n+  cloudabi_sys_file_advise(fd_, offset_, len_, advice_)\n+}\n+\n+/// Forces the allocation of space in a file.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file in which the space should be\n+/// allocated.\n+///\n+/// **offset**:\n+/// The offset at which the allocation should\n+/// start.\n+///\n+/// **len**:\n+/// The length of the area that is allocated.\n+#[inline]\n+pub unsafe fn file_allocate(fd_: fd, offset_: filesize, len_: filesize) -> errno {\n+  cloudabi_sys_file_allocate(fd_, offset_, len_)\n+}\n+\n+/// Creates a file of a specified type.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the file to be created starts.\n+///\n+/// **path**:\n+/// The path at which the file should be created.\n+///\n+/// **type**:\n+/// Possible values:\n+///\n+///   - [`DIRECTORY`](enum.filetype.html#variant.DIRECTORY):\n+///     Creates a directory.\n+#[inline]\n+pub unsafe fn file_create(fd_: fd, path_: &[u8], type_: filetype) -> errno {\n+  cloudabi_sys_file_create(fd_, path_.as_ptr(), path_.len(), type_)\n+}\n+\n+/// Creates a hard link.\n+///\n+/// ## Parameters\n+///\n+/// **fd1**:\n+/// The working directory at which the resolution\n+/// of the source path starts.\n+///\n+/// **path1**:\n+/// The source path of the file that should be\n+/// hard linked.\n+///\n+/// **fd2**:\n+/// The working directory at which the resolution\n+/// of the destination path starts.\n+///\n+/// **path2**:\n+/// The destination path at which the hard link\n+/// should be created.\n+#[inline]\n+pub unsafe fn file_link(fd1_: lookup, path1_: &[u8], fd2_: fd, path2_: &[u8]) -> errno {\n+  cloudabi_sys_file_link(fd1_, path1_.as_ptr(), path1_.len(), fd2_, path2_.as_ptr(), path2_.len())\n+}\n+\n+/// Opens a file.\n+///\n+/// ## Parameters\n+///\n+/// **dirfd**:\n+/// The working directory at which the resolution\n+/// of the file to be opened starts.\n+///\n+/// **path**:\n+/// The path of the file that should be opened.\n+///\n+/// **oflags**:\n+/// The method at which the file should be opened.\n+///\n+/// **fds**:\n+/// [`fdstat.fs_rights_base`](struct.fdstat.html#structfield.fs_rights_base) and\n+/// [`fdstat.fs_rights_inheriting`](struct.fdstat.html#structfield.fs_rights_inheriting) specify the\n+/// initial rights of the newly created file\n+/// descriptor. The operating system is allowed to\n+/// return a file descriptor with fewer rights\n+/// than specified, if and only if those rights do\n+/// not apply to the type of file being opened.\n+///\n+/// [`fdstat.fs_flags`](struct.fdstat.html#structfield.fs_flags) specifies the initial flags\n+/// of the file descriptor.\n+///\n+/// [`fdstat.fs_filetype`](struct.fdstat.html#structfield.fs_filetype) is ignored.\n+///\n+/// **fd**:\n+/// The file descriptor of the file that has been\n+/// opened.\n+#[inline]\n+pub unsafe fn file_open(dirfd_: lookup, path_: &[u8], oflags_: oflags, fds_: *const fdstat, fd_: &mut fd) -> errno {\n+  cloudabi_sys_file_open(dirfd_, path_.as_ptr(), path_.len(), oflags_, fds_, fd_)\n+}\n+\n+/// Reads directory entries from a directory.\n+///\n+/// When successful, the contents of the output buffer consist of\n+/// a sequence of directory entries. Each directory entry consists\n+/// of a [`dirent`](struct.dirent.html) object, followed by [`dirent.d_namlen`](struct.dirent.html#structfield.d_namlen) bytes\n+/// holding the name of the directory entry.\n+///\n+/// This system call fills the output buffer as much as possible,\n+/// potentially truncating the last directory entry. This allows\n+/// the caller to grow its read buffer size in case it's too small\n+/// to fit a single large directory entry, or skip the oversized\n+/// directory entry.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The directory from which to read the directory\n+/// entries.\n+///\n+/// **buf**:\n+/// The buffer where directory entries are stored.\n+///\n+/// **cookie**:\n+/// The location within the directory to start\n+/// reading.\n+///\n+/// **bufused**:\n+/// The number of bytes stored in the read buffer.\n+/// If less than the size of the read buffer, the\n+/// end of the directory has been reached.\n+#[inline]\n+pub unsafe fn file_readdir(fd_: fd, buf_: &mut [u8], cookie_: dircookie, bufused_: &mut usize) -> errno {\n+  cloudabi_sys_file_readdir(fd_, buf_.as_mut_ptr() as *mut (), buf_.len(), cookie_, bufused_)\n+}\n+\n+/// Reads the contents of a symbolic link.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the path of the symbolic starts.\n+///\n+/// **path**:\n+/// The path of the symbolic link whose contents\n+/// should be read.\n+///\n+/// **buf**:\n+/// The buffer where the contents of the symbolic\n+/// link should be stored.\n+///\n+/// **bufused**:\n+/// The number of bytes placed in the buffer.\n+#[inline]\n+pub unsafe fn file_readlink(fd_: fd, path_: &[u8], buf_: &mut [u8], bufused_: &mut usize) -> errno {\n+  cloudabi_sys_file_readlink(fd_, path_.as_ptr(), path_.len(), buf_.as_mut_ptr(), buf_.len(), bufused_)\n+}\n+\n+/// Renames a file.\n+///\n+/// ## Parameters\n+///\n+/// **fd1**:\n+/// The working directory at which the resolution\n+/// of the source path starts.\n+///\n+/// **path1**:\n+/// The source path of the file that should be\n+/// renamed.\n+///\n+/// **fd2**:\n+/// The working directory at which the resolution\n+/// of the destination path starts.\n+///\n+/// **path2**:\n+/// The destination path to which the file should\n+/// be renamed.\n+#[inline]\n+pub unsafe fn file_rename(fd1_: fd, path1_: &[u8], fd2_: fd, path2_: &[u8]) -> errno {\n+  cloudabi_sys_file_rename(fd1_, path1_.as_ptr(), path1_.len(), fd2_, path2_.as_ptr(), path2_.len())\n+}\n+\n+/// Gets attributes of a file by file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor whose attributes have to\n+/// be obtained.\n+///\n+/// **buf**:\n+/// The buffer where the file's attributes are\n+/// stored.\n+#[inline]\n+pub unsafe fn file_stat_fget(fd_: fd, buf_: *mut filestat) -> errno {\n+  cloudabi_sys_file_stat_fget(fd_, buf_)\n+}\n+\n+/// Adjusts attributes of a file by file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor whose attributes have to\n+/// be adjusted.\n+///\n+/// **buf**:\n+/// The desired values of the file attributes that\n+/// are adjusted.\n+///\n+/// **flags**:\n+/// A bitmask indicating which attributes have to\n+/// be adjusted.\n+#[inline]\n+pub unsafe fn file_stat_fput(fd_: fd, buf_: *const filestat, flags_: fsflags) -> errno {\n+  cloudabi_sys_file_stat_fput(fd_, buf_, flags_)\n+}\n+\n+/// Gets attributes of a file by path.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the path whose attributes have to be\n+/// obtained starts.\n+///\n+/// **path**:\n+/// The path of the file whose attributes have to\n+/// be obtained.\n+///\n+/// **buf**:\n+/// The buffer where the file's attributes are\n+/// stored.\n+#[inline]\n+pub unsafe fn file_stat_get(fd_: lookup, path_: &[u8], buf_: *mut filestat) -> errno {\n+  cloudabi_sys_file_stat_get(fd_, path_.as_ptr(), path_.len(), buf_)\n+}\n+\n+/// Adjusts attributes of a file by path.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the path whose attributes have to be\n+/// adjusted starts.\n+///\n+/// **path**:\n+/// The path of the file whose attributes have to\n+/// be adjusted.\n+///\n+/// **buf**:\n+/// The desired values of the file attributes that\n+/// are adjusted.\n+///\n+/// **flags**:\n+/// A bitmask indicating which attributes have to\n+/// be adjusted.\n+#[inline]\n+pub unsafe fn file_stat_put(fd_: lookup, path_: &[u8], buf_: *const filestat, flags_: fsflags) -> errno {\n+  cloudabi_sys_file_stat_put(fd_, path_.as_ptr(), path_.len(), buf_, flags_)\n+}\n+\n+/// Creates a symbolic link.\n+///\n+/// ## Parameters\n+///\n+/// **path1**:\n+/// The contents of the symbolic link.\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the destination path starts.\n+///\n+/// **path2**:\n+/// The destination path at which the symbolic\n+/// link should be created.\n+#[inline]\n+pub unsafe fn file_symlink(path1_: &[u8], fd_: fd, path2_: &[u8]) -> errno {\n+  cloudabi_sys_file_symlink(path1_.as_ptr(), path1_.len(), fd_, path2_.as_ptr(), path2_.len())\n+}\n+\n+/// Unlinks a file, or removes a directory.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the path starts.\n+///\n+/// **path**:\n+/// The path that needs to be unlinked or removed.\n+///\n+/// **flags**:\n+/// Possible values:\n+///\n+///   - [`REMOVEDIR`](struct.ulflags.html#associatedconstant.REMOVEDIR):\n+///     If set, attempt to remove a directory.\n+///     Otherwise, unlink a file.\n+#[inline]\n+pub unsafe fn file_unlink(fd_: fd, path_: &[u8], flags_: ulflags) -> errno {\n+  cloudabi_sys_file_unlink(fd_, path_.as_ptr(), path_.len(), flags_)\n+}\n+\n+/// Unlocks a write-locked userspace lock.\n+///\n+/// If a userspace lock is unlocked while having its\n+/// [`LOCK_KERNEL_MANAGED`](constant.LOCK_KERNEL_MANAGED.html) flag set, the lock cannot be unlocked in\n+/// userspace directly. This system call needs to be performed\n+/// instead, so that any waiting threads can be woken up.\n+///\n+/// To prevent spurious invocations of this system call, the lock\n+/// must be locked for writing. This prevents other threads from\n+/// acquiring additional read locks while the system call is in\n+/// progress. If the lock is acquired for reading, it must first\n+/// be upgraded to a write lock.\n+///\n+/// ## Parameters\n+///\n+/// **lock**:\n+/// The userspace lock that is locked for writing\n+/// by the calling thread.\n+///\n+/// **scope**:\n+/// Whether the lock is stored in private or\n+/// shared memory.\n+#[inline]\n+pub unsafe fn lock_unlock(lock_: *mut lock, scope_: scope) -> errno {\n+  cloudabi_sys_lock_unlock(lock_, scope_)\n+}\n+\n+/// Provides memory advisory information on a region of memory.\n+///\n+/// ## Parameters\n+///\n+/// **mapping**:\n+/// The pages for which to provide memory advisory\n+/// information.\n+///\n+/// **advice**:\n+/// The advice.\n+#[inline]\n+pub unsafe fn mem_advise(mapping_: &mut [u8], advice_: advice) -> errno {\n+  cloudabi_sys_mem_advise(mapping_.as_mut_ptr() as *mut (), mapping_.len(), advice_)\n+}\n+\n+/// Creates a memory mapping, making the contents of a file\n+/// accessible through memory.\n+///\n+/// ## Parameters\n+///\n+/// **addr**:\n+/// If [`FIXED`](struct.mflags.html#associatedconstant.FIXED) is set, specifies to which\n+/// address the file region is mapped. Otherwise,\n+/// the mapping is performed at an unused\n+/// location.\n+///\n+/// **len**:\n+/// The length of the memory mapping to be\n+/// created.\n+///\n+/// **prot**:\n+/// Initial memory protection options for the\n+/// memory mapping.\n+///\n+/// **flags**:\n+/// Memory mapping flags.\n+///\n+/// **fd**:\n+/// If [`ANON`](struct.mflags.html#associatedconstant.ANON) is set, this argument must be\n+/// [`MAP_ANON_FD`](constant.MAP_ANON_FD.html). Otherwise, this argument\n+/// specifies the file whose contents need to be\n+/// mapped.\n+///\n+/// **off**:\n+/// If [`ANON`](struct.mflags.html#associatedconstant.ANON) is set, this argument must be\n+/// zero. Otherwise, this argument specifies the\n+/// offset within the file at which the mapping\n+/// starts.\n+///\n+/// **mem**:\n+/// The starting address of the memory mapping.\n+#[inline]\n+pub unsafe fn mem_map(addr_: *mut (), len_: usize, prot_: mprot, flags_: mflags, fd_: fd, off_: filesize, mem_: &mut *mut ()) -> errno {\n+  cloudabi_sys_mem_map(addr_, len_, prot_, flags_, fd_, off_, mem_)\n+}\n+\n+/// Change the protection of a memory mapping.\n+///\n+/// ## Parameters\n+///\n+/// **mapping**:\n+/// The pages that need their protection changed.\n+///\n+/// **prot**:\n+/// New protection options.\n+#[inline]\n+pub unsafe fn mem_protect(mapping_: &mut [u8], prot_: mprot) -> errno {\n+  cloudabi_sys_mem_protect(mapping_.as_mut_ptr() as *mut (), mapping_.len(), prot_)\n+}\n+\n+/// Synchronize a region of memory with its physical storage.\n+///\n+/// ## Parameters\n+///\n+/// **mapping**:\n+/// The pages that need to be synchronized.\n+///\n+/// **flags**:\n+/// The method of synchronization.\n+#[inline]\n+pub unsafe fn mem_sync(mapping_: &mut [u8], flags_: msflags) -> errno {\n+  cloudabi_sys_mem_sync(mapping_.as_mut_ptr() as *mut (), mapping_.len(), flags_)\n+}\n+\n+/// Unmaps a region of memory.\n+///\n+/// ## Parameters\n+///\n+/// **mapping**:\n+/// The pages that needs to be unmapped.\n+#[inline]\n+pub unsafe fn mem_unmap(mapping_: &mut [u8]) -> errno {\n+  cloudabi_sys_mem_unmap(mapping_.as_mut_ptr() as *mut (), mapping_.len())\n+}\n+\n+/// Concurrently polls for the occurrence of a set of events.\n+///\n+/// ## Parameters\n+///\n+/// **in**:\n+/// The events to which to subscribe.\n+///\n+/// **out**:\n+/// The events that have occurred.\n+///\n+/// **nsubscriptions**:\n+/// Both the number of subscriptions and events.\n+///\n+/// **nevents**:\n+/// The number of events stored.\n+#[inline]\n+pub unsafe fn poll(in_: *const subscription, out_: *mut event, nsubscriptions_: usize, nevents_: &mut usize) -> errno {\n+  cloudabi_sys_poll(in_, out_, nsubscriptions_, nevents_)\n+}\n+\n+/// Replaces the process by a new executable.\n+///\n+/// Process execution in CloudABI differs from POSIX in two ways:\n+/// handling of arguments and inheritance of file descriptors.\n+///\n+/// CloudABI does not use string command line arguments. Instead,\n+/// a buffer with binary data is copied into the address space of\n+/// the new executable. The kernel does not enforce any specific\n+/// structure to this data, although CloudABI's C library uses it\n+/// to store a tree structure that is semantically identical to\n+/// YAML.\n+///\n+/// Due to the strong focus on thread safety, file descriptors\n+/// aren't inherited through close-on-exec flags. An explicit\n+/// list of file descriptors that need to be retained needs to be\n+/// provided. After execution, file descriptors are placed in the\n+/// order in which they are stored in the array. This not only\n+/// makes the execution process deterministic. It also prevents\n+/// potential information disclosures about the layout of the\n+/// original process.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// A file descriptor of the new executable.\n+///\n+/// **data**:\n+/// Binary argument data that is passed on to the\n+/// new executable.\n+///\n+/// **fds**:\n+/// The layout of the file descriptor table after\n+/// execution.\n+#[inline]\n+pub unsafe fn proc_exec(fd_: fd, data_: &[u8], fds_: &[fd]) -> errno {\n+  cloudabi_sys_proc_exec(fd_, data_.as_ptr() as *const (), data_.len(), fds_.as_ptr(), fds_.len())\n+}\n+\n+/// Terminates the process normally.\n+///\n+/// ## Parameters\n+///\n+/// **rval**:\n+/// The exit code returned by the process. The\n+/// exit code can be obtained by other processes\n+/// through [`event.union.proc_terminate.exitcode`](struct.event_proc_terminate.html#structfield.exitcode).\n+#[inline]\n+pub unsafe fn proc_exit(rval_: exitcode) -> ! {\n+  cloudabi_sys_proc_exit(rval_)\n+}\n+\n+/// Forks the process of the calling thread.\n+///\n+/// After forking, a new process shall be created, having only a\n+/// copy of the calling thread. The parent process will obtain a\n+/// process descriptor. When closed, the child process is\n+/// automatically signaled with [`KILL`](enum.signal.html#variant.KILL).\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// In the parent process: the file descriptor\n+/// number of the process descriptor.\n+///\n+/// In the child process: [`PROCESS_CHILD`](constant.PROCESS_CHILD.html).\n+///\n+/// **tid**:\n+/// In the parent process: undefined.\n+///\n+/// In the child process: the thread ID of the\n+/// initial thread of the child process.\n+#[inline]\n+pub unsafe fn proc_fork(fd_: &mut fd, tid_: &mut tid) -> errno {\n+  cloudabi_sys_proc_fork(fd_, tid_)\n+}\n+\n+/// Sends a signal to the process of the calling thread.\n+///\n+/// ## Parameters\n+///\n+/// **sig**:\n+/// The signal condition that should be triggered.\n+/// If the signal causes the process to terminate,\n+/// its condition can be obtained by other\n+/// processes through\n+/// [`event.union.proc_terminate.signal`](struct.event_proc_terminate.html#structfield.signal).\n+#[inline]\n+pub unsafe fn proc_raise(sig_: signal) -> errno {\n+  cloudabi_sys_proc_raise(sig_)\n+}\n+\n+/// Obtains random data from the kernel random number generator.\n+///\n+/// As this interface is not guaranteed to be fast, it is advised\n+/// that the random data obtained through this system call is used\n+/// as the seed for a userspace pseudo-random number generator.\n+///\n+/// ## Parameters\n+///\n+/// **buf**:\n+/// The buffer that needs to be filled with random\n+/// data.\n+#[inline]\n+pub unsafe fn random_get(buf_: &mut [u8]) -> errno {\n+  cloudabi_sys_random_get(buf_.as_mut_ptr() as *mut (), buf_.len())\n+}\n+\n+/// Receives a message on a socket.\n+///\n+/// ## Parameters\n+///\n+/// **sock**:\n+/// The socket on which a message should be\n+/// received.\n+///\n+/// **in**:\n+/// Input parameters.\n+///\n+/// **out**:\n+/// Output parameters.\n+#[inline]\n+pub unsafe fn sock_recv(sock_: fd, in_: *const recv_in, out_: *mut recv_out) -> errno {\n+  cloudabi_sys_sock_recv(sock_, in_, out_)\n+}\n+\n+/// Sends a message on a socket.\n+///\n+/// ## Parameters\n+///\n+/// **sock**:\n+/// The socket on which a message should be sent.\n+///\n+/// **in**:\n+/// Input parameters.\n+///\n+/// **out**:\n+/// Output parameters.\n+#[inline]\n+pub unsafe fn sock_send(sock_: fd, in_: *const send_in, out_: *mut send_out) -> errno {\n+  cloudabi_sys_sock_send(sock_, in_, out_)\n+}\n+\n+/// Shuts down socket send and receive channels.\n+///\n+/// ## Parameters\n+///\n+/// **sock**:\n+/// The socket that needs its channels shut down.\n+///\n+/// **how**:\n+/// Which channels on the socket need to be shut\n+/// down.\n+#[inline]\n+pub unsafe fn sock_shutdown(sock_: fd, how_: sdflags) -> errno {\n+  cloudabi_sys_sock_shutdown(sock_, how_)\n+}\n+\n+/// Creates a new thread within the current process.\n+///\n+/// ## Parameters\n+///\n+/// **attr**:\n+/// The desired attributes of the new thread.\n+///\n+/// **tid**:\n+/// The thread ID of the new thread.\n+#[inline]\n+pub unsafe fn thread_create(attr_: *mut threadattr, tid_: &mut tid) -> errno {\n+  cloudabi_sys_thread_create(attr_, tid_)\n+}\n+\n+/// Terminates the calling thread.\n+///\n+/// This system call can also unlock a single userspace lock\n+/// after termination, which can be used to implement thread\n+/// joining.\n+///\n+/// ## Parameters\n+///\n+/// **lock**:\n+/// Userspace lock that is locked for writing by\n+/// the calling thread.\n+///\n+/// **scope**:\n+/// Whether the lock is stored in private or\n+/// shared memory.\n+#[inline]\n+pub unsafe fn thread_exit(lock_: *mut lock, scope_: scope) -> ! {\n+  cloudabi_sys_thread_exit(lock_, scope_)\n+}\n+\n+/// Temporarily yields execution of the calling thread.\n+#[inline]\n+pub unsafe fn thread_yield() -> errno {\n+  cloudabi_sys_thread_yield()\n+}"}]}