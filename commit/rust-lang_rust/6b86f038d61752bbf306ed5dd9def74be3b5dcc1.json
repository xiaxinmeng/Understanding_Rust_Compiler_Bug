{"sha": "6b86f038d61752bbf306ed5dd9def74be3b5dcc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiODZmMDM4ZDYxNzUyYmJmMzA2ZWQ1ZGQ5ZGVmNzRiZTNiNWRjYzE=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2019-01-07T20:35:18Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T08:46:16Z"}, "message": "refator to move all io to io module\nuse same channel for scanner and watcher\nsome implementations pending", "tree": {"sha": "680b88d8c05f0d15e46c6d3042c3d28c154e8d42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/680b88d8c05f0d15e46c6d3042c3d28c154e8d42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b86f038d61752bbf306ed5dd9def74be3b5dcc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b86f038d61752bbf306ed5dd9def74be3b5dcc1", "html_url": "https://github.com/rust-lang/rust/commit/6b86f038d61752bbf306ed5dd9def74be3b5dcc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b86f038d61752bbf306ed5dd9def74be3b5dcc1/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d032a1a4e8c52f4ea38d9ca24070203a35436158", "url": "https://api.github.com/repos/rust-lang/rust/commits/d032a1a4e8c52f4ea38d9ca24070203a35436158", "html_url": "https://github.com/rust-lang/rust/commit/d032a1a4e8c52f4ea38d9ca24070203a35436158"}], "stats": {"total": 239, "additions": 136, "deletions": 103}, "files": [{"sha": "4f984ebc769e5596ef008ae44815d9e5531ed6f3", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6b86f038d61752bbf306ed5dd9def74be3b5dcc1/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b86f038d61752bbf306ed5dd9def74be3b5dcc1/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=6b86f038d61752bbf306ed5dd9def74be3b5dcc1", "patch": "@@ -113,7 +113,6 @@ enum Event {\n     Msg(RawMessage),\n     Task(Task),\n     Vfs(VfsTask),\n-    Watcher(WatcherChange),\n     Lib(LibraryData),\n }\n \n@@ -150,7 +149,6 @@ impl fmt::Debug for Event {\n             Event::Task(it) => fmt::Debug::fmt(it, f),\n             Event::Vfs(it) => fmt::Debug::fmt(it, f),\n             Event::Lib(it) => fmt::Debug::fmt(it, f),\n-            Event::Watcher(it) => fmt::Debug::fmt(it, f),\n         }\n     }\n }\n@@ -185,10 +183,6 @@ fn main_loop_inner(\n                 Ok(task) => Event::Vfs(task),\n                 Err(RecvError) => bail!(\"vfs died\"),\n             },\n-            recv(state.vfs.read().change_receiver()) -> change => match change {\n-                Ok(change) => Event::Watcher(change),\n-                Err(RecvError) => bail!(\"vfs watcher died\"),\n-            },\n             recv(libdata_receiver) -> data => Event::Lib(data.unwrap())\n         };\n         log::info!(\"loop_turn = {:?}\", event);\n@@ -200,10 +194,6 @@ fn main_loop_inner(\n                 state.vfs.write().handle_task(task);\n                 state_changed = true;\n             }\n-            Event::Watcher(change) => {\n-                state.vfs.write().handle_change(change);\n-                state_changed = true;\n-            }\n             Event::Lib(lib) => {\n                 feedback(internal_mode, \"library loaded\", msg_sender);\n                 state.add_lib(lib);\n@@ -375,7 +365,7 @@ fn on_notification(\n             if let Some(file_id) = state\n                 .vfs\n                 .write()\n-                .add_file_overlay(&path, Some(params.text_document.text))\n+                .add_file_overlay(&path, params.text_document.text)\n             {\n                 subs.add_sub(FileId(file_id.0.into()));\n             }\n@@ -394,10 +384,7 @@ fn on_notification(\n                 .pop()\n                 .ok_or_else(|| format_err!(\"empty changes\"))?\n                 .text;\n-            state\n-                .vfs\n-                .write()\n-                .change_file_overlay(path.as_path(), Some(text));\n+            state.vfs.write().change_file_overlay(path.as_path(), text);\n             return Ok(());\n         }\n         Err(not) => not,"}, {"sha": "79dea5dc72551bccd9f575da7ca2333c99e7a28b", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6b86f038d61752bbf306ed5dd9def74be3b5dcc1/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b86f038d61752bbf306ed5dd9def74be3b5dcc1/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=6b86f038d61752bbf306ed5dd9def74be3b5dcc1", "patch": "@@ -10,17 +10,47 @@ use relative_path::RelativePathBuf;\n \n use crate::{VfsRoot, has_rs_extension};\n \n-pub(crate) struct Task {\n-    pub(crate) root: VfsRoot,\n-    pub(crate) path: PathBuf,\n-    pub(crate) filter: Box<Fn(&DirEntry) -> bool + Send>,\n+pub(crate) enum Task {\n+    AddRoot {\n+        root: VfsRoot,\n+        path: PathBuf,\n+        filter: Box<Fn(&DirEntry) -> bool + Send>,\n+    },\n+    WatcherChange(crate::watcher::WatcherChange),\n }\n \n-pub struct TaskResult {\n+#[derive(Debug)]\n+pub struct AddRootResult {\n     pub(crate) root: VfsRoot,\n     pub(crate) files: Vec<(RelativePathBuf, String)>,\n }\n \n+#[derive(Debug)]\n+pub enum WatcherChangeResult {\n+    Create {\n+        path: PathBuf,\n+        text: String,\n+    },\n+    Write {\n+        path: PathBuf,\n+        text: String,\n+    },\n+    Remove {\n+        path: PathBuf,\n+    },\n+    // can this be replaced and use Remove and Create instead?\n+    Rename {\n+        src: PathBuf,\n+        dst: PathBuf,\n+        text: String,\n+    },\n+}\n+\n+pub enum TaskResult {\n+    AddRoot(AddRootResult),\n+    WatcherChange(WatcherChangeResult),\n+}\n+\n impl fmt::Debug for TaskResult {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(\"TaskResult { ... }\")\n@@ -40,11 +70,18 @@ pub(crate) fn start() -> (Worker, WorkerHandle) {\n }\n \n fn handle_task(task: Task) -> TaskResult {\n-    let Task { root, path, filter } = task;\n-    log::debug!(\"loading {} ...\", path.as_path().display());\n-    let files = load_root(path.as_path(), &*filter);\n-    log::debug!(\"... loaded {}\", path.as_path().display());\n-    TaskResult { root, files }\n+    match task {\n+        Task::AddRoot { root, path, filter } => {\n+            log::debug!(\"loading {} ...\", path.as_path().display());\n+            let files = load_root(path.as_path(), &*filter);\n+            log::debug!(\"... loaded {}\", path.as_path().display());\n+            TaskResult::AddRoot(AddRootResult { root, files })\n+        }\n+        Task::WatcherChange(change) => {\n+            // TODO\n+            unimplemented!()\n+        }\n+    }\n }\n \n fn load_root(root: &Path, filter: &dyn Fn(&DirEntry) -> bool) -> Vec<(RelativePathBuf, String)> {"}, {"sha": "889ed788dd70d93494105581728dc1b40801870d", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 32, "deletions": 49, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6b86f038d61752bbf306ed5dd9def74be3b5dcc1/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b86f038d61752bbf306ed5dd9def74be3b5dcc1/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=6b86f038d61752bbf306ed5dd9def74be3b5dcc1", "patch": "@@ -60,7 +60,7 @@ impl RootFilter {\n     }\n }\n \n-fn has_rs_extension(p: &Path) -> bool {\n+pub(crate) fn has_rs_extension(p: &Path) -> bool {\n     p.extension() == Some(OsStr::new(\"rs\"))\n }\n \n@@ -98,7 +98,7 @@ impl Vfs {\n     pub fn new(mut roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n         let (worker, worker_handle) = io::start();\n \n-        let watcher = Watcher::start().unwrap(); // TODO return Result?\n+        let watcher = Watcher::start(worker.inp.clone()).unwrap(); // TODO return Result?\n \n         let mut res = Vfs {\n             roots: Arena::default(),\n@@ -127,7 +127,7 @@ impl Vfs {\n                     nested.iter().all(|it| it != entry.path())\n                 }\n             };\n-            let task = io::Task {\n+            let task = io::Task::AddRoot {\n                 root,\n                 path: path.clone(),\n                 filter: Box::new(filter),\n@@ -188,58 +188,43 @@ impl Vfs {\n         &self.worker.out\n     }\n \n-    pub fn change_receiver(&self) -> &Receiver<WatcherChange> {\n-        &self.watcher.change_receiver()\n-    }\n-\n     pub fn handle_task(&mut self, task: io::TaskResult) {\n-        let mut files = Vec::new();\n-        // While we were scanning the root in the backgound, a file might have\n-        // been open in the editor, so we need to account for that.\n-        let exising = self.root2files[&task.root]\n-            .iter()\n-            .map(|&file| (self.files[file].path.clone(), file))\n-            .collect::<FxHashMap<_, _>>();\n-        for (path, text) in task.files {\n-            if let Some(&file) = exising.get(&path) {\n-                let text = Arc::clone(&self.files[file].text);\n-                files.push((file, path, text));\n-                continue;\n-            }\n-            let text = Arc::new(text);\n-            let file = self.add_file(task.root, path.clone(), Arc::clone(&text));\n-            files.push((file, path, text));\n-        }\n-\n-        let change = VfsChange::AddRoot {\n-            root: task.root,\n-            files,\n-        };\n-        self.pending_changes.push(change);\n-    }\n+        match task {\n+            io::TaskResult::AddRoot(task) => {\n+                let mut files = Vec::new();\n+                // While we were scanning the root in the backgound, a file might have\n+                // been open in the editor, so we need to account for that.\n+                let exising = self.root2files[&task.root]\n+                    .iter()\n+                    .map(|&file| (self.files[file].path.clone(), file))\n+                    .collect::<FxHashMap<_, _>>();\n+                for (path, text) in task.files {\n+                    if let Some(&file) = exising.get(&path) {\n+                        let text = Arc::clone(&self.files[file].text);\n+                        files.push((file, path, text));\n+                        continue;\n+                    }\n+                    let text = Arc::new(text);\n+                    let file = self.add_file(task.root, path.clone(), Arc::clone(&text));\n+                    files.push((file, path, text));\n+                }\n \n-    pub fn handle_change(&mut self, change: WatcherChange) {\n-        match change {\n-            WatcherChange::Create(path) => {\n-                self.add_file_overlay(&path, None);\n-            }\n-            WatcherChange::Remove(path) => {\n-                self.remove_file_overlay(&path);\n-            }\n-            WatcherChange::Rename(src, dst) => {\n-                self.remove_file_overlay(&src);\n-                self.add_file_overlay(&dst, None);\n+                let change = VfsChange::AddRoot {\n+                    root: task.root,\n+                    files,\n+                };\n+                self.pending_changes.push(change);\n             }\n-            WatcherChange::Write(path) => {\n-                self.change_file_overlay(&path, None);\n+            io::TaskResult::WatcherChange(change) => {\n+                // TODO\n+                unimplemented!()\n             }\n         }\n     }\n \n-    pub fn add_file_overlay(&mut self, path: &Path, text: Option<String>) -> Option<VfsFile> {\n+    pub fn add_file_overlay(&mut self, path: &Path, text: String) -> Option<VfsFile> {\n         let mut res = None;\n         if let Some((root, rel_path, file)) = self.find_root(path) {\n-            let text = text.unwrap_or_else(|| fs::read_to_string(&path).unwrap_or_default());\n             let text = Arc::new(text);\n             let change = if let Some(file) = file {\n                 res = Some(file);\n@@ -260,10 +245,8 @@ impl Vfs {\n         res\n     }\n \n-    pub fn change_file_overlay(&mut self, path: &Path, new_text: Option<String>) {\n+    pub fn change_file_overlay(&mut self, path: &Path, new_text: String) {\n         if let Some((_root, _path, file)) = self.find_root(path) {\n-            let new_text =\n-                new_text.unwrap_or_else(|| fs::read_to_string(&path).unwrap_or_default());\n             let file = file.expect(\"can't change a file which wasn't added\");\n             let text = Arc::new(new_text);\n             self.change_file(file, Arc::clone(&text));"}, {"sha": "a6d0496c03813e1ba4b5c37eb602985024361036", "filename": "crates/ra_vfs/src/watcher.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6b86f038d61752bbf306ed5dd9def74be3b5dcc1/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b86f038d61752bbf306ed5dd9def74be3b5dcc1/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs?ref=6b86f038d61752bbf306ed5dd9def74be3b5dcc1", "patch": "@@ -5,12 +5,12 @@ use std::{\n     time::Duration,\n };\n \n-use crossbeam_channel::Receiver;\n+use crossbeam_channel::Sender;\n use drop_bomb::DropBomb;\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as NotifyWatcher};\n+use crate::{has_rs_extension, io};\n \n pub struct Watcher {\n-    receiver: Receiver<WatcherChange>,\n     watcher: RecommendedWatcher,\n     thread: thread::JoinHandle<()>,\n     bomb: DropBomb,\n@@ -21,24 +21,54 @@ pub enum WatcherChange {\n     Create(PathBuf),\n     Write(PathBuf),\n     Remove(PathBuf),\n+    // can this be replaced and use Remove and Create instead?\n     Rename(PathBuf, PathBuf),\n }\n \n impl WatcherChange {\n-    fn from_debounced_event(ev: DebouncedEvent) -> Option<WatcherChange> {\n+    fn try_from_debounced_event(ev: DebouncedEvent) -> Option<WatcherChange> {\n         match ev {\n             DebouncedEvent::NoticeWrite(_)\n             | DebouncedEvent::NoticeRemove(_)\n-            | DebouncedEvent::Chmod(_)\n-            | DebouncedEvent::Rescan => {\n+            | DebouncedEvent::Chmod(_) => {\n                 // ignore\n                 None\n             }\n-            DebouncedEvent::Create(path) => Some(WatcherChange::Create(path)),\n-            DebouncedEvent::Write(path) => Some(WatcherChange::Write(path)),\n-            DebouncedEvent::Remove(path) => Some(WatcherChange::Remove(path)),\n-            DebouncedEvent::Rename(src, dst) => Some(WatcherChange::Rename(src, dst)),\n+            DebouncedEvent::Rescan => {\n+                // TODO should we rescan the root?\n+                None\n+            }\n+            DebouncedEvent::Create(path) => {\n+                if has_rs_extension(&path) {\n+                    Some(WatcherChange::Create(path))\n+                } else {\n+                    None\n+                }\n+            }\n+            DebouncedEvent::Write(path) => {\n+                if has_rs_extension(&path) {\n+                    Some(WatcherChange::Write(path))\n+                } else {\n+                    None\n+                }\n+            }\n+            DebouncedEvent::Remove(path) => {\n+                if has_rs_extension(&path) {\n+                    Some(WatcherChange::Remove(path))\n+                } else {\n+                    None\n+                }\n+            }\n+            DebouncedEvent::Rename(src, dst) => {\n+                match (has_rs_extension(&src), has_rs_extension(&dst)) {\n+                    (true, true) => Some(WatcherChange::Rename(src, dst)),\n+                    (true, false) => Some(WatcherChange::Remove(src)),\n+                    (false, true) => Some(WatcherChange::Create(dst)),\n+                    (false, false) => None,\n+                }\n+            }\n             DebouncedEvent::Error(err, path) => {\n+                // TODO should we reload the file contents?\n                 log::warn!(\"watch error {}, {:?}\", err, path);\n                 None\n             }\n@@ -47,20 +77,20 @@ impl WatcherChange {\n }\n \n impl Watcher {\n-    pub fn start() -> Result<Watcher, Box<std::error::Error>> {\n+    pub(crate) fn start(\n+        output_sender: Sender<io::Task>,\n+    ) -> Result<Watcher, Box<std::error::Error>> {\n         let (input_sender, input_receiver) = mpsc::channel();\n         let watcher = notify::watcher(input_sender, Duration::from_millis(250))?;\n-        let (output_sender, output_receiver) = crossbeam_channel::unbounded();\n         let thread = thread::spawn(move || {\n             input_receiver\n                 .into_iter()\n                 // forward relevant events only\n-                .filter_map(WatcherChange::from_debounced_event)\n-                .try_for_each(|change| output_sender.send(change))\n+                .filter_map(WatcherChange::try_from_debounced_event)\n+                .try_for_each(|change| output_sender.send(io::Task::WatcherChange(change)))\n                 .unwrap()\n         });\n         Ok(Watcher {\n-            receiver: output_receiver,\n             watcher,\n             thread,\n             bomb: DropBomb::new(format!(\"Watcher was not shutdown\")),\n@@ -72,10 +102,6 @@ impl Watcher {\n         Ok(())\n     }\n \n-    pub fn change_receiver(&self) -> &Receiver<WatcherChange> {\n-        &self.receiver\n-    }\n-\n     pub fn shutdown(mut self) -> thread::Result<()> {\n         self.bomb.defuse();\n         drop(self.watcher);"}, {"sha": "21d5633b12cbf71aa471e6274ddae5692192ad08", "filename": "crates/ra_vfs/tests/vfs.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b86f038d61752bbf306ed5dd9def74be3b5dcc1/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b86f038d61752bbf306ed5dd9def74be3b5dcc1/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Ftests%2Fvfs.rs?ref=6b86f038d61752bbf306ed5dd9def74be3b5dcc1", "patch": "@@ -59,15 +59,15 @@ fn test_vfs_works() -> std::io::Result<()> {\n \n     // on disk change\n     fs::write(&dir.path().join(\"a/b/baz.rs\"), \"quux\").unwrap();\n-    let change = vfs.change_receiver().recv().unwrap();\n-    vfs.handle_change(change);\n+    let task = vfs.task_receiver().recv().unwrap();\n+    vfs.handle_task(task);\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::ChangeFile { text, .. }] => assert_eq!(text.as_str(), \"quux\"),\n         _ => panic!(\"unexpected changes\"),\n     }\n \n     // in memory change\n-    vfs.change_file_overlay(&dir.path().join(\"a/b/baz.rs\"), Some(\"m\".to_string()));\n+    vfs.change_file_overlay(&dir.path().join(\"a/b/baz.rs\"), \"m\".to_string());\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::ChangeFile { text, .. }] => assert_eq!(text.as_str(), \"m\"),\n         _ => panic!(\"unexpected changes\"),\n@@ -81,7 +81,7 @@ fn test_vfs_works() -> std::io::Result<()> {\n     }\n \n     // in memory add\n-    vfs.add_file_overlay(&dir.path().join(\"a/b/spam.rs\"), Some(\"spam\".to_string()));\n+    vfs.add_file_overlay(&dir.path().join(\"a/b/spam.rs\"), \"spam\".to_string());\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::AddFile { text, path, .. }] => {\n             assert_eq!(text.as_str(), \"spam\");\n@@ -99,8 +99,8 @@ fn test_vfs_works() -> std::io::Result<()> {\n \n     // on disk add\n     fs::write(&dir.path().join(\"a/new.rs\"), \"new hello\").unwrap();\n-    let change = vfs.change_receiver().recv().unwrap();\n-    vfs.handle_change(change);\n+    let task = vfs.task_receiver().recv().unwrap();\n+    vfs.handle_task(task);\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::AddFile { text, path, .. }] => {\n             assert_eq!(text.as_str(), \"new hello\");\n@@ -111,8 +111,8 @@ fn test_vfs_works() -> std::io::Result<()> {\n \n     // on disk rename\n     fs::rename(&dir.path().join(\"a/new.rs\"), &dir.path().join(\"a/new1.rs\")).unwrap();\n-    let change = vfs.change_receiver().recv().unwrap();\n-    vfs.handle_change(change);\n+    let task = vfs.task_receiver().recv().unwrap();\n+    vfs.handle_task(task);\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::RemoveFile {\n             path: removed_path, ..\n@@ -130,14 +130,14 @@ fn test_vfs_works() -> std::io::Result<()> {\n \n     // on disk remove\n     fs::remove_file(&dir.path().join(\"a/new1.rs\")).unwrap();\n-    let change = vfs.change_receiver().recv().unwrap();\n-    vfs.handle_change(change);\n+    let task = vfs.task_receiver().recv().unwrap();\n+    vfs.handle_task(task);\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::RemoveFile { path, .. }] => assert_eq!(path, \"new1.rs\"),\n         _ => panic!(\"unexpected changes\"),\n     }\n \n-    match vfs.change_receiver().try_recv() {\n+    match vfs.task_receiver().try_recv() {\n         Err(crossbeam_channel::TryRecvError::Empty) => (),\n         res => panic!(\"unexpected {:?}\", res),\n     }"}]}