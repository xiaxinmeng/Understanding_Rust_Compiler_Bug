{"sha": "ae81c89f34f1ac2cdb596cf216612e94822a8466", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlODFjODlmMzRmMWFjMmNkYjU5NmNmMjE2NjEyZTk0ODIyYTg0NjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-03T18:47:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-03T18:47:13Z"}, "message": "auto merge of #17742 : alexcrichton/rust/rollup, r=alexcrichton\n\nTrying to get a couple of these into the next snapshot.", "tree": {"sha": "5a3cd9b50266167ad0abdc56567dcdfdf882b4b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a3cd9b50266167ad0abdc56567dcdfdf882b4b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae81c89f34f1ac2cdb596cf216612e94822a8466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae81c89f34f1ac2cdb596cf216612e94822a8466", "html_url": "https://github.com/rust-lang/rust/commit/ae81c89f34f1ac2cdb596cf216612e94822a8466", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae81c89f34f1ac2cdb596cf216612e94822a8466/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a2286d3a13c4a97340c99c86c718654f6cb2ed6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a2286d3a13c4a97340c99c86c718654f6cb2ed6", "html_url": "https://github.com/rust-lang/rust/commit/9a2286d3a13c4a97340c99c86c718654f6cb2ed6"}, {"sha": "39f4bf7b1c9991cfd02f68d45ca59d6c525c4184", "url": "https://api.github.com/repos/rust-lang/rust/commits/39f4bf7b1c9991cfd02f68d45ca59d6c525c4184", "html_url": "https://github.com/rust-lang/rust/commit/39f4bf7b1c9991cfd02f68d45ca59d6c525c4184"}], "stats": {"total": 978, "additions": 718, "deletions": 260}, "files": [{"sha": "261990052988f65a8fae1d0606015c48fcbb13d9", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -3,13 +3,6 @@\n # downloads a rust/cargo snapshot, which we don't really want for building rust.\n language: c\n \n-# Make sure we've got an up-to-date g++ compiler to get past the LLVM configure\n-# script.\n-install:\n-  - sudo add-apt-repository -y ppa:ubuntu-toolchain-r/test\n-  - sudo apt-get update -qq\n-  - sudo apt-get install g++-4.7\n-\n # The test suite is in general way too stressful for travis, especially in\n # terms of time limit and reliability. In the past we've tried to scale things\n # back to only build the stage1 compiler and run a subset of tests, but this\n@@ -18,7 +11,7 @@ install:\n # As a result, we're just using travis to run `make tidy` now. It'll help\n # everyone find out about their trailing spaces early on!\n before_script:\n-  - ./configure\n+  - ./configure --llvm-root=path/to/nowhere\n script:\n   - make tidy\n "}, {"sha": "9a02a3b815e8ace6cc42b8f0b96498da1381854b", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -1412,7 +1412,7 @@ struct BitsNStrings<'a> {\n     mystring: &'a str\n }\n \n-static bits_n_strings: BitsNStrings<'static> = BitsNStrings {\n+static BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\n     mybits: BITS,\n     mystring: STRING\n };"}, {"sha": "82d320d570223670cd16654efa1117ff5a91bcbb", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -86,9 +86,12 @@ pub mod BigDigit {\n     use super::DoubleBigDigit;\n \n     // `DoubleBigDigit` size dependent\n+    #[allow(non_uppercase_statics)]\n     pub static bits: uint = 32;\n \n+    #[allow(non_uppercase_statics)]\n     pub static base: DoubleBigDigit = 1 << bits;\n+    #[allow(non_uppercase_statics)]\n     static lo_mask: DoubleBigDigit = (-1 as DoubleBigDigit) >> bits;\n \n     #[inline]\n@@ -1841,7 +1844,7 @@ mod biguint_tests {\n               BigInt::from_biguint(Plus, BigUint::new(vec!(1,2,3))));\n     }\n \n-    static sum_triples: &'static [(&'static [BigDigit],\n+    static SUM_TRIPLES: &'static [(&'static [BigDigit],\n                                    &'static [BigDigit],\n                                    &'static [BigDigit])] = &[\n         (&[],          &[],       &[]),\n@@ -1857,7 +1860,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_add() {\n-        for elm in sum_triples.iter() {\n+        for elm in SUM_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigUint::from_slice(a_vec);\n             let b = BigUint::from_slice(b_vec);\n@@ -1870,7 +1873,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_sub() {\n-        for elm in sum_triples.iter() {\n+        for elm in SUM_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigUint::from_slice(a_vec);\n             let b = BigUint::from_slice(b_vec);\n@@ -1888,7 +1891,7 @@ mod biguint_tests {\n         a - b;\n     }\n \n-    static mul_triples: &'static [(&'static [BigDigit],\n+    static MUL_TRIPLES: &'static [(&'static [BigDigit],\n                                    &'static [BigDigit],\n                                    &'static [BigDigit])] = &[\n         (&[],               &[],               &[]),\n@@ -1914,7 +1917,7 @@ mod biguint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    static div_rem_quadruples: &'static [(&'static [BigDigit],\n+    static DIV_REM_QUADRUPLES: &'static [(&'static [BigDigit],\n                                            &'static [BigDigit],\n                                            &'static [BigDigit],\n                                            &'static [BigDigit])]\n@@ -1928,7 +1931,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_mul() {\n-        for elm in mul_triples.iter() {\n+        for elm in MUL_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigUint::from_slice(a_vec);\n             let b = BigUint::from_slice(b_vec);\n@@ -1938,7 +1941,7 @@ mod biguint_tests {\n             assert!(b * a == c);\n         }\n \n-        for elm in div_rem_quadruples.iter() {\n+        for elm in DIV_REM_QUADRUPLES.iter() {\n             let (a_vec, b_vec, c_vec, d_vec) = *elm;\n             let a = BigUint::from_slice(a_vec);\n             let b = BigUint::from_slice(b_vec);\n@@ -1952,7 +1955,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_div_rem() {\n-        for elm in mul_triples.iter() {\n+        for elm in MUL_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigUint::from_slice(a_vec);\n             let b = BigUint::from_slice(b_vec);\n@@ -1966,7 +1969,7 @@ mod biguint_tests {\n             }\n         }\n \n-        for elm in div_rem_quadruples.iter() {\n+        for elm in DIV_REM_QUADRUPLES.iter() {\n             let (a_vec, b_vec, c_vec, d_vec) = *elm;\n             let a = BigUint::from_slice(a_vec);\n             let b = BigUint::from_slice(b_vec);\n@@ -1979,7 +1982,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_checked_add() {\n-        for elm in sum_triples.iter() {\n+        for elm in SUM_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigUint::from_slice(a_vec);\n             let b = BigUint::from_slice(b_vec);\n@@ -1992,7 +1995,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_checked_sub() {\n-        for elm in sum_triples.iter() {\n+        for elm in SUM_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigUint::from_slice(a_vec);\n             let b = BigUint::from_slice(b_vec);\n@@ -2012,7 +2015,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_checked_mul() {\n-        for elm in mul_triples.iter() {\n+        for elm in MUL_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigUint::from_slice(a_vec);\n             let b = BigUint::from_slice(b_vec);\n@@ -2022,7 +2025,7 @@ mod biguint_tests {\n             assert!(b.checked_mul(&a).unwrap() == c);\n         }\n \n-        for elm in div_rem_quadruples.iter() {\n+        for elm in DIV_REM_QUADRUPLES.iter() {\n             let (a_vec, b_vec, c_vec, d_vec) = *elm;\n             let a = BigUint::from_slice(a_vec);\n             let b = BigUint::from_slice(b_vec);\n@@ -2036,7 +2039,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_checked_div() {\n-        for elm in mul_triples.iter() {\n+        for elm in MUL_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigUint::from_slice(a_vec);\n             let b = BigUint::from_slice(b_vec);\n@@ -2440,7 +2443,7 @@ mod bigint_tests {\n         assert_eq!(negative.to_biguint(), None);\n     }\n \n-    static sum_triples: &'static [(&'static [BigDigit],\n+    static SUM_TRIPLES: &'static [(&'static [BigDigit],\n                                    &'static [BigDigit],\n                                    &'static [BigDigit])] = &[\n         (&[],          &[],       &[]),\n@@ -2456,7 +2459,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_add() {\n-        for elm in sum_triples.iter() {\n+        for elm in SUM_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2475,7 +2478,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_sub() {\n-        for elm in sum_triples.iter() {\n+        for elm in SUM_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2492,7 +2495,7 @@ mod bigint_tests {\n         }\n     }\n \n-    static mul_triples: &'static [(&'static [BigDigit],\n+    static MUL_TRIPLES: &'static [(&'static [BigDigit],\n                                    &'static [BigDigit],\n                                    &'static [BigDigit])] = &[\n         (&[],               &[],               &[]),\n@@ -2518,7 +2521,7 @@ mod bigint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    static div_rem_quadruples: &'static [(&'static [BigDigit],\n+    static DIV_REM_QUADRUPLES: &'static [(&'static [BigDigit],\n                                           &'static [BigDigit],\n                                           &'static [BigDigit],\n                                           &'static [BigDigit])]\n@@ -2532,7 +2535,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_mul() {\n-        for elm in mul_triples.iter() {\n+        for elm in MUL_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2545,7 +2548,7 @@ mod bigint_tests {\n             assert!((-b) * a == -c);\n         }\n \n-        for elm in div_rem_quadruples.iter() {\n+        for elm in DIV_REM_QUADRUPLES.iter() {\n             let (a_vec, b_vec, c_vec, d_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2584,7 +2587,7 @@ mod bigint_tests {\n             }\n         }\n \n-        for elm in mul_triples.iter() {\n+        for elm in MUL_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2594,7 +2597,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for elm in div_rem_quadruples.iter() {\n+        for elm in DIV_REM_QUADRUPLES.iter() {\n             let (a_vec, b_vec, c_vec, d_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2627,7 +2630,7 @@ mod bigint_tests {\n             check_sub(&a.neg(), b, &q.neg(), &r.neg());\n             check_sub(&a.neg(), &b.neg(), q, &r.neg());\n         }\n-        for elm in mul_triples.iter() {\n+        for elm in MUL_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2637,7 +2640,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for elm in div_rem_quadruples.iter() {\n+        for elm in DIV_REM_QUADRUPLES.iter() {\n             let (a_vec, b_vec, c_vec, d_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2652,7 +2655,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_checked_add() {\n-        for elm in sum_triples.iter() {\n+        for elm in SUM_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2671,7 +2674,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_checked_sub() {\n-        for elm in sum_triples.iter() {\n+        for elm in SUM_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2690,7 +2693,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_checked_mul() {\n-        for elm in mul_triples.iter() {\n+        for elm in MUL_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2703,7 +2706,7 @@ mod bigint_tests {\n             assert!((-b).checked_mul(&a).unwrap() == -c);\n         }\n \n-        for elm in div_rem_quadruples.iter() {\n+        for elm in DIV_REM_QUADRUPLES.iter() {\n             let (a_vec, b_vec, c_vec, d_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);\n@@ -2716,7 +2719,7 @@ mod bigint_tests {\n     }\n     #[test]\n     fn test_checked_div() {\n-        for elm in mul_triples.iter() {\n+        for elm in MUL_TRIPLES.iter() {\n             let (a_vec, b_vec, c_vec) = *elm;\n             let a = BigInt::from_slice(Plus, a_vec);\n             let b = BigInt::from_slice(Plus, b_vec);"}, {"sha": "ceaf685c19a5154d03b89d1a25def253c3136635", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -406,10 +406,13 @@ mod test {\n     pub static _2: Rational = Ratio { numer: 2, denom: 1};\n     pub static _1_2: Rational = Ratio { numer: 1, denom: 2};\n     pub static _3_2: Rational = Ratio { numer: 3, denom: 2};\n+    #[allow(non_uppercase_statics)]\n     pub static _neg1_2: Rational = Ratio { numer: -1, denom: 2};\n     pub static _1_3: Rational = Ratio { numer: 1, denom: 3};\n+    #[allow(non_uppercase_statics)]\n     pub static _neg1_3: Rational = Ratio { numer: -1, denom: 3};\n     pub static _2_3: Rational = Ratio { numer: 2, denom: 3};\n+    #[allow(non_uppercase_statics)]\n     pub static _neg2_3: Rational = Ratio { numer: -2, denom: 3};\n \n     pub fn to_big(n: Rational) -> BigRational {"}, {"sha": "df33e6e2ced0cbcc0036e14719aa931095110528", "filename": "src/librand/chacha.rs", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -0,0 +1,285 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The ChaCha random number generator.\n+\n+use core::prelude::*;\n+\n+use {Rng, SeedableRng, Rand};\n+\n+static KEY_WORDS    : uint =  8; // 8 words for the 256-bit key\n+static STATE_WORDS  : uint = 16;\n+static CHACHA_ROUNDS: uint = 20; // Cryptographically secure from 8 upwards as of this writing\n+\n+/// A random number generator that uses the ChaCha20 algorithm [1].\n+///\n+/// The ChaCha algorithm is widely accepted as suitable for\n+/// cryptographic purposes, but this implementation has not been\n+/// verified as such. Prefer a generator like `OsRng` that defers to\n+/// the operating system for cases that need high security.\n+///\n+/// [1]: D. J. Bernstein, [*ChaCha, a variant of\n+/// Salsa20*](http://cr.yp.to/chacha.html)\n+\n+pub struct ChaChaRng {\n+    buffer:  [u32, ..STATE_WORDS], // Internal buffer of output\n+    state:   [u32, ..STATE_WORDS], // Initial state\n+    index:   uint,                 // Index into state\n+}\n+\n+static EMPTY: ChaChaRng = ChaChaRng {\n+    buffer:  [0, ..STATE_WORDS],\n+    state:   [0, ..STATE_WORDS],\n+    index:   STATE_WORDS\n+};\n+\n+\n+macro_rules! quarter_round{\n+    ($a: expr, $b: expr, $c: expr, $d: expr) => {{\n+        $a += $b; $d ^= $a; $d = $d.rotate_left(16);\n+        $c += $d; $b ^= $c; $b = $b.rotate_left(12);\n+        $a += $b; $d ^= $a; $d = $d.rotate_left( 8);\n+        $c += $d; $b ^= $c; $b = $b.rotate_left( 7);\n+    }}\n+}\n+\n+macro_rules! double_round{\n+    ($x: expr) => {{\n+        // Column round\n+        quarter_round!($x[ 0], $x[ 4], $x[ 8], $x[12]);\n+        quarter_round!($x[ 1], $x[ 5], $x[ 9], $x[13]);\n+        quarter_round!($x[ 2], $x[ 6], $x[10], $x[14]);\n+        quarter_round!($x[ 3], $x[ 7], $x[11], $x[15]);\n+        // Diagonal round\n+        quarter_round!($x[ 0], $x[ 5], $x[10], $x[15]);\n+        quarter_round!($x[ 1], $x[ 6], $x[11], $x[12]);\n+        quarter_round!($x[ 2], $x[ 7], $x[ 8], $x[13]);\n+        quarter_round!($x[ 3], $x[ 4], $x[ 9], $x[14]);\n+    }}\n+}\n+\n+#[inline]\n+fn core(output: &mut [u32, ..STATE_WORDS], input: &[u32, ..STATE_WORDS]) {\n+    *output = *input;\n+\n+    for _ in range(0, CHACHA_ROUNDS / 2) {\n+        double_round!(output);\n+    }\n+\n+    for i in range(0, STATE_WORDS) {\n+        output[i] += input[i];\n+    }\n+}\n+\n+impl ChaChaRng {\n+\n+    /// Create an ChaCha random number generator using the default\n+    /// fixed key of 8 zero words.\n+    pub fn new_unseeded() -> ChaChaRng {\n+        let mut rng = EMPTY;\n+        rng.init(&[0, ..KEY_WORDS]);\n+        rng\n+    }\n+\n+    /// Sets the internal 128-bit ChaCha counter to\n+    /// a user-provided value. This permits jumping\n+    /// arbitrarily ahead (or backwards) in the pseudorandom stream.\n+    ///\n+    /// Since the nonce words are used to extend the counter to 128 bits,\n+    /// users wishing to obtain the conventional ChaCha pseudorandom stream\n+    /// associated with a particular nonce can call this function with\n+    /// arguments `0, desired_nonce`.\n+    pub fn set_counter(&mut self, counter_low: u64, counter_high: u64) {\n+        self.state[12] = (counter_low >>  0) as u32;\n+        self.state[13] = (counter_low >> 32) as u32;\n+        self.state[14] = (counter_high >>  0) as u32;\n+        self.state[15] = (counter_high >> 32) as u32;\n+        self.index = STATE_WORDS; // force recomputation\n+    }\n+\n+    /// Initializes `self.state` with the appropriate key and constants\n+    ///\n+    /// We deviate slightly from the ChaCha specification regarding\n+    /// the nonce, which is used to extend the counter to 128 bits.\n+    /// This is provably as strong as the original cipher, though,\n+    /// since any distinguishing attack on our variant also works\n+    /// against ChaCha with a chosen-nonce. See the XSalsa20 [1]\n+    /// security proof for a more involved example of this.\n+    ///\n+    /// The modified word layout is:\n+    /// ```notrust\n+    /// constant constant constant constant\n+    /// key      key      key      key\n+    /// key      key      key      key\n+    /// counter  counter  counter  counter\n+    /// ```\n+    /// [1]: Daniel J. Bernstein. [*Extending the Salsa20\n+    /// nonce.*](http://cr.yp.to/papers.html#xsalsa)\n+    fn init(&mut self, key: &[u32, ..KEY_WORDS]) {\n+        self.state[0] = 0x61707865;\n+        self.state[1] = 0x3320646E;\n+        self.state[2] = 0x79622D32;\n+        self.state[3] = 0x6B206574;\n+\n+        for i in range(0, KEY_WORDS) {\n+            self.state[4+i] = key[i];\n+        }\n+\n+        self.state[12] = 0;\n+        self.state[13] = 0;\n+        self.state[14] = 0;\n+        self.state[15] = 0;\n+\n+        self.index = STATE_WORDS;\n+    }\n+\n+    /// Refill the internal output buffer (`self.buffer`)\n+    fn update(&mut self) {\n+        core(&mut self.buffer, &self.state);\n+        self.index = 0;\n+        // update 128-bit counter\n+        self.state[12] += 1;\n+        if self.state[12] != 0 { return };\n+        self.state[13] += 1;\n+        if self.state[13] != 0 { return };\n+        self.state[14] += 1;\n+        if self.state[14] != 0 { return };\n+        self.state[15] += 1;\n+    }\n+}\n+\n+impl Rng for ChaChaRng {\n+    #[inline]\n+    fn next_u32(&mut self) -> u32 {\n+        if self.index == STATE_WORDS {\n+            self.update();\n+        }\n+\n+        let value = self.buffer[self.index % STATE_WORDS];\n+        self.index += 1;\n+        value\n+    }\n+}\n+\n+impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n+\n+    fn reseed(&mut self, seed: &'a [u32]) {\n+        // reset state\n+        self.init(&[0u32, ..KEY_WORDS]);\n+        // set key inplace\n+        let key = self.state.slice_mut(4, 4+KEY_WORDS);\n+        for (k, s) in key.iter_mut().zip(seed.iter()) {\n+            *k = *s;\n+        }\n+    }\n+\n+    /// Create a ChaCha generator from a seed,\n+    /// obtained from a variable-length u32 array.\n+    /// Only up to 8 words are used; if less than 8\n+    /// words are used, the remaining are set to zero.\n+    fn from_seed(seed: &'a [u32]) -> ChaChaRng {\n+        let mut rng = EMPTY;\n+        rng.reseed(seed);\n+        rng\n+    }\n+}\n+\n+impl Rand for ChaChaRng {\n+    fn rand<R: Rng>(other: &mut R) -> ChaChaRng {\n+        let mut key : [u32, ..KEY_WORDS] = [0, ..KEY_WORDS];\n+        for word in key.iter_mut() {\n+            *word = other.gen();\n+        }\n+        SeedableRng::from_seed(key.as_slice())\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use std::prelude::*;\n+\n+    use core::iter::order;\n+    use {Rng, SeedableRng};\n+    use super::ChaChaRng;\n+\n+    #[test]\n+    fn test_rng_rand_seeded() {\n+        let s = ::test::rng().gen_iter::<u32>().take(8).collect::<Vec<u32>>();\n+        let mut ra: ChaChaRng = SeedableRng::from_seed(s.as_slice());\n+        let mut rb: ChaChaRng = SeedableRng::from_seed(s.as_slice());\n+        assert!(order::equals(ra.gen_ascii_chars().take(100),\n+                              rb.gen_ascii_chars().take(100)));\n+    }\n+\n+    #[test]\n+    fn test_rng_seeded() {\n+        let seed : &[_] = &[0,1,2,3,4,5,6,7];\n+        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n+        let mut rb: ChaChaRng = SeedableRng::from_seed(seed);\n+        assert!(order::equals(ra.gen_ascii_chars().take(100),\n+                              rb.gen_ascii_chars().take(100)));\n+    }\n+\n+    #[test]\n+    fn test_rng_reseed() {\n+        let s = ::test::rng().gen_iter::<u32>().take(8).collect::<Vec<u32>>();\n+        let mut r: ChaChaRng = SeedableRng::from_seed(s.as_slice());\n+        let string1: String = r.gen_ascii_chars().take(100).collect();\n+\n+        r.reseed(s.as_slice());\n+\n+        let string2: String = r.gen_ascii_chars().take(100).collect();\n+        assert_eq!(string1, string2);\n+    }\n+\n+    #[test]\n+    fn test_rng_true_values() {\n+        // Test vectors 1 and 2 from\n+        // http://tools.ietf.org/html/draft-nir-cfrg-chacha20-poly1305-04\n+        let seed : &[_] = &[0u32, ..8];\n+        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n+\n+        let v = Vec::from_fn(16, |_| ra.next_u32());\n+        assert_eq!(v,\n+                   vec!(0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n+                        0xb819d2bd, 0x1aed8da0, 0xccef36a8, 0xc70d778b,\n+                        0x7c5941da, 0x8d485751, 0x3fe02477, 0x374ad8b8,\n+                        0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2));\n+\n+        let v = Vec::from_fn(16, |_| ra.next_u32());\n+        assert_eq!(v,\n+                   vec!(0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n+                        0xa0290fcb, 0x6965e348, 0x3e53c612, 0xed7aee32,\n+                        0x7621b729, 0x434ee69c, 0xb03371d5, 0xd539d874,\n+                        0x281fed31, 0x45fb0a51, 0x1f0ae1ac, 0x6f4d794b));\n+\n+\n+        let seed : &[_] = &[0,1,2,3,4,5,6,7];\n+        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n+\n+        // Store the 17*i-th 32-bit word,\n+        // i.e., the i-th word of the i-th 16-word block\n+        let mut v : Vec<u32> = Vec::new();\n+        for _ in range(0u, 16) {\n+            v.push(ra.next_u32());\n+            for _ in range(0u, 16) {\n+                ra.next_u32();\n+            }\n+        }\n+\n+        assert_eq!(v,\n+                   vec!(0xf225c81a, 0x6ab1be57, 0x04d42951, 0x70858036,\n+                        0x49884684, 0x64efec72, 0x4be2d186, 0x3615b384,\n+                        0x11cfa18e, 0xd3c50049, 0x75c775f6, 0x434c6530,\n+                        0x2c5bad8f, 0x898881dc, 0x5f1c86d9, 0xc1f8e7f4));\n+    }\n+}\n+"}, {"sha": "3319e75a628b69be9a4d6d1d0d7df49155f6f3c7", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -39,6 +39,7 @@ extern crate core;\n use core::prelude::*;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n+pub use chacha::ChaChaRng;\n \n use distributions::{Range, IndependentSample};\n use distributions::range::SampleRange;\n@@ -48,6 +49,7 @@ static RAND_BENCH_N: u64 = 100;\n \n pub mod distributions;\n pub mod isaac;\n+pub mod chacha;\n pub mod reseeding;\n mod rand_impls;\n "}, {"sha": "64c6b1739ebb1f962468af06d88da8026cb268dd", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -209,15 +209,15 @@ mod test {\n         assert_eq!(string1, string2);\n     }\n \n-    static fill_bytes_v_len: uint = 13579;\n+    static FILL_BYTES_V_LEN: uint = 13579;\n     #[test]\n     fn test_rng_fill_bytes() {\n-        let mut v = Vec::from_elem(fill_bytes_v_len, 0u8);\n+        let mut v = Vec::from_elem(FILL_BYTES_V_LEN, 0u8);\n         ::test::rng().fill_bytes(v.as_mut_slice());\n \n         // Sanity test: if we've gotten here, `fill_bytes` has not infinitely\n         // recursed.\n-        assert_eq!(v.len(), fill_bytes_v_len);\n+        assert_eq!(v.len(), FILL_BYTES_V_LEN);\n \n         // To test that `fill_bytes` actually did something, check that the\n         // average of `v` is not 0."}, {"sha": "9804382dbd91d913ddf5b0ac612517579a1e3689", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -494,6 +494,7 @@ pub fn get_os(triple: &str) -> Option<abi::Os> {\n     }\n     None\n }\n+#[allow(non_uppercase_statics)]\n static os_names : &'static [(&'static str, abi::Os)] = &[\n     (\"mingw32\",   abi::OsWindows),\n     (\"win32\",     abi::OsWindows),\n@@ -511,6 +512,7 @@ pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n     }\n     None\n }\n+#[allow(non_uppercase_statics)]\n static architecture_abis : &'static [(&'static str, abi::Architecture)] = &[\n     (\"i386\",   abi::X86),\n     (\"i486\",   abi::X86),"}, {"sha": "4c147517a7f03bc0aac8a3035b4ffffac8375499", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -631,7 +631,7 @@ impl LintPass for UnusedAttribute {\n     }\n }\n \n-declare_lint!(PATH_STATEMENT, Warn,\n+declare_lint!(pub PATH_STATEMENT, Warn,\n               \"path statements with no effect\")\n \n pub struct PathStatement;\n@@ -655,10 +655,10 @@ impl LintPass for PathStatement {\n     }\n }\n \n-declare_lint!(UNUSED_MUST_USE, Warn,\n+declare_lint!(pub UNUSED_MUST_USE, Warn,\n               \"unused result of a type flagged as #[must_use]\")\n \n-declare_lint!(UNUSED_RESULT, Allow,\n+declare_lint!(pub UNUSED_RESULT, Allow,\n               \"unused result of an expression in a statement\")\n \n pub struct UnusedResult;\n@@ -871,13 +871,17 @@ impl NonSnakeCase {\n         fn to_snake_case(str: &str) -> String {\n             let mut words = vec![];\n             for s in str.split('_') {\n+                let mut last_upper = false;\n                 let mut buf = String::new();\n                 if s.is_empty() { continue; }\n                 for ch in s.chars() {\n-                    if !buf.is_empty() && buf.as_slice() != \"'\" && ch.is_uppercase() {\n+                    if !buf.is_empty() && buf.as_slice() != \"'\"\n+                                       && ch.is_uppercase()\n+                                       && !last_upper {\n                         words.push(buf);\n                         buf = String::new();\n                     }\n+                    last_upper = ch.is_uppercase();\n                     buf.push_char(ch.to_lowercase());\n                 }\n                 words.push(buf);\n@@ -961,7 +965,7 @@ impl LintPass for NonSnakeCase {\n     }\n }\n \n-declare_lint!(pub NON_UPPERCASE_STATICS, Allow,\n+declare_lint!(pub NON_UPPERCASE_STATICS, Warn,\n               \"static constants should have uppercase identifiers\")\n \n pub struct NonUppercaseStatics;\n@@ -1136,7 +1140,7 @@ impl LintPass for UnnecessaryImportBraces {\n     }\n }\n \n-declare_lint!(UNUSED_UNSAFE, Warn,\n+declare_lint!(pub UNUSED_UNSAFE, Warn,\n               \"unnecessary use of an `unsafe` block\")\n \n pub struct UnusedUnsafe;\n@@ -1488,14 +1492,17 @@ impl LintPass for Stability {\n         });\n         if skip { return; }\n \n+        let mut span = e.span;\n+\n         let id = match e.node {\n             ast::ExprPath(..) | ast::ExprStruct(..) => {\n                 match cx.tcx.def_map.borrow().find(&e.id) {\n                     Some(&def) => def.def_id(),\n                     None => return\n                 }\n             }\n-            ast::ExprMethodCall(..) => {\n+            ast::ExprMethodCall(i, _, _) => {\n+                span = i.span;\n                 let method_call = typeck::MethodCall::expr(e.id);\n                 match cx.tcx.method_map.borrow().find(&method_call) {\n                     Some(method) => {\n@@ -1552,7 +1559,7 @@ impl LintPass for Stability {\n             _ => format!(\"use of {} item\", label)\n         };\n \n-        cx.span_lint(lint, e.span, msg.as_slice());\n+        cx.span_lint(lint, span, msg.as_slice());\n     }\n }\n "}, {"sha": "bb277511463b9f61c69e43cbe60a2853e8f8b444", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -203,7 +203,8 @@ impl LintStore {\n \n         add_lint_group!(sess, \"unused\",\n                         UNUSED_IMPORTS, UNUSED_VARIABLE, DEAD_ASSIGNMENT, DEAD_CODE,\n-                        UNUSED_MUT, UNREACHABLE_CODE, UNUSED_EXTERN_CRATE)\n+                        UNUSED_MUT, UNREACHABLE_CODE, UNUSED_EXTERN_CRATE, UNUSED_MUST_USE,\n+                        UNUSED_UNSAFE, UNUSED_RESULT, PATH_STATEMENT)\n \n         // We have one lint pass defined in this module.\n         self.register_pass(sess, false, box GatherNodeLevels as LintPassObject);"}, {"sha": "8047c12efc2917adc9b4549fb0f5a0dfcf7fafb4", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -98,6 +98,7 @@ macro_rules! declare_lint (\n #[macro_export]\n macro_rules! lint_array ( ($( $lint:expr ),*) => (\n     {\n+        #[allow(non_uppercase_statics)]\n         static array: LintArray = &[ $( $lint ),* ];\n         array\n     }"}, {"sha": "ef88795762e43617966665217885920a7612caf9", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n+#![allow(non_camel_case_types, non_uppercase_statics)]\n \n use std::mem;\n use back::svh::Svh;"}, {"sha": "642f66e259a6272025e28f45173a79ffa2450b3d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -2028,6 +2028,7 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n }\n \n // NB: Increment this as you change the metadata encoding version.\n+#[allow(non_uppercase_statics)]\n pub static metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 1 ];\n \n pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {"}, {"sha": "eda145419616ba72416e43bac6d0ae0ccaabe754", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -83,6 +83,7 @@ impl Clone for MovePathIndex {\n     }\n }\n \n+#[allow(non_uppercase_statics)]\n static InvalidMovePathIndex: MovePathIndex =\n     MovePathIndex(uint::MAX);\n \n@@ -96,6 +97,7 @@ impl MoveIndex {\n     }\n }\n \n+#[allow(non_uppercase_statics)]\n static InvalidMoveIndex: MoveIndex =\n     MoveIndex(uint::MAX);\n "}, {"sha": "9135ca07935a5d8903a79b160a9ae1223a216da8", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -57,16 +57,20 @@ pub struct Edge<E> {\n \n #[deriving(Clone, PartialEq, Show)]\n pub struct NodeIndex(pub uint);\n+#[allow(non_uppercase_statics)]\n pub static InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n \n #[deriving(PartialEq)]\n pub struct EdgeIndex(pub uint);\n+#[allow(non_uppercase_statics)]\n pub static InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n #[deriving(Show)]\n pub struct Direction { repr: uint }\n+#[allow(non_uppercase_statics)]\n pub static Outgoing: Direction = Direction { repr: 0 };\n+#[allow(non_uppercase_statics)]\n pub static Incoming: Direction = Direction { repr: 1 };\n \n impl NodeIndex {"}, {"sha": "f88b010c28a357d2b0d70a6189b03fd112ddb144", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -389,10 +389,12 @@ fn mk_cenum(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n     debug!(\"range_to_inttype: {:?} {:?}\", hint, bounds);\n     // Lists of sizes to try.  u64 is always allowed as a fallback.\n+    #[allow(non_uppercase_statics)]\n     static choose_shortest: &'static[IntType] = &[\n         attr::UnsignedInt(ast::TyU8), attr::SignedInt(ast::TyI8),\n         attr::UnsignedInt(ast::TyU16), attr::SignedInt(ast::TyI16),\n         attr::UnsignedInt(ast::TyU32), attr::SignedInt(ast::TyI32)];\n+    #[allow(non_uppercase_statics)]\n     static at_least_32: &'static[IntType] = &[\n         attr::UnsignedInt(ast::TyU32), attr::SignedInt(ast::TyI32)];\n "}, {"sha": "0cd8510b750acbaf7b88cce73a841d7fa6ac433d", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -31,8 +31,8 @@ pub struct Builder<'a, 'tcx: 'a> {\n // This is a really awful way to get a zero-length c-string, but better (and a\n // lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n pub fn noname() -> *const c_char {\n-    static cnull: c_char = 0;\n-    &cnull as *const c_char\n+    static CNULL: c_char = 0;\n+    &CNULL as *const c_char\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {"}, {"sha": "55e34ad48cd0c68d4c90557a8d6cb7a6bdb045ac", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -218,13 +218,20 @@ use syntax::parse::token::special_idents;\n \n static DW_LANG_RUST: c_uint = 0x9000;\n \n+#[allow(non_uppercase_statics)]\n static DW_TAG_auto_variable: c_uint = 0x100;\n+#[allow(non_uppercase_statics)]\n static DW_TAG_arg_variable: c_uint = 0x101;\n \n+#[allow(non_uppercase_statics)]\n static DW_ATE_boolean: c_uint = 0x02;\n+#[allow(non_uppercase_statics)]\n static DW_ATE_float: c_uint = 0x04;\n+#[allow(non_uppercase_statics)]\n static DW_ATE_signed: c_uint = 0x05;\n+#[allow(non_uppercase_statics)]\n static DW_ATE_unsigned: c_uint = 0x07;\n+#[allow(non_uppercase_statics)]\n static DW_ATE_unsigned_char: c_uint = 0x08;\n \n static UNKNOWN_LINE_NUMBER: c_uint = 0;"}, {"sha": "df92251c87e303cfe02e490e0a93874730d24e07", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -2197,7 +2197,10 @@ macro_rules! def_type_content_sets(\n         #[allow(non_snake_case)]\n         mod $mname {\n             use middle::ty::TypeContents;\n-            $(pub static $name: TypeContents = TypeContents { bits: $bits };)+\n+            $(\n+                #[allow(non_uppercase_statics)]\n+                pub static $name: TypeContents = TypeContents { bits: $bits };\n+             )+\n         }\n     }\n )\n@@ -4650,6 +4653,7 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId)\n }\n \n pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n+    #![allow(non_uppercase_statics)]\n     static tycat_other: int = 0;\n     static tycat_bool: int = 1;\n     static tycat_char: int = 2;"}, {"sha": "ca5d711d360ab509f0689c9ce180ccec6420aef1", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -693,16 +693,6 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n \n         let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n-        for impl_item in impl_items.iter() {\n-            match *impl_item {\n-                ast::MethodImplItem(ref m) => {\n-                    check_method_body(ccx, &impl_pty.generics, &**m);\n-                }\n-                ast::TypeImplItem(_) => {\n-                    // Nothing to do here.\n-                }\n-            }\n-        }\n \n         match *opt_trait_ref {\n             Some(ref ast_trait_ref) => {\n@@ -717,6 +707,17 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n             None => { }\n         }\n \n+        for impl_item in impl_items.iter() {\n+            match *impl_item {\n+                ast::MethodImplItem(ref m) => {\n+                    check_method_body(ccx, &impl_pty.generics, &**m);\n+                }\n+                ast::TypeImplItem(_) => {\n+                    // Nothing to do here.\n+                }\n+            }\n+        }\n+\n       }\n       ast::ItemTrait(_, _, _, ref trait_methods) => {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));"}, {"sha": "13659d4b77e1c5e1a59e601c1eec6c55aa7b374a", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -46,6 +46,8 @@\n // future).  If you want to resolve everything but one type, you are\n // probably better off writing `resolve_all - resolve_ivar`.\n \n+#![allow(non_uppercase_statics)]\n+\n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n use middle::ty::{IntType, UintType};\n use middle::ty;"}, {"sha": "7ed9d556a0ba76d0fbde3e0c2793b4220a25542b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -427,7 +427,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n       ty_vec(t, sz) => {\n           match sz {\n               Some(n) => {\n-                  format!(\"[{}, .. {}]\", ty_to_string(cx, t), n)\n+                  format!(\"[{}, ..{}]\", ty_to_string(cx, t), n)\n               }\n               None => format!(\"[{}]\", ty_to_string(cx, t)),\n           }"}, {"sha": "1e69ce003c557a9125d06d5a02c79e6accd3fe65", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(non_uppercase_statics)]\n+\n pub static box_field_refcnt: uint = 0u;\n pub static box_field_drop_glue: uint = 1u;\n pub static box_field_body: uint = 4u;"}, {"sha": "934fb0ddd3ce43dd7a4531a0bb9fca1e437ec47e", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -733,9 +733,9 @@ mod bench {\n         }\n     }\n \n-    static s_short: &'static str = \"Mary\";\n-    static s_medium: &'static str = \"Mary had a little lamb\";\n-    static s_long: &'static str = \"\\\n+    static S_SHORT: &'static str = \"Mary\";\n+    static S_MEDIUM: &'static str = \"Mary had a little lamb\";\n+    static S_LONG: &'static str = \"\\\n         Mary had a little lamb, Little lamb\n         Mary had a little lamb, Little lamb\n         Mary had a little lamb, Little lamb\n@@ -752,17 +752,17 @@ mod bench {\n \n     #[bench]\n     fn bench_to_c_str_short(b: &mut Bencher) {\n-        bench_to_string(b, s_short)\n+        bench_to_string(b, S_SHORT)\n     }\n \n     #[bench]\n     fn bench_to_c_str_medium(b: &mut Bencher) {\n-        bench_to_string(b, s_medium)\n+        bench_to_string(b, S_MEDIUM)\n     }\n \n     #[bench]\n     fn bench_to_c_str_long(b: &mut Bencher) {\n-        bench_to_string(b, s_long)\n+        bench_to_string(b, S_LONG)\n     }\n \n     fn bench_to_c_str_unchecked(b: &mut Bencher, s: &str) {\n@@ -774,17 +774,17 @@ mod bench {\n \n     #[bench]\n     fn bench_to_c_str_unchecked_short(b: &mut Bencher) {\n-        bench_to_c_str_unchecked(b, s_short)\n+        bench_to_c_str_unchecked(b, S_SHORT)\n     }\n \n     #[bench]\n     fn bench_to_c_str_unchecked_medium(b: &mut Bencher) {\n-        bench_to_c_str_unchecked(b, s_medium)\n+        bench_to_c_str_unchecked(b, S_MEDIUM)\n     }\n \n     #[bench]\n     fn bench_to_c_str_unchecked_long(b: &mut Bencher) {\n-        bench_to_c_str_unchecked(b, s_long)\n+        bench_to_c_str_unchecked(b, S_LONG)\n     }\n \n     fn bench_with_c_str(b: &mut Bencher, s: &str) {\n@@ -795,17 +795,17 @@ mod bench {\n \n     #[bench]\n     fn bench_with_c_str_short(b: &mut Bencher) {\n-        bench_with_c_str(b, s_short)\n+        bench_with_c_str(b, S_SHORT)\n     }\n \n     #[bench]\n     fn bench_with_c_str_medium(b: &mut Bencher) {\n-        bench_with_c_str(b, s_medium)\n+        bench_with_c_str(b, S_MEDIUM)\n     }\n \n     #[bench]\n     fn bench_with_c_str_long(b: &mut Bencher) {\n-        bench_with_c_str(b, s_long)\n+        bench_with_c_str(b, S_LONG)\n     }\n \n     fn bench_with_c_str_unchecked(b: &mut Bencher, s: &str) {\n@@ -818,16 +818,16 @@ mod bench {\n \n     #[bench]\n     fn bench_with_c_str_unchecked_short(b: &mut Bencher) {\n-        bench_with_c_str_unchecked(b, s_short)\n+        bench_with_c_str_unchecked(b, S_SHORT)\n     }\n \n     #[bench]\n     fn bench_with_c_str_unchecked_medium(b: &mut Bencher) {\n-        bench_with_c_str_unchecked(b, s_medium)\n+        bench_with_c_str_unchecked(b, S_MEDIUM)\n     }\n \n     #[bench]\n     fn bench_with_c_str_unchecked_long(b: &mut Bencher) {\n-        bench_with_c_str_unchecked(b, s_long)\n+        bench_with_c_str_unchecked(b, S_LONG)\n     }\n }"}, {"sha": "bb7a1227e0e4708c1c70ffb327a1541fd04fb502", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -10,6 +10,7 @@\n \n //! Unwind library interface\n \n+#![allow(non_uppercase_statics)]\n #![allow(non_camel_case_types)]\n #![allow(non_snake_case)]\n #![allow(dead_code)] // these are just bindings"}, {"sha": "8d5c49d767f1584f41e735acb65219397b19d9e5", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -416,37 +416,37 @@ mod tests {\n \n     #[test]\n     fn test_tls_multitask() {\n-        static my_key: Key<String> = &KeyValueKey;\n-        my_key.replace(Some(\"parent data\".to_string()));\n+        static MY_KEY: Key<String> = &KeyValueKey;\n+        MY_KEY.replace(Some(\"parent data\".to_string()));\n         task::spawn(proc() {\n             // TLD shouldn't carry over.\n-            assert!(my_key.get().is_none());\n-            my_key.replace(Some(\"child data\".to_string()));\n-            assert!(my_key.get().as_ref().unwrap().as_slice() == \"child data\");\n+            assert!(MY_KEY.get().is_none());\n+            MY_KEY.replace(Some(\"child data\".to_string()));\n+            assert!(MY_KEY.get().as_ref().unwrap().as_slice() == \"child data\");\n             // should be cleaned up for us\n         });\n \n         // Must work multiple times\n-        assert!(my_key.get().unwrap().as_slice() == \"parent data\");\n-        assert!(my_key.get().unwrap().as_slice() == \"parent data\");\n-        assert!(my_key.get().unwrap().as_slice() == \"parent data\");\n+        assert!(MY_KEY.get().unwrap().as_slice() == \"parent data\");\n+        assert!(MY_KEY.get().unwrap().as_slice() == \"parent data\");\n+        assert!(MY_KEY.get().unwrap().as_slice() == \"parent data\");\n     }\n \n     #[test]\n     fn test_tls_overwrite() {\n-        static my_key: Key<String> = &KeyValueKey;\n-        my_key.replace(Some(\"first data\".to_string()));\n-        my_key.replace(Some(\"next data\".to_string())); // Shouldn't leak.\n-        assert!(my_key.get().unwrap().as_slice() == \"next data\");\n+        static MY_KEY: Key<String> = &KeyValueKey;\n+        MY_KEY.replace(Some(\"first data\".to_string()));\n+        MY_KEY.replace(Some(\"next data\".to_string())); // Shouldn't leak.\n+        assert!(MY_KEY.get().unwrap().as_slice() == \"next data\");\n     }\n \n     #[test]\n     fn test_tls_pop() {\n-        static my_key: Key<String> = &KeyValueKey;\n-        my_key.replace(Some(\"weasel\".to_string()));\n-        assert!(my_key.replace(None).unwrap() == \"weasel\".to_string());\n+        static MY_KEY: Key<String> = &KeyValueKey;\n+        MY_KEY.replace(Some(\"weasel\".to_string()));\n+        assert!(MY_KEY.replace(None).unwrap() == \"weasel\".to_string());\n         // Pop must remove the data from the map.\n-        assert!(my_key.replace(None).is_none());\n+        assert!(MY_KEY.replace(None).is_none());\n     }\n \n     #[test]\n@@ -457,58 +457,58 @@ mod tests {\n         // to get recorded as something within a rust stack segment. Then a\n         // subsequent upcall (esp. for logging, think vsnprintf) would run on\n         // a stack smaller than 1 MB.\n-        static my_key: Key<String> = &KeyValueKey;\n+        static MY_KEY: Key<String> = &KeyValueKey;\n         task::spawn(proc() {\n-            my_key.replace(Some(\"hax\".to_string()));\n+            MY_KEY.replace(Some(\"hax\".to_string()));\n         });\n     }\n \n     #[test]\n     fn test_tls_multiple_types() {\n-        static str_key: Key<String> = &KeyValueKey;\n-        static box_key: Key<Box<int>> = &KeyValueKey;\n-        static int_key: Key<int> = &KeyValueKey;\n+        static STR_KEY: Key<String> = &KeyValueKey;\n+        static BOX_KEY: Key<Box<int>> = &KeyValueKey;\n+        static INT_KEY: Key<int> = &KeyValueKey;\n         task::spawn(proc() {\n-            str_key.replace(Some(\"string data\".to_string()));\n-            box_key.replace(Some(box 0));\n-            int_key.replace(Some(42));\n+            STR_KEY.replace(Some(\"string data\".to_string()));\n+            BOX_KEY.replace(Some(box 0));\n+            INT_KEY.replace(Some(42));\n         });\n     }\n \n     #[test]\n     fn test_tls_overwrite_multiple_types() {\n-        static str_key: Key<String> = &KeyValueKey;\n-        static box_key: Key<Box<int>> = &KeyValueKey;\n-        static int_key: Key<int> = &KeyValueKey;\n+        static STR_KEY: Key<String> = &KeyValueKey;\n+        static BOX_KEY: Key<Box<int>> = &KeyValueKey;\n+        static INT_KEY: Key<int> = &KeyValueKey;\n         task::spawn(proc() {\n-            str_key.replace(Some(\"string data\".to_string()));\n-            str_key.replace(Some(\"string data 2\".to_string()));\n-            box_key.replace(Some(box 0));\n-            box_key.replace(Some(box 1));\n-            int_key.replace(Some(42));\n+            STR_KEY.replace(Some(\"string data\".to_string()));\n+            STR_KEY.replace(Some(\"string data 2\".to_string()));\n+            BOX_KEY.replace(Some(box 0));\n+            BOX_KEY.replace(Some(box 1));\n+            INT_KEY.replace(Some(42));\n             // This could cause a segfault if overwriting-destruction is done\n             // with the crazy polymorphic transmute rather than the provided\n             // finaliser.\n-            int_key.replace(Some(31337));\n+            INT_KEY.replace(Some(31337));\n         });\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_tls_cleanup_on_failure() {\n-        static str_key: Key<String> = &KeyValueKey;\n-        static box_key: Key<Box<int>> = &KeyValueKey;\n-        static int_key: Key<int> = &KeyValueKey;\n-        str_key.replace(Some(\"parent data\".to_string()));\n-        box_key.replace(Some(box 0));\n+        static STR_KEY: Key<String> = &KeyValueKey;\n+        static BOX_KEY: Key<Box<int>> = &KeyValueKey;\n+        static INT_KEY: Key<int> = &KeyValueKey;\n+        STR_KEY.replace(Some(\"parent data\".to_string()));\n+        BOX_KEY.replace(Some(box 0));\n         task::spawn(proc() {\n-            str_key.replace(Some(\"string data\".to_string()));\n-            box_key.replace(Some(box 2));\n-            int_key.replace(Some(42));\n+            STR_KEY.replace(Some(\"string data\".to_string()));\n+            BOX_KEY.replace(Some(box 2));\n+            INT_KEY.replace(Some(42));\n             fail!();\n         });\n         // Not quite nondeterministic.\n-        int_key.replace(Some(31337));\n+        INT_KEY.replace(Some(31337));\n         fail!();\n     }\n \n@@ -523,9 +523,9 @@ mod tests {\n                 self.tx.send(());\n             }\n         }\n-        static key: Key<Dropper> = &KeyValueKey;\n+        static KEY: Key<Dropper> = &KeyValueKey;\n         let _ = task::try(proc() {\n-            key.replace(Some(Dropper{ tx: tx }));\n+            KEY.replace(Some(Dropper{ tx: tx }));\n         });\n         // At this point the task has been cleaned up and the TLD dropped.\n         // If the channel doesn't have a value now, then the Sender was leaked.\n@@ -534,56 +534,56 @@ mod tests {\n \n     #[test]\n     fn test_static_pointer() {\n-        static key: Key<&'static int> = &KeyValueKey;\n+        static KEY: Key<&'static int> = &KeyValueKey;\n         static VALUE: int = 0;\n-        key.replace(Some(&VALUE));\n+        KEY.replace(Some(&VALUE));\n     }\n \n     #[test]\n     fn test_owned() {\n-        static key: Key<Box<int>> = &KeyValueKey;\n-        key.replace(Some(box 1));\n+        static KEY: Key<Box<int>> = &KeyValueKey;\n+        KEY.replace(Some(box 1));\n \n         {\n-            let k1 = key.get().unwrap();\n-            let k2 = key.get().unwrap();\n-            let k3 = key.get().unwrap();\n+            let k1 = KEY.get().unwrap();\n+            let k2 = KEY.get().unwrap();\n+            let k3 = KEY.get().unwrap();\n             assert_eq!(**k1, 1);\n             assert_eq!(**k2, 1);\n             assert_eq!(**k3, 1);\n         }\n-        key.replace(Some(box 2));\n-        assert_eq!(**key.get().unwrap(), 2);\n+        KEY.replace(Some(box 2));\n+        assert_eq!(**KEY.get().unwrap(), 2);\n     }\n \n     #[test]\n     fn test_same_key_type() {\n-        static key1: Key<int> = &KeyValueKey;\n-        static key2: Key<int> = &KeyValueKey;\n-        static key3: Key<int> = &KeyValueKey;\n-        static key4: Key<int> = &KeyValueKey;\n-        static key5: Key<int> = &KeyValueKey;\n-        key1.replace(Some(1));\n-        key2.replace(Some(2));\n-        key3.replace(Some(3));\n-        key4.replace(Some(4));\n-        key5.replace(Some(5));\n-\n-        assert_eq!(*key1.get().unwrap(), 1);\n-        assert_eq!(*key2.get().unwrap(), 2);\n-        assert_eq!(*key3.get().unwrap(), 3);\n-        assert_eq!(*key4.get().unwrap(), 4);\n-        assert_eq!(*key5.get().unwrap(), 5);\n+        static KEY1: Key<int> = &KeyValueKey;\n+        static KEY2: Key<int> = &KeyValueKey;\n+        static KEY3: Key<int> = &KeyValueKey;\n+        static KEY4: Key<int> = &KeyValueKey;\n+        static KEY5: Key<int> = &KeyValueKey;\n+        KEY1.replace(Some(1));\n+        KEY2.replace(Some(2));\n+        KEY3.replace(Some(3));\n+        KEY4.replace(Some(4));\n+        KEY5.replace(Some(5));\n+\n+        assert_eq!(*KEY1.get().unwrap(), 1);\n+        assert_eq!(*KEY2.get().unwrap(), 2);\n+        assert_eq!(*KEY3.get().unwrap(), 3);\n+        assert_eq!(*KEY4.get().unwrap(), 4);\n+        assert_eq!(*KEY5.get().unwrap(), 5);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_nested_get_set1() {\n-        static key: Key<int> = &KeyValueKey;\n-        assert_eq!(key.replace(Some(4)), None);\n+        static KEY: Key<int> = &KeyValueKey;\n+        assert_eq!(KEY.replace(Some(4)), None);\n \n-        let _k = key.get();\n-        key.replace(Some(4));\n+        let _k = KEY.get();\n+        KEY.replace(Some(4));\n     }\n \n     // ClearKey is a RAII class that ensures the keys are cleared from the map.\n@@ -601,95 +601,95 @@ mod tests {\n \n     #[bench]\n     fn bench_replace_none(b: &mut test::Bencher) {\n-        static key: Key<uint> = &KeyValueKey;\n-        let _clear = ClearKey(key);\n-        key.replace(None);\n+        static KEY: Key<uint> = &KeyValueKey;\n+        let _clear = ClearKey(KEY);\n+        KEY.replace(None);\n         b.iter(|| {\n-            key.replace(None)\n+            KEY.replace(None)\n         });\n     }\n \n     #[bench]\n     fn bench_replace_some(b: &mut test::Bencher) {\n-        static key: Key<uint> = &KeyValueKey;\n-        let _clear = ClearKey(key);\n-        key.replace(Some(1u));\n+        static KEY: Key<uint> = &KeyValueKey;\n+        let _clear = ClearKey(KEY);\n+        KEY.replace(Some(1u));\n         b.iter(|| {\n-            key.replace(Some(2))\n+            KEY.replace(Some(2))\n         });\n     }\n \n     #[bench]\n     fn bench_replace_none_some(b: &mut test::Bencher) {\n-        static key: Key<uint> = &KeyValueKey;\n-        let _clear = ClearKey(key);\n-        key.replace(Some(0u));\n+        static KEY: Key<uint> = &KeyValueKey;\n+        let _clear = ClearKey(KEY);\n+        KEY.replace(Some(0u));\n         b.iter(|| {\n-            let old = key.replace(None).unwrap();\n+            let old = KEY.replace(None).unwrap();\n             let new = old + 1;\n-            key.replace(Some(new))\n+            KEY.replace(Some(new))\n         });\n     }\n \n     #[bench]\n     fn bench_100_keys_replace_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..100] = [KeyValueKey, ..100];\n-        let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n-        for (i, key) in keys.iter().enumerate() {\n+        static KEYS: [KeyValue<uint>, ..100] = [KeyValueKey, ..100];\n+        let _clear = KEYS.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n+        for (i, key) in KEYS.iter().enumerate() {\n             key.replace(Some(i));\n         }\n         b.iter(|| {\n-            let key: Key<uint> = &keys[99];\n+            let key: Key<uint> = &KEYS[99];\n             key.replace(Some(42))\n         });\n     }\n \n     #[bench]\n     fn bench_1000_keys_replace_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..1000] = [KeyValueKey, ..1000];\n-        let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n-        for (i, key) in keys.iter().enumerate() {\n+        static KEYS: [KeyValue<uint>, ..1000] = [KeyValueKey, ..1000];\n+        let _clear = KEYS.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n+        for (i, key) in KEYS.iter().enumerate() {\n             key.replace(Some(i));\n         }\n         b.iter(|| {\n-            let key: Key<uint> = &keys[999];\n+            let key: Key<uint> = &KEYS[999];\n             key.replace(Some(42))\n         });\n-        for key in keys.iter() { key.clear(); }\n+        for key in KEYS.iter() { key.clear(); }\n     }\n \n     #[bench]\n     fn bench_get(b: &mut test::Bencher) {\n-        static key: Key<uint> = &KeyValueKey;\n-        let _clear = ClearKey(key);\n-        key.replace(Some(42));\n+        static KEY: Key<uint> = &KeyValueKey;\n+        let _clear = ClearKey(KEY);\n+        KEY.replace(Some(42));\n         b.iter(|| {\n-            key.get()\n+            KEY.get()\n         });\n     }\n \n     #[bench]\n     fn bench_100_keys_get_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..100] = [KeyValueKey, ..100];\n-        let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n-        for (i, key) in keys.iter().enumerate() {\n+        static KEYS: [KeyValue<uint>, ..100] = [KeyValueKey, ..100];\n+        let _clear = KEYS.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n+        for (i, key) in KEYS.iter().enumerate() {\n             key.replace(Some(i));\n         }\n         b.iter(|| {\n-            let key: Key<uint> = &keys[99];\n+            let key: Key<uint> = &KEYS[99];\n             key.get()\n         });\n     }\n \n     #[bench]\n     fn bench_1000_keys_get_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..1000] = [KeyValueKey, ..1000];\n-        let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n-        for (i, key) in keys.iter().enumerate() {\n+        static KEYS: [KeyValue<uint>, ..1000] = [KeyValueKey, ..1000];\n+        let _clear = KEYS.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n+        for (i, key) in KEYS.iter().enumerate() {\n             key.replace(Some(i));\n         }\n         b.iter(|| {\n-            let key: Key<uint> = &keys[999];\n+            let key: Key<uint> = &KEYS[999];\n             key.get()\n         });\n     }"}, {"sha": "28b0256f2e6e378bffc4435b23f7d3f795caeeab", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -376,8 +376,8 @@ mod imp {\n         #[cfg(target_arch = \"arm\")]\n         static __PTHREAD_COND_SIZE__: uint = 24;\n \n-        static _PTHREAD_MUTEX_SIG_init: libc::c_long = 0x32AAABA7;\n-        static _PTHREAD_COND_SIG_init: libc::c_long = 0x3CB0B1BB;\n+        static _PTHREAD_MUTEX_SIG_INIT: libc::c_long = 0x32AAABA7;\n+        static _PTHREAD_COND_SIG_INIT: libc::c_long = 0x3CB0B1BB;\n \n         #[repr(C)]\n         pub struct pthread_mutex_t {\n@@ -391,11 +391,11 @@ mod imp {\n         }\n \n         pub static PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n-            __sig: _PTHREAD_MUTEX_SIG_init,\n+            __sig: _PTHREAD_MUTEX_SIG_INIT,\n             __opaque: [0, ..__PTHREAD_MUTEX_SIZE__],\n         };\n         pub static PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n-            __sig: _PTHREAD_COND_SIG_init,\n+            __sig: _PTHREAD_COND_SIG_INIT,\n             __opaque: [0, ..__PTHREAD_COND_SIZE__],\n         };\n     }"}, {"sha": "9fbf4d09cd60dbf0c689632c4a2483fe5fdedcef", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -28,7 +28,9 @@ pub static ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n \n pub struct Stdio(libc::c_int);\n \n+#[allow(non_uppercase_statics)]\n pub static Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n+#[allow(non_uppercase_statics)]\n pub static Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n \n impl fmt::FormatWriter for Stdio {"}, {"sha": "654278cf81baf4d9ed3296d2bf032969806f1753", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -360,7 +360,9 @@ fn escape_char(writer: &mut io::Writer, v: char) -> Result<(), io::IoError> {\n }\n \n fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n+    #[allow(non_uppercase_statics)]\n     static len: uint = 16;\n+    #[allow(non_uppercase_statics)]\n     static buf: [u8, ..len] = [b' ', ..len];\n \n     while n >= len {"}, {"sha": "391d099de87c6a8aa5f2983a6fb55a4a522198e6", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -123,7 +123,10 @@ macro_rules! bitflags {\n             bits: $T,\n         }\n \n-        $($(#[$Flag_attr])* pub static $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+        $(\n+            #[allow(non_uppercase_statics)]\n+            $(#[$Flag_attr])* pub static $Flag: $BitFlags = $BitFlags { bits: $value };\n+         )+\n \n         impl $BitFlags {\n             /// Returns an empty set of flags.\n@@ -240,7 +243,10 @@ macro_rules! bitflags {\n         bitflags! {\n             $(#[$attr])*\n             flags $BitFlags: $T {\n-                $($(#[$Flag_attr])* static $Flag = $value),+\n+                $(\n+                    #[allow(non_uppercase_statics)]\n+                    $(#[$Flag_attr])* static $Flag = $value\n+                 ),+\n             }\n         }\n     };"}, {"sha": "ef336bc7b4f99f4a07cfbd773bfeef5551cd83bd", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -11,6 +11,7 @@\n //! Bindings for executing child processes\n \n #![allow(experimental)]\n+#![allow(non_uppercase_statics)]\n \n use prelude::*;\n \n@@ -1024,32 +1025,6 @@ mod tests {\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n     }\n \n-    #[test]\n-    fn test_remove_from_env() {\n-        use os;\n-\n-        // save original environment\n-        let old_env = os::getenv(\"RUN_TEST_NEW_ENV\");\n-\n-        os::setenv(\"RUN_TEST_NEW_ENV\", \"123\");\n-        let prog = env_cmd().env_remove(\"RUN_TEST_NEW_ENV\").spawn().unwrap();\n-        let result = prog.wait_with_output().unwrap();\n-        let output = str::from_utf8_lossy(result.output.as_slice()).into_string();\n-\n-        // restore original environment\n-        match old_env {\n-            None => {\n-                os::unsetenv(\"RUN_TEST_NEW_ENV\");\n-            }\n-            Some(val) => {\n-                os::setenv(\"RUN_TEST_NEW_ENV\", val.as_slice());\n-            }\n-        }\n-\n-        assert!(!output.as_slice().contains(\"RUN_TEST_NEW_ENV\"),\n-                \"found RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n-    }\n-\n     #[cfg(unix)]\n     pub fn sleeper() -> Process {\n         Command::new(\"sleep\").arg(\"1000\").spawn().unwrap()"}, {"sha": "fa356432a673158e7043c48ddf4fe7ddedbecec3", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -304,9 +304,11 @@ macro_rules! println(\n #[macro_export]\n macro_rules! local_data_key(\n     ($name:ident: $ty:ty) => (\n+        #[allow(non_uppercase_statics)]\n         static $name: ::std::local_data::Key<$ty> = &::std::local_data::KeyValueKey;\n     );\n     (pub $name:ident: $ty:ty) => (\n+        #[allow(non_uppercase_statics)]\n         pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::KeyValueKey;\n     );\n )"}, {"sha": "805db000686a02856b0daaacec79973625e55cc6", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -457,7 +457,9 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> {\n     }\n }\n \n+#[allow(non_uppercase_statics)]\n static dot_static: &'static [u8] = b\".\";\n+#[allow(non_uppercase_statics)]\n static dot_dot_static: &'static [u8] = b\"..\";\n \n #[cfg(test)]"}, {"sha": "29eae0ced5412d0663ab53407edd89839748b011", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -233,7 +233,7 @@ use core_rand::IsaacRng as IsaacWordRng;\n use core_rand::Isaac64Rng as IsaacWordRng;\n \n pub use core_rand::{Rand, Rng, SeedableRng, Open01, Closed01};\n-pub use core_rand::{XorShiftRng, IsaacRng, Isaac64Rng};\n+pub use core_rand::{XorShiftRng, IsaacRng, Isaac64Rng, ChaChaRng};\n pub use core_rand::{distributions, reseeding};\n pub use rand::os::OsRng;\n "}, {"sha": "977b3018fa74c24b182f3d630c94faacce26d4f7", "filename": "src/libstd/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -569,10 +569,10 @@ mod test {\n         // climbing the task tree to dereference each ancestor. (See #1789)\n         // (well, it would if the constant were 8000+ - I lowered it to be more\n         // valgrind-friendly. try this at home, instead..!)\n-        static generations: uint = 16;\n+        static GENERATIONS: uint = 16;\n         fn child_no(x: uint) -> proc(): Send {\n             return proc() {\n-                if x < generations {\n+                if x < GENERATIONS {\n                     TaskBuilder::new().spawn(child_no(x+1));\n                 }\n             }"}, {"sha": "3a02d74edffb752f5e553a6a0cb65f7b6944dae0", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -47,7 +47,9 @@ pub enum Architecture {\n     Mipsel\n }\n \n+#[allow(non_uppercase_statics)]\n static IntelBits: u32 = (1 << (X86 as uint)) | (1 << (X86_64 as uint));\n+#[allow(non_uppercase_statics)]\n static ArmBits: u32 = (1 << (Arm as uint));\n \n pub struct AbiData {\n@@ -70,6 +72,7 @@ pub enum AbiArchitecture {\n     Archs(u32)\n }\n \n+#[allow(non_uppercase_statics)]\n static AbiDatas: &'static [AbiData] = &[\n     // Platform-specific ABIs\n     AbiData {abi: Cdecl, name: \"cdecl\", abi_arch: Archs(IntelBits)},"}, {"sha": "f746e1f14822a90fbdbf4fa5e6cd1314d98dcf87", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -293,6 +293,7 @@ pub fn operator_prec(op: ast::BinOp) -> uint {\n \n /// Precedence of the `as` operator, which is a binary operator\n /// not appearing in the prior table.\n+#[allow(non_uppercase_statics)]\n pub static as_prec: uint = 12u;\n \n pub fn empty_generics() -> Generics {"}, {"sha": "4c877c0b101e00e35c86220e2eaa3181358c9648", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -3402,9 +3402,10 @@ impl<'a> Parser<'a> {\n                        binding_mode: ast::BindingMode)\n                        -> ast::Pat_ {\n         if !is_plain_ident(&self.token) {\n-            let last_span = self.last_span;\n-            self.span_fatal(last_span,\n-                            \"expected identifier, found path\");\n+            let span = self.span;\n+            let tok_str = self.this_token_to_string();\n+            self.span_fatal(span,\n+                            format!(\"expected identifier, found `{}`\", tok_str).as_slice());\n         }\n         let ident = self.parse_ident();\n         let last_span = self.last_span;\n@@ -4731,8 +4732,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_item_const(&mut self) -> ItemInfo {\n-        let m = if self.eat_keyword(keywords::Mut) {MutMutable} else {MutImmutable};\n+    fn parse_item_const(&mut self, m: Mutability) -> ItemInfo {\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n         let ty = self.parse_ty(true);\n@@ -5288,7 +5288,26 @@ impl<'a> Parser<'a> {\n         if self.is_keyword(keywords::Static) {\n             // STATIC ITEM\n             self.bump();\n-            let (ident, item_, extra_attrs) = self.parse_item_const();\n+            let m = if self.eat_keyword(keywords::Mut) {MutMutable} else {MutImmutable};\n+            let (ident, item_, extra_attrs) = self.parse_item_const(m);\n+            let last_span = self.last_span;\n+            let item = self.mk_item(lo,\n+                                    last_span.hi,\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return IoviItem(item);\n+        }\n+        if self.is_keyword(keywords::Const) {\n+            // CONST ITEM\n+            self.bump();\n+            if self.eat_keyword(keywords::Mut) {\n+                let last_span = self.last_span;\n+                self.span_err(last_span, \"const globals cannot be mutable, \\\n+                                          did you mean to declare a static?\");\n+            }\n+            let (ident, item_, extra_attrs) = self.parse_item_const(MutImmutable);\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,"}, {"sha": "a8c827439cc605a6dfc31f3e605e4b47d882f34b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -383,12 +383,15 @@ macro_rules! declare_special_idents_and_keywords {(\n \n     pub mod special_idents {\n         use ast::{Ident, Name};\n-        $( pub static $si_static: Ident = Ident { name: Name($si_name), ctxt: 0 }; )*\n+        $(\n+            #[allow(non_uppercase_statics)]\n+            pub static $si_static: Ident = Ident { name: Name($si_name), ctxt: 0 };\n+         )*\n     }\n \n     pub mod special_names {\n         use ast::Name;\n-        $( pub static $si_static: Name =  Name($si_name); )*\n+        $( #[allow(non_uppercase_statics)] pub static $si_static: Name =  Name($si_name); )*\n     }\n \n     /**"}, {"sha": "c3a3848019a5dacd862144f3575e9c93df3b6095", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -89,8 +89,10 @@ pub fn rust_printer_annotated<'a>(writer: Box<io::Writer+'static>,\n     }\n }\n \n+#[allow(non_uppercase_statics)]\n pub static indent_unit: uint = 4u;\n \n+#[allow(non_uppercase_statics)]\n pub static default_columns: uint = 78u;\n \n /// Requires you to pass an input filename and reader so that"}, {"sha": "c0c3f707ecb3c80dad0e59185a49fe55db2eeb07", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -173,6 +173,7 @@ impl fmt::Show for ParseError {\n }\n \n // Length of each hyphenated group in hex digits\n+#[allow(non_uppercase_statics)]\n static UuidGroupLens: [uint, ..5] = [8u, 4u, 4u, 4u, 12u];\n \n /// UUID support"}, {"sha": "1d14da73b7eebd80fc2339a1f10144a4c487d714", "filename": "src/test/compile-fail-fulldeps/syntax-extension-regex-unused-static.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -17,6 +17,7 @@ extern crate regex;\n \n #[deny(unused_variable)]\n #[deny(dead_code)]\n+#[allow(non_uppercase_statics)]\n \n // Tests to make sure that extraneous dead code warnings aren't emitted from\n // the code generated by regex!."}, {"sha": "74bfc6e6ffc1fb7777419194875c3d5e14c552d8", "filename": "src/test/compile-fail/asm-misplaced-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(asm)]\n \n-#![allow(dead_code)]\n+#![allow(dead_code, non_uppercase_statics)]\n \n #[cfg(any(target_arch = \"x86\",\n           target_arch = \"x86_64\"))]"}, {"sha": "59499ac070d6d536b36d4a5a260c87eacaa0e096", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n     let f1 = Fat { ptr: [1, 2, 3] };\n     let f2: &Fat<[int, ..3]> = &f1;\n     let f3: &Fat<[uint]> = f2;\n-    //~^ ERROR mismatched types: expected `&Fat<[uint]>`, found `&Fat<[int, .. 3]>`\n+    //~^ ERROR mismatched types: expected `&Fat<[uint]>`, found `&Fat<[int, ..3]>`\n \n     // With a trait.\n     let f1 = Fat { ptr: Foo };"}, {"sha": "9010185f76b6ad2ddeb7e5b5149897814cbe7e8b", "filename": "src/test/compile-fail/dst-bad-coerce4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -18,5 +18,5 @@ pub fn main() {\n     // With a vec of ints.\n     let f1: &Fat<[int]> = &Fat { ptr: [1, 2, 3] };\n     let f2: &Fat<[int, ..3]> = f1;\n-    //~^ ERROR mismatched types: expected `&Fat<[int, .. 3]>`, found `&Fat<[int]>`\n+    //~^ ERROR mismatched types: expected `&Fat<[int, ..3]>`, found `&Fat<[int]>`\n }"}, {"sha": "e5d87395286e4cd2c438c0207504c49b2dc4f310", "filename": "src/test/compile-fail/issue-13482.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -12,7 +12,7 @@ fn main() {\n   let x = [1,2];\n   let y = match x {\n     [] => None,\n-//~^ ERROR expected `[<generic integer #0>, .. 2]`, found a fixed vector pattern of size 0\n+//~^ ERROR expected `[<generic integer #0>, ..2]`, found a fixed vector pattern of size 0\n     [a,_] => Some(a)\n   };\n }"}, {"sha": "bc606d8139f0144aa1a696b654bce35fc1bea9fe", "filename": "src/test/compile-fail/issue-14845.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -16,9 +16,9 @@ struct X {\n fn main() {\n     let x = X { a: [0] };\n     let _f = &x.a as *mut u8;\n-    //~^ ERROR mismatched types: expected `*mut u8`, found `&[u8, .. 1]`\n+    //~^ ERROR mismatched types: expected `*mut u8`, found `&[u8, ..1]`\n \n     let local = [0u8];\n     let _v = &local as *mut u8;\n-    //~^ ERROR mismatched types: expected `*mut u8`, found `&[u8, .. 1]`\n+    //~^ ERROR mismatched types: expected `*mut u8`, found `&[u8, ..1]`\n }"}, {"sha": "45b3abfddfba2f14d642b6254cbb07860ab2e3d2", "filename": "src/test/compile-fail/issue-15914.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-15914.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-15914.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15914.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let ref\n+        (); //~ ERROR expected identifier, found `(`\n+}"}, {"sha": "e0f655084ff700634a5d492a0fceaa2d04086ae2", "filename": "src/test/compile-fail/issue-17337.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(deprecated)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    #[deprecated]\n+    fn foo(self) {}\n+}\n+\n+fn main() {\n+    Foo\n+    .foo(); //~ ERROR use of deprecated item\n+}"}, {"sha": "da5590971bc3c9c2657113fb5ff94a0928cae830", "filename": "src/test/compile-fail/issue-17441.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let _foo = &[1u, 2] as [uint];\n-    //~^ ERROR cast to unsized type: `&[uint, .. 2]` as `[uint]`\n+    //~^ ERROR cast to unsized type: `&[uint, ..2]` as `[uint]`\n     //~^^ NOTE consider using an implicit coercion to `&[uint]` instead\n     let _bar = box 1u as std::fmt::Show;\n     //~^ ERROR cast to unsized type: `Box<uint>` as `core::fmt::Show`\n@@ -19,6 +19,6 @@ fn main() {\n     //~^ ERROR cast to unsized type: `uint` as `core::fmt::Show`\n     //~^^ NOTE consider using a box or reference as appropriate\n     let _quux = [1u, 2] as [uint];\n-    //~^ ERROR cast to unsized type: `[uint, .. 2]` as `[uint]`\n+    //~^ ERROR cast to unsized type: `[uint, ..2]` as `[uint]`\n     //~^^ NOTE consider using a box or reference as appropriate\n }"}, {"sha": "31a5fee2044dc878259c2c8b742ff7e77fadf314", "filename": "src/test/compile-fail/issue-17718-const-mut.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-mut.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const\n+mut //~ ERROR: const globals cannot be mutable, did you mean to declare a static?\n+FOO: uint = 3;\n+\n+fn main() {\n+}\n+"}, {"sha": "81f57dd96402b63d5e3d19042bf0cc63211525e2", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -22,5 +22,5 @@ impl<A> vec_monad<A> for Vec<A> {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR type `[&str, .. 1]` does not implement any method in scope named `bind`\n+    //~^ ERROR type `[&str, ..1]` does not implement any method in scope named `bind`\n }"}, {"sha": "f61ed35fca3595cc0d8054726181a6355848b17c", "filename": "src/test/compile-fail/issue-4517.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -13,6 +13,6 @@ fn bar(int_param: int) {}\n fn main() {\n     let foo: [u8, ..4] = [1u8, ..4u];\n     bar(foo);\n-    //~^ ERROR mismatched types: expected `int`, found `[u8, .. 4]`\n+    //~^ ERROR mismatched types: expected `int`, found `[u8, ..4]`\n     //         (expected int, found vector)\n }"}, {"sha": "30d3ab17a463e6622480b0e22fbf7478b7b225a1", "filename": "src/test/compile-fail/issue-6804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -30,4 +30,4 @@ fn main() {\n \n // At least one error is needed so that compilation fails\n #[static_assert]\n-static b: bool = false; //~ ERROR static assertion failed\n+static B: bool = false; //~ ERROR static assertion failed"}, {"sha": "45380235a2a8b34aa546620e53eae95a9c92d7e7", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -11,6 +11,7 @@\n #![no_std]\n #![allow(unused_variable)]\n #![allow(non_camel_case_types)]\n+#![allow(non_uppercase_statics)]\n #![deny(dead_code)]\n #![feature(lang_items)]\n "}, {"sha": "bbd88f1f0aade81ebc1e283572bf2598235156c0", "filename": "src/test/compile-fail/lint-directives-on-use-items-issue-10534.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Flint-directives-on-use-items-issue-10534.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Flint-directives-on-use-items-issue-10534.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-directives-on-use-items-issue-10534.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![deny(unused_imports)]\n+#![allow(non_uppercase_statics)]\n \n // The aim of this test is to ensure that deny/allow/warn directives\n // are applied to individual \"use\" statements instead of silently"}, {"sha": "6cfdc6ad90b91eae7bc309e676c562b1769a609d", "filename": "src/test/compile-fail/lint-non-snake-case-functions.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Flint-non-snake-case-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fcompile-fail%2Flint-non-snake-case-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-non-snake-case-functions.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -23,11 +23,14 @@ impl Foo {\n \n     pub fn xyZ(&mut self) {}\n     //~^ ERROR method `xyZ` should have a snake case name such as `xy_z`\n+\n+    fn render_HTML() {}\n+    //~^ ERROR method `render_HTML` should have a snake case name such as `render_html`\n }\n \n trait X {\n     fn ABC();\n-    //~^ ERROR trait method `ABC` should have a snake case name such as `a_b_c`\n+    //~^ ERROR trait method `ABC` should have a snake case name such as `abc`\n \n     fn a_b_C(&self) {}\n     //~^ ERROR trait method `a_b_C` should have a snake case name such as `a_b_c`"}, {"sha": "2bc09d7e96e58bc9dca3ef0dca9a6bedb66d9dd1", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -26,33 +26,33 @@\n \n pub fn bar() {\n     static FOO: uint = ((5u as uint) - (4u as uint) as uint);\n-    let _: [(), ..(FOO as uint)] = ([(() as ())] as [(), .. 1]);\n+    let _: [(), ..(FOO as uint)] = ([(() as ())] as [(), ..1]);\n \n-    let _: [(), ..(1u as uint)] = ([(() as ())] as [(), .. 1]);\n+    let _: [(), ..(1u as uint)] = ([(() as ())] as [(), ..1]);\n \n     let _ =\n-        (((&((([(1i as int), (2 as int), (3 as int)] as [int, .. 3])) as\n-                [int, .. 3]) as &[int, .. 3]) as *const _ as\n-             *const [int, .. 3]) as *const [int, ..(3u as uint)] as\n-            *const [int, .. 3]);\n+        (((&((([(1i as int), (2 as int), (3 as int)] as [int, ..3])) as\n+                [int, ..3]) as &[int, ..3]) as *const _ as *const [int, ..3])\n+            as *const [int, ..(3u as uint)] as *const [int, ..3]);\n+\n     (match (() as ()) {\n          () => {\n              #[inline]\n              #[allow(dead_code)]\n              static __STATIC_FMTSTR: [&'static str, ..(1u as uint)] =\n-                 ([(\"test\" as &'static str)] as [&'static str, .. 1]);\n+                 ([(\"test\" as &'static str)] as [&'static str, ..1]);\n              let __args_vec =\n-                 (&([] as [core::fmt::Argument<'_>, .. 0]) as\n-                     &[core::fmt::Argument<'_>, .. 0]);\n+                 (&([] as [core::fmt::Argument<'_>, ..0]) as\n+                     &[core::fmt::Argument<'_>, ..0]);\n              let __args =\n                  (unsafe {\n                       ((::std::fmt::Arguments::new as\n                            unsafe fn(&'static [&'static str], &'a [core::fmt::Argument<'a>]) -> core::fmt::Arguments<'a>)((__STATIC_FMTSTR\n                                                                                                                               as\n-                                                                                                                              [&'static str, .. 1]),\n+                                                                                                                              [&'static str, ..1]),\n                                                                                                                           (__args_vec\n                                                                                                                               as\n-                                                                                                                              &[core::fmt::Argument<'_>, .. 0]))\n+                                                                                                                              &[core::fmt::Argument<'_>, ..0]))\n                           as core::fmt::Arguments<'_>)\n                   } as core::fmt::Arguments<'_>);\n \n@@ -83,8 +83,8 @@\n pub fn use_id() {\n     let _ =\n         ((id::<[int, ..(3u as uint)]> as\n-             fn([int, .. 3]) -> [int, .. 3])(([(1 as int), (2 as int),\n-                                               (3 as int)] as [int, .. 3])) as\n-            [int, .. 3]);\n+             fn([int, ..3]) -> [int, ..3])(([(1 as int), (2 as int),\n+                                             (3 as int)] as [int, ..3])) as\n+            [int, ..3]);\n }\n fn main() { }"}, {"sha": "1d49823101855b150c31c83fcde616243a09ad47", "filename": "src/test/run-make/rustdoc-where/verify.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Frun-make%2Frustdoc-where%2Fverify.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Frun-make%2Frustdoc-where%2Fverify.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-where%2Fverify.sh?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/bin/sh\n set -e\n \n # $1 is the TMPDIR"}, {"sha": "3ca6f473a7900a6fe3de06c98b6166b16ea04e44", "filename": "src/test/run-pass/issue-17718-parse-const.rs", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Frun-pass%2Fissue-17718-parse-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Frun-pass%2Fissue-17718-parse-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718-parse-const.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,4 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const i: int = 42; //~ ERROR expected item, found `const`\n+const FOO: uint = 3;\n+\n+fn main() {\n+    assert_eq!(FOO, 3);\n+}", "previous_filename": "src/test/compile-fail/removed-syntax-const-item.rs"}, {"sha": "eab9c8a95da2c20c8e28a654890a8bf19e9f51c6", "filename": "src/test/run-pass/process-remove-from-env.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae81c89f34f1ac2cdb596cf216612e94822a8466/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs?ref=ae81c89f34f1ac2cdb596cf216612e94822a8466", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::Command;\n+use std::os;\n+\n+#[cfg(all(unix, not(target_os=\"android\")))]\n+pub fn env_cmd() -> Command {\n+    Command::new(\"env\")\n+}\n+#[cfg(target_os=\"android\")]\n+pub fn env_cmd() -> Command {\n+    let mut cmd = Command::new(\"/system/bin/sh\");\n+    cmd.arg(\"-c\").arg(\"set\");\n+    cmd\n+}\n+\n+#[cfg(windows)]\n+pub fn env_cmd() -> Command {\n+    let mut cmd = Command::new(\"cmd\");\n+    cmd.arg(\"/c\").arg(\"set\");\n+    cmd\n+}\n+\n+fn main() {\n+    // save original environment\n+    let old_env = os::getenv(\"RUN_TEST_NEW_ENV\");\n+\n+    os::setenv(\"RUN_TEST_NEW_ENV\", \"123\");\n+\n+    let mut cmd = env_cmd();\n+    cmd.env_remove(\"RUN_TEST_NEW_ENV\");\n+\n+    // restore original environment\n+    match old_env {\n+        None => os::unsetenv(\"RUN_TEST_NEW_ENV\"),\n+        Some(val) => os::setenv(\"RUN_TEST_NEW_ENV\", val.as_slice())\n+    }\n+\n+    let prog = cmd.spawn().unwrap();\n+    let result = prog.wait_with_output().unwrap();\n+    let output = String::from_utf8_lossy(result.output.as_slice());\n+\n+    assert!(!output.as_slice().contains(\"RUN_TEST_NEW_ENV\"),\n+            \"found RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n+}"}]}