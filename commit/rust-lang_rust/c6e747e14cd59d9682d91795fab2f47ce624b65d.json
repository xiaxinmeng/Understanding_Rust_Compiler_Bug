{"sha": "c6e747e14cd59d9682d91795fab2f47ce624b65d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZTc0N2UxNGNkNTlkOTY4MmQ5MTc5NWZhYjJmNDdjZTYyNGI2NWQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-14T07:33:37Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-14T07:33:37Z"}, "message": "Merge remote-tracking branch 'origin/master' into str-index-mut", "tree": {"sha": "6685822608e8dc0b714559f47b16ccbdeabc6897", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6685822608e8dc0b714559f47b16ccbdeabc6897"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6e747e14cd59d9682d91795fab2f47ce624b65d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6e747e14cd59d9682d91795fab2f47ce624b65d", "html_url": "https://github.com/rust-lang/rust/commit/c6e747e14cd59d9682d91795fab2f47ce624b65d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6e747e14cd59d9682d91795fab2f47ce624b65d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5972c38a3322e8ab98aead64d75f63fe4c7c75d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5972c38a3322e8ab98aead64d75f63fe4c7c75d", "html_url": "https://github.com/rust-lang/rust/commit/e5972c38a3322e8ab98aead64d75f63fe4c7c75d"}, {"sha": "39275ab9f7f4f7afffd634a5b3377b94fcc6f122", "url": "https://api.github.com/repos/rust-lang/rust/commits/39275ab9f7f4f7afffd634a5b3377b94fcc6f122", "html_url": "https://github.com/rust-lang/rust/commit/39275ab9f7f4f7afffd634a5b3377b94fcc6f122"}], "stats": {"total": 1159, "additions": 820, "deletions": 339}, "files": [{"sha": "a46214a3c45c61b42f71005f5651942a6fcc5590", "filename": ".appveyor.yml", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/.appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/.appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.appveyor.yml?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "previous_filename": "appveyor.yml"}, {"sha": "721ebe5cfd46b972a7241d1039081aeb2eb81a03", "filename": "Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -39,6 +39,7 @@ directories = { version = \"1.0\", optional = true }\n rustc_version = { version = \"0.2.3\", optional = true }\n env_logger = \"0.6\"\n log = \"0.4\"\n+shell-escape = \"0.1.4\"\n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n # for more information.\n@@ -55,3 +56,6 @@ rustc_tests = []\n [dev-dependencies]\n compiletest_rs = { version = \"0.3.17\", features = [\"tmp\"] }\n colored = \"1.6\"\n+\n+[profile.release]\n+debug = true"}, {"sha": "21e9fa43a8f8c55ec53ea6759de1dc73154928e2", "filename": "README.md", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -48,12 +48,19 @@ Now you can run your project in Miri:\n 3. If you have a binary project, you can run it through Miri using `cargo\n    +nightly miri run`.\n \n-When running code via `cargo miri`, the `cargo-miri` feature is set.  You can\n+You can pass arguments to Miri after the first `--`, and pass arguments to the\n+interpreted program or test suite after the second `--`.  For example, `cargo\n++nightly miri run -- -Zmiri-disable-validation` runs the program without\n+validation of basic type invariants and references.  `cargo +nightly miri test\n+-- -- filter` passes `filter` to the test suite the same way `cargo test filter`\n+would.\n+\n+When running code via `cargo miri`, the `miri` config flag is set.  You can\n use this to exclude test cases that will fail under Miri because they do things\n Miri does not support:\n \n ```rust\n-#[cfg(not(feature = \"cargo-miri\"))]\n+#[cfg(not(miri))]\n #[test]\n fn does_not_work_on_miri() {\n     let x = 0u8;"}, {"sha": "404fe7ae91501928f0b86740aa61af7323a8cd44", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -4,11 +4,13 @@ extern crate rustc;\n extern crate rustc_driver;\n extern crate test;\n \n-use self::miri::eval_main;\n-use self::rustc_driver::{driver, Compilation};\n+use rustc_driver::{driver, Compilation};\n use rustc::hir::def_id::LOCAL_CRATE;\n use std::cell::RefCell;\n use std::rc::Rc;\n+\n+use miri::{MiriConfig, eval_main};\n+\n use crate::test::Bencher;\n \n pub struct MiriCompilerCalls<'a>(Rc<RefCell<&'a mut Bencher>>);\n@@ -50,7 +52,8 @@ pub fn run(filename: &str, bencher: &mut Bencher) {\n         );\n \n         bencher.borrow_mut().iter(|| {\n-            eval_main(tcx, entry_def_id, false);\n+            let config = MiriConfig { validate: true, args: vec![] };\n+            eval_main(tcx, entry_def_id, config);\n         });\n \n         state.session.abort_if_errors();"}, {"sha": "b265e000950eb2da528f251f5903435a5cdf37b5", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1 +1 @@\n-nightly-2019-01-30\n+nightly-2019-02-13"}, {"sha": "bca2b6df1b40bec717c83325b1ac22c464fb5e9e", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 205, "deletions": 181, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -7,10 +7,10 @@ use std::io::{self, Write, BufRead};\n use std::process::Command;\n use std::fs::{self, File};\n \n-const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates\n+const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates and tests in Miri\n \n Usage:\n-    cargo miri [subcommand] [options] [--] [<opts>...]\n+    cargo miri [subcommand] [options] [--] [<miri opts>...] [--] [<program opts>...]\n \n Subcommands:\n     run                      Run binaries (default)\n@@ -22,12 +22,14 @@ Common options:\n     --features               Features to compile for the package\n     -V, --version            Print version info and exit\n \n-Other options are the same as `cargo rustc`.\n+Other [options] are the same as `cargo rustc`.  Everything after the first \"--\" is\n+passed verbatim to Miri, which will pass everything after the second \"--\" verbatim\n+to the interpreted program.\n \n-The feature `cargo-miri` is automatically defined for convenience. You can use\n+The config flag `miri` is automatically defined for convenience. You can use\n it to configure the resource limits\n \n-    #![cfg_attr(feature = \"cargo-miri\", memory_size = 42)]\n+    #![cfg_attr(miri, memory_size = 42)]\n \n available resource limits are `memory_size`, `step_limit`, `stack_limit`\n \"#;\n@@ -53,23 +55,32 @@ fn show_error(msg: String) -> ! {\n     std::process::exit(1)\n }\n \n+// Determines whether a --flag is present\n+fn has_arg_flag(name: &str) -> bool {\n+    let mut args = std::env::args().take_while(|val| val != \"--\");\n+    args.any(|val| val == name)\n+}\n+\n+/// Gets the value of a --flag\n fn get_arg_flag_value(name: &str) -> Option<String> {\n     // stop searching at `--`\n-    let mut args = std::env::args().skip_while(|val| !(val.starts_with(name) || val == \"--\"));\n-\n-    match args.next() {\n-        Some(ref p) if p == \"--\" => None,\n-        Some(ref p) if p == name => args.next(),\n-        Some(p) => {\n-            // Make sure this really starts with `$name=`, we didn't test for the `=` yet.\n-            let v = &p[name.len()..]; // strip leading `$name`\n-            if v.starts_with('=') {\n-                Some(v[1..].to_owned()) // strip leading `=`\n-            } else {\n-                None\n-            }\n-        },\n-        None => None,\n+    let mut args = std::env::args().take_while(|val| val != \"--\");\n+    loop {\n+        let arg = match args.next() {\n+            Some(arg) => arg,\n+            None => return None,\n+        };\n+        if !arg.starts_with(name) {\n+            continue;\n+        }\n+        let suffix = &arg[name.len()..]; // strip leading `name`\n+        if suffix.is_empty() {\n+            // This argument is exactly `name`, the next one is the value\n+            return args.next();\n+        } else if suffix.starts_with('=') {\n+            // This argument is `name=value`, get the value\n+            return Some(suffix[1..].to_owned()); // strip leading `=`\n+        }\n     }\n }\n \n@@ -182,18 +193,21 @@ fn setup(ask_user: bool) {\n         }\n     }\n \n-    // Then, we also need rust-src.  Let's see if it is already installed.\n-    let sysroot = Command::new(\"rustc\").args(&[\"--print\", \"sysroot\"]).output().unwrap().stdout;\n-    let sysroot = std::str::from_utf8(&sysroot[..]).unwrap();\n-    let src = Path::new(sysroot.trim_end_matches('\\n')).join(\"lib\").join(\"rustlib\").join(\"src\");\n-    if !src.exists() {\n-        if ask_user {\n-            ask(\"It seems you do not have the rust-src component installed. I will run `rustup component add rust-src`. Proceed?\");\n-        } else {\n-            println!(\"Installing rust-src component: `rustup component add rust-src`\");\n-        }\n-        if !Command::new(\"rustup\").args(&[\"component\", \"add\", \"rust-src\"]).status().unwrap().success() {\n-            show_error(format!(\"Failed to install rust-src component\"));\n+    // Then, unless XARGO_RUST_SRC is set, we also need rust-src.\n+    // Let's see if it is already installed.\n+    if std::env::var(\"XARGO_RUST_SRC\").is_err() {\n+        let sysroot = Command::new(\"rustc\").args(&[\"--print\", \"sysroot\"]).output().unwrap().stdout;\n+        let sysroot = std::str::from_utf8(&sysroot[..]).unwrap();\n+        let src = Path::new(sysroot.trim_end_matches('\\n')).join(\"lib\").join(\"rustlib\").join(\"src\");\n+        if !src.exists() {\n+            if ask_user {\n+                ask(\"It seems you do not have the rust-src component installed. I will run `rustup component add rust-src`. Proceed?\");\n+            } else {\n+                println!(\"Installing rust-src component: `rustup component add rust-src`\");\n+            }\n+            if !Command::new(\"rustup\").args(&[\"component\", \"add\", \"rust-src\"]).status().unwrap().success() {\n+                show_error(format!(\"Failed to install rust-src component\"));\n+            }\n         }\n     }\n \n@@ -272,167 +286,177 @@ fn main() {\n         // each applicable target, but with the RUSTC env var set to the `cargo-miri`\n         // binary so that we come back in the other branch, and dispatch\n         // the invocations to rustc and miri, respectively.\n-\n-        let (subcommand, skip) = match std::env::args().nth(2).deref() {\n-            Some(\"test\") => (MiriCommand::Test, 3),\n-            Some(\"run\") => (MiriCommand::Run, 3),\n-            Some(\"setup\") => (MiriCommand::Setup, 3),\n-            // Default command, if there is an option or nothing\n-            Some(s) if s.starts_with(\"-\") => (MiriCommand::Run, 2),\n-            None => (MiriCommand::Run, 2),\n-            // Unvalid command\n-            Some(s) => {\n-                show_error(format!(\"Unknown command `{}`\", s))\n-            }\n-        };\n-\n-        // We always setup\n-        let ask = subcommand != MiriCommand::Setup;\n-        setup(ask);\n-        if subcommand == MiriCommand::Setup {\n-            // Stop here.\n-            return;\n-        }\n-\n-        // Now run the command.\n-        for target in list_targets() {\n-            let args = std::env::args().skip(skip);\n-            let kind = target.kind.get(0).expect(\n-                \"badly formatted cargo metadata: target::kind is an empty array\",\n-            );\n-            match (subcommand, &kind[..]) {\n-                (MiriCommand::Test, \"test\") => {\n-                    // For test binaries we call `cargo rustc --test target -- <rustc args>`\n-                    if let Err(code) = process(\n-                        vec![\"--test\".to_string(), target.name].into_iter().chain(\n-                            args,\n-                        ),\n-                    )\n-                    {\n-                        std::process::exit(code);\n-                    }\n-                }\n-                (MiriCommand::Test, \"lib\") => {\n-                    // For libraries we call `cargo rustc -- --test <rustc args>`\n-                    // Notice now that `--test` is a rustc arg rather than a cargo arg. This tells\n-                    // rustc to build a test harness which calls all #[test] functions.\n-                    // We then execute that harness just like any other binary.\n-                    if let Err(code) = process(\n-                        vec![\"--\".to_string(), \"--test\".to_string()].into_iter().chain(\n-                            args,\n-                        ),\n-                    )\n-                    {\n-                        std::process::exit(code);\n-                    }\n-                }\n-                (MiriCommand::Run, \"bin\") => {\n-                    // For ordinary binaries we call `cargo rustc --bin target -- <rustc args>`\n-                    if let Err(code) = process(\n-                        vec![\"--bin\".to_string(), target.name].into_iter().chain(\n-                            args,\n-                        ),\n-                    )\n-                    {\n-                        std::process::exit(code);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n+        in_cargo_miri();\n     } else if let Some(\"rustc\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n         // This arm is executed when cargo-miri runs `cargo rustc` with the `RUSTC_WRAPPER` env var set to itself:\n         // Dependencies get dispatched to rustc, the final test/binary to miri.\n+        inside_cargo_rustc();\n+    } else {\n+        show_error(format!(\"Must be called with either `miri` or `rustc` as first argument.\"))\n+    }\n+}\n \n-        let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n-        let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n-        let sys_root = if let Ok(sysroot) = ::std::env::var(\"MIRI_SYSROOT\") {\n-            sysroot\n-        } else if let (Some(home), Some(toolchain)) = (home, toolchain) {\n-            format!(\"{}/toolchains/{}\", home, toolchain)\n-        } else {\n-            option_env!(\"RUST_SYSROOT\")\n-                .map(|s| s.to_owned())\n-                .or_else(|| {\n-                    Command::new(\"rustc\")\n-                        .arg(\"--print\")\n-                        .arg(\"sysroot\")\n-                        .output()\n-                        .ok()\n-                        .and_then(|out| String::from_utf8(out.stdout).ok())\n-                        .map(|s| s.trim().to_owned())\n-                })\n-                .expect(\"need to specify RUST_SYSROOT env var during miri compilation, or use rustup or multirust\")\n-        };\n+fn in_cargo_miri() {\n+    let (subcommand, skip) = match std::env::args().nth(2).deref() {\n+        Some(\"test\") => (MiriCommand::Test, 3),\n+        Some(\"run\") => (MiriCommand::Run, 3),\n+        Some(\"setup\") => (MiriCommand::Setup, 3),\n+        // Default command, if there is an option or nothing\n+        Some(s) if s.starts_with(\"-\") => (MiriCommand::Run, 2),\n+        None => (MiriCommand::Run, 2),\n+        // Unvalid command\n+        Some(s) => {\n+            show_error(format!(\"Unknown command `{}`\", s))\n+        }\n+    };\n+    let verbose = has_arg_flag(\"-v\");\n \n-        // this conditional check for the --sysroot flag is there so users can call `cargo-miri` directly\n-        // without having to pass --sysroot or anything\n-        let rustc_args = std::env::args().skip(2);\n-        let mut args: Vec<String> = if std::env::args().any(|s| s == \"--sysroot\") {\n-            rustc_args.collect()\n-        } else {\n-            rustc_args\n-                .chain(Some(\"--sysroot\".to_owned()))\n-                .chain(Some(sys_root))\n-                .collect()\n-        };\n-        args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n-        args.extend_from_slice(&[\"--cfg\".to_owned(), r#\"feature=\"cargo-miri\"\"#.to_owned()]);\n-\n-        // this check ensures that dependencies are built but not interpreted and the final crate is\n-        // interpreted but not built\n-        let miri_enabled = std::env::args().any(|s| s == \"--emit=dep-info,metadata\");\n-        let mut command = if miri_enabled {\n-            let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n-            path.set_file_name(\"miri\");\n-            Command::new(path)\n-        } else {\n-            Command::new(\"rustc\")\n-        };\n-        command.args(&args);\n+    // We always setup\n+    let ask = subcommand != MiriCommand::Setup;\n+    setup(ask);\n+    if subcommand == MiriCommand::Setup {\n+        // Stop here.\n+        return;\n+    }\n \n-        match command.status() {\n-            Ok(exit) => {\n-                if !exit.success() {\n-                    std::process::exit(exit.code().unwrap_or(42));\n-                }\n+    // Now run the command.\n+    for target in list_targets() {\n+        let mut args = std::env::args().skip(skip);\n+        let kind = target.kind.get(0).expect(\n+            \"badly formatted cargo metadata: target::kind is an empty array\",\n+        );\n+        // Now we run `cargo rustc $FLAGS $ARGS`, giving the user the\n+        // change to add additional flags.  \"FLAGS\" is set to identify\n+        // this target.  The user gets to control what gets actually passed to Miri.\n+        // However, we need to add a flag to what gets passed to rustc for the finaly\n+        // binary, so that we know to interpret that with Miri.\n+        // So after the first \"--\", we add \"-Zcargo-miri-marker\".\n+        let mut cmd = Command::new(\"cargo\");\n+        cmd.arg(\"rustc\");\n+        match (subcommand, &kind[..]) {\n+            (MiriCommand::Run, \"bin\") => {\n+                // FIXME: We just run all the binaries here.\n+                // We should instead support `cargo miri --bin foo`.\n+                cmd.arg(\"--bin\").arg(target.name);\n             }\n-            Err(ref e) if miri_enabled => panic!(\"error during miri run: {:?}\", e),\n-            Err(ref e) => panic!(\"error during rustc call: {:?}\", e),\n+            (MiriCommand::Test, \"test\") => {\n+                cmd.arg(\"--test\").arg(target.name);\n+            }\n+            (MiriCommand::Test, \"lib\") => {\n+                // There can be only one lib\n+                cmd.arg(\"--lib\").arg(\"--profile\").arg(\"test\");\n+            }\n+            (MiriCommand::Test, \"bin\") => {\n+                cmd.arg(\"--bin\").arg(target.name).arg(\"--profile\").arg(\"test\");\n+            }\n+            // The remaining targets we do not even want to build\n+            _ => continue,\n+        }\n+        // add user-defined args until first \"--\"\n+        while let Some(arg) = args.next() {\n+            if arg == \"--\" {\n+                break;\n+            }\n+            cmd.arg(arg);\n+        }\n+        // Add \"--\" (to end the cargo flags), and then the user flags.  We add markers around the user flags\n+        // to be able to identify them later.\n+        cmd\n+            .arg(\"--\")\n+            .arg(\"cargo-miri-marker-begin\")\n+            .args(args)\n+            .arg(\"cargo-miri-marker-end\");\n+        let path = std::env::current_exe().expect(\"current executable path invalid\");\n+        cmd.env(\"RUSTC_WRAPPER\", path);\n+        if verbose {\n+            eprintln!(\"+ {:?}\", cmd);\n+        }\n+\n+        let exit_status = cmd\n+            .spawn()\n+            .expect(\"could not run cargo\")\n+            .wait()\n+            .expect(\"failed to wait for cargo?\");\n+\n+        if !exit_status.success() {\n+            std::process::exit(exit_status.code().unwrap_or(-1))\n         }\n-    } else {\n-        show_error(format!(\"Must be called with either `miri` or `rustc` as first argument.\"))\n     }\n }\n \n-fn process<I>(old_args: I) -> Result<(), i32>\n-where\n-    I: Iterator<Item = String>,\n-{\n-    let mut args = vec![\"rustc\".to_owned()];\n+fn inside_cargo_rustc() {\n+    let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n+    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n+    let sys_root = if let Ok(sysroot) = ::std::env::var(\"MIRI_SYSROOT\") {\n+        sysroot\n+    } else if let (Some(home), Some(toolchain)) = (home, toolchain) {\n+        format!(\"{}/toolchains/{}\", home, toolchain)\n+    } else {\n+        option_env!(\"RUST_SYSROOT\")\n+            .map(|s| s.to_owned())\n+            .or_else(|| {\n+                Command::new(\"rustc\")\n+                    .arg(\"--print\")\n+                    .arg(\"sysroot\")\n+                    .output()\n+                    .ok()\n+                    .and_then(|out| String::from_utf8(out.stdout).ok())\n+                    .map(|s| s.trim().to_owned())\n+            })\n+            .expect(\"need to specify RUST_SYSROOT env var during miri compilation, or use rustup or multirust\")\n+    };\n \n-    let mut found_dashes = false;\n-    for arg in old_args {\n-        found_dashes |= arg == \"--\";\n-        args.push(arg);\n-    }\n-    if !found_dashes {\n-        args.push(\"--\".to_owned());\n-    }\n-    args.push(\"--emit=dep-info,metadata\".to_owned());\n-\n-    let path = std::env::current_exe().expect(\"current executable path invalid\");\n-    let exit_status = Command::new(\"cargo\")\n-        .args(&args)\n-        .env(\"RUSTC_WRAPPER\", path)\n-        .spawn()\n-        .expect(\"could not run cargo\")\n-        .wait()\n-        .expect(\"failed to wait for cargo?\");\n-\n-    if exit_status.success() {\n-        Ok(())\n+    // this conditional check for the --sysroot flag is there so users can call `cargo-miri` directly\n+    // without having to pass --sysroot or anything\n+    let rustc_args = std::env::args().skip(2);\n+    let mut args: Vec<String> = if std::env::args().any(|s| s == \"--sysroot\") {\n+        rustc_args.collect()\n     } else {\n-        Err(exit_status.code().unwrap_or(-1))\n+        rustc_args\n+            .chain(Some(\"--sysroot\".to_owned()))\n+            .chain(Some(sys_root))\n+            .collect()\n+    };\n+    args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n+\n+    // See if we can find the cargo-miri markers.  Those only get added to the binary we want to\n+    // run.  They also serve to mark the user-defined arguments, which we have to move all the way to the\n+    // end (they get added somewhere in the middle).\n+    let needs_miri = if let Some(begin) = args.iter().position(|arg| arg == \"cargo-miri-marker-begin\") {\n+        let end = args.iter().position(|arg| arg == \"cargo-miri-marker-end\").expect(\"Cannot find end marker\");\n+        // These mark the user arguments.  We remove the first and last as they are the markers.\n+        let mut user_args = args.drain(begin..=end);\n+        assert_eq!(user_args.next().unwrap(), \"cargo-miri-marker-begin\");\n+        assert_eq!(user_args.next_back().unwrap(), \"cargo-miri-marker-end\");\n+        // Collect the rest and add it back at the end\n+        let mut user_args = user_args.collect::<Vec<String>>();\n+        args.append(&mut user_args);\n+        // Run this in Miri\n+        true\n+    } else {\n+        false\n+    };\n+\n+\n+    let mut command = if needs_miri {\n+        let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n+        path.set_file_name(\"miri\");\n+        Command::new(path)\n+    } else {\n+        Command::new(\"rustc\")\n+    };\n+    command.args(&args);\n+    if has_arg_flag(\"-v\") {\n+        eprintln!(\"+ {:?}\", command);\n+    }\n+\n+    match command.status() {\n+        Ok(exit) => {\n+            if !exit.success() {\n+                std::process::exit(exit.code().unwrap_or(42));\n+            }\n+        }\n+        Err(ref e) if needs_miri => panic!(\"error during miri run: {:?}\", e),\n+        Err(ref e) => panic!(\"error during rustc call: {:?}\", e),\n     }\n }"}, {"sha": "3a70577cb7f22c00f0a02f4a0bb125ba987ecc12", "filename": "src/bin/miri-rustc-tests.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Fbin%2Fmiri-rustc-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Fbin%2Fmiri-rustc-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri-rustc-tests.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -25,6 +25,8 @@ use rustc::ty::TyCtxt;\n use syntax::ast;\n use rustc::hir::def_id::LOCAL_CRATE;\n \n+use miri::MiriConfig;\n+\n struct MiriCompilerCalls {\n     default: Box<RustcDefaultCalls>,\n     /// whether we are building for the host\n@@ -94,9 +96,10 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n             fn visit_item(&mut self, i: &'hir hir::Item) {\n                 if let hir::ItemKind::Fn(.., body_id) = i.node {\n                     if i.attrs.iter().any(|attr| attr.name() == \"test\") {\n+                        let config = MiriConfig { validate: true, args: vec![] };\n                         let did = self.0.hir().body_owner_def_id(body_id);\n                         println!(\"running test: {}\", self.0.def_path_debug_str(did));\n-                        miri::eval_main(self.0, did, /*validate*/true);\n+                        miri::eval_main(self.0, did, config);\n                         self.1.session.abort_if_errors();\n                     }\n                 }\n@@ -106,7 +109,8 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n         }\n         state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(tcx, state));\n     } else if let Some((entry_def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n-        miri::eval_main(tcx, entry_def_id, /*validate*/true);\n+        let config = MiriConfig { validate: true, args: vec![] };\n+        miri::eval_main(tcx, entry_def_id, config);\n \n         state.session.abort_if_errors();\n     } else {"}, {"sha": "31bd1deb10f57e6c3df135caa65f75dc39a13bc7", "filename": "src/bin/miri.rs", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -27,11 +27,11 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc::hir::def_id::LOCAL_CRATE;\n use syntax::ast;\n \n+use miri::MiriConfig;\n+\n struct MiriCompilerCalls {\n     default: Box<RustcDefaultCalls>,\n-\n-    /// Whether to enforce the validity invariant.\n-    validate: bool,\n+    miri_config: MiriConfig,\n }\n \n impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n@@ -79,6 +79,8 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>,\n     ) -> Compilation {\n+        // Called *before* build_controller. Add filename to miri arguments.\n+        self.miri_config.args.insert(0, input.filestem().to_string());\n         self.default.late_callback(codegen_backend, matches, sess, cstore, input, odir, ofile)\n     }\n     fn build_controller(\n@@ -89,9 +91,9 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         let this = *self;\n         let mut control = this.default.build_controller(sess, matches);\n         control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n-        let validate = this.validate;\n+        let miri_config = this.miri_config;\n         control.after_analysis.callback =\n-            Box::new(move |state| after_analysis(state, validate));\n+            Box::new(move |state| after_analysis(state, miri_config.clone()));\n         control.after_analysis.stop = Compilation::Stop;\n         control\n     }\n@@ -107,7 +109,7 @@ fn after_hir_lowering(state: &mut CompileState) {\n \n fn after_analysis<'a, 'tcx>(\n     state: &mut CompileState<'a, 'tcx>,\n-    validate: bool,\n+    miri_config: MiriConfig,\n ) {\n     init_late_loggers();\n     state.session.abort_if_errors();\n@@ -117,7 +119,7 @@ fn after_analysis<'a, 'tcx>(\n \n     let (entry_def_id, _) = tcx.entry_fn(LOCAL_CRATE).expect(\"no main function found!\");\n \n-    miri::eval_main(tcx, entry_def_id, validate);\n+    miri::eval_main(tcx, entry_def_id, miri_config);\n \n     state.session.abort_if_errors();\n }\n@@ -188,34 +190,51 @@ fn find_sysroot() -> String {\n \n fn main() {\n     init_early_loggers();\n-    let mut args: Vec<String> = std::env::args().collect();\n \n-    // Parse our own -Z flags and remove them before rustc gets their hand on them.\n+    // Parse our arguments and split them across rustc and miri\n     let mut validate = true;\n-    args.retain(|arg| {\n-        match arg.as_str() {\n-            \"-Zmiri-disable-validation\" => {\n-                validate = false;\n-                false\n-            },\n-            _ => true\n+    let mut rustc_args = vec![];\n+    let mut miri_args = vec![];\n+    let mut after_dashdash = false;\n+    for arg in std::env::args() {\n+        if rustc_args.is_empty() {\n+            // Very first arg: for rustc\n+            rustc_args.push(arg);\n         }\n-    });\n+        else if after_dashdash {\n+            // Everything that comes is Miri args\n+            miri_args.push(arg);\n+        } else {\n+            match arg.as_str() {\n+                \"-Zmiri-disable-validation\" => {\n+                    validate = false;\n+                },\n+                \"--\" => {\n+                    after_dashdash = true;\n+                }\n+                _ => {\n+                    rustc_args.push(arg);\n+                }\n+            }\n+        }\n+    }\n \n     // Determine sysroot and let rustc know about it\n     let sysroot_flag = String::from(\"--sysroot\");\n-    if !args.contains(&sysroot_flag) {\n-        args.push(sysroot_flag);\n-        args.push(find_sysroot());\n+    if !rustc_args.contains(&sysroot_flag) {\n+        rustc_args.push(sysroot_flag);\n+        rustc_args.push(find_sysroot());\n     }\n     // Finally, add the default flags all the way in the beginning, but after the binary name.\n-    args.splice(1..1, miri::miri_default_args().iter().map(ToString::to_string));\n+    rustc_args.splice(1..1, miri::miri_default_args().iter().map(ToString::to_string));\n \n-    trace!(\"rustc arguments: {:?}\", args);\n+    debug!(\"rustc arguments: {:?}\", rustc_args);\n+    debug!(\"miri arguments: {:?}\", miri_args);\n+    let miri_config = MiriConfig { validate, args: miri_args };\n     let result = rustc_driver::run(move || {\n-        rustc_driver::run_compiler(&args, Box::new(MiriCompilerCalls {\n+        rustc_driver::run_compiler(&rustc_args, Box::new(MiriCompilerCalls {\n             default: Box::new(RustcDefaultCalls),\n-            validate,\n+            miri_config,\n         }), None, None)\n     });\n     std::process::exit(result as i32);"}, {"sha": "fa68f1d0d703ad2c01ab1a50da3796b1779718b5", "filename": "src/fn_call.rs", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -39,12 +39,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         if this.tcx.is_foreign_item(instance.def_id()) {\n             // An external function that we cannot find MIR for, but we can still run enough\n             // of them to make miri viable.\n-            this.emulate_foreign_item(\n-                instance.def_id(),\n-                args,\n-                dest.unwrap(),\n-                ret.unwrap(),\n-            )?;\n+            this.emulate_foreign_item(instance.def_id(), args, dest, ret)?;\n             // `goto_block` already handled\n             return Ok(None);\n         }\n@@ -59,8 +54,8 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         &mut self,\n         def_id: DefId,\n         args: &[OpTy<'tcx, Borrow>],\n-        dest: PlaceTy<'tcx, Borrow>,\n-        ret: mir::BasicBlock,\n+        dest: Option<PlaceTy<'tcx, Borrow>>,\n+        ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_mut();\n         let attrs = this.tcx.get_attrs(def_id);\n@@ -70,9 +65,23 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         };\n         // Strip linker suffixes (seen on 32bit macOS)\n         let link_name = link_name.trim_end_matches(\"$UNIX2003\");\n-\n         let tcx = &{this.tcx.tcx};\n \n+        // first: functions that could diverge\n+        match &link_name[..] {\n+            \"__rust_start_panic\" | \"panic_impl\" => {\n+                return err!(MachineError(\"the evaluated program panicked\".to_string()));\n+            }\n+            _ => if dest.is_none() {\n+                return err!(Unimplemented(\n+                    format!(\"can't call diverging foreign function: {}\", link_name),\n+                ));\n+            }\n+        }\n+\n+        // now: functions that assume a ret and dest\n+        let dest = dest.expect(\"we already checked for a dest\");\n+        let ret = ret.expect(\"dest is Some but ret is None\");\n         match &link_name[..] {\n             \"malloc\" => {\n                 let size = this.read_scalar(args[0])?.to_usize(this)?;\n@@ -84,6 +93,32 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     this.write_scalar(Scalar::Ptr(ptr.with_default_tag()), dest)?;\n                 }\n             }\n+            \"posix_memalign\" => {\n+                let ret = this.deref_operand(args[0])?;\n+                let align = this.read_scalar(args[1])?.to_usize(this)?;\n+                let size = this.read_scalar(args[2])?.to_usize(this)?;\n+                // align must be a power of 2, and also at least ptr-sized (wtf, POSIX)\n+                if !align.is_power_of_two() {\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                if align < this.pointer_size().bytes() {\n+                    return err!(MachineError(format!(\n+                        \"posix_memalign: alignment must be at least the size of a pointer, but is {}\",\n+                        align,\n+                    )));\n+                }\n+                if size == 0 {\n+                    this.write_null(ret.into())?;\n+                } else {\n+                    let ptr = this.memory_mut().allocate(\n+                        Size::from_bytes(size),\n+                        Align::from_bytes(align).unwrap(),\n+                        MiriMemoryKind::C.into()\n+                    );\n+                    this.write_scalar(Scalar::Ptr(ptr.with_default_tag()), ret.into())?;\n+                }\n+                this.write_null(dest)?;\n+            }\n \n             \"free\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n@@ -245,9 +280,6 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 return Ok(());\n             }\n \n-            \"__rust_start_panic\" =>\n-                return err!(MachineError(\"the evaluated program panicked\".to_string())),\n-\n             \"memcmp\" => {\n                 let left = this.read_scalar(args[0])?.not_undef()?;\n                 let right = this.read_scalar(args[1])?.not_undef()?;\n@@ -384,9 +416,17 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     use std::io::{self, Write};\n \n                     let buf_cont = this.memory().read_bytes(buf, Size::from_bytes(n))?;\n+                    // We need to flush to make sure this actually appears on the screen\n                     let res = if fd == 1 {\n-                        io::stdout().write(buf_cont)\n+                        // Stdout is buffered, flush to make sure it appears on the screen.\n+                        // This is the write() syscall of the interpreted program, we want it\n+                        // to correspond to a write() syscall on the host -- there is no good\n+                        // in adding extra buffering here.\n+                        let res = io::stdout().write(buf_cont);\n+                        io::stdout().flush().unwrap();\n+                        res\n                     } else {\n+                        // No need to flush, stderr is not buffered.\n                         io::stderr().write(buf_cont)\n                     };\n                     match res {"}, {"sha": "09df91b3ab3885754eef9f7a00f36eb1ee24b206", "filename": "src/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -108,6 +108,11 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             \"atomic_and_rel\" |\n             \"atomic_and_acqrel\" |\n             \"atomic_and_relaxed\" |\n+            \"atomic_nand\" |\n+            \"atomic_nand_acq\" |\n+            \"atomic_nand_rel\" |\n+            \"atomic_nand_acqrel\" |\n+            \"atomic_nand_relaxed\" |\n             \"atomic_xadd\" |\n             \"atomic_xadd_acq\" |\n             \"atomic_xadd_rel\" |\n@@ -125,16 +130,23 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 let rhs = this.read_immediate(args[1])?;\n                 let old = this.read_immediate(ptr.into())?;\n                 this.write_immediate(*old, dest)?; // old value is returned\n-                let op = match intrinsic_name.split('_').nth(1).unwrap() {\n-                    \"or\" => mir::BinOp::BitOr,\n-                    \"xor\" => mir::BinOp::BitXor,\n-                    \"and\" => mir::BinOp::BitAnd,\n-                    \"xadd\" => mir::BinOp::Add,\n-                    \"xsub\" => mir::BinOp::Sub,\n+                let (op, neg) = match intrinsic_name.split('_').nth(1).unwrap() {\n+                    \"or\" => (mir::BinOp::BitOr, false),\n+                    \"xor\" => (mir::BinOp::BitXor, false),\n+                    \"and\" => (mir::BinOp::BitAnd, false),\n+                    \"xadd\" => (mir::BinOp::Add, false),\n+                    \"xsub\" => (mir::BinOp::Sub, false),\n+                    \"nand\" => (mir::BinOp::BitAnd, true),\n                     _ => bug!(),\n                 };\n                 // Atomics wrap around on overflow.\n-                this.binop_ignore_overflow(op, old, rhs, ptr.into())?;\n+                let (val, _overflowed) = this.binary_op_imm(op, old, rhs)?;\n+                let val = if neg {\n+                    this.unary_op(mir::UnOp::Not, val, old.layout)?\n+                } else {\n+                    val\n+                };\n+                this.write_scalar(val, ptr.into())?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -233,7 +245,13 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 this.binop_ignore_overflow(mir::BinOp::Div, a, b, dest)?;\n             },\n \n-            \"likely\" | \"unlikely\" | \"forget\" => {}\n+            \"forget\" => {}\n+\n+            \"likely\" | \"unlikely\" => {\n+                // These just return their argument\n+                let b = this.read_immediate(args[0])?;\n+                this.write_immediate(*b, dest)?;\n+            }\n \n             \"init\" => {\n                 // Check fast path: we don't want to force an allocation in case the destination is a simple value,"}, {"sha": "f59a476ed94e8478af52371d267d80053e631b1f", "filename": "src/lib.rs", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -54,19 +54,26 @@ pub use crate::stacked_borrows::{Borrow, Stack, Stacks, BorStackItem};\n pub fn miri_default_args() -> &'static [&'static str] {\n     // The flags here should be kept in sync with what bootstrap adds when `test-miri` is\n     // set, which happens in `bootstrap/bin/rustc.rs` in the rustc sources.\n-    &[\"-Zalways-encode-mir\", \"-Zmir-emit-retag\", \"-Zmir-opt-level=0\"]\n+    &[\"-Zalways-encode-mir\", \"-Zmir-emit-retag\", \"-Zmir-opt-level=0\", \"--cfg=miri\"]\n+}\n+\n+/// Configuration needed to spawn a Miri instance\n+#[derive(Clone)]\n+pub struct MiriConfig {\n+    pub validate: bool,\n+    pub args: Vec<String>,\n }\n \n // Used by priroda\n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n-    validate: bool,\n+    config: MiriConfig,\n ) -> EvalResult<'tcx, EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>> {\n     let mut ecx = EvalContext::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n-        Evaluator::new(validate),\n+        Evaluator::new(config.validate),\n     );\n \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n@@ -120,7 +127,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n \n     // Second argument (argc): 1\n     let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-    let argc = Scalar::from_int(1, dest.layout.size);\n+    let argc = Scalar::from_uint(config.args.len() as u128, dest.layout.size);\n     ecx.write_scalar(argc, dest)?;\n     // Store argc for macOS _NSGetArgc\n     {\n@@ -130,26 +137,46 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     }\n \n     // FIXME: extract main source file path\n-    // Third argument (argv): &[b\"foo\"]\n-    const CMD: &str = \"running-in-miri\\0\";\n+    // Third argument (argv): Created from config.args\n     let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-    let cmd = ecx.memory_mut().allocate_static_bytes(CMD.as_bytes()).with_default_tag();\n-    let raw_str_layout = ecx.layout_of(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8))?;\n-    let cmd_place = ecx.allocate(raw_str_layout, MiriMemoryKind::Env.into());\n-    ecx.write_scalar(Scalar::Ptr(cmd), cmd_place.into())?;\n-    ecx.memory_mut().mark_immutable(cmd_place.to_ptr()?.alloc_id)?;\n+    // For Windows, construct a command string with all the aguments\n+    let mut cmd = String::new();\n+    for arg in config.args.iter() {\n+        if !cmd.is_empty() {\n+            cmd.push(' ');\n+        }\n+        cmd.push_str(&*shell_escape::windows::escape(arg.as_str().into()));\n+    }\n+    cmd.push(std::char::from_u32(0).unwrap()); // don't forget 0 terminator\n+    // Collect the pointers to the individual strings.\n+    let mut argvs = Vec::<Pointer<Borrow>>::new();\n+    for arg in config.args {\n+        // Add 0 terminator\n+        let mut arg = arg.into_bytes();\n+        arg.push(0);\n+        argvs.push(ecx.memory_mut().allocate_static_bytes(arg.as_slice()).with_default_tag());\n+    }\n+    // Make an array with all these pointers, in the Miri memory.\n+    let argvs_layout = ecx.layout_of(ecx.tcx.mk_array(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8), argvs.len() as u64))?;\n+    let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Env.into());\n+    for (idx, arg) in argvs.into_iter().enumerate() {\n+        let place = ecx.mplace_field(argvs_place, idx as u64)?;\n+        ecx.write_scalar(Scalar::Ptr(arg), place.into())?;\n+    }\n+    ecx.memory_mut().mark_immutable(argvs_place.to_ptr()?.alloc_id)?;\n+    // Write a pointe to that place as the argument.\n+    let argv = argvs_place.ptr;\n+    ecx.write_scalar(argv, dest)?;\n     // Store argv for macOS _NSGetArgv\n     {\n-        let argv = cmd_place.ptr;\n-        ecx.write_scalar(argv, dest)?;\n         let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n         ecx.write_scalar(argv, argv_place.into())?;\n         ecx.machine.argv = Some(argv_place.ptr.to_ptr()?);\n     }\n     // Store cmdline as UTF-16 for Windows GetCommandLineW\n     {\n         let tcx = &{ecx.tcx.tcx};\n-        let cmd_utf16: Vec<u16> = CMD.encode_utf16().collect();\n+        let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n         let cmd_ptr = ecx.memory_mut().allocate(\n             Size::from_bytes(cmd_utf16.len() as u64 * 2),\n             Align::from_bytes(2).unwrap(),\n@@ -179,9 +206,9 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n-    validate: bool,\n+    config: MiriConfig,\n ) {\n-    let mut ecx = create_ecx(tcx, main_id, validate).expect(\"Couldn't create ecx\");\n+    let mut ecx = create_ecx(tcx, main_id, config).expect(\"Couldn't create ecx\");\n \n     // Run! The main execution.\n     let res: EvalResult = (|| {"}, {"sha": "a52e115323c6ff98ae90b53f3d887ef1eb0ac049", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -21,19 +21,19 @@ pub type CallId = u64;\n pub enum Borrow {\n     /// A unique (mutable) reference.\n     Uniq(Timestamp),\n-    /// A shared reference.  This is also used by raw pointers, which do not track details\n+    /// An aliasing reference.  This is also used by raw pointers, which do not track details\n     /// of how or when they were created, hence the timestamp is optional.\n     /// Shr(Some(_)) does NOT mean that the destination of this reference is frozen;\n     /// that depends on the type!  Only those parts outside of an `UnsafeCell` are actually\n     /// frozen.\n-    Shr(Option<Timestamp>),\n+    Alias(Option<Timestamp>),\n }\n \n impl Borrow {\n     #[inline(always)]\n-    pub fn is_shared(self) -> bool {\n+    pub fn is_aliasing(self) -> bool {\n         match self {\n-            Borrow::Shr(_) => true,\n+            Borrow::Alias(_) => true,\n             _ => false,\n         }\n     }\n@@ -49,7 +49,7 @@ impl Borrow {\n \n impl Default for Borrow {\n     fn default() -> Self {\n-        Borrow::Shr(None)\n+        Borrow::Alias(None)\n     }\n }\n \n@@ -58,10 +58,9 @@ impl Default for Borrow {\n pub enum BorStackItem {\n     /// Indicates the unique reference that may mutate.\n     Uniq(Timestamp),\n-    /// Indicates that the location has been shared.  Used for raw pointers, but\n-    /// also for shared references.  The latter *additionally* get frozen\n-    /// when there is no `UnsafeCell`.\n-    Shr,\n+    /// Indicates that the location has been mutably shared.  Used for raw pointers as\n+    /// well as for unfrozen shared references.\n+    Raw,\n     /// A barrier, tracking the function it belongs to by its index on the call stack\n     FnBarrier(CallId)\n }\n@@ -186,19 +185,19 @@ impl<'tcx> Stack {\n         kind: RefKind,\n     ) -> Result<Option<usize>, String> {\n         // Exclude unique ref with frozen tag.\n-        if let (RefKind::Unique, Borrow::Shr(Some(_))) = (kind, bor) {\n+        if let (RefKind::Unique, Borrow::Alias(Some(_))) = (kind, bor) {\n             return Err(format!(\"Encountered mutable reference with frozen tag ({:?})\", bor));\n         }\n         // Checks related to freezing\n         match bor {\n-            Borrow::Shr(Some(bor_t)) if kind == RefKind::Frozen => {\n+            Borrow::Alias(Some(bor_t)) if kind == RefKind::Frozen => {\n                 // We need the location to be frozen. This ensures F3.\n                 let frozen = self.frozen_since.map_or(false, |itm_t| itm_t <= bor_t);\n                 return if frozen { Ok(None) } else {\n                     Err(format!(\"Location is not frozen long enough\"))\n                 }\n             }\n-            Borrow::Shr(_) if self.frozen_since.is_some() => {\n+            Borrow::Alias(_) if self.frozen_since.is_some() => {\n                 return Ok(None) // Shared deref to frozen location, looking good\n             }\n             _ => {} // Not sufficient, go on looking.\n@@ -210,8 +209,8 @@ impl<'tcx> Stack {\n                     // Found matching unique item.  This satisfies U3.\n                     return Ok(Some(idx))\n                 }\n-                (BorStackItem::Shr, Borrow::Shr(_)) => {\n-                    // Found matching shared/raw item.\n+                (BorStackItem::Raw, Borrow::Alias(_)) => {\n+                    // Found matching aliasing/raw item.\n                     return Ok(Some(idx))\n                 }\n                 // Go on looking.  We ignore barriers!  When an `&mut` and an `&` alias,\n@@ -221,7 +220,7 @@ impl<'tcx> Stack {\n             }\n         }\n         // If we got here, we did not find our item.  We have to error to satisfy U3.\n-        Err(format!(\"Borrow being dereferenced ({:?}) does not exist on the stack\", bor))\n+        Err(format!(\"Borrow being dereferenced ({:?}) does not exist on the borrow stack\", bor))\n     }\n \n     /// Perform an actual memory access using `bor`.  We do not know any types here\n@@ -258,14 +257,15 @@ impl<'tcx> Stack {\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n                     // Found matching unique item.  Continue after the match.\n                 }\n-                (BorStackItem::Shr, _) if kind == AccessKind::Read => {\n-                    // When reading, everything can use a shared item!\n+                (BorStackItem::Raw, _) if kind == AccessKind::Read => {\n+                    // When reading, everything can use a raw item!\n                     // We do not want to do this when writing: Writing to an `&mut`\n                     // should reaffirm its exclusivity (i.e., make sure it is\n-                    // on top of the stack).  Continue after the match.\n+                    // on top of the stack).\n+                    // Continue after the match.\n                 }\n-                (BorStackItem::Shr, Borrow::Shr(_)) => {\n-                    // Found matching shared item.  Continue after the match.\n+                (BorStackItem::Raw, Borrow::Alias(_)) => {\n+                    // Found matching raw item.  Continue after the match.\n                 }\n                 _ => {\n                     // Pop this, go on.  This ensures U2.\n@@ -294,7 +294,7 @@ impl<'tcx> Stack {\n         }\n         // If we got here, we did not find our item.\n         err!(MachineError(format!(\n-            \"Borrow being accessed ({:?}) does not exist on the stack\",\n+            \"Borrow being accessed ({:?}) does not exist on the borrow stack\",\n             bor\n         )))\n     }\n@@ -309,7 +309,7 @@ impl<'tcx> Stack {\n         // of access (like writing through raw pointers) is permitted.\n         if kind == RefKind::Frozen {\n             let bor_t = match bor {\n-                Borrow::Shr(Some(t)) => t,\n+                Borrow::Alias(Some(t)) => t,\n                 _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n             };\n             // It is possible that we already are frozen (e.g. if we just pushed a barrier,\n@@ -328,12 +328,12 @@ impl<'tcx> Stack {\n         // Push new item to the stack.\n         let itm = match bor {\n             Borrow::Uniq(t) => BorStackItem::Uniq(t),\n-            Borrow::Shr(_) => BorStackItem::Shr,\n+            Borrow::Alias(_) => BorStackItem::Raw,\n         };\n         if *self.borrows.last().unwrap() == itm {\n             // This is just an optimization, no functional change: Avoid stacking\n             // multiple `Shr` on top of each other.\n-            assert!(bor.is_shared());\n+            assert!(bor.is_aliasing());\n             trace!(\"create: Sharing a shared location is a NOP\");\n         } else {\n             // This ensures U1.\n@@ -440,7 +440,7 @@ impl<'tcx> Stacks {\n                     _ => false,\n                 };\n             if bor_redundant {\n-                assert!(new_bor.is_shared(), \"A unique reborrow can never be redundant\");\n+                assert!(new_bor.is_aliasing(), \"A unique reborrow can never be redundant\");\n                 trace!(\"reborrow is redundant\");\n                 continue;\n             }\n@@ -465,7 +465,7 @@ impl AllocationExtra<Borrow, MemoryState> for Stacks {\n     #[inline(always)]\n     fn memory_allocated<'tcx>(size: Size, extra: &MemoryState) -> Self {\n         let stack = Stack {\n-            borrows: vec![BorStackItem::Shr],\n+            borrows: vec![BorStackItem::Raw],\n             frozen_since: None,\n         };\n         Stacks {\n@@ -511,7 +511,7 @@ impl<'tcx> Stacks {\n     ) {\n         for stack in self.stacks.get_mut().iter_mut(Size::ZERO, size) {\n             assert!(stack.borrows.len() == 1);\n-            assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Shr);\n+            assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Raw);\n             stack.borrows.push(itm);\n         }\n     }\n@@ -536,7 +536,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let alloc = this.memory().get(ptr.alloc_id)?;\n         alloc.check_bounds(this, ptr, size)?;\n         // Update the stacks.\n-        if let Borrow::Shr(Some(_)) = new_bor {\n+        if let Borrow::Alias(Some(_)) = new_bor {\n             // Reference that cares about freezing. We need a frozen-sensitive reborrow.\n             this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                 let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n@@ -574,7 +574,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let time = this.machine.stacked_borrows.increment_clock();\n         let new_bor = match mutbl {\n             Some(MutMutable) => Borrow::Uniq(time),\n-            Some(MutImmutable) => Borrow::Shr(Some(time)),\n+            Some(MutImmutable) => Borrow::Alias(Some(time)),\n             None => Borrow::default(),\n         };\n \n@@ -586,7 +586,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             assert!(mutbl == Some(MutMutable), \"two-phase shared borrows make no sense\");\n             // We immediately share it, to allow read accesses\n             let two_phase_time = this.machine.stacked_borrows.increment_clock();\n-            let two_phase_bor = Borrow::Shr(Some(two_phase_time));\n+            let two_phase_bor = Borrow::Alias(Some(two_phase_time));\n             this.reborrow(new_place, size, /*fn_barrier*/false, two_phase_bor)?;\n         }\n \n@@ -651,7 +651,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let alloc = this.memory().get(ptr.alloc_id)?;\n         alloc.check_bounds(this, ptr, size)?;\n         // If we got here, we do some checking, *but* we leave the tag unchanged.\n-        if let Borrow::Shr(Some(_)) = ptr.tag {\n+        if let Borrow::Alias(Some(_)) = ptr.tag {\n             assert_eq!(mutability, Some(MutImmutable));\n             // We need a frozen-sensitive check\n             this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {"}, {"sha": "76fb04c6672aadd6898e9870cd948989a3c7d931", "filename": "test-cargo-miri/Cargo.lock", "status": "modified", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2FCargo.lock?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1,3 +1,15 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"autocfg\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"bitflags\"\n+version = \"1.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"byteorder\"\n version = \"1.0.0\"\n@@ -8,7 +20,192 @@ name = \"cargo-miri-test\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"cloudabi\"\n+version = \"0.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"fuchsia-cprng\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.48\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"rand\"\n+version = \"0.6.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"autocfg 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_hc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_isaac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_jitter 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_os 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_pcg 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_xorshift 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_chacha\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"autocfg 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_core\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_core\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"rand_hc\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_isaac\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rand_jitter\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_os\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rdrand 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_pcg\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_xorshift\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rdrand\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rustc_version\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"semver\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"semver-parser\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.3.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"winapi-i686-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-x86_64-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [metadata]\n+\"checksum autocfg 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a6d640bee2da49f60a4068a7fae53acde8982514ab7bae8b8cea9e88cbcfd799\"\n+\"checksum bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"228047a76f468627ca71776ecdebd732a3423081fcf5125585bcd7c49886ce12\"\n \"checksum byteorder 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c40977b0ee6b9885c9013cd41d9feffdd22deb3bb4dc3a71d901cc7a77de18c8\"\n+\"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n+\"checksum fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba\"\n+\"checksum libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e962c7641008ac010fa60a7dfdc1712449f29c44ef2d4702394aea943ee75047\"\n+\"checksum rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca\"\n+\"checksum rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"556d3a1ca6600bfcbab7c7c91ccb085ac7fbbcd70e008a98742e7847f4f7bcef\"\n+\"checksum rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b\"\n+\"checksum rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d0e7a549d590831370895ab7ba4ea0c1b6b011d106b5ff2da6eee112615e6dc0\"\n+\"checksum rand_hc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7b40677c7be09ae76218dc623efbf7b18e34bced3f38883af07bb75630a21bc4\"\n+\"checksum rand_isaac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ded997c9d5f13925be2a6fd7e66bf1872597f759fd9dd93513dd7e92e5a5ee08\"\n+\"checksum rand_jitter 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"080723c6145e37503a2224f801f252e14ac5531cb450f4502698542d188cb3c0\"\n+\"checksum rand_os 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b7c690732391ae0abafced5015ffb53656abfaec61b342290e5eb56b286a679d\"\n+\"checksum rand_pcg 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"086bd09a33c7044e56bb44d5bdde5a60e7f119a9e95b0775f545de759a32fe05\"\n+\"checksum rand_xorshift 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cbf7e9e623549b0e21f6e97cf8ecf247c1a8fd2e8a992ae265314300b2455d5c\"\n+\"checksum rdrand 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"678054eb77286b51581ba43620cc911abf02758c91f93f479767aed0f90458b2\"\n+\"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n+\"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n+\"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n+\"checksum winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92c1eb33641e276cfa214a0522acad57be5c56b10cb348b3c5117db75f3ac4b0\"\n+\"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n+\"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\""}, {"sha": "04f259a0aedba4f41f2a1a6e9fd111994ebefb80", "filename": "test-cargo-miri/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2FCargo.toml?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -6,3 +6,6 @@ edition = \"2018\"\n \n [dependencies]\n byteorder = \"1.0\"\n+\n+[dev-dependencies]\n+rand = \"0.6.5\""}, {"sha": "8c59b6bcdead616496035b3d17b001011daeb946", "filename": "test-cargo-miri/run-test.py", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Frun-test.py?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -37,10 +37,19 @@ def test(name, cmd, stdout_ref, stderr_ref):\n \n def test_cargo_miri_run():\n     test(\"cargo miri run\", [\"cargo\", \"miri\", \"run\", \"-q\"], \"stdout.ref\", \"stderr.ref\")\n+    test(\"cargo miri run (with arguments)\",\n+        [\"cargo\", \"miri\", \"run\", \"-q\", \"--\", \"--\", \"hello world\", '\"hello world\"'],\n+        \"stdout.ref\", \"stderr.ref2\"\n+    )\n \n def test_cargo_miri_test():\n     test(\"cargo miri test\", [\"cargo\", \"miri\", \"test\", \"-q\"], \"test.stdout.ref\", \"test.stderr.ref\")\n+    test(\"cargo miri test (with filter)\",\n+        [\"cargo\", \"miri\", \"test\", \"-q\", \"--\", \"--\", \"impl\"],\n+        \"test.stdout.ref2\", \"test.stderr.ref\"\n+    )\n \n test_cargo_miri_run()\n test_cargo_miri_test()\n+print(\"TEST SUCCESSFUL!\")\n sys.exit(0)"}, {"sha": "32f1bac57d20ff4e5fe26a4a36c56567d33df613", "filename": "test-cargo-miri/src/main.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fsrc%2Fmain.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1,9 +1,29 @@\n+extern crate byteorder;\n+#[cfg(test)]\n+extern crate rand;\n+\n use byteorder::{BigEndian, ByteOrder};\n \n fn main() {\n     let buf = &[1,2,3,4];\n     let n = <BigEndian as ByteOrder>::read_u32(buf);\n     assert_eq!(n, 0x01020304);\n     println!(\"{:#010x}\", n);\n-    eprintln!(\"standard error\");\n+    for arg in std::env::args() {\n+        eprintln!(\"{}\", arg);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use rand::{Rng, SeedableRng};\n+\n+    // Make sure in-crate tests with dev-dependencies work\n+    #[test]\n+    fn rng() {\n+        let mut rng = rand::rngs::StdRng::seed_from_u64(0xcafebeef);\n+        let x: u32 = rng.gen();\n+        let y: u32 = rng.gen();\n+        assert_ne!(x, y);\n+    }\n }"}, {"sha": "ba2906d0666cf726c7eaadd2cd3db615dedfdf3a", "filename": "test-cargo-miri/stderr.ref", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Fstderr.ref", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Fstderr.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fstderr.ref?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1 +1 @@\n-standard error\n+main"}, {"sha": "8226b1b7cdec7f93577fa8dd1a7e8a5147d5145b", "filename": "test-cargo-miri/stderr.ref2", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Fstderr.ref2", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Fstderr.ref2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fstderr.ref2?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -0,0 +1,3 @@\n+main\n+hello world\n+\"hello world\""}, {"sha": "9c3621f21535bf1dfdf63a984cb3f1b956e63d9d", "filename": "test-cargo-miri/test.stdout.ref", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Ftest.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Ftest.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1,7 +1,13 @@\n \n+running 1 test\n+test test::rng ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+\n+\n running 2 tests\n-test bar ... ok\n-test baz ... ok\n+test rng ... ok\n+test simple ... ok\n \n test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n "}, {"sha": "ce3506709d5a09b46c0f09981b198d4d6b7b8dd5", "filename": "test-cargo-miri/test.stdout.ref2", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Ftest.stdout.ref2", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Ftest.stdout.ref2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref2?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -0,0 +1,11 @@\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n+\n+\n+running 1 test\n+test simple ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n+"}, {"sha": "e9faaf2fb2f19f9ef46477a576079f9258c1c37b", "filename": "test-cargo-miri/tests/test.rs", "status": "renamed", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/test-cargo-miri%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftests%2Ftest.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1,17 +1,24 @@\n+extern crate rand;\n+\n+use rand::{Rng, SeedableRng};\n+\n #[test]\n-fn bar() {\n+fn simple() {\n     assert_eq!(4, 4);\n }\n \n // Having more than 1 test does seem to make a difference\n // (i.e., this calls ptr::swap which having just one test does not).\n #[test]\n-fn baz() {\n-    assert_eq!(5, 5);\n+fn rng() {\n+    let mut rng = rand::rngs::StdRng::seed_from_u64(0xdeadcafe);\n+    let x: u32 = rng.gen();\n+    let y: u32 = rng.gen();\n+    assert_ne!(x, y);\n }\n \n // A test that won't work on miri\n-#[cfg(not(feature = \"cargo-miri\"))]\n+#[cfg(not(miri))]\n #[test]\n fn does_not_work_on_miri() {\n     let x = 0u8;", "previous_filename": "test-cargo-miri/tests/foo.rs"}, {"sha": "1163c8708287cb51eb3f0df2ee47e8a9c069cce1", "filename": "tests/compile-fail/panic1.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fpanic1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fpanic1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic1.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1,5 +1,5 @@\n //error-pattern: the evaluated program panicked\n \n fn main() {\n-    assert_eq!(5, 6);\n+    std::panic!(\"panicking from libstd\");\n }", "previous_filename": "tests/compile-fail/panic.rs"}, {"sha": "e643e69224139592d09eccb11463b15c56af0f38", "filename": "tests/compile-fail/panic2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fpanic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fpanic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic2.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -0,0 +1,5 @@\n+//error-pattern: the evaluated program panicked\n+\n+fn main() {\n+    std::panic!(\"{}-panicking from libstd\", 42);\n+}"}, {"sha": "b22f95d9c69d1431188682d82fab95e16f2e3ed6", "filename": "tests/compile-fail/panic3.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fpanic3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fpanic3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic3.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -0,0 +1,5 @@\n+//error-pattern: the evaluated program panicked\n+\n+fn main() {\n+    core::panic!(\"panicking from libcore\");\n+}"}, {"sha": "449e716e161cf7af647859be9836d8cd22848eee", "filename": "tests/compile-fail/panic4.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fpanic4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fpanic4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic4.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -0,0 +1,5 @@\n+//error-pattern: the evaluated program panicked\n+\n+fn main() {\n+    core::panic!(\"{}-panicking from libcore\", 42);\n+}"}, {"sha": "30f5921202c3ffb02b76fc126ee06bf03fcf21da", "filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -9,5 +9,5 @@ fn main() {\n     retarget(&mut target_alias, target);\n     // now `target_alias` points to the same thing as `target`\n     *target = 13;\n-    let _val = *target_alias; //~ ERROR does not exist on the stack\n+    let _val = *target_alias; //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "e3c59d1566142f6255dea8ea5addf2316564ea82", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-pub fn safe(_x: &mut i32, _y: &i32) {} //~ ERROR does not exist on the stack\n+pub fn safe(_x: &mut i32, _y: &i32) {} //~ ERROR does not exist on the borrow stack\n \n fn main() {\n     let mut x = 0;"}, {"sha": "481915faed0401260af9e9a76a0004b1bbc250ac", "filename": "tests/compile-fail/stacked_borrows/box_exclusive_violation1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -8,7 +8,7 @@ fn demo_mut_advanced_unique(mut our: Box<i32>) -> i32 {\n   unknown_code_2();\n \n   // We know this will return 5\n-  *our //~ ERROR does not exist on the stack\n+  *our //~ ERROR does not exist on the borrow stack\n }\n \n // Now comes the evil context"}, {"sha": "98d4e6f22965dd24353bafe66f7e9ac430cbd394", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -13,5 +13,5 @@ fn main() {\n     let v1 = safe::as_mut_slice(&v);\n     let _v2 = safe::as_mut_slice(&v);\n     v1[1] = 5;\n-    //~^ ERROR does not exist on the stack\n+    //~^ ERROR does not exist on the borrow stack\n }"}, {"sha": "42f345f55144cd8a718d71fc860892d381d6397c", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -9,7 +9,7 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            //~^ ERROR does not exist on the stack\n+            //~^ ERROR does not exist on the borrow stack\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }"}, {"sha": "0181f739a899d5d6478c371767ee236e47534553", "filename": "tests/compile-fail/stacked_borrows/illegal_read1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: does not exist on the stack\n+    //~^ ERROR: does not exist on the borrow stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "b55fe1c6c88a443b113fd3ff9f117ba0e86f543e", "filename": "tests/compile-fail/stacked_borrows/illegal_read2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: does not exist on the stack\n+    //~^ ERROR: does not exist on the borrow stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "9da4ca09606e73e3347532871688c10cb2aa9632", "filename": "tests/compile-fail/stacked_borrows/illegal_read3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read3.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     let xref2 = &mut *xref1; // derived from xref1, so using raw is still okay...\n     callee(xref1_sneaky);\n     let _val = *xref2; // ...but any use of it will invalidate our ref.\n-    //~^ ERROR: does not exist on the stack\n+    //~^ ERROR: does not exist on the borrow stack\n }\n \n fn callee(xref1: usize) {"}, {"sha": "bb889de8f839eb7fdc07b16e369a50a4f3291dc5", "filename": "tests/compile-fail/stacked_borrows/illegal_read4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xraw = xref1 as *mut _;\n     let xref2 = unsafe { &mut *xraw };\n     let _val = unsafe { *xraw }; // use the raw again, this invalidates xref2 *even* with the special read except for uniq refs\n-    let _illegal = *xref2; //~ ERROR does not exist on the stack\n+    let _illegal = *xref2; //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "5f800e754a5d02749346efbd0f0e5d9302cd6aeb", "filename": "tests/compile-fail/stacked_borrows/illegal_read5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -12,5 +12,5 @@ fn main() {\n     let _val = *xref; // we can even still use our mutable reference\n     mem::forget(unsafe { ptr::read(xshr) }); // but after reading through the shared ref\n     let _val = *xref; // the mutable one is dead and gone\n-    //~^ ERROR does not exist on the stack\n+    //~^ ERROR does not exist on the borrow stack\n }"}, {"sha": "affa21c7625ead98ae207921dc55d799ca4545f1", "filename": "tests/compile-fail/stacked_borrows/illegal_write2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     let target2 = target as *mut _;\n     drop(&mut *target); // reborrow\n     // Now make sure our ref is still the only one.\n-    unsafe { *target2 = 13; } //~ ERROR does not exist on the stack\n+    unsafe { *target2 = 13; } //~ ERROR does not exist on the borrow stack\n     let _val = *target;\n }"}, {"sha": "dc4edcc3a5b4496c5e0424ba68905379f2f52368", "filename": "tests/compile-fail/stacked_borrows/illegal_write3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     // Make sure raw ptr with raw tag cannot mutate frozen location without breaking the shared ref.\n     let r#ref = &target; // freeze\n     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n-    unsafe { *ptr = 42; } //~ ERROR does not exist on the stack\n+    unsafe { *ptr = 42; } //~ ERROR does not exist on the borrow stack\n     let _val = *r#ref;\n }"}, {"sha": "af57221260ce893750beecef0161092edc22676f", "filename": "tests/compile-fail/stacked_borrows/illegal_write5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: does not exist on the stack\n+    //~^ ERROR: does not exist on the borrow stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "f2e4b36f85cc242234914854df72397a0b8eedea", "filename": "tests/compile-fail/stacked_borrows/load_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xref = unsafe { &mut *xraw };\n     let xref_in_mem = Box::new(xref);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    let _val = *xref_in_mem; //~ ERROR does not exist on the stack\n+    let _val = *xref_in_mem; //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "ba36e43e0c5d4c39ab960bdc0bc0c9d2f2ce8aa2", "filename": "tests/compile-fail/stacked_borrows/outdated_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -3,7 +3,7 @@ fn main() {\n     let y: *const i32 = &x;\n     x = 1; // this invalidates y by reactivating the lowermost uniq borrow for this local\n \n-    assert_eq!(unsafe { *y }, 1); //~ ERROR does not exist on the stack\n+    assert_eq!(unsafe { *y }, 1); //~ ERROR does not exist on the borrow stack\n \n     assert_eq!(x, 1);\n }"}, {"sha": "b239237f019928e4a22209fba51a97859f143128", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n     let _val = unsafe { *xraw }; // invalidate xref\n-    foo(xref); //~ ERROR does not exist on the stack\n+    foo(xref); //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "a8207d58e99b23dccaf4a144175b61c8c96ab8d4", "filename": "tests/compile-fail/stacked_borrows/pointer_smuggling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -8,7 +8,7 @@ fn fun1(x: &mut u8) {\n \n fn fun2() {\n     // Now we use a pointer we are not allowed to use\n-    let _x = unsafe { *PTR }; //~ ERROR does not exist on the stack\n+    let _x = unsafe { *PTR }; //~ ERROR does not exist on the borrow stack\n }\n \n fn main() {"}, {"sha": "31f8a4e33afd906a77efb2d6ee58622d374bdc59", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &mut i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 };\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR does not exist on the stack\n+    ret //~ ERROR does not exist on the borrow stack\n }\n \n fn main() {"}, {"sha": "750d507d6f660150f7ef96d20cbd2dea93768e59", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut_option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> Option<&mut i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = Some(unsafe { &mut (*xraw).1 });\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR does not exist on the stack\n+    ret //~ ERROR does not exist on the borrow stack\n }\n \n fn main() {"}, {"sha": "bb712e9e486cd6d977edaa4cafe5b5e18c2f24d3", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut_tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> (&mut i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &mut (*xraw).1 },);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR does not exist on the stack\n+    ret //~ ERROR does not exist on the borrow stack\n }\n \n fn main() {"}, {"sha": "45ada88977788968f3f15be18ed4cae423f02ae1", "filename": "tests/compile-fail/stacked_borrows/transmute-is-no-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -10,5 +10,5 @@ fn main() {\n     let _raw: *mut i32 = unsafe { mem::transmute(&mut x[0]) };\n     // `raw` still carries a tag, so we get another pointer to the same location that does not carry a tag\n     let raw = (&mut x[1] as *mut i32).wrapping_offset(-1);\n-    unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n+    unsafe { *raw = 13; } //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "1db14ea7eda545e6f0bc72162fb05e5516a07452", "filename": "tests/compile-fail/stacked_borrows/unescaped_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     let mut x = 42;\n     let raw = &mut x as *mut i32 as usize as *mut i32;\n     let _ptr = &mut x;\n-    unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n+    unsafe { *raw = 13; } //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "0116dce4992dcab2c92df739ed408773f601ee99", "filename": "tests/run-pass/args.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fargs.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    for arg in std::env::args() {\n+        println!(\"{}\", arg);\n+    }\n+}"}, {"sha": "9564f5a1aa056804e6b7f35d533c3a06afd76af9", "filename": "tests/run-pass/args.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fargs.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fargs.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fargs.stdout?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -0,0 +1 @@\n+args"}, {"sha": "053cce36130c72714281adf86b06626aaee5eddf", "filename": "tests/run-pass/format.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fformat.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1,3 +1,4 @@\n fn main() {\n     println!(\"Hello {}\", 13);\n+    println!(\"{:0<width$}\", \"hello\", width = 10);\n }"}, {"sha": "3c9a55d0d4c1aeb35639cb8a39eb742dc3fc6cf1", "filename": "tests/run-pass/format.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fformat.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fformat.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fformat.stdout?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1 +1,2 @@\n Hello 13\n+hello00000"}, {"sha": "26a2d5a6c2a9e1a1f677ae7b749e326880e57761", "filename": "tests/run-pass/function_pointers.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Ffunction_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Ffunction_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_pointers.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1,5 +1,16 @@\n-fn f() -> i32 {\n-    42\n+trait Answer {\n+    fn answer() -> Self;\n+}\n+\n+impl Answer for i32 {\n+    fn answer() -> i32 {\n+        42\n+    }\n+}\n+\n+// A generic function, to make its address unstable\n+fn f<T: Answer>() -> T {\n+    Answer::answer()\n }\n \n fn g(i: i32) -> i32 {"}, {"sha": "0eb2097047135411d2bc7c57d330a5f41842acdc", "filename": "tests/run-pass/heap_system.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fheap_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fheap_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fheap_system.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -0,0 +1,29 @@\n+//ignore-windows: Inspects allocation base address on Windows\n+#![feature(allocator_api)]\n+\n+use std::alloc::{Global, Alloc, Layout, System};\n+\n+fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n+    let size = 8;\n+    let align = 16; // greater than size\n+    let iterations = 1; // Miri is deterministic, no need to try many times\n+    unsafe {\n+        let pointers: Vec<_> = (0..iterations).map(|_| {\n+            allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n+        }).collect();\n+        for &ptr in &pointers {\n+            assert_eq!((ptr.as_ptr() as usize) % align, 0,\n+                       \"Got a pointer less aligned than requested\")\n+        }\n+\n+        // Clean up\n+        for &ptr in &pointers {\n+            allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n+        }\n+    }\n+}\n+\n+fn main() {\n+    check_overalign_requests(System);\n+    check_overalign_requests(Global);\n+}"}, {"sha": "1bef21d83bda3c5e14a1bb172a02e9f278c8f70a", "filename": "tests/run-pass/iter.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/tests%2Frun-pass%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fiter.rs?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -0,0 +1,40 @@\n+fn iter_empty_and_zst() {\n+    for _ in Vec::<u32>::new().iter() { // this iterates over a Unique::empty()\n+        panic!(\"We should never be here.\");\n+    }\n+\n+    // Iterate over a ZST (uses arith_offset internally)\n+    let mut count = 0;\n+    for _ in &[(), (), ()] {\n+        count += 1;\n+    }\n+    assert_eq!(count, 3);\n+}\n+\n+fn test_iterator_step_by_nth() {\n+    let mut it = (0..16).step_by(5);\n+    assert_eq!(it.nth(0), Some(0));\n+    assert_eq!(it.nth(0), Some(5));\n+    assert_eq!(it.nth(0), Some(10));\n+    assert_eq!(it.nth(0), Some(15));\n+    assert_eq!(it.nth(0), None);\n+}\n+\n+fn iter_any() {\n+    let f = |x: &u8| { 10u8 == *x };\n+    f(&1u8);\n+\n+    let g = |(), x: &u8| { 10u8 == *x };\n+    g((), &1u8);\n+\n+    let h = |(), (), x: &u8| { 10u8 == *x };\n+    h((), (), &1u8);\n+\n+    [1, 2, 3u8].into_iter().any(|elt| 10 == *elt);\n+}\n+\n+fn main() {\n+    test_iterator_step_by_nth();\n+    iter_any();\n+    iter_empty_and_zst();\n+}"}, {"sha": "b14eb074488b29244744dd496a86dff277c5955d", "filename": "tests/run-pass/iter_any.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e5972c38a3322e8ab98aead64d75f63fe4c7c75d/tests%2Frun-pass%2Fiter_any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5972c38a3322e8ab98aead64d75f63fe4c7c75d/tests%2Frun-pass%2Fiter_any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fiter_any.rs?ref=e5972c38a3322e8ab98aead64d75f63fe4c7c75d", "patch": "@@ -1,12 +0,0 @@\n-pub fn main() {\n-    let f = |x: &u8| { 10u8 == *x };\n-    f(&1u8);\n-\n-    let g = |(), x: &u8| { 10u8 == *x };\n-    g((), &1u8);\n-\n-    let h = |(), (), x: &u8| { 10u8 == *x };\n-    h((), (), &1u8);\n-\n-    [1, 2, 3u8].into_iter().any(|elt| 10 == *elt);\n-}"}, {"sha": "fd7229c3455e4da6a491d289b056fad62c91282a", "filename": "tests/run-pass/iter_slice.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e5972c38a3322e8ab98aead64d75f63fe4c7c75d/tests%2Frun-pass%2Fiter_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5972c38a3322e8ab98aead64d75f63fe4c7c75d/tests%2Frun-pass%2Fiter_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fiter_slice.rs?ref=e5972c38a3322e8ab98aead64d75f63fe4c7c75d", "patch": "@@ -1,12 +0,0 @@\n-fn main() {\n-    for _ in Vec::<u32>::new().iter() { // this iterates over a Unique::empty()\n-        panic!(\"We should never be here.\");\n-    }\n-\n-    // Iterate over a ZST (uses arith_offset internally)\n-    let mut count = 0;\n-    for _ in &[(), (), ()] {\n-        count += 1;\n-    }\n-    assert_eq!(count, 3);\n-}"}, {"sha": "8ec1d56ab77092155fe02d60abf5cc789aa6132b", "filename": "travis.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e747e14cd59d9682d91795fab2f47ce624b65d/travis.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c6e747e14cd59d9682d91795fab2f47ce624b65d/travis.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/travis.sh?ref=c6e747e14cd59d9682d91795fab2f47ce624b65d", "patch": "@@ -1,5 +1,5 @@\n #!/bin/bash\n-set -e\n+set -euo pipefail\n \n # Determine configuration\n if [ \"$TRAVIS_OS_NAME\" == osx ]; then"}]}