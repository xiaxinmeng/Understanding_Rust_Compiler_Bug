{"sha": "99398dd2fd46c24857707ee5db8c7a90f0811850", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5Mzk4ZGQyZmQ0NmMyNDg1NzcwN2VlNWRiOGM3YTkwZjA4MTE4NTA=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-14T09:32:50Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-01T21:35:30Z"}, "message": "BTreeMap::drain_filter no longer touches the root during iteration", "tree": {"sha": "80dddc29388784e2aa179c180bebbbb4b31a4a26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80dddc29388784e2aa179c180bebbbb4b31a4a26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99398dd2fd46c24857707ee5db8c7a90f0811850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99398dd2fd46c24857707ee5db8c7a90f0811850", "html_url": "https://github.com/rust-lang/rust/commit/99398dd2fd46c24857707ee5db8c7a90f0811850", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99398dd2fd46c24857707ee5db8c7a90f0811850/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "602f9aab89791ac2e63d0a41731ddf0a9b727f29", "url": "https://api.github.com/repos/rust-lang/rust/commits/602f9aab89791ac2e63d0a41731ddf0a9b727f29", "html_url": "https://github.com/rust-lang/rust/commit/602f9aab89791ac2e63d0a41731ddf0a9b727f29"}], "stats": {"total": 103, "additions": 73, "deletions": 30}, "files": [{"sha": "6184051316ef801584398bd5083d8d2b02229967", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 64, "deletions": 23, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/99398dd2fd46c24857707ee5db8c7a90f0811850/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99398dd2fd46c24857707ee5db8c7a90f0811850/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=99398dd2fd46c24857707ee5db8c7a90f0811850", "patch": "@@ -174,7 +174,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n \n                     {\n                         let out_root = BTreeMap::ensure_is_owned(&mut out_tree.root);\n-                        let mut out_node = out_root.push_level();\n+                        let mut out_node = out_root.push_internal_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n@@ -1080,9 +1080,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                                 test_node = parent.forget_type();\n                             }\n                         }\n-                        Err(node) => {\n+                        Err(_) => {\n                             // We are at the top, create a new root node and push there.\n-                            open_node = node.into_root_mut().push_level();\n+                            open_node = root.push_internal_level();\n                             break;\n                         }\n                     }\n@@ -1092,7 +1092,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 let tree_height = open_node.height() - 1;\n                 let mut right_tree = node::Root::new_leaf();\n                 for _ in 0..tree_height {\n-                    right_tree.push_level();\n+                    right_tree.push_internal_level();\n                 }\n                 open_node.push(key, value, right_tree);\n \n@@ -1171,7 +1171,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut right = Self::new();\n         let right_root = Self::ensure_is_owned(&mut right.root);\n         for _ in 0..left_root.height() {\n-            right_root.push_level();\n+            right_root.push_internal_level();\n         }\n \n         {\n@@ -1255,7 +1255,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n     pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n         let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n-        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n+        DrainFilterInner {\n+            length: &mut self.length,\n+            cur_leaf_edge: front,\n+            emptied_internal_root: false,\n+        }\n     }\n \n     /// Calculates the number of elements if it is incorrect.\n@@ -1625,6 +1629,7 @@ where\n pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    emptied_internal_root: bool,\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n@@ -1665,6 +1670,17 @@ where\n     }\n }\n \n+impl<K, V> Drop for DrainFilterInner<'_, K, V> {\n+    fn drop(&mut self) {\n+        if self.emptied_internal_root {\n+            if let Some(handle) = self.cur_leaf_edge.take() {\n+                let root = handle.into_node().into_root_mut();\n+                root.pop_internal_level();\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n     /// Allow Debug implementations to predict the next element.\n     pub(super) fn peek(&self) -> Option<(&K, &V)> {\n@@ -1681,9 +1697,10 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n-                let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n-                self.cur_leaf_edge = Some(leaf_edge_location);\n-                return Some((k, v));\n+                let RemoveResult { old_kv, pos, emptied_internal_root } = kv.remove_kv_tracking();\n+                self.cur_leaf_edge = Some(pos);\n+                self.emptied_internal_root |= emptied_internal_root;\n+                return Some(old_kv);\n             }\n             self.cur_leaf_edge = Some(kv.next_leaf_edge());\n         }\n@@ -2477,7 +2494,7 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n                     }\n                 },\n                 Err(root) => {\n-                    root.push_level().push(ins_k, ins_v, ins_edge);\n+                    root.push_internal_level().push(ins_k, ins_v, ins_edge);\n                     return unsafe { &mut *out_ptr };\n                 }\n             }\n@@ -2647,20 +2664,35 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         self.remove_kv().1\n     }\n \n+    // Body of `remove_entry`, separate to keep the above implementations short.\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let (old_key, old_val, _) = self.handle.remove_kv_tracking();\n-        (old_key, old_val)\n+        let RemoveResult { old_kv, pos, emptied_internal_root } = self.handle.remove_kv_tracking();\n+        let root = pos.into_node().into_root_mut();\n+        if emptied_internal_root {\n+            root.pop_internal_level();\n+        }\n+        old_kv\n     }\n }\n \n+struct RemoveResult<'a, K, V> {\n+    // Key and value removed.\n+    old_kv: (K, V),\n+    // Unique location at the leaf level that the removed KV lopgically collapsed into.\n+    pos: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    // Whether the remove left behind and empty internal root node, that should be removed\n+    // using `pop_internal_level`.\n+    emptied_internal_root: bool,\n+}\n+\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    /// Removes a key/value-pair from the map, and returns that pair, as well as\n-    /// the leaf edge corresponding to that former pair.\n-    fn remove_kv_tracking(\n-        self,\n-    ) -> (K, V, Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+    /// Removes a key/value-pair from the tree, and returns that pair, as well as\n+    /// the leaf edge corresponding to that former pair. It's possible this leaves\n+    /// an empty internal root node, which the caller should subsequently pop from\n+    /// the map holding the tree. The caller should also decrement the map's length.\n+    fn remove_kv_tracking(self) -> RemoveResult<'a, K, V> {\n         let (mut pos, old_key, old_val, was_internal) = match self.force() {\n             Leaf(leaf) => {\n                 let (hole, old_key, old_val) = leaf.remove();\n@@ -2689,6 +2721,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n         };\n \n         // Handle underflow\n+        let mut emptied_internal_root = false;\n         let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n         let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n@@ -2709,8 +2742,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n \n                     let parent = edge.into_node();\n                     if parent.len() == 0 {\n-                        // We must be at the root\n-                        parent.into_root_mut().pop_level();\n+                        // This empty parent must be the root, and should be popped off the tree.\n+                        emptied_internal_root = true;\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n@@ -2737,15 +2770,15 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n             pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n         }\n \n-        (old_key, old_val, pos)\n+        RemoveResult { old_kv: (old_key, old_val), pos, emptied_internal_root }\n     }\n }\n \n impl<K, V> node::Root<K, V> {\n     /// Removes empty levels on the top, but keep an empty leaf if the entire tree is empty.\n     fn fix_top(&mut self) {\n         while self.height() > 0 && self.as_ref().len() == 0 {\n-            self.pop_level();\n+            self.pop_internal_level();\n         }\n     }\n \n@@ -2817,8 +2850,16 @@ fn handle_underfull_node<K, V>(\n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n         Err(parent) => {\n-            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n-            (false, right)\n+            match parent.right_kv() {\n+                Ok(right) => (false, right),\n+                Err(_) => {\n+                    // The underfull node has an empty parent, so it is the only child\n+                    // of an empty root. It is destined to become the new root, thus\n+                    // allowed to be underfull. The empty parent should be removed later\n+                    // by `pop_internal_level`.\n+                    return AtRoot;\n+                }\n+            }\n         }\n     };\n "}, {"sha": "4a7497a983297291b33f8b7264cc62da1dfc614e", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99398dd2fd46c24857707ee5db8c7a90f0811850/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99398dd2fd46c24857707ee5db8c7a90f0811850/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=99398dd2fd46c24857707ee5db8c7a90f0811850", "patch": "@@ -191,8 +191,9 @@ impl<K, V> Root<K, V> {\n     }\n \n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n-    /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n-    pub fn push_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n+    /// new node the root. This increases the height by 1 and is the opposite of\n+    /// `pop_internal_level`.\n+    pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n@@ -213,11 +214,12 @@ impl<K, V> Root<K, V> {\n         ret\n     }\n \n-    /// Removes the root node, using its first child as the new root. This cannot be called when\n-    /// the tree consists only of a leaf node. As it is intended only to be called when the root\n-    /// has only one edge, no cleanup is done on any of the other children of the root.\n-    /// This decreases the height by 1 and is the opposite of `push_level`.\n-    pub fn pop_level(&mut self) {\n+    /// Removes the internal root node, using its first child as the new root.\n+    /// As it is intended only to be called when the root has only one child,\n+    /// no cleanup is done on any of the other children of the root.\n+    /// This decreases the height by 1 and is the opposite of `push_internal_level`.\n+    /// Panics if there is no internal level, i.e. if the root is a leaf.\n+    pub fn pop_internal_level(&mut self) {\n         assert!(self.height > 0);\n \n         let top = self.node.ptr;"}]}