{"sha": "74b2783877d5f6906a2e532828203f155054d8f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YjI3ODM4NzdkNWY2OTA2YTJlNTMyODI4MjAzZjE1NTA1NGQ4Zjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-01T22:44:25Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T20:21:56Z"}, "message": "delete dead code", "tree": {"sha": "a1291960703f2771520d12a3862b21b25f178f08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1291960703f2771520d12a3862b21b25f178f08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74b2783877d5f6906a2e532828203f155054d8f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74b2783877d5f6906a2e532828203f155054d8f9", "html_url": "https://github.com/rust-lang/rust/commit/74b2783877d5f6906a2e532828203f155054d8f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74b2783877d5f6906a2e532828203f155054d8f9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fa1ba3e7ed22e9610ba06618538a7b14f61a9ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa1ba3e7ed22e9610ba06618538a7b14f61a9ff", "html_url": "https://github.com/rust-lang/rust/commit/2fa1ba3e7ed22e9610ba06618538a7b14f61a9ff"}], "stats": {"total": 430, "additions": 3, "deletions": 427}, "files": [{"sha": "cec157b03ac0ab3f5da4fc8db27b538273d8fce3", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 87, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/74b2783877d5f6906a2e532828203f155054d8f9/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74b2783877d5f6906a2e532828203f155054d8f9/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=74b2783877d5f6906a2e532828203f155054d8f9", "patch": "@@ -26,15 +26,12 @@ use util::nodemap::{DefIdSet, NodeSet};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n-use std::option;\n use std::fmt::Debug;\n use std::hash::Hash;\n-use std::iter::{self, Once};\n use std::mem;\n use std::collections::BTreeMap;\n use std::ops::Deref;\n use std::rc::Rc;\n-use std::vec;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::symbol::Symbol;\n \n@@ -161,67 +158,6 @@ impl<'tcx> Value<'tcx> for ty::SymbolName {\n     }\n }\n \n-trait IntoKeyValues<K: Key, V> {\n-    type KeyValues: IntoIterator<Item=(K, V)>;\n-\n-    fn into_key_values(key: &K, value: Self) -> Self::KeyValues;\n-}\n-\n-impl<K: Key, V> IntoKeyValues<K, V> for V {\n-    type KeyValues = Once<(K, V)>;\n-\n-    fn into_key_values(key: &K, value: Self) -> Self::KeyValues {\n-        iter::once((key.clone(), value))\n-    }\n-}\n-\n-/// Return type for a multi-query, which is a query which may (if it\n-/// chooses) return more than one (key, value) pair. Construct a\n-/// `Multi` using `Multi::from(...)`.\n-pub struct Multi<K: Key, V> {\n-    single: Option<V>,\n-    map: Vec<(K, V)>,\n-}\n-\n-impl<K: Key, V> Multi<K, V> {\n-    pub fn iter<'a>(&'a self, key: &'a K) -> impl Iterator<Item = (&'a K, &'a V)> + 'a {\n-        self.single.iter()\n-                   .map(move |v| (key, v))\n-                   .chain(self.map.iter().map(move |&(ref k, ref v)| (k, v)))\n-    }\n-}\n-\n-/// Construct a `Multi` from a single value.\n-impl<K: Key, V> From<V> for Multi<K, V> {\n-    fn from(value: V) -> Self {\n-        Multi {\n-            single: Some(value),\n-            map: vec![],\n-        }\n-    }\n-}\n-\n-/// Construct a `Multi` from a hashmap of (K, V) pairs.\n-impl<K: Key, V> From<Vec<(K, V)>> for Multi<K, V> {\n-    fn from(value: Vec<(K, V)>) -> Self {\n-        Multi {\n-            single: None,\n-            map: value\n-        }\n-    }\n-}\n-\n-impl<K: Key, V> IntoKeyValues<K, V> for Multi<K, V> {\n-    type KeyValues = iter::Chain<option::IntoIter<(K, V)>, vec::IntoIter<(K, V)>>;\n-\n-    fn into_key_values(key: &K, value: Self) -> Self::KeyValues {\n-        value.single\n-             .map(|v| (key.clone(), v))\n-             .into_iter()\n-             .chain(value.map)\n-    }\n-}\n-\n pub struct CycleError<'a, 'tcx: 'a> {\n     span: Span,\n     cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n@@ -490,14 +426,7 @@ macro_rules! define_maps {\n                     provider(tcx.global_tcx(), key)\n                 })?;\n \n-                {\n-                    let map = &mut *tcx.maps.$name.borrow_mut();\n-                    for (k, v) in IntoKeyValues::<$K, $V>::into_key_values(&key, result) {\n-                        map.insert(k, v);\n-                    }\n-                }\n-\n-                Ok(f(tcx.maps.$name.borrow().get(&key).expect(\"value just generated\")))\n+                Ok(f(tcx.maps.$name.borrow_mut().entry(key).or_insert(result)))\n             }\n \n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n@@ -683,20 +612,6 @@ macro_rules! define_provider_struct {\n         }\n     };\n \n-    // The `multi` modifier indicates a **multiquery**, in which case\n-    // the function returns a `Multi<K,V>` instead of just a value\n-    // `V`.\n-    (tcx: $tcx:tt,\n-     input: (([multi $($other_modifiers:tt)*] $name:tt [$K:ty] [$V:ty]) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            ready: ($name [$K] [Multi<$K,$V>]),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n     // Regular queries produce a `V` only.\n     (tcx: $tcx:tt,\n      input: (([] $name:tt $K:tt $V:tt) $($input:tt)*),\n@@ -709,7 +624,7 @@ macro_rules! define_provider_struct {\n         }\n     };\n \n-    // Skip modifiers other than `multi`.\n+    // Skip modifiers.\n     (tcx: $tcx:tt,\n      input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n      output: $output:tt) => {"}, {"sha": "977b9d2e994473d8c6e66c14b309ecf66719f032", "filename": "src/librustc_mir/callgraph.rs", "status": "removed", "additions": 0, "deletions": 249, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/2fa1ba3e7ed22e9610ba06618538a7b14f61a9ff/src%2Flibrustc_mir%2Fcallgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa1ba3e7ed22e9610ba06618538a7b14f61a9ff/src%2Flibrustc_mir%2Fcallgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fcallgraph.rs?ref=2fa1ba3e7ed22e9610ba06618538a7b14f61a9ff", "patch": "@@ -1,249 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! MIR-based callgraph.\n-//!\n-//! This only considers direct calls\n-\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_data_structures::graph;\n-\n-use rustc::mir::*;\n-use rustc::mir::visit::*;\n-\n-use rustc::ty;\n-\n-use rustc::util::nodemap::DefIdMap;\n-\n-use transform::interprocedural::InterproceduralCx;\n-\n-pub struct CallGraph {\n-    node_map: DefIdMap<graph::NodeIndex>,\n-    graph: graph::Graph<DefId, ()>\n-}\n-\n-impl CallGraph {\n-    pub fn build<'a, 'tcx>(cx: &mut InterproceduralCx<'a, 'tcx>) -> CallGraph {\n-        let mut callgraph = CallGraph {\n-            node_map: DefIdMap(),\n-            graph: graph::Graph::new()\n-        };\n-\n-        for &def_id in cx.tcx.mir_keys(LOCAL_CRATE).iter() {\n-            let idx = callgraph.add_node(def_id);\n-\n-            let mut call_visitor = CallVisitor {\n-                caller: idx,\n-                graph: &mut callgraph\n-            };\n-\n-            if let Some(mir) = cx.ensure_mir_and_read(def_id) {\n-                call_visitor.visit_mir(mir);\n-            }\n-        }\n-\n-        callgraph\n-    }\n-\n-    // Iterate over the strongly-connected components of the graph\n-    pub fn scc_iter(&self) -> SCCIterator {\n-        SCCIterator::new(&self.graph)\n-    }\n-\n-    // Get the def_id for the given graph node\n-    pub fn def_id(&self, node: graph::NodeIndex) -> DefId {\n-        *self.graph.node_data(node)\n-    }\n-\n-    fn add_node(&mut self, id: DefId) -> graph::NodeIndex {\n-        let graph = &mut self.graph;\n-        *self.node_map.entry(id).or_insert_with(|| {\n-            graph.add_node(id)\n-        })\n-    }\n-}\n-\n-struct CallVisitor<'a> {\n-    caller: graph::NodeIndex,\n-    graph: &'a mut CallGraph\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for CallVisitor<'a> {\n-    fn visit_terminator_kind(&mut self, _block: BasicBlock,\n-                             kind: &TerminatorKind<'tcx>, _loc: Location) {\n-        if let TerminatorKind::Call {\n-            func: Operand::Constant(ref f)\n-            , .. } = *kind {\n-            if let ty::TyFnDef(def_id, _, _) = f.ty.sty {\n-                let callee = self.graph.add_node(def_id);\n-                self.graph.graph.add_edge(self.caller, callee, ());\n-            }\n-        }\n-    }\n-}\n-\n-struct StackElement<'g> {\n-    node: graph::NodeIndex,\n-    lowlink: usize,\n-    children: graph::AdjacentTargets<'g, DefId, ()>\n-}\n-\n-/**\n- * Iterator over strongly-connected-components using Tarjan's algorithm[1]\n- *\n- * [1]: https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n- */\n-pub struct SCCIterator<'g> {\n-    graph: &'g graph::Graph<DefId, ()>,\n-    index: usize,\n-    node_indices: Vec<Option<usize>>,\n-    scc_stack: Vec<graph::NodeIndex>,\n-    current_scc: Vec<graph::NodeIndex>,\n-    visit_stack: Vec<StackElement<'g>>,\n-}\n-\n-impl<'g> SCCIterator<'g> {\n-    pub fn new(graph: &'g graph::Graph<DefId, ()>) -> SCCIterator<'g> {\n-        if graph.len_nodes() == 0 {\n-            return SCCIterator {\n-                graph: graph,\n-                index: 0,\n-                node_indices: Vec::new(),\n-                scc_stack: Vec::new(),\n-                current_scc: Vec::new(),\n-                visit_stack: Vec::new()\n-            };\n-        }\n-\n-        let first = graph::NodeIndex(0);\n-\n-        SCCIterator::with_entry(graph, first)\n-    }\n-\n-    pub fn with_entry(graph: &'g graph::Graph<DefId, ()>,\n-                      entry: graph::NodeIndex) -> SCCIterator<'g> {\n-        let mut iter = SCCIterator {\n-            graph: graph,\n-            index: 0,\n-            node_indices: Vec::with_capacity(graph.len_nodes()),\n-            scc_stack: Vec::new(),\n-            current_scc: Vec::new(),\n-            visit_stack: Vec::new()\n-        };\n-\n-        iter.visit_one(entry);\n-\n-        iter\n-    }\n-\n-    fn get_next(&mut self) {\n-        self.current_scc.clear();\n-\n-        while !self.visit_stack.is_empty() {\n-            self.visit_children();\n-\n-            let node = self.visit_stack.pop().unwrap();\n-\n-            if let Some(last) = self.visit_stack.last_mut() {\n-                if last.lowlink > node.lowlink {\n-                    last.lowlink = node.lowlink;\n-                }\n-            }\n-\n-            debug!(\"TarjanSCC: Popped node {:?} : lowlink = {:?}; index = {:?}\",\n-                   node.node, node.lowlink, self.node_index(node.node).unwrap());\n-\n-            if node.lowlink != self.node_index(node.node).unwrap() {\n-                continue;\n-            }\n-\n-            loop {\n-                let n = self.scc_stack.pop().unwrap();\n-                self.current_scc.push(n);\n-                self.set_node_index(n, !0);\n-                if n == node.node { return; }\n-            }\n-        }\n-    }\n-\n-    fn visit_one(&mut self, node: graph::NodeIndex) {\n-        self.index += 1;\n-        let idx =  self.index;\n-        self.set_node_index(node, idx);\n-        self.scc_stack.push(node);\n-        self.visit_stack.push(StackElement {\n-            node: node,\n-            lowlink: self.index,\n-            children: self.graph.successor_nodes(node)\n-        });\n-        debug!(\"TarjanSCC: Node {:?} : index = {:?}\", node, idx);\n-    }\n-\n-    fn visit_children(&mut self) {\n-        while let Some(child) = self.visit_stack.last_mut().unwrap().children.next() {\n-            if let Some(child_num) = self.node_index(child) {\n-                let cur = self.visit_stack.last_mut().unwrap();\n-                if cur.lowlink > child_num {\n-                    cur.lowlink = child_num;\n-                }\n-            } else {\n-                self.visit_one(child);\n-            }\n-        }\n-    }\n-\n-    fn node_index(&self, node: graph::NodeIndex) -> Option<usize> {\n-        self.node_indices.get(node.node_id()).and_then(|&idx| idx)\n-    }\n-\n-    fn set_node_index(&mut self, node: graph::NodeIndex, idx: usize) {\n-        let i = node.node_id();\n-        if i >= self.node_indices.len() {\n-            self.node_indices.resize(i + 1, None);\n-        }\n-        self.node_indices[i] = Some(idx);\n-    }\n-}\n-\n-impl<'g> Iterator for SCCIterator<'g> {\n-    type Item = Vec<graph::NodeIndex>;\n-\n-    fn next(&mut self) -> Option<Vec<graph::NodeIndex>> {\n-        self.get_next();\n-\n-        if self.current_scc.is_empty() {\n-            // Try a new root for the next SCC, if the node_indices\n-            // map is doesn't contain all nodes, use the smallest one\n-            // with no entry, otherwise find the first empty node.\n-            //\n-            // FIXME: This should probably use a set of precomputed\n-            // roots instead\n-            if self.node_indices.len() < self.graph.len_nodes() {\n-                let idx = graph::NodeIndex(self.node_indices.len());\n-                self.visit_one(idx);\n-            } else {\n-                for idx in 0..self.node_indices.len() {\n-                    if self.node_indices[idx].is_none() {\n-                        let idx = graph::NodeIndex(idx);\n-                        self.visit_one(idx);\n-                        break;\n-                    }\n-                }\n-            }\n-            self.get_next();\n-        }\n-\n-        if self.current_scc.is_empty() {\n-            None\n-        } else {\n-            Some(self.current_scc.clone())\n-        }\n-    }\n-}"}, {"sha": "0213dbc730279e71e0b5cb44d209f40f4d9ffa6e", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74b2783877d5f6906a2e532828203f155054d8f9/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74b2783877d5f6906a2e532828203f155054d8f9/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=74b2783877d5f6906a2e532828203f155054d8f9", "patch": "@@ -46,8 +46,7 @@ extern crate rustc_const_eval;\n \n pub mod diagnostics;\n \n-pub mod build;\n-pub mod callgraph;\n+mod build;\n mod hair;\n mod shim;\n mod queries;"}, {"sha": "7a2645567e24e8b8a45ffe16fe08f58a0c0ef6a6", "filename": "src/librustc_mir/transform/interprocedural.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2fa1ba3e7ed22e9610ba06618538a7b14f61a9ff/src%2Flibrustc_mir%2Ftransform%2Finterprocedural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa1ba3e7ed22e9610ba06618538a7b14f61a9ff/src%2Flibrustc_mir%2Ftransform%2Finterprocedural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finterprocedural.rs?ref=2fa1ba3e7ed22e9610ba06618538a7b14f61a9ff", "patch": "@@ -1,88 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir::def_id::DefId;\n-use rustc::mir::Mir;\n-use rustc::mir::transform::{PassId};\n-use rustc::ty::steal::Steal;\n-use rustc::ty::TyCtxt;\n-use rustc_data_structures::fx::FxHashMap;\n-\n-/// When writing inter-procedural analyses etc, we need to read (and\n-/// steal) the MIR for a number of def-ids at once, not all of which\n-/// are local. This little cache code attempts to remember what you've\n-/// stolen and so forth. It is more of a placeholder meant to get\n-/// inlining up and going again, and is probably going to need heavy\n-/// revision as we scale up to more interesting optimizations.\n-pub struct InterproceduralCx<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    local_cache: FxHashMap<DefId, Mir<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> InterproceduralCx<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        InterproceduralCx {\n-            tcx: tcx,\n-            local_cache: FxHashMap::default(),\n-        }\n-    }\n-\n-    pub fn into_local_mirs(self) -> Vec<(PassId, &'tcx Steal<Mir<'tcx>>)> {\n-        unimplemented!()\n-    }\n-\n-    /// Ensures that the mir for `def_id` is available, if it can be\n-    /// made available.\n-    pub fn ensure_mir(&mut self, def_id: DefId) {\n-        if def_id.is_local() {\n-            self.ensure_mir_and_read(def_id);\n-        }\n-    }\n-\n-    /// Ensures that the mir for `def_id` is available and returns it if possible;\n-    /// returns `None` if this is a cross-crate MIR that is not\n-    /// available from metadata.\n-    pub fn ensure_mir_and_read(&mut self, def_id: DefId) -> Option<&Mir<'tcx>> {\n-        if def_id.is_local() {\n-            Some(self.mir_mut(def_id))\n-        } else {\n-            self.tcx.maybe_item_mir(def_id)\n-        }\n-    }\n-\n-    /// True if the local cache contains MIR for `def-id`.\n-    pub fn contains_mir(&self, def_id: DefId) -> bool {\n-        if def_id.is_local() {\n-            self.local_cache.contains_key(&def_id)\n-        } else {\n-            self.tcx.is_item_mir_available(def_id)\n-        }\n-    }\n-\n-    /// Reads the MIR for `def-id`. If the MIR is local, this will\n-    /// panic if you have not previously invoked `ensure_mir`.\n-    pub fn mir(&self, def_id: DefId) -> Option<&Mir<'tcx>> {\n-        if def_id.is_local() {\n-            match self.local_cache.get(&def_id) {\n-                Some(p) => Some(p),\n-                None => {\n-                    panic!(\"MIR for local def-id `{:?}` not previously ensured\", def_id)\n-                }\n-            }\n-        } else {\n-            self.tcx.maybe_item_mir(def_id)\n-        }\n-    }\n-\n-    pub fn mir_mut(&mut self, def_id: DefId) -> &mut Mir<'tcx> {\n-        assert!(def_id.is_local(), \"cannot get mutable mir of remote entry\");\n-        unimplemented!()\n-    }\n-}"}, {"sha": "e835a79a8bc3a07b401951f47e8029bcd500776f", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74b2783877d5f6906a2e532828203f155054d8f9/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74b2783877d5f6906a2e532828203f155054d8f9/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=74b2783877d5f6906a2e532828203f155054d8f9", "patch": "@@ -26,7 +26,6 @@ pub mod deaggregator;\n pub mod instcombine;\n pub mod copy_prop;\n pub mod inline;\n-pub mod interprocedural;\n \n pub(crate) fn provide(providers: &mut Providers) {\n     self::qualify_consts::provide(providers);"}]}