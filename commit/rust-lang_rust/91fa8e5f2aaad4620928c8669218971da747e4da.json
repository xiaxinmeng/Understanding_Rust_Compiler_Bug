{"sha": "91fa8e5f2aaad4620928c8669218971da747e4da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZmE4ZTVmMmFhYWQ0NjIwOTI4Yzg2NjkyMTg5NzFkYTc0N2U0ZGE=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-04-04T11:57:39Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-05-16T16:55:29Z"}, "message": "arena: add docs for Arena", "tree": {"sha": "62aa66d0eba70b47b6da0acbbdcf7235e921ef25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62aa66d0eba70b47b6da0acbbdcf7235e921ef25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91fa8e5f2aaad4620928c8669218971da747e4da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91fa8e5f2aaad4620928c8669218971da747e4da", "html_url": "https://github.com/rust-lang/rust/commit/91fa8e5f2aaad4620928c8669218971da747e4da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91fa8e5f2aaad4620928c8669218971da747e4da/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30250d3de8d730d977d157f92e5671c87df855ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/30250d3de8d730d977d157f92e5671c87df855ab", "html_url": "https://github.com/rust-lang/rust/commit/30250d3de8d730d977d157f92e5671c87df855ab"}], "stats": {"total": 62, "additions": 34, "deletions": 28}, "files": [{"sha": "f49bffe06d3930cc07f1aec9c87732b91f00771b", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/91fa8e5f2aaad4620928c8669218971da747e4da/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fa8e5f2aaad4620928c8669218971da747e4da/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=91fa8e5f2aaad4620928c8669218971da747e4da", "patch": "@@ -14,6 +14,10 @@\n //! once, once the arena itself is destroyed. They do not support deallocation\n //! of individual objects while the arena itself is still alive. The benefit\n //! of an arena is very fast allocation; just a pointer bump.\n+//!\n+//! This crate has two arenas implemented: TypedArena, which is a simpler\n+//! arena but can only hold objects of a single type, and Arena, which is a\n+//! more complex, slower Arena which can hold objects of any type.\n \n #![crate_id = \"arena#0.11.0-pre\"]\n #![crate_type = \"rlib\"]\n@@ -56,41 +60,42 @@ impl Chunk {\n     }\n }\n \n-// Arenas are used to quickly allocate objects that share a\n-// lifetime. The arena uses ~[u8] vectors as a backing store to\n-// allocate objects from. For each allocated object, the arena stores\n-// a pointer to the type descriptor followed by the\n-// object. (Potentially with alignment padding after each of them.)\n-// When the arena is destroyed, it iterates through all of its chunks,\n-// and uses the tydesc information to trace through the objects,\n-// calling the destructors on them.\n-// One subtle point that needs to be addressed is how to handle\n-// failures while running the user provided initializer function. It\n-// is important to not run the destructor on uninitialized objects, but\n-// how to detect them is somewhat subtle. Since alloc() can be invoked\n-// recursively, it is not sufficient to simply exclude the most recent\n-// object. To solve this without requiring extra space, we use the low\n-// order bit of the tydesc pointer to encode whether the object it\n-// describes has been fully initialized.\n-\n-// As an optimization, objects with destructors are stored in\n-// different chunks than objects without destructors. This reduces\n-// overhead when initializing plain-old-data and means we don't need\n-// to waste time running the destructors of POD.\n+/// A slower reflection-based arena that can allocate objects of any type.\n+///\n+/// This arena uses Vec<u8> as a backing store to allocate objects from.  For\n+/// each allocated object, the arena stores a pointer to the type descriptor\n+/// followed by the object. (Potentially with alignment padding after each\n+/// element.) When the arena is destroyed, it iterates through all of its\n+/// chunks, and uses the tydesc information to trace through the objects,\n+/// calling the destructors on them.  One subtle point that needs to be\n+/// addressed is how to handle failures while running the user provided\n+/// initializer function. It is important to not run the destructor on\n+/// uninitialized objects, but how to detect them is somewhat subtle. Since\n+/// alloc() can be invoked recursively, it is not sufficient to simply exclude\n+/// the most recent object. To solve this without requiring extra space, we\n+/// use the low order bit of the tydesc pointer to encode whether the object\n+/// it describes has been fully initialized.\n+///\n+/// As an optimization, objects with destructors are stored in\n+/// different chunks than objects without destructors. This reduces\n+/// overhead when initializing plain-old-data and means we don't need\n+/// to waste time running the destructors of POD.\n pub struct Arena {\n     // The head is separated out from the list as a unbenchmarked\n-    // microoptimization, to avoid needing to case on the list to\n-    // access the head.\n+    // microoptimization, to avoid needing to case on the list to access the\n+    // head.\n     head: Chunk,\n     copy_head: Chunk,\n     chunks: RefCell<Vec<Chunk>>,\n }\n \n impl Arena {\n+    /// Allocate a new Arena with 32 bytes preallocated.\n     pub fn new() -> Arena {\n         Arena::new_with_size(32u)\n     }\n \n+    /// Allocate a new Arena with `initial_size` bytes preallocated.\n     pub fn new_with_size(initial_size: uint) -> Arena {\n         Arena {\n             head: chunk(initial_size, false),\n@@ -265,7 +270,8 @@ impl Arena {\n         }\n     }\n \n-    // The external interface\n+    /// Allocate a new item in the arena, using `op` to initialize the value\n+    /// and returning a reference to it.\n     #[inline]\n     pub fn alloc<'a, T>(&'a self, op: || -> T) -> &'a T {\n         unsafe {\n@@ -313,7 +319,7 @@ fn test_arena_destructors_fail() {\n     });\n }\n \n-/// An arena that can hold objects of only one type.\n+/// A faster arena that can hold objects of only one type.\n ///\n /// Safety note: Modifying objects in the arena that have already had their\n /// `drop` destructors run can cause leaks, because the destructor will not\n@@ -405,13 +411,13 @@ impl<T> TypedArenaChunk<T> {\n }\n \n impl<T> TypedArena<T> {\n-    /// Creates a new arena with preallocated space for 8 objects.\n+    /// Creates a new TypedArena with preallocated space for 8 objects.\n     #[inline]\n     pub fn new() -> TypedArena<T> {\n         TypedArena::with_capacity(8)\n     }\n \n-    /// Creates a new arena with preallocated space for the given number of\n+    /// Creates a new TypedArena with preallocated space for the given number of\n     /// objects.\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n@@ -423,7 +429,7 @@ impl<T> TypedArena<T> {\n         }\n     }\n \n-    /// Allocates an object into this arena.\n+    /// Allocates an object in the TypedArena, returning a reference to it.\n     #[inline]\n     pub fn alloc<'a>(&'a self, object: T) -> &'a T {\n         unsafe {"}]}