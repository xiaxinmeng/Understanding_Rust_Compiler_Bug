{"sha": "ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkOGEzZWIwMzljYTNkYzFmZjVhM2Q1NzU3YWZjNWU1MzMwYzFiY2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-15T13:58:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-15T13:58:03Z"}, "message": "Auto merge of #58140 - eddyb:advent-of-print, r=nikomatsakis\n\nRefactor ppaux out of existence.\n\nA long-time coming, this PR reorganizes and rewrites the pretty-printing architecture of rustc, specifically the parts that involve the typesystem (which used to be in `rustc::util::ppaux`).\n\n*Note: these commits used to be in #57967 before being split off.*\n\nThe new API (i.e. the `Printer` and `PrettyPrint` traits) is in `rustc::ty::print`.\n\nDesign points, roughly:\n* using associated types in `Printer` to allow building e.g. an AST, not just printing as a side-effect\n* several overloading points for implementers of `PrettyPrinter`, e.g. how `<...>` is printed\n* for `fmt::Display` impls, the value to print is lifted to the `ty::tls` `tcx`, and everything after that stays within the `ty::print` API, which requires `'tcx` to match between values and the printer's `tcx`, without going through `fmt::Display` again\n\nMost of the behavior is unchanged, except for a few details, which should be clear from the test changes.\n\nr? @nikomatsakis\n\nFixes https://github.com/rust-lang/rust/issues/55464", "tree": {"sha": "9d51335b0eff0734c9913a3ec245e235f974fa85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d51335b0eff0734c9913a3ec245e235f974fa85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "html_url": "https://github.com/rust-lang/rust/commit/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16e7e05e95a6a5a1e0dba54ae722274bd7d725f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/16e7e05e95a6a5a1e0dba54ae722274bd7d725f7", "html_url": "https://github.com/rust-lang/rust/commit/16e7e05e95a6a5a1e0dba54ae722274bd7d725f7"}, {"sha": "dbf19c3975a014861535b775b2fb7cd71e6c5042", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf19c3975a014861535b775b2fb7cd71e6c5042", "html_url": "https://github.com/rust-lang/rust/commit/dbf19c3975a014861535b775b2fb7cd71e6c5042"}], "stats": {"total": 6340, "additions": 3407, "deletions": 2933}, "files": [{"sha": "07be27c2f5a0238a24a2523989a836139b87a434", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -48,7 +48,6 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/test/pretty \\\n \t\tsrc/test/run-pass/pretty \\\n \t\tsrc/test/run-fail/pretty \\\n \t\tsrc/test/run-pass-valgrind/pretty \\"}, {"sha": "81e09bc878a1087d40dfad356150f3a87bb3e7e6", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -897,12 +897,10 @@ host_test!(Rustdoc {\n     suite: \"rustdoc\"\n });\n \n-test!(Pretty {\n+host_test!(Pretty {\n     path: \"src/test/pretty\",\n     mode: \"pretty\",\n-    suite: \"pretty\",\n-    default: false,\n-    host: true\n+    suite: \"pretty\"\n });\n test!(RunPassPretty {\n     path: \"src/test/run-pass/pretty\",\n@@ -993,11 +991,7 @@ impl Step for Compiletest {\n             });\n         }\n \n-        if suite.ends_with(\"fulldeps\") ||\n-            // FIXME: Does pretty need librustc compiled? Note that there are\n-            // fulldeps test suites with mode = pretty as well.\n-            mode == \"pretty\"\n-        {\n+        if suite.ends_with(\"fulldeps\") {\n             builder.ensure(compile::Rustc { compiler, target });\n         }\n "}, {"sha": "eb75e624d34b2982ebff060f9ed42d609de36548", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -724,7 +724,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefId {\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.item_path_str(*self)\n+        tcx.def_path_str(*self)\n     }\n }\n \n@@ -736,7 +736,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefIndex {\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.item_path_str(DefId::local(*self))\n+        tcx.def_path_str(DefId::local(*self))\n     }\n }\n "}, {"sha": "397843fd75afa1d7f118af8002f58bb9e5608727", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -249,7 +249,7 @@ impl DefId {\n         if self.is_local() && self.index == CRATE_DEF_INDEX {\n             format!(\"top-level module\")\n         } else {\n-            format!(\"module `{}`\", tcx.item_path_str(*self))\n+            format!(\"module `{}`\", tcx.def_path_str(*self))\n         }\n     }\n }"}, {"sha": "dca4ce4aef81773e9ac5879a6fd0e750560f53f9", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -679,13 +679,13 @@ impl DefPathData {\n                 return name\n             }\n             // note that this does not show up in user printouts\n-            CrateRoot => \"{{root}}\",\n+            CrateRoot => \"{{crate}}\",\n             Impl => \"{{impl}}\",\n-            Misc => \"{{?}}\",\n+            Misc => \"{{misc}}\",\n             ClosureExpr => \"{{closure}}\",\n             StructCtor => \"{{constructor}}\",\n             AnonConst => \"{{constant}}\",\n-            ImplTrait => \"{{impl-Trait}}\",\n+            ImplTrait => \"{{opaque}}\",\n         };\n \n         Symbol::intern(s).as_interned_str()"}, {"sha": "600e7e21e9998fd0a7bf301d772ca326c34a93e4", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1351,7 +1351,8 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n         // the user-friendly path, otherwise fall back to stringifying DefPath.\n         crate::ty::tls::with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n-                tcx.node_path_str(id)\n+                let def_id = map.local_def_id(id);\n+                tcx.def_path_str(def_id)\n             } else if let Some(path) = map.def_path_from_id(id) {\n                 path.data.into_iter().map(|elem| {\n                     elem.data.to_string()"}, {"sha": "2810b5a8e6ada5cad0922392a80cd56c44f0dd5b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 114, "deletions": 15, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     self.hir().span_by_hir_id(node),\n                 ),\n                 _ => (\n-                    format!(\"the lifetime {} as defined on\", fr.bound_region),\n+                    format!(\"the lifetime {} as defined on\", region),\n                     cm.def_span(self.hir().span_by_hir_id(node)),\n                 ),\n             },\n@@ -444,17 +444,109 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         terr: &TypeError<'tcx>,\n         sp: Span,\n     ) {\n+        use hir::def_id::CrateNum;\n+        use hir::map::DisambiguatedDefPathData;\n+        use ty::print::Printer;\n+        use ty::subst::Kind;\n+\n+        struct AbsolutePathPrinter<'a, 'gcx, 'tcx> {\n+            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        }\n+\n+        struct NonTrivialPath;\n+\n+        impl<'gcx, 'tcx> Printer<'gcx, 'tcx> for AbsolutePathPrinter<'_, 'gcx, 'tcx> {\n+            type Error = NonTrivialPath;\n+\n+            type Path = Vec<String>;\n+            type Region = !;\n+            type Type = !;\n+            type DynExistential = !;\n+\n+            fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+                self.tcx\n+            }\n+\n+            fn print_region(\n+                self,\n+                _region: ty::Region<'_>,\n+            ) -> Result<Self::Region, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n+            fn print_type(\n+                self,\n+                _ty: Ty<'tcx>,\n+            ) -> Result<Self::Type, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n+            fn print_dyn_existential(\n+                self,\n+                _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+            ) -> Result<Self::DynExistential, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n+            fn path_crate(\n+                self,\n+                cnum: CrateNum,\n+            ) -> Result<Self::Path, Self::Error> {\n+                Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n+            }\n+            fn path_qualified(\n+                self,\n+                _self_ty: Ty<'tcx>,\n+                _trait_ref: Option<ty::TraitRef<'tcx>>,\n+            ) -> Result<Self::Path, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n+            fn path_append_impl(\n+                self,\n+                _print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                _disambiguated_data: &DisambiguatedDefPathData,\n+                _self_ty: Ty<'tcx>,\n+                _trait_ref: Option<ty::TraitRef<'tcx>>,\n+            ) -> Result<Self::Path, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+            fn path_append(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                disambiguated_data: &DisambiguatedDefPathData,\n+            ) -> Result<Self::Path, Self::Error> {\n+                let mut path = print_prefix(self)?;\n+                path.push(disambiguated_data.data.as_interned_str().to_string());\n+                Ok(path)\n+            }\n+            fn path_generic_args(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                _args: &[Kind<'tcx>],\n+            ) -> Result<Self::Path, Self::Error> {\n+                print_prefix(self)\n+            }\n+        }\n+\n         let report_path_match = |err: &mut DiagnosticBuilder<'_>, did1: DefId, did2: DefId| {\n             // Only external crates, if either is from a local\n             // module we could have false positives\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n-                let exp_path = self.tcx.item_path_str(did1);\n-                let found_path = self.tcx.item_path_str(did2);\n-                let exp_abs_path = self.tcx.absolute_item_path_str(did1);\n-                let found_abs_path = self.tcx.absolute_item_path_str(did2);\n+                let abs_path = |def_id| {\n+                    AbsolutePathPrinter { tcx: self.tcx }\n+                        .print_def_path(def_id, &[])\n+                };\n+\n                 // We compare strings because DefPath can be different\n                 // for imported and non-imported crates\n-                if exp_path == found_path || exp_abs_path == found_abs_path {\n+                let same_path = || -> Result<_, NonTrivialPath> {\n+                    Ok(\n+                        self.tcx.def_path_str(did1) == self.tcx.def_path_str(did2) ||\n+                        abs_path(did1)? == abs_path(did2)?\n+                    )\n+                };\n+                if same_path().unwrap_or(false) {\n                     let crate_name = self.tcx.crate_name(did1.krate);\n                     err.span_note(\n                         sp,\n@@ -658,7 +750,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 return Some(());\n             }\n             if let &ty::Adt(def, _) = &ta.sty {\n-                let path_ = self.tcx.item_path_str(def.did.clone());\n+                let path_ = self.tcx.def_path_str(def.did.clone());\n                 if path_ == other_path {\n                     self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n                     return Some(());\n@@ -683,7 +775,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// For generic types with parameters with defaults, remove the parameters corresponding to\n-    /// the defaults. This repeats a lot of the logic found in `PrintContext::parameterized`.\n+    /// the defaults. This repeats a lot of the logic found in `ty::print::pretty`.\n     fn strip_generic_default_params(\n         &self,\n         def_id: DefId,\n@@ -742,11 +834,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             mutbl: hir::Mutability,\n             s: &mut DiagnosticStyledString,\n         ) {\n-            let r = &r.to_string();\n+            let mut r = r.to_string();\n+            if r == \"'_\" {\n+                r.clear();\n+            } else {\n+                r.push(' ');\n+            }\n             s.push_highlighted(format!(\n-                \"&{}{}{}\",\n+                \"&{}{}\",\n                 r,\n-                if r == \"\" { \"\" } else { \" \" },\n                 if mutbl == hir::MutMutable { \"mut \" } else { \"\" }\n             ));\n             s.push_normal(ty.to_string());\n@@ -757,8 +853,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let sub_no_defaults_1 = self.strip_generic_default_params(def1.did, sub1);\n                 let sub_no_defaults_2 = self.strip_generic_default_params(def2.did, sub2);\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n-                let path1 = self.tcx.item_path_str(def1.did.clone());\n-                let path2 = self.tcx.item_path_str(def2.did.clone());\n+                let path1 = self.tcx.def_path_str(def1.did.clone());\n+                let path2 = self.tcx.def_path_str(def2.did.clone());\n                 if def1.did == def2.did {\n                     // Easy case. Replace same types with `_` to shorten the output and highlight\n                     // the differing ones.\n@@ -1013,7 +1109,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             if exp_is_struct && &exp_found.expected == ret_ty.skip_binder() {\n                                 let message = format!(\n                                     \"did you mean `{}(/* fields */)`?\",\n-                                    self.tcx.item_path_str(def_id)\n+                                    self.tcx.def_path_str(def_id)\n                                 );\n                                 diag.span_label(span, message);\n                             }\n@@ -1425,7 +1521,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         var_origin: RegionVariableOrigin,\n     ) -> DiagnosticBuilder<'tcx> {\n         let br_string = |br: ty::BoundRegion| {\n-            let mut s = br.to_string();\n+            let mut s = match br {\n+                ty::BrNamed(_, name) => name.to_string(),\n+                _ => String::new(),\n+            };\n             if !s.is_empty() {\n                 s.push_str(\" \");\n             }"}, {"sha": "0a83b839201ed299557903253fd250e8b7c47e70", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,8 +1,10 @@\n+use crate::hir::def::Namespace;\n use crate::hir::{self, Local, Pat, Body, HirId};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOrigin;\n use crate::ty::{self, Ty, Infer, TyVar};\n+use crate::ty::print::Print;\n use syntax::source_map::CompilerDesugaringKind;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n@@ -64,18 +66,26 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n \n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    pub fn extract_type_name(&self, ty: &'a Ty<'tcx>) -> String {\n+    pub fn extract_type_name(\n+        &self,\n+        ty: &'a Ty<'tcx>,\n+        highlight: Option<ty::print::RegionHighlightMode>,\n+    ) -> String {\n         if let ty::Infer(ty::TyVar(ty_vid)) = (*ty).sty {\n             let ty_vars = self.type_variables.borrow();\n             if let TypeVariableOrigin::TypeParameterDefinition(_, name) =\n                 *ty_vars.var_origin(ty_vid) {\n-                name.to_string()\n-            } else {\n-                ty.to_string()\n+                return name.to_string();\n             }\n-        } else {\n-            ty.to_string()\n         }\n+\n+        let mut s = String::new();\n+        let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n+        if let Some(highlight) = highlight {\n+            printer.region_highlight_mode = highlight;\n+        }\n+        let _ = ty.print(printer);\n+        s\n     }\n \n     pub fn need_type_info_err(&self,\n@@ -84,7 +94,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             ty: Ty<'tcx>)\n                             -> DiagnosticBuilder<'gcx> {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n-        let name = self.extract_type_name(&ty);\n+        let name = self.extract_type_name(&ty, None);\n \n         let mut err_span = span;\n         let mut labels = vec![("}, {"sha": "e708454b5b672fcd936f3c0e42ef53059ba6bbc8", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 125, "deletions": 108, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,14 +1,17 @@\n use errors::DiagnosticBuilder;\n+use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::ValuePairs;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n-use crate::ty;\n+use crate::ty::{self, TyCtxt};\n use crate::ty::error::ExpectedFound;\n use crate::ty::subst::SubstsRef;\n-use crate::util::ppaux::RegionHighlightMode;\n+use crate::ty::print::{Print, RegionHighlightMode, FmtPrinter};\n+\n+use std::fmt::{self, Write};\n \n impl NiceRegionError<'me, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n@@ -193,15 +196,15 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             cause.span(&self.tcx()),\n             &format!(\n                 \"implementation of `{}` is not general enough\",\n-                self.tcx().item_path_str(trait_def_id),\n+                self.tcx().def_path_str(trait_def_id),\n             ),\n         );\n \n         match cause.code {\n             ObligationCauseCode::ItemObligation(def_id) => {\n                 err.note(&format!(\n                     \"Due to a where-clause on `{}`,\",\n-                    self.tcx().item_path_str(def_id),\n+                    self.tcx().def_path_str(def_id),\n                 ));\n             }\n             _ => (),\n@@ -309,13 +312,46 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         sup_placeholder: Option<ty::Region<'tcx>>,\n         has_sub: Option<usize>,\n         has_sup: Option<usize>,\n-        expected_trait_ref: ty::TraitRef<'_>,\n-        actual_trait_ref: ty::TraitRef<'_>,\n+        expected_trait_ref: ty::TraitRef<'tcx>,\n+        actual_trait_ref: ty::TraitRef<'tcx>,\n         vid: Option<ty::Region<'tcx>>,\n         expected_has_vid: Option<usize>,\n         actual_has_vid: Option<usize>,\n         any_self_ty_has_vid: bool,\n     ) {\n+        // HACK(eddyb) maybe move this in a more central location.\n+        #[derive(Copy, Clone)]\n+        struct Highlighted<'a, 'gcx, 'tcx, T> {\n+            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+            highlight: RegionHighlightMode,\n+            value: T,\n+        }\n+\n+        impl<'a, 'gcx, 'tcx, T> Highlighted<'a, 'gcx, 'tcx, T> {\n+            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'a, 'gcx, 'tcx, U> {\n+                Highlighted {\n+                    tcx: self.tcx,\n+                    highlight: self.highlight,\n+                    value: f(self.value),\n+                }\n+            }\n+        }\n+\n+        impl<'a, 'gcx, 'tcx, T> fmt::Display for Highlighted<'a, 'gcx, 'tcx, T>\n+            where T: for<'b, 'c> Print<'gcx, 'tcx,\n+                FmtPrinter<'a, 'gcx, 'tcx, &'b mut fmt::Formatter<'c>>,\n+                Error = fmt::Error,\n+            >,\n+        {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                let mut printer = ty::print::FmtPrinter::new(self.tcx, f, Namespace::TypeNS);\n+                printer.region_highlight_mode = self.highlight;\n+\n+                self.value.print(printer)?;\n+                Ok(())\n+            }\n+        }\n+\n         // The weird thing here with the `maybe_highlighting_region` calls and the\n         // the match inside is meant to be like this:\n         //\n@@ -331,112 +367,93 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         // None, an then we check again inside the closure, but this\n         // setup sort of minimized the number of calls and so form.\n \n-        RegionHighlightMode::maybe_highlighting_region(sub_placeholder, has_sub, || {\n-            RegionHighlightMode::maybe_highlighting_region(sup_placeholder, has_sup, || {\n-                match (has_sub, has_sup) {\n-                    (Some(n1), Some(n2)) => {\n-                        if any_self_ty_has_vid {\n-                            err.note(&format!(\n-                                \"`{}` would have to be implemented for the type `{}`, \\\n-                                 for any two lifetimes `'{}` and `'{}`\",\n-                                expected_trait_ref,\n-                                expected_trait_ref.self_ty(),\n-                                std::cmp::min(n1, n2),\n-                                std::cmp::max(n1, n2),\n-                            ));\n-                        } else {\n-                            err.note(&format!(\n-                                \"`{}` must implement `{}`, \\\n-                                 for any two lifetimes `'{}` and `'{}`\",\n-                                expected_trait_ref.self_ty(),\n-                                expected_trait_ref,\n-                                std::cmp::min(n1, n2),\n-                                std::cmp::max(n1, n2),\n-                            ));\n-                        }\n-                    }\n-                    (Some(n), _) | (_, Some(n)) => {\n-                        if any_self_ty_has_vid {\n-                            err.note(&format!(\n-                                \"`{}` would have to be implemented for the type `{}`, \\\n-                                 for any lifetime `'{}`\",\n-                                expected_trait_ref,\n-                                expected_trait_ref.self_ty(),\n-                                n,\n-                            ));\n-                        } else {\n-                            err.note(&format!(\n-                                \"`{}` must implement `{}`, for any lifetime `'{}`\",\n-                                expected_trait_ref.self_ty(),\n-                                expected_trait_ref,\n-                                n,\n-                            ));\n-                        }\n-                    }\n-                    (None, None) => RegionHighlightMode::maybe_highlighting_region(\n-                        vid,\n-                        expected_has_vid,\n-                        || {\n-                            if let Some(n) = expected_has_vid {\n-                                err.note(&format!(\n-                                    \"`{}` would have to be implemented for the type `{}`, \\\n-                                     for some specific lifetime `'{}`\",\n-                                    expected_trait_ref,\n-                                    expected_trait_ref.self_ty(),\n-                                    n,\n-                                ));\n-                            } else {\n-                                if any_self_ty_has_vid {\n-                                    err.note(&format!(\n-                                        \"`{}` would have to be implemented for the type `{}`\",\n-                                        expected_trait_ref,\n-                                        expected_trait_ref.self_ty(),\n-                                    ));\n-                                } else {\n-                                    err.note(&format!(\n-                                        \"`{}` must implement `{}`\",\n-                                        expected_trait_ref.self_ty(),\n-                                        expected_trait_ref,\n-                                    ));\n-                                }\n-                            }\n-                        },\n-                    ),\n-                }\n-            })\n-        });\n+        let highlight_trait_ref = |trait_ref| Highlighted {\n+            tcx: self.tcx(),\n+            highlight: RegionHighlightMode::default(),\n+            value: trait_ref,\n+        };\n \n-        RegionHighlightMode::maybe_highlighting_region(\n-            vid,\n-            actual_has_vid,\n-            || match actual_has_vid {\n-                Some(n) => {\n-                    if any_self_ty_has_vid {\n-                        err.note(&format!(\n-                            \"but `{}` is actually implemented for the type `{}`, \\\n-                             for some specific lifetime `'{}`\",\n-                            actual_trait_ref,\n-                            actual_trait_ref.self_ty(),\n-                            n\n-                        ));\n-                    } else {\n-                        err.note(&format!(\n-                            \"but `{}` actually implements `{}`, for some specific lifetime `'{}`\",\n-                            actual_trait_ref.self_ty(),\n-                            actual_trait_ref,\n-                            n\n-                        ));\n+        let mut expected_trait_ref = highlight_trait_ref(expected_trait_ref);\n+        expected_trait_ref.highlight.maybe_highlighting_region(sub_placeholder, has_sub);\n+        expected_trait_ref.highlight.maybe_highlighting_region(sup_placeholder, has_sup);\n+        err.note(&{\n+            let passive_voice = match (has_sub, has_sup) {\n+                (Some(_), _) | (_, Some(_)) => any_self_ty_has_vid,\n+                (None, None) => {\n+                    expected_trait_ref.highlight.maybe_highlighting_region(vid, expected_has_vid);\n+                    match expected_has_vid {\n+                        Some(_) => true,\n+                        None => any_self_ty_has_vid,\n                     }\n                 }\n+            };\n \n-                _ => {\n-                    err.note(&format!(\n-                        \"but `{}` is actually implemented for the type `{}`\",\n-                        actual_trait_ref,\n-                        actual_trait_ref.self_ty(),\n-                    ));\n+            let mut note = if passive_voice {\n+                format!(\n+                    \"`{}` would have to be implemented for the type `{}`\",\n+                    expected_trait_ref,\n+                    expected_trait_ref.map(|tr| tr.self_ty()),\n+                )\n+            } else {\n+                format!(\n+                    \"`{}` must implement `{}`\",\n+                    expected_trait_ref.map(|tr| tr.self_ty()),\n+                    expected_trait_ref,\n+                )\n+            };\n+\n+            match (has_sub, has_sup) {\n+                (Some(n1), Some(n2)) => {\n+                    let _ = write!(note,\n+                        \", for any two lifetimes `'{}` and `'{}`\",\n+                        std::cmp::min(n1, n2),\n+                        std::cmp::max(n1, n2),\n+                    );\n                 }\n-            },\n-        );\n+                (Some(n), _) | (_, Some(n)) => {\n+                    let _ = write!(note,\n+                        \", for any lifetime `'{}`\",\n+                        n,\n+                    );\n+                }\n+                (None, None) => if let Some(n) = expected_has_vid {\n+                    let _ = write!(note,\n+                        \", for some specific lifetime `'{}`\",\n+                        n,\n+                    );\n+                },\n+            }\n+\n+            note\n+        });\n+\n+        let mut actual_trait_ref = highlight_trait_ref(actual_trait_ref);\n+        actual_trait_ref.highlight.maybe_highlighting_region(vid, actual_has_vid);\n+        err.note(&{\n+            let passive_voice = match actual_has_vid {\n+                Some(_) => any_self_ty_has_vid,\n+                None => true,\n+            };\n+\n+            let mut note = if passive_voice {\n+                format!(\n+                    \"but `{}` is actually implemented for the type `{}`\",\n+                    actual_trait_ref,\n+                    actual_trait_ref.map(|tr| tr.self_ty()),\n+                )\n+            } else {\n+                format!(\n+                    \"but `{}` actually implements `{}`\",\n+                    actual_trait_ref.map(|tr| tr.self_ty()),\n+                    actual_trait_ref,\n+                )\n+            };\n+\n+            if let Some(n) = actual_has_vid {\n+                let _ = write!(note, \", for some specific lifetime `'{}`\", n);\n+            }\n+\n+            note\n+        });\n     }\n }"}, {"sha": "3ed28a1f9882562f495db732b2052a5dc41f46b9", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -3,7 +3,7 @@\n \n use crate::hir;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::ty::{self, Region, Ty};\n+use crate::ty::{self, DefIdTree, Region, Ty};\n use crate::hir::def_id::DefId;\n use syntax_pos::Span;\n \n@@ -44,7 +44,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         let (id, bound_region) = match *anon_region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n             ty::ReEarlyBound(ref ebr) => (\n-                self.tcx().parent_def_id(ebr.def_id).unwrap(),\n+                self.tcx().parent(ebr.def_id).unwrap(),\n                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n             ),\n             _ => return None, // not a free region"}, {"sha": "5349e990a77613781b2916e30530251ba0f0218b", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -91,7 +91,7 @@ impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n     type Lifted = FreeRegionMap<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n-        self.relation.maybe_map(|&fr| fr.lift_to_tcx(tcx))\n+        self.relation.maybe_map(|&fr| tcx.lift(&fr))\n                      .map(|relation| FreeRegionMap { relation })\n     }\n }"}, {"sha": "b6677326227f4e00b365a36b7f53509f240bfa56", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -31,6 +31,7 @@\n #![deny(rust_2018_idioms)]\n #![allow(explicit_outlives_requirements)]\n \n+#![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n@@ -134,7 +135,6 @@ pub mod ty;\n pub mod util {\n     pub mod captures;\n     pub mod common;\n-    pub mod ppaux;\n     pub mod nodemap;\n     pub mod profiling;\n     pub mod bug;"}, {"sha": "3da82d728c0c4b96dd2201563668ed55fe456a8b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -12,7 +12,7 @@ use crate::hir::CodegenFnAttrFlags;\n use crate::hir::def_id::{DefId, LOCAL_CRATE};\n use crate::lint;\n use crate::middle::privacy;\n-use crate::ty::{self, TyCtxt};\n+use crate::ty::{self, DefIdTree, TyCtxt};\n use crate::util::nodemap::FxHashSet;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -78,7 +78,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Def::PrimTy(..) | Def::SelfTy(..) | Def::SelfCtor(..) |\n             Def::Local(..) | Def::Upvar(..) => {}\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                if let Some(enum_id) = self.tcx.parent_def_id(variant_id) {\n+                if let Some(enum_id) = self.tcx.parent(variant_id) {\n                     self.check_def_id(enum_id);\n                 }\n                 if !self.ignore_variant_stack.contains(&variant_id) {"}, {"sha": "b36d2a57cb3b1d3f4043e86599eaaa4c1c60242f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -64,7 +64,7 @@ use crate::hir::Node;\n use crate::infer::InferCtxt;\n use crate::hir::def::{Def, CtorKind};\n use crate::ty::adjustment;\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::layout::VariantIdx;\n \n@@ -786,7 +786,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n \n-        let kind = match self.node_ty(fn_hir_id)?.sty {\n+        let ty = self.node_ty(fn_hir_id)?;\n+        let kind = match ty.sty {\n             ty::Generator(..) => ty::ClosureKind::FnOnce,\n             ty::Closure(closure_def_id, closure_substs) => {\n                 match self.infcx {\n@@ -803,7 +804,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                 .closure_kind(closure_def_id, self.tcx.global_tcx()),\n                 }\n             }\n-            ref t => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", t),\n+            _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),\n         };\n \n         let closure_expr_def_id = self.tcx.hir().local_def_id(fn_node_id);\n@@ -1064,7 +1065,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 let bk = ty::BorrowKind::from_mutbl(mutbl);\n                 BorrowedPtr(bk, r)\n             }\n-            ref ty => bug!(\"unexpected type in cat_deref: {:?}\", ty)\n+            _ => bug!(\"unexpected type in cat_deref: {:?}\", base_cmt.ty)\n         };\n         let ret = cmt_ {\n             hir_id: node.hir_id(),\n@@ -1132,7 +1133,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                              variant_did: DefId)\n                                              -> cmt<'tcx> {\n         // univariant enums do not need downcasts\n-        let base_did = self.tcx.parent_def_id(variant_did).unwrap();\n+        let base_did = self.tcx.parent(variant_did).unwrap();\n         if self.tcx.adt_def(base_did).variants.len() != 1 {\n             let base_ty = base_cmt.ty;\n             let ret = Rc::new(cmt_ {\n@@ -1274,16 +1275,17 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         return Err(())\n                     }\n                     Def::VariantCtor(def_id, CtorKind::Fn) => {\n-                        let enum_def = self.tcx.parent_def_id(def_id).unwrap();\n+                        let enum_def = self.tcx.parent(def_id).unwrap();\n                         (self.cat_downcast_if_needed(pat, cmt, def_id),\n                         self.tcx.adt_def(enum_def).variant_with_id(def_id).fields.len())\n                     }\n                     Def::StructCtor(_, CtorKind::Fn) | Def::SelfCtor(..) => {\n-                        match self.pat_ty_unadjusted(&pat)?.sty {\n+                        let ty = self.pat_ty_unadjusted(&pat)?;\n+                        match ty.sty {\n                             ty::Adt(adt_def, _) => {\n                                 (cmt, adt_def.non_enum_variant().fields.len())\n                             }\n-                            ref ty => {\n+                            _ => {\n                                 span_bug!(pat.span,\n                                           \"tuple struct pattern unexpected type {:?}\", ty);\n                             }\n@@ -1334,9 +1336,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n             PatKind::Tuple(ref subpats, ddpos) => {\n                 // (p1, ..., pN)\n-                let expected_len = match self.pat_ty_unadjusted(&pat)?.sty {\n+                let ty = self.pat_ty_unadjusted(&pat)?;\n+                let expected_len = match ty.sty {\n                     ty::Tuple(ref tys) => tys.len(),\n-                    ref ty => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n+                    _ => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n                 };\n                 for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                     let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)"}, {"sha": "2b3802388106a89e5fc689ae33febf33b0f108a6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -17,7 +17,7 @@ use rustc_macros::HashStable;\n use syntax::source_map;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::ty::TyCtxt;\n+use crate::ty::{DefIdTree, TyCtxt};\n use crate::ty::query::Providers;\n \n use crate::hir;\n@@ -650,7 +650,7 @@ impl<'tcx> ScopeTree {\n     pub fn early_free_scope<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                       br: &ty::EarlyBoundRegion)\n                                       -> Scope {\n-        let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n+        let param_owner = tcx.parent(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n         let scope = tcx.hir().maybe_body_owned_by_by_hir_id(param_owner_id).map(|body_id| {\n@@ -679,7 +679,7 @@ impl<'tcx> ScopeTree {\n                                  -> Scope {\n         let param_owner = match fr.bound_region {\n             ty::BoundRegion::BrNamed(def_id, _) => {\n-                tcx.parent_def_id(def_id).unwrap()\n+                tcx.parent(def_id).unwrap()\n             }\n             _ => fr.scope\n         };"}, {"sha": "0a2a375e1b2c154e37fedad45e0c4853581b7baf", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -593,7 +593,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n                 if !skip {\n-                    let path = self.item_path_str(def_id);\n+                    let path = self.def_path_str(def_id);\n                     let message = format!(\"use of deprecated item '{}'\", path);\n                     lint_deprecated(def_id,\n                                     id,\n@@ -620,7 +620,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if let Some(id) = id {\n             if let Some(stability) = stability {\n                 if let Some(depr) = &stability.rustc_depr {\n-                    let path = self.item_path_str(def_id);\n+                    let path = self.def_path_str(def_id);\n                     if deprecation_in_effect(&depr.since.as_str()) {\n                         let message = format!(\"use of deprecated item '{}'\", path);\n                         lint_deprecated(def_id,"}, {"sha": "718b506d051135e188b6cc68e2febf9a307dde62", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -2,7 +2,7 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/index.html\n \n-use crate::hir::def::CtorKind;\n+use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n use crate::hir::{self, HirId, InlineAsm};\n use crate::mir::interpret::{ConstValue, EvalErrorKind, Scalar};\n@@ -34,7 +34,7 @@ use crate::ty::{\n     self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n     UserTypeAnnotationIndex,\n };\n-use crate::util::ppaux;\n+use crate::ty::print::{FmtPrinter, Printer};\n \n pub use crate::mir::interpret::AssertMessage;\n \n@@ -2062,7 +2062,7 @@ impl<'tcx> Debug for Place<'tcx> {\n             Base(PlaceBase::Static(box self::Static { def_id, ty })) => write!(\n                 fmt,\n                 \"({}: {:?})\",\n-                ty::tls::with(|tcx| tcx.item_path_str(def_id)),\n+                ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n                 ty\n             ),\n             Base(PlaceBase::Promoted(ref promoted)) => write!(\n@@ -2369,7 +2369,10 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 };\n \n                 // When printing regions, add trailing space if necessary.\n-                let region = if ppaux::verbose() || ppaux::identify_regions() {\n+                let print_region = ty::tls::with(|tcx| {\n+                    tcx.sess.verbose() || tcx.sess.opts.debugging_opts.identify_regions\n+                });\n+                let region = if print_region {\n                     let mut region = region.to_string();\n                     if region.len() > 0 {\n                         region.push(' ');\n@@ -2403,7 +2406,13 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     AggregateKind::Adt(adt_def, variant, substs, _user_ty, _) => {\n                         let variant_def = &adt_def.variants[variant];\n \n-                        ppaux::parameterized(fmt, substs, variant_def.did, &[])?;\n+                        let f = &mut *fmt;\n+                        ty::tls::with(|tcx| {\n+                            let substs = tcx.lift(&substs).expect(\"could not lift for printing\");\n+                            FmtPrinter::new(tcx, f, Namespace::ValueNS)\n+                                .print_def_path(variant_def.did, substs)?;\n+                            Ok(())\n+                        })?;\n \n                         match variant_def.ctor_kind {\n                             CtorKind::Const => Ok(()),\n@@ -2729,7 +2738,7 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: ty::Const<'_>) -> fmt::Resul\n     }\n     // print function definitions\n     if let FnDef(did, _) = ty.sty {\n-        return write!(f, \"{}\", item_path_str(did));\n+        return write!(f, \"{}\", def_path_str(did));\n     }\n     // print string literals\n     if let ConstValue::Slice(ptr, len) = value {\n@@ -2754,8 +2763,8 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: ty::Const<'_>) -> fmt::Resul\n     write!(f, \"{:?}:{}\", value, ty)\n }\n \n-fn item_path_str(def_id: DefId) -> String {\n-    ty::tls::with(|tcx| tcx.item_path_str(def_id))\n+fn def_path_str(def_id: DefId) -> String {\n+    ty::tls::with(|tcx| tcx.def_path_str(def_id))\n }\n \n impl<'tcx> graph::DirectedGraph for Mir<'tcx> {"}, {"sha": "6c8fe0875b60c232a0cac7db751294a696901cfb", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -854,10 +854,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     _ => vec![ArgKind::empty()],\n                 };\n \n-                let expected = match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n+                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n+                let expected = match expected_ty.sty {\n                     ty::Tuple(ref tys) => tys.iter()\n                         .map(|t| ArgKind::from_expected_ty(t, Some(span))).collect(),\n-                    ref sty => vec![ArgKind::Arg(\"_\".to_owned(), sty.to_string())],\n+                    _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n                 };\n \n                 if found.len() == expected.len() {\n@@ -1284,11 +1285,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let span = self.sess.source_map().def_span(span);\n         let mut err = struct_span_err!(self.sess, span, E0072,\n                                        \"recursive type `{}` has infinite size\",\n-                                       self.item_path_str(type_def_id));\n+                                       self.def_path_str(type_def_id));\n         err.span_label(span, \"recursive type has infinite size\");\n         err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n                            at some point to make `{}` representable\",\n-                          self.item_path_str(type_def_id)));\n+                          self.def_path_str(type_def_id)));\n         err\n     }\n \n@@ -1298,7 +1299,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                       violations: Vec<ObjectSafetyViolation>)\n                                       -> DiagnosticBuilder<'tcx>\n     {\n-        let trait_str = self.item_path_str(trait_def_id);\n+        let trait_str = self.def_path_str(trait_def_id);\n         let span = self.sess.source_map().def_span(span);\n         let mut err = struct_span_err!(\n             self.sess, span, E0038,\n@@ -1523,7 +1524,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                   region, object_ty));\n             }\n             ObligationCauseCode::ItemObligation(item_def_id) => {\n-                let item_name = tcx.item_path_str(item_def_id);\n+                let item_name = tcx.def_path_str(item_def_id);\n                 let msg = format!(\"required by `{}`\", item_name);\n \n                 if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n@@ -1686,10 +1687,10 @@ impl ArgKind {\n             ty::Tuple(ref tys) => ArgKind::Tuple(\n                 span,\n                 tys.iter()\n-                   .map(|ty| (\"_\".to_owned(), ty.sty.to_string()))\n+                   .map(|ty| (\"_\".to_owned(), ty.to_string()))\n                    .collect::<Vec<_>>()\n             ),\n-            _ => ArgKind::Arg(\"_\".to_owned(), t.sty.to_string()),\n+            _ => ArgKind::Arg(\"_\".to_owned(), t.to_string()),\n         }\n     }\n }"}, {"sha": "78c80b48ee80d9756f6b15ada676db838c25e650", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -650,7 +650,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n ) -> bool {\n     debug!(\"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n            ty,\n-           infcx.tcx.item_path_str(def_id));\n+           infcx.tcx.def_path_str(def_id));\n \n     let trait_ref = ty::TraitRef {\n         def_id,\n@@ -665,7 +665,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n \n     let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n     debug!(\"type_known_to_meet_ty={:?} bound={} => {:?}\",\n-           ty, infcx.tcx.item_path_str(def_id), result);\n+           ty, infcx.tcx.def_path_str(def_id), result);\n \n     if result && (ty.has_infer_types() || ty.has_closure_types()) {\n         // Because of inference \"guessing\", selection can sometimes claim\n@@ -692,13 +692,13 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n             Ok(()) => {\n                 debug!(\"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n                        ty,\n-                       infcx.tcx.item_path_str(def_id));\n+                       infcx.tcx.def_path_str(def_id));\n                 true\n             }\n             Err(e) => {\n                 debug!(\"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} errors={:?}\",\n                        ty,\n-                       infcx.tcx.item_path_str(def_id),\n+                       infcx.tcx.def_path_str(def_id),\n                        e);\n                 false\n             }"}, {"sha": "1c8ea5c7b9c5b0dd437301f536a24c15e19472f9", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                         hir::CRATE_HIR_ID,\n                         *span,\n                         &format!(\"the trait `{}` cannot be made into an object\",\n-                                 self.item_path_str(trait_def_id)),\n+                                 self.def_path_str(trait_def_id)),\n                         &violation.error_msg());\n                     false\n                 } else {"}, {"sha": "fc0058a1df5ffebc19bd4be54718ed7e5ef40d51", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                   -> String\n     {\n         let name = tcx.item_name(trait_ref.def_id);\n-        let trait_str = tcx.item_path_str(trait_ref.def_id);\n+        let trait_str = tcx.def_path_str(trait_ref.def_id);\n         let generics = tcx.generics_of(trait_ref.def_id);\n         let generic_map = generics.params.iter().filter_map(|param| {\n             let value = match param.kind {"}, {"sha": "ab6acc662131b4663c57c06978cb2eeafa531ae2", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1549,7 +1549,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n         // should have failed in astconv.\n         bug!(\"No associated type `{}` for {}\",\n              assoc_ty_name,\n-             tcx.item_path_str(impl_def_id))\n+             tcx.def_path_str(impl_def_id))\n     }\n }\n "}, {"sha": "c576586fcad8ea21aa178266d64810988a11a281", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -411,7 +411,7 @@ fn to_pretty_impl_header(tcx: TyCtxt<'_, '_, '_>, impl_def_id: DefId) -> Option<\n         w.push('<');\n         w.push_str(&substs.iter()\n             .map(|k| k.to_string())\n-            .filter(|k| &k[..] != \"'_\")\n+            .filter(|k| k != \"'_\")\n             .collect::<Vec<_>>().join(\", \"));\n         w.push('>');\n     }"}, {"sha": "f3a800bf46d87e8f8cfafeec0218032aed18dfc9", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -165,7 +165,8 @@ impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use crate::traits::WhereClause::*;\n \n-        // Bypass ppaux because it does not print out anonymous regions.\n+        // Bypass `ty::print` because it does not print out anonymous regions.\n+        // FIXME(eddyb) implement a custom `PrettyPrinter`, or move this to `ty::print`.\n         fn write_region_name<'tcx>(\n             r: ty::Region<'tcx>,\n             fmt: &mut fmt::Formatter<'_>\n@@ -256,7 +257,7 @@ impl fmt::Display for traits::QuantifierKind {\n }\n \n /// Collect names for regions / types bound by a quantified goal / clause.\n-/// This collector does not try to do anything clever like in ppaux, it's just used\n+/// This collector does not try to do anything clever like in `ty::print`, it's just used\n /// for debug output in tests anyway.\n struct BoundNamesCollector {\n     // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway."}, {"sha": "1942f98abff17ab58e6dcb2b79ad140421138f22", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -26,7 +26,7 @@ use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n use crate::traits;\n use crate::traits::{Clause, Clauses, GoalKind, Goal, Goals};\n-use crate::ty::{self, Ty, TypeAndMut};\n+use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n use crate::ty::{TyS, TyKind, List};\n use crate::ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const, LazyConst};\n use crate::ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n@@ -1594,7 +1594,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n             ty::ReEarlyBound(ref ebr) => (\n-                self.parent_def_id(ebr.def_id).unwrap(),\n+                self.parent(ebr.def_id).unwrap(),\n                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n             ),\n             _ => return None, // not a free region"}, {"sha": "fa3c76a817a4fbc22a0c814df380d6bf170d0f4e", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -71,6 +71,13 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n         }\n \n+        let br_string = |br: ty::BoundRegion| {\n+            match br {\n+                ty::BrNamed(_, name) => format!(\" {}\", name),\n+                _ => String::new(),\n+            }\n+        };\n+\n         match *self {\n             CyclicTy(_) => write!(f, \"cyclic type of infinite size\"),\n             Mismatch => write!(f, \"types differ\"),\n@@ -105,15 +112,13 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n             RegionsInsufficientlyPolymorphic(br, _) => {\n                 write!(f,\n-                       \"expected bound lifetime parameter{}{}, found concrete lifetime\",\n-                       if br.is_named() { \" \" } else { \"\" },\n-                       br)\n+                       \"expected bound lifetime parameter{}, found concrete lifetime\",\n+                       br_string(br))\n             }\n             RegionsOverlyPolymorphic(br, _) => {\n                 write!(f,\n-                       \"expected concrete lifetime, found bound lifetime parameter{}{}\",\n-                       if br.is_named() { \" \" } else { \"\" },\n-                       br)\n+                       \"expected concrete lifetime, found bound lifetime parameter{}\",\n+                       br_string(br))\n             }\n             RegionsPlaceholderMismatch => {\n                 write!(f, \"one type is more general than the other\")\n@@ -125,9 +130,9 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             Traits(values) => ty::tls::with(|tcx| {\n                 report_maybe_different(f,\n                                        &format!(\"trait `{}`\",\n-                                                tcx.item_path_str(values.expected)),\n+                                                tcx.def_path_str(values.expected)),\n                                        &format!(\"trait `{}`\",\n-                                                tcx.item_path_str(values.found)))\n+                                                tcx.def_path_str(values.found)))\n             }),\n             IntMismatch(ref values) => {\n                 write!(f, \"expected `{:?}`, found `{:?}`\",\n@@ -146,8 +151,8 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n             ProjectionMismatched(ref values) => ty::tls::with(|tcx| {\n                 write!(f, \"expected {}, found {}\",\n-                       tcx.item_path_str(values.expected),\n-                       tcx.item_path_str(values.found))\n+                       tcx.def_path_str(values.expected),\n+                       tcx.def_path_str(values.found))\n             }),\n             ProjectionBoundsLength(ref values) => {\n                 write!(f, \"expected {} associated type bindings, found {}\",\n@@ -169,8 +174,8 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => self.to_string().into(),\n             ty::Tuple(ref tys) if tys.is_empty() => self.to_string().into(),\n \n-            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)).into(),\n-            ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)).into(),\n+            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.def_path_str(def.did)).into(),\n+            ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.def_path_str(def_id)).into(),\n             ty::Array(_, n) => match n {\n                 ty::LazyConst::Evaluated(n) => match n.assert_usize(tcx) {\n                     Some(n) => format!(\"array of {} elements\", n).into(),\n@@ -185,7 +190,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                 let tymut_string = tymut.to_string();\n                 if tymut_string == \"_\" ||         //unknown type name,\n                    tymut_string.len() > 10 ||     //name longer than saying \"reference\",\n-                   region.to_string() != \"\"       //... or a complex type\n+                   region.to_string() != \"'_\"     //... or a complex type\n                 {\n                     format!(\"{}reference\", match mutbl {\n                         hir::Mutability::MutMutable => \"mutable \",\n@@ -199,7 +204,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) => {\n                 if let Some(principal) = inner.principal() {\n-                    format!(\"trait {}\", tcx.item_path_str(principal.def_id())).into()\n+                    format!(\"trait {}\", tcx.def_path_str(principal.def_id())).into()\n                 } else {\n                     \"trait\".into()\n                 }"}, {"sha": "995e85fc5f4db557cf54dd8d0729986985a12bc5", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,10 +1,11 @@\n use crate::hir::Unsafety;\n+use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n use crate::ty::{self, Ty, PolyFnSig, TypeFoldable, SubstsRef, TyCtxt};\n+use crate::ty::print::{FmtPrinter, Printer};\n use crate::traits;\n use rustc_target::spec::abi::Abi;\n use rustc_macros::HashStable;\n-use crate::util::ppaux;\n \n use std::fmt;\n use std::iter;\n@@ -175,7 +176,13 @@ impl<'tcx> InstanceDef<'tcx> {\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ppaux::parameterized(f, self.substs, self.def_id(), &[])?;\n+        ty::tls::with(|tcx| {\n+            let substs = tcx.lift(&self.substs).expect(\"could not lift for printing\");\n+            FmtPrinter::new(tcx, &mut *f, Namespace::ValueNS)\n+                .print_def_path(self.def_id(), substs)?;\n+            Ok(())\n+        })?;\n+\n         match self.def {\n             InstanceDef::Item(_) => Ok(()),\n             InstanceDef::VtableShim(_) => {"}, {"sha": "26e2705a7a0346feeb955f066e8b5a6405541afd", "filename": "src/librustc/ty/item_path.rs", "status": "removed", "additions": 0, "deletions": 573, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/16e7e05e95a6a5a1e0dba54ae722274bd7d725f7/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e7e05e95a6a5a1e0dba54ae722274bd7d725f7/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=16e7e05e95a6a5a1e0dba54ae722274bd7d725f7", "patch": "@@ -1,573 +0,0 @@\n-use crate::hir::map::DefPathData;\n-use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n-use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n-use syntax::ast;\n-use syntax::symbol::{keywords, LocalInternedString, Symbol};\n-\n-use std::cell::Cell;\n-use std::fmt::Debug;\n-\n-thread_local! {\n-    static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false);\n-    static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n-    static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n-}\n-\n-/// Enforces that item_path_str always returns an absolute path and\n-/// also enables \"type-based\" impl paths. This is used when building\n-/// symbols that contain types, where we want the crate name to be\n-/// part of the symbol.\n-pub fn with_forced_absolute_paths<F: FnOnce() -> R, R>(f: F) -> R {\n-    FORCE_ABSOLUTE.with(|force| {\n-        let old = force.get();\n-        force.set(true);\n-        let result = f();\n-        force.set(old);\n-        result\n-    })\n-}\n-\n-/// Force us to name impls with just the filename/line number. We\n-/// normally try to use types. But at some points, notably while printing\n-/// cycle errors, this can result in extra or suboptimal error output,\n-/// so this variable disables that check.\n-pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n-    FORCE_IMPL_FILENAME_LINE.with(|force| {\n-        let old = force.get();\n-        force.set(true);\n-        let result = f();\n-        force.set(old);\n-        result\n-    })\n-}\n-\n-/// Adds the `crate::` prefix to paths where appropriate.\n-pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n-    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n-        let old = flag.get();\n-        flag.set(true);\n-        let result = f();\n-        flag.set(old);\n-        result\n-    })\n-}\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Returns a string identifying this `DefId`. This string is\n-    /// suitable for user output. It is relative to the current crate\n-    /// root, unless with_forced_absolute_paths was used.\n-    pub fn item_path_str(self, def_id: DefId) -> String {\n-        let mode = FORCE_ABSOLUTE.with(|force| {\n-            if force.get() {\n-                RootMode::Absolute\n-            } else {\n-                RootMode::Local\n-            }\n-        });\n-        let mut buffer = LocalPathBuffer::new(mode);\n-        debug!(\"item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n-        self.push_item_path(&mut buffer, def_id, false);\n-        buffer.into_string()\n-    }\n-\n-    /// Returns a string identifying this local node-id.\n-    pub fn node_path_str(self, id: ast::NodeId) -> String {\n-        self.item_path_str(self.hir().local_def_id(id))\n-    }\n-\n-    /// Returns a string identifying this def-id. This string is\n-    /// suitable for user output. It always begins with a crate identifier.\n-    pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n-        let mut buffer = LocalPathBuffer::new(RootMode::Absolute);\n-        debug!(\"absolute_item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n-        self.push_item_path(&mut buffer, def_id, false);\n-        buffer.into_string()\n-    }\n-\n-    /// Returns the \"path\" to a particular crate. This can proceed in\n-    /// various ways, depending on the `root_mode` of the `buffer`.\n-    /// (See `RootMode` enum for more details.)\n-    ///\n-    /// `pushed_prelude_crate` argument should be `true` when the buffer\n-    /// has had a prelude crate pushed to it. If this is the case, then\n-    /// we do not want to prepend `crate::` (as that would not be a valid\n-    /// path).\n-    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum, pushed_prelude_crate: bool)\n-        where T: ItemPathBuffer + Debug\n-    {\n-        debug!(\n-            \"push_krate_path: buffer={:?} cnum={:?} LOCAL_CRATE={:?}\",\n-            buffer, cnum, LOCAL_CRATE\n-        );\n-        match *buffer.root_mode() {\n-            RootMode::Local => {\n-                // In local mode, when we encounter a crate other than\n-                // LOCAL_CRATE, execution proceeds in one of two ways:\n-                //\n-                // 1. for a direct dependency, where user added an\n-                //    `extern crate` manually, we put the `extern\n-                //    crate` as the parent. So you wind up with\n-                //    something relative to the current crate.\n-                // 2. for an extern inferred from a path or an indirect crate,\n-                //    where there is no explicit `extern crate`, we just prepend\n-                //    the crate name.\n-                //\n-                // Returns `None` for the local crate.\n-                if cnum != LOCAL_CRATE {\n-                    let opt_extern_crate = self.extern_crate(cnum.as_def_id());\n-                    if let Some(ExternCrate {\n-                        src: ExternCrateSource::Extern(def_id),\n-                        direct: true,\n-                        ..\n-                    }) = *opt_extern_crate\n-                    {\n-                        debug!(\"push_krate_path: def_id={:?}\", def_id);\n-                        self.push_item_path(buffer, def_id, pushed_prelude_crate);\n-                    } else {\n-                        let name = self.crate_name(cnum).as_str();\n-                        debug!(\"push_krate_path: name={:?}\", name);\n-                        buffer.push(&name);\n-                    }\n-                } else if self.sess.rust_2018() && !pushed_prelude_crate {\n-                    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n-                        // We only add the `crate::` keyword where appropriate. In particular,\n-                        // when we've not previously pushed a prelude crate to this path.\n-                        if flag.get() {\n-                            buffer.push(&keywords::Crate.name().as_str())\n-                        }\n-                    })\n-                }\n-            }\n-            RootMode::Absolute => {\n-                // In absolute mode, just write the crate name\n-                // unconditionally.\n-                let name = self.original_crate_name(cnum).as_str();\n-                debug!(\"push_krate_path: original_name={:?}\", name);\n-                buffer.push(&name);\n-            }\n-        }\n-    }\n-\n-    /// If possible, this pushes a global path resolving to `external_def_id` that is visible\n-    /// from at least one local module and returns true. If the crate defining `external_def_id` is\n-    /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n-    pub fn try_push_visible_item_path<T>(\n-        self,\n-        buffer: &mut T,\n-        external_def_id: DefId,\n-        pushed_prelude_crate: bool,\n-    ) -> bool\n-        where T: ItemPathBuffer + Debug\n-    {\n-        debug!(\n-            \"try_push_visible_item_path: buffer={:?} external_def_id={:?}\",\n-            buffer, external_def_id\n-        );\n-        let visible_parent_map = self.visible_parent_map(LOCAL_CRATE);\n-\n-        let (mut cur_def, mut cur_path) = (external_def_id, Vec::<LocalInternedString>::new());\n-        loop {\n-            debug!(\n-                \"try_push_visible_item_path: cur_def={:?} cur_path={:?} CRATE_DEF_INDEX={:?}\",\n-                cur_def, cur_path, CRATE_DEF_INDEX,\n-            );\n-            // If `cur_def` is a direct or injected extern crate, push the path to the crate\n-            // followed by the path to the item within the crate and return.\n-            if cur_def.index == CRATE_DEF_INDEX {\n-                match *self.extern_crate(cur_def) {\n-                    Some(ExternCrate {\n-                        src: ExternCrateSource::Extern(def_id),\n-                        direct: true,\n-                        ..\n-                    }) => {\n-                        debug!(\"try_push_visible_item_path: def_id={:?}\", def_id);\n-                        self.push_item_path(buffer, def_id, pushed_prelude_crate);\n-                        cur_path.iter().rev().for_each(|segment| buffer.push(&segment));\n-                        return true;\n-                    }\n-                    None => {\n-                        buffer.push(&self.crate_name(cur_def.krate).as_str());\n-                        cur_path.iter().rev().for_each(|segment| buffer.push(&segment));\n-                        return true;\n-                    }\n-                    _ => {},\n-                }\n-            }\n-\n-            let mut cur_def_key = self.def_key(cur_def);\n-            debug!(\"try_push_visible_item_path: cur_def_key={:?}\", cur_def_key);\n-\n-            // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n-            if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n-                let parent = DefId {\n-                    krate: cur_def.krate,\n-                    index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n-                };\n-\n-                cur_def_key = self.def_key(parent);\n-            }\n-\n-            let visible_parent = visible_parent_map.get(&cur_def).cloned();\n-            let actual_parent = self.parent(cur_def);\n-\n-            let data = cur_def_key.disambiguated_data.data;\n-            debug!(\n-                \"try_push_visible_item_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n-                data, visible_parent, actual_parent,\n-            );\n-            let symbol = match data {\n-                // In order to output a path that could actually be imported (valid and visible),\n-                // we need to handle re-exports correctly.\n-                //\n-                // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n-                // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n-                //\n-                // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n-                // private so the \"true\" path to `CommandExt` isn't accessible.\n-                //\n-                // In this case, the `visible_parent_map` will look something like this:\n-                //\n-                // (child) -> (parent)\n-                // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n-                // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n-                // `std::sys::unix::ext` -> `std::os`\n-                //\n-                // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n-                // `std::os`.\n-                //\n-                // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n-                // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n-                // to the parent - resulting in a mangled path like\n-                // `std::os::ext::process::CommandExt`.\n-                //\n-                // Instead, we must detect that there was a re-export and instead print `unix`\n-                // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n-                // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n-                // the visible parent (`std::os`). If these do not match, then we iterate over\n-                // the children of the visible parent (as was done when computing\n-                // `visible_parent_map`), looking for the specific child we currently have and then\n-                // have access to the re-exported name.\n-                DefPathData::Module(actual_name) |\n-                DefPathData::TypeNs(actual_name) if visible_parent != actual_parent => {\n-                    visible_parent\n-                        .and_then(|parent| {\n-                            self.item_children(parent)\n-                                .iter()\n-                                .find(|child| child.def.def_id() == cur_def)\n-                                .map(|child| child.ident.as_str())\n-                        })\n-                        .unwrap_or_else(|| actual_name.as_str())\n-                },\n-                _ => {\n-                    data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n-                        // Re-exported `extern crate` (#43189).\n-                        if let DefPathData::CrateRoot = data {\n-                            self.original_crate_name(cur_def.krate).as_str()\n-                        } else {\n-                            Symbol::intern(\"<unnamed>\").as_str()\n-                        }\n-                    })\n-                },\n-            };\n-            debug!(\"try_push_visible_item_path: symbol={:?}\", symbol);\n-            cur_path.push(symbol);\n-\n-            match visible_parent {\n-                Some(def) => cur_def = def,\n-                None => return false,\n-            };\n-        }\n-    }\n-\n-    pub fn push_item_path<T>(self, buffer: &mut T, def_id: DefId, pushed_prelude_crate: bool)\n-        where T: ItemPathBuffer + Debug\n-    {\n-        debug!(\n-            \"push_item_path: buffer={:?} def_id={:?} pushed_prelude_crate={:?}\",\n-            buffer, def_id, pushed_prelude_crate\n-        );\n-        match *buffer.root_mode() {\n-            RootMode::Local if !def_id.is_local() =>\n-                if self.try_push_visible_item_path(buffer, def_id, pushed_prelude_crate) { return },\n-            _ => {}\n-        }\n-\n-        let key = self.def_key(def_id);\n-        debug!(\"push_item_path: key={:?}\", key);\n-        match key.disambiguated_data.data {\n-            DefPathData::CrateRoot => {\n-                assert!(key.parent.is_none());\n-                self.push_krate_path(buffer, def_id.krate, pushed_prelude_crate);\n-            }\n-\n-            DefPathData::Impl => {\n-                self.push_impl_path(buffer, def_id, pushed_prelude_crate);\n-            }\n-\n-            // Unclear if there is any value in distinguishing these.\n-            // Probably eventually (and maybe we would even want\n-            // finer-grained distinctions, e.g., between enum/struct).\n-            data @ DefPathData::Misc |\n-            data @ DefPathData::TypeNs(..) |\n-            data @ DefPathData::Trait(..) |\n-            data @ DefPathData::TraitAlias(..) |\n-            data @ DefPathData::AssocTypeInTrait(..) |\n-            data @ DefPathData::AssocTypeInImpl(..) |\n-            data @ DefPathData::AssocExistentialInImpl(..) |\n-            data @ DefPathData::ValueNs(..) |\n-            data @ DefPathData::Module(..) |\n-            data @ DefPathData::TypeParam(..) |\n-            data @ DefPathData::LifetimeParam(..) |\n-            data @ DefPathData::ConstParam(..) |\n-            data @ DefPathData::EnumVariant(..) |\n-            data @ DefPathData::Field(..) |\n-            data @ DefPathData::AnonConst |\n-            data @ DefPathData::MacroDef(..) |\n-            data @ DefPathData::ClosureExpr |\n-            data @ DefPathData::ImplTrait |\n-            data @ DefPathData::GlobalMetaData(..) => {\n-                let parent_did = self.parent_def_id(def_id).unwrap();\n-\n-                // Keep track of whether we are one recursion away from the `CrateRoot` and\n-                // pushing the name of a prelude crate. If we are, we'll want to know this when\n-                // printing the `CrateRoot` so we don't prepend a `crate::` to paths.\n-                let mut is_prelude_crate = false;\n-                if let DefPathData::CrateRoot = self.def_key(parent_did).disambiguated_data.data {\n-                    if self.extern_prelude.contains_key(&data.as_interned_str().as_symbol()) {\n-                        is_prelude_crate = true;\n-                    }\n-                }\n-\n-                self.push_item_path(\n-                    buffer, parent_did, pushed_prelude_crate || is_prelude_crate\n-                );\n-                buffer.push(&data.as_interned_str().as_symbol().as_str());\n-            },\n-\n-            DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n-                let parent_def_id = self.parent_def_id(def_id).unwrap();\n-                self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n-            }\n-        }\n-    }\n-\n-    fn push_impl_path<T>(\n-        self,\n-         buffer: &mut T,\n-         impl_def_id: DefId,\n-         pushed_prelude_crate: bool,\n-    )\n-        where T: ItemPathBuffer + Debug\n-    {\n-        debug!(\"push_impl_path: buffer={:?} impl_def_id={:?}\", buffer, impl_def_id);\n-        let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n-\n-        // Always use types for non-local impls, where types are always\n-        // available, and filename/line-number is mostly uninteresting.\n-        let use_types = !impl_def_id.is_local() || {\n-            // Otherwise, use filename/line-number if forced.\n-            let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n-            !force_no_types\n-        };\n-\n-        if !use_types {\n-            return self.push_impl_path_fallback(buffer, impl_def_id, pushed_prelude_crate);\n-        }\n-\n-        // Decide whether to print the parent path for the impl.\n-        // Logically, since impls are global, it's never needed, but\n-        // users may find it useful. Currently, we omit the parent if\n-        // the impl is either in the same module as the self-type or\n-        // as the trait.\n-        let self_ty = self.type_of(impl_def_id);\n-        let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n-            None => false,\n-            Some(ty_def_id) => self.parent_def_id(ty_def_id) == Some(parent_def_id),\n-        };\n-\n-        let impl_trait_ref = self.impl_trait_ref(impl_def_id);\n-        let in_trait_mod = match impl_trait_ref {\n-            None => false,\n-            Some(trait_ref) => self.parent_def_id(trait_ref.def_id) == Some(parent_def_id),\n-        };\n-\n-        if !in_self_mod && !in_trait_mod {\n-            // If the impl is not co-located with either self-type or\n-            // trait-type, then fallback to a format that identifies\n-            // the module more clearly.\n-            self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n-            if let Some(trait_ref) = impl_trait_ref {\n-                buffer.push(&format!(\"<impl {} for {}>\", trait_ref, self_ty));\n-            } else {\n-                buffer.push(&format!(\"<impl {}>\", self_ty));\n-            }\n-            return;\n-        }\n-\n-        // Otherwise, try to give a good form that would be valid language\n-        // syntax. Preferably using associated item notation.\n-\n-        if let Some(trait_ref) = impl_trait_ref {\n-            // Trait impls.\n-            buffer.push(&format!(\"<{} as {}>\", self_ty, trait_ref));\n-            return;\n-        }\n-\n-        // Inherent impls. Try to print `Foo::bar` for an inherent\n-        // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n-        // anything other than a simple path.\n-        match self_ty.sty {\n-            ty::Adt(adt_def, substs) => {\n-                if substs.types().next().is_none() { // ignore regions\n-                    self.push_item_path(buffer, adt_def.did, pushed_prelude_crate);\n-                } else {\n-                    buffer.push(&format!(\"<{}>\", self_ty));\n-                }\n-            }\n-\n-            ty::Foreign(did) => self.push_item_path(buffer, did, pushed_prelude_crate),\n-\n-            ty::Bool |\n-            ty::Char |\n-            ty::Int(_) |\n-            ty::Uint(_) |\n-            ty::Float(_) |\n-            ty::Str => {\n-                buffer.push(&self_ty.to_string());\n-            }\n-\n-            _ => {\n-                buffer.push(&format!(\"<{}>\", self_ty));\n-            }\n-        }\n-    }\n-\n-    fn push_impl_path_fallback<T>(\n-        self,\n-        buffer: &mut T,\n-        impl_def_id: DefId,\n-        pushed_prelude_crate: bool,\n-    )\n-        where T: ItemPathBuffer + Debug\n-    {\n-        // If no type info is available, fall back to\n-        // pretty printing some span information. This should\n-        // only occur very early in the compiler pipeline.\n-        let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n-        self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n-        let hir_id = self.hir().as_local_hir_id(impl_def_id).unwrap();\n-        let item = self.hir().expect_item_by_hir_id(hir_id);\n-        let span_str = self.sess.source_map().span_to_string(item.span);\n-        buffer.push(&format!(\"<impl at {}>\", span_str));\n-    }\n-\n-    /// Returns the `DefId` of `def_id`'s parent in the def tree. If\n-    /// this returns `None`, then `def_id` represents a crate root or\n-    /// inlined root.\n-    pub fn parent_def_id(self, def_id: DefId) -> Option<DefId> {\n-        let key = self.def_key(def_id);\n-        key.parent.map(|index| DefId { krate: def_id.krate, index: index })\n-    }\n-}\n-\n-/// As a heuristic, when we see an impl, if we see that the\n-/// 'self type' is a type defined in the same module as the impl,\n-/// we can omit including the path to the impl itself. This\n-/// function tries to find a \"characteristic `DefId`\" for a\n-/// type. It's just a heuristic so it makes some questionable\n-/// decisions and we may want to adjust it later.\n-pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n-    match ty.sty {\n-        ty::Adt(adt_def, _) => Some(adt_def.did),\n-\n-        ty::Dynamic(data, ..) => data.principal_def_id(),\n-\n-        ty::Array(subty, _) |\n-        ty::Slice(subty) => characteristic_def_id_of_type(subty),\n-\n-        ty::RawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n-\n-        ty::Ref(_, ty, _) => characteristic_def_id_of_type(ty),\n-\n-        ty::Tuple(ref tys) => tys.iter()\n-                                   .filter_map(|ty| characteristic_def_id_of_type(ty))\n-                                   .next(),\n-\n-        ty::FnDef(def_id, _) |\n-        ty::Closure(def_id, _) |\n-        ty::Generator(def_id, _, _) |\n-        ty::Foreign(def_id) => Some(def_id),\n-\n-        ty::Bool |\n-        ty::Char |\n-        ty::Int(_) |\n-        ty::Uint(_) |\n-        ty::Str |\n-        ty::FnPtr(_) |\n-        ty::Projection(_) |\n-        ty::Placeholder(..) |\n-        ty::UnnormalizedProjection(..) |\n-        ty::Param(_) |\n-        ty::Opaque(..) |\n-        ty::Infer(_) |\n-        ty::Bound(..) |\n-        ty::Error |\n-        ty::GeneratorWitness(..) |\n-        ty::Never |\n-        ty::Float(_) => None,\n-    }\n-}\n-\n-/// Unifying Trait for different kinds of item paths we might\n-/// construct. The basic interface is that components get pushed: the\n-/// instance can also customize how we handle the root of a crate.\n-pub trait ItemPathBuffer {\n-    fn root_mode(&self) -> &RootMode;\n-    fn push(&mut self, text: &str);\n-}\n-\n-#[derive(Debug)]\n-pub enum RootMode {\n-    /// Try to make a path relative to the local crate. In\n-    /// particular, local paths have no prefix, and if the path comes\n-    /// from an extern crate, start with the path to the `extern\n-    /// crate` declaration.\n-    Local,\n-\n-    /// Always prepend the crate name to the path, forming an absolute\n-    /// path from within a given set of crates.\n-    Absolute,\n-}\n-\n-#[derive(Debug)]\n-struct LocalPathBuffer {\n-    root_mode: RootMode,\n-    str: String,\n-}\n-\n-impl LocalPathBuffer {\n-    fn new(root_mode: RootMode) -> LocalPathBuffer {\n-        LocalPathBuffer {\n-            root_mode,\n-            str: String::new(),\n-        }\n-    }\n-\n-    fn into_string(self) -> String {\n-        self.str\n-    }\n-}\n-\n-impl ItemPathBuffer for LocalPathBuffer {\n-    fn root_mode(&self) -> &RootMode {\n-        &self.root_mode\n-    }\n-\n-    fn push(&mut self, text: &str) {\n-        if !self.str.is_empty() {\n-            self.str.push_str(\"::\");\n-        }\n-        self.str.push_str(text);\n-    }\n-}"}, {"sha": "882e2dc62b1c376b55a25c94002102d624da35e4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -95,10 +95,10 @@ mod erase_regions;\n pub mod fast_reject;\n pub mod fold;\n pub mod inhabitedness;\n-pub mod item_path;\n pub mod layout;\n pub mod _match;\n pub mod outlives;\n+pub mod print;\n pub mod query;\n pub mod relate;\n pub mod steal;\n@@ -1000,7 +1000,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n }\n \n /// Bounds on generics.\n-#[derive(Clone, Default, HashStable)]\n+#[derive(Clone, Default, Debug, HashStable)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n     pub predicates: Vec<(Predicate<'tcx>, Span)>,\n@@ -1505,7 +1505,7 @@ impl<'tcx> Predicate<'tcx> {\n /// `[[], [U:Bar<T>]]`. Now if there were some particular reference\n /// like `Foo<isize,usize>`, then the `InstantiatedPredicates` would be `[[],\n /// [usize:Bar<isize>]]`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct InstantiatedPredicates<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n@@ -2055,7 +2055,7 @@ impl ReprOptions {\n         }\n \n         // This is here instead of layout because the choice must make it into metadata.\n-        if !tcx.consider_optimizing(|| format!(\"Reorder fields of {:?}\", tcx.item_path_str(did))) {\n+        if !tcx.consider_optimizing(|| format!(\"Reorder fields of {:?}\", tcx.def_path_str(did))) {\n             flags.insert(ReprFlags::IS_LINEAR);\n         }\n         ReprOptions { int: size, align: max_align, pack: min_pack, flags: flags }\n@@ -2892,14 +2892,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn expect_variant_def(self, def: Def) -> &'tcx VariantDef {\n         match def {\n             Def::Variant(did) | Def::VariantCtor(did, ..) => {\n-                let enum_did = self.parent_def_id(did).unwrap();\n+                let enum_did = self.parent(did).unwrap();\n                 self.adt_def(enum_did).variant_with_id(did)\n             }\n             Def::Struct(did) | Def::Union(did) => {\n                 self.adt_def(did).non_enum_variant()\n             }\n             Def::StructCtor(ctor_did, ..) => {\n-                let did = self.parent_def_id(ctor_did).expect(\"struct ctor has no parent\");\n+                let did = self.parent(ctor_did).expect(\"struct ctor has no parent\");\n                 self.adt_def(did).non_enum_variant()\n             }\n             _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)"}, {"sha": "ef30a4032d8fabbe5d57007909c4d32028263c49", "filename": "src/librustc/ty/print/mod.rs", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -0,0 +1,327 @@\n+use crate::hir::map::{DefPathData, DisambiguatedDefPathData};\n+use crate::hir::def_id::{CrateNum, DefId};\n+use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n+use crate::ty::subst::{Kind, Subst};\n+\n+use rustc_data_structures::fx::FxHashSet;\n+\n+// `pretty` is a separate module only for organization.\n+mod pretty;\n+pub use self::pretty::*;\n+\n+pub trait Print<'gcx, 'tcx, P> {\n+    type Output;\n+    type Error;\n+\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error>;\n+}\n+\n+/// Interface for outputting user-facing \"type-system entities\"\n+/// (paths, types, lifetimes, constants, etc.) as a side-effect\n+/// (e.g. formatting, like `PrettyPrinter` implementors do) or by\n+/// constructing some alternative representation (e.g. an AST),\n+/// which the associated types allow passing through the methods.\n+///\n+/// For pretty-printing/formatting in particular, see `PrettyPrinter`.\n+// FIXME(eddyb) find a better name, this is more general than \"printing\".\n+pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n+    type Error;\n+\n+    type Path;\n+    type Region;\n+    type Type;\n+    type DynExistential;\n+\n+    fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n+\n+    fn print_def_path(\n+        self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.default_print_def_path(def_id, substs)\n+    }\n+    fn print_impl_path(\n+        self,\n+        impl_def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.default_print_impl_path(impl_def_id, substs, self_ty, trait_ref)\n+    }\n+\n+    fn print_region(\n+        self,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error>;\n+\n+    fn print_type(\n+        self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error>;\n+\n+    fn print_dyn_existential(\n+        self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error>;\n+\n+    fn path_crate(\n+        self,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error>;\n+    fn path_qualified(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error>;\n+\n+    fn path_append_impl(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error>;\n+    fn path_append(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error>;\n+    fn path_generic_args(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        args: &[Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error>;\n+\n+    // Defaults (should not be overriden):\n+\n+    fn default_print_def_path(\n+        self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        debug!(\"default_print_def_path: def_id={:?}, substs={:?}\", def_id, substs);\n+        let key = self.tcx().def_key(def_id);\n+        debug!(\"default_print_def_path: key={:?}\", key);\n+\n+        match key.disambiguated_data.data {\n+            DefPathData::CrateRoot => {\n+                assert!(key.parent.is_none());\n+                self.path_crate(def_id.krate)\n+            }\n+\n+            DefPathData::Impl => {\n+                let generics = self.tcx().generics_of(def_id);\n+                let mut self_ty = self.tcx().type_of(def_id);\n+                let mut impl_trait_ref = self.tcx().impl_trait_ref(def_id);\n+                if substs.len() >= generics.count() {\n+                    self_ty = self_ty.subst(self.tcx(), substs);\n+                    impl_trait_ref = impl_trait_ref.subst(self.tcx(), substs);\n+                }\n+                self.print_impl_path(def_id, substs, self_ty, impl_trait_ref)\n+            }\n+\n+            _ => {\n+                let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n+\n+                let mut parent_substs = substs;\n+                let mut trait_qualify_parent = false;\n+                if !substs.is_empty() {\n+                    let generics = self.tcx().generics_of(def_id);\n+                    parent_substs = &substs[..generics.parent_count.min(substs.len())];\n+\n+                    match key.disambiguated_data.data {\n+                        // Closures' own generics are only captures, don't print them.\n+                        DefPathData::ClosureExpr => {}\n+\n+                        // If we have any generic arguments to print, we do that\n+                        // on top of the same path, but without its own generics.\n+                        _ => if !generics.params.is_empty() && substs.len() >= generics.count() {\n+                            let args = self.generic_args_to_print(generics, substs);\n+                            return self.path_generic_args(\n+                                |cx| cx.print_def_path(def_id, parent_substs),\n+                                args,\n+                            );\n+                        }\n+                    }\n+\n+                    // FIXME(eddyb) try to move this into the parent's printing\n+                    // logic, instead of doing it when printing the child.\n+                    trait_qualify_parent =\n+                        generics.has_self &&\n+                        generics.parent == Some(parent_def_id) &&\n+                        parent_substs.len() == generics.parent_count &&\n+                        self.tcx().generics_of(parent_def_id).parent_count == 0;\n+                }\n+\n+                self.path_append(\n+                    |cx: Self| if trait_qualify_parent {\n+                        let trait_ref = ty::TraitRef::new(\n+                            parent_def_id,\n+                            cx.tcx().intern_substs(parent_substs),\n+                        );\n+                        cx.path_qualified(trait_ref.self_ty(), Some(trait_ref))\n+                    } else {\n+                        cx.print_def_path(parent_def_id, parent_substs)\n+                    },\n+                    &key.disambiguated_data,\n+                )\n+            }\n+        }\n+    }\n+\n+    fn generic_args_to_print(\n+        &self,\n+        generics: &'tcx ty::Generics,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> &'tcx [Kind<'tcx>] {\n+        let mut own_params = generics.parent_count..generics.count();\n+\n+        // Don't print args for `Self` parameters (of traits).\n+        if generics.has_self && own_params.start == 0 {\n+            own_params.start = 1;\n+        }\n+\n+        // Don't print args that are the defaults of their respective parameters.\n+        own_params.end -= generics.params.iter().rev().take_while(|param| {\n+            match param.kind {\n+                ty::GenericParamDefKind::Lifetime => false,\n+                ty::GenericParamDefKind::Type { has_default, .. } => {\n+                    has_default && substs[param.index as usize] == Kind::from(\n+                        self.tcx().type_of(param.def_id).subst(self.tcx(), substs)\n+                    )\n+                }\n+                ty::GenericParamDefKind::Const => false, // FIXME(const_generics:defaults)\n+            }\n+        }).count();\n+\n+        &substs[own_params]\n+    }\n+\n+    fn default_print_impl_path(\n+        self,\n+        impl_def_id: DefId,\n+        _substs: &'tcx [Kind<'tcx>],\n+        self_ty: Ty<'tcx>,\n+        impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        debug!(\"default_print_impl_path: impl_def_id={:?}, self_ty={}, impl_trait_ref={:?}\",\n+               impl_def_id, self_ty, impl_trait_ref);\n+\n+        let key = self.tcx().def_key(impl_def_id);\n+        let parent_def_id = DefId { index: key.parent.unwrap(), ..impl_def_id };\n+\n+        // Decide whether to print the parent path for the impl.\n+        // Logically, since impls are global, it's never needed, but\n+        // users may find it useful. Currently, we omit the parent if\n+        // the impl is either in the same module as the self-type or\n+        // as the trait.\n+        let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n+            None => false,\n+            Some(ty_def_id) => self.tcx().parent(ty_def_id) == Some(parent_def_id),\n+        };\n+        let in_trait_mod = match impl_trait_ref {\n+            None => false,\n+            Some(trait_ref) => self.tcx().parent(trait_ref.def_id) == Some(parent_def_id),\n+        };\n+\n+        if !in_self_mod && !in_trait_mod {\n+            // If the impl is not co-located with either self-type or\n+            // trait-type, then fallback to a format that identifies\n+            // the module more clearly.\n+            self.path_append_impl(\n+                |cx| cx.print_def_path(parent_def_id, &[]),\n+                &key.disambiguated_data,\n+                self_ty,\n+                impl_trait_ref,\n+            )\n+        } else {\n+            // Otherwise, try to give a good form that would be valid language\n+            // syntax. Preferably using associated item notation.\n+            self.path_qualified(self_ty, impl_trait_ref)\n+        }\n+    }\n+}\n+\n+/// As a heuristic, when we see an impl, if we see that the\n+/// 'self type' is a type defined in the same module as the impl,\n+/// we can omit including the path to the impl itself. This\n+/// function tries to find a \"characteristic `DefId`\" for a\n+/// type. It's just a heuristic so it makes some questionable\n+/// decisions and we may want to adjust it later.\n+pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n+    match ty.sty {\n+        ty::Adt(adt_def, _) => Some(adt_def.did),\n+\n+        ty::Dynamic(data, ..) => data.principal_def_id(),\n+\n+        ty::Array(subty, _) |\n+        ty::Slice(subty) => characteristic_def_id_of_type(subty),\n+\n+        ty::RawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n+\n+        ty::Ref(_, ty, _) => characteristic_def_id_of_type(ty),\n+\n+        ty::Tuple(ref tys) => tys.iter()\n+                                   .filter_map(|ty| characteristic_def_id_of_type(ty))\n+                                   .next(),\n+\n+        ty::FnDef(def_id, _) |\n+        ty::Closure(def_id, _) |\n+        ty::Generator(def_id, _, _) |\n+        ty::Foreign(def_id) => Some(def_id),\n+\n+        ty::Bool |\n+        ty::Char |\n+        ty::Int(_) |\n+        ty::Uint(_) |\n+        ty::Str |\n+        ty::FnPtr(_) |\n+        ty::Projection(_) |\n+        ty::Placeholder(..) |\n+        ty::UnnormalizedProjection(..) |\n+        ty::Param(_) |\n+        ty::Opaque(..) |\n+        ty::Infer(_) |\n+        ty::Bound(..) |\n+        ty::Error |\n+        ty::GeneratorWitness(..) |\n+        ty::Never |\n+        ty::Float(_) => None,\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for ty::RegionKind {\n+    type Output = P::Region;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.print_region(self)\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for ty::Region<'_> {\n+    type Output = P::Region;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.print_region(self)\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for Ty<'tcx> {\n+    type Output = P::Type;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.print_type(self)\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n+    for &'tcx ty::List<ty::ExistentialPredicate<'tcx>>\n+{\n+    type Output = P::DynExistential;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.print_dyn_existential(self)\n+    }\n+}"}, {"sha": "fa57e0b96745ae1f751a06c4c657cb9e939a6b49", "filename": "src/librustc/ty/print/pretty.rs", "status": "added", "additions": 1621, "deletions": 0, "changes": 1621, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -0,0 +1,1621 @@\n+use crate::hir;\n+use crate::hir::def::Namespace;\n+use crate::hir::map::{DefPathData, DisambiguatedDefPathData};\n+use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n+use crate::middle::region;\n+use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::subst::{Kind, Subst, UnpackedKind};\n+use crate::mir::interpret::ConstValue;\n+use syntax::symbol::{keywords, Symbol};\n+\n+use rustc_target::spec::abi::Abi;\n+use syntax::symbol::InternedString;\n+\n+use std::cell::Cell;\n+use std::fmt::{self, Write as _};\n+use std::ops::{Deref, DerefMut};\n+\n+// `pretty` is a separate module only for organization.\n+use super::*;\n+\n+macro_rules! p {\n+    (@write($($data:expr),+)) => {\n+        write!(scoped_cx!(), $($data),+)?\n+    };\n+    (@print($x:expr)) => {\n+        scoped_cx!() = $x.print(scoped_cx!())?\n+    };\n+    (@$method:ident($($arg:expr),*)) => {\n+        scoped_cx!() = scoped_cx!().$method($($arg),*)?\n+    };\n+    ($($kind:ident $data:tt),+) => {{\n+        $(p!(@$kind $data);)+\n+    }};\n+}\n+macro_rules! define_scoped_cx {\n+    ($cx:ident) => {\n+        #[allow(unused_macros)]\n+        macro_rules! scoped_cx {\n+            () => ($cx)\n+        }\n+    };\n+}\n+\n+thread_local! {\n+    static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n+    static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n+}\n+\n+/// Force us to name impls with just the filename/line number. We\n+/// normally try to use types. But at some points, notably while printing\n+/// cycle errors, this can result in extra or suboptimal error output,\n+/// so this variable disables that check.\n+pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n+    FORCE_IMPL_FILENAME_LINE.with(|force| {\n+        let old = force.get();\n+        force.set(true);\n+        let result = f();\n+        force.set(old);\n+        result\n+    })\n+}\n+\n+/// Adds the `crate::` prefix to paths where appropriate.\n+pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n+    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n+        let old = flag.get();\n+        flag.set(true);\n+        let result = f();\n+        flag.set(old);\n+        result\n+    })\n+}\n+\n+/// The \"region highlights\" are used to control region printing during\n+/// specific error messages. When a \"region highlight\" is enabled, it\n+/// gives an alternate way to print specific regions. For now, we\n+/// always print those regions using a number, so something like \"`'0`\".\n+///\n+/// Regions not selected by the region highlight mode are presently\n+/// unaffected.\n+#[derive(Copy, Clone, Default)]\n+pub struct RegionHighlightMode {\n+    /// If enabled, when we see the selected region, use \"`'N`\"\n+    /// instead of the ordinary behavior.\n+    highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n+\n+    /// If enabled, when printing a \"free region\" that originated from\n+    /// the given `ty::BoundRegion`, print it as \"`'1`\". Free regions that would ordinarily\n+    /// have names print as normal.\n+    ///\n+    /// This is used when you have a signature like `fn foo(x: &u32,\n+    /// y: &'a u32)` and we want to give a name to the region of the\n+    /// reference `x`.\n+    highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n+}\n+\n+impl RegionHighlightMode {\n+    /// If `region` and `number` are both `Some`, invokes\n+    /// `highlighting_region`.\n+    pub fn maybe_highlighting_region(\n+        &mut self,\n+        region: Option<ty::Region<'_>>,\n+        number: Option<usize>,\n+    ) {\n+        if let Some(k) = region {\n+            if let Some(n) = number {\n+                self.highlighting_region(k, n);\n+            }\n+        }\n+    }\n+\n+    /// Highlights the region inference variable `vid` as `'N`.\n+    pub fn highlighting_region(\n+        &mut self,\n+        region: ty::Region<'_>,\n+        number: usize,\n+    ) {\n+        let num_slots = self.highlight_regions.len();\n+        let first_avail_slot = self.highlight_regions.iter_mut()\n+            .filter(|s| s.is_none())\n+            .next()\n+            .unwrap_or_else(|| {\n+                bug!(\n+                    \"can only highlight {} placeholders at a time\",\n+                    num_slots,\n+                )\n+            });\n+        *first_avail_slot = Some((*region, number));\n+    }\n+\n+    /// Convenience wrapper for `highlighting_region`.\n+    pub fn highlighting_region_vid(\n+        &mut self,\n+        vid: ty::RegionVid,\n+        number: usize,\n+    ) {\n+        self.highlighting_region(&ty::ReVar(vid), number)\n+    }\n+\n+    /// Returns `Some(n)` with the number to use for the given region, if any.\n+    fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n+        self\n+            .highlight_regions\n+            .iter()\n+            .filter_map(|h| match h {\n+                Some((r, n)) if r == region => Some(*n),\n+                _ => None,\n+            })\n+            .next()\n+    }\n+\n+    /// Highlight the given bound region.\n+    /// We can only highlight one bound region at a time. See\n+    /// the field `highlight_bound_region` for more detailed notes.\n+    pub fn highlighting_bound_region(\n+        &mut self,\n+        br: ty::BoundRegion,\n+        number: usize,\n+    ) {\n+        assert!(self.highlight_bound_region.is_none());\n+        self.highlight_bound_region = Some((br, number));\n+    }\n+}\n+\n+/// Trait for printers that pretty-print using `fmt::Write` to the printer.\n+pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n+    Printer<'gcx, 'tcx,\n+        Error = fmt::Error,\n+        Path = Self,\n+        Region = Self,\n+        Type = Self,\n+        DynExistential = Self,\n+    > +\n+    fmt::Write\n+{\n+    /// Like `print_def_path` but for value paths.\n+    fn print_value_path(\n+        self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.print_def_path(def_id, substs)\n+    }\n+\n+    fn in_binder<T>(\n+        self,\n+        value: &ty::Binder<T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+    {\n+        value.skip_binder().print(self)\n+    }\n+\n+    /// Print comma-separated elements.\n+    fn comma_sep<T>(\n+        mut self,\n+        mut elems: impl Iterator<Item = T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error>\n+    {\n+        if let Some(first) = elems.next() {\n+            self = first.print(self)?;\n+            for elem in elems {\n+                self.write_str(\", \")?;\n+                self = elem.print(self)?;\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    /// Print `<...>` around what `f` prints.\n+    fn generic_delimiters(\n+        self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error>;\n+\n+    /// Return `true` if the region should be printed in\n+    /// optional positions, e.g. `&'a T` or `dyn Tr + 'b`.\n+    /// This is typically the case for all non-`'_` regions.\n+    fn region_should_not_be_omitted(\n+        &self,\n+        region: ty::Region<'_>,\n+    ) -> bool;\n+\n+    // Defaults (should not be overriden):\n+\n+    /// If possible, this returns a global path resolving to `def_id` that is visible\n+    /// from at least one local module and returns true. If the crate defining `def_id` is\n+    /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n+    fn try_print_visible_def_path(\n+        mut self,\n+        def_id: DefId,\n+    ) -> Result<(Self, bool), Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n+\n+        // If `def_id` is a direct or injected extern crate, return the\n+        // path to the crate followed by the path to the item within the crate.\n+        if def_id.index == CRATE_DEF_INDEX {\n+            let cnum = def_id.krate;\n+\n+            if cnum == LOCAL_CRATE {\n+                return Ok((self.path_crate(cnum)?, true));\n+            }\n+\n+            // In local mode, when we encounter a crate other than\n+            // LOCAL_CRATE, execution proceeds in one of two ways:\n+            //\n+            // 1. for a direct dependency, where user added an\n+            //    `extern crate` manually, we put the `extern\n+            //    crate` as the parent. So you wind up with\n+            //    something relative to the current crate.\n+            // 2. for an extern inferred from a path or an indirect crate,\n+            //    where there is no explicit `extern crate`, we just prepend\n+            //    the crate name.\n+            match *self.tcx().extern_crate(def_id) {\n+                Some(ExternCrate {\n+                    src: ExternCrateSource::Extern(def_id),\n+                    direct: true,\n+                    span,\n+                    ..\n+                }) => {\n+                    debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n+                    return Ok((if !span.is_dummy() {\n+                        self.print_def_path(def_id, &[])?\n+                    } else {\n+                        self.path_crate(cnum)?\n+                    }, true));\n+                }\n+                None => {\n+                    return Ok((self.path_crate(cnum)?, true));\n+                }\n+                _ => {},\n+            }\n+        }\n+\n+        if def_id.is_local() {\n+            return Ok((self, false));\n+        }\n+\n+        let visible_parent_map = self.tcx().visible_parent_map(LOCAL_CRATE);\n+\n+        let mut cur_def_key = self.tcx().def_key(def_id);\n+        debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n+\n+        // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n+        if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n+            let parent = DefId {\n+                krate: def_id.krate,\n+                index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n+            };\n+\n+            cur_def_key = self.tcx().def_key(parent);\n+        }\n+\n+        let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n+            Some(parent) => parent,\n+            None => return Ok((self, false)),\n+        };\n+        // HACK(eddyb) this bypasses `path_append`'s prefix printing to avoid\n+        // knowing ahead of time whether the entire path will succeed or not.\n+        // To support printers that do not implement `PrettyPrinter`, a `Vec` or\n+        // linked list on the stack would need to be built, before any printing.\n+        match self.try_print_visible_def_path(visible_parent)? {\n+            (cx, false) => return Ok((cx, false)),\n+            (cx, true) => self = cx,\n+        }\n+        let actual_parent = self.tcx().parent(def_id);\n+        debug!(\n+            \"try_print_visible_def_path: visible_parent={:?} actual_parent={:?}\",\n+            visible_parent, actual_parent,\n+        );\n+\n+        let mut data = cur_def_key.disambiguated_data.data;\n+        debug!(\n+            \"try_print_visible_def_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n+            data, visible_parent, actual_parent,\n+        );\n+\n+        match data {\n+            // In order to output a path that could actually be imported (valid and visible),\n+            // we need to handle re-exports correctly.\n+            //\n+            // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n+            // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n+            //\n+            // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n+            // private so the \"true\" path to `CommandExt` isn't accessible.\n+            //\n+            // In this case, the `visible_parent_map` will look something like this:\n+            //\n+            // (child) -> (parent)\n+            // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n+            // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n+            // `std::sys::unix::ext` -> `std::os`\n+            //\n+            // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n+            // `std::os`.\n+            //\n+            // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n+            // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n+            // to the parent - resulting in a mangled path like\n+            // `std::os::ext::process::CommandExt`.\n+            //\n+            // Instead, we must detect that there was a re-export and instead print `unix`\n+            // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n+            // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n+            // the visible parent (`std::os`). If these do not match, then we iterate over\n+            // the children of the visible parent (as was done when computing\n+            // `visible_parent_map`), looking for the specific child we currently have and then\n+            // have access to the re-exported name.\n+            DefPathData::Module(ref mut name) |\n+            DefPathData::TypeNs(ref mut name) if Some(visible_parent) != actual_parent => {\n+                let reexport = self.tcx().item_children(visible_parent)\n+                    .iter()\n+                    .find(|child| child.def.def_id() == def_id)\n+                    .map(|child| child.ident.as_interned_str());\n+                if let Some(reexport) = reexport {\n+                    *name = reexport;\n+                }\n+            }\n+            // Re-exported `extern crate` (#43189).\n+            DefPathData::CrateRoot => {\n+                data = DefPathData::Module(\n+                    self.tcx().original_crate_name(def_id.krate).as_interned_str(),\n+                );\n+            }\n+            _ => {}\n+        }\n+        debug!(\"try_print_visible_def_path: data={:?}\", data);\n+\n+        Ok((self.path_append(Ok, &DisambiguatedDefPathData {\n+            data,\n+            disambiguator: 0,\n+        })?, true))\n+    }\n+\n+    fn pretty_path_qualified(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        if trait_ref.is_none() {\n+            // Inherent impls. Try to print `Foo::bar` for an inherent\n+            // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n+            // anything other than a simple path.\n+            match self_ty.sty {\n+                ty::Adt(..) | ty::Foreign(_) |\n+                ty::Bool | ty::Char | ty::Str |\n+                ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n+                    return self_ty.print(self);\n+                }\n+\n+                _ => {}\n+            }\n+        }\n+\n+        self.generic_delimiters(|mut cx| {\n+            define_scoped_cx!(cx);\n+\n+            p!(print(self_ty));\n+            if let Some(trait_ref) = trait_ref {\n+                p!(write(\" as \"), print(trait_ref));\n+            }\n+            Ok(cx)\n+        })\n+    }\n+\n+    fn pretty_path_append_impl(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        self.generic_delimiters(|mut cx| {\n+            define_scoped_cx!(cx);\n+\n+            p!(write(\"impl \"));\n+            if let Some(trait_ref) = trait_ref {\n+                p!(print(trait_ref), write(\" for \"));\n+            }\n+            p!(print(self_ty));\n+\n+            Ok(cx)\n+        })\n+    }\n+\n+    fn pretty_print_type(\n+        mut self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        match ty.sty {\n+            ty::Bool => p!(write(\"bool\")),\n+            ty::Char => p!(write(\"char\")),\n+            ty::Int(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Uint(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Float(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::RawPtr(ref tm) => {\n+                p!(write(\"*{} \", match tm.mutbl {\n+                    hir::MutMutable => \"mut\",\n+                    hir::MutImmutable => \"const\",\n+                }));\n+                p!(print(tm.ty))\n+            }\n+            ty::Ref(r, ty, mutbl) => {\n+                p!(write(\"&\"));\n+                if self.region_should_not_be_omitted(r) {\n+                    p!(print(r), write(\" \"));\n+                }\n+                p!(print(ty::TypeAndMut { ty, mutbl }))\n+            }\n+            ty::Never => p!(write(\"!\")),\n+            ty::Tuple(ref tys) => {\n+                p!(write(\"(\"));\n+                let mut tys = tys.iter();\n+                if let Some(&ty) = tys.next() {\n+                    p!(print(ty), write(\",\"));\n+                    if let Some(&ty) = tys.next() {\n+                        p!(write(\" \"), print(ty));\n+                        for &ty in tys {\n+                            p!(write(\", \"), print(ty));\n+                        }\n+                    }\n+                }\n+                p!(write(\")\"))\n+            }\n+            ty::FnDef(def_id, substs) => {\n+                let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n+                p!(print(sig), write(\" {{\"), print_value_path(def_id, substs), write(\"}}\"));\n+            }\n+            ty::FnPtr(ref bare_fn) => {\n+                p!(print(bare_fn))\n+            }\n+            ty::Infer(infer_ty) => p!(write(\"{}\", infer_ty)),\n+            ty::Error => p!(write(\"[type error]\")),\n+            ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n+            ty::Bound(debruijn, bound_ty) => {\n+                match bound_ty.kind {\n+                    ty::BoundTyKind::Anon => {\n+                        if debruijn == ty::INNERMOST {\n+                            p!(write(\"^{}\", bound_ty.var.index()))\n+                        } else {\n+                            p!(write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n+                        }\n+                    }\n+\n+                    ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n+                }\n+            }\n+            ty::Adt(def, substs) => {\n+                p!(print_def_path(def.did, substs));\n+            }\n+            ty::Dynamic(data, r) => {\n+                let print_r = self.region_should_not_be_omitted(r);\n+                if print_r {\n+                    p!(write(\"(\"));\n+                }\n+                p!(write(\"dyn \"), print(data));\n+                if print_r {\n+                    p!(write(\" + \"), print(r), write(\")\"));\n+                }\n+            }\n+            ty::Foreign(def_id) => {\n+                p!(print_def_path(def_id, &[]));\n+            }\n+            ty::Projection(ref data) => p!(print(data)),\n+            ty::UnnormalizedProjection(ref data) => {\n+                p!(write(\"Unnormalized(\"), print(data), write(\")\"))\n+            }\n+            ty::Placeholder(placeholder) => {\n+                p!(write(\"Placeholder({:?})\", placeholder))\n+            }\n+            ty::Opaque(def_id, substs) => {\n+                // FIXME(eddyb) print this with `print_def_path`.\n+                if self.tcx().sess.verbose() {\n+                    p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n+                    return Ok(self);\n+                }\n+\n+                let def_key = self.tcx().def_key(def_id);\n+                if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n+                    p!(write(\"{}\", name));\n+                    let mut substs = substs.iter();\n+                    // FIXME(eddyb) print this with `print_def_path`.\n+                    if let Some(first) = substs.next() {\n+                        p!(write(\"::<\"));\n+                        p!(print(first));\n+                        for subst in substs {\n+                            p!(write(\", \"), print(subst));\n+                        }\n+                        p!(write(\">\"));\n+                    }\n+                    return Ok(self);\n+                }\n+                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                // by looking up the projections associated with the def_id.\n+                let bounds = self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+\n+                let mut first = true;\n+                let mut is_sized = false;\n+                p!(write(\"impl\"));\n+                for predicate in bounds.predicates {\n+                    if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                        // Don't print +Sized, but rather +?Sized if absent.\n+                        if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n+                            is_sized = true;\n+                            continue;\n+                        }\n+\n+                        p!(\n+                                write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                print(trait_ref));\n+                        first = false;\n+                    }\n+                }\n+                if !is_sized {\n+                    p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n+                } else if first {\n+                    p!(write(\" Sized\"));\n+                }\n+            }\n+            ty::Str => p!(write(\"str\")),\n+            ty::Generator(did, substs, movability) => {\n+                let upvar_tys = substs.upvar_tys(did, self.tcx());\n+                let witness = substs.witness(did, self.tcx());\n+                if movability == hir::GeneratorMovability::Movable {\n+                    p!(write(\"[generator\"));\n+                } else {\n+                    p!(write(\"[static generator\"));\n+                }\n+\n+                // FIXME(eddyb) should use `def_span`.\n+                if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n+                    p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n+                    let mut sep = \" \";\n+                    for (freevar, upvar_ty) in self.tcx().freevars(did)\n+                        .as_ref()\n+                        .map_or(&[][..], |fv| &fv[..])\n+                        .iter()\n+                        .zip(upvar_tys)\n+                    {\n+                        p!(\n+                            write(\"{}{}:\",\n+                                    sep,\n+                                    self.tcx().hir().name(freevar.var_id())),\n+                            print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in codegen bug reports, I imagine.\n+                    p!(write(\"@{:?}\", did));\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n+                        p!(\n+                                write(\"{}{}:\", sep, index),\n+                                print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                }\n+\n+                p!(write(\" \"), print(witness), write(\"]\"))\n+            },\n+            ty::GeneratorWitness(types) => {\n+                p!(in_binder(&types));\n+            }\n+            ty::Closure(did, substs) => {\n+                let upvar_tys = substs.upvar_tys(did, self.tcx());\n+                p!(write(\"[closure\"));\n+\n+                // FIXME(eddyb) should use `def_span`.\n+                if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n+                    if self.tcx().sess.opts.debugging_opts.span_free_formats {\n+                        p!(write(\"@{:?}\", hir_id));\n+                    } else {\n+                        p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n+                    }\n+                    let mut sep = \" \";\n+                    for (freevar, upvar_ty) in self.tcx().freevars(did)\n+                        .as_ref()\n+                        .map_or(&[][..], |fv| &fv[..])\n+                        .iter()\n+                        .zip(upvar_tys)\n+                    {\n+                        p!(\n+                            write(\"{}{}:\",\n+                                    sep,\n+                                    self.tcx().hir().name(freevar.var_id())),\n+                            print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in codegen bug reports, I imagine.\n+                    p!(write(\"@{:?}\", did));\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n+                        p!(\n+                                write(\"{}{}:\", sep, index),\n+                                print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                }\n+\n+                if self.tcx().sess.verbose() {\n+                    p!(write(\n+                        \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n+                        substs.closure_kind_ty(did, self.tcx()),\n+                        substs.closure_sig_ty(did, self.tcx())\n+                    ));\n+                }\n+\n+                p!(write(\"]\"))\n+            },\n+            ty::Array(ty, sz) => {\n+                p!(write(\"[\"), print(ty), write(\"; \"));\n+                match sz {\n+                    ty::LazyConst::Unevaluated(_def_id, _substs) => {\n+                        p!(write(\"_\"));\n+                    }\n+                    ty::LazyConst::Evaluated(c) => {\n+                        match c.val {\n+                            ConstValue::Infer(..) => p!(write(\"_\")),\n+                            ConstValue::Param(ParamConst { name, .. }) =>\n+                                p!(write(\"{}\", name)),\n+                            _ => p!(write(\"{}\", c.unwrap_usize(self.tcx()))),\n+                        }\n+                    }\n+                }\n+                p!(write(\"]\"))\n+            }\n+            ty::Slice(ty) => {\n+                p!(write(\"[\"), print(ty), write(\"]\"))\n+            }\n+        }\n+\n+        Ok(self)\n+    }\n+\n+    fn pretty_print_dyn_existential(\n+        mut self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        // Generate the main trait ref, including associated types.\n+        let mut first = true;\n+\n+        if let Some(principal) = predicates.principal() {\n+            p!(print_def_path(principal.def_id, &[]));\n+\n+            let mut resugared = false;\n+\n+            // Special-case `Fn(...) -> ...` and resugar it.\n+            let fn_trait_kind = self.tcx().lang_items().fn_trait_kind(principal.def_id);\n+            if !self.tcx().sess.verbose() && fn_trait_kind.is_some() {\n+                if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n+                    let mut projections = predicates.projection_bounds();\n+                    if let (Some(proj), None) = (projections.next(), projections.next()) {\n+                        p!(pretty_fn_sig(args, false, proj.ty));\n+                        resugared = true;\n+                    }\n+                }\n+            }\n+\n+            // HACK(eddyb) this duplicates `FmtPrinter`'s `path_generic_args`,\n+            // in order to place the projections inside the `<...>`.\n+            if !resugared {\n+                // Use a type that can't appear in defaults of type parameters.\n+                let dummy_self = self.tcx().mk_infer(ty::FreshTy(0));\n+                let principal = principal.with_self_ty(self.tcx(), dummy_self);\n+\n+                let args = self.generic_args_to_print(\n+                    self.tcx().generics_of(principal.def_id),\n+                    principal.substs,\n+                );\n+\n+                // Don't print `'_` if there's no unerased regions.\n+                let print_regions = args.iter().any(|arg| {\n+                    match arg.unpack() {\n+                        UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                        _ => false,\n+                    }\n+                });\n+                let mut args = args.iter().cloned().filter(|arg| {\n+                    match arg.unpack() {\n+                        UnpackedKind::Lifetime(_) => print_regions,\n+                        _ => true,\n+                    }\n+                });\n+                let mut projections = predicates.projection_bounds();\n+\n+                let arg0 = args.next();\n+                let projection0 = projections.next();\n+                if arg0.is_some() || projection0.is_some() {\n+                    let args = arg0.into_iter().chain(args);\n+                    let projections = projection0.into_iter().chain(projections);\n+\n+                    p!(generic_delimiters(|mut cx| {\n+                        cx = cx.comma_sep(args)?;\n+                        if arg0.is_some() && projection0.is_some() {\n+                            write!(cx, \", \")?;\n+                        }\n+                        cx.comma_sep(projections)\n+                    }));\n+                }\n+            }\n+            first = false;\n+        }\n+\n+        // Builtin bounds.\n+        // FIXME(eddyb) avoid printing twice (needed to ensure\n+        // that the auto traits are sorted *and* printed via cx).\n+        let mut auto_traits: Vec<_> = predicates.auto_traits().map(|did| {\n+            (self.tcx().def_path_str(did), did)\n+        }).collect();\n+\n+        // The auto traits come ordered by `DefPathHash`. While\n+        // `DefPathHash` is *stable* in the sense that it depends on\n+        // neither the host nor the phase of the moon, it depends\n+        // \"pseudorandomly\" on the compiler version and the target.\n+        //\n+        // To avoid that causing instabilities in compiletest\n+        // output, sort the auto-traits alphabetically.\n+        auto_traits.sort();\n+\n+        for (_, def_id) in auto_traits {\n+            if !first {\n+                p!(write(\" + \"));\n+            }\n+            first = false;\n+\n+            p!(print_def_path(def_id, &[]));\n+        }\n+\n+        Ok(self)\n+    }\n+\n+    fn pretty_fn_sig(\n+        mut self,\n+        inputs: &[Ty<'tcx>],\n+        c_variadic: bool,\n+        output: Ty<'tcx>,\n+    ) -> Result<Self, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        p!(write(\"(\"));\n+        let mut inputs = inputs.iter();\n+        if let Some(&ty) = inputs.next() {\n+            p!(print(ty));\n+            for &ty in inputs {\n+                p!(write(\", \"), print(ty));\n+            }\n+            if c_variadic {\n+                p!(write(\", ...\"));\n+            }\n+        }\n+        p!(write(\")\"));\n+        if !output.is_unit() {\n+            p!(write(\" -> \"), print(output));\n+        }\n+\n+        Ok(self)\n+    }\n+}\n+\n+// HACK(eddyb) boxed to avoid moving around a large struct by-value.\n+pub struct FmtPrinter<'a, 'gcx, 'tcx, F>(Box<FmtPrinterData<'a, 'gcx, 'tcx, F>>);\n+\n+pub struct FmtPrinterData<'a, 'gcx, 'tcx, F> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fmt: F,\n+\n+    empty_path: bool,\n+    in_value: bool,\n+\n+    used_region_names: FxHashSet<InternedString>,\n+    region_index: usize,\n+    binder_depth: usize,\n+\n+    pub region_highlight_mode: RegionHighlightMode,\n+}\n+\n+impl<F> Deref for FmtPrinter<'a, 'gcx, 'tcx, F> {\n+    type Target = FmtPrinterData<'a, 'gcx, 'tcx, F>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl<F> DerefMut for FmtPrinter<'_, '_, '_, F> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n+impl<F> FmtPrinter<'a, 'gcx, 'tcx, F> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, fmt: F, ns: Namespace) -> Self {\n+        FmtPrinter(Box::new(FmtPrinterData {\n+            tcx,\n+            fmt,\n+            empty_path: false,\n+            in_value: ns == Namespace::ValueNS,\n+            used_region_names: Default::default(),\n+            region_index: 0,\n+            binder_depth: 0,\n+            region_highlight_mode: RegionHighlightMode::default(),\n+        }))\n+    }\n+}\n+\n+impl TyCtxt<'_, '_, '_> {\n+    // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n+    // (but also some things just print a `DefId` generally so maybe we need this?)\n+    fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n+        match self.def_key(def_id).disambiguated_data.data {\n+            DefPathData::ValueNs(..) |\n+            DefPathData::EnumVariant(..) |\n+            DefPathData::Field(..) |\n+            DefPathData::AnonConst |\n+            DefPathData::ConstParam(..) |\n+            DefPathData::ClosureExpr |\n+            DefPathData::StructCtor => Namespace::ValueNS,\n+\n+            DefPathData::MacroDef(..) => Namespace::MacroNS,\n+\n+            _ => Namespace::TypeNS,\n+        }\n+    }\n+\n+    /// Returns a string identifying this `DefId`. This string is\n+    /// suitable for user output.\n+    pub fn def_path_str(self, def_id: DefId) -> String {\n+        let ns = self.guess_def_namespace(def_id);\n+        debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n+        let mut s = String::new();\n+        let _ = FmtPrinter::new(self, &mut s, ns)\n+            .print_def_path(def_id, &[]);\n+        s\n+    }\n+}\n+\n+impl<F: fmt::Write> fmt::Write for FmtPrinter<'_, '_, '_, F> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.fmt.write_str(s)\n+    }\n+}\n+\n+impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n+    type Error = fmt::Error;\n+\n+    type Path = Self;\n+    type Region = Self;\n+    type Type = Self;\n+    type DynExistential = Self;\n+\n+    fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn print_def_path(\n+        mut self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        if substs.is_empty() {\n+            match self.try_print_visible_def_path(def_id)? {\n+                (cx, true) => return Ok(cx),\n+                (cx, false) => self = cx,\n+            }\n+        }\n+\n+        let key = self.tcx.def_key(def_id);\n+        if let DefPathData::Impl = key.disambiguated_data.data {\n+            // Always use types for non-local impls, where types are always\n+            // available, and filename/line-number is mostly uninteresting.\n+            let use_types =\n+                !def_id.is_local() || {\n+                    // Otherwise, use filename/line-number if forced.\n+                    let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n+                    !force_no_types\n+                };\n+\n+            if !use_types {\n+                // If no type info is available, fall back to\n+                // pretty printing some span information. This should\n+                // only occur very early in the compiler pipeline.\n+                let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n+                let span = self.tcx.def_span(def_id);\n+\n+                self = self.print_def_path(parent_def_id, &[])?;\n+\n+                // HACK(eddyb) copy of `path_append` to avoid\n+                // constructing a `DisambiguatedDefPathData`.\n+                if !self.empty_path {\n+                    write!(self, \"::\")?;\n+                }\n+                write!(self, \"<impl at {:?}>\", span)?;\n+                self.empty_path = false;\n+\n+                return Ok(self);\n+            }\n+        }\n+\n+        self.default_print_def_path(def_id, substs)\n+    }\n+\n+    fn print_region(\n+        self,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        self.pretty_print_region(region)\n+    }\n+\n+    fn print_type(\n+        self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        self.pretty_print_type(ty)\n+    }\n+\n+    fn print_dyn_existential(\n+        self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        self.pretty_print_dyn_existential(predicates)\n+    }\n+\n+    fn path_crate(\n+        mut self,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.empty_path = true;\n+        if cnum == LOCAL_CRATE {\n+            if self.tcx.sess.rust_2018() {\n+                // We add the `crate::` keyword on Rust 2018, only when desired.\n+                if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n+                    write!(self, \"{}\", keywords::Crate.name())?;\n+                    self.empty_path = false;\n+                }\n+            }\n+        } else {\n+            write!(self, \"{}\", self.tcx.crate_name(cnum))?;\n+            self.empty_path = false;\n+        }\n+        Ok(self)\n+    }\n+    fn path_qualified(\n+        mut self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = self.pretty_path_qualified(self_ty, trait_ref)?;\n+        self.empty_path = false;\n+        Ok(self)\n+    }\n+\n+    fn path_append_impl(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = self.pretty_path_append_impl(|mut cx| {\n+            cx = print_prefix(cx)?;\n+            if !cx.empty_path {\n+                write!(cx, \"::\")?;\n+            }\n+\n+            Ok(cx)\n+        }, self_ty, trait_ref)?;\n+        self.empty_path = false;\n+        Ok(self)\n+    }\n+    fn path_append(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        // Skip `::{{constructor}}` on tuple/unit structs.\n+        match disambiguated_data.data {\n+            DefPathData::StructCtor => return Ok(self),\n+            _ => {}\n+        }\n+\n+        // FIXME(eddyb) `name` should never be empty, but it\n+        // currently is for `extern { ... }` \"foreign modules\".\n+        let name = disambiguated_data.data.as_interned_str().as_str();\n+        if !name.is_empty() {\n+            if !self.empty_path {\n+                write!(self, \"::\")?;\n+            }\n+            write!(self, \"{}\", name)?;\n+\n+            // FIXME(eddyb) this will print e.g. `{{closure}}#3`, but it\n+            // might be nicer to use something else, e.g. `{closure#3}`.\n+            let dis = disambiguated_data.disambiguator;\n+            let print_dis =\n+                disambiguated_data.data.get_opt_name().is_none() ||\n+                dis != 0 && self.tcx.sess.verbose();\n+            if print_dis {\n+                write!(self, \"#{}\", dis)?;\n+            }\n+\n+            self.empty_path = false;\n+        }\n+\n+        Ok(self)\n+    }\n+    fn path_generic_args(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        args: &[Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        // Don't print `'_` if there's no unerased regions.\n+        let print_regions = args.iter().any(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                _ => false,\n+            }\n+        });\n+        let args = args.iter().cloned().filter(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(_) => print_regions,\n+                _ => true,\n+            }\n+        });\n+\n+        if args.clone().next().is_some() {\n+            if self.in_value {\n+                write!(self, \"::\")?;\n+            }\n+            self.generic_delimiters(|cx| cx.comma_sep(args))\n+        } else {\n+            Ok(self)\n+        }\n+    }\n+}\n+\n+impl<F: fmt::Write> PrettyPrinter<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n+    fn print_value_path(\n+        mut self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        let was_in_value = std::mem::replace(&mut self.in_value, true);\n+        self = self.print_def_path(def_id, substs)?;\n+        self.in_value = was_in_value;\n+\n+        Ok(self)\n+    }\n+\n+    fn in_binder<T>(\n+        self,\n+        value: &ty::Binder<T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+    {\n+        self.pretty_in_binder(value)\n+    }\n+\n+    fn generic_delimiters(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error> {\n+        write!(self, \"<\")?;\n+\n+        let was_in_value = std::mem::replace(&mut self.in_value, false);\n+        let mut inner = f(self)?;\n+        inner.in_value = was_in_value;\n+\n+        write!(inner, \">\")?;\n+        Ok(inner)\n+    }\n+\n+    fn region_should_not_be_omitted(\n+        &self,\n+        region: ty::Region<'_>,\n+    ) -> bool {\n+        let highlight = self.region_highlight_mode;\n+        if highlight.region_highlighted(region).is_some() {\n+            return true;\n+        }\n+\n+        if self.tcx.sess.verbose() {\n+            return true;\n+        }\n+\n+        let identify_regions = self.tcx.sess.opts.debugging_opts.identify_regions;\n+\n+        match *region {\n+            ty::ReEarlyBound(ref data) => {\n+                data.name != \"\" && data.name != \"'_\"\n+            }\n+\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+                if let ty::BrNamed(_, name) = br {\n+                    if name != \"\" && name != \"'_\" {\n+                        return true;\n+                    }\n+                }\n+\n+                if let Some((region, _)) = highlight.highlight_bound_region {\n+                    if br == region {\n+                        return true;\n+                    }\n+                }\n+\n+                false\n+            }\n+\n+            ty::ReScope(_) |\n+            ty::ReVar(_) if identify_regions => true,\n+\n+            ty::ReVar(_) |\n+            ty::ReScope(_) |\n+            ty::ReErased => false,\n+\n+            ty::ReStatic |\n+            ty::ReEmpty |\n+            ty::ReClosureBound(_) => true,\n+        }\n+    }\n+}\n+\n+// HACK(eddyb) limited to `FmtPrinter` because of `region_highlight_mode`.\n+impl<F: fmt::Write> FmtPrinter<'_, '_, '_, F> {\n+    pub fn pretty_print_region(\n+        mut self,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self, fmt::Error> {\n+        define_scoped_cx!(self);\n+\n+        // Watch out for region highlights.\n+        let highlight = self.region_highlight_mode;\n+        if let Some(n) = highlight.region_highlighted(region) {\n+            p!(write(\"'{}\", n));\n+            return Ok(self);\n+        }\n+\n+        if self.tcx.sess.verbose() {\n+            p!(write(\"{:?}\", region));\n+            return Ok(self);\n+        }\n+\n+        let identify_regions = self.tcx.sess.opts.debugging_opts.identify_regions;\n+\n+        // These printouts are concise.  They do not contain all the information\n+        // the user might want to diagnose an error, but there is basically no way\n+        // to fit that into a short string.  Hence the recommendation to use\n+        // `explain_region()` or `note_and_explain_region()`.\n+        match *region {\n+            ty::ReEarlyBound(ref data) => {\n+                if data.name != \"\" {\n+                    p!(write(\"{}\", data.name));\n+                    return Ok(self);\n+                }\n+            }\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+                if let ty::BrNamed(_, name) = br {\n+                    if name != \"\" && name != \"'_\" {\n+                        p!(write(\"{}\", name));\n+                        return Ok(self);\n+                    }\n+                }\n+\n+                if let Some((region, counter)) = highlight.highlight_bound_region {\n+                    if br == region {\n+                        p!(write(\"'{}\", counter));\n+                        return Ok(self);\n+                    }\n+                }\n+            }\n+            ty::ReScope(scope) if identify_regions => {\n+                match scope.data {\n+                    region::ScopeData::Node =>\n+                        p!(write(\"'{}s\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::CallSite =>\n+                        p!(write(\"'{}cs\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Arguments =>\n+                        p!(write(\"'{}as\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Destruction =>\n+                        p!(write(\"'{}ds\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Remainder(first_statement_index) => p!(write(\n+                        \"'{}_{}rs\",\n+                        scope.item_local_id().as_usize(),\n+                        first_statement_index.index()\n+                    )),\n+                }\n+                return Ok(self);\n+            }\n+            ty::ReVar(region_vid) if identify_regions => {\n+                p!(write(\"{:?}\", region_vid));\n+                return Ok(self);\n+            }\n+            ty::ReVar(_) => {}\n+            ty::ReScope(_) |\n+            ty::ReErased => {}\n+            ty::ReStatic => {\n+                p!(write(\"'static\"));\n+                return Ok(self);\n+            }\n+            ty::ReEmpty => {\n+                p!(write(\"'<empty>\"));\n+                return Ok(self);\n+            }\n+\n+            // The user should never encounter these in unsubstituted form.\n+            ty::ReClosureBound(vid) => {\n+                p!(write(\"{:?}\", vid));\n+                return Ok(self);\n+            }\n+        }\n+\n+        p!(write(\"'_\"));\n+\n+        Ok(self)\n+    }\n+}\n+\n+// HACK(eddyb) limited to `FmtPrinter` because of `binder_depth`,\n+// `region_index` and `used_region_names`.\n+impl<F: fmt::Write> FmtPrinter<'_, 'gcx, 'tcx, F> {\n+    pub fn pretty_in_binder<T>(\n+        mut self,\n+        value: &ty::Binder<T>,\n+    ) -> Result<Self, fmt::Error>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>\n+    {\n+        fn name_by_region_index(index: usize) -> InternedString {\n+            match index {\n+                0 => Symbol::intern(\"'r\"),\n+                1 => Symbol::intern(\"'s\"),\n+                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n+            }.as_interned_str()\n+        }\n+\n+        // Replace any anonymous late-bound regions with named\n+        // variants, using gensym'd identifiers, so that we can\n+        // clearly differentiate between named and unnamed regions in\n+        // the output. We'll probably want to tweak this over time to\n+        // decide just how much information to give.\n+        if self.binder_depth == 0 {\n+            self.prepare_late_bound_region_info(value);\n+        }\n+\n+        let mut empty = true;\n+        let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n+            write!(cx, \"{}\", if empty {\n+                empty = false;\n+                start\n+            } else {\n+                cont\n+            })\n+        };\n+\n+        define_scoped_cx!(self);\n+\n+        let old_region_index = self.region_index;\n+        let mut region_index = old_region_index;\n+        let new_value = self.tcx.replace_late_bound_regions(value, |br| {\n+            let _ = start_or_continue(&mut self, \"for<\", \", \");\n+            let br = match br {\n+                ty::BrNamed(_, name) => {\n+                    let _ = write!(self, \"{}\", name);\n+                    br\n+                }\n+                ty::BrAnon(_) |\n+                ty::BrFresh(_) |\n+                ty::BrEnv => {\n+                    let name = loop {\n+                        let name = name_by_region_index(region_index);\n+                        region_index += 1;\n+                        if !self.used_region_names.contains(&name) {\n+                            break name;\n+                        }\n+                    };\n+                    let _ = write!(self, \"{}\", name);\n+                    ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n+                }\n+            };\n+            self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n+        }).0;\n+        start_or_continue(&mut self, \"\", \"> \")?;\n+\n+        self.binder_depth += 1;\n+        self.region_index = region_index;\n+        let mut inner = new_value.print(self)?;\n+        inner.region_index = old_region_index;\n+        inner.binder_depth -= 1;\n+        Ok(inner)\n+    }\n+\n+    fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n+        where T: TypeFoldable<'tcx>\n+    {\n+\n+        struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<InternedString>);\n+        impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_> {\n+            fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+                match *r {\n+                    ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n+                        self.0.insert(name);\n+                    },\n+                    _ => {},\n+                }\n+                r.super_visit_with(self)\n+            }\n+        }\n+\n+        self.used_region_names.clear();\n+        let mut collector = LateBoundRegionNameCollector(&mut self.used_region_names);\n+        value.visit_with(&mut collector);\n+        self.region_index = 0;\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, T, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n+    for ty::Binder<T>\n+    where T: Print<'gcx, 'tcx, P, Output = P, Error = P::Error> + TypeFoldable<'tcx>\n+{\n+    type Output = P;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.in_binder(self)\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, T, U, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n+    for ty::OutlivesPredicate<T, U>\n+    where T: Print<'gcx, 'tcx, P, Output = P, Error = P::Error>,\n+          U: Print<'gcx, 'tcx, P, Output = P, Error = P::Error>,\n+{\n+    type Output = P;\n+    type Error = P::Error;\n+    fn print(&self, mut cx: P) -> Result<Self::Output, Self::Error> {\n+        define_scoped_cx!(cx);\n+        p!(print(self.0), write(\" : \"), print(self.1));\n+        Ok(cx)\n+    }\n+}\n+\n+macro_rules! forward_display_to_print {\n+    ($($ty:ty),+) => {\n+        $(impl fmt::Display for $ty {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                ty::tls::with(|tcx| {\n+                    tcx.lift(self)\n+                        .expect(\"could not lift for printing\")\n+                        .print(FmtPrinter::new(tcx, f, Namespace::TypeNS))?;\n+                    Ok(())\n+                })\n+            }\n+        })+\n+    };\n+}\n+\n+macro_rules! define_print_and_forward_display {\n+    (($self:ident, $cx:ident): $($ty:ty $print:block)+) => {\n+        $(impl<'gcx: 'tcx, 'tcx, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for $ty {\n+            type Output = P;\n+            type Error = fmt::Error;\n+            fn print(&$self, $cx: P) -> Result<Self::Output, Self::Error> {\n+                #[allow(unused_mut)]\n+                let mut $cx = $cx;\n+                define_scoped_cx!($cx);\n+                let _: () = $print;\n+                #[allow(unreachable_code)]\n+                Ok($cx)\n+            }\n+        })+\n+\n+        forward_display_to_print!($($ty),+);\n+    };\n+}\n+\n+// HACK(eddyb) this is separate because `ty::RegionKind` doesn't need lifting.\n+impl fmt::Display for ty::RegionKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            self.print(FmtPrinter::new(tcx, f, Namespace::TypeNS))?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+forward_display_to_print! {\n+    Ty<'tcx>,\n+    &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+\n+    // HACK(eddyb) these are exhaustive instead of generic,\n+    // because `for<'gcx: 'tcx, 'tcx>` isn't possible yet.\n+    ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n+    ty::Binder<ty::TraitRef<'tcx>>,\n+    ty::Binder<ty::FnSig<'tcx>>,\n+    ty::Binder<ty::TraitPredicate<'tcx>>,\n+    ty::Binder<ty::SubtypePredicate<'tcx>>,\n+    ty::Binder<ty::ProjectionPredicate<'tcx>>,\n+    ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n+    ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>,\n+\n+    ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>,\n+    ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n+}\n+\n+define_print_and_forward_display! {\n+    (self, cx):\n+\n+    &'tcx ty::List<Ty<'tcx>> {\n+        p!(write(\"{{\"));\n+        let mut tys = self.iter();\n+        if let Some(&ty) = tys.next() {\n+            p!(print(ty));\n+            for &ty in tys {\n+                p!(write(\", \"), print(ty));\n+            }\n+        }\n+        p!(write(\"}}\"))\n+    }\n+\n+    ty::TypeAndMut<'tcx> {\n+        p!(write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n+            print(self.ty))\n+    }\n+\n+    ty::ExistentialTraitRef<'tcx> {\n+        // Use a type that can't appear in defaults of type parameters.\n+        let dummy_self = cx.tcx().mk_infer(ty::FreshTy(0));\n+        let trait_ref = self.with_self_ty(cx.tcx(), dummy_self);\n+        p!(print(trait_ref))\n+    }\n+\n+    ty::ExistentialProjection<'tcx> {\n+        let name = cx.tcx().associated_item(self.item_def_id).ident;\n+        p!(write(\"{} = \", name), print(self.ty))\n+    }\n+\n+    ty::ExistentialPredicate<'tcx> {\n+        match *self {\n+            ty::ExistentialPredicate::Trait(x) => p!(print(x)),\n+            ty::ExistentialPredicate::Projection(x) => p!(print(x)),\n+            ty::ExistentialPredicate::AutoTrait(def_id) => {\n+                p!(print_def_path(def_id, &[]));\n+            }\n+        }\n+    }\n+\n+    ty::FnSig<'tcx> {\n+        if self.unsafety == hir::Unsafety::Unsafe {\n+            p!(write(\"unsafe \"));\n+        }\n+\n+        if self.abi != Abi::Rust {\n+            p!(write(\"extern {} \", self.abi));\n+        }\n+\n+        p!(write(\"fn\"), pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n+    }\n+\n+    ty::InferTy {\n+        if cx.tcx().sess.verbose() {\n+            p!(write(\"{:?}\", self));\n+            return Ok(cx);\n+        }\n+        match *self {\n+            ty::TyVar(_) => p!(write(\"_\")),\n+            ty::IntVar(_) => p!(write(\"{}\", \"{integer}\")),\n+            ty::FloatVar(_) => p!(write(\"{}\", \"{float}\")),\n+            ty::FreshTy(v) => p!(write(\"FreshTy({})\", v)),\n+            ty::FreshIntTy(v) => p!(write(\"FreshIntTy({})\", v)),\n+            ty::FreshFloatTy(v) => p!(write(\"FreshFloatTy({})\", v))\n+        }\n+    }\n+\n+    ty::TraitRef<'tcx> {\n+        p!(print_def_path(self.def_id, self.substs));\n+    }\n+\n+    ConstValue<'tcx> {\n+        match self {\n+            ConstValue::Infer(..) => p!(write(\"_\")),\n+            ConstValue::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n+            _ => p!(write(\"{:?}\", self)),\n+        }\n+    }\n+\n+    ty::Const<'tcx> {\n+        p!(write(\"{} : {}\", self.val, self.ty))\n+    }\n+\n+    &'tcx ty::LazyConst<'tcx> {\n+        match self {\n+            // FIXME(const_generics) this should print at least the type.\n+            ty::LazyConst::Unevaluated(..) => p!(write(\"_ : _\")),\n+            ty::LazyConst::Evaluated(c) => p!(write(\"{}\", c)),\n+        }\n+    }\n+\n+    ty::ParamTy {\n+        p!(write(\"{}\", self.name))\n+    }\n+\n+    ty::ParamConst {\n+        p!(write(\"{}\", self.name))\n+    }\n+\n+    ty::SubtypePredicate<'tcx> {\n+        p!(print(self.a), write(\" <: \"), print(self.b))\n+    }\n+\n+    ty::TraitPredicate<'tcx> {\n+        p!(print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n+    }\n+\n+    ty::ProjectionPredicate<'tcx> {\n+        p!(print(self.projection_ty), write(\" == \"), print(self.ty))\n+    }\n+\n+    ty::ProjectionTy<'tcx> {\n+        p!(print_def_path(self.item_def_id, self.substs));\n+    }\n+\n+    ty::ClosureKind {\n+        match *self {\n+            ty::ClosureKind::Fn => p!(write(\"Fn\")),\n+            ty::ClosureKind::FnMut => p!(write(\"FnMut\")),\n+            ty::ClosureKind::FnOnce => p!(write(\"FnOnce\")),\n+        }\n+    }\n+\n+    ty::Predicate<'tcx> {\n+        match *self {\n+            ty::Predicate::Trait(ref data) => p!(print(data)),\n+            ty::Predicate::Subtype(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::RegionOutlives(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::TypeOutlives(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::Projection(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                p!(write(\"the trait `\"),\n+                   print_def_path(trait_def_id, &[]),\n+                   write(\"` is object-safe\"))\n+            }\n+            ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n+                p!(write(\"the closure `\"),\n+                   print_value_path(closure_def_id, &[]),\n+                   write(\"` implements the trait `{}`\", kind))\n+            }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                p!(write(\"the constant `\"),\n+                   print_value_path(def_id, substs),\n+                   write(\"` can be evaluated\"))\n+            }\n+        }\n+    }\n+\n+    Kind<'tcx> {\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => p!(print(lt)),\n+            UnpackedKind::Type(ty) => p!(print(ty)),\n+            UnpackedKind::Const(ct) => p!(print(ct)),\n+        }\n+    }\n+}"}, {"sha": "395b288df141e11410998d712d061e22ed730053", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -71,7 +71,7 @@ pub(super) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n impl<'tcx, M: QueryAccessors<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n     default fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n-            format!(\"processing `{}`\", tcx.item_path_str(def_id)).into()\n+            format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()\n         } else {\n             let name = unsafe { ::std::intrinsics::type_name::<M>() };\n             format!(\"processing {:?} with query `{}`\", def_id, name).into()\n@@ -301,7 +301,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::layout_raw<'tcx> {\n impl<'tcx> QueryDescription<'tcx> for queries::super_predicates_of<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"computing the supertraits of `{}`\",\n-                tcx.item_path_str(def_id)).into()\n+                tcx.def_path_str(def_id)).into()\n     }\n }\n \n@@ -322,7 +322,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n impl<'tcx> QueryDescription<'tcx> for queries::coherent_trait<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"coherence checking all impls of trait `{}`\",\n-                tcx.item_path_str(def_id)).into()\n+                tcx.def_path_str(def_id)).into()\n     }\n }\n \n@@ -359,7 +359,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::inferred_outlives_crate<'tcx> {\n impl<'tcx> QueryDescription<'tcx> for queries::mir_shims<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n         format!(\"generating MIR shim for `{}`\",\n-                tcx.item_path_str(def.def_id())).into()\n+                tcx.def_path_str(def.def_id())).into()\n     }\n }\n \n@@ -394,7 +394,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_eval<'tcx> {\n     ) -> Cow<'static, str> {\n         format!(\n             \"const-evaluating + checking `{}`\",\n-            tcx.item_path_str(key.value.instance.def.def_id()),\n+            tcx.def_path_str(key.value.instance.def.def_id()),\n         ).into()\n     }\n \n@@ -415,7 +415,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_eval_raw<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n         -> Cow<'static, str>\n     {\n-        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.instance.def.def_id())).into()\n+        format!(\"const-evaluating `{}`\", tcx.def_path_str(key.value.instance.def.def_id())).into()\n     }\n \n     #[inline]\n@@ -513,7 +513,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::trait_of_item<'tcx> {\n impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_static<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"const checking if rvalue is promotable to static `{}`\",\n-            tcx.item_path_str(def_id)).into()\n+            tcx.def_path_str(def_id)).into()\n     }\n \n     #[inline]\n@@ -532,21 +532,21 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_sta\n impl<'tcx> QueryDescription<'tcx> for queries::rvalue_promotable_map<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"checking which parts of `{}` are promotable to static\",\n-                tcx.item_path_str(def_id)).into()\n+                tcx.def_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_mir_available<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"checking if item is mir available: `{}`\",\n-                tcx.item_path_str(def_id)).into()\n+                tcx.def_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::codegen_fulfill_obligation<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>,\n                 key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Cow<'static, str> {\n-        format!(\"checking if `{}` fulfills its obligations\", tcx.item_path_str(key.1.def_id()))\n+        format!(\"checking if `{}` fulfills its obligations\", tcx.def_path_str(key.1.def_id()))\n             .into()\n     }\n \n@@ -565,19 +565,19 @@ impl<'tcx> QueryDescription<'tcx> for queries::codegen_fulfill_obligation<'tcx>\n \n impl<'tcx> QueryDescription<'tcx> for queries::trait_impls_of<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id)).into()\n+        format!(\"trait impls of `{}`\", tcx.def_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_object_safe<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id)).into()\n+        format!(\"determine object safety of trait `{}`\", tcx.def_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_const_fn_raw<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id)).into()\n+        format!(\"checking if item is const fn: `{}`\", tcx.def_path_str(def_id)).into()\n     }\n }\n \n@@ -883,7 +883,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::output_filenames<'tcx> {\n \n impl<'tcx> QueryDescription<'tcx> for queries::vtable_methods<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::PolyTraitRef<'tcx> ) -> Cow<'static, str> {\n-        format!(\"finding all methods for trait {}\", tcx.item_path_str(key.def_id())).into()\n+        format!(\"finding all methods for trait {}\", tcx.def_path_str(key.def_id())).into()\n     }\n }\n \n@@ -927,7 +927,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::optimized_mir<'tcx> {\n \n impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_predicates<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, key: (DefId, SubstsRef<'tcx>)) -> Cow<'static, str> {\n-        format!(\"testing substituted normalized predicates:`{}`\", tcx.item_path_str(key.0)).into()\n+        format!(\"testing substituted normalized predicates:`{}`\", tcx.def_path_str(key.0)).into()\n     }\n }\n \n@@ -945,7 +945,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::target_features_whitelist<'tcx> {\n \n impl<'tcx> QueryDescription<'tcx> for queries::instance_def_size_estimate<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n-        format!(\"estimating size for `{}`\", tcx.item_path_str(def.def_id())).into()\n+        format!(\"estimating size for `{}`\", tcx.def_path_str(def.def_id())).into()\n     }\n }\n "}, {"sha": "cff99f23d0e95176d5765cadb6f847f3419d47d0", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -4,11 +4,10 @@\n \n use crate::dep_graph::{DepNodeIndex, DepNode, DepKind, SerializedDepNodeIndex};\n use crate::ty::tls;\n-use crate::ty::{TyCtxt};\n+use crate::ty::{self, TyCtxt};\n use crate::ty::query::Query;\n use crate::ty::query::config::{QueryConfig, QueryDescription};\n use crate::ty::query::job::{QueryJob, QueryResult, QueryInfo};\n-use crate::ty::item_path;\n \n use crate::util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n \n@@ -299,7 +298,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // sometimes cycles itself, leading to extra cycle errors.\n         // (And cycle errors around impls tend to occur during the\n         // collect/coherence phases anyhow.)\n-        item_path::with_forced_impl_filename_line(|| {\n+        ty::print::with_forced_impl_filename_line(|| {\n             let span = fix_span(stack[1 % stack.len()].span, &stack[0].query);\n             let mut err = struct_span_err!(self.sess,\n                                            span,"}, {"sha": "b245d90379996951f6775dcac6ff099f77ebf859", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -351,10 +351,8 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let tcx = relation.tcx();\n-    let a_sty = &a.sty;\n-    let b_sty = &b.sty;\n-    debug!(\"super_relate_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n-    match (a_sty, b_sty) {\n+    debug!(\"super_relate_tys: a={:?} b={:?}\", a, b);\n+    match (&a.sty, &b.sty) {\n         (&ty::Infer(_), _) |\n         (_, &ty::Infer(_)) =>\n         {"}, {"sha": "ecfb034e4f2fed45f066f5b820f727514473751e", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -3,17 +3,288 @@\n //! hand, though we've recently added some macros (e.g.,\n //! `BraceStructLiftImpl!`) to help with the tedium.\n \n+use crate::hir::def::Namespace;\n use crate::mir::ProjectionKind;\n use crate::mir::interpret::ConstValue;\n use crate::ty::{self, Lift, Ty, TyCtxt, ConstVid, InferConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::print::{FmtPrinter, Printer};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use smallvec::SmallVec;\n use crate::mir::interpret;\n \n+use std::fmt;\n use std::marker::PhantomData;\n use std::rc::Rc;\n \n+impl fmt::Debug for ty::GenericParamDef {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let type_name = match self.kind {\n+            ty::GenericParamDefKind::Lifetime => \"Lifetime\",\n+            ty::GenericParamDefKind::Type {..} => \"Type\",\n+            ty::GenericParamDefKind::Const => \"Const\",\n+        };\n+        write!(f, \"{}({}, {:?}, {})\",\n+               type_name,\n+               self.name,\n+               self.def_id,\n+               self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::TraitDef {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            FmtPrinter::new(tcx, f, Namespace::TypeNS)\n+                .print_def_path(self.def_id, &[])?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl fmt::Debug for ty::AdtDef {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            FmtPrinter::new(tcx, f, Namespace::TypeNS)\n+                .print_def_path(self.did, &[])?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl fmt::Debug for ty::ClosureUpvar<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ClosureUpvar({:?},{:?})\",\n+               self.def,\n+               self.ty)\n+    }\n+}\n+\n+impl fmt::Debug for ty::UpvarId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let name = ty::tls::with(|tcx| {\n+            tcx.hir().name_by_hir_id(self.var_path.hir_id)\n+        });\n+        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n+            self.var_path.hir_id,\n+            name,\n+            self.closure_expr_id)\n+    }\n+}\n+\n+impl fmt::Debug for ty::UpvarBorrow<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"UpvarBorrow({:?}, {:?})\",\n+               self.kind, self.region)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?} -> {}\", self.kind, self.target)\n+    }\n+}\n+\n+impl fmt::Debug for ty::BoundRegion {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n+            ty::BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n+            ty::BrNamed(did, name) => {\n+                write!(f, \"BrNamed({:?}:{:?}, {})\",\n+                        did.krate, did.index, name)\n+            }\n+            ty::BrEnv => write!(f, \"BrEnv\"),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::RegionKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::ReEarlyBound(ref data) => {\n+                write!(f, \"ReEarlyBound({}, {})\",\n+                        data.index,\n+                        data.name)\n+            }\n+\n+            ty::ReClosureBound(ref vid) => {\n+                write!(f, \"ReClosureBound({:?})\", vid)\n+            }\n+\n+            ty::ReLateBound(binder_id, ref bound_region) => {\n+                write!(f, \"ReLateBound({:?}, {:?})\", binder_id, bound_region)\n+            }\n+\n+            ty::ReFree(ref fr) => fr.fmt(f),\n+\n+            ty::ReScope(id) => write!(f, \"ReScope({:?})\", id),\n+\n+            ty::ReStatic => write!(f, \"ReStatic\"),\n+\n+            ty::ReVar(ref vid) => vid.fmt(f),\n+\n+            ty::RePlaceholder(placeholder) => {\n+                write!(f, \"RePlaceholder({:?})\", placeholder)\n+            }\n+\n+            ty::ReEmpty => write!(f, \"ReEmpty\"),\n+\n+            ty::ReErased => write!(f, \"ReErased\"),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::FreeRegion {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)\n+    }\n+}\n+\n+impl fmt::Debug for ty::Variance {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match *self {\n+            ty::Covariant => \"+\",\n+            ty::Contravariant => \"-\",\n+            ty::Invariant => \"o\",\n+            ty::Bivariant => \"*\",\n+        })\n+    }\n+}\n+\n+impl fmt::Debug for ty::FnSig<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"({:?}; c_variadic: {})->{:?}\",\n+                self.inputs(), self.c_variadic, self.output())\n+    }\n+}\n+\n+impl fmt::Debug for ty::TyVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}t\", self.index)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::ConstVid<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}c\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::IntVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}i\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::FloatVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}f\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::RegionVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"'_#{}r\", self.index())\n+    }\n+}\n+\n+impl fmt::Debug for ty::InferTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::TyVar(ref v) => v.fmt(f),\n+            ty::IntVar(ref v) => v.fmt(f),\n+            ty::FloatVar(ref v) => v.fmt(f),\n+            ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::IntVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::IntType(ref v) => v.fmt(f),\n+            ty::UintType(ref v) => v.fmt(f),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::FloatVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+impl fmt::Debug for ty::TraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // FIXME(#59188) this is used across the compiler to print\n+        // a `TraitRef` qualified (with the Self type explicit),\n+        // instead of having a different way to make that choice.\n+        write!(f, \"<{} as {}>\", self.self_ty(), self)\n+    }\n+}\n+\n+impl fmt::Debug for Ty<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ParamTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}/#{}\", self.name, self.idx)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ParamConst {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}/#{}\", self.name, self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::TraitPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"TraitPredicate({:?})\", self.trait_ref)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ProjectionPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ProjectionPredicate({:?}, {:?})\", self.projection_ty, self.ty)\n+    }\n+}\n+\n+impl fmt::Debug for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::Predicate::Trait(ref a) => a.fmt(f),\n+            ty::Predicate::Subtype(ref pair) => pair.fmt(f),\n+            ty::Predicate::RegionOutlives(ref pair) => pair.fmt(f),\n+            ty::Predicate::TypeOutlives(ref pair) => pair.fmt(f),\n+            ty::Predicate::Projection(ref pair) => pair.fmt(f),\n+            ty::Predicate::WellFormed(ty) => write!(f, \"WellFormed({:?})\", ty),\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+            }\n+            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                write!(f, \"ClosureKind({:?}, {:?}, {:?})\",\n+                    closure_def_id, closure_substs, kind)\n+            }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n+            }\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Atomic structs\n //\n@@ -48,10 +319,14 @@ CloneTypeFoldableAndLiftImpls! {\n     // really meant to be folded. In general, we can only fold a fully\n     // general `Region`.\n     crate::ty::BoundRegion,\n+    crate::ty::Placeholder<crate::ty::BoundRegion>,\n     crate::ty::ClosureKind,\n+    crate::ty::FreeRegion,\n+    crate::ty::InferTy,\n     crate::ty::IntVarValue,\n     crate::ty::ParamConst,\n     crate::ty::ParamTy,\n+    crate::ty::RegionVid,\n     crate::ty::UniverseIndex,\n     crate::ty::Variance,\n     ::syntax_pos::Span,\n@@ -60,6 +335,7 @@ CloneTypeFoldableAndLiftImpls! {\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n+// FIXME(eddyb) replace all the uses of `Option::map` with `?`.\n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -156,6 +432,23 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n+    type Lifted = ty::ExistentialPredicate<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match self {\n+            ty::ExistentialPredicate::Trait(x) => {\n+                tcx.lift(x).map(ty::ExistentialPredicate::Trait)\n+            }\n+            ty::ExistentialPredicate::Projection(x) => {\n+                tcx.lift(x).map(ty::ExistentialPredicate::Projection)\n+            }\n+            ty::ExistentialPredicate::AutoTrait(def_id) => {\n+                Some(ty::ExistentialPredicate::AutoTrait(*def_id))\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n@@ -480,6 +773,13 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n     }\n }\n \n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for ty::TypeAndMut<'a> {\n+        type Lifted = ty::TypeAndMut<'tcx>;\n+        ty, mutbl\n+    }\n+}\n+\n BraceStructLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for ty::Instance<'a> {\n         type Lifted = ty::Instance<'tcx>;"}, {"sha": "dfe87242c7128ef4ed4e4adb8bc6e106537d7db2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -9,7 +9,7 @@ use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_macros::HashStable;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, Kind, UnpackedKind};\n-use crate::ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, AdtDef, DefIdTree, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n use crate::util::captures::Captures;\n use crate::mir::interpret::{Scalar, Pointer};\n@@ -84,7 +84,7 @@ impl BoundRegion {\n \n /// N.B., if you change this, you'll probably want to change the corresponding\n /// AST structure in `libsyntax/ast.rs` as well.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n          RustcEncodable, RustcDecodable, HashStable)]\n pub enum TyKind<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n@@ -383,9 +383,10 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     ///\n     /// If you have an inference context, use `infcx.closure_sig()`.\n     pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n-        match self.closure_sig_ty(def_id, tcx).sty {\n+        let ty = self.closure_sig_ty(def_id, tcx);\n+        match ty.sty {\n             ty::FnPtr(sig) => sig,\n-            ref t => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", t),\n+            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty),\n         }\n     }\n }\n@@ -1590,7 +1591,7 @@ impl RegionKind {\n     pub fn free_region_binding_scope(&self, tcx: TyCtxt<'_, '_, '_>) -> DefId {\n         match self {\n             ty::ReEarlyBound(br) => {\n-                tcx.parent_def_id(br.def_id).unwrap()\n+                tcx.parent(br.def_id).unwrap()\n             }\n             ty::ReFree(fr) => fr.scope,\n             _ => bug!(\"free_region_binding_scope invoked on inappropriate region: {:?}\", self),"}, {"sha": "846428656146917250b4104c0ff83bd09710e45b", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -12,8 +12,8 @@ use smallvec::SmallVec;\n use rustc_macros::HashStable;\n \n use core::intrinsics;\n-use std::cmp::Ordering;\n use std::fmt;\n+use std::cmp::Ordering;\n use std::marker::PhantomData;\n use std::mem;\n use std::num::NonZeroUsize;\n@@ -70,6 +70,16 @@ impl<'tcx> UnpackedKind<'tcx> {\n     }\n }\n \n+impl fmt::Debug for Kind<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => lt.fmt(f),\n+            UnpackedKind::Type(ty) => ty.fmt(f),\n+            UnpackedKind::Const(ct) => ct.fmt(f),\n+        }\n+    }\n+}\n+\n impl<'tcx> Ord for Kind<'tcx> {\n     fn cmp(&self, other: &Kind<'_>) -> Ordering {\n         self.unpack().cmp(&other.unpack())\n@@ -115,34 +125,14 @@ impl<'tcx> Kind<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for Kind<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => write!(f, \"{:?}\", lt),\n-            UnpackedKind::Type(ty) => write!(f, \"{:?}\", ty),\n-            UnpackedKind::Const(ct) => write!(f, \"{:?}\", ct),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for Kind<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => write!(f, \"{}\", lt),\n-            UnpackedKind::Type(ty) => write!(f, \"{}\", ty),\n-            UnpackedKind::Const(ct) => write!(f, \"{}\", ct),\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n     type Lifted = Kind<'tcx>;\n \n     fn lift_to_tcx<'cx, 'gcx>(&self, tcx: TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => lt.lift_to_tcx(tcx).map(|lt| lt.into()),\n-            UnpackedKind::Type(ty) => ty.lift_to_tcx(tcx).map(|ty| ty.into()),\n-            UnpackedKind::Const(ct) => ct.lift_to_tcx(tcx).map(|ct| ct.into()),\n+            UnpackedKind::Lifetime(lt) => tcx.lift(&lt).map(|lt| lt.into()),\n+            UnpackedKind::Type(ty) => tcx.lift(&ty).map(|ty| ty.into()),\n+            UnpackedKind::Const(ct) => tcx.lift(&ct).map(|ct| ct.into()),\n         }\n     }\n }"}, {"sha": "65918a90821022cc4048dec58718657950ec4eba", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -7,7 +7,7 @@ use crate::hir::{self, Node};\n use crate::mir::interpret::{sign_extend, truncate};\n use crate::ich::NodeIdHashingMode;\n use crate::traits::{self, ObligationCause};\n-use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n+use crate::ty::{self, DefIdTree, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n use crate::ty::subst::{Subst, InternalSubsts, SubstsRef, UnpackedKind};\n use crate::ty::query::TyCtxtAt;\n use crate::ty::TyKind::*;\n@@ -563,7 +563,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_base_def_id(self, def_id: DefId) -> DefId {\n         let mut def_id = def_id;\n         while self.is_closure(def_id) {\n-            def_id = self.parent_def_id(def_id).unwrap_or_else(|| {\n+            def_id = self.parent(def_id).unwrap_or_else(|| {\n                 bug!(\"closure {:?} has no parent\", def_id);\n             });\n         }"}, {"sha": "a1398c69ff0c59ea69732cbe4f5c269c948f914e", "filename": "src/librustc/util/ppaux.rs", "status": "removed", "additions": 0, "deletions": 1667, "changes": 1667, "blob_url": "https://github.com/rust-lang/rust/blob/16e7e05e95a6a5a1e0dba54ae722274bd7d725f7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e7e05e95a6a5a1e0dba54ae722274bd7d725f7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=16e7e05e95a6a5a1e0dba54ae722274bd7d725f7", "patch": "@@ -1,1667 +0,0 @@\n-use crate::hir::def_id::DefId;\n-use crate::hir::map::definitions::DefPathData;\n-use crate::middle::region;\n-use crate::ty::subst::{self, Subst, SubstsRef};\n-use crate::ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n-use crate::ty::{Bool, Char, Adt};\n-use crate::ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n-use crate::ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n-use crate::ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n-use crate::ty::{Placeholder, UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind, ParamConst};\n-use crate::mir::interpret::ConstValue;\n-use crate::util::nodemap::FxHashSet;\n-\n-use std::cell::Cell;\n-use std::fmt;\n-use std::usize;\n-\n-use rustc_target::spec::abi::Abi;\n-use syntax::ast::CRATE_NODE_ID;\n-use syntax::symbol::{Symbol, InternedString};\n-use crate::hir;\n-\n-/// The \"region highlights\" are used to control region printing during\n-/// specific error messages. When a \"region highlight\" is enabled, it\n-/// gives an alternate way to print specific regions. For now, we\n-/// always print those regions using a number, so something like \"`'0`\".\n-///\n-/// Regions not selected by the region highlight mode are presently\n-/// unaffected.\n-#[derive(Copy, Clone, Default)]\n-pub struct RegionHighlightMode {\n-    /// If enabled, when we see the selected region, use \"`'N`\"\n-    /// instead of the ordinary behavior.\n-    highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n-\n-    /// If enabled, when printing a \"free region\" that originated from\n-    /// the given `ty::BoundRegion`, print it as \"`'1`\". Free regions that would ordinarily\n-    /// have names print as normal.\n-    ///\n-    /// This is used when you have a signature like `fn foo(x: &u32,\n-    /// y: &'a u32)` and we want to give a name to the region of the\n-    /// reference `x`.\n-    highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n-}\n-\n-thread_local! {\n-    /// Mechanism for highlighting of specific regions for display in NLL region inference errors.\n-    /// Contains region to highlight and counter for number to use when highlighting.\n-    static REGION_HIGHLIGHT_MODE: Cell<RegionHighlightMode> =\n-        Cell::new(RegionHighlightMode::default())\n-}\n-\n-impl RegionHighlightMode {\n-    /// Reads and returns the current region highlight settings (accesses thread-local state).\n-    pub fn get() -> Self {\n-        REGION_HIGHLIGHT_MODE.with(|c| c.get())\n-    }\n-\n-    // Internal helper to update current settings during the execution of `op`.\n-    fn set<R>(\n-        old_mode: Self,\n-        new_mode: Self,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        REGION_HIGHLIGHT_MODE.with(|c| {\n-            c.set(new_mode);\n-            let result = op();\n-            c.set(old_mode);\n-            result\n-        })\n-    }\n-\n-    /// If `region` and `number` are both `Some`, invokes\n-    /// `highlighting_region`; otherwise, just invokes `op` directly.\n-    pub fn maybe_highlighting_region<R>(\n-        region: Option<ty::Region<'_>>,\n-        number: Option<usize>,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        if let Some(k) = region {\n-            if let Some(n) = number {\n-                return Self::highlighting_region(k, n, op);\n-            }\n-        }\n-\n-        op()\n-    }\n-\n-    /// During the execution of `op`, highlights the region inference\n-    /// variable `vid` as `'N`. We can only highlight one region `vid`\n-    /// at a time.\n-    pub fn highlighting_region<R>(\n-        region: ty::Region<'_>,\n-        number: usize,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        let old_mode = Self::get();\n-        let mut new_mode = old_mode;\n-        let first_avail_slot = new_mode.highlight_regions.iter_mut()\n-            .filter(|s| s.is_none())\n-            .next()\n-            .unwrap_or_else(|| {\n-                panic!(\n-                    \"can only highlight {} placeholders at a time\",\n-                    old_mode.highlight_regions.len(),\n-                )\n-            });\n-        *first_avail_slot = Some((*region, number));\n-        Self::set(old_mode, new_mode, op)\n-    }\n-\n-    /// Convenience wrapper for `highlighting_region`.\n-    pub fn highlighting_region_vid<R>(\n-        vid: ty::RegionVid,\n-        number: usize,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        Self::highlighting_region(&ty::ReVar(vid), number, op)\n-    }\n-\n-    /// Returns `true` if any placeholders are highlighted, and `false` otherwise.\n-    fn any_region_vids_highlighted(&self) -> bool {\n-        Self::get()\n-            .highlight_regions\n-            .iter()\n-            .any(|h| match h {\n-                Some((ty::ReVar(_), _)) => true,\n-                _ => false,\n-            })\n-    }\n-\n-    /// Returns `Some(n)` with the number to use for the given region, if any.\n-    fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n-        Self::get()\n-            .highlight_regions\n-            .iter()\n-            .filter_map(|h| match h {\n-                Some((r, n)) if r == region => Some(*n),\n-                _ => None,\n-            })\n-            .next()\n-    }\n-\n-    /// During the execution of `op`, highlight the given bound\n-    /// region. We can only highlight one bound region at a time. See\n-    /// the field `highlight_bound_region` for more detailed notes.\n-    pub fn highlighting_bound_region<R>(\n-        br: ty::BoundRegion,\n-        number: usize,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        let old_mode = Self::get();\n-        assert!(old_mode.highlight_bound_region.is_none());\n-        Self::set(\n-            old_mode,\n-            Self {\n-                highlight_bound_region: Some((br, number)),\n-                ..old_mode\n-            },\n-            op,\n-        )\n-    }\n-\n-    /// Returns `true` if any placeholders are highlighted, and `false` otherwise.\n-    pub fn any_placeholders_highlighted(&self) -> bool {\n-        Self::get()\n-            .highlight_regions\n-            .iter()\n-            .any(|h| match h {\n-                Some((ty::RePlaceholder(_), _)) => true,\n-                _ => false,\n-            })\n-    }\n-\n-    /// Returns `Some(N)` if the placeholder `p` is highlighted to print as \"`'N`\".\n-    pub fn placeholder_highlight(&self, p: ty::PlaceholderRegion) -> Option<usize> {\n-        self.region_highlighted(&ty::RePlaceholder(p))\n-    }\n-}\n-\n-macro_rules! gen_display_debug_body {\n-    ( $with:path ) => {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            let mut cx = PrintContext::new();\n-            $with(self, f, &mut cx)\n-        }\n-    };\n-}\n-macro_rules! gen_display_debug {\n-    ( ($($x:tt)+) $target:ty, display yes ) => {\n-        impl<$($x)+> fmt::Display for $target {\n-            gen_display_debug_body! { Print::print_display }\n-        }\n-    };\n-    ( () $target:ty, display yes ) => {\n-        impl fmt::Display for $target {\n-            gen_display_debug_body! { Print::print_display }\n-        }\n-    };\n-    ( ($($x:tt)+) $target:ty, debug yes ) => {\n-        impl<$($x)+> fmt::Debug for $target {\n-            gen_display_debug_body! { Print::print_debug }\n-        }\n-    };\n-    ( () $target:ty, debug yes ) => {\n-        impl fmt::Debug for $target {\n-            gen_display_debug_body! { Print::print_debug }\n-        }\n-    };\n-    ( $generic:tt $target:ty, $t:ident no ) => {};\n-}\n-macro_rules! gen_print_impl {\n-    ( ($($x:tt)+) $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n-        impl<$($x)+> Print for $target {\n-            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n-                if $cx.is_debug $dbg\n-                else $disp\n-            }\n-        }\n-    };\n-    ( () $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n-        impl Print for $target {\n-            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n-                if $cx.is_debug $dbg\n-                else $disp\n-            }\n-        }\n-    };\n-    ( $generic:tt $target:ty,\n-      $vars:tt $gendisp:ident $disp:block $gendbg:ident $dbg:block ) => {\n-        gen_print_impl! { $generic $target, $vars $disp $dbg }\n-        gen_display_debug! { $generic $target, display $gendisp }\n-        gen_display_debug! { $generic $target, debug $gendbg }\n-    }\n-}\n-macro_rules! define_print {\n-    ( $generic:tt $target:ty,\n-      $vars:tt { display $disp:block debug $dbg:block } ) => {\n-        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n-    };\n-    ( $generic:tt $target:ty,\n-      $vars:tt { debug $dbg:block display $disp:block } ) => {\n-        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n-    };\n-    ( $generic:tt $target:ty,\n-      $vars:tt { debug $dbg:block } ) => {\n-        gen_print_impl! { $generic $target, $vars no {\n-            bug!(concat!(\"display not implemented for \", stringify!($target)));\n-        } yes $dbg }\n-    };\n-    ( $generic:tt $target:ty,\n-      ($self:ident, $f:ident, $cx:ident) { display $disp:block } ) => {\n-        gen_print_impl! { $generic $target, ($self, $f, $cx) yes $disp no {\n-            write!($f, \"{:?}\", $self)\n-        } }\n-    };\n-}\n-macro_rules! define_print_multi {\n-    ( [ $($generic:tt $target:ty),* ] $vars:tt $def:tt ) => {\n-        $(define_print! { $generic $target, $vars $def })*\n-    };\n-}\n-macro_rules! print_inner {\n-    ( $f:expr, $cx:expr, write ($($data:expr),+) ) => {\n-        write!($f, $($data),+)\n-    };\n-    ( $f:expr, $cx:expr, $kind:ident ($data:expr) ) => {\n-        $data.$kind($f, $cx)\n-    };\n-}\n-macro_rules! print {\n-    ( $f:expr, $cx:expr $(, $kind:ident $data:tt)+ ) => {\n-        Ok(())$(.and_then(|_| print_inner!($f, $cx, $kind $data)))+\n-    };\n-}\n-\n-\n-struct LateBoundRegionNameCollector(FxHashSet<InternedString>);\n-impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        match *r {\n-            ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n-                self.0.insert(name);\n-            },\n-            _ => {},\n-        }\n-        r.super_visit_with(self)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct PrintContext {\n-    is_debug: bool,\n-    is_verbose: bool,\n-    identify_regions: bool,\n-    used_region_names: Option<FxHashSet<InternedString>>,\n-    region_index: usize,\n-    binder_depth: usize,\n-}\n-impl PrintContext {\n-    fn new() -> Self {\n-        ty::tls::with_opt(|tcx| {\n-            let (is_verbose, identify_regions) = tcx.map(\n-                |tcx| (tcx.sess.verbose(), tcx.sess.opts.debugging_opts.identify_regions)\n-            ).unwrap_or((false, false));\n-            PrintContext {\n-                is_debug: false,\n-                is_verbose: is_verbose,\n-                identify_regions: identify_regions,\n-                used_region_names: None,\n-                region_index: 0,\n-                binder_depth: 0,\n-            }\n-        })\n-    }\n-    fn prepare_late_bound_region_info<'tcx, T>(&mut self, value: &ty::Binder<T>)\n-    where T: TypeFoldable<'tcx>\n-    {\n-        let mut collector = LateBoundRegionNameCollector(Default::default());\n-        value.visit_with(&mut collector);\n-        self.used_region_names = Some(collector.0);\n-        self.region_index = 0;\n-    }\n-}\n-\n-pub trait Print {\n-    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result;\n-    fn print_to_string(&self, cx: &mut PrintContext) -> String {\n-        let mut result = String::new();\n-        let _ = self.print(&mut result, cx);\n-        result\n-    }\n-    fn print_display<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n-        let old_debug = cx.is_debug;\n-        cx.is_debug = false;\n-        let result = self.print(f, cx);\n-        cx.is_debug = old_debug;\n-        result\n-    }\n-    fn print_display_to_string(&self, cx: &mut PrintContext) -> String {\n-        let mut result = String::new();\n-        let _ = self.print_display(&mut result, cx);\n-        result\n-    }\n-    fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n-        let old_debug = cx.is_debug;\n-        cx.is_debug = true;\n-        let result = self.print(f, cx);\n-        cx.is_debug = old_debug;\n-        result\n-    }\n-    fn print_debug_to_string(&self, cx: &mut PrintContext) -> String {\n-        let mut result = String::new();\n-        let _ = self.print_debug(&mut result, cx);\n-        result\n-    }\n-}\n-\n-impl PrintContext {\n-    fn fn_sig<F: fmt::Write>(&mut self,\n-                             f: &mut F,\n-                             inputs: &[Ty<'_>],\n-                             c_variadic: bool,\n-                             output: Ty<'_>)\n-                             -> fmt::Result {\n-        write!(f, \"(\")?;\n-        let mut inputs = inputs.iter();\n-        if let Some(&ty) = inputs.next() {\n-            print!(f, self, print_display(ty))?;\n-            for &ty in inputs {\n-                print!(f, self, write(\", \"), print_display(ty))?;\n-            }\n-            if c_variadic {\n-                write!(f, \", ...\")?;\n-            }\n-        }\n-        write!(f, \")\")?;\n-        if !output.is_unit() {\n-            print!(f, self, write(\" -> \"), print_display(output))?;\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn parameterized<F: fmt::Write>(&mut self,\n-                                    f: &mut F,\n-                                    substs: SubstsRef<'_>,\n-                                    did: DefId,\n-                                    projections: &[ty::ProjectionPredicate<'_>])\n-                                    -> fmt::Result {\n-        let key = ty::tls::with(|tcx| tcx.def_key(did));\n-\n-        let verbose = self.is_verbose;\n-        let mut num_supplied_defaults = 0;\n-        let mut has_self = false;\n-        let mut own_counts: GenericParamCount = Default::default();\n-        let mut is_value_path = false;\n-        let mut item_name = Some(key.disambiguated_data.data.as_interned_str());\n-        let fn_trait_kind = ty::tls::with(|tcx| {\n-            // Unfortunately, some kinds of items (e.g., closures) don't have\n-            // generics. So walk back up the find the closest parent that DOES\n-            // have them.\n-            let mut item_def_id = did;\n-            loop {\n-                let key = tcx.def_key(item_def_id);\n-                match key.disambiguated_data.data {\n-                    DefPathData::AssocTypeInTrait(_) |\n-                    DefPathData::AssocTypeInImpl(_) |\n-                    DefPathData::AssocExistentialInImpl(_) |\n-                    DefPathData::Trait(_) |\n-                    DefPathData::TraitAlias(_) |\n-                    DefPathData::Impl |\n-                    DefPathData::TypeNs(_) => {\n-                        break;\n-                    }\n-                    DefPathData::ValueNs(_) |\n-                    DefPathData::EnumVariant(_) => {\n-                        is_value_path = true;\n-                        break;\n-                    }\n-                    DefPathData::CrateRoot |\n-                    DefPathData::Misc |\n-                    DefPathData::Module(_) |\n-                    DefPathData::MacroDef(_) |\n-                    DefPathData::ClosureExpr |\n-                    DefPathData::TypeParam(_) |\n-                    DefPathData::LifetimeParam(_) |\n-                    DefPathData::ConstParam(_) |\n-                    DefPathData::Field(_) |\n-                    DefPathData::StructCtor |\n-                    DefPathData::AnonConst |\n-                    DefPathData::ImplTrait |\n-                    DefPathData::GlobalMetaData(_) => {\n-                        // if we're making a symbol for something, there ought\n-                        // to be a value or type-def or something in there\n-                        // *somewhere*\n-                        item_def_id.index = key.parent.unwrap_or_else(|| {\n-                            bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                                 parent\", did, item_def_id);\n-                        });\n-                    }\n-                }\n-            }\n-            let mut generics = tcx.generics_of(item_def_id);\n-            let child_own_counts = generics.own_counts();\n-            let mut path_def_id = did;\n-            has_self = generics.has_self;\n-\n-            let mut child_types = 0;\n-            if let Some(def_id) = generics.parent {\n-                // Methods.\n-                assert!(is_value_path);\n-                child_types = child_own_counts.types;\n-                generics = tcx.generics_of(def_id);\n-                own_counts = generics.own_counts();\n-\n-                if has_self {\n-                    print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n-                }\n-\n-                path_def_id = def_id;\n-            } else {\n-                item_name = None;\n-\n-                if is_value_path {\n-                    // Functions.\n-                    assert_eq!(has_self, false);\n-                } else {\n-                    // Types and traits.\n-                    own_counts = child_own_counts;\n-                }\n-            }\n-\n-            if !verbose {\n-                let mut type_params =\n-                    generics.params.iter().rev().filter_map(|param| match param.kind {\n-                        GenericParamDefKind::Lifetime => None,\n-                        GenericParamDefKind::Type { has_default, .. } => {\n-                            Some((param.def_id, has_default))\n-                        }\n-                        GenericParamDefKind::Const => None, // FIXME(const_generics:defaults)\n-                    }).peekable();\n-                let has_default = {\n-                    let has_default = type_params.peek().map(|(_, has_default)| has_default);\n-                    *has_default.unwrap_or(&false)\n-                };\n-                if has_default {\n-                    if let Some(substs) = tcx.lift(&substs) {\n-                        let types = substs.types().rev().skip(child_types);\n-                        for ((def_id, has_default), actual) in type_params.zip(types) {\n-                            if !has_default {\n-                                break;\n-                            }\n-                            if tcx.type_of(def_id).subst(tcx, substs) != actual {\n-                                break;\n-                            }\n-                            num_supplied_defaults += 1;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            print!(f, self, write(\"{}\", tcx.item_path_str(path_def_id)))?;\n-            Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n-        })?;\n-\n-        if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n-            let projection_ty = projections[0].ty;\n-            if let Tuple(ref args) = substs.type_at(1).sty {\n-                return self.fn_sig(f, args, false, projection_ty);\n-            }\n-        }\n-\n-        let empty = Cell::new(true);\n-        let start_or_continue = |f: &mut F, start: &str, cont: &str| {\n-            if empty.get() {\n-                empty.set(false);\n-                write!(f, \"{}\", start)\n-            } else {\n-                write!(f, \"{}\", cont)\n-            }\n-        };\n-\n-        let print_regions = |f: &mut F, start: &str, skip, count| {\n-            // Don't print any regions if they're all erased.\n-            let regions = || substs.regions().skip(skip).take(count);\n-            if regions().all(|r: ty::Region<'_>| *r == ty::ReErased) {\n-                return Ok(());\n-            }\n-\n-            for region in regions() {\n-                let region: ty::Region<'_> = region;\n-                start_or_continue(f, start, \", \")?;\n-                if verbose {\n-                    write!(f, \"{:?}\", region)?;\n-                } else {\n-                    let s = region.to_string();\n-                    if s.is_empty() {\n-                        // This happens when the value of the region\n-                        // parameter is not easily serialized. This may be\n-                        // because the user omitted it in the first place,\n-                        // or because it refers to some block in the code,\n-                        // etc. I'm not sure how best to serialize this.\n-                        write!(f, \"'_\")?;\n-                    } else {\n-                        write!(f, \"{}\", s)?;\n-                    }\n-                }\n-            }\n-\n-            Ok(())\n-        };\n-\n-        print_regions(f, \"<\", 0, own_counts.lifetimes)?;\n-\n-        let tps = substs.types()\n-                        .take(own_counts.types - num_supplied_defaults)\n-                        .skip(has_self as usize);\n-\n-        for ty in tps {\n-            start_or_continue(f, \"<\", \", \")?;\n-            ty.print_display(f, self)?;\n-        }\n-\n-        for projection in projections {\n-            start_or_continue(f, \"<\", \", \")?;\n-            ty::tls::with(|tcx|\n-                print!(f, self,\n-                       write(\"{}=\",\n-                             tcx.associated_item(projection.projection_ty.item_def_id).ident),\n-                       print_display(projection.ty))\n-            )?;\n-        }\n-\n-        // FIXME(const_generics::defaults)\n-        let consts = substs.consts();\n-\n-        for ct in consts {\n-            start_or_continue(f, \"<\", \", \")?;\n-            ct.print_display(f, self)?;\n-        }\n-\n-        start_or_continue(f, \"\", \">\")?;\n-\n-        // For values, also print their name and type parameters.\n-        if is_value_path {\n-            empty.set(true);\n-\n-            if has_self {\n-                write!(f, \">\")?;\n-            }\n-\n-            if let Some(item_name) = item_name {\n-                write!(f, \"::{}\", item_name)?;\n-            }\n-\n-            print_regions(f, \"::<\", own_counts.lifetimes, usize::MAX)?;\n-\n-            // FIXME: consider being smart with defaults here too\n-            for ty in substs.types().skip(own_counts.types) {\n-                start_or_continue(f, \"::<\", \", \")?;\n-                ty.print_display(f, self)?;\n-            }\n-\n-            start_or_continue(f, \"\", \">\")?;\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn in_binder<'a, 'gcx, 'tcx, T, U, F>(&mut self,\n-                                          f: &mut F,\n-                                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                          original: &ty::Binder<T>,\n-                                          lifted: Option<ty::Binder<U>>) -> fmt::Result\n-        where T: Print, U: Print + TypeFoldable<'tcx>, F: fmt::Write\n-    {\n-        fn name_by_region_index(index: usize) -> InternedString {\n-            match index {\n-                0 => Symbol::intern(\"'r\"),\n-                1 => Symbol::intern(\"'s\"),\n-                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n-            }.as_interned_str()\n-        }\n-\n-        // Replace any anonymous late-bound regions with named\n-        // variants, using gensym'd identifiers, so that we can\n-        // clearly differentiate between named and unnamed regions in\n-        // the output. We'll probably want to tweak this over time to\n-        // decide just how much information to give.\n-        let value = if let Some(v) = lifted {\n-            v\n-        } else {\n-            return original.skip_binder().print_display(f, self);\n-        };\n-\n-        if self.binder_depth == 0 {\n-            self.prepare_late_bound_region_info(&value);\n-        }\n-\n-        let mut empty = true;\n-        let mut start_or_continue = |f: &mut F, start: &str, cont: &str| {\n-            if empty {\n-                empty = false;\n-                write!(f, \"{}\", start)\n-            } else {\n-                write!(f, \"{}\", cont)\n-            }\n-        };\n-\n-        let old_region_index = self.region_index;\n-        let mut region_index = old_region_index;\n-        let new_value = tcx.replace_late_bound_regions(&value, |br| {\n-            let _ = start_or_continue(f, \"for<\", \", \");\n-            let br = match br {\n-                ty::BrNamed(_, name) => {\n-                    let _ = write!(f, \"{}\", name);\n-                    br\n-                }\n-                ty::BrAnon(_) |\n-                ty::BrFresh(_) |\n-                ty::BrEnv => {\n-                    let name = loop {\n-                        let name = name_by_region_index(region_index);\n-                        region_index += 1;\n-                        if !self.is_name_used(&name) {\n-                            break name;\n-                        }\n-                    };\n-                    let _ = write!(f, \"{}\", name);\n-                    ty::BrNamed(tcx.hir().local_def_id(CRATE_NODE_ID), name)\n-                }\n-            };\n-            tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n-        }).0;\n-        start_or_continue(f, \"\", \"> \")?;\n-\n-        // Push current state to gcx, and restore after writing new_value.\n-        self.binder_depth += 1;\n-        self.region_index = region_index;\n-        let result = new_value.print_display(f, self);\n-        self.region_index = old_region_index;\n-        self.binder_depth -= 1;\n-        result\n-    }\n-\n-    fn is_name_used(&self, name: &InternedString) -> bool {\n-        match self.used_region_names {\n-            Some(ref names) => names.contains(name),\n-            None => false,\n-        }\n-    }\n-}\n-\n-pub fn verbose() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.verbose())\n-}\n-\n-pub fn identify_regions() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.identify_regions)\n-}\n-\n-pub fn parameterized<F: fmt::Write>(f: &mut F,\n-                                    substs: SubstsRef<'_>,\n-                                    did: DefId,\n-                                    projections: &[ty::ProjectionPredicate<'_>])\n-                                    -> fmt::Result {\n-    PrintContext::new().parameterized(f, substs, did, projections)\n-}\n-\n-impl<'a, T: Print> Print for &'a T {\n-    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n-        (*self).print(f, cx)\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) &'tcx ty::List<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n-        display {\n-            // Generate the main trait ref, including associated types.\n-            ty::tls::with(|tcx| {\n-                // Use a type that can't appear in defaults of type parameters.\n-                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-                let mut first = true;\n-\n-                if let Some(principal) = self.principal() {\n-                    let principal = tcx\n-                        .lift(&principal)\n-                        .expect(\"could not lift TraitRef for printing\")\n-                        .with_self_ty(tcx, dummy_self);\n-                    let projections = self.projection_bounds().map(|p| {\n-                        tcx.lift(&p)\n-                            .expect(\"could not lift projection for printing\")\n-                            .with_self_ty(tcx, dummy_self)\n-                    }).collect::<Vec<_>>();\n-                    cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n-                    first = false;\n-                }\n-\n-                // Builtin bounds.\n-                let mut auto_traits: Vec<_> = self.auto_traits().map(|did| {\n-                    tcx.item_path_str(did)\n-                }).collect();\n-\n-                // The auto traits come ordered by `DefPathHash`. While\n-                // `DefPathHash` is *stable* in the sense that it depends on\n-                // neither the host nor the phase of the moon, it depends\n-                // \"pseudorandomly\" on the compiler version and the target.\n-                //\n-                // To avoid that causing instabilities in compiletest\n-                // output, sort the auto-traits alphabetically.\n-                auto_traits.sort();\n-\n-                for auto_trait in auto_traits {\n-                    if !first {\n-                        write!(f, \" + \")?;\n-                    }\n-                    first = false;\n-\n-                    write!(f, \"{}\", auto_trait)?;\n-                }\n-\n-                Ok(())\n-            })?;\n-\n-            Ok(())\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::GenericParamDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let type_name = match self.kind {\n-            ty::GenericParamDefKind::Lifetime => \"Lifetime\",\n-            ty::GenericParamDefKind::Type { .. } => \"Type\",\n-            ty::GenericParamDefKind::Const => \"Const\",\n-        };\n-        write!(f, \"{}({}, {:?}, {})\",\n-               type_name,\n-               self.name,\n-               self.def_id,\n-               self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::TraitDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            write!(f, \"{}\", tcx.item_path_str(self.def_id))\n-        })\n-    }\n-}\n-\n-impl fmt::Debug for ty::AdtDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            write!(f, \"{}\", tcx.item_path_str(self.did))\n-        })\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ClosureUpvar({:?},{:?})\",\n-               self.def,\n-               self.ty)\n-    }\n-}\n-\n-impl fmt::Debug for ty::UpvarId {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n-               self.var_path.hir_id,\n-               ty::tls::with(|tcx| tcx.hir().name_by_hir_id(self.var_path.hir_id)),\n-               self.closure_expr_id)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"UpvarBorrow({:?}, {:?})\",\n-               self.kind, self.region)\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) &'tcx ty::List<Ty<'tcx>>, (self, f, cx) {\n-        display {\n-            write!(f, \"{{\")?;\n-            let mut tys = self.iter();\n-            if let Some(&ty) = tys.next() {\n-                print!(f, cx, print(ty))?;\n-                for &ty in tys {\n-                    print!(f, cx, write(\", \"), print(ty))?;\n-                }\n-            }\n-            write!(f, \"}}\")\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::TypeAndMut<'tcx>, (self, f, cx) {\n-        display {\n-            print!(f, cx,\n-                   write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n-                   print(self.ty))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::ExistentialTraitRef<'tcx>, (self, f, cx) {\n-        display {\n-            cx.parameterized(f, self.substs, self.def_id, &[])\n-        }\n-        debug {\n-            ty::tls::with(|tcx| {\n-                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-\n-                let trait_ref = *tcx.lift(&ty::Binder::bind(*self))\n-                                   .expect(\"could not lift TraitRef for printing\")\n-                                   .with_self_ty(tcx, dummy_self).skip_binder();\n-                cx.parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n-            })\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::adjustment::Adjustment<'tcx>, (self, f, cx) {\n-        debug {\n-            print!(f, cx, write(\"{:?} -> \", self.kind), print(self.target))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::BoundRegion, (self, f, cx) {\n-        display {\n-            if cx.is_verbose {\n-                return self.print_debug(f, cx);\n-            }\n-\n-            if let Some((region, counter)) = RegionHighlightMode::get().highlight_bound_region {\n-                if *self == region {\n-                    return match *self {\n-                        BrNamed(_, name) => write!(f, \"{}\", name),\n-                        BrAnon(_) | BrFresh(_) | BrEnv => write!(f, \"'{}\", counter)\n-                    };\n-                }\n-            }\n-\n-            match *self {\n-                BrNamed(_, name) => write!(f, \"{}\", name),\n-                BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n-            }\n-        }\n-        debug {\n-            return match *self {\n-                BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n-                BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n-                BrNamed(did, name) => {\n-                    write!(f, \"BrNamed({:?}:{:?}, {})\",\n-                           did.krate, did.index, name)\n-                }\n-                BrEnv => write!(f, \"BrEnv\"),\n-            };\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::PlaceholderRegion, (self, f, cx) {\n-        display {\n-            if cx.is_verbose {\n-                return self.print_debug(f, cx);\n-            }\n-\n-            let highlight = RegionHighlightMode::get();\n-            if let Some(counter) = highlight.placeholder_highlight(*self) {\n-                write!(f, \"'{}\", counter)\n-            } else if highlight.any_placeholders_highlighted() {\n-                write!(f, \"'_\")\n-            } else {\n-                write!(f, \"{}\", self.name)\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::RegionKind, (self, f, cx) {\n-        display {\n-            if cx.is_verbose {\n-                return self.print_debug(f, cx);\n-            }\n-\n-            // Watch out for region highlights.\n-            if let Some(n) = RegionHighlightMode::get().region_highlighted(self) {\n-                return write!(f, \"'{:?}\", n);\n-            }\n-\n-            // These printouts are concise.  They do not contain all the information\n-            // the user might want to diagnose an error, but there is basically no way\n-            // to fit that into a short string.  Hence the recommendation to use\n-            // `explain_region()` or `note_and_explain_region()`.\n-            match *self {\n-                ty::ReEarlyBound(ref data) => {\n-                    write!(f, \"{}\", data.name)\n-                }\n-                ty::ReLateBound(_, br) |\n-                ty::ReFree(ty::FreeRegion { bound_region: br, .. }) => {\n-                    write!(f, \"{}\", br)\n-                }\n-                ty::RePlaceholder(p) => {\n-                    write!(f, \"{}\", p)\n-                }\n-                ty::ReScope(scope) if cx.identify_regions => {\n-                    match scope.data {\n-                        region::ScopeData::Node =>\n-                            write!(f, \"'{}s\", scope.item_local_id().as_usize()),\n-                        region::ScopeData::CallSite =>\n-                            write!(f, \"'{}cs\", scope.item_local_id().as_usize()),\n-                        region::ScopeData::Arguments =>\n-                            write!(f, \"'{}as\", scope.item_local_id().as_usize()),\n-                        region::ScopeData::Destruction =>\n-                            write!(f, \"'{}ds\", scope.item_local_id().as_usize()),\n-                        region::ScopeData::Remainder(first_statement_index) => write!(\n-                            f,\n-                            \"'{}_{}rs\",\n-                            scope.item_local_id().as_usize(),\n-                            first_statement_index.index()\n-                        ),\n-                    }\n-                }\n-                ty::ReVar(region_vid) => {\n-                    if RegionHighlightMode::get().any_region_vids_highlighted() {\n-                        write!(f, \"{:?}\", region_vid)\n-                    } else if cx.identify_regions {\n-                        write!(f, \"'{}rv\", region_vid.index())\n-                    } else {\n-                        Ok(())\n-                    }\n-                }\n-                ty::ReScope(_) |\n-                ty::ReErased => Ok(()),\n-                ty::ReStatic => write!(f, \"'static\"),\n-                ty::ReEmpty => write!(f, \"'<empty>\"),\n-\n-                // The user should never encounter these in unsubstituted form.\n-                ty::ReClosureBound(vid) => write!(f, \"{:?}\", vid),\n-            }\n-        }\n-        debug {\n-            match *self {\n-                ty::ReEarlyBound(ref data) => {\n-                    write!(f, \"ReEarlyBound({}, {})\",\n-                           data.index,\n-                           data.name)\n-                }\n-\n-                ty::ReClosureBound(ref vid) => {\n-                    write!(f, \"ReClosureBound({:?})\",\n-                           vid)\n-                }\n-\n-                ty::ReLateBound(binder_id, ref bound_region) => {\n-                    write!(f, \"ReLateBound({:?}, {:?})\",\n-                           binder_id,\n-                           bound_region)\n-                }\n-\n-                ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n-\n-                ty::ReScope(id) => {\n-                    write!(f, \"ReScope({:?})\", id)\n-                }\n-\n-                ty::ReStatic => write!(f, \"ReStatic\"),\n-\n-                ty::ReVar(ref vid) => {\n-                    write!(f, \"{:?}\", vid)\n-                }\n-\n-                ty::RePlaceholder(placeholder) => {\n-                    write!(f, \"RePlaceholder({:?})\", placeholder)\n-                }\n-\n-                ty::ReEmpty => write!(f, \"ReEmpty\"),\n-\n-                ty::ReErased => write!(f, \"ReErased\")\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::FreeRegion, (self, f, cx) {\n-        debug {\n-            write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::Variance, (self, f, cx) {\n-        debug {\n-            f.write_str(match *self {\n-                ty::Covariant => \"+\",\n-                ty::Contravariant => \"-\",\n-                ty::Invariant => \"o\",\n-                ty::Bivariant => \"*\",\n-            })\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::GenericPredicates<'tcx>, (self, f, cx) {\n-        debug {\n-            write!(f, \"GenericPredicates({:?})\", self.predicates)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::InstantiatedPredicates<'tcx>, (self, f, cx) {\n-        debug {\n-            write!(f, \"InstantiatedPredicates({:?})\", self.predicates)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::FnSig<'tcx>, (self, f, cx) {\n-        display {\n-            if self.unsafety == hir::Unsafety::Unsafe {\n-                write!(f, \"unsafe \")?;\n-            }\n-\n-            if self.abi != Abi::Rust {\n-                write!(f, \"extern {} \", self.abi)?;\n-            }\n-\n-            write!(f, \"fn\")?;\n-            cx.fn_sig(f, self.inputs(), self.c_variadic, self.output())\n-        }\n-        debug {\n-            write!(f, \"({:?}; c_variadic: {})->{:?}\", self.inputs(), self.c_variadic, self.output())\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::TyVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}t\", self.index)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::ConstVid<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}f\", self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::IntVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}i\", self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::FloatVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}f\", self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::RegionVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if let Some(counter) = RegionHighlightMode::get().region_highlighted(&ty::ReVar(*self)) {\n-            return write!(f, \"'{:?}\", counter);\n-        } else if RegionHighlightMode::get().any_region_vids_highlighted() {\n-            return write!(f, \"'_\");\n-        }\n-\n-        write!(f, \"'_#{}r\", self.index())\n-    }\n-}\n-\n-define_print! {\n-    () ty::InferTy, (self, f, cx) {\n-        display {\n-            if cx.is_verbose {\n-                print!(f, cx, print_debug(self))\n-            } else {\n-                match *self {\n-                    ty::TyVar(_) => write!(f, \"_\"),\n-                    ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n-                    ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n-                    ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-                    ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n-                    ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n-                }\n-            }\n-        }\n-        debug {\n-            match *self {\n-                ty::TyVar(ref v) => write!(f, \"{:?}\", v),\n-                ty::IntVar(ref v) => write!(f, \"{:?}\", v),\n-                ty::FloatVar(ref v) => write!(f, \"{:?}\", v),\n-                ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n-                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n-                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::IntVarValue {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ty::IntType(ref v) => v.fmt(f),\n-            ty::UintType(ref v) => v.fmt(f),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::FloatVarValue {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n-// The generic impl doesn't work yet because projections are not\n-// normalized under HRTB.\n-/*impl<T> fmt::Display for ty::Binder<T>\n-    where T: fmt::Display + for<'a> ty::Lift<'a>,\n-          for<'a> <T as ty::Lift<'a>>::Lifted: fmt::Display + TypeFoldable<'a>\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}*/\n-\n-define_print_multi! {\n-    [\n-    ('tcx) ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n-    ('tcx) ty::Binder<ty::TraitRef<'tcx>>,\n-    ('tcx) ty::Binder<ty::FnSig<'tcx>>,\n-    ('tcx) ty::Binder<ty::TraitPredicate<'tcx>>,\n-    ('tcx) ty::Binder<ty::SubtypePredicate<'tcx>>,\n-    ('tcx) ty::Binder<ty::ProjectionPredicate<'tcx>>,\n-    ('tcx) ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n-    ('tcx) ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>\n-    ]\n-    (self, f, cx) {\n-        display {\n-            ty::tls::with(|tcx| cx.in_binder(f, tcx, self, tcx.lift(self)))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::TraitRef<'tcx>, (self, f, cx) {\n-        display {\n-            cx.parameterized(f, self.substs, self.def_id, &[])\n-        }\n-        debug {\n-            // when printing out the debug representation, we don't need\n-            // to enumerate the `for<...>` etc because the debruijn index\n-            // tells you everything you need to know.\n-            print!(f, cx,\n-                   write(\"<\"),\n-                   print(self.self_ty()),\n-                   write(\" as \"))?;\n-            cx.parameterized(f, self.substs, self.def_id, &[])?;\n-            write!(f, \">\")\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::TyKind<'tcx>, (self, f, cx) {\n-        display {\n-            match *self {\n-                Bool => write!(f, \"bool\"),\n-                Char => write!(f, \"char\"),\n-                Int(t) => write!(f, \"{}\", t.ty_to_string()),\n-                Uint(t) => write!(f, \"{}\", t.ty_to_string()),\n-                Float(t) => write!(f, \"{}\", t.ty_to_string()),\n-                RawPtr(ref tm) => {\n-                    write!(f, \"*{} \", match tm.mutbl {\n-                        hir::MutMutable => \"mut\",\n-                        hir::MutImmutable => \"const\",\n-                    })?;\n-                    tm.ty.print(f, cx)\n-                }\n-                Ref(r, ty, mutbl) => {\n-                    write!(f, \"&\")?;\n-                    let s = r.print_to_string(cx);\n-                    if s != \"'_\" {\n-                        write!(f, \"{}\", s)?;\n-                        if !s.is_empty() {\n-                            write!(f, \" \")?;\n-                        }\n-                    }\n-                    ty::TypeAndMut { ty, mutbl }.print(f, cx)\n-                }\n-                Never => write!(f, \"!\"),\n-                Tuple(ref tys) => {\n-                    write!(f, \"(\")?;\n-                    let mut tys = tys.iter();\n-                    if let Some(&ty) = tys.next() {\n-                        print!(f, cx, print(ty), write(\",\"))?;\n-                        if let Some(&ty) = tys.next() {\n-                            print!(f, cx, write(\" \"), print(ty))?;\n-                            for &ty in tys {\n-                                print!(f, cx, write(\", \"), print(ty))?;\n-                            }\n-                        }\n-                    }\n-                    write!(f, \")\")\n-                }\n-                FnDef(def_id, substs) => {\n-                    ty::tls::with(|tcx| {\n-                        let mut sig = tcx.fn_sig(def_id);\n-                        if let Some(substs) = tcx.lift(&substs) {\n-                            sig = sig.subst(tcx, substs);\n-                        }\n-                        print!(f, cx, print(sig), write(\" {{\"))\n-                    })?;\n-                    cx.parameterized(f, substs, def_id, &[])?;\n-                    write!(f, \"}}\")\n-                }\n-                FnPtr(ref bare_fn) => {\n-                    bare_fn.print(f, cx)\n-                }\n-                Infer(infer_ty) => write!(f, \"{}\", infer_ty),\n-                Error => write!(f, \"[type error]\"),\n-                Param(ref param_ty) => write!(f, \"{}\", param_ty),\n-                Bound(debruijn, bound_ty) => {\n-                    match bound_ty.kind {\n-                        ty::BoundTyKind::Anon => {\n-                            if debruijn == ty::INNERMOST {\n-                                write!(f, \"^{}\", bound_ty.var.index())\n-                            } else {\n-                                write!(f, \"^{}_{}\", debruijn.index(), bound_ty.var.index())\n-                            }\n-                        }\n-\n-                        ty::BoundTyKind::Param(p) => write!(f, \"{}\", p),\n-                    }\n-                }\n-                Adt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n-                Dynamic(data, r) => {\n-                    let r = r.print_to_string(cx);\n-                    if !r.is_empty() {\n-                        write!(f, \"(\")?;\n-                    }\n-                    write!(f, \"dyn \")?;\n-                    data.print(f, cx)?;\n-                    if !r.is_empty() {\n-                        write!(f, \" + {})\", r)\n-                    } else {\n-                        Ok(())\n-                    }\n-                }\n-                Foreign(def_id) => parameterized(f, subst::InternalSubsts::empty(), def_id, &[]),\n-                Projection(ref data) => data.print(f, cx),\n-                UnnormalizedProjection(ref data) => {\n-                    write!(f, \"Unnormalized(\")?;\n-                    data.print(f, cx)?;\n-                    write!(f, \")\")\n-                }\n-                Placeholder(placeholder) => {\n-                    write!(f, \"Placeholder({:?})\", placeholder)\n-                }\n-                Opaque(def_id, substs) => {\n-                    if cx.is_verbose {\n-                        return write!(f, \"Opaque({:?}, {:?})\", def_id, substs);\n-                    }\n-\n-                    ty::tls::with(|tcx| {\n-                        let def_key = tcx.def_key(def_id);\n-                        if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                            write!(f, \"{}\", name)?;\n-                            let mut substs = substs.iter();\n-                            if let Some(first) = substs.next() {\n-                                write!(f, \"::<\")?;\n-                                write!(f, \"{}\", first)?;\n-                                for subst in substs {\n-                                    write!(f, \", {}\", subst)?;\n-                                }\n-                                write!(f, \">\")?;\n-                            }\n-                            return Ok(());\n-                        }\n-                        // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                        // by looking up the projections associated with the def_id.\n-                        let predicates_of = tcx.predicates_of(def_id);\n-                        let substs = tcx.lift(&substs).unwrap_or_else(|| {\n-                            tcx.intern_substs(&[])\n-                        });\n-                        let bounds = predicates_of.instantiate(tcx, substs);\n-\n-                        let mut first = true;\n-                        let mut is_sized = false;\n-                        write!(f, \"impl\")?;\n-                        for predicate in bounds.predicates {\n-                            if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                                // Don't print +Sized, but rather +?Sized if absent.\n-                                if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n-                                    is_sized = true;\n-                                    continue;\n-                                }\n-\n-                                print!(f, cx,\n-                                       write(\"{}\", if first { \" \" } else { \"+\" }),\n-                                       print(trait_ref))?;\n-                                first = false;\n-                            }\n-                        }\n-                        if !is_sized {\n-                            write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n-                        } else if first {\n-                            write!(f, \" Sized\")?;\n-                        }\n-                        Ok(())\n-                    })\n-                }\n-                Str => write!(f, \"str\"),\n-                Generator(did, substs, movability) => ty::tls::with(|tcx| {\n-                    let upvar_tys = substs.upvar_tys(did, tcx);\n-                    let witness = substs.witness(did, tcx);\n-                    if movability == hir::GeneratorMovability::Movable {\n-                        write!(f, \"[generator\")?;\n-                    } else {\n-                        write!(f, \"[static generator\")?;\n-                    }\n-\n-                    if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-                        write!(f, \"@{:?}\", tcx.hir().span_by_hir_id(hir_id))?;\n-                        let mut sep = \" \";\n-                        tcx.with_freevars(hir_id, |freevars| {\n-                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                                print!(f, cx,\n-                                       write(\"{}{}:\",\n-                                             sep,\n-                                             tcx.hir().name(freevar.var_id())),\n-                                       print(upvar_ty))?;\n-                                sep = \", \";\n-                            }\n-                            Ok(())\n-                        })?\n-                    } else {\n-                        // cross-crate closure types should only be\n-                        // visible in codegen bug reports, I imagine.\n-                        write!(f, \"@{:?}\", did)?;\n-                        let mut sep = \" \";\n-                        for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            print!(f, cx,\n-                                   write(\"{}{}:\", sep, index),\n-                                   print(upvar_ty))?;\n-                            sep = \", \";\n-                        }\n-                    }\n-\n-                    print!(f, cx, write(\" \"), print(witness), write(\"]\"))\n-                }),\n-                GeneratorWitness(types) => {\n-                    ty::tls::with(|tcx| cx.in_binder(f, tcx, &types, tcx.lift(&types)))\n-                }\n-                Closure(did, substs) => ty::tls::with(|tcx| {\n-                    let upvar_tys = substs.upvar_tys(did, tcx);\n-                    write!(f, \"[closure\")?;\n-\n-                    if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-                        if tcx.sess.opts.debugging_opts.span_free_formats {\n-                            write!(f, \"@{:?}\", hir_id)?;\n-                        } else {\n-                            write!(f, \"@{:?}\", tcx.hir().span_by_hir_id(hir_id))?;\n-                        }\n-                        let mut sep = \" \";\n-                        tcx.with_freevars(hir_id, |freevars| {\n-                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                                print!(f, cx,\n-                                       write(\"{}{}:\",\n-                                             sep,\n-                                             tcx.hir().name(freevar.var_id())),\n-                                       print(upvar_ty))?;\n-                                sep = \", \";\n-                            }\n-                            Ok(())\n-                        })?\n-                    } else {\n-                        // cross-crate closure types should only be\n-                        // visible in codegen bug reports, I imagine.\n-                        write!(f, \"@{:?}\", did)?;\n-                        let mut sep = \" \";\n-                        for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            print!(f, cx,\n-                                   write(\"{}{}:\", sep, index),\n-                                   print(upvar_ty))?;\n-                            sep = \", \";\n-                        }\n-                    }\n-\n-                    if cx.is_verbose {\n-                        write!(\n-                            f,\n-                            \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n-                            substs.closure_kind_ty(did, tcx),\n-                            substs.closure_sig_ty(did, tcx),\n-                        )?;\n-                    }\n-\n-                    write!(f, \"]\")\n-                }),\n-                Array(ty, sz) => {\n-                    print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n-                    match sz {\n-                        ty::LazyConst::Unevaluated(_def_id, _substs) => {\n-                            write!(f, \"_\")?;\n-                        }\n-                        ty::LazyConst::Evaluated(c) => ty::tls::with(|tcx| {\n-                            match c.val {\n-                                ConstValue::Infer(..) => write!(f, \"_\"),\n-                                ConstValue::Param(ParamConst { name, .. }) =>\n-                                    write!(f, \"{}\", name),\n-                                _ => write!(f, \"{}\", c.unwrap_usize(tcx)),\n-                            }\n-                        })?,\n-                    }\n-                    write!(f, \"]\")\n-                }\n-                Slice(ty) => {\n-                    print!(f, cx, write(\"[\"), print(ty), write(\"]\"))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::TyS<'tcx>, (self, f, cx) {\n-        display {\n-            self.sty.print(f, cx)\n-        }\n-        debug {\n-            self.sty.print_display(f, cx)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ConstValue<'tcx>, (self, f, cx) {\n-        display {\n-            match self {\n-                ConstValue::Infer(..) => write!(f, \"_\"),\n-                ConstValue::Param(ParamConst { name, .. }) => write!(f, \"{}\", name),\n-                _ => write!(f, \"{:?}\", self),\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::Const<'tcx>, (self, f, cx) {\n-        display {\n-            write!(f, \"{} : {}\", self.val, self.ty)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::LazyConst<'tcx>, (self, f, cx) {\n-        display {\n-            match self {\n-                ty::LazyConst::Unevaluated(..) => write!(f, \"_ : _\"),\n-                ty::LazyConst::Evaluated(c) => write!(f, \"{}\", c),\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::ParamTy, (self, f, cx) {\n-        display {\n-            write!(f, \"{}\", self.name)\n-        }\n-        debug {\n-            write!(f, \"{}/#{}\", self.name, self.idx)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::ParamConst, (self, f, cx) {\n-        display {\n-            write!(f, \"{}\", self.name)\n-        }\n-        debug {\n-            write!(f, \"{}/#{}\", self.name, self.index)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx, T: Print + fmt::Debug, U: Print + fmt::Debug) ty::OutlivesPredicate<T, U>,\n-    (self, f, cx) {\n-        display {\n-            print!(f, cx, print(self.0), write(\" : \"), print(self.1))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::SubtypePredicate<'tcx>, (self, f, cx) {\n-        display {\n-            print!(f, cx, print(self.a), write(\" <: \"), print(self.b))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::TraitPredicate<'tcx>, (self, f, cx) {\n-        debug {\n-            write!(f, \"TraitPredicate({:?})\",\n-                   self.trait_ref)\n-        }\n-        display {\n-            print!(f, cx, print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::ProjectionPredicate<'tcx>, (self, f, cx) {\n-        debug {\n-            print!(f, cx,\n-                   write(\"ProjectionPredicate(\"),\n-                   print(self.projection_ty),\n-                   write(\", \"),\n-                   print(self.ty),\n-                   write(\")\"))\n-        }\n-        display {\n-            print!(f, cx, print(self.projection_ty), write(\" == \"), print(self.ty))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::ProjectionTy<'tcx>, (self, f, cx) {\n-        display {\n-            // FIXME(tschottdorf): use something like\n-            //   parameterized(f, self.substs, self.item_def_id, &[])\n-            // (which currently ICEs).\n-            let (trait_ref, item_name) = ty::tls::with(|tcx|\n-                (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).ident)\n-            );\n-            print!(f, cx, print_debug(trait_ref), write(\"::{}\", item_name))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::ClosureKind, (self, f, cx) {\n-        display {\n-            match *self {\n-                ty::ClosureKind::Fn => write!(f, \"Fn\"),\n-                ty::ClosureKind::FnMut => write!(f, \"FnMut\"),\n-                ty::ClosureKind::FnOnce => write!(f, \"FnOnce\"),\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::Predicate<'tcx>, (self, f, cx) {\n-        display {\n-            match *self {\n-                ty::Predicate::Trait(ref data) => data.print(f, cx),\n-                ty::Predicate::Subtype(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::RegionOutlives(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::TypeOutlives(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::Projection(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::WellFormed(ty) => print!(f, cx, print(ty), write(\" well-formed\")),\n-                ty::Predicate::ObjectSafe(trait_def_id) =>\n-                    ty::tls::with(|tcx| {\n-                        write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n-                    }),\n-                ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) =>\n-                    ty::tls::with(|tcx| {\n-                        write!(f, \"the closure `{}` implements the trait `{}`\",\n-                               tcx.item_path_str(closure_def_id), kind)\n-                    }),\n-                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                    write!(f, \"the constant `\")?;\n-                    cx.parameterized(f, substs, def_id, &[])?;\n-                    write!(f, \"` can be evaluated\")\n-                }\n-            }\n-        }\n-        debug {\n-            match *self {\n-                ty::Predicate::Trait(ref a) => a.print(f, cx),\n-                ty::Predicate::Subtype(ref pair) => pair.print(f, cx),\n-                ty::Predicate::RegionOutlives(ref pair) => pair.print(f, cx),\n-                ty::Predicate::TypeOutlives(ref pair) => pair.print(f, cx),\n-                ty::Predicate::Projection(ref pair) => pair.print(f, cx),\n-                ty::Predicate::WellFormed(ty) => ty.print(f, cx),\n-                ty::Predicate::ObjectSafe(trait_def_id) => {\n-                    write!(f, \"ObjectSafe({:?})\", trait_def_id)\n-                }\n-                ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                    write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n-                }\n-                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                    write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "01bfe5d5af70697e5bb902df86122675247c5565", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1406,7 +1406,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_loan_path_to_string(&lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&self.tcx.item_path_str(variant_def_id));\n+                out.push_str(&self.tcx.def_path_str(variant_def_id));\n                 out.push(')');\n             }\n \n@@ -1443,7 +1443,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&self.tcx.item_path_str(variant_def_id));\n+                out.push_str(&self.tcx.def_path_str(variant_def_id));\n                 out.push(')');\n             }\n \n@@ -1523,7 +1523,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.is_local() {\n-                    ty::tls::with(|tcx| tcx.item_path_str(variant_def_id))\n+                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n                 } else {\n                     format!(\"{:?}\", variant_def_id)\n                 };\n@@ -1558,7 +1558,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.is_local() {\n-                    ty::tls::with(|tcx| tcx.item_path_str(variant_def_id))\n+                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n                 } else {\n                     format!(\"{:?}\", variant_def_id)\n                 };"}, {"sha": "ceb08f943678b15a97aa5273effc4741dd962229", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -513,8 +513,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n             },\n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n-                let sty = &arg_tys[0].sty;\n-                match float_type_width(sty) {\n+                match float_type_width(arg_tys[0]) {\n                     Some(_width) =>\n                         match name {\n                             \"fadd_fast\" => self.fadd_fast(args[0].immediate(), args[1].immediate()),\n@@ -528,7 +527,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         span_invalid_monomorphization_error(\n                             tcx.sess, span,\n                             &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic float type, found `{}`\", name, sty));\n+                                      expected basic float type, found `{}`\", name, arg_tys[0]));\n                         return;\n                     }\n                 }\n@@ -1473,8 +1472,8 @@ fn generic_simd_intrinsic(\n                 require!(false, \"expected element type `{}` of second argument `{}` \\\n                                  to be a pointer to the element type `{}` of the first \\\n                                  argument `{}`, found `{}` != `*_ {}`\",\n-                         arg_tys[1].simd_type(tcx).sty, arg_tys[1], in_elem, in_ty,\n-                         arg_tys[1].simd_type(tcx).sty, in_elem);\n+                         arg_tys[1].simd_type(tcx), arg_tys[1], in_elem, in_ty,\n+                         arg_tys[1].simd_type(tcx), in_elem);\n                 unreachable!();\n             }\n         };\n@@ -1488,7 +1487,7 @@ fn generic_simd_intrinsic(\n             _ => {\n                 require!(false, \"expected element type `{}` of third argument `{}` \\\n                                  to be a signed integer type\",\n-                         arg_tys[2].simd_type(tcx).sty, arg_tys[2]);\n+                         arg_tys[2].simd_type(tcx), arg_tys[2]);\n             }\n         }\n \n@@ -1573,8 +1572,8 @@ fn generic_simd_intrinsic(\n                 require!(false, \"expected element type `{}` of second argument `{}` \\\n                                  to be a pointer to the element type `{}` of the first \\\n                                  argument `{}`, found `{}` != `*mut {}`\",\n-                         arg_tys[1].simd_type(tcx).sty, arg_tys[1], in_elem, in_ty,\n-                         arg_tys[1].simd_type(tcx).sty, in_elem);\n+                         arg_tys[1].simd_type(tcx), arg_tys[1], in_elem, in_ty,\n+                         arg_tys[1].simd_type(tcx), in_elem);\n                 unreachable!();\n             }\n         };\n@@ -1588,7 +1587,7 @@ fn generic_simd_intrinsic(\n             _ => {\n                 require!(false, \"expected element type `{}` of third argument `{}` \\\n                                  to be a signed integer type\",\n-                         arg_tys[2].simd_type(tcx).sty, arg_tys[2]);\n+                         arg_tys[2].simd_type(tcx), arg_tys[2]);\n             }\n         }\n \n@@ -1904,7 +1903,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                 return_error!(\n                     \"expected element type `{}` of vector type `{}` \\\n                      to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_type(tcx).sty, arg_tys[0]\n+                    arg_tys[0].simd_type(tcx), arg_tys[0]\n                 );\n             }\n         };\n@@ -1954,10 +1953,10 @@ fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, boo\n     }\n }\n \n-// Returns the width of a float TypeVariant\n+// Returns the width of a float Ty\n // Returns None if the type is not a float\n-fn float_type_width<'tcx>(sty: &ty::TyKind<'tcx>) -> Option<u64> {\n-    match *sty {\n+fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n+    match ty.sty {\n         ty::Float(t) => Some(t.bit_width() as u64),\n         _ => None,\n     }"}, {"sha": "2bb68dc687ca9c849661450dabc8eb91eba5e215", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let field_ty = c.ty.builtin_index().unwrap();\n                 let fields = match c.ty.sty {\n                     ty::Array(_, n) => n.unwrap_usize(bx.tcx()),\n-                    ref other => bug!(\"invalid simd shuffle type: {}\", other),\n+                    _ => bug!(\"invalid simd shuffle type: {}\", c.ty),\n                 };\n                 let values: Vec<_> = (0..fields).map(|field| {\n                     let field = const_field("}, {"sha": "fe00276a55a45f25ae7064ea417f45f7cc7d071b", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -148,7 +148,7 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n         match tail.sty {\n             ty::Foreign(..) => false,\n             ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n-            _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n+            _ => bug!(\"unexpected unsized tail: {:?}\", tail),\n         }\n     }\n }"}, {"sha": "466cf40a15795b85bb4376764bf0cc69031b3a3a", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -4,6 +4,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(custom_attribute)]"}, {"sha": "0fa935199f97b412e2d9125121b73e6c1d39495f", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 277, "deletions": 87, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -87,14 +87,14 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n-use rustc::hir::map::definitions::DefPathData;\n+use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n+use rustc::ty::print::{PrettyPrinter, Printer, Print};\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::SubstsRef;\n+use rustc::ty::subst::{Kind, SubstsRef, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::record_time;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -105,8 +105,8 @@ use syntax_pos::symbol::Symbol;\n \n use log::debug;\n \n-use std::fmt::Write;\n-use std::mem::discriminant;\n+use std::fmt::{self, Write};\n+use std::mem::{self, discriminant};\n \n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n@@ -223,11 +223,11 @@ fn get_symbol_hash<'a, 'tcx>(\n }\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n-    let mut buffer = SymbolPathBuffer::new(tcx);\n-    item_path::with_forced_absolute_paths(|| {\n-        tcx.push_item_path(&mut buffer, def_id, false);\n-    });\n-    buffer.into_interned()\n+    SymbolPrinter {\n+        tcx,\n+        path: SymbolPath::new(),\n+        keep_within_component: false,\n+    }.print_def_path(def_id, &[]).unwrap().path.into_interned()\n }\n \n fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n@@ -319,13 +319,17 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     let hash = get_symbol_hash(tcx, def_id, instance, instance_ty, substs);\n \n-    let mut buf = SymbolPathBuffer::from_interned(tcx.def_symbol_name(def_id), tcx);\n+    let mut printer = SymbolPrinter {\n+        tcx,\n+        path: SymbolPath::from_interned(tcx.def_symbol_name(def_id)),\n+        keep_within_component: false,\n+    };\n \n     if instance.is_vtable_shim() {\n-        buf.push(\"{{vtable-shim}}\");\n+        let _ = printer.write_str(\"{{vtable-shim}}\");\n     }\n \n-    buf.finish(hash)\n+    printer.path.finish(hash)\n }\n \n // Follow C++ namespace-mangling style, see\n@@ -342,126 +346,312 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n // To be able to work on all platforms and get *some* reasonable output, we\n // use C++ name-mangling.\n #[derive(Debug)]\n-struct SymbolPathBuffer {\n+struct SymbolPath {\n     result: String,\n     temp_buf: String,\n-    strict_naming: bool,\n }\n \n-impl SymbolPathBuffer {\n-    fn new(tcx: TyCtxt<'_, '_, '_>) -> Self {\n-        let mut result = SymbolPathBuffer {\n+impl SymbolPath {\n+    fn new() -> Self {\n+        let mut result = SymbolPath {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n-            strict_naming: tcx.has_strict_asm_symbol_naming(),\n         };\n         result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n         result\n     }\n \n-    fn from_interned(symbol: ty::SymbolName, tcx: TyCtxt<'_, '_, '_>) -> Self {\n-        let mut result = SymbolPathBuffer {\n+    fn from_interned(symbol: ty::SymbolName) -> Self {\n+        let mut result = SymbolPath {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n-            strict_naming: tcx.has_strict_asm_symbol_naming(),\n         };\n         result.result.push_str(&symbol.as_str());\n         result\n     }\n \n-    fn into_interned(self) -> ty::SymbolName {\n+    fn into_interned(mut self) -> ty::SymbolName {\n+        self.finalize_pending_component();\n         ty::SymbolName {\n             name: Symbol::intern(&self.result).as_interned_str(),\n         }\n     }\n \n+    fn finalize_pending_component(&mut self) {\n+        if !self.temp_buf.is_empty() {\n+            let _ = write!(self.result, \"{}{}\", self.temp_buf.len(), self.temp_buf);\n+            self.temp_buf.clear();\n+        }\n+    }\n+\n     fn finish(mut self, hash: u64) -> String {\n+        self.finalize_pending_component();\n         // E = end name-sequence\n         let _ = write!(self.result, \"17h{:016x}E\", hash);\n         self.result\n     }\n+}\n+\n+struct SymbolPrinter<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    path: SymbolPath,\n+\n+    // When `true`, `finalize_pending_component` isn't used.\n+    // This is needed when recursing into `path_qualified`,\n+    // or `path_generic_args`, as any nested paths are\n+    // logically within one component.\n+    keep_within_component: bool,\n+}\n \n-    // Name sanitation. LLVM will happily accept identifiers with weird names, but\n-    // gas doesn't!\n-    // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-    // NVPTX assembly has more strict naming rules than gas, so additionally, dots\n-    // are replaced with '$' there.\n-    fn sanitize_and_append(&mut self, s: &str) {\n-        self.temp_buf.clear();\n+// HACK(eddyb) this relies on using the `fmt` interface to get\n+// `PrettyPrinter` aka pretty printing of e.g. types in paths,\n+// symbol names should have their own printing machinery.\n+\n+impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+    type Error = fmt::Error;\n+\n+    type Path = Self;\n+    type Region = Self;\n+    type Type = Self;\n+    type DynExistential = Self;\n+\n+    fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn print_region(\n+        self,\n+        _region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        Ok(self)\n+    }\n+\n+    fn print_type(\n+        self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        match ty.sty {\n+            // Print all nominal types as paths (unlike `pretty_print_type`).\n+            ty::FnDef(def_id, substs) |\n+            ty::Opaque(def_id, substs) |\n+            ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n+            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n+                self.print_def_path(def_id, substs)\n+            }\n+            _ => self.pretty_print_type(ty),\n+        }\n+    }\n+\n+    fn print_dyn_existential(\n+        mut self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        let mut first = false;\n+        for p in predicates {\n+            if !first {\n+                write!(self, \"+\")?;\n+            }\n+            first = false;\n+            self = p.print(self)?;\n+        }\n+        Ok(self)\n+    }\n+\n+    fn path_crate(\n+        mut self,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n+        Ok(self)\n+    }\n+    fn path_qualified(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        // Similar to `pretty_path_qualified`, but for the other\n+        // types that are printed as paths (see `print_type` above).\n+        match self_ty.sty {\n+            ty::FnDef(..) |\n+            ty::Opaque(..) |\n+            ty::Projection(_) |\n+            ty::UnnormalizedProjection(_) |\n+            ty::Closure(..) |\n+            ty::Generator(..)\n+                if trait_ref.is_none() =>\n+            {\n+                self.print_type(self_ty)\n+            }\n+\n+            _ => self.pretty_path_qualified(self_ty, trait_ref)\n+        }\n+    }\n+\n+    fn path_append_impl(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.pretty_path_append_impl(\n+            |mut cx| {\n+                cx = print_prefix(cx)?;\n+\n+                if cx.keep_within_component {\n+                    // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n+                    cx.write_str(\"::\")?;\n+                } else {\n+                    cx.path.finalize_pending_component();\n+                }\n+\n+                Ok(cx)\n+            },\n+            self_ty,\n+            trait_ref,\n+        )\n+    }\n+    fn path_append(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        // Skip `::{{constructor}}` on tuple/unit structs.\n+        match disambiguated_data.data {\n+            DefPathData::StructCtor => return Ok(self),\n+            _ => {}\n+        }\n+\n+        if self.keep_within_component {\n+            // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n+            self.write_str(\"::\")?;\n+        } else {\n+            self.path.finalize_pending_component();\n+        }\n+\n+        self.write_str(&disambiguated_data.data.as_interned_str().as_str())?;\n+        Ok(self)\n+    }\n+    fn path_generic_args(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        args: &[Kind<'tcx>],\n+    )  -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        let args = args.iter().cloned().filter(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(_) => false,\n+                _ => true,\n+            }\n+        });\n+\n+        if args.clone().next().is_some() {\n+            self.generic_delimiters(|cx| cx.comma_sep(args))\n+        } else {\n+            Ok(self)\n+        }\n+    }\n+}\n+\n+impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+    fn region_should_not_be_omitted(\n+        &self,\n+        _region: ty::Region<'_>,\n+    ) -> bool {\n+        false\n+    }\n+    fn comma_sep<T>(\n+        mut self,\n+        mut elems: impl Iterator<Item = T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'tcx, 'tcx, Self, Output = Self, Error = Self::Error>\n+    {\n+        if let Some(first) = elems.next() {\n+            self = first.print(self)?;\n+            for elem in elems {\n+                self.write_str(\",\")?;\n+                self = elem.print(self)?;\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn generic_delimiters(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error> {\n+        write!(self, \"<\")?;\n+\n+        let kept_within_component =\n+            mem::replace(&mut self.keep_within_component, true);\n+        self = f(self)?;\n+        self.keep_within_component = kept_within_component;\n+\n+        write!(self, \">\")?;\n+\n+        Ok(self)\n+    }\n+}\n+\n+impl fmt::Write for SymbolPrinter<'_, '_> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        // Name sanitation. LLVM will happily accept identifiers with weird names, but\n+        // gas doesn't!\n+        // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n+        // NVPTX assembly has more strict naming rules than gas, so additionally, dots\n+        // are replaced with '$' there.\n \n         for c in s.chars() {\n+            if self.path.temp_buf.is_empty() {\n+                match c {\n+                    'a'..='z' | 'A'..='Z' | '_' => {}\n+                    _ => {\n+                        // Underscore-qualify anything that didn't start as an ident.\n+                        self.path.temp_buf.push('_');\n+                    }\n+                }\n+            }\n             match c {\n                 // Escape these with $ sequences\n-                '@' => self.temp_buf.push_str(\"$SP$\"),\n-                '*' => self.temp_buf.push_str(\"$BP$\"),\n-                '&' => self.temp_buf.push_str(\"$RF$\"),\n-                '<' => self.temp_buf.push_str(\"$LT$\"),\n-                '>' => self.temp_buf.push_str(\"$GT$\"),\n-                '(' => self.temp_buf.push_str(\"$LP$\"),\n-                ')' => self.temp_buf.push_str(\"$RP$\"),\n-                ',' => self.temp_buf.push_str(\"$C$\"),\n-\n-                '-' | ':' => if self.strict_naming {\n+                '@' => self.path.temp_buf.push_str(\"$SP$\"),\n+                '*' => self.path.temp_buf.push_str(\"$BP$\"),\n+                '&' => self.path.temp_buf.push_str(\"$RF$\"),\n+                '<' => self.path.temp_buf.push_str(\"$LT$\"),\n+                '>' => self.path.temp_buf.push_str(\"$GT$\"),\n+                '(' => self.path.temp_buf.push_str(\"$LP$\"),\n+                ')' => self.path.temp_buf.push_str(\"$RP$\"),\n+                ',' => self.path.temp_buf.push_str(\"$C$\"),\n+\n+                '-' | ':' | '.' if self.tcx.has_strict_asm_symbol_naming() => {\n                     // NVPTX doesn't support these characters in symbol names.\n-                    self.temp_buf.push('$')\n-                }\n-                else {\n-                    // '.' doesn't occur in types and functions, so reuse it\n-                    // for ':' and '-'\n-                    self.temp_buf.push('.')\n-                },\n-\n-                '.' => if self.strict_naming {\n-                    self.temp_buf.push('$')\n+                    self.path.temp_buf.push('$')\n                 }\n-                else {\n-                    self.temp_buf.push('.')\n-                },\n+\n+                // '.' doesn't occur in types and functions, so reuse it\n+                // for ':' and '-'\n+                '-' | ':' => self.path.temp_buf.push('.'),\n \n                 // These are legal symbols\n-                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '$' => self.temp_buf.push(c),\n+                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => self.path.temp_buf.push(c),\n \n                 _ => {\n-                    self.temp_buf.push('$');\n+                    self.path.temp_buf.push('$');\n                     for c in c.escape_unicode().skip(1) {\n                         match c {\n                             '{' => {}\n-                            '}' => self.temp_buf.push('$'),\n-                            c => self.temp_buf.push(c),\n+                            '}' => self.path.temp_buf.push('$'),\n+                            c => self.path.temp_buf.push(c),\n                         }\n                     }\n                 }\n             }\n         }\n \n-        let need_underscore = {\n-            // Underscore-qualify anything that didn't start as an ident.\n-            !self.temp_buf.is_empty()\n-                && self.temp_buf.as_bytes()[0] != '_' as u8\n-                && !(self.temp_buf.as_bytes()[0] as char).is_xid_start()\n-        };\n-\n-        let _ = write!(\n-            self.result,\n-            \"{}\",\n-            self.temp_buf.len() + (need_underscore as usize)\n-        );\n-\n-        if need_underscore {\n-            self.result.push('_');\n-        }\n-\n-        self.result.push_str(&self.temp_buf);\n-    }\n-}\n-\n-impl ItemPathBuffer for SymbolPathBuffer {\n-    fn root_mode(&self) -> &RootMode {\n-        const ABSOLUTE: &RootMode = &RootMode::Absolute;\n-        ABSOLUTE\n-    }\n-\n-    fn push(&mut self, text: &str) {\n-        self.sanitize_and_append(text);\n+        Ok(())\n     }\n }"}, {"sha": "6a2b6f1321b88a9420fed6add0f5e1965b7686d1", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,7 +1,7 @@\n //! Walks the crate looking for items/impl-items/trait-items that have\n-//! either a `rustc_symbol_name` or `rustc_item_path` attribute and\n+//! either a `rustc_symbol_name` or `rustc_def_path` attribute and\n //! generates an error giving, respectively, the symbol name or\n-//! item-path. This is used for unit testing the code that generates\n+//! def-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n use rustc::hir;\n@@ -10,7 +10,7 @@ use rustc::ty::TyCtxt;\n use rustc_mir::monomorphize::Instance;\n \n const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n-const ITEM_PATH: &'static str = \"rustc_item_path\";\n+const DEF_PATH: &'static str = \"rustc_def_path\";\n \n pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the\n@@ -41,9 +41,9 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n                 let instance = Instance::mono(tcx, def_id);\n                 let name = self.tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n-            } else if attr.check_name(ITEM_PATH) {\n-                let path = tcx.item_path_str(def_id);\n-                tcx.sess.span_err(attr.span, &format!(\"item-path({})\", path));\n+            } else if attr.check_name(DEF_PATH) {\n+                let path = tcx.def_path_str(def_id);\n+                tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n             }\n \n             // (*) The formatting of `tag({})` is chosen so that tests can elect"}, {"sha": "dde88a212408deee9f443ca006401849f905f1d0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -471,7 +471,7 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n     }\n \n     fn node_path(&self, id: ast::NodeId) -> Option<String> {\n-        Some(self.tcx.node_path_str(id))\n+        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id(id)))\n     }\n }\n "}, {"sha": "9fe9a60b9aaa97885d12779d62c1019b23347d49", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -206,7 +206,7 @@ fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tcx.sess.span_err(\n                     target_span,\n                     &format!(\"no path from `{}` to `{}`\",\n-                             tcx.item_path_str(source_def_id),\n+                             tcx.def_path_str(source_def_id),\n                              target_pass));\n             } else {\n                 tcx.sess.span_err("}, {"sha": "633e61a0034ab075c7a179edbb11143ccc2db429", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -463,7 +463,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         if let Some(def_id) = dep_node.extract_def_id(self.tcx) {\n             format!(\"{:?}({})\",\n                     dep_node.kind,\n-                    self.tcx.item_path_str(def_id))\n+                    self.tcx.def_path_str(def_id))\n         } else {\n             format!(\"{:?}({:?})\", dep_node.kind, dep_node.hash)\n         }"}, {"sha": "7d61547527f76d6f8953652963b6720c311b8237", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n                 if attr.check_name(\"must_use\") {\n                     let msg = format!(\"unused {}`{}`{} that must be used\",\n-                        descr_pre_path, cx.tcx.item_path_str(def_id), descr_post_path);\n+                        descr_pre_path, cx.tcx.def_path_str(def_id), descr_post_path);\n                     let mut err = cx.struct_span_lint(UNUSED_MUST_USE, sp, &msg);\n                     // check for #[must_use = \"...\"]\n                     if let Some(note) = attr.value_str() {"}, {"sha": "861346473245729c3ad44b1b800b56de8d4edc99", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 45, "deletions": 26, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -3,6 +3,7 @@ use crate::borrow_check::nll::region_infer::{RegionName, RegionNameSource};\n use crate::borrow_check::prefixes::IsPrefixOf;\n use crate::borrow_check::WriteKind;\n use rustc::hir;\n+use rustc::hir::def::Namespace;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::{\n@@ -12,7 +13,7 @@ use rustc::mir::{\n     TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, DefIdTree};\n-use rustc::util::ppaux::RegionHighlightMode;\n+use rustc::ty::print::Print;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n@@ -831,7 +832,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         if let Some(annotation) = self.annotate_argument_and_return_for_borrow(borrow) {\n-            let region_name = annotation.emit(&mut err);\n+            let region_name = annotation.emit(self, &mut err);\n \n             err.span_label(\n                 borrow_span,\n@@ -1799,7 +1800,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // (https://github.com/rust-lang/rfcs/pull/1546)\n                     bug!(\n                         \"End-user description not implemented for field access on `{:?}`\",\n-                        ty.sty\n+                        ty\n                     );\n                 }\n             }\n@@ -1875,7 +1876,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn annotate_argument_and_return_for_borrow(\n         &self,\n         borrow: &BorrowData<'tcx>,\n-    ) -> Option<AnnotatedBorrowFnSignature<'_>> {\n+    ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         // Define a fallback for when we can't match a closure.\n         let fallback = || {\n             let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n@@ -2099,7 +2100,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         did: DefId,\n         sig: ty::PolyFnSig<'tcx>,\n-    ) -> Option<AnnotatedBorrowFnSignature<'_>> {\n+    ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n         let is_closure = self.infcx.tcx.is_closure(did);\n         let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did)?;\n@@ -2245,29 +2246,33 @@ enum AnnotatedBorrowFnSignature<'tcx> {\n impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     /// Annotate the provided diagnostic with information about borrow from the fn signature that\n     /// helps explain.\n-    fn emit(&self, diag: &mut DiagnosticBuilder<'_>) -> String {\n+    fn emit(\n+        &self,\n+        cx: &mut MirBorrowckCtxt<'_, '_, 'tcx>,\n+        diag: &mut DiagnosticBuilder<'_>,\n+    ) -> String {\n         match self {\n             AnnotatedBorrowFnSignature::Closure {\n                 argument_ty,\n                 argument_span,\n             } => {\n                 diag.span_label(\n                     *argument_span,\n-                    format!(\"has type `{}`\", self.get_name_for_ty(argument_ty, 0)),\n+                    format!(\"has type `{}`\", cx.get_name_for_ty(argument_ty, 0)),\n                 );\n \n-                self.get_region_name_for_ty(argument_ty, 0)\n+                cx.get_region_name_for_ty(argument_ty, 0)\n             }\n             AnnotatedBorrowFnSignature::AnonymousFunction {\n                 argument_ty,\n                 argument_span,\n                 return_ty,\n                 return_span,\n             } => {\n-                let argument_ty_name = self.get_name_for_ty(argument_ty, 0);\n+                let argument_ty_name = cx.get_name_for_ty(argument_ty, 0);\n                 diag.span_label(*argument_span, format!(\"has type `{}`\", argument_ty_name));\n \n-                let return_ty_name = self.get_name_for_ty(return_ty, 0);\n+                let return_ty_name = cx.get_name_for_ty(return_ty, 0);\n                 let types_equal = return_ty_name == argument_ty_name;\n                 diag.span_label(\n                     *return_span,\n@@ -2286,15 +2291,15 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                      lifetime-syntax.html#lifetime-elision>\",\n                 );\n \n-                self.get_region_name_for_ty(return_ty, 0)\n+                cx.get_region_name_for_ty(return_ty, 0)\n             }\n             AnnotatedBorrowFnSignature::NamedFunction {\n                 arguments,\n                 return_ty,\n                 return_span,\n             } => {\n                 // Region of return type and arguments checked to be the same earlier.\n-                let region_name = self.get_region_name_for_ty(return_ty, 0);\n+                let region_name = cx.get_region_name_for_ty(return_ty, 0);\n                 for (_, argument_span) in arguments {\n                     diag.span_label(*argument_span, format!(\"has lifetime `{}`\", region_name));\n                 }\n@@ -2314,10 +2319,15 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n             }\n         }\n     }\n+}\n \n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Return the name of the provided `Ty` (that must be a reference) with a synthesized lifetime\n     /// name where required.\n     fn get_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n+        let mut s = String::new();\n+        let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n+\n         // We need to add synthesized lifetimes where appropriate. We do\n         // this by hooking into the pretty printer and telling it to label the\n         // lifetimes without names with the value `'0`.\n@@ -2327,28 +2337,37 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                 ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n                 _,\n                 _,\n-            ) => RegionHighlightMode::highlighting_bound_region(*br, counter, || ty.to_string()),\n-            _ => ty.to_string(),\n+            ) => printer.region_highlight_mode.highlighting_bound_region(*br, counter),\n+            _ => {}\n         }\n+\n+        let _ = ty.print(printer);\n+        s\n     }\n \n     /// Returns the name of the provided `Ty` (that must be a reference)'s region with a\n     /// synthesized lifetime name where required.\n     fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n-        match ty.sty {\n-            ty::TyKind::Ref(region, _, _) => match region {\n-                ty::RegionKind::ReLateBound(_, br)\n-                | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n-                    RegionHighlightMode::highlighting_bound_region(\n-                        *br,\n-                        counter,\n-                        || region.to_string(),\n-                    )\n+        let mut s = String::new();\n+        let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n+\n+        let region = match ty.sty {\n+            ty::TyKind::Ref(region, _, _) => {\n+                match region {\n+                    ty::RegionKind::ReLateBound(_, br)\n+                    | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n+                        printer.region_highlight_mode.highlighting_bound_region(*br, counter)\n+                    }\n+                    _ => {}\n                 }\n-                _ => region.to_string(),\n-            },\n+\n+                region\n+            }\n             _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n-        }\n+        };\n+\n+        let _ = region.print(printer);\n+        s\n     }\n }\n "}, {"sha": "c4e371d5afedb58e45d0b5864c71f5b656cb4447", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -68,7 +68,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n \n fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n     let input_mir = tcx.mir_validated(def_id);\n-    debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n+    debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n \n     let mut return_early;\n "}, {"sha": "dfa5af444d37ec76be09ddd0b2dd3ea3f5f42b65", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -93,7 +93,7 @@ impl BorrowExplanation {\n                     // simplify output by reporting just the ADT name.\n                     ty::Adt(adt, _substs) if adt.has_dtor(tcx) && !adt.is_box() => (\n                         \"`Drop` code\",\n-                        format!(\"type `{}`\", tcx.item_path_str(adt.did)),\n+                        format!(\"type `{}`\", tcx.def_path_str(adt.did)),\n                     ),\n \n                     // Otherwise, just report the whole type (and use"}, {"sha": "362214d3257123d5b54de71737686a0f60fd5160", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -8,7 +8,7 @@ use rustc::infer::InferCtxt;\n use rustc::mir::Mir;\n use rustc::ty::subst::{SubstsRef, UnpackedKind};\n use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n-use rustc::util::ppaux::RegionHighlightMode;\n+use rustc::ty::print::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n use syntax::ast::Name;\n use syntax::symbol::keywords;\n@@ -396,9 +396,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_ty: Ty<'tcx>,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n-        let type_name = RegionHighlightMode::highlighting_region_vid(needle_fr, *counter, || {\n-            infcx.extract_type_name(&argument_ty)\n-        });\n+        let mut highlight = RegionHighlightMode::default();\n+        highlight.highlighting_region_vid(needle_fr, *counter);\n+        let type_name = infcx.extract_type_name(&argument_ty, Some(highlight));\n \n         debug!(\n             \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n@@ -680,9 +680,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return None;\n         }\n \n-        let type_name = RegionHighlightMode::highlighting_region_vid(\n-            fr, *counter, || infcx.extract_type_name(&return_ty),\n-        );\n+        let mut highlight = RegionHighlightMode::default();\n+        highlight.highlighting_region_vid(fr, *counter);\n+        let type_name = infcx.extract_type_name(&return_ty, Some(highlight));\n \n         let mir_node_id = tcx.hir().as_local_node_id(mir_def_id).expect(\"non-local mir\");\n "}, {"sha": "43f019019f7c3e5a339bb6c2bb54f661f4d580fb", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -142,7 +142,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack);\n \n-    let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n+    let name = ty::tls::with(|tcx| tcx.def_path_str(cid.instance.def_id()));\n     let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n     trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n     assert!(mir.arg_count == 0);\n@@ -602,14 +602,15 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n             other => return other,\n         }\n     }\n-    // the first trace is for replicating an ice\n-    // There's no tracking issue, but the next two lines concatenated link to the discussion on\n-    // zulip. It's not really possible to test this, because it doesn't show up in diagnostics\n-    // or MIR.\n-    // https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/\n-    // subject/anon_const_instance_printing/near/135980032\n-    trace!(\"const eval: {}\", key.value.instance);\n-    trace!(\"const eval: {:?}\", key);\n+    if cfg!(debug_assertions) {\n+        // Make sure we format the instance even if we do not print it.\n+        // This serves as a regression test against an ICE on printing.\n+        // The next two lines concatenated contain some discussion:\n+        // https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/\n+        // subject/anon_const_instance_printing/near/135980032\n+        let instance = key.value.instance.to_string();\n+        trace!(\"const eval: {:?} ({})\", key, instance);\n+    }\n \n     let cid = key.value;\n     let def_id = cid.instance.def.def_id();"}, {"sha": "c8c6d73d4536a4267b2537f990a55c867ec248d3", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -955,7 +955,8 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let user_provided_types = cx.tables.user_provided_types();\n             let user_provided_type = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n             debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n-            match cx.tables().node_type(expr.hir_id).sty {\n+            let ty = cx.tables().node_type(expr.hir_id);\n+            match ty.sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n                 ty::Adt(adt_def, substs) => {\n@@ -968,7 +969,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         base: None,\n                     }\n                 }\n-                ref sty => bug!(\"unexpected sty: {:?}\", sty),\n+                _ => bug!(\"unexpected ty: {:?}\", ty),\n             }\n         }\n "}, {"sha": "49967df08891b3c4f77d372e2d7dd635ef27606f", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -319,7 +319,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                     if edef.is_enum() && edef.variants.iter().any(|variant| {\n                         variant.ident == ident && variant.ctor_kind == CtorKind::Const\n                     }) {\n-                        let ty_path = cx.tcx.item_path_str(edef.did);\n+                        let ty_path = cx.tcx.def_path_str(edef.did);\n                         let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n                             \"pattern binding `{}` is named the same as one \\\n                             of the variants of the type `{}`\","}, {"sha": "ad7b45d89453acb390b794ac8d314286d0f1db89", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -13,7 +13,7 @@ use crate::hair::constant::*;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::{UserTypeProjection};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n-use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, Lift, UserType};\n+use rustc::ty::{self, DefIdTree, Region, TyCtxt, AdtDef, Ty, Lift, UserType};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{SubstsRef, Kind};\n use rustc::ty::layout::VariantIdx;\n@@ -529,11 +529,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     ty::Error => { // Avoid ICE\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n-                    ref sty =>\n+                    _ =>\n                         span_bug!(\n                             pat.span,\n                             \"unexpanded type for vector pattern: {:?}\",\n-                            sty),\n+                            ty),\n                 }\n             }\n \n@@ -554,7 +554,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     ty::Error => { // Avoid ICE (#50577)\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n-                    ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n+                    _ => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", ty),\n                 }\n             }\n \n@@ -608,7 +608,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     }\n                     _ => span_bug!(pat.span,\n                                    \"tuple struct pattern not applied to an ADT {:?}\",\n-                                   ty.sty),\n+                                   ty),\n                 };\n                 let variant_def = adt_def.variant_of_def(def);\n \n@@ -735,7 +735,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     ) -> PatternKind<'tcx> {\n         let mut kind = match def {\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n+                let enum_id = self.tcx.parent(variant_id).unwrap();\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.is_enum() {\n                     let substs = match ty.sty {\n@@ -744,7 +744,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         ty::Error => {  // Avoid ICE (#50585)\n                             return PatternKind::Wild;\n                         }\n-                        _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n+                        _ => bug!(\"inappropriate type for def: {:?}\", ty),\n                     };\n                     PatternKind::Variant {\n                         adt_def,\n@@ -969,8 +969,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n                 let msg = format!(\"to use a constant of type `{}` in a pattern, \\\n                                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                                    self.tcx.item_path_str(adt_def.did),\n-                                    self.tcx.item_path_str(adt_def.did));\n+                                    self.tcx.def_path_str(adt_def.did),\n+                                    self.tcx.def_path_str(adt_def.did));\n                 self.tcx.sess.span_err(span, &msg);\n                 PatternKind::Wild\n             }"}, {"sha": "c9dae6990795be5276853a93cb49bfff621cb810", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -16,16 +16,20 @@ crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n         let user_provided_types = self.tables().user_provided_types();\n         let mut user_ty = *user_provided_types.get(hir_id)?;\n         debug!(\"user_subts_applied_to_ty_of_hir_id: user_ty={:?}\", user_ty);\n-        match &self.tables().node_type(hir_id).sty {\n+        let ty = self.tables().node_type(hir_id);\n+        match ty.sty {\n             ty::Adt(adt_def, ..) => {\n                 if let UserType::TypeOf(ref mut did, _) = &mut user_ty.value {\n                     *did = adt_def.did;\n                 }\n                 Some(user_ty)\n             }\n             ty::FnDef(..) => Some(user_ty),\n-            sty =>\n-                bug!(\"sty: {:?} should not have user provided type {:?} recorded \", sty, user_ty),\n+            _ => bug!(\n+                \"ty: {:?} should not have user provided type {:?} recorded \",\n+                ty,\n+                user_ty\n+            ),\n         }\n     }\n }"}, {"sha": "7543dd678d032fdd9a3f730ea0845ae4708a52e4", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         let fn_ptr = self.memory.create_fn_alloc(instance?).with_default_tag();\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n-                    ref other => bug!(\"reify fn pointer on {:?}\", other),\n+                    _ => bug!(\"reify fn pointer on {:?}\", src.layout.ty),\n                 }\n             }\n \n@@ -101,7 +101,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         // No change to value\n                         self.write_immediate(*src, dest)?;\n                     }\n-                    ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n+                    _ => bug!(\"fn to unsafe fn cast on {:?}\", dest.layout.ty),\n                 }\n             }\n \n@@ -120,7 +120,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         let val = Immediate::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n                         self.write_immediate(val, dest)?;\n                     }\n-                    ref other => bug!(\"closure fn pointer on {:?}\", other),\n+                    _ => bug!(\"closure fn pointer on {:?}\", src.layout.ty),\n                 }\n             }\n         }"}, {"sha": "e81d0a56b2b051758212c1f4bc2353648dcddef8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -283,7 +283,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n                 Ok(self.tcx.optimized_mir(did))\n             } else {\n-                err!(NoMirFor(self.tcx.item_path_str(def_id)))\n+                err!(NoMirFor(self.tcx.def_path_str(def_id)))\n             },\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }\n@@ -450,7 +450,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {\n-        if self.stack.len() > 1 { // FIXME should be \"> 0\", printing topmost frame crashes rustc...\n+        if self.stack.len() > 0 {\n             info!(\"PAUSING({}) {}\", self.cur_frame(), self.frame().instance);\n         }\n         ::log_settings::settings().indentation += 1;\n@@ -525,9 +525,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             self.frame_mut().locals = locals;\n         }\n \n-        if self.stack.len() > 1 { // FIXME no check should be needed, but some instances ICE\n-            info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n-        }\n+        info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n \n         if self.stack.len() > self.tcx.sess.const_eval_stack_frame_limit {\n             err!(StackFrameLimitReached)\n@@ -537,9 +535,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     }\n \n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n-        if self.stack.len() > 1 { // FIXME no check should be needed, but some instances ICE\n-            info!(\"LEAVING({}) {}\", self.cur_frame(), self.frame().instance);\n-        }\n+        info!(\"LEAVING({}) {}\", self.cur_frame(), self.frame().instance);\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n@@ -591,7 +587,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             StackPopCleanup::None { .. } => {}\n         }\n \n-        if self.stack.len() > 1 { // FIXME should be \"> 0\", printing topmost frame crashes rustc...\n+        if self.stack.len() > 0 {\n             info!(\"CONTINUING({}) {}\", self.cur_frame(), self.frame().instance);\n         }\n "}, {"sha": "944e393d296fc9e172d3205d660c21e4475b1988", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -336,7 +336,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n         let layout = val.layout;\n         let val = val.to_scalar()?;\n-        trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty.sty);\n+        trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty);\n \n         match layout.ty.sty {\n             ty::Bool => {"}, {"sha": "755bbd96b02f9131b1d75b2e8020bb643c1f265d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -354,7 +354,7 @@ where\n             ty::Ref(_, _, mutbl) => Some(mutbl),\n             ty::Adt(def, _) if def.is_box() => Some(hir::MutMutable),\n             ty::RawPtr(_) => None,\n-            _ => bug!(\"Unexpected pointer type {}\", val.layout.ty.sty),\n+            _ => bug!(\"Unexpected pointer type {}\", val.layout.ty),\n         };\n         place.mplace.ptr = M::tag_dereference(self, place, mutbl)?;\n         Ok(place)"}, {"sha": "307cee5d97217c1ae55e730bc5421574ad94a9ce", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -198,6 +198,8 @@ use crate::monomorphize::item::{MonoItemExt, DefPathBasedNames, InstantiationMod\n use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::{MTRef, MTLock, ParallelIterator, par_iter};\n \n+use std::iter;\n+\n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum MonoItemCollectionMode {\n     Eager,\n@@ -487,21 +489,33 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // We include the const length in the type length, as it's better\n     // to be overly conservative.\n     if type_length + const_length > type_length_limit {\n-        // The instance name is already known to be too long for rustc. Use\n-        // `{:.64}` to avoid blasting the user's terminal with thousands of\n-        // lines of type-name.\n-        let instance_name = instance.to_string();\n-        let msg = format!(\"reached the type-length limit while instantiating `{:.64}...`\",\n-                          instance_name);\n-        let mut diag = if let Some(hir_id) = tcx.hir().as_local_hir_id(instance.def_id()) {\n-            tcx.sess.struct_span_fatal(tcx.hir().span_by_hir_id(hir_id), &msg)\n-        } else {\n-            tcx.sess.struct_fatal(&msg)\n+        // The instance name is already known to be too long for rustc.\n+        // Show only the first and last 32 characters to avoid blasting\n+        // the user's terminal with thousands of lines of type-name.\n+        let shrink = |s: String, before: usize, after: usize| {\n+            // An iterator of all byte positions including the end of the string.\n+            let positions = || s.char_indices().map(|(i, _)| i).chain(iter::once(s.len()));\n+\n+            let shrunk = format!(\n+                \"{before}...{after}\",\n+                before = &s[..positions().nth(before).unwrap_or(s.len())],\n+                after = &s[positions().rev().nth(after).unwrap_or(0)..],\n+            );\n+\n+            // Only use the shrunk version if it's really shorter.\n+            // This also avoids the case where before and after slices overlap.\n+            if shrunk.len() < s.len() {\n+                shrunk\n+            } else {\n+                s\n+            }\n         };\n-\n+        let msg = format!(\"reached the type-length limit while instantiating `{}`\",\n+                          shrink(instance.to_string(), 32, 32));\n+        let mut diag = tcx.sess.struct_span_fatal(tcx.def_span(instance.def_id()), &msg);\n         diag.note(&format!(\n             \"consider adding a `#![type_length_limit=\\\"{}\\\"]` attribute to your crate\",\n-            type_length_limit * 2));\n+            type_length));\n         diag.emit();\n         tcx.sess.abort_if_errors();\n     }\n@@ -836,7 +850,7 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             match tail.sty {\n                 ty::Foreign(..) => false,\n                 ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n-                _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n+                _ => bug!(\"unexpected unsized tail: {:?}\", tail),\n             }\n         };\n         if type_has_metadata(inner_source) {"}, {"sha": "68d13bf2dcb24b52eba68fa89569bfd253c9ea80", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -216,9 +216,8 @@ impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n // These keys are used by the handwritten auto-tests, so they need to be\n // predictable and human-readable.\n //\n-// Note: A lot of this could looks very similar to what's already in the\n-//       ppaux module. It would be good to refactor things so we only have one\n-//       parameterizable implementation for printing types.\n+// Note: A lot of this could looks very similar to what's already in `ty::print`.\n+// FIXME(eddyb) implement a custom `PrettyPrinter` for this.\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter."}, {"sha": "4a2c05b2013286f0b263b0c7781272efd9d7e8e6", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -104,7 +104,7 @@ use rustc::hir::map::DefPathData;\n use rustc::mir::mono::{Linkage, Visibility, CodegenUnitNameBuilder};\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n-use rustc::ty::item_path::characteristic_def_id_of_type;\n+use rustc::ty::print::characteristic_def_id_of_type;\n use rustc::ty::query::Providers;\n use rustc::util::common::time;\n use rustc::util::nodemap::{DefIdSet, FxHashMap, FxHashSet};"}, {"sha": "001a61959c2dd75caf3a97626b38c475e6dfa211", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1253,7 +1253,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     if !self.span.allows_unstable(&feature.as_str()) {\n                                         let mut err = self.tcx.sess.struct_span_err(self.span,\n                                             &format!(\"`{}` is not yet stable as a const fn\",\n-                                                    self.tcx.item_path_str(def_id)));\n+                                                    self.tcx.def_path_str(def_id)));\n                                         if nightly_options::is_nightly_build() {\n                                             help!(&mut err,\n                                                   \"add `#![feature({})]` to the \\"}, {"sha": "f9f8abbe6c06519874cea41b4ae164dda1431480", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -29,10 +29,10 @@ impl MirPass for SanityCheck {\n         let def_id = src.def_id();\n         let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         if !tcx.has_attr(def_id, \"rustc_mir\") {\n-            debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.item_path_str(def_id));\n+            debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n             return;\n         } else {\n-            debug!(\"running rustc_peek::SanityCheck on {}\", tcx.item_path_str(def_id));\n+            debug!(\"running rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n         }\n \n         let attributes = tcx.get_attrs(def_id);"}, {"sha": "69a2adcfce026e2587e2392af894103ed707acae", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -127,7 +127,7 @@ fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                mir: &Mir<'_>,\n                                                w: &mut W)\n                                                -> io::Result<()> {\n-    write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.item_path_str(def_id)))?;\n+    write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.def_path_str(def_id)))?;\n \n     // fn argument types.\n     for (i, arg) in mir.args_iter().enumerate() {\n@@ -141,7 +141,7 @@ fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         )?;\n     }\n \n-    write!(w, \") -&gt; {}\", escape(mir.return_ty()))?;\n+    write!(w, \") -&gt; {}\", escape(&mir.return_ty()))?;\n     write!(w, r#\"<br align=\"left\"/>\"#)?;\n \n     for local in mir.vars_and_temps_iter() {"}, {"sha": "cbdd50cf4052af71d62f40f2bb97e77b22767836", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -29,7 +29,7 @@ use rustc::mir::visit::{\n };\n use rustc::mir::Local;\n use rustc::mir::*;\n-use rustc::ty::{item_path, TyCtxt};\n+use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::work_queue::WorkQueue;\n@@ -265,9 +265,9 @@ pub fn dump_mir<'a, 'tcx>(\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n     }\n-    let node_path = item_path::with_forced_impl_filename_line(|| {\n+    let node_path = ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n-        tcx.item_path_str(source.def_id())\n+        tcx.def_path_str(source.def_id())\n     });\n     dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, result);\n }"}, {"sha": "a76d26a6831c29ff1ede0cc2547b8affc26a1276", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -2,7 +2,6 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::*;\n use rustc::mir::visit::Visitor;\n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::item_path;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::fmt::Display;\n@@ -78,9 +77,9 @@ pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n         return;\n     }\n \n-    let node_path = item_path::with_forced_impl_filename_line(|| {\n+    let node_path = ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n-        tcx.item_path_str(source.def_id())\n+        tcx.def_path_str(source.def_id())\n     });\n     dump_matched_mir_node(\n         tcx,\n@@ -103,9 +102,9 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(\n         None => return false,\n         Some(ref filters) => filters,\n     };\n-    let node_path = item_path::with_forced_impl_filename_line(|| {\n+    let node_path = ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n-        tcx.item_path_str(source.def_id())\n+        tcx.def_path_str(source.def_id())\n     });\n     filters.split('|').any(|or_filter| {\n         or_filter.split('&').all(|and_filter| {\n@@ -115,7 +114,7 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(\n }\n \n // #41697 -- we use `with_forced_impl_filename_line()` because\n-// `item_path_str()` would otherwise trigger `type_of`, and this can\n+// `def_path_str()` would otherwise trigger `type_of`, and this can\n // run while we are already attempting to evaluate `type_of`.\n \n fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n@@ -612,9 +611,9 @@ fn write_mir_sig(\n         _ => bug!(\"Unexpected def description {:?}\", descr),\n     }\n \n-    item_path::with_forced_impl_filename_line(|| {\n+    ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 elsewhere\n-        write!(w, \"{}\", tcx.item_path_str(src.def_id()))\n+        write!(w, \" {}\", tcx.def_path_str(src.def_id()))\n     })?;\n \n     if src.promoted.is_none() && is_function {"}, {"sha": "5065c1de97bee27b7c860198b4ef4efe896246d8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n             ty::FnDef(def_id, ..) |\n             ty::Closure(def_id, ..) |\n             ty::Generator(def_id, ..) => {\n-                if self.def_id_visitor.visit_def_id(def_id, \"type\", ty) {\n+                if self.def_id_visitor.visit_def_id(def_id, \"type\", &ty) {\n                     return true;\n                 }\n                 if self.def_id_visitor.shallow() {\n@@ -816,7 +816,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n         let def_id = self.tcx.adjust_ident(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n-                             field.ident, def.variant_descr(), self.tcx.item_path_str(def.did))\n+                             field.ident, def.variant_descr(), self.tcx.def_path_str(def.did))\n                 .span_label(span, format!(\"field `{}` is private\", field.ident))\n                 .emit();\n         }"}, {"sha": "3fea515ae401e2a75b8e1fc3cc7a80409285ce0b", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def::Def as HirDef;\n use rustc::hir::def_id::DefId;\n use rustc::session::config::Input;\n use rustc::span_bug;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, DefIdTree, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n \n use std::path::Path;\n@@ -429,7 +429,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         vis: ast::Visibility,\n         attrs: &'l [Attribute],\n     ) {\n-        let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n+        let qualname = format!(\"::{}\",\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(id)));\n \n         if !self.span.filter_generated(ident.span) {\n             let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n@@ -470,7 +471,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     ) {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+        let qualname = format!(\"::{}\",\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n \n         let kind = match item.node {\n             ast::ItemKind::Struct(_, _) => DefKind::Struct,\n@@ -682,7 +684,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         methods: &'l [ast::TraitItem],\n     ) {\n         let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+        let qualname = format!(\"::{}\",\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n         let mut val = name.clone();\n         if !generics.params.is_empty() {\n             val.push_str(&generic_params_to_string(&generics.params));\n@@ -1093,7 +1096,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             ast::TraitItemKind::Type(ref bounds, ref default_ty) => {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(trait_item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(trait_item.id)));\n \n                 if !self.span.filter_generated(trait_item.ident.span) {\n                     let span = self.span_from_span(trait_item.ident.span);\n@@ -1201,7 +1205,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n         // The parent def id of a given use tree is always the enclosing item.\n         let parent = self.save_ctxt.tcx.hir().opt_local_def_id(id)\n-            .and_then(|id| self.save_ctxt.tcx.parent_def_id(id))\n+            .and_then(|id| self.save_ctxt.tcx.parent(id))\n             .map(id_from_def_id);\n \n         match use_tree.kind {\n@@ -1300,7 +1304,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         // only get called for the root module of a crate.\n         assert_eq!(id, ast::CRATE_NODE_ID);\n \n-        let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n+        let qualname = format!(\"::{}\",\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(id)));\n \n         let cm = self.tcx.sess.source_map();\n         let filename = cm.span_to_filename(span);\n@@ -1350,7 +1355,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 if !self.span.filter_generated(name_span) {\n                     let span = self.span_from_span(name_span);\n                     let parent = self.save_ctxt.tcx.hir().opt_local_def_id(item.id)\n-                        .and_then(|id| self.save_ctxt.tcx.parent_def_id(id))\n+                        .and_then(|id| self.save_ctxt.tcx.parent(id))\n                         .map(id_from_def_id);\n                     self.dumper.import(\n                         &Access {\n@@ -1389,7 +1394,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 self.nest_scope(item.id, |v| visit::walk_mod(v, m));\n             }\n             Ty(ref ty, ref ty_params) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n                 let value = ty_to_string(&ty);\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n@@ -1418,7 +1424,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 self.process_generic_params(ty_params, &qualname, item.id);\n             }\n             Existential(ref _bounds, ref ty_params) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n                 // FIXME do something with _bounds\n                 let value = String::new();\n                 if !self.span.filter_generated(item.ident.span) {"}, {"sha": "7ad5b7ce8c73ebdf3a25dcb824c5bdb6a0b2af08", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -20,7 +20,7 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::cstore::ExternCrate;\n use rustc::session::config::{CrateType, Input, OutputType};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, DefIdTree, TyCtxt};\n use rustc::{bug, span_bug};\n use rustc_typeck::hir_ty_to_ty;\n use rustc_codegen_utils::link::{filename_for_metadata, out_filename};\n@@ -134,7 +134,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_extern_item_data(&self, item: &ast::ForeignItem) -> Option<Data> {\n-        let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+        let qualname = format!(\"::{}\",\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 filter!(self.span_utils, item.ident.span);\n@@ -184,7 +185,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n         match item.node {\n             ast::ItemKind::Fn(ref decl, .., ref generics, _) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n                 filter!(self.span_utils, item.ident.span);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Function,\n@@ -202,7 +204,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Static(ref typ, ..) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n \n                 filter!(self.span_utils, item.ident.span);\n \n@@ -225,7 +228,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Const(ref typ, _) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n                 filter!(self.span_utils, item.ident.span);\n \n                 let id = id_from_node_id(item.id, self);\n@@ -247,7 +251,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Mod(ref m) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n \n                 let cm = self.tcx.sess.source_map();\n                 let filename = cm.span_to_filename(m.inner);\n@@ -274,7 +279,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ItemKind::Enum(ref def, _) => {\n                 let name = item.ident.to_string();\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n                 filter!(self.span_utils, item.ident.span);\n                 let variants_str = def.variants\n                     .iter()\n@@ -358,7 +364,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_field_data(&self, field: &ast::StructField, scope: NodeId) -> Option<Def> {\n         if let Some(ident) = field.ident {\n             let name = ident.to_string();\n-            let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n+            let qualname = format!(\"::{}::{}\",\n+                self.tcx.def_path_str(self.tcx.hir().local_def_id(scope)),\n+                ident);\n             filter!(self.span_utils, ident.span);\n             let def_id = self.tcx.hir().local_def_id(field.id);\n             let typ = self.tcx.type_of(def_id).to_string();\n@@ -411,7 +419,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             if let Some(def_id) = trait_id {\n                                 // A method in a trait impl.\n                                 qualname.push_str(\" as \");\n-                                qualname.push_str(&self.tcx.item_path_str(def_id));\n+                                qualname.push_str(&self.tcx.def_path_str(def_id));\n                                 self.tcx\n                                     .associated_items(def_id)\n                                     .find(|item| item.ident.name == ident.name)\n@@ -451,7 +459,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         }\n \n                         (\n-                            format!(\"::{}\", self.tcx.item_path_str(def_id)),\n+                            format!(\"::{}\", self.tcx.def_path_str(def_id)),\n                             Some(def_id),\n                             None,\n                             docs,\n@@ -763,7 +771,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 // This is a reference to a tuple struct where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct itself.\n-                let parent_def_id = self.tcx.parent_def_id(def_id).unwrap();\n+                let parent_def_id = self.tcx.parent(def_id).unwrap();\n                 Some(Ref {\n                     kind: RefKind::Type,\n                     span,"}, {"sha": "9ca75566b4280ce7f75e0e7b7450979a479fa326", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -12,7 +12,7 @@ use crate::middle::resolve_lifetime as rl;\n use crate::namespace::Namespace;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n use rustc::traits;\n-use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n+use rustc::ty::{self, DefIdTree, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc::ty::subst::{Kind, Subst, InternalSubsts, SubstsRef};\n use rustc::ty::wf::object_region_bounds;\n@@ -922,7 +922,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                                      \"the value of the associated type `{}` (from the trait `{}`) \\\n                                       is already specified\",\n                                      binding.item_name,\n-                                     tcx.item_path_str(assoc_ty.container.id()))\n+                                     tcx.def_path_str(assoc_ty.container.id()))\n                         .span_label(binding.span, \"re-bound here\")\n                         .span_label(*prev_span, format!(\"`{}` bound here first\", binding.item_name))\n                         .emit();\n@@ -959,7 +959,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// removing the dummy `Self` type (`TRAIT_OBJECT_DUMMY_SELF`).\n     fn trait_ref_to_existential(&self, trait_ref: ty::TraitRef<'tcx>)\n                                 -> ty::ExistentialTraitRef<'tcx> {\n-        assert_eq!(trait_ref.self_ty().sty, TRAIT_OBJECT_DUMMY_SELF);\n+        if trait_ref.self_ty().sty != TRAIT_OBJECT_DUMMY_SELF {\n+            bug!(\"trait_ref_to_existential called on {:?} with non-dummy Self\", trait_ref);\n+        }\n         ty::ExistentialTraitRef::erase_self_ty(self.tcx(), trait_ref)\n     }\n \n@@ -1069,7 +1071,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 format!(\n                     \"`{}` (from the trait `{}`)\",\n                     assoc_item.ident,\n-                    tcx.item_path_str(trait_def_id),\n+                    tcx.def_path_str(trait_def_id),\n                 )\n             }).collect::<Vec<_>>().join(\", \");\n             let mut err = struct_span_err!(\n@@ -1450,14 +1452,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                    -> Ty<'tcx>\n     {\n         let tcx = self.tcx();\n-        let trait_def_id = tcx.parent_def_id(item_def_id).unwrap();\n+        let trait_def_id = tcx.parent(item_def_id).unwrap();\n \n         self.prohibit_generics(slice::from_ref(item_segment));\n \n         let self_ty = if let Some(ty) = opt_self_ty {\n             ty\n         } else {\n-            let path_str = tcx.item_path_str(trait_def_id);\n+            let path_str = tcx.def_path_str(trait_def_id);\n             self.report_ambiguous_associated_type(span,\n                                                   \"Type\",\n                                                   &path_str,\n@@ -1619,7 +1621,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 } else if last >= 1 && segments[last - 1].args.is_some() {\n                     // Everything but the penultimate segment should have no\n                     // parameters at all.\n-                    let enum_def_id = tcx.parent_def_id(def_id).unwrap();\n+                    let enum_def_id = tcx.parent(def_id).unwrap();\n                     (enum_def_id, last - 1)\n                 } else {\n                     // FIXME: lint here recommending `Enum::<...>::Variant` form"}, {"sha": "c6b66393dd2f1e2733cc72c03fcf6dcc901fccc8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // See the examples in `run-pass/match-defbm*.rs`.\n             let mut pat_adjustments = vec![];\n             while let ty::Ref(_, inner_ty, inner_mutability) = exp_ty.sty {\n-                debug!(\"inspecting {:?} with type {:?}\", exp_ty, exp_ty.sty);\n+                debug!(\"inspecting {:?}\", exp_ty);\n \n                 debug!(\"current discriminant is Ref, inserting implicit deref\");\n                 // Preserve the reference type. We'll need it later during HAIR lowering.\n@@ -894,7 +894,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 subpats.len() < variant.fields.len() && ddpos.is_some() {\n             let substs = match pat_ty.sty {\n                 ty::Adt(_, substs) => substs,\n-                ref ty => bug!(\"unexpected pattern type {:?}\", ty),\n+                _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n@@ -1001,13 +1001,13 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                                            E0026,\n                                            \"{} `{}` does not have {}\",\n                                            kind_name,\n-                                           tcx.item_path_str(variant.did),\n+                                           tcx.def_path_str(variant.did),\n                                            field_names);\n             if let Some((span, ident)) = inexistent_fields.last() {\n                 err.span_label(*span,\n                                format!(\"{} `{}` does not have {} field{}\",\n                                        kind_name,\n-                                       tcx.item_path_str(variant.did),\n+                                       tcx.def_path_str(variant.did),\n                                        t,\n                                        plural));\n                 if plural == \"\" {"}, {"sha": "e6e5c46c473d54abb7ae5a6d84b2eb47ea3862e4", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -719,7 +719,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         trait `{}` has {}\",\n                                        trait_m.ident,\n                                        potentially_plural_count(impl_number_args, \"parameter\"),\n-                                       tcx.item_path_str(trait_m.def_id),\n+                                       tcx.def_path_str(trait_m.def_id),\n                                        trait_number_args);\n         if let Some(trait_span) = trait_span {\n             err.span_label(trait_span, format!(\"trait requires {}\","}, {"sha": "3a7308d09172e6581402db7d77fd0eecba619a29", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let sole_field = &variant.fields[0];\n                         let sole_field_ty = sole_field.ty(self.tcx, substs);\n                         if self.can_coerce(expr_ty, sole_field_ty) {\n-                            let variant_path = self.tcx.item_path_str(variant.did);\n+                            let variant_path = self.tcx.def_path_str(variant.did);\n                             // FIXME #56861: DRYer prelude filtering\n                             Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n                         } else {"}, {"sha": "1f0ab3abb283617346f34d9a8905876088f682e2", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1195,15 +1195,15 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // `report_method_error()`.\n         diag.help(&format!(\n             \"call with fully qualified syntax `{}(...)` to keep using the current method\",\n-            self.tcx.item_path_str(stable_pick.item.def_id),\n+            self.tcx.def_path_str(stable_pick.item.def_id),\n         ));\n \n         if nightly_options::is_nightly_build() {\n             for (candidate, feature) in unstable_candidates {\n                 diag.help(&format!(\n                     \"add #![feature({})] to the crate attributes to enable `{}`\",\n                     feature,\n-                    self.tcx.item_path_str(candidate.item.def_id),\n+                    self.tcx.def_path_str(candidate.item.def_id),\n                 ));\n             }\n         }"}, {"sha": "b4a1a2d76c262554fbf400e8724b58ad7f239810", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -15,7 +15,7 @@ use rustc::hir::print;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::Obligation;\n use rustc::ty::{self, Adt, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n-use rustc::ty::item_path::with_crate_prefix;\n+use rustc::ty::print::with_crate_prefix;\n use syntax_pos::{Span, FileName};\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             None => String::new(),\n                             Some(trait_ref) => {\n                                 format!(\" of the trait `{}`\",\n-                                        self.tcx.item_path_str(trait_ref.def_id))\n+                                        self.tcx.def_path_str(trait_ref.def_id))\n                             }\n                         };\n \n@@ -135,16 +135,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        item_span,\n                                        \"candidate #{} is defined in the trait `{}`\",\n                                        idx + 1,\n-                                       self.tcx.item_path_str(trait_did));\n+                                       self.tcx.def_path_str(trait_did));\n                         } else {\n                             span_note!(err,\n                                        item_span,\n                                        \"the candidate is defined in the trait `{}`\",\n-                                       self.tcx.item_path_str(trait_did));\n+                                       self.tcx.def_path_str(trait_did));\n                         }\n                         err.help(&format!(\"to disambiguate the method call, write `{}::{}({}{})` \\\n                                           instead\",\n-                                          self.tcx.item_path_str(trait_did),\n+                                          self.tcx.def_path_str(trait_did),\n                                           item_name,\n                                           if rcvr_ty.is_region_ptr() && args.is_some() {\n                                               if rcvr_ty.is_mutable_pointer() {\n@@ -516,7 +516,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 format!(\n                     \"use {};\\n{}\",\n-                    with_crate_prefix(|| self.tcx.item_path_str(*did)),\n+                    with_crate_prefix(|| self.tcx.def_path_str(*did)),\n                     additional_newline\n                 )\n             });\n@@ -530,14 +530,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         &format!(\n                             \"\\ncandidate #{}: `use {};`\",\n                             i + 1,\n-                            with_crate_prefix(|| self.tcx.item_path_str(*trait_did))\n+                            with_crate_prefix(|| self.tcx.def_path_str(*trait_did))\n                         )\n                     );\n                 } else {\n                     msg.push_str(\n                         &format!(\n                             \"\\n`use {};`\",\n-                            with_crate_prefix(|| self.tcx.item_path_str(*trait_did))\n+                            with_crate_prefix(|| self.tcx.def_path_str(*trait_did))\n                         )\n                     );\n                 }\n@@ -638,7 +638,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for (i, trait_info) in candidates.iter().enumerate() {\n                 msg.push_str(&format!(\"\\ncandidate #{}: `{}`\",\n                                       i + 1,\n-                                      self.tcx.item_path_str(trait_info.def_id)));\n+                                      self.tcx.def_path_str(trait_info.def_id)));\n             }\n             err.note(&msg[..]);\n         }"}, {"sha": "1383bf28113d8196acbed18e8fbf49c2410c65e4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1328,7 +1328,7 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n     debug!(\n         \"check_item_type(it.hir_id={}, it.name={})\",\n         it.hir_id,\n-        tcx.item_path_str(tcx.hir().local_def_id_from_hir_id(it.hir_id))\n+        tcx.def_path_str(tcx.hir().local_def_id_from_hir_id(it.hir_id))\n     );\n     let _indenter = indenter();\n     match it.node {\n@@ -3534,7 +3534,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         autoderef.unambiguous_final_ty(self);\n \n         if let Some((did, field_ty)) = private_candidate {\n-            let struct_path = self.tcx().item_path_str(did);\n+            let struct_path = self.tcx().def_path_str(did);\n             let mut err = struct_span_err!(self.tcx().sess, expr.span, E0616,\n                                            \"field `{}` of struct `{}` is private\",\n                                            field, struct_path);\n@@ -3885,7 +3885,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::Adt(adt, substs) => {\n                         Some((adt.variant_of_def(def), adt.did, substs))\n                     }\n-                    _ => bug!(\"unexpected type: {:?}\", ty.sty)\n+                    _ => bug!(\"unexpected type: {:?}\", ty)\n                 }\n             }\n             Def::Struct(..) | Def::Union(..) | Def::TyAlias(..) |\n@@ -5226,8 +5226,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.node);\n                 let sp = ty.span;\n                 let ty = AstConv::ast_ty_to_ty(self, ty);\n-                debug!(\"suggest_missing_return_type: return type sty {:?}\", ty.sty);\n-                debug!(\"suggest_missing_return_type: expected type sty {:?}\", ty.sty);\n+                debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n+                debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n                 if ty.sty == expected.sty {\n                     err.span_label(sp, format!(\"expected `{}` because of return type\",\n                                                expected));"}, {"sha": "a76dfdd69ba9797304da44193f7093b797910962", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -93,19 +93,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         // Extract the type of the closure.\n-        let (closure_def_id, substs) = match self.node_ty(closure_hir_id).sty {\n+        let ty = self.node_ty(closure_hir_id);\n+        let (closure_def_id, substs) = match ty.sty {\n             ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n             ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n             ty::Error => {\n                 // #51714: skip analysis when we have already encountered type errors\n                 return;\n             }\n-            ref t => {\n+            _ => {\n                 span_bug!(\n                     span,\n                     \"type of closure expr {:?} is not a closure {:?}\",\n                     closure_hir_id,\n-                    t\n+                    ty\n                 );\n             }\n         };"}, {"sha": "1f7e05de18bcf07ff09de6fed0704cc06c86b7dd", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -68,7 +68,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n \n     debug!(\"check_item_well_formed(it.hir_id={:?}, it.name={})\",\n            item.hir_id,\n-           tcx.item_path_str(def_id));\n+           tcx.def_path_str(def_id));\n \n     match item.node {\n         // Right now we check that every default trait implementation\n@@ -618,7 +618,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n     span: Span,\n     ty: Ty<'tcx>,\n ) -> Vec<ty::Predicate<'tcx>> {\n-    trace!(\"check_existential_types: {:?}, {:?}\", ty, ty.sty);\n+    trace!(\"check_existential_types: {:?}\", ty);\n     let mut substituted_predicates = Vec::new();\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n@@ -976,7 +976,7 @@ fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Some(def_id) = suggested_marker_id {\n         err.help(&format!(\"consider removing `{}` or using a marker such as `{}`\",\n                           param_name,\n-                          tcx.item_path_str(def_id)));\n+                          tcx.def_path_str(def_id)));\n     }\n     err.emit();\n }"}, {"sha": "4a3d4f31a24731eed44d220ea783e4adb3f47ed6", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -472,7 +472,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 instantiated_ty.fold_with(&mut BottomUpFolder {\n                     tcx: self.tcx().global_tcx(),\n                     fldop: |ty| {\n-                        trace!(\"checking type {:?}: {:#?}\", ty, ty.sty);\n+                        trace!(\"checking type {:?}\", ty);\n                         // find a type parameter\n                         if let ty::Param(..) = ty.sty {\n                             // look it up in the substitution list"}, {"sha": "a2b01e3843ff2d43d2361969c389603ac1cd45d7", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -198,8 +198,8 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n                     if def_a.is_struct() && def_b.is_struct() =>\n                 {\n                     if def_a != def_b {\n-                        let source_path = tcx.item_path_str(def_a.did);\n-                        let target_path = tcx.item_path_str(def_b.did);\n+                        let source_path = tcx.def_path_str(def_a.did);\n+                        let target_path = tcx.def_path_str(def_b.did);\n \n                         create_err(\n                             &format!(\n@@ -388,8 +388,8 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n             (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) if def_a.is_struct() &&\n                                                                       def_b.is_struct() => {\n                 if def_a != def_b {\n-                    let source_path = gcx.item_path_str(def_a.did);\n-                    let target_path = gcx.item_path_str(def_b.did);\n+                    let source_path = gcx.def_path_str(def_a.did);\n+                    let target_path = gcx.def_path_str(def_b.did);\n                     span_err!(gcx.sess,\n                               span,\n                               E0377,"}, {"sha": "a5452b4db2a2081538f6657284993e1549ba5fcb", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -28,7 +28,7 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n     if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n         debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n                trait_ref,\n-               tcx.item_path_str(impl_def_id));\n+               tcx.def_path_str(impl_def_id));\n \n         // Skip impls where one of the self type is an error type.\n         // This occurs with e.g., resolve failures (#30589).\n@@ -204,10 +204,10 @@ fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeI\n                                      E0371,\n                                      \"the object type `{}` automatically implements the trait `{}`\",\n                                      trait_ref.self_ty(),\n-                                     tcx.item_path_str(trait_def_id))\n+                                     tcx.def_path_str(trait_def_id))\n                         .span_label(sp, format!(\"`{}` automatically implements trait `{}`\",\n                                                 trait_ref.self_ty(),\n-                                                tcx.item_path_str(trait_def_id)))\n+                                                tcx.def_path_str(trait_def_id)))\n                         .emit();\n                 }\n             }"}, {"sha": "7e1c38e051542298eec8eb6c877a6059bb4f7edc", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -121,15 +121,15 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                 format!(\"cross-crate traits with a default impl, like `{}`, \\\n                                          can only be implemented for a struct/enum type \\\n                                          defined in the current crate\",\n-                                        self.tcx.item_path_str(trait_def_id)),\n+                                        self.tcx.def_path_str(trait_def_id)),\n                                 \"can't implement cross-crate trait for type in another crate\"\n                             ))\n                         }\n                     }\n                     _ => {\n                         Some((format!(\"cross-crate traits with a default impl, like `{}`, can \\\n                                        only be implemented for a struct/enum type, not `{}`\",\n-                                      self.tcx.item_path_str(trait_def_id),\n+                                      self.tcx.def_path_str(trait_def_id),\n                                       self_ty),\n                               \"can't implement cross-crate trait with a default impl for \\\n                                non-struct/enum type\"))"}, {"sha": "c18f9fd102f1093980b26fbc179a61122c3d7e5f", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n     fn build_constraints_for_item(&mut self, def_id: DefId) {\n         let tcx = self.tcx();\n-        debug!(\"build_constraints_for_item({})\", tcx.item_path_str(def_id));\n+        debug!(\"build_constraints_for_item({})\", tcx.def_path_str(def_id));\n \n         // Skip items with no generics - there's nothing to infer in them.\n         if tcx.generics_of(def_id).count() == 0 {"}, {"sha": "c80fd8fcd812f9588a34b9da7583a5d218dc832a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 100, "deletions": 18, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -20,8 +20,9 @@ use rustc::mir::interpret::GlobalId;\n use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n+use rustc::hir::map::DisambiguatedDefPathData;\n+use rustc::ty::subst::{Kind, InternalSubsts, SubstsRef};\n+use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n use rustc::ty::layout::VariantIdx;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -3971,7 +3972,7 @@ pub fn register_def(cx: &DocContext<'_>, def: Def) -> DefId {\n         Def::ForeignTy(i) => (i, TypeKind::Foreign),\n         Def::Const(i) => (i, TypeKind::Const),\n         Def::Static(i, _) => (i, TypeKind::Static),\n-        Def::Variant(i) => (cx.tcx.parent_def_id(i).expect(\"cannot get parent def id\"),\n+        Def::Variant(i) => (cx.tcx.parent(i).expect(\"cannot get parent def id\"),\n                             TypeKind::Enum),\n         Def::Macro(i, mac_kind) => match mac_kind {\n             MacroKind::Bang => (i, TypeKind::Macro),\n@@ -4223,32 +4224,113 @@ pub fn path_to_def(tcx: &TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n     }\n }\n \n-pub fn get_path_for_type<F>(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, def_ctor: F) -> hir::Path\n-where F: Fn(DefId) -> Def {\n-    #[derive(Debug)]\n-    struct AbsolutePathBuffer {\n-        names: Vec<String>,\n+pub fn get_path_for_type(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    def_id: DefId,\n+    def_ctor: impl Fn(DefId) -> Def,\n+) -> hir::Path {\n+    use rustc::ty::print::Printer;\n+\n+    struct AbsolutePathPrinter<'a, 'tcx> {\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n-    impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n-        fn root_mode(&self) -> &ty::item_path::RootMode {\n-            const ABSOLUTE: &'static ty::item_path::RootMode = &ty::item_path::RootMode::Absolute;\n-            ABSOLUTE\n+    impl Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+        type Error = !;\n+\n+        type Path = Vec<String>;\n+        type Region = ();\n+        type Type = ();\n+        type DynExistential = ();\n+\n+        fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+            self.tcx\n         }\n \n-        fn push(&mut self, text: &str) {\n-            self.names.push(text.to_owned());\n+        fn print_region(\n+            self,\n+            _region: ty::Region<'_>,\n+        ) -> Result<Self::Region, Self::Error> {\n+            Ok(())\n         }\n-    }\n \n-    let mut apb = AbsolutePathBuffer { names: vec![] };\n+        fn print_type(\n+            self,\n+            _ty: Ty<'tcx>,\n+        ) -> Result<Self::Type, Self::Error> {\n+            Ok(())\n+        }\n+\n+        fn print_dyn_existential(\n+            self,\n+            _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+        ) -> Result<Self::DynExistential, Self::Error> {\n+            Ok(())\n+        }\n+\n+        fn path_crate(\n+            self,\n+            cnum: CrateNum,\n+        ) -> Result<Self::Path, Self::Error> {\n+            Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n+        }\n+        fn path_qualified(\n+            self,\n+            self_ty: Ty<'tcx>,\n+            trait_ref: Option<ty::TraitRef<'tcx>>,\n+        ) -> Result<Self::Path, Self::Error> {\n+            // This shouldn't ever be needed, but just in case:\n+            Ok(vec![match trait_ref {\n+                Some(trait_ref) => format!(\"{:?}\", trait_ref),\n+                None => format!(\"<{}>\", self_ty),\n+            }])\n+        }\n+\n+        fn path_append_impl(\n+            self,\n+            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+            _disambiguated_data: &DisambiguatedDefPathData,\n+            self_ty: Ty<'tcx>,\n+            trait_ref: Option<ty::TraitRef<'tcx>>,\n+        ) -> Result<Self::Path, Self::Error> {\n+            let mut path = print_prefix(self)?;\n+\n+            // This shouldn't ever be needed, but just in case:\n+            path.push(match trait_ref {\n+                Some(trait_ref) => {\n+                    format!(\"<impl {} for {}>\", trait_ref, self_ty)\n+                }\n+                None => format!(\"<impl {}>\", self_ty),\n+            });\n+\n+            Ok(path)\n+        }\n+        fn path_append(\n+            self,\n+            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+            disambiguated_data: &DisambiguatedDefPathData,\n+        ) -> Result<Self::Path, Self::Error> {\n+            let mut path = print_prefix(self)?;\n+            path.push(disambiguated_data.data.as_interned_str().to_string());\n+            Ok(path)\n+        }\n+        fn path_generic_args(\n+            self,\n+            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+            _args: &[Kind<'tcx>],\n+        ) -> Result<Self::Path, Self::Error> {\n+            print_prefix(self)\n+        }\n+    }\n \n-    tcx.push_item_path(&mut apb, def_id, false);\n+    let names = AbsolutePathPrinter { tcx: tcx.global_tcx() }\n+        .print_def_path(def_id, &[])\n+        .unwrap();\n \n     hir::Path {\n         span: DUMMY_SP,\n         def: def_ctor(def_id),\n-        segments: hir::HirVec::from_vec(apb.names.iter().map(|s| hir::PathSegment {\n+        segments: hir::HirVec::from_vec(names.iter().map(|s| hir::PathSegment {\n             ident: ast::Ident::from_str(&s),\n             hir_id: None,\n             def: None,"}, {"sha": "fccf5a67ad46564fede5025f5925e3fc836968aa", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -5,8 +5,10 @@\n \n #![feature(bind_by_move_pattern_guards)]\n #![feature(rustc_private)]\n+#![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(set_stdio)]\n #![feature(test)]\n@@ -16,6 +18,7 @@\n #![feature(const_fn)]\n #![feature(drain_filter)]\n #![feature(inner_deref)]\n+#![feature(never_type)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "b2982629fe6b2f9cf51847f456fd4564927ecf2f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1042,7 +1042,7 @@ pub const BUILTIN_ATTRIBUTES: &[(&str, AttributeType, AttributeTemplate, Attribu\n                                              \"rustc_attrs\",\n                                              \"internal rustc attributes will never be stable\",\n                                              cfg_fn!(rustc_attrs))),\n-    (\"rustc_item_path\", Whitelisted, template!(Word), Gated(Stability::Unstable,\n+    (\"rustc_def_path\", Whitelisted, template!(Word), Gated(Stability::Unstable,\n                                            \"rustc_attrs\",\n                                            \"internal rustc attributes will never be stable\",\n                                            cfg_fn!(rustc_attrs))),"}, {"sha": "3ce43cc4a224fa1f443145bbffba5aaaca0246b7", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -35,7 +35,7 @@ fn main() {\n //        _2 = move _3;\n //        StorageDead(_3);\n //        StorageLive(_4);\n-//        _4 = std::option::Option<std::boxed::Box<u32>>::None;\n+//        _4 = std::option::Option::<std::boxed::Box<u32>>::None;\n //        FakeRead(ForLet, _4);\n //        AscribeUserType(_4, o, UserTypeProjection { base: UserType(1), projs: [] });\n //        StorageLive(_5);"}, {"sha": "5a461d61482546f65e1b121418ec474f5eed64a7", "filename": "src/test/mir-opt/issue-41697.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fmir-opt%2Fissue-41697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fmir-opt%2Fissue-41697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41697.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,7 +1,7 @@\n // Regression test for #41697. Using dump-mir was triggering\n // artificial cycles: during type-checking, we had to get the MIR for\n // the constant expressions in `[u8; 2]`, which in turn would trigger\n-// an attempt to get the item-path, which in turn would request the\n+// an attempt to get the def-path, which in turn would request the\n // types of the impl, which would trigger a cycle. We suppressed this\n // cycle now by forcing mir-dump to avoid asking for types of an impl.\n "}, {"sha": "9eeef8570a37a307f86bd0e0f0fb90d075c6cabc", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -42,7 +42,7 @@ fn main() {\n // START rustc.full_tested_match.QualifyAndPromoteConstants.after.mir\n //  bb0: {\n //      ...\n-//      _2 = std::option::Option<i32>::Some(const 42i32,);\n+//      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n //      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb7];\n@@ -111,7 +111,7 @@ fn main() {\n // START rustc.full_tested_match2.QualifyAndPromoteConstants.before.mir\n //  bb0: {\n //      ...\n-//      _2 = std::option::Option<i32>::Some(const 42i32,);\n+//      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n //      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb7];\n@@ -180,7 +180,7 @@ fn main() {\n // START rustc.main.QualifyAndPromoteConstants.before.mir\n // bb0: {\n //     ...\n-//      _2 = std::option::Option<i32>::Some(const 1i32,);\n+//      _2 = std::option::Option::<i32>::Some(const 1i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n //      switchInt(move _3) -> [1isize: bb2, otherwise: bb3];"}, {"sha": "3b333b5431c3e995dd5f02bb718abab16344a03e", "filename": "src/test/mir-opt/retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fmir-opt%2Fretag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fmir-opt%2Fretag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -98,7 +98,7 @@ fn main() {\n // }\n // END rustc.main.EraseRegions.after.mir\n // START rustc.main-{{closure}}.EraseRegions.after.mir\n-// fn main::{{closure}}(_1: &[closure@HirId { owner: DefIndex(0:7), local_id: 70 }], _2: &i32) -> &i32 {\n+// fn main::{{closure}}#0(_1: &[closure@HirId { owner: DefIndex(0:7), local_id: 70 }], _2: &i32) -> &i32 {\n //     ...\n //     bb0: {\n //         Retag([fn entry] _1);"}, {"sha": "9a22f57116ed89f7a0997e2d32a494a096f39daf", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -18,7 +18,7 @@ fn main() {\n //         StorageLive(_4);\n //         StorageLive(_5);\n //         _5 = _1;\n-//         _4 = std::option::Option<i32>::Some(move _5,);\n+//         _4 = std::option::Option::<i32>::Some(move _5,);\n //         StorageDead(_5);\n //         _3 = &_4;\n //         FakeRead(ForLet, _3);"}, {"sha": "ad663412e77768505d34156a85313ed0afd900e4", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -32,27 +32,27 @@\n                   (($crate::fmt::format as\n                        for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<$crate::fmt::Arguments>::new_v1\n                                                                                                            as\n-                                                                                                           fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})((&([(\"test\"\n+                                                                                                           fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments::<'_>::new_v1})((&([(\"test\"\n+                                                                                                                                                                                                                            as\n+                                                                                                                                                                                                                            &'static str)]\n                                                                                                                                                                                                                           as\n-                                                                                                                                                                                                                          &'static str)]\n+                                                                                                                                                                                                                          [&str; 1])\n                                                                                                                                                                                                                         as\n-                                                                                                                                                                                                                        [&str; 1])\n-                                                                                                                                                                                                                      as\n-                                                                                                                                                                                                                      &[&str; 1]),\n-                                                                                                                                                                                                                  (&(match (()\n+                                                                                                                                                                                                                        &[&str; 1]),\n+                                                                                                                                                                                                                    (&(match (()\n+                                                                                                                                                                                                                                 as\n+                                                                                                                                                                                                                                 ())\n+                                                                                                                                                                                                                           {\n+                                                                                                                                                                                                                           ()\n+                                                                                                                                                                                                                           =>\n+                                                                                                                                                                                                                           ([]\n                                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                               ())\n-                                                                                                                                                                                                                         {\n-                                                                                                                                                                                                                         ()\n-                                                                                                                                                                                                                         =>\n-                                                                                                                                                                                                                         ([]\n-                                                                                                                                                                                                                             as\n-                                                                                                                                                                                                                             [std::fmt::ArgumentV1<'_>; 0]),\n-                                                                                                                                                                                                                     }\n+                                                                                                                                                                                                                               [std::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                                       }\n+                                                                                                                                                                                                                          as\n+                                                                                                                                                                                                                          [std::fmt::ArgumentV1<'_>; 0])\n                                                                                                                                                                                                                         as\n-                                                                                                                                                                                                                        [std::fmt::ArgumentV1<'_>; 0])\n-                                                                                                                                                                                                                      as\n-                                                                                                                                                                                                                      &[std::fmt::ArgumentV1<'_>; 0]))\n+                                                                                                                                                                                                                        &[std::fmt::ArgumentV1<'_>; 0]))\n                                                                                                           as\n                                                                                                           std::fmt::Arguments<'_>))\n                       as std::string::String);"}, {"sha": "31d2c5f318e5056cc22cdb55f399f11985bfea34", "filename": "src/test/ui/associated-types/associated-types-eq-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -29,7 +29,7 @@ LL |     baz(&a);\n    |\n    = note: expected type `usize`\n               found type `Bar`\n-   = note: required for the cast to the object type `dyn Foo<A=Bar>`\n+   = note: required for the cast to the object type `dyn Foo<A = Bar>`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "ad0b6515490b973e7c3b8534a3243246445ebae1", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -6,7 +6,7 @@ LL |     let _: &I32Iterator<Item = u32> = &vec![42].into_iter();\n    |\n    = note: expected type `u32`\n               found type `i32`\n-   = note: required for the cast to the object type `dyn I32Iterator<Item=u32, Item=i32>`\n+   = note: required for the cast to the object type `dyn I32Iterator<Item = u32, Item = i32>`\n \n error: aborting due to previous error\n "}, {"sha": "51b84745552938e6df88bd7138204c1a930f9100", "filename": "src/test/ui/bad/bad-sized.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -22,7 +22,7 @@ LL |     let x: Vec<Trait + Sized> = Vec::new();\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `dyn Trait`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = note: required by `<std::vec::Vec<T>>::new`\n+   = note: required by `std::vec::Vec::<T>::new`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "456a4c18e2b3020e882d7a133517fffab68ec75b", "filename": "src/test/ui/confuse-field-and-method/issue-2392.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-2392.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-2392.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-2392.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -75,7 +75,7 @@ LL |     w.wrap.not_closure();\n    |\n    = help: did you mean to write `w.wrap.not_closure` instead of `w.wrap.not_closure(...)`?\n \n-error[E0599]: no method named `closure` found for type `Obj<std::boxed::Box<(dyn std::boxed::FnBox<(), Output=u32> + 'static)>>` in the current scope\n+error[E0599]: no method named `closure` found for type `Obj<std::boxed::Box<(dyn std::boxed::FnBox<(), Output = u32> + 'static)>>` in the current scope\n   --> $DIR/issue-2392.rs:62:24\n    |\n LL | struct Obj<F> where F: FnOnce() -> u32 {"}, {"sha": "3762f5e3d6ad8b27cd2601f0ce2ca95475ea50bd", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,22 +1,22 @@\n-error[E0391]: cycle detected when const-evaluating + checking `Foo::bytes::{{constant}}`\n+error[E0391]: cycle detected when const-evaluating + checking `Foo::bytes::{{constant}}#0`\n   --> $DIR/const-size_of-cycle.rs:6:17\n    |\n LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: ...which requires const-evaluating `Foo::bytes::{{constant}}`...\n+note: ...which requires const-evaluating `Foo::bytes::{{constant}}#0`...\n   --> $SRC_DIR/libcore/mem.rs:LL:COL\n    |\n LL |     intrinsics::size_of::<T>()\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires computing layout of `Foo`...\n    = note: ...which requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All, def_id: None }, value: [u8; _] }`...\n-note: ...which requires const-evaluating + checking `Foo::bytes::{{constant}}`...\n+note: ...which requires const-evaluating + checking `Foo::bytes::{{constant}}#0`...\n   --> $DIR/const-size_of-cycle.rs:6:17\n    |\n LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires const-evaluating + checking `Foo::bytes::{{constant}}`, completing the cycle\n+   = note: ...which again requires const-evaluating + checking `Foo::bytes::{{constant}}#0`, completing the cycle\n note: cycle used when processing `Foo`\n   --> $DIR/const-size_of-cycle.rs:5:1\n    |"}, {"sha": "7ede44c65b83a0479aaf7a7c786a24eb6b5056bb", "filename": "src/test/ui/consts/miri_unleashed/feature-gate-unleash_the_miri_inside_of_you.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -4,7 +4,7 @@ error[E0493]: destructors cannot be evaluated at compile-time\n LL |     const F: u32 = (U::X, 42).1;\n    |                    ^^^^^^^^^^ constants cannot evaluate destructors\n \n-error: `<std::vec::Vec<T>>::new` is not yet stable as a const fn\n+error: `std::vec::Vec::<T>::new` is not yet stable as a const fn\n   --> $DIR/feature-gate-unleash_the_miri_inside_of_you.rs:18:25\n    |\n LL |     const X: Vec<u32> = Vec::new();"}, {"sha": "26271395005a782d617020c94d0caad03ded82c4", "filename": "src/test/ui/deprecation/deprecation-lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -314,7 +314,7 @@ mod this_crate {\n         let _ = || {\n             #[deprecated]\n             fn bar() { }\n-            bar(); //~ ERROR use of deprecated item 'this_crate::test_fn_closure_body::{{closure}}::bar'\n+            bar(); //~ ERROR use of deprecated item 'this_crate::test_fn_closure_body::{{closure}}#0::bar'\n         };\n     }\n "}, {"sha": "ffbcb259754e77309b8207319e5616718e732658", "filename": "src/test/ui/deprecation/deprecation-lint.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -298,7 +298,7 @@ error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n LL |         <Foo as Trait>::trait_deprecated_text(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::test_fn_closure_body::{{closure}}::bar'\n+error: use of deprecated item 'this_crate::test_fn_closure_body::{{closure}}#0::bar'\n   --> $DIR/deprecation-lint.rs:317:13\n    |\n LL |             bar();"}, {"sha": "4e79dfc3f7c01cb55989d766ab3710bca1c7bc98", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,4 +1,4 @@\n-error[E0391]: cycle detected when processing `cycle1::{{impl-Trait}}`\n+error[E0391]: cycle detected when processing `cycle1::{{opaque}}#0`\n   --> $DIR/auto-trait-leak.rs:14:16\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -10,7 +10,7 @@ note: ...which requires processing `cycle1`...\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-note: ...which requires processing `cycle2::{{impl-Trait}}`...\n+note: ...which requires processing `cycle2::{{opaque}}#0`...\n   --> $DIR/auto-trait-leak.rs:23:16\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -21,7 +21,7 @@ note: ...which requires processing `cycle2`...\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-   = note: ...which again requires processing `cycle1::{{impl-Trait}}`, completing the cycle\n+   = note: ...which again requires processing `cycle1::{{opaque}}#0`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/auto-trait-leak.rs:3:1\n    |\n@@ -34,7 +34,7 @@ LL | |     Rc::new(String::from(\"foo\"))\n LL | | }\n    | |_^\n \n-error[E0391]: cycle detected when processing `cycle1::{{impl-Trait}}`\n+error[E0391]: cycle detected when processing `cycle1::{{opaque}}#0`\n   --> $DIR/auto-trait-leak.rs:14:16\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -46,7 +46,7 @@ note: ...which requires processing `cycle1`...\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-note: ...which requires processing `cycle2::{{impl-Trait}}`...\n+note: ...which requires processing `cycle2::{{opaque}}#0`...\n   --> $DIR/auto-trait-leak.rs:23:16\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -56,7 +56,7 @@ note: ...which requires processing `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires processing `cycle1::{{impl-Trait}}`, completing the cycle\n+   = note: ...which again requires processing `cycle1::{{opaque}}#0`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/auto-trait-leak.rs:3:1\n    |"}, {"sha": "da3e2e763af582788b4a1a8ca67b287680b30218", "filename": "src/test/ui/issues/issue-17252.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -5,7 +5,7 @@ LL | const FOO: usize = FOO;\n    |                    ^^^\n    |\n    = note: ...which again requires processing `FOO`, completing the cycle\n-note: cycle used when processing `main::{{constant}}`\n+note: cycle used when processing `main::{{constant}}#0`\n   --> $DIR/issue-17252.rs:4:18\n    |\n LL |     let _x: [u8; FOO]; // caused stack overflow prior to fix"}, {"sha": "ce9af1524b0879e18c663cb82d68ef8f9b0d21a2", "filename": "src/test/ui/issues/issue-17651.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -6,7 +6,7 @@ LL |     (|| Box::new(*(&[0][..])))();\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[{integer}]`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = note: required by `<std::boxed::Box<T>>::new`\n+   = note: required by `std::boxed::Box::<T>::new`\n \n error: aborting due to previous error\n "}, {"sha": "e3909e0c1253f3fdedf97fa095bb45c6013240fd", "filename": "src/test/ui/issues/issue-17905-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched method receiver\n LL |     fn say(self: &Pair<&str, isize>) {\n    |                  ^^^^^^^^^^^^^^^^^^ lifetime mismatch\n    |\n-   = note: expected type `Pair<&'_ str, _>`\n+   = note: expected type `Pair<&str, _>`\n               found type `Pair<&str, _>`\n note: the anonymous lifetime #2 defined on the method body at 8:5...\n   --> $DIR/issue-17905-2.rs:8:5\n@@ -27,7 +27,7 @@ error[E0308]: mismatched method receiver\n LL |     fn say(self: &Pair<&str, isize>) {\n    |                  ^^^^^^^^^^^^^^^^^^ lifetime mismatch\n    |\n-   = note: expected type `Pair<&'_ str, _>`\n+   = note: expected type `Pair<&str, _>`\n               found type `Pair<&str, _>`\n note: the lifetime '_ as defined on the impl at 5:5...\n   --> $DIR/issue-17905-2.rs:5:5"}, {"sha": "89df58dd2dc1b19825bda7393282ad0a86710879", "filename": "src/test/ui/issues/issue-20605.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-20605.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-20605.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20605.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,10 +1,10 @@\n-error[E0277]: the size for values of type `dyn std::iter::Iterator<Item=&mut u8>` cannot be known at compilation time\n+error[E0277]: the size for values of type `dyn std::iter::Iterator<Item = &mut u8>` cannot be known at compilation time\n   --> $DIR/issue-20605.rs:2:17\n    |\n LL |     for item in *things { *item = 0 }\n    |                 ^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = help: the trait `std::marker::Sized` is not implemented for `dyn std::iter::Iterator<Item=&mut u8>`\n+   = help: the trait `std::marker::Sized` is not implemented for `dyn std::iter::Iterator<Item = &mut u8>`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required by `std::iter::IntoIterator::into_iter`\n "}, {"sha": "e20869a6f3a7584c999f317d0b0b7ca026eb1cd5", "filename": "src/test/ui/issues/issue-20831-debruijn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -11,7 +11,7 @@ LL | |     }\n    | |_____^ lifetime mismatch\n    |\n    = note: expected type `'a`\n-              found type ``\n+              found type `'_`\n note: the anonymous lifetime #2 defined on the method body at 28:5...\n   --> $DIR/issue-20831-debruijn.rs:28:5\n    |\n@@ -42,7 +42,7 @@ LL | |     }\n    | |_____^ lifetime mismatch\n    |\n    = note: expected type `'a`\n-              found type ``\n+              found type `'_`\n note: the lifetime 'a as defined on the impl at 26:6...\n   --> $DIR/issue-20831-debruijn.rs:26:6\n    |"}, {"sha": "6a012b214c504a6a0ccfa183092dd9c582717a3e", "filename": "src/test/ui/issues/issue-22312.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-22312.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-22312.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22312.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,4 +1,4 @@\n-error[E0605]: non-primitive cast: `Self` as `&dyn std::ops::Index<usize, Output=<Self as std::ops::Index<usize>>::Output>`\n+error[E0605]: non-primitive cast: `Self` as `&dyn std::ops::Index<usize, Output = <Self as std::ops::Index<usize>>::Output>`\n   --> $DIR/issue-22312.rs:11:24\n    |\n LL |         let indexer = &(*self as &Index<usize, Output = <Self as Index<usize>>::Output>);"}, {"sha": "b60e1c29ec0ee1eac4d1e1f88c9b3b9c0e0407db", "filename": "src/test/ui/issues/issue-22638.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -8,7 +8,7 @@ LL | |         a.matches(f)\n LL | |     }\n    | |_____^\n    |\n-   = note: consider adding a `#![type_length_limit=\"40000000\"]` attribute to your crate\n+   = note: consider adding a `#![type_length_limit=\"26214380\"]` attribute to your crate\n \n error: aborting due to previous error\n "}, {"sha": "43effc0b3b9748ec4c1476ccda7ebba5800d4708", "filename": "src/test/ui/issues/issue-23302-1.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,11 +1,11 @@\n-error[E0391]: cycle detected when processing `X::A::{{constant}}`\n+error[E0391]: cycle detected when processing `X::A::{{constant}}#0`\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `X::A::{{constant}}`, completing the cycle\n-note: cycle used when const-evaluating `X::A::{{constant}}`\n+   = note: ...which again requires processing `X::A::{{constant}}#0`, completing the cycle\n+note: cycle used when const-evaluating `X::A::{{constant}}#0`\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,"}, {"sha": "707d4fa7ed3f781a38af85f4f95bcb121775ff43", "filename": "src/test/ui/issues/issue-23302-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,11 +1,11 @@\n-error[E0391]: cycle detected when processing `Y::A::{{constant}}`\n+error[E0391]: cycle detected when processing `Y::A::{{constant}}#0`\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `Y::A::{{constant}}`, completing the cycle\n-note: cycle used when const-evaluating `Y::A::{{constant}}`\n+   = note: ...which again requires processing `Y::A::{{constant}}#0`, completing the cycle\n+note: cycle used when const-evaluating `Y::A::{{constant}}#0`\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,"}, {"sha": "4c3f726180dfee8aec10c9414b5959d7ac3b6b79", "filename": "src/test/ui/issues/issue-36163.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,4 +1,4 @@\n-error[E0391]: cycle detected when processing `Foo::B::{{constant}}`\n+error[E0391]: cycle detected when processing `Foo::B::{{constant}}#0`\n   --> $DIR/issue-36163.rs:4:9\n    |\n LL |     B = A,\n@@ -9,8 +9,8 @@ note: ...which requires processing `A`...\n    |\n LL | const A: isize = Foo::B as isize;\n    |                  ^^^^^^^^^^^^^^^\n-   = note: ...which again requires processing `Foo::B::{{constant}}`, completing the cycle\n-note: cycle used when const-evaluating `Foo::B::{{constant}}`\n+   = note: ...which again requires processing `Foo::B::{{constant}}#0`, completing the cycle\n+note: cycle used when const-evaluating `Foo::B::{{constant}}#0`\n   --> $DIR/issue-36163.rs:4:9\n    |\n LL |     B = A,"}, {"sha": "aead415d23f84bf2875b33c1c0a6c0f85aacd289", "filename": "src/test/ui/issues/issue-37311-type-length-limit/issue-37311.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,12 +1,12 @@\n-error: reached the type-length limit while instantiating `<T as Foo><(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(), &()), &(&()...`\n+error: reached the type-length limit while instantiating `<(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(...))))))))))))))) as Foo>::recurse`\n   --> $DIR/issue-37311.rs:13:5\n    |\n LL | /     fn recurse(&self) {\n LL | |         (self, self).recurse();\n LL | |     }\n    | |_____^\n    |\n-   = note: consider adding a `#![type_length_limit=\"2097152\"]` attribute to your crate\n+   = note: consider adding a `#![type_length_limit=\"2097149\"]` attribute to your crate\n \n error: aborting due to previous error\n "}, {"sha": "df8e804c87a3f706a5b2246fcac43dcbbd74d75a", "filename": "src/test/ui/issues/issue-44415.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-44415.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-44415.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44415.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,22 +1,22 @@\n-error[E0391]: cycle detected when const-evaluating + checking `Foo::bytes::{{constant}}`\n+error[E0391]: cycle detected when const-evaluating + checking `Foo::bytes::{{constant}}#0`\n   --> $DIR/issue-44415.rs:6:17\n    |\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n    |                 ^^^^^^\n    |\n-note: ...which requires const-evaluating `Foo::bytes::{{constant}}`...\n+note: ...which requires const-evaluating `Foo::bytes::{{constant}}#0`...\n   --> $DIR/issue-44415.rs:6:26\n    |\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires computing layout of `Foo`...\n    = note: ...which requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All, def_id: None }, value: [u8; _] }`...\n-note: ...which requires const-evaluating + checking `Foo::bytes::{{constant}}`...\n+note: ...which requires const-evaluating + checking `Foo::bytes::{{constant}}#0`...\n   --> $DIR/issue-44415.rs:6:17\n    |\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n    |                 ^^^^^^\n-   = note: ...which again requires const-evaluating + checking `Foo::bytes::{{constant}}`, completing the cycle\n+   = note: ...which again requires const-evaluating + checking `Foo::bytes::{{constant}}#0`, completing the cycle\n note: cycle used when processing `Foo`\n   --> $DIR/issue-44415.rs:5:1\n    |"}, {"sha": "7cf597d3a98f81b5d2c1c2448a4504b53478b1f1", "filename": "src/test/ui/issues/issue-55796.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -16,8 +16,8 @@ LL |         Box::new(self.out_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: but, the lifetime must be valid for the static lifetime...\n    = note: ...so that the expression is assignable:\n-           expected std::boxed::Box<(dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node> + 'static)>\n-              found std::boxed::Box<dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node>>\n+           expected std::boxed::Box<(dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node> + 'static)>\n+              found std::boxed::Box<dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node>>\n \n error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n   --> $DIR/issue-55796.rs:21:9\n@@ -37,8 +37,8 @@ LL |         Box::new(self.in_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: but, the lifetime must be valid for the static lifetime...\n    = note: ...so that the expression is assignable:\n-           expected std::boxed::Box<(dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node> + 'static)>\n-              found std::boxed::Box<dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node>>\n+           expected std::boxed::Box<(dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node> + 'static)>\n+              found std::boxed::Box<dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node>>\n \n error: aborting due to 2 previous errors\n "}, {"sha": "99fa3b96794827ee5c0922fd16498cf271607788", "filename": "src/test/ui/namespace/namespace-mix.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fnamespace%2Fnamespace-mix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fnamespace%2Fnamespace-mix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnamespace%2Fnamespace-mix.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -462,11 +462,11 @@ note: required by `check`\n LL | fn check<T: Impossible>(_: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0277]: the trait bound `fn() -> namespace_mix::c::E {namespace_mix::c::E::TV}: Impossible` is not satisfied\n+error[E0277]: the trait bound `fn() -> namespace_mix::c::E {namespace_mix::xm7::TV}: Impossible` is not satisfied\n   --> $DIR/namespace-mix.rs:128:5\n    |\n LL |     check(xm9::TV);\n-   |     ^^^^^ the trait `Impossible` is not implemented for `fn() -> namespace_mix::c::E {namespace_mix::c::E::TV}`\n+   |     ^^^^^ the trait `Impossible` is not implemented for `fn() -> namespace_mix::c::E {namespace_mix::xm7::TV}`\n    |\n note: required by `check`\n   --> $DIR/namespace-mix.rs:21:1"}, {"sha": "46de13dbbbd9bbe944fd2c92781e4f1c77292fd8", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -16,7 +16,7 @@ LL |         let mut closure = expect_sig(|p, y| *p = y);\n    |                                       -  -  ^^^^^^ assignment requires that `'1` must outlive `'2`\n    |                                       |  |\n    |                                       |  has type `&'1 i32`\n-   |                                       has type `&mut &'2 i32`\n+   |                                       has type `&'_#2r mut &'2 i32`\n \n note: No external requirements\n   --> $DIR/escape-argument-callee.rs:20:1"}, {"sha": "7eb4d96fc5f752c50901280f907cd7547531d86e", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -20,9 +20,9 @@ error: lifetime may not live long enough\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:46:13\n    |\n LL |         |_outlives1, _outlives2, _outlives3, x, y| {\n-   |          ----------              ---------- has type `std::cell::Cell<&'2 &u32>`\n+   |          ----------              ---------- has type `std::cell::Cell<&'2 &'_#3r u32>`\n    |          |\n-   |          has type `std::cell::Cell<&&'1 u32>`\n+   |          has type `std::cell::Cell<&'_#1r &'1 u32>`\n ...\n LL |             demand_y(x, y, p)\n    |             ^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`"}, {"sha": "f8b6bfa003b32fc6a4da19cd6f66c4269926ffda", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -20,9 +20,9 @@ error: lifetime may not live long enough\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:37:9\n    |\n LL |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-   |                                                ---------  - has type `&std::cell::Cell<&'1 u32>`\n+   |                                                ---------  - has type `&'_#7r std::cell::Cell<&'1 u32>`\n    |                                                |\n-   |                                                has type `&std::cell::Cell<&'2 &u32>`\n+   |                                                has type `&'_#5r std::cell::Cell<&'2 &'_#1r u32>`\n LL |         // Only works if 'x: 'y:\n LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`"}, {"sha": "7e7429405fa068d5434e5c20d055744451b07fb8", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -20,9 +20,9 @@ error: lifetime may not live long enough\n   --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:41:9\n    |\n LL |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-   |                                                ----------  ---------- has type `&std::cell::Cell<&'2 &u32>`\n+   |                                                ----------  ---------- has type `&'_#8r std::cell::Cell<&'2 &'_#2r u32>`\n    |                                                |\n-   |                                                has type `&std::cell::Cell<&'1 &u32>`\n+   |                                                has type `&'_#6r std::cell::Cell<&'1 &'_#1r u32>`\n LL |         // Only works if 'x: 'y:\n LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`"}, {"sha": "39f2e5d4af2aaeb7fad5185640a0dd1b907875e5", "filename": "src/test/ui/privacy/private-inferred-type-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -6,7 +6,7 @@\n // error-pattern:type `fn() {<u8 as ext::PrivTrait>::method}` is private\n // error-pattern:type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct}` is private\n // error-pattern:type `fn(u8) -> ext::PubTupleStruct {ext::PubTupleStruct}` is private\n-// error-pattern:type `for<'r> fn(&'r ext::Pub<u8>) {<ext::Pub<u8>>::priv_method}` is private\n+// error-pattern:type `for<'r> fn(&'r ext::Pub<u8>) {ext::Pub::<u8>::priv_method}` is private\n \n #![feature(decl_macro)]\n "}, {"sha": "61cd84762978c6e4ee2ff691db53b405c8ce7df4", "filename": "src/test/ui/privacy/private-inferred-type-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -46,7 +46,7 @@ LL |     ext::m!();\n    |\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: type `for<'r> fn(&'r ext::Pub<u8>) {<ext::Pub<u8>>::priv_method}` is private\n+error: type `for<'r> fn(&'r ext::Pub<u8>) {ext::Pub::<u8>::priv_method}` is private\n   --> $DIR/private-inferred-type-3.rs:16:5\n    |\n LL |     ext::m!();"}, {"sha": "d9bb421b53f8c5ccf9d10b2a2741d0bd37492f00", "filename": "src/test/ui/privacy/private-inferred-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -47,7 +47,7 @@ mod m {\n         PubTupleStruct;\n         //~^ ERROR type `fn(u8) -> m::PubTupleStruct {m::PubTupleStruct}` is private\n         Pub(0u8).priv_method();\n-        //~^ ERROR type `for<'r> fn(&'r m::Pub<u8>) {<m::Pub<u8>>::priv_method}` is private\n+        //~^ ERROR type `for<'r> fn(&'r m::Pub<u8>) {m::Pub::<u8>::priv_method}` is private\n     }\n \n     trait Trait {}"}, {"sha": "4d40b6b7cab32962d78808f5c85dee662eb525eb", "filename": "src/test/ui/privacy/private-inferred-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -151,7 +151,7 @@ LL |         PubTupleStruct;\n LL |     m::m!();\n    |     -------- in this macro invocation\n \n-error: type `for<'r> fn(&'r m::Pub<u8>) {<m::Pub<u8>>::priv_method}` is private\n+error: type `for<'r> fn(&'r m::Pub<u8>) {m::Pub::<u8>::priv_method}` is private\n   --> $DIR/private-inferred-type.rs:49:18\n    |\n LL |         Pub(0u8).priv_method();"}, {"sha": "ac5e5e9aabc5bfa41e98ed87d428c99ec2ec8b50", "filename": "src/test/ui/regions/regions-addr-of-upvar-self.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for borrow expression due to\n LL |             let p: &'static mut usize = &mut self.food;\n    |                                         ^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime  as defined on the body at 9:18...\n+note: first, the lifetime cannot outlive the lifetime '_ as defined on the body at 9:18...\n   --> $DIR/regions-addr-of-upvar-self.rs:9:18\n    |\n LL |         let _f = || {"}, {"sha": "be441bc48082ed16a97865d3c625d1c8696987cc", "filename": "src/test/ui/regions/regions-return-ref-to-upvar-issue-17403.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -4,7 +4,7 @@ error[E0495]: cannot infer an appropriate lifetime for borrow expression due to\n LL |         let mut f = || &mut x;\n    |                        ^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime  as defined on the body at 7:21...\n+note: first, the lifetime cannot outlive the lifetime '_ as defined on the body at 7:21...\n   --> $DIR/regions-return-ref-to-upvar-issue-17403.rs:7:21\n    |\n LL |         let mut f = || &mut x;"}, {"sha": "a1169910ae7e2acafeff6ecaf45ecf7ad40f4f8a", "filename": "src/test/ui/retslot-cast.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fretslot-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fretslot-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fretslot-cast.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -2,10 +2,10 @@ error[E0308]: mismatched types\n   --> $DIR/retslot-cast.rs:13:5\n    |\n LL |     inner(x)\n-   |     ^^^^^^^^ expected trait `std::iter::Iterator<Item=()>`, found trait `std::iter::Iterator<Item=()> + std::marker::Send`\n+   |     ^^^^^^^^ expected trait `std::iter::Iterator<Item = ()>`, found trait `std::iter::Iterator<Item = ()> + std::marker::Send`\n    |\n-   = note: expected type `std::option::Option<&dyn std::iter::Iterator<Item=()>>`\n-              found type `std::option::Option<&dyn std::iter::Iterator<Item=()> + std::marker::Send>`\n+   = note: expected type `std::option::Option<&dyn std::iter::Iterator<Item = ()>>`\n+              found type `std::option::Option<&dyn std::iter::Iterator<Item = ()> + std::marker::Send>`\n \n error: aborting due to previous error\n "}, {"sha": "129ebd43594cedfaae8444ed68fe71595621e66b", "filename": "src/test/ui/substs-ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsubsts-ppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsubsts-ppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsubsts-ppaux.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -25,7 +25,7 @@ fn foo<'z>() where &'z (): Sized {\n     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;\n     //[verbose]~^ ERROR mismatched types\n     //[verbose]~| expected type `()`\n-    //[verbose]~| found type `fn() {<i8 as Foo<ReStatic, ReStatic, u32>>::bar::<ReStatic, char>}`\n+    //[verbose]~| found type `fn() {<i8 as Foo<ReStatic, ReStatic>>::bar::<ReStatic, char>}`\n     //[normal]~^^^^ ERROR mismatched types\n     //[normal]~| expected type `()`\n     //[normal]~| found type `fn() {<i8 as Foo<'static, 'static>>::bar::<'static, char>}`"}, {"sha": "86936475f8c145d2a32bde3238c4424ddaf6483a", "filename": "src/test/ui/substs-ppaux.verbose.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsubsts-ppaux.verbose.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsubsts-ppaux.verbose.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsubsts-ppaux.verbose.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -14,7 +14,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found fn item\n    |\n    = note: expected type `()`\n-              found type `fn() {<i8 as Foo<ReStatic, ReStatic, u32>>::bar::<ReStatic, char>}`\n+              found type `fn() {<i8 as Foo<ReStatic, ReStatic>>::bar::<ReStatic, char>}`\n \n error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:33:17"}, {"sha": "086b903b973b0b017dc7c437379a03ee6793bda1", "filename": "src/test/ui/symbol-names/basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,6 +1,6 @@\n #![feature(rustc_attrs)]\n \n #[rustc_symbol_name] //~ ERROR _ZN5basic4main\n-#[rustc_item_path] //~ ERROR item-path(main)\n+#[rustc_def_path] //~ ERROR def-path(main)\n fn main() {\n }"}, {"sha": "6ddd93d632e151d1710b1d3419653d2fa7509f38", "filename": "src/test/ui/symbol-names/basic.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -4,11 +4,11 @@ error: symbol-name(_ZN5basic4main17h08bcaf310214ed52E)\n LL | #[rustc_symbol_name]\n    | ^^^^^^^^^^^^^^^^^^^^\n \n-error: item-path(main)\n+error: def-path(main)\n   --> $DIR/basic.rs:4:1\n    |\n-LL | #[rustc_item_path]\n-   | ^^^^^^^^^^^^^^^^^^\n+LL | #[rustc_def_path]\n+   | ^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c712137e828f94e1d4e2ee8d6ce13b6cd716c944", "filename": "src/test/ui/symbol-names/impl1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -6,7 +6,7 @@ mod foo {\n \n     impl Foo {\n         #[rustc_symbol_name] //~ ERROR _ZN5impl13foo3Foo3bar\n-        #[rustc_item_path] //~ ERROR item-path(foo::Foo::bar)\n+        #[rustc_def_path] //~ ERROR def-path(foo::Foo::bar)\n         fn bar() { }\n     }\n }\n@@ -16,7 +16,7 @@ mod bar {\n \n     impl Foo {\n         #[rustc_symbol_name] //~ ERROR _ZN5impl13bar33_$LT$impl$u20$impl1..foo..Foo$GT$3baz\n-        #[rustc_item_path] //~ ERROR item-path(bar::<impl foo::Foo>::baz)\n+        #[rustc_def_path] //~ ERROR def-path(bar::<impl foo::Foo>::baz)\n         fn baz() { }\n     }\n }"}, {"sha": "eda8646b5b4de1f035fbf03a7bbe5766bbf51acc", "filename": "src/test/ui/symbol-names/impl1.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -4,23 +4,23 @@ error: symbol-name(_ZN5impl13foo3Foo3bar17hc487d6ec13fe9124E)\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: item-path(foo::Foo::bar)\n+error: def-path(foo::Foo::bar)\n   --> $DIR/impl1.rs:9:9\n    |\n-LL |         #[rustc_item_path]\n-   |         ^^^^^^^^^^^^^^^^^^\n+LL |         #[rustc_def_path]\n+   |         ^^^^^^^^^^^^^^^^^\n \n error: symbol-name(_ZN5impl13bar33_$LT$impl$u20$impl1..foo..Foo$GT$3baz17h38577281258e1527E)\n   --> $DIR/impl1.rs:18:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: item-path(bar::<impl foo::Foo>::baz)\n+error: def-path(bar::<impl foo::Foo>::baz)\n   --> $DIR/impl1.rs:19:9\n    |\n-LL |         #[rustc_item_path]\n-   |         ^^^^^^^^^^^^^^^^^^\n+LL |         #[rustc_def_path]\n+   |         ^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "cd15f81a615355dda6dae175ceded2755aa4177d", "filename": "src/test/ui/type_length_limit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Ftype_length_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Ftype_length_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype_length_limit.rs?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,3 +1,5 @@\n+// ignore-musl\n+// ignore-x86\n // error-pattern: reached the type-length limit while instantiating\n \n // Test that the type length limit can be changed."}, {"sha": "9d07c86356b67ed80ad99176621926cfe57fd0f5", "filename": "src/test/ui/type_length_limit.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype_length_limit.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,6 +1,10 @@\n-error: reached the type-length limit while instantiating `std::mem::drop::<std::option::Option<((((((G, G, G), (G, G, G), ...`\n+error: reached the type-length limit while instantiating `std::mem::drop::<std::option::Op... G), (G, G, G), (G, G, G))))))>>`\n+  --> $SRC_DIR/libcore/mem.rs:LL:COL\n    |\n-   = note: consider adding a `#![type_length_limit=\"512\"]` attribute to your crate\n+LL | pub fn drop<T>(_x: T) { }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: consider adding a `#![type_length_limit=\"1094\"]` attribute to your crate\n \n error: aborting due to previous error\n "}, {"sha": "d41086186f8d7826cc4f33c1b8c1d4adc14ddf00", "filename": "src/test/ui/typeck/issue-57673-ice-on-deref-of-boxed-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Ftypeck%2Fissue-57673-ice-on-deref-of-boxed-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Ftypeck%2Fissue-57673-ice-on-deref-of-boxed-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-57673-ice-on-deref-of-boxed-trait.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -7,7 +7,7 @@ LL |     *x\n    |     ^^ expected (), found trait std::iter::Iterator\n    |\n    = note: expected type `()`\n-              found type `(dyn std::iter::Iterator<Item=()> + 'static)`\n+              found type `(dyn std::iter::Iterator<Item = ()> + 'static)`\n \n error: aborting due to previous error\n "}, {"sha": "ce90f5b9d2486b61cc584b88f13193bc5b955305", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-default.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,8 +1,8 @@\n-error[E0277]: the trait bound `dyn Foo<(isize,), isize, Output=()>: Eq<dyn Foo<(isize,), Output=()>>` is not satisfied\n+error[E0277]: the trait bound `dyn Foo<(isize,), isize, Output = ()>: Eq<dyn Foo<(isize,), Output = ()>>` is not satisfied\n   --> $DIR/unboxed-closure-sugar-default.rs:21:5\n    |\n LL |     eq::< Foo<(isize,),isize,Output=()>,      Foo(isize)                      >();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Eq<dyn Foo<(isize,), Output=()>>` is not implemented for `dyn Foo<(isize,), isize, Output=()>`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Eq<dyn Foo<(isize,), Output = ()>>` is not implemented for `dyn Foo<(isize,), isize, Output = ()>`\n    |\n note: required by `eq`\n   --> $DIR/unboxed-closure-sugar-default.rs:14:1"}, {"sha": "857a32ca69e73a49b309f25654e65115eed6f4bf", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-equiv.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-equiv.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-equiv.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-equiv.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -1,9 +1,9 @@\n-error[E0277]: the trait bound `dyn Foo<(char,), Output=()>: Eq<dyn Foo<(), Output=()>>` is not satisfied\n+error[E0277]: the trait bound `dyn Foo<(char,), Output = ()>: Eq<dyn Foo<(), Output = ()>>` is not satisfied\n   --> $DIR/unboxed-closure-sugar-equiv.rs:43:5\n    |\n LL | /     eq::< Foo<(),Output=()>,\n LL | |           Foo(char)                                               >();\n-   | |___________________________________________________________________^ the trait `Eq<dyn Foo<(), Output=()>>` is not implemented for `dyn Foo<(char,), Output=()>`\n+   | |___________________________________________________________________^ the trait `Eq<dyn Foo<(), Output = ()>>` is not implemented for `dyn Foo<(char,), Output = ()>`\n    |\n note: required by `eq`\n   --> $DIR/unboxed-closure-sugar-equiv.rs:16:1"}, {"sha": "d0475bf08c38d2bb8fe602ac25f40ae2e1af2b4b", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr?ref=ad8a3eb039ca3dc1ff5a3d5757afc5e5330c1bce", "patch": "@@ -19,8 +19,8 @@ LL |     Box::new(items.iter())\n    |              ^^^^^\n    = note: but, the lifetime must be valid for the static lifetime...\n    = note: ...so that the expression is assignable:\n-           expected std::boxed::Box<(dyn std::iter::Iterator<Item=&T> + 'static)>\n-              found std::boxed::Box<dyn std::iter::Iterator<Item=&T>>\n+           expected std::boxed::Box<(dyn std::iter::Iterator<Item = &T> + 'static)>\n+              found std::boxed::Box<dyn std::iter::Iterator<Item = &T>>\n \n error: aborting due to previous error\n "}]}