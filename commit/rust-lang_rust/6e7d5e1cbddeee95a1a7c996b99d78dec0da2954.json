{"sha": "6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlN2Q1ZTFjYmRkZWVlOTVhMWE3Yzk5NmI5OWQ3OGRlYzBkYTI5NTQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-31T18:19:07Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-31T18:20:50Z"}, "message": "rustc: Implement \"use mod\"", "tree": {"sha": "1adc1f94f8f3888132261b4e26055586fac30d8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1adc1f94f8f3888132261b4e26055586fac30d8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "html_url": "https://github.com/rust-lang/rust/commit/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28b1473f8472099260d2b76422e7df49de0e01a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/28b1473f8472099260d2b76422e7df49de0e01a1", "html_url": "https://github.com/rust-lang/rust/commit/28b1473f8472099260d2b76422e7df49de0e01a1"}], "stats": {"total": 398, "additions": 296, "deletions": 102}, "files": [{"sha": "693fc4df5d027e7f24316f33b8fad373e5103edb", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "patch": "@@ -1109,6 +1109,15 @@ type path_list_ident_ = {name: ident, id: node_id};\n #[auto_serialize]\n type path_list_ident = spanned<path_list_ident_>;\n \n+#[auto_serialize]\n+enum namespace { module_ns, type_value_ns }\n+\n+impl namespace : cmp::Eq {\n+    pure fn eq(&&other: namespace) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n #[auto_serialize]\n type view_path = spanned<view_path_>;\n \n@@ -1120,7 +1129,7 @@ enum view_path_ {\n     // or just\n     //\n     // foo::bar::baz  (with 'baz =' implicitly on the left)\n-    view_path_simple(ident, @path, node_id),\n+    view_path_simple(ident, @path, namespace, node_id),\n \n     // foo::bar::*\n     view_path_glob(@path, node_id),\n@@ -1152,12 +1161,7 @@ enum attr_style { attr_outer, attr_inner, }\n \n impl attr_style : cmp::Eq {\n     pure fn eq(&&other: attr_style) -> bool {\n-        match (self, other) {\n-            (attr_outer, attr_outer) => true,\n-            (attr_inner, attr_inner) => true,\n-            (attr_outer, _) => false,\n-            (attr_inner, _) => false,\n-        }\n+        (self as uint) == (other as uint)\n     }\n }\n "}, {"sha": "e377707ece793571c067ccadd9ff9bd671a49857", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "patch": "@@ -293,7 +293,7 @@ fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n     match vi.node {\n       view_item_export(vps) => for vps.each |vp| {\n         let (id, name) = match vp.node {\n-          view_path_simple(nm, _, id) => {\n+          view_path_simple(nm, _, _, id) => {\n             (id, /* FIXME (#2543) */ copy nm)\n           }\n           view_path_glob(pth, id) | view_path_list(pth, _, id) => {"}, {"sha": "3badb0fbfcecdde3eb5439d8852edc87b31a2862", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "patch": "@@ -211,7 +211,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n             has_explicit_exports = true;\n             for vps.each |vp| {\n                 match vp.node {\n-                  ast::view_path_simple(id, _, _) => {\n+                  ast::view_path_simple(id, _, _, _) => {\n                     if id == i { return true; }\n                     match parent_enum {\n                       Some(parent_enum_id) => {\n@@ -442,7 +442,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n               view_item_import(vps) | view_item_export(vps) => {\n                 do vec::iter(vps) |vp| {\n                     match vp.node {\n-                      view_path_simple(_, _, id) => vfn(id),\n+                      view_path_simple(_, _, _, id) => vfn(id),\n                       view_path_glob(_, id) => vfn(id),\n                       view_path_list(_, _, id) => vfn(id)\n                     }\n@@ -602,7 +602,7 @@ fn walk_pat(pat: @pat, it: fn(@pat)) {\n \n fn view_path_id(p: @view_path) -> node_id {\n     match p.node {\n-      view_path_simple(_, _, id) | view_path_glob(_, id) |\n+      view_path_simple(_, _, _, id) | view_path_glob(_, id) |\n       view_path_list(_, _, id) => id\n     }\n }"}, {"sha": "03bb41698ccbdb00ddf1a1207908cbc0ed12acdf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "patch": "@@ -40,24 +40,25 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              lit_int_unsuffixed, lit_nil, lit_str, lit_uint, local, m_const,\n              m_imm, m_mutbl, mac_, mac_aq, mac_ellipsis, mac_invoc,\n              mac_invoc_tt, mac_var, matcher, match_nonterminal, match_seq,\n-             match_tok, method, mode, mt, mul, mutability, named_field, neg,\n-             noreturn, not, pat, pat_box, pat_enum, pat_ident, pat_lit,\n-             pat_range, pat_rec, pat_struct, pat_tup, pat_uniq, pat_wild,\n-             path, private, proto, proto_bare, proto_block, proto_box,\n-             proto_uniq, provided, public, pure_fn, purity, re_anon, re_named,\n-             region, rem, required, ret_style, return_val, self_ty, shl, shr,\n-             stmt, stmt_decl, stmt_expr, stmt_semi, struct_def, struct_field,\n-             struct_variant_kind, subtract, sty_box, sty_by_ref, sty_region,\n-             sty_static, sty_uniq, sty_value, token_tree, trait_method,\n-             trait_ref, tt_delim, tt_seq, tt_tok, tt_nonterminal, ty, ty_,\n-             ty_bot, ty_box, ty_field, ty_fn, ty_infer, ty_mac, ty_method,\n-             ty_nil, ty_param, ty_param_bound, ty_path, ty_ptr, ty_rec,\n-             ty_rptr, ty_tup, ty_u32, ty_uniq, ty_vec, ty_fixed_length,\n-             tuple_variant_kind, unchecked_blk, uniq, unnamed_field,\n-             unsafe_blk, unsafe_fn, variant, view_item, view_item_,\n-             view_item_export, view_item_import, view_item_use, view_path,\n-             view_path_glob, view_path_list, view_path_simple, visibility,\n-             vstore, vstore_box, vstore_fixed, vstore_slice, vstore_uniq};\n+             match_tok, method, mode, module_ns, mt, mul, mutability,\n+             named_field, neg, noreturn, not, pat, pat_box, pat_enum,\n+             pat_ident, pat_lit, pat_range, pat_rec, pat_struct, pat_tup,\n+             pat_uniq, pat_wild, path, private, proto, proto_bare,\n+             proto_block, proto_box, proto_uniq, provided, public, pure_fn,\n+             purity, re_anon, re_named, region, rem, required, ret_style,\n+             return_val, self_ty, shl, shr, stmt, stmt_decl, stmt_expr,\n+             stmt_semi, struct_def, struct_field, struct_variant_kind,\n+             subtract, sty_box, sty_by_ref, sty_region, sty_static, sty_uniq,\n+             sty_value, token_tree, trait_method, trait_ref, tt_delim, tt_seq,\n+             tt_tok, tt_nonterminal, tuple_variant_kind, ty, ty_, ty_bot,\n+             ty_box, ty_field, ty_fn, ty_infer, ty_mac, ty_method, ty_nil,\n+             ty_param, ty_param_bound, ty_path, ty_ptr, ty_rec, ty_rptr,\n+             ty_tup, ty_u32, ty_uniq, ty_vec, ty_fixed_length, type_value_ns,\n+             unchecked_blk, uniq, unnamed_field, unsafe_blk, unsafe_fn,\n+             variant, view_item, view_item_, view_item_export,\n+             view_item_import, view_item_use, view_path, view_path_glob,\n+             view_path_list, view_path_simple, visibility, vstore, vstore_box,\n+             vstore_fixed, vstore_slice, vstore_uniq};\n \n export file_type;\n export parser;\n@@ -3336,6 +3337,14 @@ struct parser {\n \n     fn parse_view_path() -> @view_path {\n         let lo = self.span.lo;\n+\n+        let namespace;\n+        if self.eat_keyword(~\"mod\") {\n+            namespace = module_ns;\n+        } else {\n+            namespace = type_value_ns;\n+        }\n+\n         let first_ident = self.parse_ident();\n         let mut path = ~[first_ident];\n         debug!(\"parsed view_path: %s\", *self.id_to_str(first_ident));\n@@ -3352,7 +3361,8 @@ struct parser {\n             let path = @{span: mk_sp(lo, self.span.hi), global: false,\n                          idents: path, rp: None, types: ~[]};\n             return @spanned(lo, self.span.hi,\n-                         view_path_simple(first_ident, path, self.get_id()));\n+                         view_path_simple(first_ident, path, namespace,\n+                                          self.get_id()));\n           }\n \n           token::MOD_SEP => {\n@@ -3400,7 +3410,7 @@ struct parser {\n         let path = @{span: mk_sp(lo, self.span.hi), global: false,\n                      idents: path, rp: None, types: ~[]};\n         return @spanned(lo, self.span.hi,\n-                     view_path_simple(last, path, self.get_id()));\n+                     view_path_simple(last, path, namespace, self.get_id()));\n     }\n \n     fn parse_view_paths() -> ~[@view_path] {"}, {"sha": "8f27fa4f47b9a2ad6c5d45e3da58f207d1153471", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "patch": "@@ -468,11 +468,11 @@ fn print_item(s: ps, &&item: @ast::item) {\n       ast::item_foreign_mod(nmod) => {\n         head(s, ~\"extern\");\n         match nmod.sort {\n-          ast::named => {\n-            word_nbsp(s, ~\"mod\");\n-            print_ident(s, item.ident)\n-          }\n-          ast::anonymous => {}\n+            ast::named => {\n+                word_nbsp(s, ~\"mod\");\n+                print_ident(s, item.ident);\n+            }\n+            ast::anonymous => {}\n         }\n         nbsp(s);\n         bopen(s);\n@@ -1687,7 +1687,10 @@ fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n \n fn print_view_path(s: ps, &&vp: @ast::view_path) {\n     match vp.node {\n-      ast::view_path_simple(ident, path, _) => {\n+      ast::view_path_simple(ident, path, namespace, _) => {\n+        if namespace == ast::module_ns {\n+            word_space(s, ~\"mod\");\n+        }\n         if path.idents[vec::len(path.idents)-1u] != ident {\n             print_ident(s, ident);\n             space(s.s);"}, {"sha": "923118d0a2626e2cce1ca99dc450ce4f73dd0338", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 229, "deletions": 64, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "patch": "@@ -29,19 +29,19 @@ import syntax::ast::{foreign_item, foreign_item_const, foreign_item_fn, ge};\n import syntax::ast::{gt, ident, impure_fn, inherited, item, item_class};\n import syntax::ast::{item_const, item_enum, item_fn, item_foreign_mod};\n import syntax::ast::{item_impl, item_mac, item_mod, item_trait, item_ty, le};\n-import syntax::ast::{local, local_crate, lt, method, mul, ne, neg, node_id};\n-import syntax::ast::{pat, pat_enum, pat_ident, path, prim_ty, pat_box};\n-import syntax::ast::{pat_lit, pat_range, pat_rec, pat_struct, pat_tup};\n-import syntax::ast::{pat_uniq, pat_wild, private, provided, public, required};\n-import syntax::ast::{rem, self_ty_, shl, shr, stmt_decl, struct_field};\n-import syntax::ast::{struct_variant_kind, sty_static, subtract, trait_ref};\n-import syntax::ast::{tuple_variant_kind, ty, ty_bool, ty_char, ty_f, ty_f32};\n-import syntax::ast::{ty_f64, ty_float, ty_i, ty_i16, ty_i32, ty_i64, ty_i8};\n-import syntax::ast::{ty_int, ty_param, ty_path, ty_str, ty_u, ty_u16, ty_u32};\n-import syntax::ast::{ty_u64, ty_u8, ty_uint, variant, view_item};\n-import syntax::ast::{view_item_export, view_item_import, view_item_use};\n-import syntax::ast::{view_path_glob, view_path_list, view_path_simple};\n-import syntax::ast::{visibility, anonymous, named};\n+import syntax::ast::{local, local_crate, lt, method, module_ns, mul, ne, neg};\n+import syntax::ast::{node_id, pat, pat_enum, pat_ident, path, prim_ty};\n+import syntax::ast::{pat_box, pat_lit, pat_range, pat_rec, pat_struct};\n+import syntax::ast::{pat_tup, pat_uniq, pat_wild, private, provided, public};\n+import syntax::ast::{required, rem, self_ty_, shl, shr, stmt_decl};\n+import syntax::ast::{struct_field, struct_variant_kind, sty_static, subtract};\n+import syntax::ast::{trait_ref, tuple_variant_kind, ty, ty_bool, ty_char};\n+import syntax::ast::{ty_f, ty_f32, ty_f64, ty_float, ty_i, ty_i16, ty_i32};\n+import syntax::ast::{ty_i64, ty_i8, ty_int, ty_param, ty_path, ty_str, ty_u};\n+import syntax::ast::{ty_u16, ty_u32, ty_u64, ty_u8, ty_uint, type_value_ns};\n+import syntax::ast::{variant, view_item, view_item_export, view_item_import};\n+import syntax::ast::{view_item_use, view_path_glob, view_path_list};\n+import syntax::ast::{view_path_simple, visibility, anonymous, named};\n import syntax::ast_util::{def_id_of_def, dummy_sp, local_def, new_def_hash};\n import syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n import syntax::attr::{attr_metas, contains_name};\n@@ -179,9 +179,20 @@ impl ModuleDef {\n     }\n }\n \n+enum ImportDirectiveNS {\n+    ModuleNSOnly,\n+    AnyNS\n+}\n+\n+impl ImportDirectiveNS : cmp::Eq {\n+    pure fn eq(&&other: ImportDirectiveNS) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n /// Contains data for specific types of import directives.\n enum ImportDirectiveSubclass {\n-    SingleImport(Atom /* target */, Atom /* source */),\n+    SingleImport(Atom /* target */, Atom /* source */, ImportDirectiveNS),\n     GlobImport\n }\n \n@@ -1123,7 +1134,7 @@ struct Resolver {\n \n                     let module_path = @DVec();\n                     match view_path.node {\n-                        view_path_simple(_, full_path, _) => {\n+                        view_path_simple(_, full_path, _, _) => {\n                             let path_len = full_path.idents.len();\n                             assert path_len != 0u;\n \n@@ -1145,10 +1156,16 @@ struct Resolver {\n                     // Build up the import directives.\n                     let module_ = self.get_module_from_parent(parent);\n                     match view_path.node {\n-                        view_path_simple(binding, full_path, _) => {\n+                        view_path_simple(binding, full_path, ns, _) => {\n+                            let ns = match ns {\n+                                module_ns => ModuleNSOnly,\n+                                type_value_ns => AnyNS\n+                            };\n+\n                             let source_ident = full_path.idents.last();\n                             let subclass = @SingleImport(binding,\n-                                                         source_ident);\n+                                                         source_ident,\n+                                                         ns);\n                             self.build_import_directive(module_,\n                                                         module_path,\n                                                         subclass,\n@@ -1157,7 +1174,9 @@ struct Resolver {\n                         view_path_list(_, source_idents, _) => {\n                             for source_idents.each |source_ident| {\n                                 let name = source_ident.node.name;\n-                                let subclass = @SingleImport(name, name);\n+                                let subclass = @SingleImport(name,\n+                                                             name,\n+                                                             AnyNS);\n                                 self.build_import_directive(module_,\n                                                             module_path,\n                                                             subclass,\n@@ -1178,7 +1197,7 @@ struct Resolver {\n                 let module_ = self.get_module_from_parent(parent);\n                 for view_paths.each |view_path| {\n                     match view_path.node {\n-                        view_path_simple(ident, full_path, ident_id) => {\n+                        view_path_simple(ident, full_path, _, ident_id) => {\n                             let last_ident = full_path.idents.last();\n                             if last_ident != ident {\n                                 self.session.span_err(view_item.span,\n@@ -1522,7 +1541,7 @@ struct Resolver {\n         // the appropriate flag.\n \n         match *subclass {\n-            SingleImport(target, _) => {\n+            SingleImport(target, _, _) => {\n                 match module_.import_resolutions.find(target) {\n                     Some(resolution) => {\n                         resolution.outstanding_references += 1u;\n@@ -1699,13 +1718,19 @@ struct Resolver {\n                     // within. Attempt to resolve the import within it.\n \n                     match *import_directive.subclass {\n-                        SingleImport(target, source) => {\n+                        SingleImport(target, source, AnyNS) => {\n                             resolution_result =\n                                 self.resolve_single_import(module_,\n                                                            containing_module,\n                                                            target,\n                                                            source);\n                         }\n+                        SingleImport(target, source, ModuleNSOnly) => {\n+                            resolution_result =\n+                                self.resolve_single_module_import\n+                                    (module_, containing_module, target,\n+                                     source);\n+                        }\n                         GlobImport => {\n                             let span = import_directive.span;\n                             resolution_result =\n@@ -1749,8 +1774,10 @@ struct Resolver {\n         return resolution_result;\n     }\n \n-    fn resolve_single_import(module_: @Module, containing_module: @Module,\n-                             target: Atom, source: Atom)\n+    fn resolve_single_import(module_: @Module,\n+                             containing_module: @Module,\n+                             target: Atom,\n+                             source: Atom)\n                           -> ResolveResult<()> {\n \n         debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n@@ -1937,6 +1964,137 @@ struct Resolver {\n         return Success(());\n     }\n \n+    fn resolve_single_module_import(module_: @Module,\n+                                    containing_module: @Module,\n+                                    target: Atom,\n+                                    source: Atom)\n+                                 -> ResolveResult<()> {\n+\n+        debug!(\"(resolving single module import) resolving `%s` = `%s::%s` \\\n+                from `%s`\",\n+               self.session.str_of(target),\n+               self.module_to_str(containing_module),\n+               self.session.str_of(source),\n+               self.module_to_str(module_));\n+\n+        if !self.name_is_exported(containing_module, source) {\n+            debug!(\"(resolving single import) name `%s` is unexported\",\n+                   self.session.str_of(source));\n+            return Failed;\n+        }\n+\n+        // We need to resolve the module namespace for this to succeed.\n+        let mut module_result = UnknownResult;\n+\n+        // Search for direct children of the containing module.\n+        match containing_module.children.find(source) {\n+            None => {\n+                // Continue.\n+            }\n+            Some(child_name_bindings) => {\n+                if (*child_name_bindings).defined_in_namespace(ModuleNS) {\n+                    module_result = BoundResult(containing_module,\n+                                                child_name_bindings);\n+                }\n+            }\n+        }\n+\n+        // Unless we managed to find a result, search imports as well.\n+        match module_result {\n+            BoundResult(*) => {\n+                // Continue.\n+            }\n+            _ => {\n+                // If there is an unresolved glob at this point in the\n+                // containing module, bail out. We don't know enough to be\n+                // able to resolve this import.\n+\n+                if containing_module.glob_count > 0u {\n+                    debug!(\"(resolving single module import) unresolved \\\n+                            glob; bailing out\");\n+                    return Indeterminate;\n+                }\n+\n+                // Now search the exported imports within the containing\n+                // module.\n+\n+                match containing_module.import_resolutions.find(source) {\n+                    None => {\n+                        // The containing module definitely doesn't have an\n+                        // exported import with the name in question. We can\n+                        // therefore accurately report that the names are\n+                        // unbound.\n+\n+                        if module_result.is_unknown() {\n+                            module_result = UnboundResult;\n+                        }\n+                    }\n+                    Some(import_resolution)\n+                            if import_resolution.outstanding_references\n+                                == 0u => {\n+                        // The name is an import which has been fully\n+                        // resolved. We can, therefore, just follow it.\n+\n+                        if module_result.is_unknown() {\n+                            match (*import_resolution).\n+                                    target_for_namespace(ModuleNS) {\n+                                None => {\n+                                    module_result = UnboundResult;\n+                                }\n+                                Some(target) => {\n+                                    import_resolution.used = true;\n+                                    module_result = BoundResult\n+                                        (target.target_module,\n+                                         target.bindings);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Some(_) => {\n+                        // The import is unresolved. Bail out.\n+                        debug!(\"(resolving single module import) unresolved \\\n+                                import; bailing out\");\n+                        return Indeterminate;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // We've successfully resolved the import. Write the results in.\n+        assert module_.import_resolutions.contains_key(target);\n+        let import_resolution = module_.import_resolutions.get(target);\n+\n+        match module_result {\n+            BoundResult(target_module, name_bindings) => {\n+                debug!(\"(resolving single import) found module binding\");\n+                import_resolution.module_target =\n+                    Some(Target(target_module, name_bindings));\n+            }\n+            UnboundResult => {\n+                debug!(\"(resolving single import) didn't find module \\\n+                        binding\");\n+            }\n+            UnknownResult => {\n+                fail ~\"module result should be known at this point\";\n+            }\n+        }\n+\n+        let i = import_resolution;\n+        if i.module_target.is_none() {\n+          // If this name wasn't found in the module namespace, it's\n+          // definitely unresolved.\n+          return Failed;\n+        }\n+\n+        assert import_resolution.outstanding_references >= 1u;\n+        import_resolution.outstanding_references -= 1u;\n+\n+        debug!(\"(resolving single module import) successfully resolved \\\n+               import\");\n+        return Success(());\n+    }\n+\n+\n     /**\n      * Resolves a glob import. Note that this function cannot fail; it either\n      * succeeds or bails out (as importing * from an empty module or a module\n@@ -2384,10 +2542,12 @@ struct Resolver {\n \n         let mut target_name;\n         let mut source_name;\n+        let allowable_namespaces;\n         match *import_directive.subclass {\n-            SingleImport(target, source) => {\n+            SingleImport(target, source, namespaces) => {\n                 target_name = target;\n                 source_name = source;\n+                allowable_namespaces = namespaces;\n             }\n             GlobImport => {\n                 fail ~\"found `import *`, which is invalid\";\n@@ -2407,8 +2567,8 @@ struct Resolver {\n         let mut module_result;\n         debug!(\"(resolving one-level naming result) searching for module\");\n         match self.resolve_item_in_lexical_scope(module_,\n-                                               source_name,\n-                                               ModuleNS) {\n+                                                 source_name,\n+                                                 ModuleNS) {\n \n             Failed => {\n                 debug!(\"(resolving one-level renaming import) didn't find \\\n@@ -2428,48 +2588,53 @@ struct Resolver {\n         }\n \n         let mut value_result;\n-        debug!(\"(resolving one-level naming result) searching for value\");\n-        match self.resolve_item_in_lexical_scope(module_,\n-                                               source_name,\n-                                               ValueNS) {\n+        let mut type_result;\n+        if allowable_namespaces == ModuleNSOnly {\n+            value_result = None;\n+            type_result = None;\n+        } else {\n+            debug!(\"(resolving one-level naming result) searching for value\");\n+            match self.resolve_item_in_lexical_scope(module_,\n+                                                   source_name,\n+                                                   ValueNS) {\n \n-            Failed => {\n-                debug!(\"(resolving one-level renaming import) didn't find \\\n-                        value result\");\n-                value_result = None;\n-            }\n-            Indeterminate => {\n-                debug!(\"(resolving one-level renaming import) value result \\\n-                        is indeterminate; bailing\");\n-                return Indeterminate;\n-            }\n-            Success(name_bindings) => {\n-                debug!(\"(resolving one-level renaming import) value result \\\n-                        found\");\n-                value_result = Some(copy name_bindings);\n+                Failed => {\n+                    debug!(\"(resolving one-level renaming import) didn't \\\n+                            find value result\");\n+                    value_result = None;\n+                }\n+                Indeterminate => {\n+                    debug!(\"(resolving one-level renaming import) value \\\n+                            result is indeterminate; bailing\");\n+                    return Indeterminate;\n+                }\n+                Success(name_bindings) => {\n+                    debug!(\"(resolving one-level renaming import) value \\\n+                            result found\");\n+                    value_result = Some(copy name_bindings);\n+                }\n             }\n-        }\n \n-        let mut type_result;\n-        debug!(\"(resolving one-level naming result) searching for type\");\n-        match self.resolve_item_in_lexical_scope(module_,\n-                                               source_name,\n-                                               TypeNS) {\n+            debug!(\"(resolving one-level naming result) searching for type\");\n+            match self.resolve_item_in_lexical_scope(module_,\n+                                                   source_name,\n+                                                   TypeNS) {\n \n-            Failed => {\n-                debug!(\"(resolving one-level renaming import) didn't find \\\n-                        type result\");\n-                type_result = None;\n-            }\n-            Indeterminate => {\n-                debug!(\"(resolving one-level renaming import) type result is \\\n-                        indeterminate; bailing\");\n-                return Indeterminate;\n-            }\n-            Success(name_bindings) => {\n-                debug!(\"(resolving one-level renaming import) type result \\\n-                        found\");\n-                type_result = Some(copy name_bindings);\n+                Failed => {\n+                    debug!(\"(resolving one-level renaming import) didn't \\\n+                            find type result\");\n+                    type_result = None;\n+                }\n+                Indeterminate => {\n+                    debug!(\"(resolving one-level renaming import) type \\\n+                            result is indeterminate; bailing\");\n+                    return Indeterminate;\n+                }\n+                Success(name_bindings) => {\n+                    debug!(\"(resolving one-level renaming import) type \\\n+                            result found\");\n+                    type_result = Some(copy name_bindings);\n+                }\n             }\n         }\n "}, {"sha": "981a8125655f05fadfe0276742410cf0878180b4", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "patch": "@@ -39,7 +39,7 @@ fn traverse_exports(cx: ctx, vis: ~[@view_item]) -> bool {\n             found_export = true;\n             for vec::each(vps) |vp| {\n                 match vp.node {\n-                  view_path_simple(_, _, id) | view_path_glob(_, id) |\n+                  view_path_simple(_, _, _, id) | view_path_glob(_, id) |\n                   view_path_list(_, _, id) => {\n                     traverse_export(cx, id);\n                   }"}, {"sha": "fcb50bd343647c2debecf49576aadc459ad4f7e1", "filename": "src/test/run-pass/use-mod.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Ftest%2Frun-pass%2Fuse-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e7d5e1cbddeee95a1a7c996b99d78dec0da2954/src%2Ftest%2Frun-pass%2Fuse-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse-mod.rs?ref=6e7d5e1cbddeee95a1a7c996b99d78dec0da2954", "patch": "@@ -0,0 +1,12 @@\n+use mod a::b;\n+\n+mod a {\n+    mod b {\n+        fn f() {}\n+    }\n+}\n+\n+fn main() {\n+    b::f();\n+}\n+"}]}