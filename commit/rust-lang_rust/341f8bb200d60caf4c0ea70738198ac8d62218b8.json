{"sha": "341f8bb200d60caf4c0ea70738198ac8d62218b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MWY4YmIyMDBkNjBjYWY0YzBlYTcwNzM4MTk4YWM4ZDYyMjE4Yjg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-31T16:06:40Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-31T16:45:50Z"}, "message": "fix: avoid panics in match case diagnostic", "tree": {"sha": "17b534d34bf7f6da4f550678374d7da98d49c687", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17b534d34bf7f6da4f550678374d7da98d49c687"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/341f8bb200d60caf4c0ea70738198ac8d62218b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/341f8bb200d60caf4c0ea70738198ac8d62218b8", "html_url": "https://github.com/rust-lang/rust/commit/341f8bb200d60caf4c0ea70738198ac8d62218b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/341f8bb200d60caf4c0ea70738198ac8d62218b8/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10b15b27f2f4bee6de63f66c344f741482becd21", "url": "https://api.github.com/repos/rust-lang/rust/commits/10b15b27f2f4bee6de63f66c344f741482becd21", "html_url": "https://github.com/rust-lang/rust/commit/10b15b27f2f4bee6de63f66c344f741482becd21"}], "stats": {"total": 141, "additions": 33, "deletions": 108}, "files": [{"sha": "bfa53bdce7ed93645a9cb629de02681b5d07ea8e", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 33, "deletions": 108, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/341f8bb200d60caf4c0ea70738198ac8d62218b8/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341f8bb200d60caf4c0ea70738198ac8d62218b8/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=341f8bb200d60caf4c0ea70738198ac8d62218b8", "patch": "@@ -150,29 +150,11 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n             expected_case: CaseType::LowerSnakeCase,\n         });\n \n-        // Check the param names.\n-        let fn_param_replacements = body\n-            .params\n-            .iter()\n-            .filter_map(|&id| match &body[id] {\n-                Pat::Bind { name, .. } => Some(name),\n-                _ => None,\n-            })\n-            .filter_map(|param_name| {\n-                Some(Replacement {\n-                    current_name: param_name.clone(),\n-                    suggested_text: to_lower_snake_case(&param_name.to_string())?,\n-                    expected_case: CaseType::LowerSnakeCase,\n-                })\n-            })\n-            .collect();\n-\n         // Check the patterns inside the function body.\n+        // This includes function parameters.\n         let pats_replacements = body\n             .pats\n             .iter()\n-            // We aren't interested in function parameters, we've processed them above.\n-            .filter(|(pat_idx, _)| !body.params.contains(&pat_idx))\n             .filter_map(|(id, pat)| match pat {\n                 Pat::Bind { name, .. } => Some((id, name)),\n                 _ => None,\n@@ -190,11 +172,10 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n             .collect();\n \n         // If there is at least one element to spawn a warning on, go to the source map and generate a warning.\n-        self.create_incorrect_case_diagnostic_for_func(\n-            func,\n-            fn_name_replacement,\n-            fn_param_replacements,\n-        );\n+        if let Some(fn_name_replacement) = fn_name_replacement {\n+            self.create_incorrect_case_diagnostic_for_func(func, fn_name_replacement);\n+        }\n+\n         self.create_incorrect_case_diagnostic_for_variables(func, pats_replacements);\n     }\n \n@@ -203,100 +184,34 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n     fn create_incorrect_case_diagnostic_for_func(\n         &mut self,\n         func: FunctionId,\n-        fn_name_replacement: Option<Replacement>,\n-        fn_param_replacements: Vec<Replacement>,\n+        fn_name_replacement: Replacement,\n     ) {\n-        // XXX: only look at sources if we do have incorrect names\n-        if fn_name_replacement.is_none() && fn_param_replacements.is_empty() {\n-            return;\n-        }\n-\n         let fn_loc = func.lookup(self.db.upcast());\n         let fn_src = fn_loc.source(self.db.upcast());\n \n         // Diagnostic for function name.\n-        if let Some(replacement) = fn_name_replacement {\n-            let ast_ptr = match fn_src.value.name() {\n-                Some(name) => name,\n-                None => {\n-                    never!(\n-                        \"Replacement ({:?}) was generated for a function without a name: {:?}\",\n-                        replacement,\n-                        fn_src\n-                    );\n-                    return;\n-                }\n-            };\n-\n-            let diagnostic = IncorrectCase {\n-                file: fn_src.file_id,\n-                ident_type: IdentType::Function,\n-                ident: AstPtr::new(&ast_ptr),\n-                expected_case: replacement.expected_case,\n-                ident_text: replacement.current_name.to_string(),\n-                suggested_text: replacement.suggested_text,\n-            };\n-\n-            self.sink.push(diagnostic);\n-        }\n-\n-        // Diagnostics for function params.\n-        let fn_params_list = match fn_src.value.param_list() {\n-            Some(params) => params,\n+        let ast_ptr = match fn_src.value.name() {\n+            Some(name) => name,\n             None => {\n-                always!(\n-                    fn_param_replacements.is_empty(),\n-                    \"Replacements ({:?}) were generated for a function parameters which had no parameters list: {:?}\",\n-                    fn_param_replacements,\n+                never!(\n+                    \"Replacement ({:?}) was generated for a function without a name: {:?}\",\n+                    fn_name_replacement,\n                     fn_src\n                 );\n                 return;\n             }\n         };\n-        let mut fn_params_iter = fn_params_list.params();\n-        for param_to_rename in fn_param_replacements {\n-            // We assume that parameters in replacement are in the same order as in the\n-            // actual params list, but just some of them (ones that named correctly) are skipped.\n-            let ast_ptr: ast::Name = loop {\n-                match fn_params_iter.next() {\n-                    Some(element) => {\n-                        if let Some(ast::Pat::IdentPat(pat)) = element.pat() {\n-                            if pat.to_string() == param_to_rename.current_name.to_string() {\n-                                if let Some(name) = pat.name() {\n-                                    break name;\n-                                }\n-                                // This is critical. If we consider this parameter the expected one,\n-                                // it **must** have a name.\n-                                never!(\n-                                    \"Pattern {:?} equals to expected replacement {:?}, but has no name\",\n-                                    element,\n-                                    param_to_rename\n-                                );\n-                                return;\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        never!(\n-                            \"Replacement ({:?}) was generated for a function parameter which was not found: {:?}\",\n-                            param_to_rename, fn_src\n-                        );\n-                        return;\n-                    }\n-                }\n-            };\n \n-            let diagnostic = IncorrectCase {\n-                file: fn_src.file_id,\n-                ident_type: IdentType::Argument,\n-                ident: AstPtr::new(&ast_ptr),\n-                expected_case: param_to_rename.expected_case,\n-                ident_text: param_to_rename.current_name.to_string(),\n-                suggested_text: param_to_rename.suggested_text,\n-            };\n+        let diagnostic = IncorrectCase {\n+            file: fn_src.file_id,\n+            ident_type: IdentType::Function,\n+            ident: AstPtr::new(&ast_ptr),\n+            expected_case: fn_name_replacement.expected_case,\n+            ident_text: fn_name_replacement.current_name.to_string(),\n+            suggested_text: fn_name_replacement.suggested_text,\n+        };\n \n-            self.sink.push(diagnostic);\n-        }\n+        self.sink.push(diagnostic);\n     }\n \n     /// Given the information about incorrect variable names, looks up into the source code\n@@ -327,20 +242,25 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n                             None => continue,\n                         };\n \n+                        let is_param = ast::Param::can_cast(parent.kind());\n+\n                         // We have to check that it's either `let var = ...` or `var @ Variant(_)` statement,\n                         // because e.g. match arms are patterns as well.\n                         // In other words, we check that it's a named variable binding.\n                         let is_binding = ast::LetStmt::can_cast(parent.kind())\n                             || (ast::MatchArm::can_cast(parent.kind())\n                                 && ident_pat.at_token().is_some());\n-                        if !is_binding {\n+                        if !(is_param || is_binding) {\n                             // This pattern is not an actual variable declaration, e.g. `Some(val) => {..}` match arm.\n                             continue;\n                         }\n \n+                        let ident_type =\n+                            if is_param { IdentType::Argument } else { IdentType::Variable };\n+\n                         let diagnostic = IncorrectCase {\n                             file: source_ptr.file_id,\n-                            ident_type: IdentType::Variable,\n+                            ident_type,\n                             ident: AstPtr::new(&name_ast),\n                             expected_case: replacement.expected_case,\n                             ident_text: replacement.current_name.to_string(),\n@@ -408,7 +328,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n         struct_name_replacement: Option<Replacement>,\n         struct_fields_replacements: Vec<Replacement>,\n     ) {\n-        // XXX: only look at sources if we do have incorrect names\n+        // XXX: Only look at sources if we do have incorrect names.\n         if struct_name_replacement.is_none() && struct_fields_replacements.is_empty() {\n             return;\n         }\n@@ -1037,4 +957,9 @@ fn qualify() {\n             \"#,\n         )\n     }\n+\n+    #[test] // Issue #8809.\n+    fn parenthesized_parameter() {\n+        check_diagnostics(r#\"fn f((O): _) {}\"#)\n+    }\n }"}]}