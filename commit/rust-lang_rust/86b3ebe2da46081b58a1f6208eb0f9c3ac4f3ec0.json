{"sha": "86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YjNlYmUyZGE0NjA4MWI1OGExZjYyMDhlYjBmOWMzYWM0ZjNlYzA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-05-31T13:17:04Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-08T17:24:15Z"}, "message": "Inline box_region macro calls", "tree": {"sha": "d7c2fa41b8d2f94a7d876d4890bda285a72fdf12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7c2fa41b8d2f94a7d876d4890bda285a72fdf12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0", "html_url": "https://github.com/rust-lang/rust/commit/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f397bc8a0d8f2569d9aec7ad787b484c4b147e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f397bc8a0d8f2569d9aec7ad787b484c4b147e4", "html_url": "https://github.com/rust-lang/rust/commit/8f397bc8a0d8f2569d9aec7ad787b484c4b147e4"}], "stats": {"total": 162, "additions": 77, "deletions": 85}, "files": [{"sha": "a1a757b705418c421fdbe92e3b51b8c5219f87be", "filename": "compiler/rustc_data_structures/src/box_region.rs", "status": "modified", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs?ref=86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0", "patch": "@@ -78,83 +78,3 @@ pub enum YieldType<I, A> {\n     Initial(I),\n     Accessor(Marker<A>),\n }\n-\n-#[macro_export]\n-#[allow_internal_unstable(fn_traits)]\n-macro_rules! declare_box_region_type {\n-    ($v:vis $name: ident, ($($args:ty),*) -> ($reti:ty, $retc:ty)) => {\n-        $v struct $name($crate::box_region::PinnedGenerator<\n-            $reti,\n-            fn(($($args,)*)),\n-            $retc\n-        >);\n-\n-        impl $name {\n-            fn new<T>(generator: T) -> ($reti, Self)\n-            where T: ::std::ops::Generator<\n-                $crate::box_region::Action,\n-                Yield = $crate::box_region::YieldType<$reti, fn(($($args,)*))>,\n-                Return = $retc,\n-            > + 'static {\n-                let (initial, pinned) = $crate::box_region::PinnedGenerator::new(generator);\n-                (initial, $name(pinned))\n-            }\n-\n-            $v fn access<F: FnOnce($($args,)*) -> R, R>(&mut self, f: F) -> R {\n-                // Turn the FnOnce closure into *mut dyn FnMut()\n-                // so we can pass it in to the generator\n-                let mut r = None;\n-                let mut f = Some(f);\n-                let mut_f: &mut dyn FnMut(($($args,)*)) =\n-                    &mut |args| {\n-                        let f = f.take().unwrap();\n-                        r = Some(FnOnce::call_once(f, args));\n-                };\n-                let mut_f = mut_f as *mut dyn FnMut(($($args,)*));\n-\n-                // Get the generator to call our closure\n-                unsafe {\n-                    self.0.access(::std::mem::transmute(mut_f));\n-                }\n-\n-                // Unwrap the result\n-                r.unwrap()\n-            }\n-\n-            $v fn complete(mut self) -> $retc {\n-                self.0.complete()\n-            }\n-\n-            fn initial_yield(\n-                value: $reti,\n-            ) -> $crate::box_region::YieldType<$reti, fn(($($args,)*))> {\n-                $crate::box_region::YieldType::Initial(value)\n-            }\n-        }\n-    };\n-}\n-\n-#[macro_export]\n-#[allow_internal_unstable(fn_traits)]\n-macro_rules! box_region_allow_access {\n-    (($($args:ty),*), ($($exprs:expr),*), $action:ident) => {\n-        loop {\n-            match $action {\n-                $crate::box_region::Action::Access(accessor) => {\n-                    let accessor: &mut dyn FnMut($($args),*) = unsafe {\n-                        ::std::mem::transmute(accessor.get())\n-                    };\n-                    (*accessor)(($($exprs),*));\n-                    unsafe {\n-                        let marker = $crate::box_region::Marker::<\n-                            fn(($($args,)*))\n-                        >::new();\n-                        $action = yield $crate::box_region::YieldType::Accessor(marker);\n-                    };\n-                }\n-                $crate::box_region::Action::Complete => break,\n-                $crate::box_region::Action::Initial => panic!(\"unexpected box_region action: Initial\"),\n-            }\n-        }\n-    }\n-}"}, {"sha": "383917e41b5201274b2d10e3df7163e4d44aef43", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 77, "deletions": 5, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=86b3ebe2da46081b58a1f6208eb0f9c3ac4f3ec0", "patch": "@@ -6,10 +6,10 @@ use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self as ast, visit};\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_data_structures::parallel;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{par_iter, Lrc, OnceCell, ParallelIterator, WorkerLocal};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n-use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_errors::{ErrorReported, PResult};\n use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::LOCAL_CRATE;\n@@ -85,11 +85,62 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n     counter.count\n }\n \n-declare_box_region_type!(\n-    pub BoxedResolver,\n-    (&mut Resolver<'_>) -> (Result<ast::Crate>, ResolverOutputs)\n+pub struct BoxedResolver(\n+    rustc_data_structures::box_region::PinnedGenerator<\n+        Result<ast::Crate>,\n+        fn(&mut Resolver<'_>),\n+        ResolverOutputs,\n+    >,\n );\n \n+impl BoxedResolver {\n+    fn new<T>(generator: T) -> (Result<ast::Crate>, Self)\n+    where\n+        T: ::std::ops::Generator<\n+                rustc_data_structures::box_region::Action,\n+                Yield = rustc_data_structures::box_region::YieldType<\n+                    Result<ast::Crate>,\n+                    fn(&mut Resolver<'_>),\n+                >,\n+                Return = ResolverOutputs,\n+            > + 'static,\n+    {\n+        let (initial, pinned) = rustc_data_structures::box_region::PinnedGenerator::new(generator);\n+        (initial, BoxedResolver(pinned))\n+    }\n+\n+    pub fn access<F: FnOnce(&mut Resolver<'_>) -> R, R>(&mut self, f: F) -> R {\n+        // Turn the FnOnce closure into *mut dyn FnMut()\n+        // so we can pass it in to the generator\n+        let mut r = None;\n+        let mut f = Some(f);\n+        let mut_f: &mut dyn FnMut(&mut Resolver<'_>) = &mut |resolver| {\n+            let f = f.take().unwrap();\n+            r = Some(f(resolver));\n+        };\n+        let mut_f = mut_f as *mut dyn FnMut(&mut Resolver<'_>);\n+\n+        // Get the generator to call our closure\n+        unsafe {\n+            self.0.access(::std::mem::transmute(mut_f));\n+        }\n+\n+        // Unwrap the result\n+        r.unwrap()\n+    }\n+\n+    pub fn complete(mut self) -> ResolverOutputs {\n+        self.0.complete()\n+    }\n+\n+    fn initial_yield(\n+        value: Result<ast::Crate>,\n+    ) -> rustc_data_structures::box_region::YieldType<Result<ast::Crate>, fn(&mut Resolver<'_>)>\n+    {\n+        rustc_data_structures::box_region::YieldType::Initial(value)\n+    }\n+}\n+\n /// Runs the \"early phases\" of the compiler: initial `cfg` processing, loading compiler plugins,\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n /// harness if one is to be provided, injection of a dependency on the\n@@ -132,7 +183,28 @@ pub fn configure_and_expand(\n                 resolver\n             }\n         };\n-        box_region_allow_access!((&mut Resolver<'_>), (&mut resolver), action);\n+\n+        loop {\n+            match action {\n+                rustc_data_structures::box_region::Action::Access(accessor) => {\n+                    let accessor: &mut dyn FnMut(&mut Resolver<'_>) =\n+                        unsafe { ::std::mem::transmute(accessor.get()) };\n+                    (*accessor)(&mut resolver);\n+                    unsafe {\n+                        let marker = rustc_data_structures::box_region::Marker::<\n+                            fn(&mut Resolver<'_>),\n+                        >::new();\n+                        action =\n+                            yield rustc_data_structures::box_region::YieldType::Accessor(marker);\n+                    };\n+                }\n+                rustc_data_structures::box_region::Action::Complete => break,\n+                rustc_data_structures::box_region::Action::Initial => {\n+                    panic!(\"unexpected box_region action: Initial\")\n+                }\n+            }\n+        }\n+\n         resolver.into_outputs()\n     });\n     result.map(|k| (k, resolver))"}]}