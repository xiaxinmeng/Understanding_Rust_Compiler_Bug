{"sha": "31586339b14e8c4167c3bf80d375881f3ff2fb19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNTg2MzM5YjE0ZThjNDE2N2MzYmY4MGQzNzU4ODFmM2ZmMmZiMTk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-07T09:20:51Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-07T12:43:19Z"}, "message": "Make it possible to have locals that don't live on the stack\n\nLocal values that are not mutated, don't need to be cleaned up, and\nare immediate, don't need to be spilled. (All immediate args, and\nnon-pointer immediate let locals.)", "tree": {"sha": "ced79b25f4235cb52bd1e181bfdb398736494c69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ced79b25f4235cb52bd1e181bfdb398736494c69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31586339b14e8c4167c3bf80d375881f3ff2fb19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31586339b14e8c4167c3bf80d375881f3ff2fb19", "html_url": "https://github.com/rust-lang/rust/commit/31586339b14e8c4167c3bf80d375881f3ff2fb19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31586339b14e8c4167c3bf80d375881f3ff2fb19/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7586082bb08a4158914ab72b27b1c3a1b2dfb78c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7586082bb08a4158914ab72b27b1c3a1b2dfb78c", "html_url": "https://github.com/rust-lang/rust/commit/7586082bb08a4158914ab72b27b1c3a1b2dfb78c"}], "stats": {"total": 321, "additions": 172, "deletions": 149}, "files": [{"sha": "20a8490d2aafbbba05f9f7a0ec7ca0b856ef2feb", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 150, "deletions": 133, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/31586339b14e8c4167c3bf80d375881f3ff2fb19/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31586339b14e8c4167c3bf80d375881f3ff2fb19/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=31586339b14e8c4167c3bf80d375881f3ff2fb19", "patch": "@@ -2087,25 +2087,23 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n     let src_val = src.val;\n     let tcx = bcx_tcx(cx);\n     if ty::type_is_scalar(tcx, t) || ty::type_is_native(tcx, t) {\n-        if src.is_mem { src_val = Load(cx, src_val); }\n+        if src.kind == owned { src_val = Load(cx, src_val); }\n         Store(cx, src_val, dst);\n         ret cx;\n     } else if ty::type_is_nil(tcx, t) || ty::type_is_bot(tcx, t) {\n         ret cx;\n     } else if ty::type_is_boxed(tcx, t) || ty::type_is_unique_box(tcx, t) {\n-        if src.is_mem { src_val = Load(cx, src_val); }\n+        if src.kind == owned { src_val = Load(cx, src_val); }\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         Store(cx, src_val, dst);\n-        if src.is_mem { ret zero_alloca(cx, src.val, t); }\n-\n+        if src.kind == owned { ret zero_alloca(cx, src.val, t); }\n         // If we're here, it must be a temporary.\n         ret revoke_clean(cx, src_val);\n     } else if ty::type_is_unique(tcx, t) ||\n                   type_is_structural_or_param(tcx, t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         cx = memmove_ty(cx, dst, src_val, t);\n-        if src.is_mem { ret zero_alloca(cx, src_val, t); }\n-\n+        if src.kind == owned { ret zero_alloca(cx, src_val, t); }\n         // If we're here, it must be a temporary.\n         ret revoke_clean(cx, src_val);\n     }\n@@ -2117,9 +2115,10 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n fn store_temp_expr(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n                    src: lval_result, t: ty::t) -> @block_ctxt {\n     // Lvals in memory are not temporaries. Copy them.\n-    if src.is_mem {\n-        ret copy_val(cx, action, dst, load_if_immediate(cx, src.val, t),\n-                     t);\n+    if src.kind != temporary {\n+        let v = src.kind == owned ? load_if_immediate(cx, src.val, t)\n+                                  : src.val;\n+        ret copy_val(cx, action, dst, v, t);\n     }\n     ret move_val(cx, action, dst, src, t);\n }\n@@ -2344,7 +2343,7 @@ fn trans_assign_op(bcx: @block_ctxt, op: ast::binop, dst: @ast::expr,\n     let tcx = bcx_tcx(bcx);\n     let t = ty::expr_ty(tcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n-    assert (lhs_res.is_mem);\n+    assert (lhs_res.kind == owned);\n     // Special case for `+= [x]`\n     alt ty::struct(tcx, t) {\n       ty::ty_vec(_) {\n@@ -2574,7 +2573,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n         Br(bcx, scope_cx.llbb);\n         curr = PointerCast(bcx, curr, T_ptr(type_of_or_i8(bcx, t)));\n         bcx = trans_alt::bind_irrefutable_pat(scope_cx, local.node.pat, curr,\n-                                              bcx.fcx.lllocals, false);\n+                                              false);\n         bcx = trans_block_dps(bcx, body, ignore);\n         Br(bcx, next_cx.llbb);\n         ret next_cx;\n@@ -2599,7 +2598,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n \n tag environment_value {\n     env_expr(@ast::expr);\n-    env_direct(ValueRef, ty::t);\n+    env_direct(ValueRef, ty::t, bool);\n }\n \n // Given a block context and a list of tydescs and values to bind\n@@ -2619,7 +2618,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     let bound_tys = [];\n     for bv in bound_values {\n         bound_tys += [alt bv {\n-          env_direct(_, t) { t }\n+          env_direct(_, t, _) { t }\n           env_expr(e) { ty::expr_ty(tcx, e) }\n         }];\n     }\n@@ -2694,11 +2693,14 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n             add_clean_temp_mem(bcx, bound.val, bound_tys[i]);\n             temp_cleanups += [bound.val];\n           }\n-          env_direct(val, ty) {\n+          env_direct(val, ty, is_mem) {\n             if copying {\n-                bcx = copy_val(bcx, INIT, bound.val,\n-                               load_if_immediate(bcx, val, ty), ty);\n-            } else { Store(bcx, val, bound.val); }\n+                let val1 = is_mem ? load_if_immediate(bcx, val, ty) : val;\n+                bcx = copy_val(bcx, INIT, bound.val, val1, ty);\n+            } else {\n+                let addr = is_mem ? val : do_spill_noroot(bcx, val);\n+                Store(bcx, addr, bound.val);\n+            }\n           }\n         }\n         i += 1u;\n@@ -2730,17 +2732,17 @@ fn build_closure(cx: @block_ctxt, upvars: @[ast::def], copying: bool) ->\n     // If we need to, package up the iterator body to call\n     let env_vals = alt cx.fcx.lliterbody {\n       some(body) when !copying {\n-        [env_direct(body, option::get(cx.fcx.iterbodyty))]\n+        [env_direct(body, option::get(cx.fcx.iterbodyty), true)]\n       }\n       _ { [] }\n     };\n     // Package up the upvars\n     for def in *upvars {\n-        let val = trans_local_var(cx, def).val;\n+        let lv = trans_local_var(cx, def);\n         let nid = ast_util::def_id_of_def(def).node;\n         let ty = ty::node_id_to_monotype(bcx_tcx(cx), nid);\n         if !copying { ty = ty::mk_mut_ptr(bcx_tcx(cx), ty); }\n-        env_vals += [env_direct(val, ty)];\n+        env_vals += [env_direct(lv.val, ty, lv.kind == owned)];\n     }\n     ret build_environment(cx, copy cx.fcx.lltydescs, env_vals, copying);\n }\n@@ -2894,10 +2896,9 @@ fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n \n     let bcx = new_top_block_ctxt(fcx);\n     // Add bindings for the loop variable alias.\n-    bcx =\n-        trans_alt::bind_irrefutable_pat(bcx, local.node.pat,\n-                                        llvm::LLVMGetParam(fcx.llfn, 3u),\n-                                        bcx.fcx.lllocals, false);\n+    bcx = trans_alt::bind_irrefutable_pat(bcx, local.node.pat,\n+                                          llvm::LLVMGetParam(fcx.llfn, 3u),\n+                                          false);\n     let lltop = bcx.llbb;\n     bcx = trans_block(bcx, body);\n     finish_fn(fcx, lltop);\n@@ -2948,30 +2949,29 @@ type generic_info =\n      static_tis: [option::t<@tydesc_info>],\n      tydescs: [ValueRef]};\n \n-type lval_result = {bcx: @block_ctxt,\n-                    val: ValueRef,\n-                    is_mem: bool};\n+tag lval_kind { temporary; owned; owned_imm; }\n+type lval_result = {bcx: @block_ctxt, val: ValueRef, kind: lval_kind};\n tag callee_env { obj_env(ValueRef); null_env; is_closure; }\n type lval_maybe_callee = {bcx: @block_ctxt,\n                           val: ValueRef,\n-                          is_mem: bool,\n+                          kind: lval_kind,\n                           env: callee_env,\n                           generic: option::t<generic_info>};\n \n fn null_env_ptr(bcx: @block_ctxt) -> ValueRef {\n     C_null(T_opaque_closure_ptr(*bcx_ccx(bcx)))\n }\n \n-fn lval_mem(bcx: @block_ctxt, val: ValueRef) -> lval_result {\n-    ret {bcx: bcx, val: val, is_mem: true};\n+fn lval_owned(bcx: @block_ctxt, val: ValueRef) -> lval_result {\n+    ret {bcx: bcx, val: val, kind: owned};\n }\n-fn lval_val(bcx: @block_ctxt, val: ValueRef) -> lval_result {\n-    ret {bcx: bcx, val: val, is_mem: false};\n+fn lval_temp(bcx: @block_ctxt, val: ValueRef) -> lval_result {\n+    ret {bcx: bcx, val: val, kind: temporary};\n }\n \n-fn lval_no_env(bcx: @block_ctxt, val: ValueRef, is_mem: bool)\n+fn lval_no_env(bcx: @block_ctxt, val: ValueRef, kind: lval_kind)\n     -> lval_maybe_callee {\n-    ret {bcx: bcx, val: val, is_mem: is_mem, env: is_closure, generic: none};\n+    ret {bcx: bcx, val: val, kind: kind, env: is_closure, generic: none};\n }\n \n fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n@@ -3006,7 +3006,7 @@ fn lval_static_fn(bcx: @block_ctxt, tpt: ty::ty_param_kinds_and_ty,\n         }\n         gen = some({item_type: tpt.ty, static_tis: tis, tydescs: tydescs});\n     }\n-    ret {bcx: bcx, val: val, is_mem: true, env: null_env, generic: gen};\n+    ret {bcx: bcx, val: val, kind: owned, env: null_env, generic: gen};\n }\n \n fn lookup_discriminant(lcx: @local_ctxt, vid: ast::def_id) -> ValueRef {\n@@ -3031,26 +3031,27 @@ fn lookup_discriminant(lcx: @local_ctxt, vid: ast::def_id) -> ValueRef {\n }\n \n fn trans_local_var(cx: @block_ctxt, def: ast::def) -> lval_result {\n+    fn take_local(cx: @block_ctxt, table: hashmap<ast::node_id, local_val>,\n+                  id: ast::node_id) -> lval_result {\n+        alt table.find(id) {\n+          some(local_mem(v)) { lval_owned(cx, v) }\n+          some(local_imm(v)) { {bcx: cx, val: v, kind: owned_imm} }\n+        }\n+    }\n     alt def {\n       ast::def_upvar(did, _, _) {\n         assert (cx.fcx.llupvars.contains_key(did.node));\n-        ret lval_mem(cx, cx.fcx.llupvars.get(did.node));\n+        ret lval_owned(cx, cx.fcx.llupvars.get(did.node));\n       }\n       ast::def_arg(did, _) {\n-        assert (cx.fcx.llargs.contains_key(did.node));\n-        ret lval_mem(cx, cx.fcx.llargs.get(did.node));\n-      }\n-      ast::def_local(did, _) {\n-        assert (cx.fcx.lllocals.contains_key(did.node));\n-        ret lval_mem(cx, cx.fcx.lllocals.get(did.node));\n+        ret take_local(cx, cx.fcx.llargs, did.node);\n       }\n-      ast::def_binding(did) {\n-        assert (cx.fcx.lllocals.contains_key(did.node));\n-        ret lval_mem(cx, cx.fcx.lllocals.get(did.node));\n+      ast::def_local(did, _) | ast::def_binding(did) {\n+        ret take_local(cx, cx.fcx.lllocals, did.node);\n       }\n       ast::def_obj_field(did, _) {\n         assert (cx.fcx.llobjfields.contains_key(did.node));\n-        ret lval_mem(cx, cx.fcx.llobjfields.get(did.node));\n+        ret lval_owned(cx, cx.fcx.llobjfields.get(did.node));\n       }\n       _ {\n         bcx_ccx(cx).sess.span_unimpl\n@@ -3093,24 +3094,24 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n                 let lldiscrimptr = GEP(bcx, lltagptr, [C_int(0), C_int(0)]);\n                 Store(bcx, lldiscrim, lldiscrimptr);\n             }\n-            ret lval_no_env(bcx, lltagptr, false);\n+            ret lval_no_env(bcx, lltagptr, temporary);\n           }\n         }\n       }\n       ast::def_const(did) {\n         if did.crate == ast::local_crate {\n             assert (ccx.consts.contains_key(did.node));\n-            ret lval_no_env(cx, ccx.consts.get(did.node), true);\n+            ret lval_no_env(cx, ccx.consts.get(did.node), owned);\n         } else {\n             let tp = ty::node_id_to_monotype(ccx.tcx, id);\n             let k: [ast::kind] = [];\n             let val = trans_external_path(cx, did, {kinds: k, ty: tp});\n-            ret lval_no_env(cx, load_if_immediate(cx, val, tp), false);\n+            ret lval_no_env(cx, load_if_immediate(cx, val, tp), owned_imm);\n         }\n       }\n       _ {\n         let loc = trans_local_var(cx, def);\n-        ret lval_no_env(loc.bcx, loc.val, loc.is_mem);\n+        ret lval_no_env(loc.bcx, loc.val, loc.kind);\n       }\n     }\n }\n@@ -3157,7 +3158,7 @@ fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n     // Silly check\n     check type_is_tup_like(bcx, ty);\n     let {bcx, val} = GEP_tup_like(bcx, ty, val, [0, ix as int]);\n-    ret {bcx: bcx, val: val, is_mem: true};\n+    ret {bcx: bcx, val: val, kind: owned};\n }\n \n fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n@@ -3206,7 +3207,7 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n             GEP(next_cx, body, [scaled_ix])\n         };\n \n-    ret lval_mem(next_cx, elt);\n+    ret lval_owned(next_cx, elt);\n }\n \n fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n@@ -3216,23 +3217,23 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n         // Lval means this is a record field, so not a method\n         if !expr_is_lval(bcx_tcx(bcx), e) {\n             let of = trans_object_field(bcx, base, ident);\n-            ret {bcx: of.bcx, val: of.mthptr, is_mem: true,\n+            ret {bcx: of.bcx, val: of.mthptr, kind: owned,\n                  env: obj_env(of.objptr), generic: none};\n         }\n       }\n       ast::expr_self_method(ident) {\n         alt bcx.fcx.llself {\n           some(pair) {\n             let fld = trans_object_field_inner(bcx, pair.v, ident, pair.t);\n-            ret {bcx: fld.bcx, val: fld.mthptr, is_mem: true,\n+            ret {bcx: fld.bcx, val: fld.mthptr, kind: owned,\n                  env: obj_env(fld.objptr), generic: none};\n           }\n         }\n       }\n       _ {}\n     }\n     let lv = trans_temp_lval(bcx, e);\n-    ret lval_no_env(lv.bcx, lv.val, lv.is_mem);\n+    ret lval_no_env(lv.bcx, lv.val, lv.kind);\n }\n \n fn expr_is_lval(tcx: ty::ctxt, e: @ast::expr) -> bool {\n@@ -3294,28 +3295,29 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n               }\n               ty::ty_ptr(_) | ty::ty_uniq(_) { sub.val }\n             };\n-        ret lval_mem(sub.bcx, val);\n+        ret lval_owned(sub.bcx, val);\n       }\n       // This is a by-ref returning call. Regular calls are not lval\n       ast::expr_call(f, args) {\n         let cell = empty_dest_cell();\n         let bcx = trans_call(cx, f, none, args, e.id, by_val(cell));\n-        ret lval_mem(bcx, *cell);\n+        ret lval_owned(bcx, *cell);\n       }\n       _ { bcx_ccx(cx).sess.span_bug(e.span, \"non-lval in trans_lval\"); }\n     }\n }\n \n fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n-    -> (bool, ValueRef) {\n+    -> (lval_kind, ValueRef) {\n     alt c.env {\n-      is_closure. { (c.is_mem, c.val) }\n+      is_closure. { (c.kind, c.val) }\n       obj_env(_) {\n         fail \"Taking the value of a method does not work yet (issue #435)\";\n       }\n       null_env. {\n         let llfnty = llvm::LLVMGetElementType(val_ty(c.val));\n-        (false, create_real_fn_pair(bcx, llfnty, c.val, null_env_ptr(bcx)))\n+        (temporary, create_real_fn_pair(bcx, llfnty, c.val,\n+                                        null_env_ptr(bcx)))\n       }\n     }\n }\n@@ -3329,11 +3331,11 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n         let bcx = trans_bind_1(space.bcx, ty, c, args, ty,\n                                save_in(space.val));\n         add_clean_temp(bcx, space.val, ty);\n-        ret lval_val(bcx, space.val);\n+        ret {bcx: bcx, val: space.val, kind: temporary};\n       }\n       none. {\n-        let (is_mem, val) = maybe_add_env(c.bcx, c);\n-        ret {bcx: c.bcx, val: val, is_mem: is_mem};\n+        let (kind, val) = maybe_add_env(c.bcx, c);\n+        ret {bcx: c.bcx, val: val, kind: kind};\n       }\n     }\n }\n@@ -3666,7 +3668,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n         let sp = cx.sp;\n         let llclosurety = T_ptr(type_of(ccx, sp, outgoing_fty));\n         let src_loc = PointerCast(bcx, cl, llclosurety);\n-        ([env_direct(src_loc, pair_ty)], none)\n+        ([env_direct(src_loc, pair_ty, true)], none)\n       }\n       none. { ([], some(f_res.val)) }\n     };\n@@ -3704,12 +3706,11 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n         val = llvm::LLVMGetUndef(lldestty0);\n     } else if arg.mode == ast::by_ref || arg.mode == ast::by_val {\n         let copied = false, imm = type_is_immediate(ccx, e_ty);\n-        if arg.mode == ast::by_ref && !lv.is_mem && imm {\n+        if arg.mode == ast::by_ref && lv.kind != owned && imm {\n             val = do_spill_noroot(bcx, val);\n             copied = true;\n         }\n-        if ccx.copy_map.contains_key(e.id) && lv.is_mem {\n-            assert lv.is_mem;\n+        if ccx.copy_map.contains_key(e.id) && lv.kind != temporary {\n             if !copied {\n                 let alloc = alloc_ty(bcx, e_ty);\n                 bcx = copy_val(alloc.bcx, INIT, alloc.val,\n@@ -3718,10 +3719,10 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n             } else { bcx = take_ty(bcx, val, e_ty); }\n             add_clean(bcx, val, e_ty);\n         }\n-        if arg.mode == ast::by_val && (lv.is_mem || !imm) {\n+        if arg.mode == ast::by_val && (lv.kind == owned || !imm) {\n             val = Load(bcx, val);\n         }\n-    } else if type_is_immediate(ccx, e_ty) && !lv.is_mem {\n+    } else if type_is_immediate(ccx, e_ty) && lv.kind != owned {\n         let r = do_spill(bcx, val, e_ty);\n         val = r.val;\n         bcx = r.bcx;\n@@ -3734,7 +3735,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n \n     // Collect arg for later if it happens to be one we've moving out.\n     if arg.mode == ast::by_move {\n-        if lv.is_mem {\n+        if lv.kind == owned {\n             // Use actual ty, not declared ty -- anything else doesn't make\n             // sense if declared ty is a ty param\n             to_zero += [{v: lv.val, t: e_ty}];\n@@ -3890,7 +3891,9 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n       obj_env(e) { llenv = e; }\n       is_closure. {\n         // It's a closure. Have to fetch the elements\n-        if f_res.is_mem { faddr = load_if_immediate(bcx, faddr, fn_expr_ty); }\n+        if f_res.kind == owned {\n+            faddr = load_if_immediate(bcx, faddr, fn_expr_ty);\n+        }\n         let pair = faddr;\n         faddr = GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_code)]);\n         faddr = Load(bcx, faddr);\n@@ -4208,7 +4211,7 @@ fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n }\n \n // Call this to compile an expression that you need as an intermediate value,\n-// and you want to know whether you're dealing with an lval or not (the is_mem\n+// and you want to know whether you're dealing with an lval or not (the kind\n // field in the returned struct). For non-immediates, use trans_expr or\n // trans_expr_save_in. For intermediates where you don't care about lval-ness,\n // use trans_temp_expr.\n@@ -4220,28 +4223,27 @@ fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n         let ty = ty::expr_ty(tcx, e);\n         if ty::type_is_nil(tcx, ty) || ty::type_is_bot(tcx, ty) {\n             bcx = trans_expr(bcx, e, ignore);\n-            ret {bcx: bcx, val: C_nil(), is_mem: false};\n+            ret {bcx: bcx, val: C_nil(), kind: temporary};\n         } else if type_is_immediate(bcx_ccx(bcx), ty) {\n             let cell = empty_dest_cell();\n             bcx = trans_expr(bcx, e, by_val(cell));\n             add_clean_temp(bcx, *cell, ty);\n-            ret {bcx: bcx, val: *cell, is_mem: false};\n+            ret {bcx: bcx, val: *cell, kind: temporary};\n         } else {\n             let {bcx, val: scratch} = alloc_ty(bcx, ty);\n             bcx = trans_expr(bcx, e, save_in(scratch));\n             add_clean_temp(bcx, scratch, ty);\n-            ret {bcx: bcx, val: scratch, is_mem: false};\n+            ret {bcx: bcx, val: scratch, kind: temporary};\n         }\n     }\n }\n \n // Use only for intermediate values. See trans_expr and trans_expr_save_in for\n // expressions that must 'end up somewhere' (or get ignored).\n fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n-    let {bcx, val, is_mem} = trans_temp_lval(bcx, e);\n-    if is_mem && type_is_immediate(bcx_ccx(bcx),\n-                                   ty::expr_ty(bcx_tcx(bcx), e)) {\n-        val = Load(bcx, val);\n+    let {bcx, val, kind} = trans_temp_lval(bcx, e);\n+    if kind == owned {\n+        val = load_if_immediate(bcx, val, ty::expr_ty(bcx_tcx(bcx), e));\n     }\n     ret {bcx: bcx, val: val};\n }\n@@ -4381,31 +4383,31 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n       ast::expr_assign(dst, src) {\n         assert dest == ignore;\n         let src_r = trans_temp_lval(bcx, src);\n-        let {bcx, val: addr, is_mem} = trans_lval(src_r.bcx, dst);\n-        assert is_mem;\n+        let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n+        assert kind == owned;\n         ret store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n                             ty::expr_ty(bcx_tcx(bcx), src));\n       }\n       ast::expr_move(dst, src) {\n         // FIXME: calculate copy init-ness in typestate.\n         assert dest == ignore;\n         let src_r = trans_temp_lval(bcx, src);\n-        let {bcx, val: addr, is_mem} = trans_lval(src_r.bcx, dst);\n-        assert is_mem;\n+        let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n+        assert kind == owned;\n         ret move_val(bcx, DROP_EXISTING, addr, src_r,\n                      ty::expr_ty(bcx_tcx(bcx), src));\n       }\n       ast::expr_swap(dst, src) {\n         assert dest == ignore;\n         let lhs_res = trans_lval(bcx, dst);\n-        assert (lhs_res.is_mem);\n+        assert lhs_res.kind == owned;\n         let rhs_res = trans_lval(lhs_res.bcx, src);\n         let t = ty::expr_ty(tcx, src);\n         let {bcx: bcx, val: tmp_alloc} = alloc_ty(rhs_res.bcx, t);\n         // Swap through a temporary.\n         bcx = move_val(bcx, INIT, tmp_alloc, lhs_res, t);\n         bcx = move_val(bcx, INIT, lhs_res.val, rhs_res, t);\n-        ret move_val(bcx, INIT, rhs_res.val, lval_mem(bcx, tmp_alloc), t);\n+        ret move_val(bcx, INIT, rhs_res.val, lval_owned(bcx, tmp_alloc), t);\n       }\n       ast::expr_assign_op(op, dst, src) {\n         assert dest == ignore;\n@@ -4416,11 +4418,11 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n \n fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     let lv = trans_lval(bcx, e);\n-    let {bcx, val, is_mem} = lv;\n+    let {bcx, val, kind} = lv;\n     let ty = ty::expr_ty(bcx_tcx(bcx), e);\n     alt dest {\n       by_val(cell) {\n-        if !is_mem {\n+        if kind != owned {\n             revoke_clean(bcx, val);\n             *cell = val;\n         } else if ty::type_is_unique(bcx_tcx(bcx), ty) {\n@@ -4683,8 +4685,8 @@ fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n     alt e {\n       some(x) {\n         if ast_util::ret_by_ref(bcx.fcx.ret_style) {\n-            let {bcx: cx, val, is_mem} = trans_lval(bcx, x);\n-            assert is_mem;\n+            let {bcx: cx, val, kind} = trans_lval(bcx, x);\n+            assert kind == owned;\n             Store(cx, val, bcx.fcx.llretptr);\n             bcx = cx;\n         } else {\n@@ -4720,7 +4722,16 @@ fn trans_be(cx: @block_ctxt, e: @ast::expr) : ast_util::is_call_expr(e) ->\n \n fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let ty = node_id_type(bcx_ccx(bcx), local.node.id);\n-    let llptr = bcx.fcx.lllocals.get(local.node.id);\n+    let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n+      some(local_mem(v)) { v }\n+      // This is a local that is kept immediate\n+      none. {\n+        let initexpr = alt local.node.init { some({expr, _}) { expr } };\n+        let val = trans_temp_expr(bcx, initexpr);\n+        bcx.fcx.lllocals.insert(local.node.pat.id, local_imm(val.val));\n+        ret val.bcx;\n+      }\n+    };\n \n     alt local.node.init {\n       some(init) {\n@@ -4736,16 +4747,15 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     }\n     // Make a note to drop this slot on the way out.\n     add_clean(bcx, llptr, ty);\n-    ret trans_alt::bind_irrefutable_pat(bcx, local.node.pat, llptr,\n-                                        bcx.fcx.lllocals, false);\n+    ret trans_alt::bind_irrefutable_pat(bcx, local.node.pat, llptr, false);\n }\n \n fn init_ref_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let init_expr = option::get(local.node.init).expr;\n     let val = trans_lval(bcx, init_expr);\n-    assert val.is_mem;\n-    ret trans_alt::bind_irrefutable_pat(val.bcx, local.node.pat,\n-                                        val.val, bcx.fcx.lllocals, false);\n+    assert val.kind == owned;\n+    ret trans_alt::bind_irrefutable_pat(val.bcx, local.node.pat, val.val,\n+                                        false);\n }\n \n fn zero_alloca(cx: @block_ctxt, llptr: ValueRef, t: ty::t)\n@@ -4971,20 +4981,33 @@ fn alloc_ty(cx: @block_ctxt, t: ty::t) -> result {\n     ret rslt(cx, val);\n }\n \n-fn alloc_local(cx: @block_ctxt, local: @ast::local) -> result {\n+fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let t = node_id_type(bcx_ccx(cx), local.node.id);\n+    let is_simple = alt local.node.pat.node {\n+      ast::pat_bind(_) { true } _ { false }\n+    };\n+    // Do not allocate space for locals that can be kept immediate.\n+    if is_simple && !bcx_ccx(cx).mut_map.contains_key(local.node.pat.id) &&\n+        ty::type_is_immediate(bcx_tcx(cx), t) &&\n+        !ty::type_needs_drop(bcx_tcx(cx), t) {\n+        alt local.node.init {\n+          some({op: ast::init_assign., _}) { ret cx; }\n+          _ {}\n+        }\n+    }\n     let r = alloc_ty(cx, t);\n     alt local.node.pat.node {\n       ast::pat_bind(ident) {\n         if bcx_ccx(cx).sess.get_opts().debuginfo {\n-            let _: () =\n-                str::as_buf(ident,\n-                            {|buf| llvm::LLVMSetValueName(r.val, buf) });\n+            let _: () = str::as_buf(ident, {|buf|\n+                llvm::LLVMSetValueName(r.val, buf)\n+            });\n         }\n       }\n       _ { }\n     }\n-    ret r;\n+    cx.fcx.lllocals.insert(local.node.id, local_mem(r.val));\n+    ret r.bcx;\n }\n \n fn trans_block(bcx: @block_ctxt, b: ast::blk) -> @block_ctxt {\n@@ -4994,10 +5017,7 @@ fn trans_block(bcx: @block_ctxt, b: ast::blk) -> @block_ctxt {\n fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n     -> @block_ctxt {\n     for each local: @ast::local in block_locals(b) {\n-        // FIXME Update bcx.sp\n-        let r = alloc_local(bcx, local);\n-        bcx = r.bcx;\n-        bcx.fcx.lllocals.insert(local.node.id, r.val);\n+        bcx = alloc_local(bcx, local);\n     }\n     for s: @ast::stmt in b.node.stmts {\n         bcx = trans_stmt(bcx, *s);\n@@ -5072,9 +5092,9 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: span, llfndecl: ValueRef,\n           mutable llself: none::<val_self_pair>,\n           mutable lliterbody: none::<ValueRef>,\n           mutable iterbodyty: none::<ty::t>,\n-          llargs: new_int_hash::<ValueRef>(),\n+          llargs: new_int_hash::<local_val>(),\n           llobjfields: new_int_hash::<ValueRef>(),\n-          lllocals: new_int_hash::<ValueRef>(),\n+          lllocals: new_int_hash::<local_val>(),\n           llupvars: new_int_hash::<ValueRef>(),\n           mutable lltydescs: [],\n           derived_tydescs: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n@@ -5139,7 +5159,10 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, proto: ast::proto,\n     for arg: ast::arg in args {\n         let llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n         assert (llarg as int != 0);\n-        cx.llargs.insert(arg.id, llarg);\n+        // Note that this uses local_mem even for things passed by value.\n+        // copy_args_to_allocas will overwrite the table entry with local_imm\n+        // before it's actually used.\n+        cx.llargs.insert(arg.id, local_mem(llarg));\n         arg_n += 1u;\n     }\n }\n@@ -5151,34 +5174,32 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n     for arg in arg_tys {\n         let id = args[arg_n].id;\n         let mutated = !ignore_mut && fcx.lcx.ccx.mut_map.contains_key(id);\n+        let argval = alt fcx.llargs.get(id) { local_mem(v) { v } };\n         alt arg.mode {\n-          ast::mode_infer. {\n-            bcx_ccx(bcx).sess.span_fatal(fcx.sp, \"this\");\n-          }\n-          ast::by_move. {\n-            add_clean(bcx, fcx.llargs.get(id), arg.ty);\n-          }\n           ast::by_mut_ref. { }\n+          ast::by_move. { add_clean(bcx, argval, arg.ty); }\n           ast::by_val. {\n-            let aval = fcx.llargs.get(id);\n-            let {bcx: cx, val: alloc} = alloc_ty(bcx, arg.ty);\n-            bcx = cx;\n-            Store(bcx, aval, alloc);\n-            if mutated {\n-                bcx = take_ty(bcx, alloc, arg.ty);\n-                add_clean(bcx, alloc, arg.ty);\n+            if mutated || !ty::type_is_immediate(bcx_tcx(bcx), arg.ty) {\n+                let {bcx: cx, val: alloc} = alloc_ty(bcx, arg.ty);\n+                bcx = cx;\n+                Store(bcx, argval, alloc);\n+                if mutated {\n+                    bcx = take_ty(bcx, alloc, arg.ty);\n+                    add_clean(bcx, alloc, arg.ty);\n+                }\n+                fcx.llargs.insert(id, local_mem(alloc));\n+            } else {\n+                fcx.llargs.insert(id, local_imm(argval));\n             }\n-            fcx.llargs.insert(id, alloc);\n           }\n           ast::by_ref. {\n             // Overwrite the llargs entry for locally mutated params\n             // with a local alloca.\n             if mutated {\n-                let aptr = fcx.llargs.get(id);\n                 let {bcx: cx, val: alloc} = alloc_ty(bcx, arg.ty);\n                 bcx = copy_val(cx, INIT, alloc,\n-                               load_if_immediate(cx, aptr, arg.ty), arg.ty);\n-                fcx.llargs.insert(id, alloc);\n+                               load_if_immediate(cx, argval, arg.ty), arg.ty);\n+                fcx.llargs.insert(id, local_mem(alloc));\n                 add_clean(bcx, alloc, arg.ty);\n             }\n           }\n@@ -5340,7 +5361,8 @@ fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::_fn,\n     let tup_t = ty::mk_tup(cx.ccx.tcx, [ty::mk_int(cx.ccx.tcx), arg_t]);\n     let arg;\n     alt fcx.llargs.find(dtor.decl.inputs[0].id) {\n-      some(x) { arg = load_if_immediate(bcx, x, arg_t); }\n+      some(local_mem(x)) { arg = load_if_immediate(bcx, x, arg_t); }\n+      some(local_imm(x)) { arg = x; }\n       _ { cx.ccx.sess.span_fatal(sp, \"unbound dtor decl in trans_res_ctor\"); }\n     }\n     let llretptr = fcx.llretptr;\n@@ -5429,14 +5451,9 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n \n-        let llargptr;\n-        alt fcx.llargs.find(va.id) {\n-          some(x) { llargptr = PointerCast(bcx, x, val_ty(lldestptr)); }\n-          none. {\n-            bcx_ccx(bcx).sess.bug(\"unbound argptr in \\\n-                                      trans_tag_variant\");\n-          }\n-        }\n+        let llargptr = alt fcx.llargs.find(va.id) {\n+          some(local_mem(x)) { PointerCast(bcx, x, val_ty(lldestptr)) }\n+        };\n         let arg_ty = arg_tys[i].ty;\n         let llargval;\n         if ty::type_is_structural(cx.ccx.tcx, arg_ty) ||"}, {"sha": "6ac217bdee9c0b8c61ed9edc6bd9dc8607f08c81", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/31586339b14e8c4167c3bf80d375881f3ff2fb19/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31586339b14e8c4167c3bf80d375881f3ff2fb19/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=31586339b14e8c4167c3bf80d375881f3ff2fb19", "patch": "@@ -357,8 +357,8 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             // Temporarily set bindings. They'll be rewritten to PHI nodes for\n             // the actual arm block.\n             for each @{key: key, val: val} in data.id_map.items() {\n-                bcx.fcx.lllocals.insert(val,\n-                                        option::get(assoc(key, m[0].bound)));\n+                let local = local_mem(option::get(assoc(key, m[0].bound)));\n+                bcx.fcx.lllocals.insert(val, local);\n             }\n             let {bcx: guard_bcx, val: guard_val} =\n                 trans::trans_temp_expr(guard_cx, e);\n@@ -593,21 +593,23 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n         }\n         if vec::len(vals) > 0u {\n             let local = Phi(bcx, val_ty(vals[0]), vals, llbbs);\n-            bcx.fcx.lllocals.insert(node_id, local);\n+            bcx.fcx.lllocals.insert(node_id, local_mem(local));\n         } else { success = false; }\n     }\n     if success {\n         // Copy references that the alias analysis considered unsafe\n         for each @{val: node_id, _} in ids.items() {\n             if bcx_ccx(bcx).copy_map.contains_key(node_id) {\n-                let local = bcx.fcx.lllocals.get(node_id);\n+                let local = alt bcx.fcx.lllocals.get(node_id) {\n+                  local_mem(x) { x }\n+                };\n                 let e_ty = ty::node_id_to_type(bcx_tcx(bcx), node_id);\n                 let {bcx: abcx, val: alloc} = trans::alloc_ty(bcx, e_ty);\n                 bcx = trans::copy_val(abcx, trans::INIT, alloc,\n                                       load_if_immediate(abcx, local, e_ty),\n                                       e_ty);\n                 add_clean(bcx, alloc, e_ty);\n-                bcx.fcx.lllocals.insert(node_id, alloc);\n+                bcx.fcx.lllocals.insert(node_id, local_mem(alloc));\n             }\n         }\n     } else {\n@@ -668,7 +670,6 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms: [ast::arm],\n \n // Not alt-related, but similar to the pattern-munging code above\n fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n-                        table: hashmap<ast::node_id, ValueRef>,\n                         make_copy: bool) -> @block_ctxt {\n     let ccx = bcx.fcx.lcx.ccx;\n     alt pat.node {\n@@ -684,17 +685,17 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n             bcx =\n                 trans::copy_val(bcx, trans::INIT, alloc,\n                                 trans::load_if_immediate(bcx, val, ty), ty);\n-            table.insert(pat.id, alloc);\n+            bcx.fcx.lllocals.insert(pat.id, local_mem(alloc));\n             trans_common::add_clean(bcx, alloc, ty);\n-        } else { table.insert(pat.id, val); }\n+        } else { bcx.fcx.lllocals.insert(pat.id, local_mem(val)); }\n       }\n       ast::pat_tag(_, sub) {\n         if vec::len(sub) == 0u { ret bcx; }\n         let vdefs = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);\n         let i = 0;\n         for argval: ValueRef in args.vals {\n-            bcx = bind_irrefutable_pat(bcx, sub[i], argval, table, make_copy);\n+            bcx = bind_irrefutable_pat(bcx, sub[i], argval, make_copy);\n             i += 1;\n         }\n       }\n@@ -708,7 +709,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n             // how to get rid of this check?\n             check type_is_tup_like(bcx, rec_ty);\n             let r = trans::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n-            bcx = bind_irrefutable_pat(r.bcx, f.pat, r.val, table, make_copy);\n+            bcx = bind_irrefutable_pat(r.bcx, f.pat, r.val, make_copy);\n         }\n       }\n       ast::pat_tup(elems) {\n@@ -718,7 +719,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n             // how to get rid of this check?\n             check type_is_tup_like(bcx, tup_ty);\n             let r = trans::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n-            bcx = bind_irrefutable_pat(r.bcx, elem, r.val, table, make_copy);\n+            bcx = bind_irrefutable_pat(r.bcx, elem, r.val, make_copy);\n             i += 1u;\n         }\n       }\n@@ -727,11 +728,11 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         let unboxed =\n             InBoundsGEP(bcx, box,\n                         [C_int(0), C_int(back::abi::box_rc_field_body)]);\n-        bcx = bind_irrefutable_pat(bcx, inner, unboxed, table, true);\n+        bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_uniq(inner) {\n         let val = Load(bcx, val);\n-        bcx = bind_irrefutable_pat(bcx, inner, val, table, true);\n+        bcx = bind_irrefutable_pat(bcx, inner, val, true);\n       }\n       ast::pat_wild. | ast::pat_lit(_) | ast::pat_range(_, _) { }\n     }"}, {"sha": "32dbb5334d7e7236a61f1056328f59fb7eb10991", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31586339b14e8c4167c3bf80d375881f3ff2fb19/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31586339b14e8c4167c3bf80d375881f3ff2fb19/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=31586339b14e8c4167c3bf80d375881f3ff2fb19", "patch": "@@ -135,6 +135,8 @@ type local_ctxt =\n // Types used for llself.\n type val_self_pair = {v: ValueRef, t: ty::t};\n \n+tag local_val { local_mem(ValueRef); local_imm(ValueRef); }\n+\n // Function context.  Every LLVM function we create will have one of\n // these.\n type fn_ctxt =\n@@ -245,9 +247,9 @@ type fn_ctxt =\n      mutable llself: option::t<val_self_pair>,\n      mutable lliterbody: option::t<ValueRef>,\n      mutable iterbodyty: option::t<ty::t>,\n-     llargs: hashmap<ast::node_id, ValueRef>,\n+     llargs: hashmap<ast::node_id, local_val>,\n      llobjfields: hashmap<ast::node_id, ValueRef>,\n-     lllocals: hashmap<ast::node_id, ValueRef>,\n+     lllocals: hashmap<ast::node_id, local_val>,\n      llupvars: hashmap<ast::node_id, ValueRef>,\n      mutable lltydescs: [ValueRef],\n      derived_tydescs: hashmap<ty::t, derived_tydesc_info>,"}, {"sha": "aabe09b3d058690998d290a6e9815f539e7dde06", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31586339b14e8c4167c3bf80d375881f3ff2fb19/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31586339b14e8c4167c3bf80d375881f3ff2fb19/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=31586339b14e8c4167c3bf80d375881f3ff2fb19", "patch": "@@ -180,7 +180,10 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n         for f: ast::obj_field in ob.fields {\n             alt bcx.fcx.llargs.find(f.id) {\n               some(arg1) {\n-                let arg = load_if_immediate(bcx, arg1, arg_tys[i].ty);\n+                let arg = alt arg1 {\n+                  local_mem(v) { load_if_immediate(bcx, v, arg_tys[i].ty) }\n+                  local_imm(v) { v }\n+                };\n                 // TODO: can we just get fields_ty out of body_ty instead?\n                 let fields_ty: ty::t = ty::mk_tup(ccx.tcx, obj_fields);\n                 // Silly check"}]}