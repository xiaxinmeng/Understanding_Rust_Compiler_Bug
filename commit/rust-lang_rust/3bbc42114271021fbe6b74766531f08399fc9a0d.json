{"sha": "3bbc42114271021fbe6b74766531f08399fc9a0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYmM0MjExNDI3MTAyMWZiZTZiNzQ3NjY1MzFmMDgzOTlmYzlhMGQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-09T02:52:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-09T02:52:37Z"}, "message": "Rollup merge of #62090 - davidtwco:ice-async-await-out-of-range-substitution, r=nikomatsakis\n\ntypeck: merge opaque type inference logic\n\nFixes #55872. See [relevant Zulip topic](https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations/topic/type.20parameter.20out.20of.20range.20.2355872).\n\nr? @nikomatsakis", "tree": {"sha": "abb935eb8c6b78b6385f69dd1e1f19309ba35604", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abb935eb8c6b78b6385f69dd1e1f19309ba35604"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bbc42114271021fbe6b74766531f08399fc9a0d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdJAF1CRBK7hj4Ov3rIwAAdHIIABbcdsVxHM6/SZiyb/XxQMA0\nAsdqQj4HcIu9w1xEbrgLqbijA3sfFTS/KMX3OTTt3WU8QduQuI8AVT+4JeVP8Rtb\nwV3xYqCtSlWXnvF8EKPvkNdAMyFtw7A9cnoml++8CjeBF/jhV1cO1BEooKIa3Vvp\nBLbfcMsRt1n/HbIQnda7Gm4jZJVuVRRSkKXiLI8DyiZIn6PKi8QUqcxIBl9Ix7Fy\nJSp0qrt6R2ixypX6Yt8QXhw8jphkKrcItCH4OP3NXDg8JBzUOblO3djdREXhseMk\ncTxqP4MxlIx3HHiMjHcOHZvgQf+T7/M3galBz6X6rjmYlO3qt4qIzsagwybZ5ew=\n=/Y2P\n-----END PGP SIGNATURE-----\n", "payload": "tree abb935eb8c6b78b6385f69dd1e1f19309ba35604\nparent fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c\nparent de8660ab610f046bbdeb1a90f2c94cba1d3d3185\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1562640757 +0200\ncommitter GitHub <noreply@github.com> 1562640757 +0200\n\nRollup merge of #62090 - davidtwco:ice-async-await-out-of-range-substitution, r=nikomatsakis\n\ntypeck: merge opaque type inference logic\n\nFixes #55872. See [relevant Zulip topic](https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations/topic/type.20parameter.20out.20of.20range.20.2355872).\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bbc42114271021fbe6b74766531f08399fc9a0d", "html_url": "https://github.com/rust-lang/rust/commit/3bbc42114271021fbe6b74766531f08399fc9a0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bbc42114271021fbe6b74766531f08399fc9a0d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c", "html_url": "https://github.com/rust-lang/rust/commit/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c"}, {"sha": "de8660ab610f046bbdeb1a90f2c94cba1d3d3185", "url": "https://api.github.com/repos/rust-lang/rust/commits/de8660ab610f046bbdeb1a90f2c94cba1d3d3185", "html_url": "https://github.com/rust-lang/rust/commit/de8660ab610f046bbdeb1a90f2c94cba1d3d3185"}], "stats": {"total": 356, "additions": 217, "deletions": 139}, "files": [{"sha": "f3dc4d3f72a9b37129c46cbfbcdffc82b4f2f1d7", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=3bbc42114271021fbe6b74766531f08399fc9a0d", "patch": "@@ -4,6 +4,7 @@ use crate::hir::Node;\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::middle::region;\n+use crate::mir::interpret::ConstValue;\n use crate::traits::{self, PredicateObligation};\n use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::subst::{InternalSubsts, Kind, SubstsRef, UnpackedKind};\n@@ -553,6 +554,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         def_id: DefId,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         instantiated_ty: Ty<'tcx>,\n+        span: Span,\n     ) -> Ty<'tcx> {\n         debug!(\n             \"infer_opaque_definition_from_instantiation(def_id={:?}, instantiated_ty={:?})\",\n@@ -584,6 +586,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             def_id,\n             map,\n             instantiated_ty,\n+            span,\n         ));\n         debug!(\"infer_opaque_definition_from_instantiation: definition_ty={:?}\", definition_ty);\n \n@@ -761,6 +764,9 @@ struct ReverseMapper<'tcx> {\n \n     /// initially `Some`, set to `None` once error has been reported\n     hidden_ty: Option<Ty<'tcx>>,\n+\n+    /// Span of function being checked.\n+    span: Span,\n }\n \n impl ReverseMapper<'tcx> {\n@@ -770,6 +776,7 @@ impl ReverseMapper<'tcx> {\n         opaque_type_def_id: DefId,\n         map: FxHashMap<Kind<'tcx>, Kind<'tcx>>,\n         hidden_ty: Ty<'tcx>,\n+        span: Span,\n     ) -> Self {\n         Self {\n             tcx,\n@@ -778,6 +785,7 @@ impl ReverseMapper<'tcx> {\n             map,\n             map_missing_regions_to_empty: false,\n             hidden_ty: Some(hidden_ty),\n+            span,\n         }\n     }\n \n@@ -812,10 +820,11 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             _ => { }\n         }\n \n+        let generics = self.tcx().generics_of(self.opaque_type_def_id);\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n             Some(UnpackedKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None => {\n+            None if generics.parent.is_some() => {\n                 if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n                     if let Some(hidden_ty) = self.hidden_ty.take() {\n                         unexpected_hidden_region_diagnostic(\n@@ -829,6 +838,21 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 }\n                 self.tcx.lifetimes.re_empty\n             }\n+            None => {\n+                self.tcx.sess\n+                    .struct_span_err(\n+                        self.span,\n+                        \"non-defining existential type use in defining scope\"\n+                    )\n+                    .span_label(\n+                        self.span,\n+                        format!(\"lifetime `{}` is part of concrete type but not used in \\\n+                                 parameter list of existential type\", r),\n+                    )\n+                    .emit();\n+\n+                self.tcx().global_tcx().mk_region(ty::ReStatic)\n+            },\n         }\n     }\n \n@@ -890,9 +914,59 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 self.tcx.mk_generator(def_id, ty::GeneratorSubsts { substs }, movability)\n             }\n \n+            ty::Param(..) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list; replace with the parameter from the\n+                    // existential type.\n+                    Some(UnpackedKind::Type(t1)) => t1,\n+                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        self.tcx.sess\n+                            .struct_span_err(\n+                                self.span,\n+                                &format!(\"type parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for existential type\", ty),\n+                            )\n+                            .emit();\n+\n+                        self.tcx().types.err\n+                    }\n+                }\n+            }\n+\n             _ => ty.super_fold_with(self),\n         }\n     }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        trace!(\"checking const {:?}\", ct);\n+        // Find a const parameter\n+        match ct.val {\n+            ConstValue::Param(..) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list, replace with the parameter from the\n+                    // existential type.\n+                    Some(UnpackedKind::Const(c1)) => c1,\n+                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        self.tcx.sess\n+                            .struct_span_err(\n+                                self.span,\n+                                &format!(\"const parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for existential type\", ct)\n+                            )\n+                            .emit();\n+\n+                        self.tcx().consts.err\n+                    }\n+                }\n+            }\n+\n+            _ => ct,\n+        }\n+    }\n }\n \n struct Instantiator<'a, 'tcx> {"}, {"sha": "145b37ff907abb29fe1c51bea3739a63159191ef", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 15, "deletions": 138, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=3bbc42114271021fbe6b74766531f08399fc9a0d", "patch": "@@ -9,10 +9,8 @@ use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::infer::InferCtxt;\n use rustc::ty::adjustment::{Adjust, Adjustment, PointerCast};\n-use rustc::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n-use rustc::ty::subst::UnpackedKind;\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::mir::interpret::ConstValue;\n use rustc::util::nodemap::DefIdSet;\n use rustc_data_structures::sync::Lrc;\n use std::mem;\n@@ -440,141 +438,20 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n \n-            let generics = self.tcx().generics_of(def_id);\n-\n-            let definition_ty = if generics.parent.is_some() {\n-                // `impl Trait`\n-                self.fcx.infer_opaque_definition_from_instantiation(\n-                    def_id,\n-                    opaque_defn,\n-                    instantiated_ty,\n-                )\n-            } else {\n-                // Prevent:\n-                // * `fn foo<T>() -> Foo<T>`\n-                // * `fn foo<T: Bound + Other>() -> Foo<T>`\n-                // from being defining.\n-\n-                // Also replace all generic params with the ones from the existential type\n-                // definition so that\n-                // ```rust\n-                // existential type Foo<T>: 'static;\n-                // fn foo<U>() -> Foo<U> { .. }\n-                // ```\n-                // figures out the concrete type with `U`, but the stored type is with `T`.\n-                instantiated_ty.fold_with(&mut BottomUpFolder {\n-                    tcx: self.tcx().global_tcx(),\n-                    ty_op: |ty| {\n-                        trace!(\"checking type {:?}\", ty);\n-                        // Find a type parameter.\n-                        if let ty::Param(..) = ty.sty {\n-                            // Look it up in the substitution list.\n-                            assert_eq!(opaque_defn.substs.len(), generics.params.len());\n-                            for (subst, param) in opaque_defn.substs.iter().zip(&generics.params) {\n-                                if let UnpackedKind::Type(subst) = subst.unpack() {\n-                                    if subst == ty {\n-                                        // Found it in the substitution list; replace with the\n-                                        // parameter from the existential type.\n-                                        return self.tcx()\n-                                            .global_tcx()\n-                                            .mk_ty_param(param.index, param.name);\n-                                    }\n-                                }\n-                            }\n-                            self.tcx()\n-                                .sess\n-                                .struct_span_err(\n-                                    span,\n-                                    &format!(\n-                                        \"type parameter `{}` is part of concrete type but not used \\\n-                                         in parameter list for existential type\",\n-                                        ty,\n-                                    ),\n-                                )\n-                                .emit();\n-                            return self.tcx().types.err;\n-                        }\n-                        ty\n-                    },\n-                    lt_op: |region| {\n-                        match region {\n-                            // Skip static and bound regions: they don't require substitution.\n-                            ty::ReStatic | ty::ReLateBound(..) => region,\n-                            _ => {\n-                                trace!(\"checking {:?}\", region);\n-                                for (subst, p) in opaque_defn.substs.iter().zip(&generics.params) {\n-                                    if let UnpackedKind::Lifetime(subst) = subst.unpack() {\n-                                        if subst == region {\n-                                            // Found it in the substitution list; replace with the\n-                                            // parameter from the existential type.\n-                                            let reg = ty::EarlyBoundRegion {\n-                                                def_id: p.def_id,\n-                                                index: p.index,\n-                                                name: p.name,\n-                                            };\n-                                            trace!(\"replace {:?} with {:?}\", region, reg);\n-                                            return self.tcx()\n-                                                .global_tcx()\n-                                                .mk_region(ty::ReEarlyBound(reg));\n-                                        }\n-                                    }\n-                                }\n-                                trace!(\"opaque_defn: {:#?}\", opaque_defn);\n-                                trace!(\"generics: {:#?}\", generics);\n-                                self.tcx()\n-                                    .sess\n-                                    .struct_span_err(\n-                                        span,\n-                                        \"non-defining existential type use in defining scope\",\n-                                    )\n-                                    .span_label(\n-                                        span,\n-                                        format!(\n-                                            \"lifetime `{}` is part of concrete type but not used \\\n-                                             in parameter list of existential type\",\n-                                            region,\n-                                        ),\n-                                    )\n-                                    .emit();\n-                                self.tcx().global_tcx().mk_region(ty::ReStatic)\n-                            }\n-                        }\n-                    },\n-                    ct_op: |ct| {\n-                        trace!(\"checking const {:?}\", ct);\n-                        // Find a const parameter\n-                        if let ConstValue::Param(..) = ct.val {\n-                            // look it up in the substitution list\n-                            assert_eq!(opaque_defn.substs.len(), generics.params.len());\n-                            for (subst, param) in opaque_defn.substs.iter()\n-                                                                    .zip(&generics.params) {\n-                                if let UnpackedKind::Const(subst) = subst.unpack() {\n-                                    if subst == ct {\n-                                        // found it in the substitution list, replace with the\n-                                        // parameter from the existential type\n-                                        return self.tcx()\n-                                            .global_tcx()\n-                                            .mk_const_param(param.index, param.name, ct.ty);\n-                                    }\n-                                }\n-                            }\n-                            self.tcx()\n-                                .sess\n-                                .struct_span_err(\n-                                    span,\n-                                    &format!(\n-                                        \"const parameter `{}` is part of concrete type but not \\\n-                                            used in parameter list for existential type\",\n-                                        ct,\n-                                    ),\n-                                )\n-                                .emit();\n-                            return self.tcx().consts.err;\n-                        }\n-                        ct\n-                    }\n-                })\n-            };\n+            // Prevent:\n+            // * `fn foo<T>() -> Foo<T>`\n+            // * `fn foo<T: Bound + Other>() -> Foo<T>`\n+            // from being defining.\n+\n+            // Also replace all generic params with the ones from the existential type\n+            // definition so that\n+            // ```rust\n+            // existential type Foo<T>: 'static;\n+            // fn foo<U>() -> Foo<U> { .. }\n+            // ```\n+            // figures out the concrete type with `U`, but the stored type is with `T`.\n+            let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n+                def_id, opaque_defn, instantiated_ty, span);\n \n             if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.sty {\n                 if def_id == defin_ty_def_id {"}, {"sha": "5095b26f8a4e0f935f0abbc240fb4cce9634a939", "filename": "src/test/ui/impl-trait/issue-55872-1.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs?ref=3bbc42114271021fbe6b74766531f08399fc9a0d", "patch": "@@ -0,0 +1,22 @@\n+// ignore-tidy-linelength\n+#![feature(existential_type)]\n+\n+pub trait Bar\n+{\n+    type E: Copy;\n+\n+    fn foo<T>() -> Self::E;\n+}\n+\n+impl<S: Default> Bar for S {\n+    existential type E: Copy;\n+    //~^ ERROR the trait bound `S: std::marker::Copy` is not satisfied in `(S, T)` [E0277]\n+    //~^^ ERROR the trait bound `T: std::marker::Copy` is not satisfied in `(S, T)` [E0277]\n+\n+    fn foo<T: Default>() -> Self::E {\n+    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for existential type\n+        (S::default(), T::default())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "04b4d2d4a50a53008b127f53943ebb6d011b0110", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=3bbc42114271021fbe6b74766531f08399fc9a0d", "patch": "@@ -0,0 +1,33 @@\n+error[E0277]: the trait bound `S: std::marker::Copy` is not satisfied in `(S, T)`\n+  --> $DIR/issue-55872-1.rs:12:5\n+   |\n+LL |     existential type E: Copy;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `S`\n+   |\n+   = help: consider adding a `where S: std::marker::Copy` bound\n+   = note: required because it appears within the type `(S, T)`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied in `(S, T)`\n+  --> $DIR/issue-55872-1.rs:12:5\n+   |\n+LL |     existential type E: Copy;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `T`\n+   |\n+   = help: consider adding a `where T: std::marker::Copy` bound\n+   = note: required because it appears within the type `(S, T)`\n+   = note: the return type of a function must have a statically known size\n+\n+error: type parameter `T` is part of concrete type but not used in parameter list for existential type\n+  --> $DIR/issue-55872-1.rs:16:37\n+   |\n+LL |       fn foo<T: Default>() -> Self::E {\n+   |  _____________________________________^\n+LL | |\n+LL | |         (S::default(), T::default())\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2bdeb14bdc3e6fd9144fd1497c69691401334bed", "filename": "src/test/ui/impl-trait/issue-55872-2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs?ref=3bbc42114271021fbe6b74766531f08399fc9a0d", "patch": "@@ -0,0 +1,20 @@\n+// edition:2018\n+// ignore-tidy-linelength\n+#![feature(async_await, existential_type)]\n+\n+pub trait Bar {\n+    type E: Copy;\n+\n+    fn foo<T>() -> Self::E;\n+}\n+\n+impl<S> Bar for S {\n+    existential type E: Copy;\n+    //~^ ERROR the trait bound `impl std::future::Future: std::marker::Copy` is not satisfied [E0277]\n+    fn foo<T>() -> Self::E {\n+    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for existential type\n+        async {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2505a82ee23cb30638858453dbfd2ff8c4eea99c", "filename": "src/test/ui/impl-trait/issue-55872-2.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr?ref=3bbc42114271021fbe6b74766531f08399fc9a0d", "patch": "@@ -0,0 +1,21 @@\n+error[E0277]: the trait bound `impl std::future::Future: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-55872-2.rs:12:5\n+   |\n+LL |     existential type E: Copy;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `impl std::future::Future`\n+   |\n+   = note: the return type of a function must have a statically known size\n+\n+error: type parameter `T` is part of concrete type but not used in parameter list for existential type\n+  --> $DIR/issue-55872-2.rs:14:28\n+   |\n+LL |       fn foo<T>() -> Self::E {\n+   |  ____________________________^\n+LL | |\n+LL | |         async {}\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "95604545c37f18b29dc52a89e9acb553fa72b444", "filename": "src/test/ui/impl-trait/issue-55872.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs?ref=3bbc42114271021fbe6b74766531f08399fc9a0d", "patch": "@@ -0,0 +1,19 @@\n+// ignore-tidy-linelength\n+#![feature(existential_type)]\n+\n+pub trait Bar {\n+    type E: Copy;\n+\n+    fn foo<T>() -> Self::E;\n+}\n+\n+impl<S> Bar for S {\n+    existential type E: Copy;\n+\n+    fn foo<T>() -> Self::E {\n+    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for existential type\n+        || ()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "487f276e317e9ff3026eee37d2fb7862e3358c35", "filename": "src/test/ui/impl-trait/issue-55872.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3bbc42114271021fbe6b74766531f08399fc9a0d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr?ref=3bbc42114271021fbe6b74766531f08399fc9a0d", "patch": "@@ -0,0 +1,12 @@\n+error: type parameter `T` is part of concrete type but not used in parameter list for existential type\n+  --> $DIR/issue-55872.rs:13:28\n+   |\n+LL |       fn foo<T>() -> Self::E {\n+   |  ____________________________^\n+LL | |\n+LL | |         || ()\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to previous error\n+"}]}