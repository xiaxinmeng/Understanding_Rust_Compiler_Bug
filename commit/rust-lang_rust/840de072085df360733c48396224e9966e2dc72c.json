{"sha": "840de072085df360733c48396224e9966e2dc72c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MGRlMDcyMDg1ZGYzNjA3MzNjNDgzOTYyMjRlOTk2NmUyZGM3MmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-19T02:52:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-19T02:52:01Z"}, "message": "auto merge of #19955 : Gankro/rust/kill-all-code, r=aturon\n\nEnumSet lives on in libcollections so that librustc can still use it. This adds a direct dependency on libcollections to librustc and libserialize.\r\n\r\nShould not be merged until https://github.com/rust-lang/rfcs/pull/509 is accepted.\r\n\r\nAll of these collections have already been moved to collect-rs where they will ideally be maintained and experimented with, or will be replaced by something better: https://github.com/Gankro/collect-rs/\r\n\r\n[breaking-change]\r\n\r\nr? @aturon @alexcrichton", "tree": {"sha": "32a78633b0a580c05050da6cfc7036ded796364a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32a78633b0a580c05050da6cfc7036ded796364a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/840de072085df360733c48396224e9966e2dc72c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/840de072085df360733c48396224e9966e2dc72c", "html_url": "https://github.com/rust-lang/rust/commit/840de072085df360733c48396224e9966e2dc72c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/840de072085df360733c48396224e9966e2dc72c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99d6956c3bdb290b9fd539c5dc15a2b502da5e7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a", "html_url": "https://github.com/rust-lang/rust/commit/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a"}, {"sha": "67d3823fc3ffa8b4e86a2d7cb007339a042605e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/67d3823fc3ffa8b4e86a2d7cb007339a042605e7", "html_url": "https://github.com/rust-lang/rust/commit/67d3823fc3ffa8b4e86a2d7cb007339a042605e7"}], "stats": {"total": 6878, "additions": 65, "deletions": 6813}, "files": [{"sha": "a8eb10e51635ff975c8725766a5c075af2fa434a", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -46,10 +46,6 @@ pub use dlist::DList;\n pub use enum_set::EnumSet;\n pub use ring_buf::RingBuf;\n pub use string::String;\n-pub use tree_map::TreeMap;\n-pub use tree_set::TreeSet;\n-pub use trie_map::TrieMap;\n-pub use trie_set::TrieSet;\n pub use vec::Vec;\n pub use vec_map::VecMap;\n \n@@ -61,8 +57,6 @@ mod btree;\n pub mod dlist;\n pub mod enum_set;\n pub mod ring_buf;\n-mod tree;\n-mod trie;\n pub mod slice;\n pub mod str;\n pub mod string;\n@@ -77,22 +71,6 @@ pub mod bitv_set {\n     pub use bit::{BitvSet, BitPositions, TwoBitPositions};\n }\n \n-pub mod tree_map {\n-    pub use tree::map::*;\n-}\n-\n-pub mod tree_set {\n-    pub use tree::set::*;\n-}\n-\n-pub mod trie_map {\n-    pub use trie::map::*;\n-}\n-\n-pub mod trie_set {\n-    pub use trie::set::*;\n-}\n-\n pub mod btree_map {\n     pub use btree::map::*;\n }"}, {"sha": "cc667285d29f37e6efbbe3f10681af3bed1b61fc", "filename": "src/libcollections/tree/map.rs", "status": "removed", "additions": 0, "deletions": 1961, "changes": 1961, "blob_url": "https://github.com/rust-lang/rust/blob/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=99d6956c3bdb290b9fd539c5dc15a2b502da5e7a", "patch": "@@ -1,1961 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use alloc::boxed::Box;\n-\n-use core::borrow::BorrowFrom;\n-use core::default::Default;\n-use core::fmt;\n-use core::fmt::Show;\n-use core::iter;\n-use core::mem::{replace, swap};\n-use core::ptr;\n-use std::hash::{Writer, Hash};\n-\n-use vec::Vec;\n-\n-// FIXME(conventions): implement bounded iterators\n-// FIXME(conventions): replace rev_iter(_mut) by making iter(_mut) DoubleEnded\n-\n-/// This is implemented as an AA tree, which is a simplified variation of\n-/// a red-black tree where red (horizontal) nodes can only be added\n-/// as a right child. The time complexity is the same, and re-balancing\n-/// operations are more frequent but also cheaper.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::collections::TreeMap;\n-///\n-/// let mut map = TreeMap::new();\n-///\n-/// map.insert(2i, \"bar\");\n-/// map.insert(1i, \"foo\");\n-/// map.insert(3i, \"quux\");\n-///\n-/// // In ascending order by keys\n-/// for (key, value) in map.iter() {\n-///     println!(\"{}: {}\", key, value);\n-/// }\n-///\n-/// // Prints 1, 2, 3\n-/// for key in map.keys() {\n-///     println!(\"{}\", key);\n-/// }\n-///\n-/// // Prints `foo`, `bar`, `quux`\n-/// for key in map.values() {\n-///     println!(\"{}\", key);\n-/// }\n-///\n-/// map.remove(&1);\n-/// assert_eq!(map.len(), 2);\n-///\n-/// if !map.contains_key(&1) {\n-///     println!(\"1 is no more\");\n-/// }\n-///\n-/// for key in range(0, 4) {\n-///     match map.get(&key) {\n-///         Some(val) => println!(\"{} has a value: {}\", key, val),\n-///         None => println!(\"{} not in map\", key),\n-///     }\n-/// }\n-///\n-/// map.clear();\n-/// assert!(map.is_empty());\n-/// ```\n-///\n-/// The easiest way to use `TreeMap` with a custom type as keys is to implement `Ord`.\n-/// We must also implement `PartialEq`, `Eq` and `PartialOrd`.\n-///\n-/// ```\n-/// use std::collections::TreeMap;\n-///\n-/// // We need `Eq` and `PartialEq`, these can be derived.\n-/// #[deriving(Eq, PartialEq)]\n-/// struct Troll<'a> {\n-///     name: &'a str,\n-///     level: uint,\n-/// }\n-///\n-/// // Implement `Ord` and sort trolls by level.\n-/// impl<'a> Ord for Troll<'a> {\n-///     fn cmp(&self, other: &Troll) -> Ordering {\n-///         // If we swap `self` and `other`, we get descending ordering.\n-///         self.level.cmp(&other.level)\n-///     }\n-/// }\n-///\n-/// // `PartialOrd` needs to be implemented as well.\n-/// impl<'a> PartialOrd for Troll<'a> {\n-///     fn partial_cmp(&self, other: &Troll) -> Option<Ordering> {\n-///         Some(self.cmp(other))\n-///     }\n-/// }\n-///\n-/// // Use a map to store trolls, sorted by level, and track a list of\n-/// // heroes slain.\n-/// let mut trolls = TreeMap::new();\n-///\n-/// trolls.insert(Troll { name: \"Orgarr\", level: 2 },\n-///               vec![\"King Karl\"]);\n-/// trolls.insert(Troll { name: \"Blargarr\", level: 3 },\n-///               vec![\"Odd\"]);\n-/// trolls.insert(Troll { name: \"Kron the Smelly One\", level: 4 },\n-///               vec![\"Omar the Brave\", \"Peter: Slayer of Trolls\"]);\n-/// trolls.insert(Troll { name: \"Wartilda\", level: 1 },\n-///               vec![]);\n-///\n-/// println!(\"You are facing {} trolls!\", trolls.len());\n-///\n-/// // Print the trolls, ordered by level with smallest level first\n-/// for (troll, heroes) in trolls.iter() {\n-///     let what = if heroes.len() == 1u { \"hero\" }\n-///                else { \"heroes\" };\n-///\n-///     println!(\"level {}: '{}' has slain {} {}\",\n-///              troll.level, troll.name, heroes.len(), what);\n-/// }\n-///\n-/// // Kill all trolls\n-/// trolls.clear();\n-/// assert_eq!(trolls.len(), 0);\n-/// ```\n-\n-// Future improvements:\n-\n-// range search - O(log n) retrieval of an iterator from some key\n-\n-// (possibly) implement the overloads Python does for sets:\n-//   * intersection: &\n-//   * difference: -\n-//   * symmetric difference: ^\n-//   * union: |\n-// These would be convenient since the methods work like `each`\n-\n-#[deriving(Clone)]\n-pub struct TreeMap<K, V> {\n-    root: Option<Box<TreeNode<K, V>>>,\n-    length: uint\n-}\n-\n-impl<K: PartialEq + Ord, V: PartialEq> PartialEq for TreeMap<K, V> {\n-    fn eq(&self, other: &TreeMap<K, V>) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().zip(other.iter()).all(|(a, b)| a == b)\n-    }\n-}\n-\n-impl<K: Eq + Ord, V: Eq> Eq for TreeMap<K, V> {}\n-\n-impl<K: Ord, V: PartialOrd> PartialOrd for TreeMap<K, V> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &TreeMap<K, V>) -> Option<Ordering> {\n-        iter::order::partial_cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-impl<K: Ord, V: Ord> Ord for TreeMap<K, V> {\n-    #[inline]\n-    fn cmp(&self, other: &TreeMap<K, V>) -> Ordering {\n-        iter::order::cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-impl<K: Ord + Show, V: Show> Show for TreeMap<K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n-\n-        for (i, (k, v)) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}: {}\", *k, *v));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-#[stable]\n-impl<K: Ord, V> Default for TreeMap<K,V> {\n-    #[inline]\n-    #[stable]\n-    fn default() -> TreeMap<K, V> { TreeMap::new() }\n-}\n-\n-impl<K: Ord, Sized? Q, V> Index<Q, V> for TreeMap<K, V> where Q: BorrowFrom<K> + Ord {\n-    #[inline]\n-    fn index<'a>(&'a self, i: &Q) -> &'a V {\n-        self.get(i).expect(\"no entry found for key\")\n-    }\n-}\n-\n-impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for TreeMap<K, V> where Q: BorrowFrom<K> + Ord {\n-    #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &Q) -> &'a mut V {\n-        self.get_mut(i).expect(\"no entry found for key\")\n-    }\n-}\n-\n-impl<K: Ord, V> TreeMap<K, V> {\n-    /// Creates an empty `TreeMap`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    /// let mut map: TreeMap<&str, int> = TreeMap::new();\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n-\n-    /// Gets a lazy iterator over the keys in the map, in ascending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// map.insert(\"c\", 3i);\n-    /// map.insert(\"b\", 2i);\n-    ///\n-    /// // Print \"a\", \"b\", \"c\" in order.\n-    /// for x in map.keys() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-\n-        self.iter().map(first)\n-    }\n-\n-    /// Gets a lazy iterator over the values in the map, in ascending order\n-    /// with respect to the corresponding keys.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// map.insert(\"c\", 3i);\n-    /// map.insert(\"b\", 2i);\n-    ///\n-    /// // Print 1, 2, 3 ordered by keys.\n-    /// for x in map.values() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n-        fn second<A, B>((_, b): (A, B)) -> B { b }\n-\n-        self.iter().map(second)\n-    }\n-\n-    /// Gets a lazy iterator over the key-value pairs in the map, in ascending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// map.insert(\"c\", 3i);\n-    /// map.insert(\"b\", 2i);\n-    ///\n-    /// // Print contents in ascending order\n-    /// for (key, value) in map.iter() {\n-    ///     println!(\"{}: {}\", key, value);\n-    /// }\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n-        Entries {\n-            stack: vec!(),\n-            node: deref(&self.root),\n-            remaining_min: self.length,\n-            remaining_max: self.length\n-        }\n-    }\n-\n-    /// Gets a lazy reverse iterator over the key-value pairs in the map, in descending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// map.insert(\"c\", 3i);\n-    /// map.insert(\"b\", 2i);\n-    ///\n-    /// // Print contents in descending order\n-    /// for (key, value) in map.rev_iter() {\n-    ///     println!(\"{}: {}\", key, value);\n-    /// }\n-    /// ```\n-    pub fn rev_iter<'a>(&'a self) -> RevEntries<'a, K, V> {\n-        RevEntries{iter: self.iter()}\n-    }\n-\n-    /// Gets a lazy forward iterator over the key-value pairs in the\n-    /// map, with the values being mutable.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// map.insert(\"c\", 3i);\n-    /// map.insert(\"b\", 2i);\n-    ///\n-    /// // Add 10 until we find \"b\"\n-    /// for (key, value) in map.iter_mut() {\n-    ///     *value += 10;\n-    ///     if key == &\"b\" { break }\n-    /// }\n-    ///\n-    /// assert_eq!(map.get(&\"a\"), Some(&11));\n-    /// assert_eq!(map.get(&\"b\"), Some(&12));\n-    /// assert_eq!(map.get(&\"c\"), Some(&3));\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n-        MutEntries {\n-            stack: vec!(),\n-            node: deref_mut(&mut self.root),\n-            remaining_min: self.length,\n-            remaining_max: self.length\n-        }\n-    }\n-\n-    /// Gets a lazy reverse iterator over the key-value pairs in the\n-    /// map, with the values being mutable.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// map.insert(\"c\", 3i);\n-    /// map.insert(\"b\", 2i);\n-    ///\n-    /// // Add 10 until we find \"b\"\n-    /// for (key, value) in map.rev_iter_mut() {\n-    ///     *value += 10;\n-    ///     if key == &\"b\" { break }\n-    /// }\n-    ///\n-    /// assert_eq!(map.get(&\"a\"), Some(&1));\n-    /// assert_eq!(map.get(&\"b\"), Some(&12));\n-    /// assert_eq!(map.get(&\"c\"), Some(&13));\n-    /// ```\n-    pub fn rev_iter_mut<'a>(&'a mut self) -> RevMutEntries<'a, K, V> {\n-        RevMutEntries{iter: self.iter_mut()}\n-    }\n-\n-    /// Gets a lazy iterator that consumes the treemap.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// map.insert(\"c\", 3i);\n-    /// map.insert(\"b\", 2i);\n-    ///\n-    /// // Not possible with a regular `.iter()`\n-    /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n-    /// assert_eq!(vec, vec![(\"a\", 1), (\"b\", 2), (\"c\", 3)]);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveEntries<K, V> {\n-        let TreeMap { root, length } = self;\n-        let stk = match root {\n-            None => vec!(),\n-            Some(box tn) => vec!(tn)\n-        };\n-        MoveEntries {\n-            stack: stk,\n-            remaining: length\n-        }\n-    }\n-\n-    /// Return the number of elements in the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut a = TreeMap::new();\n-    /// assert_eq!(a.len(), 0);\n-    /// a.insert(1u, \"a\");\n-    /// assert_eq!(a.len(), 1);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn len(&self) -> uint { self.length }\n-\n-    /// Return true if the map contains no elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut a = TreeMap::new();\n-    /// assert!(a.is_empty());\n-    /// a.insert(1u, \"a\");\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    #[inline]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clears the map, removing all values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut a = TreeMap::new();\n-    /// a.insert(1u, \"a\");\n-    /// a.clear();\n-    /// assert!(a.is_empty());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn clear(&mut self) {\n-        self.root = None;\n-        self.length = 0\n-    }\n-\n-    /// Deprecated: Renamed to `get`.\n-    #[deprecated = \"Renamed to `get`\"]\n-    pub fn find(&self, key: &K) -> Option<&V> {\n-        self.get(key)\n-    }\n-\n-    /// Returns a reference to the value corresponding to the key.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but the ordering\n-    /// on the borrowed form *must* match the ordering on the key type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.get(&1), Some(&\"a\"));\n-    /// assert_eq!(map.get(&2), None);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V>\n-        where Q: BorrowFrom<K> + Ord\n-    {\n-        tree_find_with(&self.root, |k2| key.cmp(BorrowFrom::borrow_from(k2)))\n-    }\n-\n-    /// Returns true if the map contains a value for the specified key.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but the ordering\n-    /// on the borrowed form *must* match the ordering on the key type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.contains_key(&1), true);\n-    /// assert_eq!(map.contains_key(&2), false);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains_key<Sized? Q>(&self, key: &Q) -> bool\n-        where Q: BorrowFrom<K> + Ord\n-    {\n-        self.get(key).is_some()\n-    }\n-\n-    /// Deprecated: Renamed to `get_mut`.\n-    #[deprecated = \"Renamed to `get_mut`\"]\n-    pub fn find_mut(&mut self, key: &K) -> Option<&mut V> {\n-        self.get_mut(key)\n-    }\n-\n-    /// Returns a mutable reference to the value corresponding to the key.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but the ordering\n-    /// on the borrowed form *must* match the ordering on the key type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(1u, \"a\");\n-    /// match map.get_mut(&1) {\n-    ///     Some(x) => *x = \"b\",\n-    ///     None => (),\n-    /// }\n-    /// assert_eq!(map[1], \"b\");\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get_mut<Sized? Q>(&mut self, key: &Q) -> Option<&mut V>\n-        where Q: BorrowFrom<K> + Ord\n-    {\n-        tree_find_with_mut(&mut self.root, |x| key.cmp(BorrowFrom::borrow_from(x)))\n-    }\n-\n-    /// Deprecated: Renamed to `insert`.\n-    #[deprecated = \"Renamed to `insert`\"]\n-    pub fn swap(&mut self, key: K, value: V) -> Option<V> {\n-        self.insert(key, value)\n-    }\n-\n-    /// Inserts a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise, `None` is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// assert_eq!(map.insert(37u, \"a\"), None);\n-    /// assert_eq!(map.is_empty(), false);\n-    ///\n-    /// map.insert(37, \"b\");\n-    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n-    /// assert_eq!(map[37], \"c\");\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n-        let ret = insert(&mut self.root, key, value);\n-        if ret.is_none() { self.length += 1 }\n-        ret\n-    }\n-\n-    /// Deprecated: Renamed to `remove`.\n-    #[deprecated = \"Renamed to `remove`\"]\n-    pub fn pop(&mut self, key: &K) -> Option<V> {\n-        self.remove(key)\n-    }\n-\n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but the ordering\n-    /// on the borrowed form *must* match the ordering on the key type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.remove(&1), Some(\"a\"));\n-    /// assert_eq!(map.remove(&1), None);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove<Sized? Q>(&mut self, key: &Q) -> Option<V>\n-        where Q: BorrowFrom<K> + Ord\n-    {\n-        let ret = remove(&mut self.root, key);\n-        if ret.is_some() { self.length -= 1 }\n-        ret\n-    }\n-}\n-\n-impl<K, V> TreeMap<K, V> {\n-    /// Returns the value for which `f(key)` returns `Equal`. `f` is invoked\n-    /// with current key and guides tree navigation. That means `f` should\n-    /// be aware of natural ordering of the tree.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use collections::tree_map::TreeMap;\n-    ///\n-    /// fn get_headers() -> TreeMap<String, String> {\n-    ///     let mut result = TreeMap::new();\n-    ///     result.insert(\"Content-Type\".to_string(), \"application/xml\".to_string());\n-    ///     result.insert(\"User-Agent\".to_string(), \"Curl-Rust/0.1\".to_string());\n-    ///     result\n-    /// }\n-    ///\n-    /// let headers = get_headers();\n-    /// let ua_key = \"User-Agent\";\n-    /// let ua = headers.find_with(|k| {\n-    ///    ua_key.cmp(k.as_slice())\n-    /// });\n-    ///\n-    /// assert_eq!((*ua.unwrap()).as_slice(), \"Curl-Rust/0.1\");\n-    /// ```\n-    #[inline]\n-    #[experimental = \"likely to be renamed, may be removed\"]\n-    pub fn find_with<F>(&self, f: F) -> Option<&V> where F: FnMut(&K) -> Ordering {\n-        tree_find_with(&self.root, f)\n-    }\n-\n-    /// Returns the value for which `f(key)` returns `Equal`. `f` is invoked\n-    /// with current key and guides tree navigation. That means `f` should\n-    /// be aware of natural ordering of the tree.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut t = collections::tree_map::TreeMap::new();\n-    /// t.insert(\"Content-Type\", \"application/xml\");\n-    /// t.insert(\"User-Agent\", \"Curl-Rust/0.1\");\n-    ///\n-    /// let new_ua = \"Safari/156.0\";\n-    /// match t.find_with_mut(|&k| \"User-Agent\".cmp(k)) {\n-    ///    Some(x) => *x = new_ua,\n-    ///    None => panic!(),\n-    /// }\n-    ///\n-    /// assert_eq!(t.get(&\"User-Agent\"), Some(&new_ua));\n-    /// ```\n-    #[inline]\n-    #[experimental = \"likely to be renamed, may be removed\"]\n-    pub fn find_with_mut<'a, F>(&'a mut self, f: F) -> Option<&'a mut V> where\n-        F: FnMut(&K) -> Ordering\n-    {\n-        tree_find_with_mut(&mut self.root, f)\n-    }\n-}\n-\n-// range iterators.\n-\n-macro_rules! bound_setup {\n-    // initialiser of the iterator to manipulate\n-    ($iter:expr, $k:expr,\n-     // whether we are looking for the lower or upper bound.\n-     $is_lower_bound:expr) => {\n-        {\n-            let mut iter = $iter;\n-            loop {\n-                if !iter.node.is_null() {\n-                    let node_k = unsafe {&(*iter.node).key};\n-                    match $k.cmp(node_k) {\n-                        Less => iter.traverse_left(),\n-                        Greater => iter.traverse_right(),\n-                        Equal => {\n-                            if $is_lower_bound {\n-                                iter.traverse_complete();\n-                                return iter;\n-                            } else {\n-                                iter.traverse_right()\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    iter.traverse_complete();\n-                    return iter;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-\n-impl<K: Ord, V> TreeMap<K, V> {\n-    /// Gets a lazy iterator that should be initialized using\n-    /// `traverse_left`/`traverse_right`/`traverse_complete`.\n-    fn iter_for_traversal<'a>(&'a self) -> Entries<'a, K, V> {\n-        Entries {\n-            stack: vec!(),\n-            node: deref(&self.root),\n-            remaining_min: 0,\n-            remaining_max: self.length\n-        }\n-    }\n-\n-    /// Returns a lazy iterator to the first key-value pair whose key is not less than `k`\n-    /// If all keys in map are less than `k` an empty iterator is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(2i, \"a\");\n-    /// map.insert(4, \"b\");\n-    /// map.insert(6, \"c\");\n-    /// map.insert(8, \"d\");\n-    ///\n-    /// assert_eq!(map.lower_bound(&4).next(), Some((&4, &\"b\")));\n-    /// assert_eq!(map.lower_bound(&5).next(), Some((&6, &\"c\")));\n-    /// assert_eq!(map.lower_bound(&10).next(), None);\n-    /// ```\n-    pub fn lower_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n-        bound_setup!(self.iter_for_traversal(), k, true)\n-    }\n-\n-    /// Returns a lazy iterator to the first key-value pair whose key is greater than `k`\n-    /// If all keys in map are less than or equal to `k` an empty iterator is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(2i, \"a\");\n-    /// map.insert(4, \"b\");\n-    /// map.insert(6, \"c\");\n-    /// map.insert(8, \"d\");\n-    ///\n-    /// assert_eq!(map.upper_bound(&4).next(), Some((&6, &\"c\")));\n-    /// assert_eq!(map.upper_bound(&5).next(), Some((&6, &\"c\")));\n-    /// assert_eq!(map.upper_bound(&10).next(), None);\n-    /// ```\n-    pub fn upper_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n-        bound_setup!(self.iter_for_traversal(), k, false)\n-    }\n-\n-    /// Gets a lazy iterator that should be initialized using\n-    /// `traverse_left`/`traverse_right`/`traverse_complete`.\n-    fn iter_mut_for_traversal<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n-        MutEntries {\n-            stack: vec!(),\n-            node: deref_mut(&mut self.root),\n-            remaining_min: 0,\n-            remaining_max: self.length\n-        }\n-    }\n-\n-    /// Returns a lazy value iterator to the first key-value pair (with\n-    /// the value being mutable) whose key is not less than `k`.\n-    ///\n-    /// If all keys in map are less than `k` an empty iterator is\n-    /// returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(2i, \"a\");\n-    /// map.insert(4, \"b\");\n-    /// map.insert(6, \"c\");\n-    /// map.insert(8, \"d\");\n-    ///\n-    /// assert_eq!(map.lower_bound_mut(&4).next(), Some((&4, &mut \"b\")));\n-    /// assert_eq!(map.lower_bound_mut(&5).next(), Some((&6, &mut \"c\")));\n-    /// assert_eq!(map.lower_bound_mut(&10).next(), None);\n-    ///\n-    /// for (key, value) in map.lower_bound_mut(&4) {\n-    ///     *value = \"changed\";\n-    /// }\n-    ///\n-    /// assert_eq!(map.get(&2), Some(&\"a\"));\n-    /// assert_eq!(map.get(&4), Some(&\"changed\"));\n-    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n-    /// assert_eq!(map.get(&8), Some(&\"changed\"));\n-    /// ```\n-    pub fn lower_bound_mut<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n-        bound_setup!(self.iter_mut_for_traversal(), k, true)\n-    }\n-\n-    /// Returns a lazy iterator to the first key-value pair (with the\n-    /// value being mutable) whose key is greater than `k`.\n-    ///\n-    /// If all keys in map are less than or equal to `k` an empty iterator\n-    /// is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// map.insert(2i, \"a\");\n-    /// map.insert(4, \"b\");\n-    /// map.insert(6, \"c\");\n-    /// map.insert(8, \"d\");\n-    ///\n-    /// assert_eq!(map.upper_bound_mut(&4).next(), Some((&6, &mut \"c\")));\n-    /// assert_eq!(map.upper_bound_mut(&5).next(), Some((&6, &mut \"c\")));\n-    /// assert_eq!(map.upper_bound_mut(&10).next(), None);\n-    ///\n-    /// for (key, value) in map.upper_bound_mut(&4) {\n-    ///     *value = \"changed\";\n-    /// }\n-    ///\n-    /// assert_eq!(map.get(&2), Some(&\"a\"));\n-    /// assert_eq!(map.get(&4), Some(&\"b\"));\n-    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n-    /// assert_eq!(map.get(&8), Some(&\"changed\"));\n-    /// ```\n-    pub fn upper_bound_mut<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n-        bound_setup!(self.iter_mut_for_traversal(), k, false)\n-    }\n-}\n-\n-/// Lazy forward iterator over a map\n-pub struct Entries<'a, K:'a, V:'a> {\n-    stack: Vec<&'a TreeNode<K, V>>,\n-    // See the comment on MutEntries; this is just to allow\n-    // code-sharing (for this immutable-values iterator it *could* very\n-    // well be Option<&'a TreeNode<K,V>>).\n-    node: *const TreeNode<K, V>,\n-    remaining_min: uint,\n-    remaining_max: uint\n-}\n-\n-/// Lazy backward iterator over a map\n-pub struct RevEntries<'a, K:'a, V:'a> {\n-    iter: Entries<'a, K, V>,\n-}\n-\n-/// Lazy forward iterator over a map that allows for the mutation of\n-/// the values.\n-pub struct MutEntries<'a, K:'a, V:'a> {\n-    stack: Vec<&'a mut TreeNode<K, V>>,\n-    // Unfortunately, we require some unsafe-ness to get around the\n-    // fact that we would be storing a reference *into* one of the\n-    // nodes in the stack.\n-    //\n-    // As far as the compiler knows, this would let us invalidate the\n-    // reference by assigning a new value to this node's position in\n-    // its parent, which would cause this current one to be\n-    // deallocated so this reference would be invalid. (i.e. the\n-    // compilers complaints are 100% correct.)\n-    //\n-    // However, as far as you humans reading this code know (or are\n-    // about to know, if you haven't read far enough down yet), we are\n-    // only reading from the TreeNode.{left,right} fields. the only\n-    // thing that is ever mutated is the .value field (although any\n-    // actual mutation that happens is done externally, by the\n-    // iterator consumer). So, don't be so concerned, rustc, we've got\n-    // it under control.\n-    //\n-    // (This field can legitimately be null.)\n-    node: *mut TreeNode<K, V>,\n-    remaining_min: uint,\n-    remaining_max: uint\n-}\n-\n-/// Lazy backward iterator over a map\n-pub struct RevMutEntries<'a, K:'a, V:'a> {\n-    iter: MutEntries<'a, K, V>,\n-}\n-\n-/// TreeMap keys iterator.\n-pub type Keys<'a, K, V> =\n-    iter::Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>;\n-\n-/// TreeMap values iterator.\n-pub type Values<'a, K, V> =\n-    iter::Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>;\n-\n-\n-// FIXME #5846 we want to be able to choose between &x and &mut x\n-// (with many different `x`) below, so we need to optionally pass mut\n-// as a tt, but the only thing we can do with a `tt` is pass them to\n-// other macros, so this takes the `& <mutability> <operand>` token\n-// sequence and forces their evaluation as an expression.\n-macro_rules! addr { ($e:expr) => { $e }}\n-// putting an optional mut into type signatures\n-macro_rules! item { ($i:item) => { $i }}\n-\n-macro_rules! define_iterator {\n-    ($name:ident,\n-     $rev_name:ident,\n-\n-     // the function to go from &m Option<Box<TreeNode>> to *m TreeNode\n-     deref = $deref:ident,\n-\n-     // see comment on `addr!`, this is just an optional `mut`, but\n-     // there's no support for 0-or-1 repeats.\n-     addr_mut = $($addr_mut:tt)*\n-     ) => {\n-        // private methods on the forward iterator (item!() for the\n-        // addr_mut in the next_ return value)\n-        item! { impl<'a, K, V> $name<'a, K, V> {\n-            #[inline(always)]\n-            fn next_(&mut self, forward: bool) -> Option<(&'a K, &'a $($addr_mut)* V)> {\n-                while !self.stack.is_empty() || !self.node.is_null() {\n-                    if !self.node.is_null() {\n-                        let node = unsafe {addr!(& $($addr_mut)* *self.node)};\n-                        {\n-                            let next_node = if forward {\n-                                addr!(& $($addr_mut)* node.left)\n-                            } else {\n-                                addr!(& $($addr_mut)* node.right)\n-                            };\n-                            self.node = $deref(next_node);\n-                        }\n-                        self.stack.push(node);\n-                    } else {\n-                        let node = self.stack.pop().unwrap();\n-                        let next_node = if forward {\n-                            addr!(& $($addr_mut)* node.right)\n-                        } else {\n-                            addr!(& $($addr_mut)* node.left)\n-                        };\n-                        self.node = $deref(next_node);\n-                        self.remaining_max -= 1;\n-                        if self.remaining_min > 0 {\n-                            self.remaining_min -= 1;\n-                        }\n-                        return Some((&node.key, addr!(& $($addr_mut)* node.value)));\n-                    }\n-                }\n-                None\n-            }\n-\n-            /// traverse_left, traverse_right and traverse_complete are\n-            /// used to initialize Entries/MutEntries\n-            /// pointing to element inside tree structure.\n-            ///\n-            /// They should be used in following manner:\n-            ///   - create iterator using TreeMap::[mut_]iter_for_traversal\n-            ///   - find required node using `traverse_left`/`traverse_right`\n-            ///     (current node is `Entries::node` field)\n-            ///   - complete initialization with `traverse_complete`\n-            ///\n-            /// After this, iteration will start from `self.node`.  If\n-            /// `self.node` is None iteration will start from last\n-            /// node from which we traversed left.\n-            #[inline]\n-            fn traverse_left(&mut self) {\n-                let node = unsafe {addr!(& $($addr_mut)* *self.node)};\n-                self.node = $deref(addr!(& $($addr_mut)* node.left));\n-                self.stack.push(node);\n-            }\n-\n-            #[inline]\n-            fn traverse_right(&mut self) {\n-                let node = unsafe {addr!(& $($addr_mut)* *self.node)};\n-                self.node = $deref(addr!(& $($addr_mut)* node.right));\n-            }\n-\n-            #[inline]\n-            fn traverse_complete(&mut self) {\n-                if !self.node.is_null() {\n-                    unsafe {\n-                        self.stack.push(addr!(& $($addr_mut)* *self.node));\n-                    }\n-                    self.node = ptr::RawPtr::null();\n-                }\n-            }\n-        } }\n-\n-        // the forward Iterator impl.\n-        item! { impl<'a, K, V> Iterator<(&'a K, &'a $($addr_mut)* V)> for $name<'a, K, V> {\n-            /// Advances the iterator to the next node (in order) and return a\n-            /// tuple with a reference to the key and value. If there are no\n-            /// more nodes, return `None`.\n-            fn next(&mut self) -> Option<(&'a K, &'a $($addr_mut)* V)> {\n-                self.next_(true)\n-            }\n-\n-            #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n-                (self.remaining_min, Some(self.remaining_max))\n-            }\n-        } }\n-\n-        // the reverse Iterator impl.\n-        item! { impl<'a, K, V> Iterator<(&'a K, &'a $($addr_mut)* V)> for $rev_name<'a, K, V> {\n-            fn next(&mut self) -> Option<(&'a K, &'a $($addr_mut)* V)> {\n-                self.iter.next_(false)\n-            }\n-\n-            #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n-                self.iter.size_hint()\n-            }\n-        } }\n-    }\n-} // end of define_iterator\n-\n-define_iterator! {\n-    Entries,\n-    RevEntries,\n-    deref = deref,\n-\n-    // immutable, so no mut\n-    addr_mut =\n-}\n-define_iterator! {\n-    MutEntries,\n-    RevMutEntries,\n-    deref = deref_mut,\n-\n-    addr_mut = mut\n-}\n-\n-fn deref<'a, K, V>(node: &'a Option<Box<TreeNode<K, V>>>) -> *const TreeNode<K, V> {\n-    match *node {\n-        Some(ref n) => {\n-            let n: &TreeNode<K, V> = &**n;\n-            n as *const TreeNode<K, V>\n-        }\n-        None => ptr::null()\n-    }\n-}\n-\n-fn deref_mut<K, V>(x: &mut Option<Box<TreeNode<K, V>>>)\n-             -> *mut TreeNode<K, V> {\n-    match *x {\n-        Some(ref mut n) => {\n-            let n: &mut TreeNode<K, V> = &mut **n;\n-            n as *mut TreeNode<K, V>\n-        }\n-        None => ptr::null_mut()\n-    }\n-}\n-\n-/// Lazy forward iterator over a map that consumes the map while iterating\n-pub struct MoveEntries<K, V> {\n-    stack: Vec<TreeNode<K, V>>,\n-    remaining: uint\n-}\n-\n-impl<K, V> Iterator<(K, V)> for MoveEntries<K,V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(K, V)> {\n-        while !self.stack.is_empty() {\n-            let TreeNode {\n-                key,\n-                value,\n-                left,\n-                right,\n-                level,\n-            } = self.stack.pop().unwrap();\n-\n-            match left {\n-                Some(box left) => {\n-                    let n = TreeNode {\n-                        key: key,\n-                        value: value,\n-                        left: None,\n-                        right: right,\n-                        level: level\n-                    };\n-                    self.stack.push(n);\n-                    self.stack.push(left);\n-                }\n-                None => {\n-                    match right {\n-                        Some(box right) => self.stack.push(right),\n-                        None => ()\n-                    }\n-                    self.remaining -= 1;\n-                    return Some((key, value))\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.remaining, Some(self.remaining))\n-    }\n-\n-}\n-\n-\n-\n-// Nodes keep track of their level in the tree, starting at 1 in the\n-// leaves and with a red child sharing the level of the parent.\n-#[deriving(Clone)]\n-struct TreeNode<K, V> {\n-    key: K,\n-    value: V,\n-    left: Option<Box<TreeNode<K, V>>>,\n-    right: Option<Box<TreeNode<K, V>>>,\n-    level: uint\n-}\n-\n-impl<K: Ord, V> TreeNode<K, V> {\n-    /// Creates a new tree node.\n-    #[inline]\n-    pub fn new(key: K, value: V) -> TreeNode<K, V> {\n-        TreeNode{key: key, value: value, left: None, right: None, level: 1}\n-    }\n-}\n-\n-// Remove left horizontal link by rotating right\n-fn skew<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n-    if node.left.as_ref().map_or(false, |x| x.level == node.level) {\n-        let mut save = node.left.take().unwrap();\n-        swap(&mut node.left, &mut save.right); // save.right now None\n-        swap(node, &mut save);\n-        node.right = Some(save);\n-    }\n-}\n-\n-// Remove dual horizontal link by rotating left and increasing level of\n-// the parent\n-fn split<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n-    if node.right.as_ref().map_or(false,\n-      |x| x.right.as_ref().map_or(false, |y| y.level == node.level)) {\n-        let mut save = node.right.take().unwrap();\n-        swap(&mut node.right, &mut save.left); // save.left now None\n-        save.level += 1;\n-        swap(node, &mut save);\n-        node.left = Some(save);\n-    }\n-}\n-\n-// Next 2 functions have the same convention: comparator gets\n-// at input current key and returns search_key cmp cur_key\n-// (i.e. search_key.cmp(&cur_key))\n-fn tree_find_with<'r, K, V, F>(\n-    node: &'r Option<Box<TreeNode<K, V>>>,\n-    mut f: F,\n-) -> Option<&'r V> where\n-    F: FnMut(&K) -> Ordering,\n-{\n-    let mut current: &'r Option<Box<TreeNode<K, V>>> = node;\n-    loop {\n-        match *current {\n-            Some(ref r) => {\n-                match f(&r.key) {\n-                    Less => current = &r.left,\n-                    Greater => current = &r.right,\n-                    Equal => return Some(&r.value)\n-                }\n-            }\n-            None => return None\n-        }\n-    }\n-}\n-\n-// See comments above tree_find_with\n-fn tree_find_with_mut<'r, K, V, F>(\n-    node: &'r mut Option<Box<TreeNode<K, V>>>,\n-    mut f: F,\n-) -> Option<&'r mut V> where\n-    F: FnMut(&K) -> Ordering,\n-{\n-\n-    let mut current = node;\n-    loop {\n-        let temp = current; // hack to appease borrowck\n-        match *temp {\n-            Some(ref mut r) => {\n-                match f(&r.key) {\n-                    Less => current = &mut r.left,\n-                    Greater => current = &mut r.right,\n-                    Equal => return Some(&mut r.value)\n-                }\n-            }\n-            None => return None\n-        }\n-    }\n-}\n-\n-fn insert<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n-                          key: K, value: V) -> Option<V> {\n-    match *node {\n-      Some(ref mut save) => {\n-        match key.cmp(&save.key) {\n-          Less => {\n-            let inserted = insert(&mut save.left, key, value);\n-            skew(save);\n-            split(save);\n-            inserted\n-          }\n-          Greater => {\n-            let inserted = insert(&mut save.right, key, value);\n-            skew(save);\n-            split(save);\n-            inserted\n-          }\n-          Equal => {\n-            save.key = key;\n-            Some(replace(&mut save.value, value))\n-          }\n-        }\n-      }\n-      None => {\n-       *node = Some(box TreeNode::new(key, value));\n-        None\n-      }\n-    }\n-}\n-\n-fn remove<K, Sized? Q, V>(node: &mut Option<Box<TreeNode<K, V>>>, key: &Q) -> Option<V>\n-    where K: Ord, Q: BorrowFrom<K> + Ord\n-{\n-    fn heir_swap<K: Ord, V>(node: &mut Box<TreeNode<K, V>>,\n-                            child: &mut Option<Box<TreeNode<K, V>>>) {\n-        // *could* be done without recursion, but it won't borrow check\n-        for x in child.iter_mut() {\n-            if x.right.is_some() {\n-                heir_swap(node, &mut x.right);\n-            } else {\n-                swap(&mut node.key, &mut x.key);\n-                swap(&mut node.value, &mut x.value);\n-            }\n-        }\n-    }\n-\n-    match *node {\n-      None => {\n-        return None; // bottom of tree\n-      }\n-      Some(ref mut save) => {\n-        let (ret, rebalance) = match key.cmp(BorrowFrom::borrow_from(&save.key)) {\n-          Less => (remove(&mut save.left, key), true),\n-          Greater => (remove(&mut save.right, key), true),\n-          Equal => {\n-            if save.left.is_some() {\n-                if save.right.is_some() {\n-                    let mut left = save.left.take().unwrap();\n-                    if left.right.is_some() {\n-                        heir_swap(save, &mut left.right);\n-                    } else {\n-                        swap(&mut save.key, &mut left.key);\n-                        swap(&mut save.value, &mut left.value);\n-                    }\n-                    save.left = Some(left);\n-                    (remove(&mut save.left, key), true)\n-                } else {\n-                    let new = save.left.take().unwrap();\n-                    let box TreeNode{value, ..} = replace(save, new);\n-                    *save = save.left.take().unwrap();\n-                    (Some(value), true)\n-                }\n-            } else if save.right.is_some() {\n-                let new = save.right.take().unwrap();\n-                let box TreeNode{value, ..} = replace(save, new);\n-                (Some(value), true)\n-            } else {\n-                (None, false)\n-            }\n-          }\n-        };\n-\n-        if rebalance {\n-            let left_level = save.left.as_ref().map_or(0, |x| x.level);\n-            let right_level = save.right.as_ref().map_or(0, |x| x.level);\n-\n-            // re-balance, if necessary\n-            if left_level < save.level - 1 || right_level < save.level - 1 {\n-                save.level -= 1;\n-\n-                if right_level > save.level {\n-                    let save_level = save.level;\n-                    for x in save.right.iter_mut() { x.level = save_level }\n-                }\n-\n-                skew(save);\n-\n-                for right in save.right.iter_mut() {\n-                    skew(right);\n-                    for x in right.right.iter_mut() { skew(x) }\n-                }\n-\n-                split(save);\n-                for x in save.right.iter_mut() { split(x) }\n-            }\n-\n-            return ret;\n-        }\n-      }\n-    }\n-    return match node.take() {\n-        Some(box TreeNode{value, ..}) => Some(value), None => panic!()\n-    };\n-}\n-\n-impl<K: Ord, V> FromIterator<(K, V)> for TreeMap<K, V> {\n-    fn from_iter<T: Iterator<(K, V)>>(iter: T) -> TreeMap<K, V> {\n-        let mut map = TreeMap::new();\n-        map.extend(iter);\n-        map\n-    }\n-}\n-\n-impl<K: Ord, V> Extend<(K, V)> for TreeMap<K, V> {\n-    #[inline]\n-    fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) {\n-        for (k, v) in iter {\n-            self.insert(k, v);\n-        }\n-    }\n-}\n-\n-impl<S: Writer, K: Ord + Hash<S>, V: Hash<S>> Hash<S> for TreeMap<K, V> {\n-    fn hash(&self, state: &mut S) {\n-        for elt in self.iter() {\n-            elt.hash(state);\n-        }\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod test_treemap {\n-    use std::prelude::*;\n-    use std::rand::Rng;\n-    use std::rand;\n-\n-    use super::{TreeMap, TreeNode};\n-\n-    #[test]\n-    fn find_empty() {\n-        let m: TreeMap<int,int> = TreeMap::new();\n-        assert!(m.get(&5) == None);\n-    }\n-\n-    #[test]\n-    fn find_not_found() {\n-        let mut m = TreeMap::new();\n-        assert!(m.insert(1i, 2i).is_none());\n-        assert!(m.insert(5i, 3i).is_none());\n-        assert!(m.insert(9i, 3i).is_none());\n-        assert_eq!(m.get(&2), None);\n-    }\n-\n-    #[test]\n-    fn find_with_empty() {\n-        let m: TreeMap<&'static str,int> = TreeMap::new();\n-        assert!(m.find_with(|&k| \"test\".cmp(k)) == None);\n-    }\n-\n-    #[test]\n-    fn find_with_not_found() {\n-        let mut m = TreeMap::new();\n-        assert!(m.insert(\"test1\", 2i).is_none());\n-        assert!(m.insert(\"test2\", 3i).is_none());\n-        assert!(m.insert(\"test3\", 3i).is_none());\n-        assert_eq!(m.find_with(|&k| \"test4\".cmp(k)), None);\n-    }\n-\n-    #[test]\n-    fn find_with_found() {\n-        let mut m = TreeMap::new();\n-        assert!(m.insert(\"test1\", 2i).is_none());\n-        assert!(m.insert(\"test2\", 3i).is_none());\n-        assert!(m.insert(\"test3\", 4i).is_none());\n-        assert_eq!(m.find_with(|&k| \"test2\".cmp(k)), Some(&3i));\n-    }\n-\n-    #[test]\n-    fn test_find_mut() {\n-        let mut m = TreeMap::new();\n-        assert!(m.insert(1i, 12i).is_none());\n-        assert!(m.insert(2, 8).is_none());\n-        assert!(m.insert(5, 14).is_none());\n-        let new = 100;\n-        match m.get_mut(&5) {\n-          None => panic!(), Some(x) => *x = new\n-        }\n-        assert_eq!(m.get(&5), Some(&new));\n-    }\n-\n-    #[test]\n-    fn test_find_with_mut() {\n-        let mut m = TreeMap::new();\n-        assert!(m.insert(\"t1\", 12i).is_none());\n-        assert!(m.insert(\"t2\", 8).is_none());\n-        assert!(m.insert(\"t5\", 14).is_none());\n-        let new = 100;\n-\n-        match m.find_with_mut(|&k| \"t5\".cmp(k)) {\n-          None => panic!(), Some(x) => *x = new\n-        }\n-        assert_eq!(m.find_with(|&k| \"t5\".cmp(k)), Some(&new));\n-    }\n-\n-    #[test]\n-    fn insert_replace() {\n-        let mut m = TreeMap::new();\n-        assert!(m.insert(5i, 2i).is_none());\n-        assert!(m.insert(2, 9).is_none());\n-        assert!(!m.insert(2, 11).is_none());\n-        assert_eq!(m.get(&2).unwrap(), &11);\n-    }\n-\n-    #[test]\n-    fn test_clear() {\n-        let mut m = TreeMap::new();\n-        m.clear();\n-        assert!(m.insert(5i, 11i).is_none());\n-        assert!(m.insert(12, -3).is_none());\n-        assert!(m.insert(19, 2).is_none());\n-        m.clear();\n-        assert!(m.get(&5).is_none());\n-        assert!(m.get(&12).is_none());\n-        assert!(m.get(&19).is_none());\n-        assert!(m.is_empty());\n-    }\n-\n-    #[test]\n-    fn u8_map() {\n-        let mut m = TreeMap::new();\n-\n-        let k1 = \"foo\".as_bytes();\n-        let k2 = \"bar\".as_bytes();\n-        let v1 = \"baz\".as_bytes();\n-        let v2 = \"foobar\".as_bytes();\n-\n-        m.insert(k1.clone(), v1.clone());\n-        m.insert(k2.clone(), v2.clone());\n-\n-        assert_eq!(m.get(&k2), Some(&v2));\n-        assert_eq!(m.get(&k1), Some(&v1));\n-    }\n-\n-    fn check_equal<K: PartialEq + Ord, V: PartialEq>(ctrl: &[(K, V)],\n-                                            map: &TreeMap<K, V>) {\n-        assert_eq!(ctrl.is_empty(), map.is_empty());\n-        for x in ctrl.iter() {\n-            let &(ref k, ref v) = x;\n-            assert!(map.get(k).unwrap() == v)\n-        }\n-        for (map_k, map_v) in map.iter() {\n-            let mut found = false;\n-            for x in ctrl.iter() {\n-                let &(ref ctrl_k, ref ctrl_v) = x;\n-                if *map_k == *ctrl_k {\n-                    assert!(*map_v == *ctrl_v);\n-                    found = true;\n-                    break;\n-                }\n-            }\n-            assert!(found);\n-        }\n-    }\n-\n-    fn check_left<K: Ord, V>(node: &Option<Box<TreeNode<K, V>>>,\n-                                  parent: &Box<TreeNode<K, V>>) {\n-        match *node {\n-          Some(ref r) => {\n-            assert_eq!(r.key.cmp(&parent.key), Less);\n-            assert!(r.level == parent.level - 1); // left is black\n-            check_left(&r.left, r);\n-            check_right(&r.right, r, false);\n-          }\n-          None => assert!(parent.level == 1) // parent is leaf\n-        }\n-    }\n-\n-    fn check_right<K: Ord, V>(node: &Option<Box<TreeNode<K, V>>>,\n-                                   parent: &Box<TreeNode<K, V>>,\n-                                   parent_red: bool) {\n-        match *node {\n-          Some(ref r) => {\n-            assert_eq!(r.key.cmp(&parent.key), Greater);\n-            let red = r.level == parent.level;\n-            if parent_red { assert!(!red) } // no dual horizontal links\n-            // Right red or black\n-            assert!(red || r.level == parent.level - 1);\n-            check_left(&r.left, r);\n-            check_right(&r.right, r, red);\n-          }\n-          None => assert!(parent.level == 1) // parent is leaf\n-        }\n-    }\n-\n-    fn check_structure<K: Ord, V>(map: &TreeMap<K, V>) {\n-        match map.root {\n-          Some(ref r) => {\n-            check_left(&r.left, r);\n-            check_right(&r.right, r, false);\n-          }\n-          None => ()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_rand_int() {\n-        let mut map: TreeMap<int,int> = TreeMap::new();\n-        let mut ctrl = vec![];\n-\n-        check_equal(ctrl.as_slice(), &map);\n-        assert!(map.get(&5).is_none());\n-\n-        let seed: &[_] = &[42];\n-        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n-\n-        for _ in range(0u, 3) {\n-            for _ in range(0u, 90) {\n-                let k = rng.gen();\n-                let v = rng.gen();\n-                if !ctrl.iter().any(|x| x == &(k, v)) {\n-                    assert!(map.insert(k, v).is_none());\n-                    ctrl.push((k, v));\n-                    check_structure(&map);\n-                    check_equal(ctrl.as_slice(), &map);\n-                }\n-            }\n-\n-            for _ in range(0u, 30) {\n-                let r = rng.gen_range(0, ctrl.len());\n-                let (key, _) = ctrl.remove(r).unwrap();\n-                assert!(map.remove(&key).is_some());\n-                check_structure(&map);\n-                check_equal(ctrl.as_slice(), &map);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_len() {\n-        let mut m = TreeMap::new();\n-        assert!(m.insert(3i, 6i).is_none());\n-        assert_eq!(m.len(), 1);\n-        assert!(m.insert(0, 0).is_none());\n-        assert_eq!(m.len(), 2);\n-        assert!(m.insert(4, 8).is_none());\n-        assert_eq!(m.len(), 3);\n-        assert!(m.remove(&3).is_some());\n-        assert_eq!(m.len(), 2);\n-        assert!(!m.remove(&5).is_some());\n-        assert_eq!(m.len(), 2);\n-        assert!(m.insert(2, 4).is_none());\n-        assert_eq!(m.len(), 3);\n-        assert!(m.insert(1, 2).is_none());\n-        assert_eq!(m.len(), 4);\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let mut m = TreeMap::new();\n-\n-        assert!(m.insert(3i, 6i).is_none());\n-        assert!(m.insert(0, 0).is_none());\n-        assert!(m.insert(4, 8).is_none());\n-        assert!(m.insert(2, 4).is_none());\n-        assert!(m.insert(1, 2).is_none());\n-\n-        let mut n = 0;\n-        for (k, v) in m.iter() {\n-            assert_eq!(*k, n);\n-            assert_eq!(*v, n * 2);\n-            n += 1;\n-        }\n-        assert_eq!(n, 5);\n-    }\n-\n-    #[test]\n-    fn test_interval_iteration() {\n-        let mut m = TreeMap::new();\n-        for i in range(1i, 100i) {\n-            assert!(m.insert(i * 2, i * 4).is_none());\n-        }\n-\n-        for i in range(1i, 198i) {\n-            let mut lb_it = m.lower_bound(&i);\n-            let (&k, &v) = lb_it.next().unwrap();\n-            let lb = i + i % 2;\n-            assert_eq!(lb, k);\n-            assert_eq!(lb * 2, v);\n-\n-            let mut ub_it = m.upper_bound(&i);\n-            let (&k, &v) = ub_it.next().unwrap();\n-            let ub = i + 2 - i % 2;\n-            assert_eq!(ub, k);\n-            assert_eq!(ub * 2, v);\n-        }\n-        let mut end_it = m.lower_bound(&199);\n-        assert_eq!(end_it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_rev_iter() {\n-        let mut m = TreeMap::new();\n-\n-        assert!(m.insert(3i, 6i).is_none());\n-        assert!(m.insert(0, 0).is_none());\n-        assert!(m.insert(4, 8).is_none());\n-        assert!(m.insert(2, 4).is_none());\n-        assert!(m.insert(1, 2).is_none());\n-\n-        let mut n = 4;\n-        for (k, v) in m.rev_iter() {\n-            assert_eq!(*k, n);\n-            assert_eq!(*v, n * 2);\n-            n -= 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_mut_iter() {\n-        let mut m = TreeMap::new();\n-        for i in range(0u, 10) {\n-            assert!(m.insert(i, 100 * i).is_none());\n-        }\n-\n-        for (i, (&k, v)) in m.iter_mut().enumerate() {\n-            *v += k * 10 + i; // 000 + 00 + 0, 100 + 10 + 1, ...\n-        }\n-\n-        for (&k, &v) in m.iter() {\n-            assert_eq!(v, 111 * k);\n-        }\n-    }\n-    #[test]\n-    fn test_mut_rev_iter() {\n-        let mut m = TreeMap::new();\n-        for i in range(0u, 10) {\n-            assert!(m.insert(i, 100 * i).is_none());\n-        }\n-\n-        for (i, (&k, v)) in m.rev_iter_mut().enumerate() {\n-            *v += k * 10 + (9 - i); // 900 + 90 + (9 - 0), 800 + 80 + (9 - 1), ...\n-        }\n-\n-        for (&k, &v) in m.iter() {\n-            assert_eq!(v, 111 * k);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_mut_interval_iter() {\n-        let mut m_lower = TreeMap::new();\n-        let mut m_upper = TreeMap::new();\n-        for i in range(1i, 100i) {\n-            assert!(m_lower.insert(i * 2, i * 4).is_none());\n-            assert!(m_upper.insert(i * 2, i * 4).is_none());\n-        }\n-\n-        for i in range(1i, 199) {\n-            let mut lb_it = m_lower.lower_bound_mut(&i);\n-            let (&k, v) = lb_it.next().unwrap();\n-            let lb = i + i % 2;\n-            assert_eq!(lb, k);\n-            *v -= k;\n-        }\n-        for i in range(0i, 198) {\n-            let mut ub_it = m_upper.upper_bound_mut(&i);\n-            let (&k, v) = ub_it.next().unwrap();\n-            let ub = i + 2 - i % 2;\n-            assert_eq!(ub, k);\n-            *v -= k;\n-        }\n-\n-        assert!(m_lower.lower_bound_mut(&199).next().is_none());\n-\n-        assert!(m_upper.upper_bound_mut(&198).next().is_none());\n-\n-        assert!(m_lower.iter().all(|(_, &x)| x == 0));\n-        assert!(m_upper.iter().all(|(_, &x)| x == 0));\n-    }\n-\n-    #[test]\n-    fn test_keys() {\n-        let vec = vec![(1i, 'a'), (2i, 'b'), (3i, 'c')];\n-        let map = vec.into_iter().collect::<TreeMap<int, char>>();\n-        let keys = map.keys().map(|&k| k).collect::<Vec<int>>();\n-        assert_eq!(keys.len(), 3);\n-        assert!(keys.contains(&1));\n-        assert!(keys.contains(&2));\n-        assert!(keys.contains(&3));\n-    }\n-\n-    #[test]\n-    fn test_values() {\n-        let vec = vec![(1i, 'a'), (2i, 'b'), (3i, 'c')];\n-        let map = vec.into_iter().collect::<TreeMap<int, char>>();\n-        let values = map.values().map(|&v| v).collect::<Vec<char>>();\n-        assert_eq!(values.len(), 3);\n-        assert!(values.contains(&'a'));\n-        assert!(values.contains(&'b'));\n-        assert!(values.contains(&'c'));\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        let mut a = TreeMap::new();\n-        let mut b = TreeMap::new();\n-\n-        assert!(a == b);\n-        assert!(a.insert(0i, 5i).is_none());\n-        assert!(a != b);\n-        assert!(b.insert(0, 4).is_none());\n-        assert!(a != b);\n-        assert!(a.insert(5, 19).is_none());\n-        assert!(a != b);\n-        assert!(!b.insert(0, 5).is_none());\n-        assert!(a != b);\n-        assert!(b.insert(5, 19).is_none());\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_lt() {\n-        let mut a = TreeMap::new();\n-        let mut b = TreeMap::new();\n-\n-        assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(0i, 5i).is_none());\n-        assert!(a < b);\n-        assert!(a.insert(0, 7).is_none());\n-        assert!(!(a < b) && b < a);\n-        assert!(b.insert(-2, 0).is_none());\n-        assert!(b < a);\n-        assert!(a.insert(-5, 2).is_none());\n-        assert!(a < b);\n-        assert!(a.insert(6, 2).is_none());\n-        assert!(a < b && !(b < a));\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = TreeMap::new();\n-        let mut b = TreeMap::new();\n-\n-        assert!(a <= b && a >= b);\n-        assert!(a.insert(1i, 1i).is_none());\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        assert!(b.insert(2, 2).is_none());\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut map: TreeMap<int, int> = TreeMap::new();\n-        let empty: TreeMap<int, int> = TreeMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(3, 4);\n-\n-        let map_str = format!(\"{}\", map);\n-\n-        assert!(map_str == \"{1: 2, 3: 4}\");\n-        assert_eq!(format!(\"{}\", empty), \"{}\");\n-    }\n-\n-    #[test]\n-    fn test_lazy_iterator() {\n-        let mut m = TreeMap::new();\n-        let (x1, y1) = (2i, 5i);\n-        let (x2, y2) = (9, 12);\n-        let (x3, y3) = (20, -3);\n-        let (x4, y4) = (29, 5);\n-        let (x5, y5) = (103, 3);\n-\n-        assert!(m.insert(x1, y1).is_none());\n-        assert!(m.insert(x2, y2).is_none());\n-        assert!(m.insert(x3, y3).is_none());\n-        assert!(m.insert(x4, y4).is_none());\n-        assert!(m.insert(x5, y5).is_none());\n-\n-        let m = m;\n-        let mut a = m.iter();\n-\n-        assert_eq!(a.next().unwrap(), (&x1, &y1));\n-        assert_eq!(a.next().unwrap(), (&x2, &y2));\n-        assert_eq!(a.next().unwrap(), (&x3, &y3));\n-        assert_eq!(a.next().unwrap(), (&x4, &y4));\n-        assert_eq!(a.next().unwrap(), (&x5, &y5));\n-\n-        assert!(a.next().is_none());\n-\n-        let mut b = m.iter();\n-\n-        let expected = [(&x1, &y1), (&x2, &y2), (&x3, &y3), (&x4, &y4),\n-                        (&x5, &y5)];\n-        let mut i = 0;\n-\n-        for x in b {\n-            assert_eq!(expected[i], x);\n-            i += 1;\n-\n-            if i == 2 {\n-                break\n-            }\n-        }\n-\n-        for x in b {\n-            assert_eq!(expected[i], x);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = [(1i, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: TreeMap<int, int> = xs.iter().map(|&x| x).collect();\n-\n-        for &(k, v) in xs.iter() {\n-            assert_eq!(map.get(&k), Some(&v));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_index() {\n-        let mut map: TreeMap<int, int> = TreeMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(2, 1);\n-        map.insert(3, 4);\n-\n-        assert_eq!(map[2], 1);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_index_nonexistent() {\n-        let mut map: TreeMap<int, int> = TreeMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(2, 1);\n-        map.insert(3, 4);\n-\n-        map[4];\n-    }\n-\n-    #[test]\n-    fn test_swap() {\n-        let mut m = TreeMap::new();\n-        assert_eq!(m.insert(1u, 2i), None);\n-        assert_eq!(m.insert(1u, 3i), Some(2));\n-        assert_eq!(m.insert(1u, 4i), Some(3));\n-    }\n-\n-    #[test]\n-    fn test_pop() {\n-        let mut m = TreeMap::new();\n-        m.insert(1u, 2i);\n-        assert_eq!(m.remove(&1), Some(2));\n-        assert_eq!(m.remove(&1), None);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    use std::prelude::*;\n-    use std::rand::{weak_rng, Rng};\n-    use test::{Bencher, black_box};\n-\n-    use super::TreeMap;\n-    use bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n-\n-    #[bench]\n-    pub fn insert_rand_100(b: &mut Bencher) {\n-        let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        insert_rand_n(100, &mut m, b,\n-                      |m, i| { m.insert(i, 1); },\n-                      |m, i| { m.remove(&i); });\n-    }\n-\n-    #[bench]\n-    pub fn insert_rand_10_000(b: &mut Bencher) {\n-        let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        insert_rand_n(10_000, &mut m, b,\n-                      |m, i| { m.insert(i, 1); },\n-                      |m, i| { m.remove(&i); });\n-    }\n-\n-    // Insert seq\n-    #[bench]\n-    pub fn insert_seq_100(b: &mut Bencher) {\n-        let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        insert_seq_n(100, &mut m, b,\n-                     |m, i| { m.insert(i, 1); },\n-                     |m, i| { m.remove(&i); });\n-    }\n-\n-    #[bench]\n-    pub fn insert_seq_10_000(b: &mut Bencher) {\n-        let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        insert_seq_n(10_000, &mut m, b,\n-                     |m, i| { m.insert(i, 1); },\n-                     |m, i| { m.remove(&i); });\n-    }\n-\n-    // Find rand\n-    #[bench]\n-    pub fn find_rand_100(b: &mut Bencher) {\n-        let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        find_rand_n(100, &mut m, b,\n-                    |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.get(&i); });\n-    }\n-\n-    #[bench]\n-    pub fn find_rand_10_000(b: &mut Bencher) {\n-        let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        find_rand_n(10_000, &mut m, b,\n-                    |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.get(&i); });\n-    }\n-\n-    // Find seq\n-    #[bench]\n-    pub fn find_seq_100(b: &mut Bencher) {\n-        let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        find_seq_n(100, &mut m, b,\n-                   |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.get(&i); });\n-    }\n-\n-    #[bench]\n-    pub fn find_seq_10_000(b: &mut Bencher) {\n-        let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        find_seq_n(10_000, &mut m, b,\n-                   |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.get(&i); });\n-    }\n-\n-    fn bench_iter(b: &mut Bencher, size: uint) {\n-        let mut map = TreeMap::<uint, uint>::new();\n-        let mut rng = weak_rng();\n-\n-        for _ in range(0, size) {\n-            map.insert(rng.gen(), rng.gen());\n-        }\n-\n-        b.iter(|| {\n-            for entry in map.iter() {\n-                black_box(entry);\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn iter_20(b: &mut Bencher) {\n-        bench_iter(b, 20);\n-    }\n-\n-    #[bench]\n-    pub fn iter_1000(b: &mut Bencher) {\n-        bench_iter(b, 1000);\n-    }\n-\n-    #[bench]\n-    pub fn iter_100000(b: &mut Bencher) {\n-        bench_iter(b, 100000);\n-    }\n-}"}, {"sha": "8c8a2c2f78ee989253c1e35cf51f428d76f23f33", "filename": "src/libcollections/tree/mod.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmod.rs?ref=99d6956c3bdb290b9fd539c5dc15a2b502da5e7a", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Maps are collections of unique keys with corresponding values, and sets are\n-//! just unique keys without a corresponding value.\n-//!\n-//! This crate defines the `TreeMap` and `TreeSet` types. Their keys must implement `Ord`.\n-//!\n-//! `TreeMap`s are ordered.\n-//!\n-//! # Examples\n-//!\n-//! ```{rust}\n-//! use std::collections::TreeSet;\n-//!\n-//! let mut tree_set = TreeSet::new();\n-//!\n-//! tree_set.insert(2i);\n-//! tree_set.insert(1i);\n-//! tree_set.insert(3i);\n-//!\n-//! for i in tree_set.iter() {\n-//!    println!(\"{}\", i) // prints 1, then 2, then 3\n-//! }\n-//! ```\n-\n-pub mod map;\n-pub mod set;"}, {"sha": "c3aebc2736c960d44eb3c96e1f529f11052ce7f3", "filename": "src/libcollections/tree/set.rs", "status": "removed", "additions": 0, "deletions": 1218, "changes": 1218, "blob_url": "https://github.com/rust-lang/rust/blob/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=99d6956c3bdb290b9fd539c5dc15a2b502da5e7a", "patch": "@@ -1,1218 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use core::borrow::BorrowFrom;\n-use core::default::Default;\n-use core::fmt;\n-use core::fmt::Show;\n-use core::iter::Peekable;\n-use core::iter;\n-use std::hash::{Writer, Hash};\n-\n-use tree_map::{TreeMap, Entries, RevEntries, MoveEntries};\n-\n-// FIXME(conventions): implement bounded iterators\n-// FIXME(conventions): replace rev_iter(_mut) by making iter(_mut) DoubleEnded\n-\n-/// An implementation of a set on top of the `TreeMap` container. The only\n-/// requirement is that the type of the elements contained ascribes to the\n-/// `Ord` trait.\n-///\n-/// # Examples\n-///\n-/// ```{rust}\n-/// use std::collections::TreeSet;\n-///\n-/// let mut set = TreeSet::new();\n-///\n-/// set.insert(2i);\n-/// set.insert(1i);\n-/// set.insert(3i);\n-///\n-/// for i in set.iter() {\n-///    println!(\"{}\", i) // prints 1, then 2, then 3\n-/// }\n-///\n-/// set.remove(&3);\n-///\n-/// if !set.contains(&3) {\n-///     println!(\"set does not contain a 3 anymore\");\n-/// }\n-/// ```\n-///\n-/// The easiest way to use `TreeSet` with a custom type is to implement `Ord`.\n-/// We must also implement `PartialEq`, `Eq` and `PartialOrd`.\n-///\n-/// ```\n-/// use std::collections::TreeSet;\n-///\n-/// // We need `Eq` and `PartialEq`, these can be derived.\n-/// #[deriving(Eq, PartialEq)]\n-/// struct Troll<'a> {\n-///     name: &'a str,\n-///     level: uint,\n-/// }\n-///\n-/// // Implement `Ord` and sort trolls by level.\n-/// impl<'a> Ord for Troll<'a> {\n-///     fn cmp(&self, other: &Troll) -> Ordering {\n-///         // If we swap `self` and `other`, we get descending ordering.\n-///         self.level.cmp(&other.level)\n-///     }\n-/// }\n-///\n-/// // `PartialOrd` needs to be implemented as well.\n-/// impl<'a> PartialOrd for Troll<'a> {\n-///     fn partial_cmp(&self, other: &Troll) -> Option<Ordering> {\n-///         Some(self.cmp(other))\n-///     }\n-/// }\n-///\n-/// let mut trolls = TreeSet::new();\n-///\n-/// trolls.insert(Troll { name: \"Orgarr\", level: 2 });\n-/// trolls.insert(Troll { name: \"Blargarr\", level: 3 });\n-/// trolls.insert(Troll { name: \"Kron the Smelly One\", level: 4 });\n-/// trolls.insert(Troll { name: \"Wartilda\", level: 1 });\n-///\n-/// println!(\"You are facing {} trolls!\", trolls.len());\n-///\n-/// // Print the trolls, ordered by level with smallest level first\n-/// for x in trolls.iter() {\n-///     println!(\"level {}: {}!\", x.level, x.name);\n-/// }\n-///\n-/// // Kill all trolls\n-/// trolls.clear();\n-/// assert_eq!(trolls.len(), 0);\n-/// ```\n-#[deriving(Clone)]\n-pub struct TreeSet<T> {\n-    map: TreeMap<T, ()>\n-}\n-\n-impl<T: PartialEq + Ord> PartialEq for TreeSet<T> {\n-    #[inline]\n-    fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n-}\n-\n-impl<T: Eq + Ord> Eq for TreeSet<T> {}\n-\n-impl<T: Ord> PartialOrd for TreeSet<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &TreeSet<T>) -> Option<Ordering> {\n-        self.map.partial_cmp(&other.map)\n-    }\n-}\n-\n-impl<T: Ord> Ord for TreeSet<T> {\n-    #[inline]\n-    fn cmp(&self, other: &TreeSet<T>) -> Ordering {\n-        iter::order::cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-impl<T: Ord + Show> Show for TreeSet<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n-\n-        for (i, x) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", *x));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-#[stable]\n-impl<T: Ord> Default for TreeSet<T> {\n-    #[inline]\n-    #[stable]\n-    fn default() -> TreeSet<T> { TreeSet::new() }\n-}\n-\n-impl<T: Ord> TreeSet<T> {\n-    /// Creates an empty `TreeSet`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let mut set: TreeSet<int> = TreeSet::new();\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n-\n-    /// Gets a lazy iterator over the values in the set, in ascending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n-    ///\n-    /// // Will print in ascending order.\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n-        SetItems{iter: self.map.iter()}\n-    }\n-\n-    /// Gets a lazy iterator over the values in the set, in descending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n-    ///\n-    /// // Will print in descending order.\n-    /// for x in set.rev_iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn rev_iter<'a>(&'a self) -> RevSetItems<'a, T> {\n-        RevSetItems{iter: self.map.rev_iter()}\n-    }\n-\n-    /// Creates a consuming iterator, that is, one that moves each value out of the\n-    /// set in ascending order. The set cannot be used after calling this.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n-    ///\n-    /// // Not possible with a regular `.iter()`\n-    /// let v: Vec<int> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveSetItems<T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-\n-        self.map.into_iter().map(first)\n-    }\n-\n-    /// Gets a lazy iterator pointing to the first value not less than `v` (greater or equal).\n-    /// If all elements in the set are less than `v` empty iterator is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(set.lower_bound(&4).next(), Some(&4));\n-    /// assert_eq!(set.lower_bound(&5).next(), Some(&6));\n-    /// assert_eq!(set.lower_bound(&10).next(), None);\n-    /// ```\n-    #[inline]\n-    pub fn lower_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n-        SetItems{iter: self.map.lower_bound(v)}\n-    }\n-\n-    /// Gets a lazy iterator pointing to the first value greater than `v`.\n-    /// If all elements in the set are less than or equal to `v` an\n-    /// empty iterator is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(set.upper_bound(&4).next(), Some(&6));\n-    /// assert_eq!(set.upper_bound(&5).next(), Some(&6));\n-    /// assert_eq!(set.upper_bound(&10).next(), None);\n-    /// ```\n-    #[inline]\n-    pub fn upper_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n-        SetItems{iter: self.map.upper_bound(v)}\n-    }\n-\n-    /// Visits the values representing the difference, in ascending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Can be seen as `a - b`.\n-    /// for x in a.difference(&b) {\n-    ///     println!(\"{}\", x); // Print 1 then 2\n-    /// }\n-    ///\n-    /// let diff: TreeSet<int> = a.difference(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1, 2].iter().map(|&x| x).collect());\n-    ///\n-    /// // Note that difference is not symmetric,\n-    /// // and `b - a` means something else:\n-    /// let diff: TreeSet<int> = b.difference(&a).map(|&x| x).collect();\n-    /// assert_eq!(diff, [4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> {\n-        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the symmetric difference, in ascending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 2, 4, 5 in ascending order.\n-    /// for x in a.symmetric_difference(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff1: TreeSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n-    /// let diff2: TreeSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(diff1, diff2);\n-    /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n-        -> SymDifferenceItems<'a, T> {\n-        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the intersection, in ascending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 2, 3 in ascending order.\n-    /// for x in a.intersection(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: TreeSet<int> = a.intersection(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n-        -> IntersectionItems<'a, T> {\n-        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the union, in ascending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 2, 3, 4, 5 in ascending order.\n-    /// for x in a.union(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: TreeSet<int> = a.union(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {\n-        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Return the number of elements in the set\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let mut v = TreeSet::new();\n-    /// assert_eq!(v.len(), 0);\n-    /// v.insert(1i);\n-    /// assert_eq!(v.len(), 1);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn len(&self) -> uint { self.map.len() }\n-\n-    /// Returns true if the set contains no elements\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let mut v = TreeSet::new();\n-    /// assert!(v.is_empty());\n-    /// v.insert(1i);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clears the set, removing all values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let mut v = TreeSet::new();\n-    /// v.insert(1i);\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn clear(&mut self) { self.map.clear() }\n-\n-    /// Returns `true` if the set contains a value.\n-    ///\n-    /// The value may be any borrowed form of the set's value type,\n-    /// but the ordering on the borrowed form *must* match the\n-    /// ordering on the value type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let set: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.contains(&1), true);\n-    /// assert_eq!(set.contains(&4), false);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains<Sized? Q>(&self, value: &Q) -> bool\n-        where Q: Ord + BorrowFrom<T>\n-    {\n-        self.map.contains_key(value)\n-    }\n-\n-    /// Returns `true` if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut b: TreeSet<int> = TreeSet::new();\n-    ///\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(4);\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(1);\n-    /// assert_eq!(a.is_disjoint(&b), false);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n-        self.intersection(other).next().is_none()\n-    }\n-\n-    /// Returns `true` if the set is a subset of another.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let sup: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut set: TreeSet<int> = TreeSet::new();\n-    ///\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(4);\n-    /// assert_eq!(set.is_subset(&sup), false);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_subset(&self, other: &TreeSet<T>) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-        let mut a = x.next();\n-        let mut b = y.next();\n-        while a.is_some() {\n-            if b.is_none() {\n-                return false;\n-            }\n-\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            match b1.cmp(a1) {\n-                Less => (),\n-                Greater => return false,\n-                Equal => a = x.next(),\n-            }\n-\n-            b = y.next();\n-        }\n-        true\n-    }\n-\n-    /// Returns `true` if the set is a superset of another.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let sub: TreeSet<int> = [1i, 2].iter().map(|&x| x).collect();\n-    /// let mut set: TreeSet<int> = TreeSet::new();\n-    ///\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(0);\n-    /// set.insert(1);\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_superset(&sub), true);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_superset(&self, other: &TreeSet<T>) -> bool {\n-        other.is_subset(self)\n-    }\n-\n-    /// Adds a value to the set. Returns `true` if the value was not already\n-    /// present in the set.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let mut set = TreeSet::new();\n-    ///\n-    /// assert_eq!(set.insert(2i), true);\n-    /// assert_eq!(set.insert(2i), false);\n-    /// assert_eq!(set.len(), 1);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n-\n-    /// Removes a value from the set. Returns `true` if the value was\n-    /// present in the set.\n-    ///\n-    /// The value may be any borrowed form of the set's value type,\n-    /// but the ordering on the borrowed form *must* match the\n-    /// ordering on the value type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let mut set = TreeSet::new();\n-    ///\n-    /// set.insert(2i);\n-    /// assert_eq!(set.remove(&2), true);\n-    /// assert_eq!(set.remove(&2), false);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool\n-        where Q: Ord + BorrowFrom<T>\n-    {\n-        self.map.remove(value).is_some()\n-    }\n-}\n-\n-/// A lazy forward iterator over a set.\n-pub struct SetItems<'a, T:'a> {\n-    iter: Entries<'a, T, ()>\n-}\n-\n-/// A lazy backward iterator over a set.\n-pub struct RevSetItems<'a, T:'a> {\n-    iter: RevEntries<'a, T, ()>\n-}\n-\n-/// A lazy forward iterator over a set that consumes the set while iterating.\n-pub type MoveSetItems<T> = iter::Map<(T, ()), T, MoveEntries<T, ()>, fn((T, ())) -> T>;\n-\n-/// A lazy iterator producing elements in the set difference (in-order).\n-pub struct DifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// A lazy iterator producing elements in the set symmetric difference (in-order).\n-pub struct SymDifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// A lazy iterator producing elements in the set intersection (in-order).\n-pub struct IntersectionItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// A lazy iterator producing elements in the set union (in-order).\n-pub struct UnionItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n-                        short: Ordering, long: Ordering) -> Ordering {\n-    match (x, y) {\n-        (None    , _       ) => short,\n-        (_       , None    ) => long,\n-        (Some(x1), Some(y1)) => x1.cmp(y1),\n-    }\n-}\n-\n-\n-impl<'a, T> Iterator<&'a T> for SetItems<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a T> {\n-        self.iter.next().map(|(value, _)| value)\n-    }\n-}\n-\n-impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a T> {\n-        self.iter.next().map(|(value, _)| value)\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.a.next(); self.b.next(); }\n-                Greater => { self.b.next(); }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.a.next(); self.b.next(); }\n-                Greater => return self.b.next(),\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            let o_cmp = match (self.a.peek(), self.b.peek()) {\n-                (None    , _       ) => None,\n-                (_       , None    ) => None,\n-                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n-            };\n-            match o_cmp {\n-                None          => return None,\n-                Some(Less)    => { self.a.next(); }\n-                Some(Equal)   => { self.b.next(); return self.a.next() }\n-                Some(Greater) => { self.b.next(); }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.b.next(); return self.a.next() }\n-                Greater => return self.b.next(),\n-            }\n-        }\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitOr<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n-    /// Returns the union of `self` and `rhs` as a new `TreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TreeSet<int> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TreeSet<int> = a | b;\n-    /// let v: Vec<int> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n-    /// ```\n-    fn bitor(&self, rhs: &TreeSet<T>) -> TreeSet<T> {\n-        self.union(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-impl<'a, 'b, T: Ord + Clone> BitOr<&'b TreeSet<T>, TreeSet<T>> for &'a TreeSet<T> {\n-    /// Returns the union of `self` and `rhs` as a new `TreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TreeSet<int> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TreeSet<int> = &a | &b;\n-    /// let v: Vec<int> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n-    /// ```\n-    fn bitor(self, rhs: &TreeSet<T>) -> TreeSet<T> {\n-        self.union(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitAnd<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n-    /// Returns the intersection of `self` and `rhs` as a new `TreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TreeSet<int> = vec![2, 3, 4].into_iter().collect();\n-    ///\n-    /// let set: TreeSet<int> = a & b;\n-    /// let v: Vec<int> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![2, 3]);\n-    /// ```\n-    fn bitand(&self, rhs: &TreeSet<T>) -> TreeSet<T> {\n-        self.intersection(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-impl<'a, 'b, T: Ord + Clone> BitAnd<&'b TreeSet<T>, TreeSet<T>> for &'a TreeSet<T> {\n-    /// Returns the intersection of `self` and `rhs` as a new `TreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TreeSet<int> = vec![2, 3, 4].into_iter().collect();\n-    ///\n-    /// let set: TreeSet<int> = &a & &b;\n-    /// let v: Vec<int> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![2, 3]);\n-    /// ```\n-    fn bitand(self, rhs: &TreeSet<T>) -> TreeSet<T> {\n-        self.intersection(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitXor<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n-    /// Returns the symmetric difference of `self` and `rhs` as a new `TreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TreeSet<int> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TreeSet<int> = a ^ b;\n-    /// let v: Vec<int> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1, 2, 4, 5]);\n-    /// ```\n-    fn bitxor(&self, rhs: &TreeSet<T>) -> TreeSet<T> {\n-        self.symmetric_difference(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-impl<'a, 'b, T: Ord + Clone> BitXor<&'b TreeSet<T>, TreeSet<T>> for &'a TreeSet<T> {\n-    /// Returns the symmetric difference of `self` and `rhs` as a new `TreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TreeSet<int> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TreeSet<int> = &a ^ &b;\n-    /// let v: Vec<int> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1, 2, 4, 5]);\n-    /// ```\n-    fn bitxor(self, rhs: &TreeSet<T>) -> TreeSet<T> {\n-        self.symmetric_difference(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> Sub<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n-    /// Returns the difference of `self` and `rhs` as a new `TreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TreeSet<int> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TreeSet<int> = a - b;\n-    /// let v: Vec<int> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1, 2]);\n-    /// ```\n-    fn sub(&self, rhs: &TreeSet<T>) -> TreeSet<T> {\n-        self.difference(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-impl<'a, 'b, T: Ord + Clone> Sub<&'b TreeSet<T>, TreeSet<T>> for &'a TreeSet<T> {\n-    /// Returns the difference of `self` and `rhs` as a new `TreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TreeSet<int> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TreeSet<int> = &a - &b;\n-    /// let v: Vec<int> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1, 2]);\n-    /// ```\n-    fn sub(self, rhs: &TreeSet<T>) -> TreeSet<T> {\n-        self.difference(rhs).cloned().collect()\n-    }\n-}\n-\n-impl<T: Ord> FromIterator<T> for TreeSet<T> {\n-    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> TreeSet<T> {\n-        let mut set = TreeSet::new();\n-        set.extend(iter);\n-        set\n-    }\n-}\n-\n-impl<T: Ord> Extend<T> for TreeSet<T> {\n-    #[inline]\n-    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n-        for elem in iter {\n-            self.insert(elem);\n-        }\n-    }\n-}\n-\n-impl<S: Writer, T: Ord + Hash<S>> Hash<S> for TreeSet<T> {\n-    fn hash(&self, state: &mut S) {\n-        for elt in self.iter() {\n-            elt.hash(state);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use std::prelude::*;\n-    use std::hash;\n-    use vec::Vec;\n-\n-    use super::TreeSet;\n-\n-    #[test]\n-    fn test_clear() {\n-        let mut s = TreeSet::new();\n-        s.clear();\n-        assert!(s.insert(5i));\n-        assert!(s.insert(12));\n-        assert!(s.insert(19));\n-        s.clear();\n-        assert!(!s.contains(&5));\n-        assert!(!s.contains(&12));\n-        assert!(!s.contains(&19));\n-        assert!(s.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_disjoint() {\n-        let mut xs = TreeSet::new();\n-        let mut ys = TreeSet::new();\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(5i));\n-        assert!(ys.insert(11i));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(7));\n-        assert!(xs.insert(19));\n-        assert!(xs.insert(4));\n-        assert!(ys.insert(2));\n-        assert!(ys.insert(-11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(ys.insert(7));\n-        assert!(!xs.is_disjoint(&ys));\n-        assert!(!ys.is_disjoint(&xs));\n-    }\n-\n-    #[test]\n-    fn test_subset_and_superset() {\n-        let mut a = TreeSet::new();\n-        assert!(a.insert(0i));\n-        assert!(a.insert(5));\n-        assert!(a.insert(11));\n-        assert!(a.insert(7));\n-\n-        let mut b = TreeSet::new();\n-        assert!(b.insert(0i));\n-        assert!(b.insert(7));\n-        assert!(b.insert(19));\n-        assert!(b.insert(250));\n-        assert!(b.insert(11));\n-        assert!(b.insert(200));\n-\n-        assert!(!a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(!b.is_superset(&a));\n-\n-        assert!(b.insert(5));\n-\n-        assert!(a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(b.is_superset(&a));\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let mut m = TreeSet::new();\n-\n-        assert!(m.insert(3i));\n-        assert!(m.insert(0));\n-        assert!(m.insert(4));\n-        assert!(m.insert(2));\n-        assert!(m.insert(1));\n-\n-        let mut n = 0;\n-        for x in m.iter() {\n-            assert_eq!(*x, n);\n-            n += 1\n-        }\n-    }\n-\n-    #[test]\n-    fn test_rev_iter() {\n-        let mut m = TreeSet::new();\n-\n-        assert!(m.insert(3i));\n-        assert!(m.insert(0));\n-        assert!(m.insert(4));\n-        assert!(m.insert(2));\n-        assert!(m.insert(1));\n-\n-        let mut n = 4;\n-        for x in m.rev_iter() {\n-            assert_eq!(*x, n);\n-            n -= 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_move_iter() {\n-        let s: TreeSet<int> = range(0i, 5).collect();\n-\n-        let mut n = 0;\n-        for x in s.into_iter() {\n-            assert_eq!(x, n);\n-            n += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_move_iter_size_hint() {\n-        let s: TreeSet<int> = vec!(0i, 1).into_iter().collect();\n-\n-        let mut it = s.into_iter();\n-\n-        assert_eq!(it.size_hint(), (2, Some(2)));\n-        assert!(it.next() != None);\n-\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert!(it.next() != None);\n-\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_clone_eq() {\n-      let mut m = TreeSet::new();\n-\n-      m.insert(1i);\n-      m.insert(2);\n-\n-      assert!(m.clone() == m);\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-      let mut x = TreeSet::new();\n-      let mut y = TreeSet::new();\n-\n-      x.insert(1i);\n-      x.insert(2);\n-      x.insert(3);\n-\n-      y.insert(3i);\n-      y.insert(2);\n-      y.insert(1);\n-\n-      assert!(hash::hash(&x) == hash::hash(&y));\n-    }\n-\n-    struct Counter<'a, 'b> {\n-        i: &'a mut uint,\n-        expected: &'b [int],\n-    }\n-\n-    impl<'a, 'b> FnMut(&int) -> bool for Counter<'a, 'b> {\n-        extern \"rust-call\" fn call_mut(&mut self, (&x,): (&int,)) -> bool {\n-            assert_eq!(x, self.expected[*self.i]);\n-            *self.i += 1;\n-            true\n-        }\n-    }\n-\n-    fn check<F>(a: &[int], b: &[int], expected: &[int], f: F) where\n-        // FIXME Replace `Counter` with `Box<FnMut(&int) -> bool>`\n-        F: FnOnce(&TreeSet<int>, &TreeSet<int>, Counter) -> bool,\n-    {\n-        let mut set_a = TreeSet::new();\n-        let mut set_b = TreeSet::new();\n-\n-        for x in a.iter() { assert!(set_a.insert(*x)) }\n-        for y in b.iter() { assert!(set_b.insert(*y)) }\n-\n-        let mut i = 0;\n-        f(&set_a, &set_b, Counter { i: &mut i, expected: expected });\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_intersection() {\n-        fn check_intersection(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n-        }\n-\n-        check_intersection(&[], &[], &[]);\n-        check_intersection(&[1, 2, 3], &[], &[]);\n-        check_intersection(&[], &[1, 2, 3], &[]);\n-        check_intersection(&[2], &[1, 2, 3], &[2]);\n-        check_intersection(&[1, 2, 3], &[2], &[2]);\n-        check_intersection(&[11, 1, 3, 77, 103, 5, -5],\n-                           &[2, 11, 77, -9, -42, 5, 3],\n-                           &[3, 5, 11, 77]);\n-    }\n-\n-    #[test]\n-    fn test_difference() {\n-        fn check_difference(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.difference(y).all(f))\n-        }\n-\n-        check_difference(&[], &[], &[]);\n-        check_difference(&[1, 12], &[], &[1, 12]);\n-        check_difference(&[], &[1, 2, 3, 9], &[]);\n-        check_difference(&[1, 3, 5, 9, 11],\n-                         &[3, 9],\n-                         &[1, 5, 11]);\n-        check_difference(&[-5, 11, 22, 33, 40, 42],\n-                         &[-12, -5, 14, 23, 34, 38, 39, 50],\n-                         &[11, 22, 33, 40, 42]);\n-    }\n-\n-    #[test]\n-    fn test_symmetric_difference() {\n-        fn check_symmetric_difference(a: &[int], b: &[int],\n-                                      expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n-        }\n-\n-        check_symmetric_difference(&[], &[], &[]);\n-        check_symmetric_difference(&[1, 2, 3], &[2], &[1, 3]);\n-        check_symmetric_difference(&[2], &[1, 2, 3], &[1, 3]);\n-        check_symmetric_difference(&[1, 3, 5, 9, 11],\n-                                   &[-2, 3, 9, 14, 22],\n-                                   &[-2, 1, 5, 11, 14, 22]);\n-    }\n-\n-    #[test]\n-    fn test_union() {\n-        fn check_union(a: &[int], b: &[int],\n-                                      expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.union(y).all(f))\n-        }\n-\n-        check_union(&[], &[], &[]);\n-        check_union(&[1, 2, 3], &[2], &[1, 2, 3]);\n-        check_union(&[2], &[1, 2, 3], &[1, 2, 3]);\n-        check_union(&[1, 3, 5, 9, 11, 16, 19, 24],\n-                    &[-2, 1, 5, 9, 13, 19],\n-                    &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n-    }\n-\n-    #[test]\n-    fn test_bit_or() {\n-        let a: TreeSet<int> = vec![1, 3, 5, 9, 11, 16, 19, 24].into_iter().collect();\n-        let b: TreeSet<int> = vec![-2, 1, 5, 9, 13, 19].into_iter().collect();\n-\n-        let set: TreeSet<int> = &a | &b;\n-        let v: Vec<int> = set.into_iter().collect();\n-        assert_eq!(v, vec![-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n-    }\n-\n-    #[test]\n-    fn test_bit_and() {\n-        let a: TreeSet<int> = vec![11, 1, 3, 77, 103, 5, -5].into_iter().collect();\n-        let b: TreeSet<int> = vec![2, 11, 77, -9, -42, 5, 3].into_iter().collect();\n-\n-        let set: TreeSet<int> = &a & &b;\n-        let v: Vec<int> = set.into_iter().collect();\n-        assert_eq!(v, vec![3, 5, 11, 77]);\n-    }\n-\n-    #[test]\n-    fn test_bit_xor() {\n-        let a: TreeSet<int> = vec![1, 3, 5, 9, 11].into_iter().collect();\n-        let b: TreeSet<int> = vec![-2, 3, 9, 14, 22].into_iter().collect();\n-\n-        let set: TreeSet<int> = &a ^ &b;\n-        let v: Vec<int> = set.into_iter().collect();\n-        assert_eq!(v, vec![-2, 1, 5, 11, 14, 22]);\n-    }\n-\n-    #[test]\n-    fn test_sub() {\n-        let a: TreeSet<int> = vec![-5, 11, 22, 33, 40, 42].into_iter().collect();\n-        let b: TreeSet<int> = vec![-12, -5, 14, 23, 34, 38, 39, 50].into_iter().collect();\n-\n-        let set: TreeSet<int> = &a - &b;\n-        let v: Vec<int> = set.into_iter().collect();\n-        assert_eq!(v, vec![11, 22, 33, 40, 42]);\n-    }\n-\n-    #[test]\n-    fn test_zip() {\n-        let mut x = TreeSet::new();\n-        x.insert(5u);\n-        x.insert(12u);\n-        x.insert(11u);\n-\n-        let mut y = TreeSet::new();\n-        y.insert(\"foo\");\n-        y.insert(\"bar\");\n-\n-        let x = x;\n-        let y = y;\n-        let mut z = x.iter().zip(y.iter());\n-\n-        // FIXME: #5801: this needs a type hint to compile...\n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&5u, &(\"bar\")));\n-\n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&11u, &(\"foo\")));\n-\n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert!(result.is_none());\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = [1i, 2, 3, 4, 5, 6, 7, 8, 9];\n-\n-        let set: TreeSet<int> = xs.iter().map(|&x| x).collect();\n-\n-        for x in xs.iter() {\n-            assert!(set.contains(x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut set: TreeSet<int> = TreeSet::new();\n-        let empty: TreeSet<int> = TreeSet::new();\n-\n-        set.insert(1);\n-        set.insert(2);\n-\n-        let set_str = format!(\"{}\", set);\n-\n-        assert!(set_str == \"{1, 2}\");\n-        assert_eq!(format!(\"{}\", empty), \"{}\");\n-    }\n-}"}, {"sha": "9a9ac6a3c582996560e4efc028c7b2a7c0211d80", "filename": "src/libcollections/trie/map.rs", "status": "removed", "additions": 0, "deletions": 1958, "changes": 1958, "blob_url": "https://github.com/rust-lang/rust/blob/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=99d6956c3bdb290b9fd539c5dc15a2b502da5e7a", "patch": "@@ -1,1958 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Ordered maps and sets, implemented as simple tries.\n-use core::prelude::*;\n-\n-pub use self::Entry::*;\n-use self::TrieNode::*;\n-use alloc::boxed::Box;\n-use core::default::Default;\n-use core::fmt;\n-use core::fmt::Show;\n-use core::mem::zeroed;\n-use core::mem;\n-use core::ops::{Slice, SliceMut};\n-use core::uint;\n-use core::iter;\n-use core::ptr;\n-use std::hash::{Writer, Hash};\n-\n-use slice::{Items, MutItems};\n-use slice;\n-\n-// FIXME(conventions): implement bounded iterators\n-// FIXME(conventions): implement into_iter\n-// FIXME(conventions): replace each_reverse by making iter DoubleEnded\n-\n-// FIXME: #5244: need to manually update the InternalNode constructor\n-const SHIFT: uint = 4;\n-const SIZE: uint = 1 << SHIFT;\n-const MASK: uint = SIZE - 1;\n-// The number of chunks that the key is divided into. Also the maximum depth of the TrieMap.\n-const MAX_DEPTH: uint = uint::BITS / SHIFT;\n-\n-/// A map implemented as a radix trie.\n-///\n-/// Keys are split into sequences of 4 bits, which are used to place elements in\n-/// 16-entry arrays which are nested to form a tree structure. Inserted elements are placed\n-/// as close to the top of the tree as possible. The most significant bits of the key are used to\n-/// assign the key to a node/bucket in the first layer. If there are no other elements keyed by\n-/// the same 4 bits in the first layer, a leaf node will be created in the first layer.\n-/// When keys coincide, the next 4 bits are used to assign the node to a bucket in the next layer,\n-/// with this process continuing until an empty spot is found or there are no more bits left in the\n-/// key. As a result, the maximum depth using 32-bit `uint` keys is 8. The worst collisions occur\n-/// for very small numbers. For example, 1 and 2 are identical in all but their least significant\n-/// 4 bits. If both numbers are used as keys, a chain of maximum length will be created to\n-/// differentiate them.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::collections::TrieMap;\n-///\n-/// let mut map = TrieMap::new();\n-/// map.insert(27, \"Olaf\");\n-/// map.insert(1, \"Edgar\");\n-/// map.insert(13, \"Ruth\");\n-/// map.insert(1, \"Martin\");\n-///\n-/// assert_eq!(map.len(), 3);\n-/// assert_eq!(map.get(&1), Some(&\"Martin\"));\n-///\n-/// if !map.contains_key(&90) {\n-///     println!(\"Nobody is keyed 90\");\n-/// }\n-///\n-/// // Update a key\n-/// match map.get_mut(&1) {\n-///     Some(value) => *value = \"Olga\",\n-///     None => (),\n-/// }\n-///\n-/// map.remove(&13);\n-/// assert_eq!(map.len(), 2);\n-///\n-/// // Print the key value pairs, ordered by key.\n-/// for (key, value) in map.iter() {\n-///     // Prints `1: Olga` then `27: Olaf`\n-///     println!(\"{}: {}\", key, value);\n-/// }\n-///\n-/// map.clear();\n-/// assert!(map.is_empty());\n-/// ```\n-#[deriving(Clone)]\n-pub struct TrieMap<T> {\n-    root: InternalNode<T>,\n-    length: uint\n-}\n-\n-// An internal node holds SIZE child nodes, which may themselves contain more internal nodes.\n-//\n-// Throughout this implementation, \"idx\" is used to refer to a section of key that is used\n-// to access a node. The layer of the tree directly below the root corresponds to idx 0.\n-struct InternalNode<T> {\n-    // The number of direct children which are external (i.e. that store a value).\n-    count: uint,\n-    children: [TrieNode<T>, ..SIZE]\n-}\n-\n-// Each child of an InternalNode may be internal, in which case nesting continues,\n-// external (containing a value), or empty\n-#[deriving(Clone)]\n-enum TrieNode<T> {\n-    Internal(Box<InternalNode<T>>),\n-    External(uint, T),\n-    Nothing\n-}\n-\n-impl<T: PartialEq> PartialEq for TrieMap<T> {\n-    fn eq(&self, other: &TrieMap<T>) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().zip(other.iter()).all(|(a, b)| a == b)\n-    }\n-}\n-\n-impl<T: Eq> Eq for TrieMap<T> {}\n-\n-impl<T: PartialOrd> PartialOrd for TrieMap<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &TrieMap<T>) -> Option<Ordering> {\n-        iter::order::partial_cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-impl<T: Ord> Ord for TrieMap<T> {\n-    #[inline]\n-    fn cmp(&self, other: &TrieMap<T>) -> Ordering {\n-        iter::order::cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-impl<T: Show> Show for TrieMap<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n-\n-        for (i, (k, v)) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}: {}\", k, *v));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-#[stable]\n-impl<T> Default for TrieMap<T> {\n-    #[inline]\n-    #[stable]\n-    fn default() -> TrieMap<T> { TrieMap::new() }\n-}\n-\n-impl<T> TrieMap<T> {\n-    /// Creates an empty `TrieMap`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    /// let mut map: TrieMap<&str> = TrieMap::new();\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn new() -> TrieMap<T> {\n-        TrieMap{root: InternalNode::new(), length: 0}\n-    }\n-\n-    /// Visits all key-value pairs in reverse order. Aborts traversal when `f` returns `false`.\n-    /// Returns `true` if `f` returns `true` for all elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    /// let map: TrieMap<&str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].iter().map(|&x| x).collect();\n-    ///\n-    /// let mut vec = Vec::new();\n-    /// assert_eq!(true, map.each_reverse(|&key, &value| { vec.push((key, value)); true }));\n-    /// assert_eq!(vec, vec![(3, \"c\"), (2, \"b\"), (1, \"a\")]);\n-    ///\n-    /// // Stop when we reach 2\n-    /// let mut vec = Vec::new();\n-    /// assert_eq!(false, map.each_reverse(|&key, &value| { vec.push(value); key != 2 }));\n-    /// assert_eq!(vec, vec![\"c\", \"b\"]);\n-    /// ```\n-    #[inline]\n-    pub fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n-        self.root.each_reverse(f)\n-    }\n-\n-    /// Gets an iterator visiting all keys in ascending order by the keys.\n-    /// The iterator's element type is `uint`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn keys<'r>(&'r self) -> Keys<'r, T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-\n-        self.iter().map(first)\n-    }\n-\n-    /// Gets an iterator visiting all values in ascending order by the keys.\n-    /// The iterator's element type is `&'r T`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn values<'r>(&'r self) -> Values<'r, T> {\n-        fn second<A, B>((_, b): (A, B)) -> B { b }\n-\n-        self.iter().map(second)\n-    }\n-\n-    /// Gets an iterator over the key-value pairs in the map, ordered by keys.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    /// let map: TrieMap<&str> = [(3, \"c\"), (1, \"a\"), (2, \"b\")].iter().map(|&x| x).collect();\n-    ///\n-    /// for (key, value) in map.iter() {\n-    ///     println!(\"{}: {}\", key, value);\n-    /// }\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Entries<'a, T> {\n-        let mut iter = unsafe {Entries::new()};\n-        iter.stack[0] = self.root.children.iter();\n-        iter.length = 1;\n-        iter.remaining_min = self.length;\n-        iter.remaining_max = self.length;\n-\n-        iter\n-    }\n-\n-    /// Gets an iterator over the key-value pairs in the map, with the\n-    /// ability to mutate the values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    /// let mut map: TrieMap<int> = [(1, 2), (2, 4), (3, 6)].iter().map(|&x| x).collect();\n-    ///\n-    /// for (key, value) in map.iter_mut() {\n-    ///     *value = -(key as int);\n-    /// }\n-    ///\n-    /// assert_eq!(map.get(&1), Some(&-1));\n-    /// assert_eq!(map.get(&2), Some(&-2));\n-    /// assert_eq!(map.get(&3), Some(&-3));\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, T> {\n-        let mut iter = unsafe {MutEntries::new()};\n-        iter.stack[0] = self.root.children.iter_mut();\n-        iter.length = 1;\n-        iter.remaining_min = self.length;\n-        iter.remaining_max = self.length;\n-\n-        iter\n-    }\n-\n-    /// Return the number of elements in the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut a = TrieMap::new();\n-    /// assert_eq!(a.len(), 0);\n-    /// a.insert(1, \"a\");\n-    /// assert_eq!(a.len(), 1);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn len(&self) -> uint { self.length }\n-\n-    /// Return true if the map contains no elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut a = TrieMap::new();\n-    /// assert!(a.is_empty());\n-    /// a.insert(1, \"a\");\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clears the map, removing all values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut a = TrieMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.clear();\n-    /// assert!(a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn clear(&mut self) {\n-        self.root = InternalNode::new();\n-        self.length = 0;\n-    }\n-\n-    /// Deprecated: renamed to `get`.\n-    #[deprecated = \"renamed to `get`\"]\n-    pub fn find(&self, key: &uint) -> Option<&T> {\n-        self.get(key)\n-    }\n-\n-    /// Returns a reference to the value corresponding to the key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut map = TrieMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.get(&1), Some(&\"a\"));\n-    /// assert_eq!(map.get(&2), None);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get(&self, key: &uint) -> Option<&T> {\n-        let mut node = &self.root;\n-        let mut idx = 0;\n-        loop {\n-            match node.children[chunk(*key, idx)] {\n-              Internal(ref x) => node = &**x,\n-              External(stored, ref value) => {\n-                if stored == *key {\n-                    return Some(value)\n-                } else {\n-                    return None\n-                }\n-              }\n-              Nothing => return None\n-            }\n-            idx += 1;\n-        }\n-    }\n-\n-    /// Returns true if the map contains a value for the specified key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut map = TrieMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.contains_key(&1), true);\n-    /// assert_eq!(map.contains_key(&2), false);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains_key(&self, key: &uint) -> bool {\n-        self.get(key).is_some()\n-    }\n-\n-    /// Deprecated: renamed to `get_mut`.\n-    #[deprecated = \"renamed to `get_mut`\"]\n-    pub fn find_mut(&mut self, key: &uint) -> Option<&mut T> {\n-        self.get_mut(key)\n-    }\n-\n-    /// Returns a mutable reference to the value corresponding to the key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut map = TrieMap::new();\n-    /// map.insert(1, \"a\");\n-    /// match map.get_mut(&1) {\n-    ///     Some(x) => *x = \"b\",\n-    ///     None => (),\n-    /// }\n-    /// assert_eq!(map[1], \"b\");\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n-        find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n-    }\n-\n-    /// Deprecated: Renamed to `insert`.\n-    #[deprecated = \"Renamed to `insert`\"]\n-    pub fn swap(&mut self, key: uint, value: T) -> Option<T> {\n-        self.insert(key, value)\n-    }\n-\n-    /// Inserts a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise, `None` is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut map = TrieMap::new();\n-    /// assert_eq!(map.insert(37, \"a\"), None);\n-    /// assert_eq!(map.is_empty(), false);\n-    ///\n-    /// map.insert(37, \"b\");\n-    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n-    /// assert_eq!(map[37], \"c\");\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn insert(&mut self, key: uint, value: T) -> Option<T> {\n-        let (_, old_val) = insert(&mut self.root.count,\n-                                    &mut self.root.children[chunk(key, 0)],\n-                                    key, value, 1);\n-        if old_val.is_none() { self.length += 1 }\n-        old_val\n-    }\n-\n-    /// Deprecated: Renamed to `remove`.\n-    #[deprecated = \"Renamed to `remove`\"]\n-    pub fn pop(&mut self, key: &uint) -> Option<T> {\n-        self.remove(key)\n-    }\n-\n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut map = TrieMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), Some(\"a\"));\n-    /// assert_eq!(map.remove(&1), None);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, key: &uint) -> Option<T> {\n-        let ret = remove(&mut self.root.count,\n-                         &mut self.root.children[chunk(*key, 0)],\n-                         *key, 1);\n-        if ret.is_some() { self.length -= 1 }\n-        ret\n-    }\n-}\n-\n-// FIXME #5846 we want to be able to choose between &x and &mut x\n-// (with many different `x`) below, so we need to optionally pass mut\n-// as a tt, but the only thing we can do with a `tt` is pass them to\n-// other macros, so this takes the `& <mutability> <operand>` token\n-// sequence and forces their evaluation as an expression. (see also\n-// `item!` below.)\n-macro_rules! addr { ($e:expr) => { $e } }\n-\n-macro_rules! bound {\n-    ($iterator_name:ident,\n-     // the current treemap\n-     self = $this:expr,\n-     // the key to look for\n-     key = $key:expr,\n-     // are we looking at the upper bound?\n-     is_upper = $upper:expr,\n-\n-     // method names for slicing/iterating.\n-     slice_from = $slice_from:ident,\n-     iter = $iter:ident,\n-\n-     // see the comment on `addr!`, this is just an optional mut, but\n-     // there's no 0-or-1 repeats yet.\n-     mutability = $($mut_:tt)*) => {\n-        {\n-            // # For `mut`\n-            // We need an unsafe pointer here because we are borrowing\n-            // mutable references to the internals of each of these\n-            // mutable nodes, while still using the outer node.\n-            //\n-            // However, we're allowed to flaunt rustc like this because we\n-            // never actually modify the \"shape\" of the nodes. The only\n-            // place that mutation is can actually occur is of the actual\n-            // values of the TrieMap (as the return value of the\n-            // iterator), i.e. we can never cause a deallocation of any\n-            // InternalNodes so the raw pointer is always valid.\n-            //\n-            // # For non-`mut`\n-            // We like sharing code so much that even a little unsafe won't\n-            // stop us.\n-            let this = $this;\n-            let mut node = unsafe {\n-                mem::transmute::<_, uint>(&this.root) as *mut InternalNode<T>\n-            };\n-\n-            let key = $key;\n-\n-            let mut it = unsafe {$iterator_name::new()};\n-            // everything else is zero'd, as we want.\n-            it.remaining_max = this.length;\n-\n-            // this addr is necessary for the `Internal` pattern.\n-            addr!(loop {\n-                    let children = unsafe {addr!(& $($mut_)* (*node).children)};\n-                    // it.length is the current depth in the iterator and the\n-                    // current depth through the `uint` key we've traversed.\n-                    let child_id = chunk(key, it.length);\n-                    let (slice_idx, ret) = match children[child_id] {\n-                        Internal(ref $($mut_)* n) => {\n-                            node = unsafe {\n-                                mem::transmute::<_, uint>(&**n)\n-                                    as *mut InternalNode<T>\n-                            };\n-                            (child_id + 1, false)\n-                        }\n-                        External(stored, _) => {\n-                            (if stored < key || ($upper && stored == key) {\n-                                child_id + 1\n-                            } else {\n-                                child_id\n-                            }, true)\n-                        }\n-                        Nothing => {\n-                            (child_id + 1, true)\n-                        }\n-                    };\n-                    // push to the stack.\n-                    it.stack[it.length] = children.$slice_from(&slice_idx).$iter();\n-                    it.length += 1;\n-                    if ret { return it }\n-                })\n-        }\n-    }\n-}\n-\n-impl<T> TrieMap<T> {\n-    // If `upper` is true then returns upper_bound else returns lower_bound.\n-    #[inline]\n-    fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n-        bound!(Entries, self = self,\n-               key = key, is_upper = upper,\n-               slice_from = slice_from_or_fail, iter = iter,\n-               mutability = )\n-    }\n-\n-    /// Gets an iterator pointing to the first key-value pair whose key is not less than `key`.\n-    /// If all keys in the map are less than `key` an empty iterator is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    /// let map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(map.lower_bound(4).next(), Some((4, &\"b\")));\n-    /// assert_eq!(map.lower_bound(5).next(), Some((6, &\"c\")));\n-    /// assert_eq!(map.lower_bound(10).next(), None);\n-    /// ```\n-    pub fn lower_bound<'a>(&'a self, key: uint) -> Entries<'a, T> {\n-        self.bound(key, false)\n-    }\n-\n-    /// Gets an iterator pointing to the first key-value pair whose key is greater than `key`.\n-    /// If all keys in the map are not greater than `key` an empty iterator is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    /// let map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(map.upper_bound(4).next(), Some((6, &\"c\")));\n-    /// assert_eq!(map.upper_bound(5).next(), Some((6, &\"c\")));\n-    /// assert_eq!(map.upper_bound(10).next(), None);\n-    /// ```\n-    pub fn upper_bound<'a>(&'a self, key: uint) -> Entries<'a, T> {\n-        self.bound(key, true)\n-    }\n-    // If `upper` is true then returns upper_bound else returns lower_bound.\n-    #[inline]\n-    fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n-        bound!(MutEntries, self = self,\n-               key = key, is_upper = upper,\n-               slice_from = slice_from_or_fail_mut, iter = iter_mut,\n-               mutability = mut)\n-    }\n-\n-    /// Gets an iterator pointing to the first key-value pair whose key is not less than `key`.\n-    /// If all keys in the map are less than `key` an empty iterator is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    /// let mut map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(map.lower_bound_mut(4).next(), Some((4, &mut \"b\")));\n-    /// assert_eq!(map.lower_bound_mut(5).next(), Some((6, &mut \"c\")));\n-    /// assert_eq!(map.lower_bound_mut(10).next(), None);\n-    ///\n-    /// for (key, value) in map.lower_bound_mut(4) {\n-    ///     *value = \"changed\";\n-    /// }\n-    ///\n-    /// assert_eq!(map.get(&2), Some(&\"a\"));\n-    /// assert_eq!(map.get(&4), Some(&\"changed\"));\n-    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n-    /// ```\n-    pub fn lower_bound_mut<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n-        self.bound_mut(key, false)\n-    }\n-\n-    /// Gets an iterator pointing to the first key-value pair whose key is greater than `key`.\n-    /// If all keys in the map are not greater than `key` an empty iterator is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    /// let mut map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(map.upper_bound_mut(4).next(), Some((6, &mut \"c\")));\n-    /// assert_eq!(map.upper_bound_mut(5).next(), Some((6, &mut \"c\")));\n-    /// assert_eq!(map.upper_bound_mut(10).next(), None);\n-    ///\n-    /// for (key, value) in map.upper_bound_mut(4) {\n-    ///     *value = \"changed\";\n-    /// }\n-    ///\n-    /// assert_eq!(map.get(&2), Some(&\"a\"));\n-    /// assert_eq!(map.get(&4), Some(&\"b\"));\n-    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n-    /// ```\n-    pub fn upper_bound_mut<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n-        self.bound_mut(key, true)\n-    }\n-}\n-\n-impl<T> FromIterator<(uint, T)> for TrieMap<T> {\n-    fn from_iter<Iter: Iterator<(uint, T)>>(iter: Iter) -> TrieMap<T> {\n-        let mut map = TrieMap::new();\n-        map.extend(iter);\n-        map\n-    }\n-}\n-\n-impl<T> Extend<(uint, T)> for TrieMap<T> {\n-    fn extend<Iter: Iterator<(uint, T)>>(&mut self, mut iter: Iter) {\n-        for (k, v) in iter {\n-            self.insert(k, v);\n-        }\n-    }\n-}\n-\n-impl<S: Writer, T: Hash<S>> Hash<S> for TrieMap<T> {\n-    fn hash(&self, state: &mut S) {\n-        for elt in self.iter() {\n-            elt.hash(state);\n-        }\n-    }\n-}\n-\n-impl<T> Index<uint, T> for TrieMap<T> {\n-    #[inline]\n-    fn index<'a>(&'a self, i: &uint) -> &'a T {\n-        self.get(i).expect(\"key not present\")\n-    }\n-}\n-\n-impl<T> IndexMut<uint, T> for TrieMap<T> {\n-    #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut T {\n-        self.get_mut(i).expect(\"key not present\")\n-    }\n-}\n-\n-impl<T:Clone> Clone for InternalNode<T> {\n-    #[inline]\n-    fn clone(&self) -> InternalNode<T> {\n-        let ch = &self.children;\n-        InternalNode {\n-            count: self.count,\n-             children: [ch[0].clone(), ch[1].clone(), ch[2].clone(), ch[3].clone(),\n-                        ch[4].clone(), ch[5].clone(), ch[6].clone(), ch[7].clone(),\n-                        ch[8].clone(), ch[9].clone(), ch[10].clone(), ch[11].clone(),\n-                        ch[12].clone(), ch[13].clone(), ch[14].clone(), ch[15].clone()]}\n-    }\n-}\n-\n-impl<T> InternalNode<T> {\n-    #[inline]\n-    fn new() -> InternalNode<T> {\n-        // FIXME: #5244: [Nothing, ..SIZE] should be possible without implicit\n-        // copyability\n-        InternalNode{count: 0,\n-                 children: [Nothing, Nothing, Nothing, Nothing,\n-                            Nothing, Nothing, Nothing, Nothing,\n-                            Nothing, Nothing, Nothing, Nothing,\n-                            Nothing, Nothing, Nothing, Nothing]}\n-    }\n-}\n-\n-impl<T> InternalNode<T> {\n-    fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n-        for elt in self.children.iter().rev() {\n-            match *elt {\n-                Internal(ref x) => if !x.each_reverse(|i,t| f(i,t)) { return false },\n-                External(k, ref v) => if !f(&k, v) { return false },\n-                Nothing => ()\n-            }\n-        }\n-        true\n-    }\n-}\n-\n-// if this was done via a trait, the key could be generic\n-#[inline]\n-fn chunk(n: uint, idx: uint) -> uint {\n-    let sh = uint::BITS - (SHIFT * (idx + 1));\n-    (n >> sh) & MASK\n-}\n-\n-fn find_mut<'r, T>(child: &'r mut TrieNode<T>, key: uint, idx: uint) -> Option<&'r mut T> {\n-    match *child {\n-        External(stored, ref mut value) if stored == key => Some(value),\n-        External(..) => None,\n-        Internal(ref mut x) => find_mut(&mut x.children[chunk(key, idx)], key, idx + 1),\n-        Nothing => None\n-    }\n-}\n-\n-/// Inserts a new node for the given key and value, at or below `start_node`.\n-///\n-/// The index (`idx`) is the index of the next node, such that the start node\n-/// was accessed via parent.children[chunk(key, idx - 1)].\n-///\n-/// The count is the external node counter for the start node's parent,\n-/// which will be incremented only if `start_node` is transformed into a *new* external node.\n-///\n-/// Returns a mutable reference to the inserted value and an optional previous value.\n-fn insert<'a, T>(count: &mut uint, start_node: &'a mut TrieNode<T>, key: uint, value: T, idx: uint)\n-    -> (&'a mut T, Option<T>) {\n-    // We branch twice to avoid having to do the `replace` when we\n-    // don't need to; this is much faster, especially for keys that\n-    // have long shared prefixes.\n-    match *start_node {\n-        Nothing => {\n-            *count += 1;\n-            *start_node = External(key, value);\n-            match *start_node {\n-                External(_, ref mut value_ref) => return (value_ref, None),\n-                _ => unreachable!()\n-            }\n-        }\n-        Internal(box ref mut x) => {\n-            return insert(&mut x.count, &mut x.children[chunk(key, idx)], key, value, idx + 1);\n-        }\n-        External(stored_key, ref mut stored_value) if stored_key == key => {\n-            // Swap in the new value and return the old.\n-            let old_value = mem::replace(stored_value, value);\n-            return (stored_value, Some(old_value));\n-        }\n-        _ => {}\n-    }\n-\n-    // Conflict, an external node with differing keys.\n-    // We replace the old node by an internal one, then re-insert the two values beneath it.\n-    match mem::replace(start_node, Internal(box InternalNode::new())) {\n-        External(stored_key, stored_value) => {\n-            match *start_node {\n-                Internal(box ref mut new_node) => {\n-                    // Re-insert the old value.\n-                    insert(&mut new_node.count,\n-                           &mut new_node.children[chunk(stored_key, idx)],\n-                           stored_key, stored_value, idx + 1);\n-\n-                    // Insert the new value, and return a reference to it directly.\n-                    insert(&mut new_node.count,\n-                           &mut new_node.children[chunk(key, idx)],\n-                           key, value, idx + 1)\n-                }\n-                // Value that was just copied disappeared.\n-                _ => unreachable!()\n-            }\n-        }\n-        // Logic error in previous match.\n-        _ => unreachable!(),\n-    }\n-}\n-\n-fn remove<T>(count: &mut uint, child: &mut TrieNode<T>, key: uint,\n-             idx: uint) -> Option<T> {\n-    let (ret, this) = match *child {\n-      External(stored, _) if stored == key => {\n-        match mem::replace(child, Nothing) {\n-            External(_, value) => (Some(value), true),\n-            _ => unreachable!()\n-        }\n-      }\n-      External(..) => (None, false),\n-      Internal(box ref mut x) => {\n-          let ret = remove(&mut x.count, &mut x.children[chunk(key, idx)],\n-                           key, idx + 1);\n-          (ret, x.count == 0)\n-      }\n-      Nothing => (None, false)\n-    };\n-\n-    if this {\n-        *child = Nothing;\n-        *count -= 1;\n-    }\n-    return ret;\n-}\n-\n-/// A view into a single entry in a TrieMap, which may be vacant or occupied.\n-pub enum Entry<'a, T: 'a> {\n-    /// An occupied entry.\n-    Occupied(OccupiedEntry<'a, T>),\n-    /// A vacant entry.\n-    Vacant(VacantEntry<'a, T>)\n-}\n-\n-/// A view into an occupied entry in a TrieMap.\n-pub struct OccupiedEntry<'a, T: 'a> {\n-    search_stack: SearchStack<'a, T>\n-}\n-\n-/// A view into a vacant entry in a TrieMap.\n-pub struct VacantEntry<'a, T: 'a> {\n-    search_stack: SearchStack<'a, T>\n-}\n-\n-/// A list of nodes encoding a path from the root of a TrieMap to a node.\n-///\n-/// Invariants:\n-/// * The last node is either `External` or `Nothing`.\n-/// * Pointers at indexes less than `length` can be safely dereferenced.\n-struct SearchStack<'a, T: 'a> {\n-    map: &'a mut TrieMap<T>,\n-    length: uint,\n-    key: uint,\n-    items: [*mut TrieNode<T>, ..MAX_DEPTH]\n-}\n-\n-impl<'a, T> SearchStack<'a, T> {\n-    /// Creates a new search-stack with empty entries.\n-    fn new(map: &'a mut TrieMap<T>, key: uint) -> SearchStack<'a, T> {\n-        SearchStack {\n-            map: map,\n-            length: 0,\n-            key: key,\n-            items: [ptr::null_mut(), ..MAX_DEPTH]\n-        }\n-    }\n-\n-    fn push(&mut self, node: *mut TrieNode<T>) {\n-        self.length += 1;\n-        self.items[self.length - 1] = node;\n-    }\n-\n-    fn peek(&self) -> *mut TrieNode<T> {\n-        self.items[self.length - 1]\n-    }\n-\n-    fn peek_ref(&self) -> &'a mut TrieNode<T> {\n-        unsafe {\n-            &mut *self.items[self.length - 1]\n-        }\n-    }\n-\n-    fn pop_ref(&mut self) -> &'a mut TrieNode<T> {\n-        self.length -= 1;\n-        unsafe {\n-            &mut *self.items[self.length]\n-        }\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.length == 0\n-    }\n-\n-    fn get_ref(&self, idx: uint) -> &'a mut TrieNode<T> {\n-        assert!(idx < self.length);\n-        unsafe {\n-            &mut *self.items[idx]\n-        }\n-    }\n-}\n-\n-// Implementation of SearchStack creation logic.\n-// Once a SearchStack has been created the Entry methods are relatively straight-forward.\n-impl<T> TrieMap<T> {\n-    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    #[inline]\n-    pub fn entry<'a>(&'a mut self, key: uint) -> Entry<'a, T> {\n-        // Create an empty search stack.\n-        let mut search_stack = SearchStack::new(self, key);\n-\n-        // Unconditionally add the corresponding node from the first layer.\n-        let first_node = &mut search_stack.map.root.children[chunk(key, 0)] as *mut _;\n-        search_stack.push(first_node);\n-\n-        // While no appropriate slot is found, keep descending down the Trie,\n-        // adding nodes to the search stack.\n-        let search_successful: bool;\n-        loop {\n-            match unsafe { next_child(search_stack.peek(), key, search_stack.length) } {\n-                (Some(child), _) => search_stack.push(child),\n-                (None, success) => {\n-                    search_successful = success;\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if search_successful {\n-            Occupied(OccupiedEntry { search_stack: search_stack })\n-        } else {\n-            Vacant(VacantEntry { search_stack: search_stack })\n-        }\n-    }\n-}\n-\n-/// Get a mutable pointer to the next child of a node, given a key and an idx.\n-///\n-/// The idx is the index of the next child, such that `node` was accessed via\n-/// parent.children[chunk(key, idx - 1)].\n-///\n-/// Returns a tuple with an optional mutable pointer to the next child, and\n-/// a boolean flag to indicate whether the external key node was found.\n-///\n-/// This function is safe only if `node` points to a valid `TrieNode`.\n-#[inline]\n-unsafe fn next_child<'a, T>(node: *mut TrieNode<T>, key: uint, idx: uint)\n-    -> (Option<*mut TrieNode<T>>, bool) {\n-    match *node {\n-        // If the node is internal, tell the caller to descend further.\n-        Internal(box ref mut node_internal) => {\n-            (Some(&mut node_internal.children[chunk(key, idx)] as *mut _), false)\n-        },\n-        // If the node is external or empty, the search is complete.\n-        // If the key doesn't match, node expansion will be done upon\n-        // insertion. If it does match, we've found our node.\n-        External(stored_key, _) if stored_key == key => (None, true),\n-        External(..) | Nothing => (None, false)\n-    }\n-}\n-\n-// NB: All these methods assume a correctly constructed occupied entry (matching the given key).\n-impl<'a, T> OccupiedEntry<'a, T> {\n-    /// Gets a reference to the value in the entry.\n-    #[inline]\n-    pub fn get(&self) -> &T {\n-        match *self.search_stack.peek_ref() {\n-            External(_, ref value) => value,\n-            // Invalid SearchStack, non-external last node.\n-            _ => unreachable!()\n-        }\n-    }\n-\n-    /// Gets a mutable reference to the value in the entry.\n-    #[inline]\n-    pub fn get_mut(&mut self) -> &mut T {\n-        match *self.search_stack.peek_ref() {\n-            External(_, ref mut value) => value,\n-            // Invalid SearchStack, non-external last node.\n-            _ => unreachable!()\n-        }\n-    }\n-\n-    /// Converts the OccupiedEntry into a mutable reference to the value in the entry,\n-    /// with a lifetime bound to the map itself.\n-    #[inline]\n-    pub fn into_mut(self) -> &'a mut T {\n-        match *self.search_stack.peek_ref() {\n-            External(_, ref mut value) => value,\n-            // Invalid SearchStack, non-external last node.\n-            _ => unreachable!()\n-        }\n-    }\n-\n-    /// Sets the value of the entry, and returns the entry's old value.\n-    #[inline]\n-    pub fn set(&mut self, value: T) -> T {\n-        match *self.search_stack.peek_ref() {\n-            External(_, ref mut stored_value) => {\n-                mem::replace(stored_value, value)\n-            }\n-            // Invalid SearchStack, non-external last node.\n-            _ => unreachable!()\n-        }\n-    }\n-\n-    /// Takes the value out of the entry, and returns it.\n-    #[inline]\n-    pub fn take(self) -> T {\n-        // This function removes the external leaf-node, then unwinds the search-stack\n-        // deleting now-childless ancestors.\n-        let mut search_stack = self.search_stack;\n-\n-        // Extract the value from the leaf-node of interest.\n-        let leaf_node = mem::replace(search_stack.pop_ref(), Nothing);\n-\n-        let value = match leaf_node {\n-            External(_, value) => value,\n-            // Invalid SearchStack, non-external last node.\n-            _ => unreachable!()\n-        };\n-\n-        // Iterate backwards through the search stack, deleting nodes if they are childless.\n-        // We compare each ancestor's parent count to 1 because each ancestor reached has just\n-        // had one of its children deleted.\n-        while !search_stack.is_empty() {\n-            let ancestor = search_stack.pop_ref();\n-            match *ancestor {\n-                Internal(ref mut internal) => {\n-                    // If stopping deletion, update the child count and break.\n-                    if internal.count != 1 {\n-                        internal.count -= 1;\n-                        break;\n-                    }\n-                }\n-                // Invalid SearchStack, non-internal ancestor node.\n-                _ => unreachable!()\n-            }\n-            *ancestor = Nothing;\n-        }\n-\n-        // Decrement the length of the entire TrieMap, for the removed node.\n-        search_stack.map.length -= 1;\n-\n-        value\n-    }\n-}\n-\n-impl<'a, T> VacantEntry<'a, T> {\n-    /// Set the vacant entry to the given value.\n-    pub fn set(self, value: T) -> &'a mut T {\n-        let search_stack = self.search_stack;\n-        let old_length = search_stack.length;\n-        let key = search_stack.key;\n-\n-        // Update the TrieMap's length for the new element.\n-        search_stack.map.length += 1;\n-\n-        // If there's only 1 node in the search stack, insert a new node below it at idx 1.\n-        if old_length == 1 {\n-            // Note: Small hack to appease the borrow checker. Can't mutably borrow root.count\n-            let mut temp = search_stack.map.root.count;\n-            let (value_ref, _) = insert(&mut temp, search_stack.get_ref(0), key, value, 1);\n-            search_stack.map.root.count = temp;\n-            value_ref\n-        }\n-        // Otherwise, find the predecessor of the last stack node, and insert as normal.\n-        else {\n-            match *search_stack.get_ref(old_length - 2) {\n-                Internal(box ref mut parent) => {\n-                    let (value_ref, _) = insert(&mut parent.count,\n-                                                &mut parent.children[chunk(key, old_length - 1)],\n-                                                key, value, old_length);\n-                    value_ref\n-                }\n-                // Invalid SearchStack, non-internal ancestor node.\n-                _ => unreachable!()\n-            }\n-        }\n-    }\n-}\n-\n-/// A forward iterator over a map.\n-pub struct Entries<'a, T:'a> {\n-    stack: [slice::Items<'a, TrieNode<T>>, .. MAX_DEPTH],\n-    length: uint,\n-    remaining_min: uint,\n-    remaining_max: uint\n-}\n-\n-/// A forward iterator over the key-value pairs of a map, with the\n-/// values being mutable.\n-pub struct MutEntries<'a, T:'a> {\n-    stack: [slice::MutItems<'a, TrieNode<T>>, .. MAX_DEPTH],\n-    length: uint,\n-    remaining_min: uint,\n-    remaining_max: uint\n-}\n-\n-/// A forward iterator over the keys of a map.\n-pub type Keys<'a, T> = iter::Map<(uint, &'a T), uint, Entries<'a, T>, fn((uint, &'a T)) -> uint>;\n-\n-/// A forward iterator over the values of a map.\n-pub type Values<'a, T> =\n-    iter::Map<(uint, &'a T), &'a T, Entries<'a, T>, fn((uint, &'a T)) -> &'a T>;\n-\n-// FIXME #5846: see `addr!` above.\n-macro_rules! item { ($i:item) => {$i}}\n-\n-macro_rules! iterator_impl {\n-    ($name:ident,\n-     iter = $iter:ident,\n-     mutability = $($mut_:tt)*) => {\n-        impl<'a, T> $name<'a, T> {\n-            // Create new zero'd iterator. We have a thin gilding of safety by\n-            // using init rather than uninit, so that the worst that can happen\n-            // from failing to initialise correctly after calling these is a\n-            // segfault.\n-            #[cfg(target_word_size=\"32\")]\n-            unsafe fn new() -> $name<'a, T> {\n-                $name {\n-                    remaining_min: 0,\n-                    remaining_max: 0,\n-                    length: 0,\n-                    // ick :( ... at least the compiler will tell us if we screwed up.\n-                    stack: [zeroed(), zeroed(), zeroed(), zeroed(), zeroed(),\n-                            zeroed(), zeroed(), zeroed()]\n-                }\n-            }\n-\n-            #[cfg(target_word_size=\"64\")]\n-            unsafe fn new() -> $name<'a, T> {\n-                $name {\n-                    remaining_min: 0,\n-                    remaining_max: 0,\n-                    length: 0,\n-                    stack: [zeroed(), zeroed(), zeroed(), zeroed(),\n-                            zeroed(), zeroed(), zeroed(), zeroed(),\n-                            zeroed(), zeroed(), zeroed(), zeroed(),\n-                            zeroed(), zeroed(), zeroed(), zeroed()]\n-                }\n-            }\n-        }\n-\n-        item! { impl<'a, T> Iterator<(uint, &'a $($mut_)* T)> for $name<'a, T> {\n-                // you might wonder why we're not even trying to act within the\n-                // rules, and are just manipulating raw pointers like there's no\n-                // such thing as invalid pointers and memory unsafety. The\n-                // reason is performance, without doing this we can get the\n-                // (now replaced) bench_iter_large microbenchmark down to about\n-                // 30000 ns/iter (using .unsafe_get to index self.stack directly, 38000\n-                // ns/iter with [] checked indexing), but this smashes that down\n-                // to 13500 ns/iter.\n-                //\n-                // Fortunately, it's still safe...\n-                //\n-                // We have an invariant that every Internal node\n-                // corresponds to one push to self.stack, and one pop,\n-                // nested appropriately. self.stack has enough storage\n-                // to store the maximum depth of Internal nodes in the\n-                // trie (8 on 32-bit platforms, 16 on 64-bit).\n-                fn next(&mut self) -> Option<(uint, &'a $($mut_)* T)> {\n-                    let start_ptr = self.stack.as_mut_ptr();\n-\n-                    unsafe {\n-                        // write_ptr is the next place to write to the stack.\n-                        // invariant: start_ptr <= write_ptr < end of the\n-                        // vector.\n-                        let mut write_ptr = start_ptr.offset(self.length as int);\n-                        while write_ptr != start_ptr {\n-                            // indexing back one is safe, since write_ptr >\n-                            // start_ptr now.\n-                            match (*write_ptr.offset(-1)).next() {\n-                                // exhausted this iterator (i.e. finished this\n-                                // Internal node), so pop from the stack.\n-                                //\n-                                // don't bother clearing the memory, because the\n-                                // next time we use it we'll've written to it\n-                                // first.\n-                                None => write_ptr = write_ptr.offset(-1),\n-                                Some(child) => {\n-                                    addr!(match *child {\n-                                            Internal(ref $($mut_)* node) => {\n-                                                // going down a level, so push\n-                                                // to the stack (this is the\n-                                                // write referenced above)\n-                                                *write_ptr = node.children.$iter();\n-                                                write_ptr = write_ptr.offset(1);\n-                                            }\n-                                            External(key, ref $($mut_)* value) => {\n-                                                self.remaining_max -= 1;\n-                                                if self.remaining_min > 0 {\n-                                                    self.remaining_min -= 1;\n-                                                }\n-                                                // store the new length of the\n-                                                // stack, based on our current\n-                                                // position.\n-                                                self.length = (write_ptr as uint\n-                                                               - start_ptr as uint) /\n-                                                    mem::size_of_val(&*write_ptr);\n-\n-                                                return Some((key, value));\n-                                            }\n-                                            Nothing => {}\n-                                        })\n-                                }\n-                            }\n-                        }\n-                    }\n-                    return None;\n-                }\n-\n-                #[inline]\n-                fn size_hint(&self) -> (uint, Option<uint>) {\n-                    (self.remaining_min, Some(self.remaining_max))\n-                }\n-            } }\n-    }\n-}\n-\n-iterator_impl! { Entries, iter = iter, mutability = }\n-iterator_impl! { MutEntries, iter = iter_mut, mutability = mut }\n-\n-#[cfg(test)]\n-mod test {\n-    use std::prelude::*;\n-    use std::iter::range_step;\n-    use std::uint;\n-    use std::hash;\n-\n-    use super::{TrieMap, InternalNode};\n-    use super::Entry::*;\n-    use super::TrieNode::*;\n-\n-    fn check_integrity<T>(trie: &InternalNode<T>) {\n-        assert!(trie.count != 0);\n-\n-        let mut sum = 0;\n-\n-        for x in trie.children.iter() {\n-            match *x {\n-              Nothing => (),\n-              Internal(ref y) => {\n-                  check_integrity(&**y);\n-                  sum += 1\n-              }\n-              External(_, _) => { sum += 1 }\n-            }\n-        }\n-\n-        assert_eq!(sum, trie.count);\n-    }\n-\n-    #[test]\n-    fn test_find_mut() {\n-        let mut m = TrieMap::new();\n-        assert!(m.insert(1u, 12i).is_none());\n-        assert!(m.insert(2u, 8i).is_none());\n-        assert!(m.insert(5u, 14i).is_none());\n-        let new = 100;\n-        match m.get_mut(&5) {\n-            None => panic!(), Some(x) => *x = new\n-        }\n-        assert_eq!(m.get(&5), Some(&new));\n-    }\n-\n-    #[test]\n-    fn test_find_mut_missing() {\n-        let mut m = TrieMap::new();\n-        assert!(m.get_mut(&0).is_none());\n-        assert!(m.insert(1u, 12i).is_none());\n-        assert!(m.get_mut(&0).is_none());\n-        assert!(m.insert(2, 8).is_none());\n-        assert!(m.get_mut(&0).is_none());\n-    }\n-\n-    #[test]\n-    fn test_step() {\n-        let mut trie = TrieMap::new();\n-        let n = 300u;\n-\n-        for x in range_step(1u, n, 2) {\n-            assert!(trie.insert(x, x + 1).is_none());\n-            assert!(trie.contains_key(&x));\n-            check_integrity(&trie.root);\n-        }\n-\n-        for x in range_step(0u, n, 2) {\n-            assert!(!trie.contains_key(&x));\n-            assert!(trie.insert(x, x + 1).is_none());\n-            check_integrity(&trie.root);\n-        }\n-\n-        for x in range(0u, n) {\n-            assert!(trie.contains_key(&x));\n-            assert!(!trie.insert(x, x + 1).is_none());\n-            check_integrity(&trie.root);\n-        }\n-\n-        for x in range_step(1u, n, 2) {\n-            assert!(trie.remove(&x).is_some());\n-            assert!(!trie.contains_key(&x));\n-            check_integrity(&trie.root);\n-        }\n-\n-        for x in range_step(0u, n, 2) {\n-            assert!(trie.contains_key(&x));\n-            assert!(!trie.insert(x, x + 1).is_none());\n-            check_integrity(&trie.root);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_reverse() {\n-        let mut m = TrieMap::new();\n-\n-        assert!(m.insert(3, 6).is_none());\n-        assert!(m.insert(0, 0).is_none());\n-        assert!(m.insert(4, 8).is_none());\n-        assert!(m.insert(2, 4).is_none());\n-        assert!(m.insert(1, 2).is_none());\n-\n-        let mut n = 4;\n-        m.each_reverse(|k, v| {\n-            assert_eq!(*k, n);\n-            assert_eq!(*v, n * 2);\n-            n -= 1;\n-            true\n-        });\n-    }\n-\n-    #[test]\n-    fn test_each_reverse_break() {\n-        let mut m = TrieMap::new();\n-\n-        for x in range(uint::MAX - 10000, uint::MAX).rev() {\n-            m.insert(x, x / 2);\n-        }\n-\n-        let mut n = uint::MAX - 1;\n-        m.each_reverse(|k, v| {\n-            if n == uint::MAX - 5000 { false } else {\n-                assert!(n > uint::MAX - 5000);\n-\n-                assert_eq!(*k, n);\n-                assert_eq!(*v, n / 2);\n-                n -= 1;\n-                true\n-            }\n-        });\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        let mut m = TrieMap::new();\n-        assert_eq!(m.insert(1u, 2i), None);\n-        assert_eq!(m.insert(1u, 3i), Some(2));\n-        assert_eq!(m.insert(1u, 4i), Some(3));\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        let mut m = TrieMap::new();\n-        m.insert(1u, 2i);\n-        assert_eq!(m.remove(&1), Some(2));\n-        assert_eq!(m.remove(&1), None);\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = vec![(1u, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: TrieMap<int> = xs.iter().map(|&x| x).collect();\n-\n-        for &(k, v) in xs.iter() {\n-            assert_eq!(map.get(&k), Some(&v));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_keys() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map = vec.into_iter().collect::<TrieMap<char>>();\n-        let keys = map.keys().collect::<Vec<uint>>();\n-        assert_eq!(keys.len(), 3);\n-        assert!(keys.contains(&1));\n-        assert!(keys.contains(&2));\n-        assert!(keys.contains(&3));\n-    }\n-\n-    #[test]\n-    fn test_values() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map = vec.into_iter().collect::<TrieMap<char>>();\n-        let values = map.values().map(|&v| v).collect::<Vec<char>>();\n-        assert_eq!(values.len(), 3);\n-        assert!(values.contains(&'a'));\n-        assert!(values.contains(&'b'));\n-        assert!(values.contains(&'c'));\n-    }\n-\n-    #[test]\n-    fn test_iteration() {\n-        let empty_map : TrieMap<uint> = TrieMap::new();\n-        assert_eq!(empty_map.iter().next(), None);\n-\n-        let first = uint::MAX - 10000;\n-        let last = uint::MAX;\n-\n-        let mut map = TrieMap::new();\n-        for x in range(first, last).rev() {\n-            map.insert(x, x / 2);\n-        }\n-\n-        let mut i = 0;\n-        for (k, &v) in map.iter() {\n-            assert_eq!(k, first + i);\n-            assert_eq!(v, k / 2);\n-            i += 1;\n-        }\n-        assert_eq!(i, last - first);\n-    }\n-\n-    #[test]\n-    fn test_mut_iter() {\n-        let mut empty_map : TrieMap<uint> = TrieMap::new();\n-        assert!(empty_map.iter_mut().next().is_none());\n-\n-        let first = uint::MAX - 10000;\n-        let last = uint::MAX;\n-\n-        let mut map = TrieMap::new();\n-        for x in range(first, last).rev() {\n-            map.insert(x, x / 2);\n-        }\n-\n-        let mut i = 0;\n-        for (k, v) in map.iter_mut() {\n-            assert_eq!(k, first + i);\n-            *v -= k / 2;\n-            i += 1;\n-        }\n-        assert_eq!(i, last - first);\n-\n-        assert!(map.iter().all(|(_, &v)| v == 0));\n-    }\n-\n-    #[test]\n-    fn test_bound() {\n-        let empty_map : TrieMap<uint> = TrieMap::new();\n-        assert_eq!(empty_map.lower_bound(0).next(), None);\n-        assert_eq!(empty_map.upper_bound(0).next(), None);\n-\n-        let last = 999u;\n-        let step = 3u;\n-        let value = 42u;\n-\n-        let mut map : TrieMap<uint> = TrieMap::new();\n-        for x in range_step(0u, last, step) {\n-            assert!(x % step == 0);\n-            map.insert(x, value);\n-        }\n-\n-        for i in range(0u, last - step) {\n-            let mut lb = map.lower_bound(i);\n-            let mut ub = map.upper_bound(i);\n-            let next_key = i - i % step + step;\n-            let next_pair = (next_key, &value);\n-            if i % step == 0 {\n-                assert_eq!(lb.next(), Some((i, &value)));\n-            } else {\n-                assert_eq!(lb.next(), Some(next_pair));\n-            }\n-            assert_eq!(ub.next(), Some(next_pair));\n-        }\n-\n-        let mut lb = map.lower_bound(last - step);\n-        assert_eq!(lb.next(), Some((last - step, &value)));\n-        let mut ub = map.upper_bound(last - step);\n-        assert_eq!(ub.next(), None);\n-\n-        for i in range(last - step + 1, last) {\n-            let mut lb = map.lower_bound(i);\n-            assert_eq!(lb.next(), None);\n-            let mut ub = map.upper_bound(i);\n-            assert_eq!(ub.next(), None);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_mut_bound() {\n-        let empty_map : TrieMap<uint> = TrieMap::new();\n-        assert_eq!(empty_map.lower_bound(0).next(), None);\n-        assert_eq!(empty_map.upper_bound(0).next(), None);\n-\n-        let mut m_lower = TrieMap::new();\n-        let mut m_upper = TrieMap::new();\n-        for i in range(0u, 100) {\n-            m_lower.insert(2 * i, 4 * i);\n-            m_upper.insert(2 * i, 4 * i);\n-        }\n-\n-        for i in range(0u, 199) {\n-            let mut lb_it = m_lower.lower_bound_mut(i);\n-            let (k, v) = lb_it.next().unwrap();\n-            let lb = i + i % 2;\n-            assert_eq!(lb, k);\n-            *v -= k;\n-        }\n-\n-        for i in range(0u, 198) {\n-            let mut ub_it = m_upper.upper_bound_mut(i);\n-            let (k, v) = ub_it.next().unwrap();\n-            let ub = i + 2 - i % 2;\n-            assert_eq!(ub, k);\n-            *v -= k;\n-        }\n-\n-        assert!(m_lower.lower_bound_mut(199).next().is_none());\n-        assert!(m_upper.upper_bound_mut(198).next().is_none());\n-\n-        assert!(m_lower.iter().all(|(_, &x)| x == 0));\n-        assert!(m_upper.iter().all(|(_, &x)| x == 0));\n-    }\n-\n-    #[test]\n-    fn test_clone() {\n-        let mut a = TrieMap::new();\n-\n-        a.insert(1, 'a');\n-        a.insert(2, 'b');\n-        a.insert(3, 'c');\n-\n-        assert!(a.clone() == a);\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        let mut a = TrieMap::new();\n-        let mut b = TrieMap::new();\n-\n-        assert!(a == b);\n-        assert!(a.insert(0, 5i).is_none());\n-        assert!(a != b);\n-        assert!(b.insert(0, 4i).is_none());\n-        assert!(a != b);\n-        assert!(a.insert(5, 19).is_none());\n-        assert!(a != b);\n-        assert!(!b.insert(0, 5).is_none());\n-        assert!(a != b);\n-        assert!(b.insert(5, 19).is_none());\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_lt() {\n-        let mut a = TrieMap::new();\n-        let mut b = TrieMap::new();\n-\n-        assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2u, 5i).is_none());\n-        assert!(a < b);\n-        assert!(a.insert(2, 7).is_none());\n-        assert!(!(a < b) && b < a);\n-        assert!(b.insert(1, 0).is_none());\n-        assert!(b < a);\n-        assert!(a.insert(0, 6).is_none());\n-        assert!(a < b);\n-        assert!(a.insert(6, 2).is_none());\n-        assert!(a < b && !(b < a));\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = TrieMap::new();\n-        let mut b = TrieMap::new();\n-\n-        assert!(a <= b && a >= b);\n-        assert!(a.insert(1u, 1i).is_none());\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        assert!(b.insert(2, 2).is_none());\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-      let mut x = TrieMap::new();\n-      let mut y = TrieMap::new();\n-\n-      assert!(hash::hash(&x) == hash::hash(&y));\n-      x.insert(1, 'a');\n-      x.insert(2, 'b');\n-      x.insert(3, 'c');\n-\n-      y.insert(3, 'c');\n-      y.insert(2, 'b');\n-      y.insert(1, 'a');\n-\n-      assert!(hash::hash(&x) == hash::hash(&y));\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut map = TrieMap::new();\n-        let empty: TrieMap<uint> = TrieMap::new();\n-\n-        map.insert(1, 'a');\n-        map.insert(2, 'b');\n-\n-        let map_str = format!(\"{}\", map);\n-\n-        assert!(map_str == \"{1: a, 2: b}\");\n-        assert_eq!(format!(\"{}\", empty), \"{}\");\n-    }\n-\n-    #[test]\n-    fn test_index() {\n-        let mut map = TrieMap::new();\n-\n-        map.insert(1, 2i);\n-        map.insert(2, 1i);\n-        map.insert(3, 4i);\n-\n-        assert_eq!(map[2], 1);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_index_nonexistent() {\n-        let mut map = TrieMap::new();\n-\n-        map.insert(1, 2i);\n-        map.insert(2, 1i);\n-        map.insert(3, 4i);\n-\n-        map[4];\n-    }\n-\n-    // Number of items to insert into the map during entry tests.\n-    // The tests rely on it being even.\n-    const SQUARES_UPPER_LIM: uint = 128;\n-\n-    /// Make a TrieMap storing i^2 for i in [0, 128)\n-    fn squares_map() -> TrieMap<uint> {\n-        let mut map = TrieMap::new();\n-        for i in range(0, SQUARES_UPPER_LIM) {\n-            map.insert(i, i * i);\n-        }\n-        map\n-    }\n-\n-    #[test]\n-    fn test_entry_get() {\n-        let mut map = squares_map();\n-\n-        for i in range(0, SQUARES_UPPER_LIM) {\n-            match map.entry(i) {\n-                Occupied(slot) => assert_eq!(slot.get(), &(i * i)),\n-                Vacant(_) => panic!(\"Key not found.\")\n-            }\n-        }\n-        check_integrity(&map.root);\n-    }\n-\n-    #[test]\n-    fn test_entry_get_mut() {\n-        let mut map = squares_map();\n-\n-        // Change the entries to cubes.\n-        for i in range(0, SQUARES_UPPER_LIM) {\n-            match map.entry(i) {\n-                Occupied(mut e) => {\n-                    *e.get_mut() = i * i * i;\n-                }\n-                Vacant(_) => panic!(\"Key not found.\")\n-            }\n-            assert_eq!(map.get(&i).unwrap(), &(i * i * i));\n-        }\n-\n-        check_integrity(&map.root);\n-    }\n-\n-    #[test]\n-    fn test_entry_into_mut() {\n-        let mut map = TrieMap::new();\n-        map.insert(3, 6u);\n-\n-        let value_ref = match map.entry(3) {\n-            Occupied(e) => e.into_mut(),\n-            Vacant(_) => panic!(\"Entry not found.\")\n-        };\n-\n-        assert_eq!(*value_ref, 6u);\n-    }\n-\n-    #[test]\n-    fn test_entry_take() {\n-        let mut map = squares_map();\n-        assert_eq!(map.len(), SQUARES_UPPER_LIM);\n-\n-        // Remove every odd key, checking that the correct value is returned.\n-        for i in range_step(1, SQUARES_UPPER_LIM, 2) {\n-            match map.entry(i) {\n-                Occupied(e) => assert_eq!(e.take(), i * i),\n-                Vacant(_) => panic!(\"Key not found.\")\n-            }\n-        }\n-\n-        check_integrity(&map.root);\n-\n-        // Check that the values for even keys remain unmodified.\n-        for i in range_step(0, SQUARES_UPPER_LIM, 2) {\n-            assert_eq!(map.get(&i).unwrap(), &(i * i));\n-        }\n-\n-        assert_eq!(map.len(), SQUARES_UPPER_LIM / 2);\n-    }\n-\n-    #[test]\n-    fn test_occupied_entry_set() {\n-        let mut map = squares_map();\n-\n-        // Change all the entries to cubes.\n-        for i in range(0, SQUARES_UPPER_LIM) {\n-            match map.entry(i) {\n-                Occupied(mut e) => assert_eq!(e.set(i * i * i), i * i),\n-                Vacant(_) => panic!(\"Key not found.\")\n-            }\n-            assert_eq!(map.get(&i).unwrap(), &(i * i * i));\n-        }\n-        check_integrity(&map.root);\n-    }\n-\n-    #[test]\n-    fn test_vacant_entry_set() {\n-        let mut map = TrieMap::new();\n-\n-        for i in range(0, SQUARES_UPPER_LIM) {\n-            match map.entry(i) {\n-                Vacant(e) => {\n-                    // Insert i^2.\n-                    let inserted_val = e.set(i * i);\n-                    assert_eq!(*inserted_val, i * i);\n-\n-                    // Update it to i^3 using the returned mutable reference.\n-                    *inserted_val = i * i * i;\n-                },\n-                _ => panic!(\"Non-existent key found.\")\n-            }\n-            assert_eq!(map.get(&i).unwrap(), &(i * i * i));\n-        }\n-\n-        check_integrity(&map.root);\n-        assert_eq!(map.len(), SQUARES_UPPER_LIM);\n-    }\n-\n-    #[test]\n-    fn test_single_key() {\n-        let mut map = TrieMap::new();\n-        map.insert(1, 2u);\n-\n-        match map.entry(1) {\n-            Occupied(e) => { e.take(); },\n-            _ => ()\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    use std::prelude::*;\n-    use std::rand::{weak_rng, Rng};\n-    use test::{Bencher, black_box};\n-\n-    use super::{TrieMap, Occupied, Vacant};\n-\n-    const MAP_SIZE: uint = 1000;\n-\n-    fn random_map(size: uint) -> TrieMap<uint> {\n-        let mut map = TrieMap::<uint>::new();\n-        let mut rng = weak_rng();\n-\n-        for _ in range(0, size) {\n-            map.insert(rng.gen(), rng.gen());\n-        }\n-        map\n-    }\n-\n-    fn bench_iter(b: &mut Bencher, size: uint) {\n-        let map = random_map(size);\n-        b.iter(|| {\n-            for entry in map.iter() {\n-                black_box(entry);\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn iter_20(b: &mut Bencher) {\n-        bench_iter(b, 20);\n-    }\n-\n-    #[bench]\n-    pub fn iter_1000(b: &mut Bencher) {\n-        bench_iter(b, 1000);\n-    }\n-\n-    #[bench]\n-    pub fn iter_100000(b: &mut Bencher) {\n-        bench_iter(b, 100000);\n-    }\n-\n-    #[bench]\n-    fn bench_lower_bound(b: &mut Bencher) {\n-        let mut m = TrieMap::<uint>::new();\n-        let mut rng = weak_rng();\n-        for _ in range(0u, MAP_SIZE) {\n-            m.insert(rng.gen(), rng.gen());\n-        }\n-\n-        b.iter(|| {\n-            for _ in range(0u, 10) {\n-                m.lower_bound(rng.gen());\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_upper_bound(b: &mut Bencher) {\n-        let mut m = TrieMap::<uint>::new();\n-        let mut rng = weak_rng();\n-        for _ in range(0u, MAP_SIZE) {\n-            m.insert(rng.gen(), rng.gen());\n-        }\n-\n-        b.iter(|| {\n-            for _ in range(0u, 10) {\n-                m.upper_bound(rng.gen());\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_insert_large(b: &mut Bencher) {\n-        let mut m = TrieMap::<[uint, .. 10]>::new();\n-        let mut rng = weak_rng();\n-\n-        b.iter(|| {\n-            for _ in range(0u, MAP_SIZE) {\n-                m.insert(rng.gen(), [1, .. 10]);\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_insert_large_entry(b: &mut Bencher) {\n-        let mut m = TrieMap::<[uint, .. 10]>::new();\n-        let mut rng = weak_rng();\n-\n-        b.iter(|| {\n-            for _ in range(0u, MAP_SIZE) {\n-                match m.entry(rng.gen()) {\n-                    Occupied(mut e) => { e.set([1, ..10]); },\n-                    Vacant(e) => { e.set([1, ..10]); }\n-                }\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_insert_large_low_bits(b: &mut Bencher) {\n-        let mut m = TrieMap::<[uint, .. 10]>::new();\n-        let mut rng = weak_rng();\n-\n-        b.iter(|| {\n-            for _ in range(0u, MAP_SIZE) {\n-                // only have the last few bits set.\n-                m.insert(rng.gen::<uint>() & 0xff_ff, [1, .. 10]);\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_insert_small(b: &mut Bencher) {\n-        let mut m = TrieMap::<()>::new();\n-        let mut rng = weak_rng();\n-\n-        b.iter(|| {\n-            for _ in range(0u, MAP_SIZE) {\n-                m.insert(rng.gen(), ());\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_insert_small_low_bits(b: &mut Bencher) {\n-        let mut m = TrieMap::<()>::new();\n-        let mut rng = weak_rng();\n-\n-        b.iter(|| {\n-            for _ in range(0u, MAP_SIZE) {\n-                // only have the last few bits set.\n-                m.insert(rng.gen::<uint>() & 0xff_ff, ());\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_get(b: &mut Bencher) {\n-        let map = random_map(MAP_SIZE);\n-        let keys: Vec<uint> = map.keys().collect();\n-        b.iter(|| {\n-            for key in keys.iter() {\n-                black_box(map.get(key));\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_get_entry(b: &mut Bencher) {\n-        let mut map = random_map(MAP_SIZE);\n-        let keys: Vec<uint> = map.keys().collect();\n-        b.iter(|| {\n-            for key in keys.iter() {\n-                match map.entry(*key) {\n-                    Occupied(e) => { black_box(e.get()); },\n-                    _ => ()\n-                }\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_remove(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut map = random_map(MAP_SIZE);\n-            let keys: Vec<uint> = map.keys().collect();\n-            for key in keys.iter() {\n-                black_box(map.remove(key));\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_remove_entry(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut map = random_map(MAP_SIZE);\n-            let keys: Vec<uint> = map.keys().collect();\n-            for key in keys.iter() {\n-                match map.entry(*key) {\n-                    Occupied(e) => { black_box(e.take()); },\n-                    _ => ()\n-                }\n-            }\n-        });\n-    }\n-}"}, {"sha": "4d9191a65b695fa80946a2431bf35245462b1240", "filename": "src/libcollections/trie/mod.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftrie%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftrie%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmod.rs?ref=99d6956c3bdb290b9fd539c5dc15a2b502da5e7a", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Maps are collections of unique keys with corresponding values, and sets are\n-//! just unique keys without a corresponding value.\n-//!\n-//! This crate defines `TrieMap` and `TrieSet`, which require `uint` keys.\n-//!\n-//! `TrieMap` is ordered.\n-\n-pub mod map;\n-pub mod set;"}, {"sha": "5d24673ae751c4a0eac10b2e9a63748e476d7e01", "filename": "src/libcollections/trie/set.rs", "status": "removed", "additions": 0, "deletions": 972, "changes": 972, "blob_url": "https://github.com/rust-lang/rust/blob/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=99d6956c3bdb290b9fd539c5dc15a2b502da5e7a", "patch": "@@ -1,972 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// FIXME(conventions): implement bounded iterators\n-// FIXME(conventions): replace each_reverse by making iter DoubleEnded\n-// FIXME(conventions): implement iter_mut and into_iter\n-\n-use core::prelude::*;\n-\n-use core::default::Default;\n-use core::fmt;\n-use core::fmt::Show;\n-use core::iter::Peekable;\n-use std::hash::Hash;\n-\n-use trie_map::{TrieMap, Entries};\n-\n-/// A set implemented as a radix trie.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::collections::TrieSet;\n-///\n-/// let mut set = TrieSet::new();\n-/// set.insert(6);\n-/// set.insert(28);\n-/// set.insert(6);\n-///\n-/// assert_eq!(set.len(), 2);\n-///\n-/// if !set.contains(&3) {\n-///     println!(\"3 is not in the set\");\n-/// }\n-///\n-/// // Print contents in order\n-/// for x in set.iter() {\n-///     println!(\"{}\", x);\n-/// }\n-///\n-/// set.remove(&6);\n-/// assert_eq!(set.len(), 1);\n-///\n-/// set.clear();\n-/// assert!(set.is_empty());\n-/// ```\n-#[deriving(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct TrieSet {\n-    map: TrieMap<()>\n-}\n-\n-impl Show for TrieSet {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n-\n-        for (i, x) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", x));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-#[stable]\n-impl Default for TrieSet {\n-    #[inline]\n-    #[stable]\n-    fn default() -> TrieSet { TrieSet::new() }\n-}\n-\n-impl TrieSet {\n-    /// Creates an empty TrieSet.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    /// let mut set = TrieSet::new();\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn new() -> TrieSet {\n-        TrieSet{map: TrieMap::new()}\n-    }\n-\n-    /// Visits all values in reverse order. Aborts traversal when `f` returns `false`.\n-    /// Returns `true` if `f` returns `true` for all elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [1, 2, 3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// let mut vec = Vec::new();\n-    /// assert_eq!(true, set.each_reverse(|&x| { vec.push(x); true }));\n-    /// assert_eq!(vec, vec![5, 4, 3, 2, 1]);\n-    ///\n-    /// // Stop when we reach 3\n-    /// let mut vec = Vec::new();\n-    /// assert_eq!(false, set.each_reverse(|&x| { vec.push(x); x != 3 }));\n-    /// assert_eq!(vec, vec![5, 4, 3]);\n-    /// ```\n-    #[inline]\n-    pub fn each_reverse(&self, f: |&uint| -> bool) -> bool {\n-        self.map.each_reverse(|k, _| f(k))\n-    }\n-\n-    /// Gets an iterator over the values in the set, in sorted order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut set = TrieSet::new();\n-    /// set.insert(3);\n-    /// set.insert(2);\n-    /// set.insert(1);\n-    /// set.insert(2);\n-    ///\n-    /// // Print 1, 2, 3\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> SetItems<'a> {\n-        SetItems{iter: self.map.iter()}\n-    }\n-\n-    /// Gets an iterator pointing to the first value that is not less than `val`.\n-    /// If all values in the set are less than `val` an empty iterator is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.lower_bound(4).next(), Some(4));\n-    /// assert_eq!(set.lower_bound(5).next(), Some(6));\n-    /// assert_eq!(set.lower_bound(10).next(), None);\n-    /// ```\n-    pub fn lower_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n-        SetItems{iter: self.map.lower_bound(val)}\n-    }\n-\n-    /// Gets an iterator pointing to the first value that key is greater than `val`.\n-    /// If all values in the set are less than or equal to `val` an empty iterator is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.upper_bound(4).next(), Some(6));\n-    /// assert_eq!(set.upper_bound(5).next(), Some(6));\n-    /// assert_eq!(set.upper_bound(10).next(), None);\n-    /// ```\n-    pub fn upper_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n-        SetItems{iter: self.map.upper_bound(val)}\n-    }\n-\n-    /// Visits the values representing the difference, in ascending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TrieSet = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Can be seen as `a - b`.\n-    /// for x in a.difference(&b) {\n-    ///     println!(\"{}\", x); // Print 1 then 2\n-    /// }\n-    ///\n-    /// let diff1: TrieSet = a.difference(&b).collect();\n-    /// assert_eq!(diff1, [1, 2].iter().map(|&x| x).collect());\n-    ///\n-    /// // Note that difference is not symmetric,\n-    /// // and `b - a` means something else:\n-    /// let diff2: TrieSet = b.difference(&a).collect();\n-    /// assert_eq!(diff2, [4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn difference<'a>(&'a self, other: &'a TrieSet) -> DifferenceItems<'a> {\n-        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the symmetric difference, in ascending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TrieSet = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 2, 4, 5 in ascending order.\n-    /// for x in a.symmetric_difference(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff1: TrieSet = a.symmetric_difference(&b).collect();\n-    /// let diff2: TrieSet = b.symmetric_difference(&a).collect();\n-    ///\n-    /// assert_eq!(diff1, diff2);\n-    /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle.\"]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a TrieSet) -> SymDifferenceItems<'a> {\n-        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the intersection, in ascending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TrieSet = [2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 2, 3 in ascending order.\n-    /// for x in a.intersection(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: TrieSet = a.intersection(&b).collect();\n-    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn intersection<'a>(&'a self, other: &'a TrieSet) -> IntersectionItems<'a> {\n-        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the union, in ascending order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TrieSet = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 2, 3, 4, 5 in ascending order.\n-    /// for x in a.union(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: TrieSet = a.union(&b).collect();\n-    /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn union<'a>(&'a self, other: &'a TrieSet) -> UnionItems<'a> {\n-        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Return the number of elements in the set\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut v = TrieSet::new();\n-    /// assert_eq!(v.len(), 0);\n-    /// v.insert(1);\n-    /// assert_eq!(v.len(), 1);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn len(&self) -> uint { self.map.len() }\n-\n-    /// Returns true if the set contains no elements\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut v = TrieSet::new();\n-    /// assert!(v.is_empty());\n-    /// v.insert(1);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clears the set, removing all values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut v = TrieSet::new();\n-    /// v.insert(1);\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn clear(&mut self) { self.map.clear() }\n-\n-    /// Returns `true` if the set contains a value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.contains(&1), true);\n-    /// assert_eq!(set.contains(&4), false);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains(&self, value: &uint) -> bool {\n-        self.map.contains_key(value)\n-    }\n-\n-    /// Returns `true` if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut b: TrieSet = TrieSet::new();\n-    ///\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(4);\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(1);\n-    /// assert_eq!(a.is_disjoint(&b), false);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_disjoint(&self, other: &TrieSet) -> bool {\n-        self.iter().all(|v| !other.contains(&v))\n-    }\n-\n-    /// Returns `true` if the set is a subset of another.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let sup: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut set: TrieSet = TrieSet::new();\n-    ///\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(4);\n-    /// assert_eq!(set.is_subset(&sup), false);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_subset(&self, other: &TrieSet) -> bool {\n-        self.iter().all(|v| other.contains(&v))\n-    }\n-\n-    /// Returns `true` if the set is a superset of another.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let sub: TrieSet = [1, 2].iter().map(|&x| x).collect();\n-    /// let mut set: TrieSet = TrieSet::new();\n-    ///\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(0);\n-    /// set.insert(1);\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_superset(&sub), true);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_superset(&self, other: &TrieSet) -> bool {\n-        other.is_subset(self)\n-    }\n-\n-    /// Adds a value to the set. Returns `true` if the value was not already\n-    /// present in the set.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut set = TrieSet::new();\n-    ///\n-    /// assert_eq!(set.insert(2), true);\n-    /// assert_eq!(set.insert(2), false);\n-    /// assert_eq!(set.len(), 1);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn insert(&mut self, value: uint) -> bool {\n-        self.map.insert(value, ()).is_none()\n-    }\n-\n-    /// Removes a value from the set. Returns `true` if the value was\n-    /// present in the set.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut set = TrieSet::new();\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.remove(&2), true);\n-    /// assert_eq!(set.remove(&2), false);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, value: &uint) -> bool {\n-        self.map.remove(value).is_some()\n-    }\n-}\n-\n-impl FromIterator<uint> for TrieSet {\n-    fn from_iter<Iter: Iterator<uint>>(iter: Iter) -> TrieSet {\n-        let mut set = TrieSet::new();\n-        set.extend(iter);\n-        set\n-    }\n-}\n-\n-impl Extend<uint> for TrieSet {\n-    fn extend<Iter: Iterator<uint>>(&mut self, mut iter: Iter) {\n-        for elem in iter {\n-            self.insert(elem);\n-        }\n-    }\n-}\n-\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-impl BitOr<TrieSet, TrieSet> for TrieSet {\n-    /// Returns the union of `self` and `rhs` as a new `TrieSet`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TrieSet = a | b;\n-    /// let v: Vec<uint> = set.iter().collect();\n-    /// assert_eq!(v, vec![1u, 2, 3, 4, 5]);\n-    /// ```\n-    fn bitor(&self, rhs: &TrieSet) -> TrieSet {\n-        self.union(rhs).collect()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-impl<'a, 'b> BitOr<&'b TrieSet, TrieSet> for &'a TrieSet {\n-    /// Returns the union of `self` and `rhs` as a new `TrieSet`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TrieSet = &a | &b;\n-    /// let v: Vec<uint> = set.iter().collect();\n-    /// assert_eq!(v, vec![1u, 2, 3, 4, 5]);\n-    /// ```\n-    fn bitor(self, rhs: &TrieSet) -> TrieSet {\n-        self.union(rhs).collect()\n-    }\n-}\n-\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-impl BitAnd<TrieSet, TrieSet> for TrieSet {\n-    /// Returns the intersection of `self` and `rhs` as a new `TrieSet`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TrieSet = vec![2, 3, 4].into_iter().collect();\n-    ///\n-    /// let set: TrieSet = a & b;\n-    /// let v: Vec<uint> = set.iter().collect();\n-    /// assert_eq!(v, vec![2u, 3]);\n-    /// ```\n-    fn bitand(&self, rhs: &TrieSet) -> TrieSet {\n-        self.intersection(rhs).collect()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-impl<'a, 'b> BitAnd<&'b TrieSet, TrieSet> for &'a TrieSet {\n-    /// Returns the intersection of `self` and `rhs` as a new `TrieSet`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TrieSet = vec![2, 3, 4].into_iter().collect();\n-    ///\n-    /// let set: TrieSet = &a & &b;\n-    /// let v: Vec<uint> = set.iter().collect();\n-    /// assert_eq!(v, vec![2u, 3]);\n-    /// ```\n-    fn bitand(self, rhs: &TrieSet) -> TrieSet {\n-        self.intersection(rhs).collect()\n-    }\n-}\n-\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-impl BitXor<TrieSet, TrieSet> for TrieSet {\n-    /// Returns the symmetric difference of `self` and `rhs` as a new `TrieSet`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TrieSet = a ^ b;\n-    /// let v: Vec<uint> = set.iter().collect();\n-    /// assert_eq!(v, vec![1u, 2, 4, 5]);\n-    /// ```\n-    fn bitxor(&self, rhs: &TrieSet) -> TrieSet {\n-        self.symmetric_difference(rhs).collect()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-impl<'a, 'b> BitXor<&'b TrieSet, TrieSet> for &'a TrieSet {\n-    /// Returns the symmetric difference of `self` and `rhs` as a new `TrieSet`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TrieSet = &a ^ &b;\n-    /// let v: Vec<uint> = set.iter().collect();\n-    /// assert_eq!(v, vec![1u, 2, 4, 5]);\n-    /// ```\n-    fn bitxor(self, rhs: &TrieSet) -> TrieSet {\n-        self.symmetric_difference(rhs).collect()\n-    }\n-}\n-\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-impl Sub<TrieSet, TrieSet> for TrieSet {\n-    /// Returns the difference of `self` and `rhs` as a new `TrieSet`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TrieSet = a - b;\n-    /// let v: Vec<uint> = set.iter().collect();\n-    /// assert_eq!(v, vec![1u, 2]);\n-    /// ```\n-    fn sub(&self, rhs: &TrieSet) -> TrieSet {\n-        self.difference(rhs).collect()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-impl<'a, 'b> Sub<&'b TrieSet, TrieSet> for &'a TrieSet {\n-    /// Returns the difference of `self` and `rhs` as a new `TrieSet`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set: TrieSet = &a - &b;\n-    /// let v: Vec<uint> = set.iter().collect();\n-    /// assert_eq!(v, vec![1u, 2]);\n-    /// ```\n-    fn sub(self, rhs: &TrieSet) -> TrieSet {\n-        self.difference(rhs).collect()\n-    }\n-}\n-\n-/// A forward iterator over a set.\n-pub struct SetItems<'a> {\n-    iter: Entries<'a, ()>\n-}\n-\n-/// An iterator producing elements in the set difference (in-order).\n-pub struct DifferenceItems<'a> {\n-    a: Peekable<uint, SetItems<'a>>,\n-    b: Peekable<uint, SetItems<'a>>,\n-}\n-\n-/// An iterator producing elements in the set symmetric difference (in-order).\n-pub struct SymDifferenceItems<'a> {\n-    a: Peekable<uint, SetItems<'a>>,\n-    b: Peekable<uint, SetItems<'a>>,\n-}\n-\n-/// An iterator producing elements in the set intersection (in-order).\n-pub struct IntersectionItems<'a> {\n-    a: Peekable<uint, SetItems<'a>>,\n-    b: Peekable<uint, SetItems<'a>>,\n-}\n-\n-/// An iterator producing elements in the set union (in-order).\n-pub struct UnionItems<'a> {\n-    a: Peekable<uint, SetItems<'a>>,\n-    b: Peekable<uint, SetItems<'a>>,\n-}\n-\n-/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt(x: Option<&uint>, y: Option<&uint>, short: Ordering, long: Ordering) -> Ordering {\n-    match (x, y) {\n-        (None    , _       ) => short,\n-        (_       , None    ) => long,\n-        (Some(x1), Some(y1)) => x1.cmp(y1),\n-    }\n-}\n-\n-impl<'a> Iterator<uint> for SetItems<'a> {\n-    fn next(&mut self) -> Option<uint> {\n-        self.iter.next().map(|(key, _)| key)\n-    }\n-\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<'a> Iterator<uint> for DifferenceItems<'a> {\n-    fn next(&mut self) -> Option<uint> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.a.next(); self.b.next(); }\n-                Greater => { self.b.next(); }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> Iterator<uint> for SymDifferenceItems<'a> {\n-    fn next(&mut self) -> Option<uint> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less => return self.a.next(),\n-                Equal => { self.a.next(); self.b.next(); }\n-                Greater => return self.b.next(),\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> Iterator<uint> for IntersectionItems<'a> {\n-    fn next(&mut self) -> Option<uint> {\n-        loop {\n-            let o_cmp = match (self.a.peek(), self.b.peek()) {\n-                (None    , _       ) => None,\n-                (_       , None    ) => None,\n-                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n-            };\n-            match o_cmp {\n-                None          => return None,\n-                Some(Less)    => { self.a.next(); }\n-                Some(Equal)   => { self.b.next(); return self.a.next() }\n-                Some(Greater) => { self.b.next(); }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> Iterator<uint> for UnionItems<'a> {\n-    fn next(&mut self) -> Option<uint> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.b.next(); return self.a.next() }\n-                Greater => return self.b.next(),\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use std::prelude::*;\n-    use std::uint;\n-    use vec::Vec;\n-\n-    use super::TrieSet;\n-\n-    #[test]\n-    fn test_sane_chunk() {\n-        let x = 1;\n-        let y = 1 << (uint::BITS - 1);\n-\n-        let mut trie = TrieSet::new();\n-\n-        assert!(trie.insert(x));\n-        assert!(trie.insert(y));\n-\n-        assert_eq!(trie.len(), 2);\n-\n-        let expected = [x, y];\n-\n-        for (i, x) in trie.iter().enumerate() {\n-            assert_eq!(expected[i], x);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = vec![9u, 8, 7, 6, 5, 4, 3, 2, 1];\n-\n-        let set: TrieSet = xs.iter().map(|&x| x).collect();\n-\n-        for x in xs.iter() {\n-            assert!(set.contains(x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut set = TrieSet::new();\n-        let empty = TrieSet::new();\n-\n-        set.insert(1);\n-        set.insert(2);\n-\n-        let set_str = format!(\"{}\", set);\n-\n-        assert!(set_str == \"{1, 2}\");\n-        assert_eq!(format!(\"{}\", empty), \"{}\");\n-    }\n-\n-    #[test]\n-    fn test_clone() {\n-        let mut a = TrieSet::new();\n-\n-        a.insert(1);\n-        a.insert(2);\n-        a.insert(3);\n-\n-        assert!(a.clone() == a);\n-    }\n-\n-    #[test]\n-    fn test_lt() {\n-        let mut a = TrieSet::new();\n-        let mut b = TrieSet::new();\n-\n-        assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2u));\n-        assert!(a < b);\n-        assert!(a.insert(3u));\n-        assert!(!(a < b) && b < a);\n-        assert!(b.insert(1));\n-        assert!(b < a);\n-        assert!(a.insert(0));\n-        assert!(a < b);\n-        assert!(a.insert(6));\n-        assert!(a < b && !(b < a));\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = TrieSet::new();\n-        let mut b = TrieSet::new();\n-\n-        assert!(a <= b && a >= b);\n-        assert!(a.insert(1u));\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        assert!(b.insert(2u));\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n-    }\n-\n-    struct Counter<'a, 'b> {\n-        i: &'a mut uint,\n-        expected: &'b [uint],\n-    }\n-\n-    impl<'a, 'b> FnMut(uint) -> bool for Counter<'a, 'b> {\n-        extern \"rust-call\" fn call_mut(&mut self, (x,): (uint,)) -> bool {\n-            assert_eq!(x, self.expected[*self.i]);\n-            *self.i += 1;\n-            true\n-        }\n-    }\n-\n-    fn check<F>(a: &[uint], b: &[uint], expected: &[uint], f: F) where\n-        // FIXME Replace `Counter` with `Box<FnMut(&uint) -> bool>`\n-        F: FnOnce(&TrieSet, &TrieSet, Counter) -> bool,\n-    {\n-        let mut set_a = TrieSet::new();\n-        let mut set_b = TrieSet::new();\n-\n-        for x in a.iter() { assert!(set_a.insert(*x)) }\n-        for y in b.iter() { assert!(set_b.insert(*y)) }\n-\n-        let mut i = 0;\n-        f(&set_a, &set_b, Counter { i: &mut i, expected: expected });\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_intersection() {\n-        fn check_intersection(a: &[uint], b: &[uint], expected: &[uint]) {\n-            check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n-        }\n-\n-        check_intersection(&[], &[], &[]);\n-        check_intersection(&[1, 2, 3], &[], &[]);\n-        check_intersection(&[], &[1, 2, 3], &[]);\n-        check_intersection(&[2], &[1, 2, 3], &[2]);\n-        check_intersection(&[1, 2, 3], &[2], &[2]);\n-        check_intersection(&[11, 1, 3, 77, 103, 5],\n-                           &[2, 11, 77, 5, 3],\n-                           &[3, 5, 11, 77]);\n-    }\n-\n-    #[test]\n-    fn test_difference() {\n-        fn check_difference(a: &[uint], b: &[uint], expected: &[uint]) {\n-            check(a, b, expected, |x, y, f| x.difference(y).all(f))\n-        }\n-\n-        check_difference(&[], &[], &[]);\n-        check_difference(&[1, 12], &[], &[1, 12]);\n-        check_difference(&[], &[1, 2, 3, 9], &[]);\n-        check_difference(&[1, 3, 5, 9, 11],\n-                         &[3, 9],\n-                         &[1, 5, 11]);\n-        check_difference(&[11, 22, 33, 40, 42],\n-                         &[14, 23, 34, 38, 39, 50],\n-                         &[11, 22, 33, 40, 42]);\n-    }\n-\n-    #[test]\n-    fn test_symmetric_difference() {\n-        fn check_symmetric_difference(a: &[uint], b: &[uint], expected: &[uint]) {\n-            check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n-        }\n-\n-        check_symmetric_difference(&[], &[], &[]);\n-        check_symmetric_difference(&[1, 2, 3], &[2], &[1, 3]);\n-        check_symmetric_difference(&[2], &[1, 2, 3], &[1, 3]);\n-        check_symmetric_difference(&[1, 3, 5, 9, 11],\n-                                   &[3, 9, 14, 22],\n-                                   &[1, 5, 11, 14, 22]);\n-    }\n-\n-    #[test]\n-    fn test_union() {\n-        fn check_union(a: &[uint], b: &[uint], expected: &[uint]) {\n-            check(a, b, expected, |x, y, f| x.union(y).all(f))\n-        }\n-\n-        check_union(&[], &[], &[]);\n-        check_union(&[1, 2, 3], &[2], &[1, 2, 3]);\n-        check_union(&[2], &[1, 2, 3], &[1, 2, 3]);\n-        check_union(&[1, 3, 5, 9, 11, 16, 19, 24],\n-                    &[1, 5, 9, 13, 19],\n-                    &[1, 3, 5, 9, 11, 13, 16, 19, 24]);\n-    }\n-\n-    #[test]\n-    fn test_bit_or() {\n-        let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-        let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n-\n-        let set: TrieSet = &a | &b;\n-        let v: Vec<uint> = set.iter().collect();\n-        assert_eq!(v, vec![1u, 2, 3, 4, 5]);\n-    }\n-\n-    #[test]\n-    fn test_bit_and() {\n-        let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-        let b: TrieSet = vec![2, 3, 4].into_iter().collect();\n-\n-        let set: TrieSet = &a & &b;\n-        let v: Vec<uint> = set.iter().collect();\n-        assert_eq!(v, vec![2u, 3]);\n-    }\n-\n-    #[test]\n-    fn test_bit_xor() {\n-        let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-        let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n-\n-        let set: TrieSet = &a ^ &b;\n-        let v: Vec<uint> = set.iter().collect();\n-        assert_eq!(v, vec![1u, 2, 4, 5]);\n-    }\n-\n-    #[test]\n-    fn test_sub() {\n-        let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n-        let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n-\n-        let set: TrieSet = &a - &b;\n-        let v: Vec<uint> = set.iter().collect();\n-        assert_eq!(v, vec![1u, 2]);\n-    }\n-}"}, {"sha": "90e9973c3f302f9d8ae4c2882f7ea3a114ef9917", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -36,6 +36,7 @@ extern crate rustc_llvm;\n extern crate rustc_back;\n extern crate serialize;\n extern crate rbml;\n+extern crate collections;\n #[phase(plugin, link)] extern crate log;\n #[phase(plugin, link)] extern crate syntax;\n "}, {"sha": "0ad07bed7d923869651d707349f557e18476bbcd", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -77,7 +77,7 @@ use std::hash::{Hash, sip, Writer};\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n-use std::collections::enum_set::{EnumSet, CLike};\n+use collections::enum_set::{EnumSet, CLike};\n use std::collections::hash_map::{HashMap, Occupied, Vacant};\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, DUMMY_NODE_ID, Ident, ItemTrait, LOCAL_CRATE};"}, {"sha": "3d51a6d6ab0772a40812af631645e6071b032481", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -472,7 +472,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     //   \"crate\": { parsed crate ... },\n     //   \"plugins\": { output of plugins ... }\n     // }\n-    let mut json = std::collections::TreeMap::new();\n+    let mut json = std::collections::BTreeMap::new();\n     json.insert(\"schema\".to_string(), Json::String(SCHEMA_VERSION.to_string()));\n     let plugins_json = res.into_iter()\n                           .filter_map(|opt| {"}, {"sha": "f2d79b133469958d48a5a3d8b3519871b5f494c0", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 10, "deletions": 68, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -15,9 +15,8 @@ use std::default::Default;\n use std::hash::{Hash, Hasher};\n \n use {Decodable, Encodable, Decoder, Encoder};\n-use std::collections::{DList, RingBuf, TreeMap, TreeSet, HashMap, HashSet,\n-                       TrieMap, TrieSet, VecMap};\n-use std::collections::enum_set::{EnumSet, CLike};\n+use std::collections::{DList, RingBuf, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n+use collections::enum_set::{EnumSet, CLike};\n \n impl<\n     E,\n@@ -78,7 +77,7 @@ impl<\n     S: Encoder<E>,\n     K: Encodable<S, E> + PartialEq + Ord,\n     V: Encodable<S, E> + PartialEq\n-> Encodable<S, E> for TreeMap<K, V> {\n+> Encodable<S, E> for BTreeMap<K, V> {\n     fn encode(&self, e: &mut S) -> Result<(), E> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n@@ -97,10 +96,10 @@ impl<\n     D: Decoder<E>,\n     K: Decodable<D, E> + PartialEq + Ord,\n     V: Decodable<D, E> + PartialEq\n-> Decodable<D, E> for TreeMap<K, V> {\n-    fn decode(d: &mut D) -> Result<TreeMap<K, V>, E> {\n+> Decodable<D, E> for BTreeMap<K, V> {\n+    fn decode(d: &mut D) -> Result<BTreeMap<K, V>, E> {\n         d.read_map(|d, len| {\n-            let mut map = TreeMap::new();\n+            let mut map = BTreeMap::new();\n             for i in range(0u, len) {\n                 let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n                 let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n@@ -115,7 +114,7 @@ impl<\n     E,\n     S: Encoder<E>,\n     T: Encodable<S, E> + PartialEq + Ord\n-> Encodable<S, E> for TreeSet<T> {\n+> Encodable<S, E> for BTreeSet<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n@@ -132,10 +131,10 @@ impl<\n     E,\n     D: Decoder<E>,\n     T: Decodable<D, E> + PartialEq + Ord\n-> Decodable<D, E> for TreeSet<T> {\n-    fn decode(d: &mut D) -> Result<TreeSet<T>, E> {\n+> Decodable<D, E> for BTreeSet<T> {\n+    fn decode(d: &mut D) -> Result<BTreeSet<T>, E> {\n         d.read_seq(|d, len| {\n-            let mut set = TreeSet::new();\n+            let mut set = BTreeSet::new();\n             for i in range(0u, len) {\n                 set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n@@ -255,63 +254,6 @@ impl<\n     }\n }\n \n-impl<\n-    E,\n-    S: Encoder<E>,\n-    V: Encodable<S, E>\n-> Encodable<S, E> for TrieMap<V> {\n-    fn encode(&self, e: &mut S) -> Result<(), E> {\n-        e.emit_map(self.len(), |e| {\n-                for (i, (key, val)) in self.iter().enumerate() {\n-                    try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n-                    try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n-                }\n-                Ok(())\n-            })\n-    }\n-}\n-\n-impl<\n-    E,\n-    D: Decoder<E>,\n-    V: Decodable<D, E>\n-> Decodable<D, E> for TrieMap<V> {\n-    fn decode(d: &mut D) -> Result<TrieMap<V>, E> {\n-        d.read_map(|d, len| {\n-            let mut map = TrieMap::new();\n-            for i in range(0u, len) {\n-                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n-                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n-                map.insert(key, val);\n-            }\n-            Ok(map)\n-        })\n-    }\n-}\n-\n-impl<E, S: Encoder<E>> Encodable<S, E> for TrieSet {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_seq(self.len(), |s| {\n-                for (i, e) in self.iter().enumerate() {\n-                    try!(s.emit_seq_elt(i, |s| e.encode(s)));\n-                }\n-                Ok(())\n-            })\n-    }\n-}\n-\n-impl<E, D: Decoder<E>> Decodable<D, E> for TrieSet {\n-    fn decode(d: &mut D) -> Result<TrieSet, E> {\n-        d.read_seq(|d, len| {\n-            let mut set = TrieSet::new();\n-            for i in range(0u, len) {\n-                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n-            }\n-            Ok(set)\n-        })\n-    }\n-}\n-\n impl<\n     E,\n     S: Encoder<E>,"}, {"sha": "6d143329b0c30869616e7b5a79fa6f23fb8fb56f", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -151,7 +151,7 @@\n //!\n //! ```rust\n //! extern crate serialize;\n-//! use std::collections::TreeMap;\n+//! use std::collections::BTreeMap;\n //! use serialize::json::{mod, Json, ToJson};\n //!\n //! // Only generate `Decodable` trait implementation\n@@ -165,7 +165,7 @@\n //! // Specify encoding method manually\n //! impl ToJson for TestStruct {\n //!     fn to_json(&self) -> Json {\n-//!         let mut d = TreeMap::new();\n+//!         let mut d = BTreeMap::new();\n //!         // All standard types implement `to_json()`, so use it\n //!         d.insert(\"data_int\".to_string(), self.data_int.to_json());\n //!         d.insert(\"data_str\".to_string(), self.data_str.to_json());\n@@ -198,7 +198,7 @@ use self::ParserState::*;\n use self::InternalStackElement::*;\n \n use std;\n-use std::collections::{HashMap, TreeMap};\n+use std::collections::{HashMap, BTreeMap};\n use std::{char, f64, fmt, io, num, str};\n use std::mem::{swap, transmute};\n use std::num::{Float, FPNaN, FPInfinite, Int};\n@@ -223,7 +223,7 @@ pub enum Json {\n }\n \n pub type Array = Vec<Json>;\n-pub type Object = TreeMap<string::String, Json>;\n+pub type Object = BTreeMap<string::String, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n #[deriving(Clone, PartialEq)]\n@@ -973,7 +973,7 @@ impl Json {\n         self.as_object().is_some()\n     }\n \n-    /// If the Json value is an Object, returns the associated TreeMap.\n+    /// If the Json value is an Object, returns the associated BTreeMap.\n     /// Returns None otherwise.\n     pub fn as_object<'a>(&'a self) -> Option<&'a Object> {\n         match self {\n@@ -1909,7 +1909,7 @@ impl<T: Iterator<char>> Builder<T> {\n     fn build_object(&mut self) -> Result<Json, BuilderError> {\n         self.bump();\n \n-        let mut values = TreeMap::new();\n+        let mut values = BTreeMap::new();\n \n         loop {\n             match self.token {\n@@ -2391,9 +2391,9 @@ impl<A: ToJson> ToJson for Vec<A> {\n     fn to_json(&self) -> Json { Json::Array(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n-impl<A: ToJson> ToJson for TreeMap<string::String, A> {\n+impl<A: ToJson> ToJson for BTreeMap<string::String, A> {\n     fn to_json(&self) -> Json {\n-        let mut d = TreeMap::new();\n+        let mut d = BTreeMap::new();\n         for (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n@@ -2403,7 +2403,7 @@ impl<A: ToJson> ToJson for TreeMap<string::String, A> {\n \n impl<A: ToJson> ToJson for HashMap<string::String, A> {\n     fn to_json(&self) -> Json {\n-        let mut d = TreeMap::new();\n+        let mut d = BTreeMap::new();\n         for (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n@@ -2451,7 +2451,7 @@ mod tests {\n     use super::{PrettyEncoder, Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n                 StackElement, Stack, Encoder, Decoder};\n     use std::{i64, u64, f32, f64, io};\n-    use std::collections::TreeMap;\n+    use std::collections::BTreeMap;\n     use std::num::Float;\n     use std::string;\n \n@@ -2501,7 +2501,7 @@ mod tests {\n     }\n \n     fn mk_object(items: &[(string::String, Json)]) -> Json {\n-        let mut d = TreeMap::new();\n+        let mut d = BTreeMap::new();\n \n         for item in items.iter() {\n             match *item {\n@@ -3075,7 +3075,7 @@ mod tests {\n     fn test_decode_map() {\n         let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n                   \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut map: TreeMap<string::String, Animal> = super::decode(s).unwrap();\n+        let mut map: BTreeMap<string::String, Animal> = super::decode(s).unwrap();\n \n         assert_eq!(map.remove(&\"a\".into_string()), Some(Dog));\n         assert_eq!(map.remove(&\"b\".into_string()), Some(Frog(\"Henry\".into_string(), 349)));\n@@ -3350,9 +3350,9 @@ mod tests {\n     #[test]\n     fn test_prettyencoder_indent_level_param() {\n         use std::str::from_utf8;\n-        use std::collections::TreeMap;\n+        use std::collections::BTreeMap;\n \n-        let mut tree = TreeMap::new();\n+        let mut tree = BTreeMap::new();\n \n         tree.insert(\"hello\".into_string(), String(\"guten tag\".into_string()));\n         tree.insert(\"goodbye\".into_string(), String(\"sayonara\".into_string()));\n@@ -3719,13 +3719,13 @@ mod tests {\n \n     #[test]\n     fn test_to_json() {\n-        use std::collections::{HashMap,TreeMap};\n+        use std::collections::{HashMap,BTreeMap};\n         use super::ToJson;\n \n         let array2 = Array(vec!(U64(1), U64(2)));\n         let array3 = Array(vec!(U64(1), U64(2), U64(3)));\n         let object = {\n-            let mut tree_map = TreeMap::new();\n+            let mut tree_map = BTreeMap::new();\n             tree_map.insert(\"a\".into_string(), U64(1));\n             tree_map.insert(\"b\".into_string(), U64(2));\n             Object(tree_map)\n@@ -3758,7 +3758,7 @@ mod tests {\n         assert_eq!((&[1u, 2, 3]).to_json(), array3);\n         assert_eq!((vec![1u, 2]).to_json(), array2);\n         assert_eq!(vec!(1u, 2, 3).to_json(), array3);\n-        let mut tree_map = TreeMap::new();\n+        let mut tree_map = BTreeMap::new();\n         tree_map.insert(\"a\".into_string(), 1u);\n         tree_map.insert(\"b\".into_string(), 2);\n         assert_eq!(tree_map.to_json(), object);"}, {"sha": "e700d102fefda92ced017bf4fe73843ffd33922c", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -33,6 +33,8 @@ extern crate test;\n #[phase(plugin, link)]\n extern crate log;\n \n+extern crate collections;\n+\n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable,\n                           DecoderHelpers, EncoderHelpers};\n "}, {"sha": "6caa2f7b4da6a06f249f002a113bc6fdd71a6be7", "filename": "src/libstd/collections/lru_cache.rs", "status": "removed", "additions": 0, "deletions": 471, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d6956c3bdb290b9fd539c5dc15a2b502da5e7a/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=99d6956c3bdb290b9fd539c5dc15a2b502da5e7a", "patch": "@@ -1,471 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-//! A cache that holds a limited number of key-value pairs. When the\n-//! capacity of the cache is exceeded, the least-recently-used\n-//! (where \"used\" means a look-up or putting the pair into the cache)\n-//! pair is automatically removed.\n-//!\n-//! # Example\n-//!\n-//! ```rust\n-//! use std::collections::LruCache;\n-//!\n-//! let mut cache: LruCache<int, int> = LruCache::new(2);\n-//! cache.insert(1, 10);\n-//! cache.insert(2, 20);\n-//! cache.insert(3, 30);\n-//! assert!(cache.get(&1).is_none());\n-//! assert_eq!(*cache.get(&2).unwrap(), 20);\n-//! assert_eq!(*cache.get(&3).unwrap(), 30);\n-//!\n-//! cache.insert(2, 22);\n-//! assert_eq!(*cache.get(&2).unwrap(), 22);\n-//!\n-//! cache.insert(6, 60);\n-//! assert!(cache.get(&3).is_none());\n-//!\n-//! cache.set_capacity(1);\n-//! assert!(cache.get(&2).is_none());\n-//! ```\n-\n-use cmp::{PartialEq, Eq};\n-use collections::HashMap;\n-use fmt;\n-use hash::Hash;\n-use iter::{range, Iterator, Extend};\n-use mem;\n-use ops::Drop;\n-use option::Option;\n-use option::Option::{Some, None};\n-use boxed::Box;\n-use ptr;\n-use result::Result::{Ok, Err};\n-\n-// FIXME(conventions): implement iterators?\n-// FIXME(conventions): implement indexing?\n-\n-struct KeyRef<K> { k: *const K }\n-\n-struct LruEntry<K, V> {\n-    next: *mut LruEntry<K, V>,\n-    prev: *mut LruEntry<K, V>,\n-    key: K,\n-    value: V,\n-}\n-\n-/// An LRU Cache.\n-pub struct LruCache<K, V> {\n-    map: HashMap<KeyRef<K>, Box<LruEntry<K, V>>>,\n-    max_size: uint,\n-    head: *mut LruEntry<K, V>,\n-}\n-\n-impl<S, K: Hash<S>> Hash<S> for KeyRef<K> {\n-    fn hash(&self, state: &mut S) {\n-        unsafe { (*self.k).hash(state) }\n-    }\n-}\n-\n-impl<K: PartialEq> PartialEq for KeyRef<K> {\n-    fn eq(&self, other: &KeyRef<K>) -> bool {\n-        unsafe{ (*self.k).eq(&*other.k) }\n-    }\n-}\n-\n-impl<K: Eq> Eq for KeyRef<K> {}\n-\n-impl<K, V> LruEntry<K, V> {\n-    fn new(k: K, v: V) -> LruEntry<K, V> {\n-        LruEntry {\n-            key: k,\n-            value: v,\n-            next: ptr::null_mut(),\n-            prev: ptr::null_mut(),\n-        }\n-    }\n-}\n-\n-impl<K: Hash + Eq, V> LruCache<K, V> {\n-    /// Create an LRU Cache that holds at most `capacity` items.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::LruCache;\n-    /// let mut cache: LruCache<int, &str> = LruCache::new(10);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn new(capacity: uint) -> LruCache<K, V> {\n-        let cache = LruCache {\n-            map: HashMap::new(),\n-            max_size: capacity,\n-            head: unsafe{ mem::transmute(box mem::uninitialized::<LruEntry<K, V>>()) },\n-        };\n-        unsafe {\n-            (*cache.head).next = cache.head;\n-            (*cache.head).prev = cache.head;\n-        }\n-        return cache;\n-    }\n-\n-    /// Deprecated: Replaced with `insert`.\n-    #[deprecated = \"Replaced with `insert`\"]\n-    pub fn put(&mut self, k: K, v: V) {\n-        self.insert(k, v);\n-    }\n-\n-    /// Inserts a key-value pair into the cache. If the key already existed, the old value is\n-    /// returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::LruCache;\n-    /// let mut cache = LruCache::new(2);\n-    ///\n-    /// cache.insert(1i, \"a\");\n-    /// cache.insert(2, \"b\");\n-    /// assert_eq!(cache.get(&1), Some(&\"a\"));\n-    /// assert_eq!(cache.get(&2), Some(&\"b\"));\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n-        let (node_ptr, node_opt, old_val) = match self.map.get_mut(&KeyRef{k: &k}) {\n-            Some(node) => {\n-                let old_val = mem::replace(&mut node.value, v);\n-                let node_ptr: *mut LruEntry<K, V> = &mut **node;\n-                (node_ptr, None, Some(old_val))\n-            }\n-            None => {\n-                let mut node = box LruEntry::new(k, v);\n-                let node_ptr: *mut LruEntry<K, V> = &mut *node;\n-                (node_ptr, Some(node), None)\n-            }\n-        };\n-        match node_opt {\n-            None => {\n-                // Existing node, just update LRU position\n-                self.detach(node_ptr);\n-                self.attach(node_ptr);\n-            }\n-            Some(node) => {\n-                let keyref = unsafe { &(*node_ptr).key };\n-                self.map.insert(KeyRef{k: keyref}, node);\n-                self.attach(node_ptr);\n-                if self.len() > self.capacity() {\n-                    self.remove_lru();\n-                }\n-            }\n-        }\n-        old_val\n-    }\n-\n-    /// Return a value corresponding to the key in the cache.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::LruCache;\n-    /// let mut cache = LruCache::new(2);\n-    ///\n-    /// cache.insert(1i, \"a\");\n-    /// cache.insert(2, \"b\");\n-    /// cache.insert(2, \"c\");\n-    /// cache.insert(3, \"d\");\n-    ///\n-    /// assert_eq!(cache.get(&1), None);\n-    /// assert_eq!(cache.get(&2), Some(&\"c\"));\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get(&mut self, k: &K) -> Option<&V> {\n-        let (value, node_ptr_opt) = match self.map.get_mut(&KeyRef{k: k}) {\n-            None => (None, None),\n-            Some(node) => {\n-                let node_ptr: *mut LruEntry<K, V> = &mut **node;\n-                (Some(unsafe { &(*node_ptr).value }), Some(node_ptr))\n-            }\n-        };\n-        match node_ptr_opt {\n-            None => (),\n-            Some(node_ptr) => {\n-                self.detach(node_ptr);\n-                self.attach(node_ptr);\n-            }\n-        }\n-        return value;\n-    }\n-\n-    /// Deprecated: Renamed to `remove`.\n-    #[deprecated = \"Renamed to `remove`\"]\n-    pub fn pop(&mut self, k: &K) -> Option<V> {\n-        self.remove(k)\n-    }\n-\n-    /// Remove and return a value corresponding to the key from the cache.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::LruCache;\n-    /// let mut cache = LruCache::new(2);\n-    ///\n-    /// cache.insert(2i, \"a\");\n-    ///\n-    /// assert_eq!(cache.remove(&1), None);\n-    /// assert_eq!(cache.remove(&2), Some(\"a\"));\n-    /// assert_eq!(cache.remove(&2), None);\n-    /// assert_eq!(cache.len(), 0);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, k: &K) -> Option<V> {\n-        match self.map.remove(&KeyRef{k: k}) {\n-            None => None,\n-            Some(lru_entry) => Some(lru_entry.value)\n-        }\n-    }\n-\n-    /// Return the maximum number of key-value pairs the cache can hold.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::LruCache;\n-    /// let mut cache: LruCache<int, &str> = LruCache::new(2);\n-    /// assert_eq!(cache.capacity(), 2);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn capacity(&self) -> uint {\n-        self.max_size\n-    }\n-\n-    /// Deprecated: Renamed to `set_capacity`.\n-    #[deprecated = \"Renamed to `set_capacity`\"]\n-    pub fn change_capacity(&mut self, capacity: uint) {\n-        self.set_capacity(capacity)\n-    }\n-\n-    /// Change the number of key-value pairs the cache can hold. Remove\n-    /// least-recently-used key-value pairs if necessary.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::LruCache;\n-    /// let mut cache = LruCache::new(2);\n-    ///\n-    /// cache.insert(1i, \"a\");\n-    /// cache.insert(2, \"b\");\n-    /// cache.insert(3, \"c\");\n-    ///\n-    /// assert_eq!(cache.get(&1), None);\n-    /// assert_eq!(cache.get(&2), Some(&\"b\"));\n-    /// assert_eq!(cache.get(&3), Some(&\"c\"));\n-    ///\n-    /// cache.set_capacity(3);\n-    /// cache.insert(1i, \"a\");\n-    /// cache.insert(2, \"b\");\n-    ///\n-    /// assert_eq!(cache.get(&1), Some(&\"a\"));\n-    /// assert_eq!(cache.get(&2), Some(&\"b\"));\n-    /// assert_eq!(cache.get(&3), Some(&\"c\"));\n-    ///\n-    /// cache.set_capacity(1);\n-    ///\n-    /// assert_eq!(cache.get(&1), None);\n-    /// assert_eq!(cache.get(&2), None);\n-    /// assert_eq!(cache.get(&3), Some(&\"c\"));\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn set_capacity(&mut self, capacity: uint) {\n-        for _ in range(capacity, self.len()) {\n-            self.remove_lru();\n-        }\n-        self.max_size = capacity;\n-    }\n-\n-    #[inline]\n-    fn remove_lru(&mut self) {\n-        if self.len() > 0 {\n-            let lru = unsafe { (*self.head).prev };\n-            self.detach(lru);\n-            self.map.remove(&KeyRef{k: unsafe { &(*lru).key }});\n-        }\n-    }\n-\n-    #[inline]\n-    fn detach(&mut self, node: *mut LruEntry<K, V>) {\n-        unsafe {\n-            (*(*node).prev).next = (*node).next;\n-            (*(*node).next).prev = (*node).prev;\n-        }\n-    }\n-\n-    #[inline]\n-    fn attach(&mut self, node: *mut LruEntry<K, V>) {\n-        unsafe {\n-            (*node).next = (*self.head).next;\n-            (*node).prev = self.head;\n-            (*self.head).next = node;\n-            (*(*node).next).prev = node;\n-        }\n-    }\n-\n-    /// Return the number of key-value pairs in the cache.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn len(&self) -> uint { self.map.len() }\n-\n-    /// Returns whether the cache is currently empty.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clear the cache of all key-value pairs.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn clear(&mut self) { self.map.clear(); }\n-\n-}\n-\n-impl<K: Hash + Eq, V> Extend<(K, V)> for LruCache<K, V> {\n-    fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) {\n-        for (k, v) in iter{\n-            self.insert(k, v);\n-        }\n-    }\n-}\n-\n-impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n-    /// Return a string that lists the key-value pairs from most-recently\n-    /// used to least-recently used.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n-        let mut cur = self.head;\n-        for i in range(0, self.len()) {\n-            if i > 0 { try!(write!(f, \", \")) }\n-            unsafe {\n-                cur = (*cur).next;\n-                try!(write!(f, \"{}\", (*cur).key));\n-            }\n-            try!(write!(f, \": \"));\n-            unsafe {\n-                try!(write!(f, \"{}\", (*cur).value));\n-            }\n-        }\n-        write!(f, r\"}}\")\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<K, V> Drop for LruCache<K, V> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let node: Box<LruEntry<K, V>> = mem::transmute(self.head);\n-            // Prevent compiler from trying to drop the un-initialized field in the sigil node.\n-            let box internal_node = node;\n-            let LruEntry { next: _, prev: _, key: k, value: v } = internal_node;\n-            mem::forget(k);\n-            mem::forget(v);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::LruCache;\n-\n-    fn assert_opt_eq<V: PartialEq>(opt: Option<&V>, v: V) {\n-        assert!(opt.is_some());\n-        assert!(opt.unwrap() == &v);\n-    }\n-\n-    #[test]\n-    fn test_put_and_get() {\n-        let mut cache: LruCache<int, int> = LruCache::new(2);\n-        cache.insert(1, 10);\n-        cache.insert(2, 20);\n-        assert_opt_eq(cache.get(&1), 10);\n-        assert_opt_eq(cache.get(&2), 20);\n-        assert_eq!(cache.len(), 2);\n-    }\n-\n-    #[test]\n-    fn test_put_update() {\n-        let mut cache: LruCache<String, Vec<u8>> = LruCache::new(1);\n-        cache.insert(\"1\".to_string(), vec![10, 10]);\n-        cache.insert(\"1\".to_string(), vec![10, 19]);\n-        assert_opt_eq(cache.get(&\"1\".to_string()), vec![10, 19]);\n-        assert_eq!(cache.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_expire_lru() {\n-        let mut cache: LruCache<String, String> = LruCache::new(2);\n-        cache.insert(\"foo1\".to_string(), \"bar1\".to_string());\n-        cache.insert(\"foo2\".to_string(), \"bar2\".to_string());\n-        cache.insert(\"foo3\".to_string(), \"bar3\".to_string());\n-        assert!(cache.get(&\"foo1\".to_string()).is_none());\n-        cache.insert(\"foo2\".to_string(), \"bar2update\".to_string());\n-        cache.insert(\"foo4\".to_string(), \"bar4\".to_string());\n-        assert!(cache.get(&\"foo3\".to_string()).is_none());\n-    }\n-\n-    #[test]\n-    fn test_pop() {\n-        let mut cache: LruCache<int, int> = LruCache::new(2);\n-        cache.insert(1, 10);\n-        cache.insert(2, 20);\n-        assert_eq!(cache.len(), 2);\n-        let opt1 = cache.remove(&1);\n-        assert!(opt1.is_some());\n-        assert_eq!(opt1.unwrap(), 10);\n-        assert!(cache.get(&1).is_none());\n-        assert_eq!(cache.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_change_capacity() {\n-        let mut cache: LruCache<int, int> = LruCache::new(2);\n-        assert_eq!(cache.capacity(), 2);\n-        cache.insert(1, 10);\n-        cache.insert(2, 20);\n-        cache.set_capacity(1);\n-        assert!(cache.get(&1).is_none());\n-        assert_eq!(cache.capacity(), 1);\n-    }\n-\n-    #[test]\n-    fn test_to_string() {\n-        let mut cache: LruCache<int, int> = LruCache::new(3);\n-        cache.insert(1, 10);\n-        cache.insert(2, 20);\n-        cache.insert(3, 30);\n-        assert_eq!(cache.to_string(), \"{3: 30, 2: 20, 1: 10}\");\n-        cache.insert(2, 22);\n-        assert_eq!(cache.to_string(), \"{2: 22, 3: 30, 1: 10}\");\n-        cache.insert(6, 60);\n-        assert_eq!(cache.to_string(), \"{6: 60, 2: 22, 3: 30}\");\n-        cache.get(&3);\n-        assert_eq!(cache.to_string(), \"{3: 30, 6: 60, 2: 22}\");\n-        cache.set_capacity(2);\n-        assert_eq!(cache.to_string(), \"{3: 30, 6: 60}\");\n-    }\n-\n-    #[test]\n-    fn test_clear() {\n-        let mut cache: LruCache<int, int> = LruCache::new(2);\n-        cache.insert(1, 10);\n-        cache.insert(2, 20);\n-        cache.clear();\n-        assert!(cache.get(&1).is_none());\n-        assert!(cache.get(&2).is_none());\n-        assert_eq!(cache.to_string(), \"{}\");\n-    }\n-}"}, {"sha": "0d44e6d869ab1efd4358a1f2a6cff9ea88ab8e8d", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -24,8 +24,8 @@\n //! Rust's collections can be grouped into four major categories:\n //!\n //! * Sequences: `Vec`, `RingBuf`, `DList`, `BitV`\n-//! * Maps: `HashMap`, `BTreeMap`, `TreeMap`, `TrieMap`, `VecMap`, `LruCache`\n-//! * Sets: `HashSet`, `BTreeSet`, `TreeSet`, `TrieSet`, `BitVSet`, `EnumSet`\n+//! * Maps: `HashMap`, `BTreeMap`, `VecMap`\n+//! * Sets: `HashSet`, `BTreeSet`, `BitVSet`\n //! * Misc: `BinaryHeap`\n //!\n //! # When Should You Use Which Collection?\n@@ -64,16 +64,6 @@\n //! * You want to be able to get all of the entries in order on-demand.\n //! * You want a sorted map.\n //!\n-//! ### Use a `TreeMap` when:\n-//! * You want a `BTreeMap`, but can't tolerate inconsistent performance.\n-//! * You want a `BTreeMap`, but have *very large* keys or values.\n-//! * You want a `BTreeMap`, but have keys that are expensive to compare.\n-//! * You want a `BTreeMap`, but you accept arbitrary untrusted inputs.\n-//!\n-//! ### Use a `TrieMap` when:\n-//! * You want a `HashMap`, but with many potentially large `uint` keys.\n-//! * You want a `BTreeMap`, but with potentially large `uint` keys.\n-//!\n //! ### Use a `VecMap` when:\n //! * You want a `HashMap` but with known to be small `uint` keys.\n //! * You want a `BTreeMap`, but with known to be small `uint` keys.\n@@ -90,18 +80,11 @@\n //! ### Use a `BitVSet` when:\n //! * You want a `VecSet`.\n //!\n-//! ### Use an `EnumSet` when:\n-//! * You want a C-like enum, stored in a single `uint`.\n-//!\n //! ### Use a `BinaryHeap` when:\n //! * You want to store a bunch of elements, but only ever want to process the \"biggest\"\n //! or \"most important\" one at any given time.\n //! * You want a priority queue.\n //!\n-//! ### Use an `LruCache` when:\n-//! * You want a cache that discards infrequently used items when it becomes full.\n-//! * You want a least-recently-used cache.\n-//!\n //! # Correct and Efficient Usage of Collections\n //!\n //! Of course, knowing which collection is the right one for the job doesn't instantly\n@@ -329,15 +312,21 @@\n #![experimental]\n \n pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n-pub use core_collections::{DList, EnumSet, RingBuf};\n-pub use core_collections::{TreeMap, TreeSet, TrieMap, TrieSet, VecMap};\n+pub use core_collections::{DList, RingBuf, VecMap};\n \n-pub use core_collections::{binary_heap, bitv, bitv_set, btree_map, btree_set, dlist, enum_set};\n-pub use core_collections::{ring_buf, tree_map, tree_set, trie_map, trie_set, vec_map};\n+/// Deprecated: Moved to collect-rs: https://github.com/Gankro/collect-rs/\n+#[deprecated = \"Moved to collect-rs: https://github.com/Gankro/collect-rs/\"]\n+pub use core_collections::EnumSet;\n+\n+pub use core_collections::{binary_heap, bitv, bitv_set, btree_map, btree_set};\n+pub use core_collections::{dlist, ring_buf, vec_map};\n+\n+/// Deprecated: Moved to collect-rs: https://github.com/Gankro/collect-rs/\n+#[deprecated = \"Moved to collect-rs: https://github.com/Gankro/collect-rs/\"]\n+pub use core_collections::enum_set;\n \n pub use self::hash_map::HashMap;\n pub use self::hash_set::HashSet;\n-pub use self::lru_cache::LruCache;\n \n mod hash;\n \n@@ -350,5 +339,3 @@ pub mod hash_set {\n     //! A hashset\n     pub use super::hash::set::*;\n }\n-\n-pub mod lru_cache;"}, {"sha": "d786409e895b299cd0cea252ae3cf5769cf8e924", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -49,7 +49,7 @@ use self::NamePadding::*;\n use self::OutputLocation::*;\n \n use std::any::{Any, AnyRefExt};\n-use std::collections::TreeMap;\n+use std::collections::BTreeMap;\n use stats::Stats;\n use getopts::{OptGroup, optflag, optopt};\n use regex::Regex;\n@@ -230,7 +230,7 @@ impl Metric {\n }\n \n #[deriving(PartialEq)]\n-pub struct MetricMap(TreeMap<String,Metric>);\n+pub struct MetricMap(BTreeMap<String,Metric>);\n \n impl Clone for MetricMap {\n     fn clone(&self) -> MetricMap {\n@@ -251,7 +251,7 @@ pub enum MetricChange {\n \n impl Copy for MetricChange {}\n \n-pub type MetricDiff = TreeMap<String,MetricChange>;\n+pub type MetricDiff = BTreeMap<String,MetricChange>;\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n@@ -1191,7 +1191,7 @@ fn calc_result(desc: &TestDesc, task_result: Result<(), Box<Any+Send>>) -> TestR\n impl MetricMap {\n \n     pub fn new() -> MetricMap {\n-        MetricMap(TreeMap::new())\n+        MetricMap(BTreeMap::new())\n     }\n \n     /// Load MetricDiff from a file.\n@@ -1227,7 +1227,7 @@ impl MetricMap {\n     /// map.\n     pub fn compare_to_old(&self, old: &MetricMap,\n                           noise_pct: Option<f64>) -> MetricDiff {\n-        let mut diff : MetricDiff = TreeMap::new();\n+        let mut diff : MetricDiff = BTreeMap::new();\n         let MetricMap(ref selfmap) = *self;\n         let MetricMap(ref old) = *old;\n         for (k, vold) in old.iter() {"}, {"sha": "60331dfb5505a72cf8bb76f304fe9a2ad0fef066", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(unboxed_closures)]\n \n-use std::collections::{TrieMap, TreeMap, HashMap, HashSet};\n+use std::collections::{BTreeMap, HashMap, HashSet};\n use std::os;\n use std::rand::{Rng, IsaacRng, SeedableRng};\n use std::time::Duration;\n@@ -26,7 +26,7 @@ trait MutableMap {\n     fn find(&self, k: &uint) -> Option<&uint>;\n }\n \n-impl MutableMap for TreeMap<uint, uint> {\n+impl MutableMap for BTreeMap<uint, uint> {\n     fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n     fn remove(&mut self, k: &uint) -> bool { self.remove(k).is_some() }\n     fn find(&self, k: &uint) -> Option<&uint> { self.get(k) }\n@@ -36,11 +36,6 @@ impl MutableMap for HashMap<uint, uint> {\n     fn remove(&mut self, k: &uint) -> bool { self.remove(k).is_some() }\n     fn find(&self, k: &uint) -> Option<&uint> { self.get(k) }\n }\n-impl MutableMap for TrieMap<uint> {\n-    fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n-    fn remove(&mut self, k: &uint) -> bool { self.remove(k).is_some() }\n-    fn find(&self, k: &uint) -> Option<&uint> { self.get(k) }\n-}\n \n fn ascending<M: MutableMap>(map: &mut M, n_keys: uint) {\n     println!(\" Ascending integers:\");\n@@ -134,21 +129,21 @@ fn main() {\n     println!(\"{} keys\", n_keys);\n \n     // FIXME: #9970\n-    println!(\"{}\", \"\\nTreeMap:\");\n+    println!(\"{}\", \"\\nBTreeMap:\");\n \n     {\n-        let mut map: TreeMap<uint,uint> = TreeMap::new();\n+        let mut map: BTreeMap<uint,uint> = BTreeMap::new();\n         ascending(&mut map, n_keys);\n     }\n \n     {\n-        let mut map: TreeMap<uint,uint> = TreeMap::new();\n+        let mut map: BTreeMap<uint,uint> = BTreeMap::new();\n         descending(&mut map, n_keys);\n     }\n \n     {\n         println!(\" Random integers:\");\n-        let mut map: TreeMap<uint,uint> = TreeMap::new();\n+        let mut map: BTreeMap<uint,uint> = BTreeMap::new();\n         vector(&mut map, n_keys, rand.as_slice());\n     }\n \n@@ -170,23 +165,4 @@ fn main() {\n         let mut map: HashMap<uint,uint> = HashMap::new();\n         vector(&mut map, n_keys, rand.as_slice());\n     }\n-\n-    // FIXME: #9970\n-    println!(\"{}\", \"\\nTrieMap:\");\n-\n-    {\n-        let mut map: TrieMap<uint> = TrieMap::new();\n-        ascending(&mut map, n_keys);\n-    }\n-\n-    {\n-        let mut map: TrieMap<uint> = TrieMap::new();\n-        descending(&mut map, n_keys);\n-    }\n-\n-    {\n-        println!(\" Random integers:\");\n-        let mut map: TrieMap<uint> = TrieMap::new();\n-        vector(&mut map, n_keys, rand.as_slice());\n-    }\n }"}, {"sha": "49f5c7751d9a0c5c1bb8ce85439ee0301074c6d2", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -17,7 +17,7 @@ extern crate rand;\n \n use std::collections::BitvSet;\n use std::collections::HashSet;\n-use std::collections::TreeSet;\n+use std::collections::BTreeSet;\n use std::hash::Hash;\n use std::os;\n use std::time::Duration;\n@@ -48,7 +48,7 @@ impl<T: Hash + Eq> MutableSet<T> for HashSet<T> {\n     fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n     fn contains(&self, k: &T) -> bool { self.contains(k) }\n }\n-impl<T: Ord> MutableSet<T> for TreeSet<T> {\n+impl<T: Ord> MutableSet<T> for BTreeSet<T> {\n     fn insert(&mut self, k: T) { self.insert(k); }\n     fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n     fn contains(&self, k: &T) -> bool { self.contains(k) }\n@@ -207,14 +207,14 @@ fn main() {\n         let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n         let mut results = empty_results();\n         results.bench_int(&mut rng, num_keys, max, || {\n-            let s: TreeSet<uint> = TreeSet::new();\n+            let s: BTreeSet<uint> = BTreeSet::new();\n             s\n         });\n         results.bench_str(&mut rng, num_keys, || {\n-            let s: TreeSet<String> = TreeSet::new();\n+            let s: BTreeSet<String> = BTreeSet::new();\n             s\n         });\n-        write_results(\"collections::TreeSet\", &results);\n+        write_results(\"collections::BTreeSet\", &results);\n     }\n \n     {"}, {"sha": "ade312da21b7036853db790473cb1fe6bb088631", "filename": "src/test/run-pass/issue-16278.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Ftest%2Frun-pass%2Fissue-16278.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Ftest%2Frun-pass%2Fissue-16278.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16278.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -12,9 +12,9 @@\n \n // this file has some special \\r\\n endings (use xxd to see them)\n \n-fn main() {assert_eq!(b\"\", b\"\\\r\n+fn main() {assert_eq!(b\"\", b\"\\\n                                    \");\n-assert_eq!(b\"\\n\", b\"\r\n+assert_eq!(b\"\\n\", b\"\n \");\n }\n "}, {"sha": "24480d85272059a405ddeed726c2c8dcdd623c64", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/840de072085df360733c48396224e9966e2dc72c/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840de072085df360733c48396224e9966e2dc72c/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=840de072085df360733c48396224e9966e2dc72c", "patch": "@@ -10,13 +10,13 @@\n \n extern crate collections;\n \n-use self::collections::TreeMap;\n+use self::collections::BTreeMap;\n use std::option::Option::Some;\n use std::str::SendStr;\n use std::string::ToString;\n \n pub fn main() {\n-    let mut map: TreeMap<SendStr, uint> = TreeMap::new();\n+    let mut map: BTreeMap<SendStr, uint> = BTreeMap::new();\n     assert!(map.insert(\"foo\".into_cow(), 42).is_none());\n     assert!(map.insert(\"foo\".to_string().into_cow(), 42).is_some());\n     assert!(map.insert(\"foo\".into_cow(), 42).is_some());"}]}