{"sha": "17ed06aad2542f59221f40b7c23a3b7ef771af1c", "node_id": "C_kwDOAAsO6NoAKDE3ZWQwNmFhZDI1NDJmNTkyMjFmNDBiN2MyM2EzYjdlZjc3MWFmMWM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-06T22:00:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-06T22:00:25Z"}, "message": "Rollup merge of #109960 - thomcc:symlink-junction-buffer-overrun, r=ChrisDenton\n\nFix buffer overrun in bootstrap and (test-only) symlink_junction\n\nI don't think these can be hit in practice, due to their inputs being valid paths. It's also not security-sensitive code, but just... bad vibes.\n\nI think this is still not really the right way to do this (in terms of path correctness), but is no worse than it was.\n\nr? `@ChrisDenton`", "tree": {"sha": "19795dbee2c32fe7742cb16ccb363228f35145ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19795dbee2c32fe7742cb16ccb363228f35145ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17ed06aad2542f59221f40b7c23a3b7ef771af1c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkL0D5CRBK7hj4Ov3rIwAAZYwIAFXcFSfQvFQOaOTpUDXbFd70\nLcAqyjWmPhNY4bVTDngF/zmP7UT3R3lEQ6AAZZor0FXB6AekraQEprZHT+rR/UyQ\ndWjkUyJXVTwBmdKF9hthQzBfkvADWf7h+XN9cK4YLyfCDBZsqS3KzoS6d6I5MSI6\neafV4381SO36gm8WCS+Dr7Ei5ppO1m6tOIK2vsAfHeK4wBqe51G5ak7V8kbMn2nL\nTpBCnWxiyGL5SrMX6yvxk0NbekfPP+VYfRZ6Z0KBThWDBzQhx8I8/6743+on8dIN\nUMwq+hmSikSEpGiyQFf6k/wKqDIizZJuICHLrtQFNvP/ZafbXEO07pkvB0OXf6o=\n=cVcH\n-----END PGP SIGNATURE-----\n", "payload": "tree 19795dbee2c32fe7742cb16ccb363228f35145ce\nparent e63586f386ea32c658974a0174da4cf9ac4cf385\nparent 42e38e89498ec4690479b268066ad1ca58917aec\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1680818425 +0200\ncommitter GitHub <noreply@github.com> 1680818425 +0200\n\nRollup merge of #109960 - thomcc:symlink-junction-buffer-overrun, r=ChrisDenton\n\nFix buffer overrun in bootstrap and (test-only) symlink_junction\n\nI don't think these can be hit in practice, due to their inputs being valid paths. It's also not security-sensitive code, but just... bad vibes.\n\nI think this is still not really the right way to do this (in terms of path correctness), but is no worse than it was.\n\nr? `@ChrisDenton`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17ed06aad2542f59221f40b7c23a3b7ef771af1c", "html_url": "https://github.com/rust-lang/rust/commit/17ed06aad2542f59221f40b7c23a3b7ef771af1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17ed06aad2542f59221f40b7c23a3b7ef771af1c/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e63586f386ea32c658974a0174da4cf9ac4cf385", "url": "https://api.github.com/repos/rust-lang/rust/commits/e63586f386ea32c658974a0174da4cf9ac4cf385", "html_url": "https://github.com/rust-lang/rust/commit/e63586f386ea32c658974a0174da4cf9ac4cf385"}, {"sha": "42e38e89498ec4690479b268066ad1ca58917aec", "url": "https://api.github.com/repos/rust-lang/rust/commits/42e38e89498ec4690479b268066ad1ca58917aec", "html_url": "https://github.com/rust-lang/rust/commit/42e38e89498ec4690479b268066ad1ca58917aec"}], "stats": {"total": 147, "additions": 40, "deletions": 107}, "files": [{"sha": "956db577d537182cd4fbd37e4329a2eb4528b7c8", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/17ed06aad2542f59221f40b7c23a3b7ef771af1c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ed06aad2542f59221f40b7c23a3b7ef771af1c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=17ed06aad2542f59221f40b7c23a3b7ef771af1c", "patch": "@@ -1403,24 +1403,40 @@ fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n     opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT | c::FILE_FLAG_BACKUP_SEMANTICS);\n     let f = File::open(junction, &opts)?;\n     let h = f.as_inner().as_raw_handle();\n-\n     unsafe {\n         let mut data = Align8([MaybeUninit::<u8>::uninit(); c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n         let data_ptr = data.0.as_mut_ptr();\n+        let data_end = data_ptr.add(c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE);\n         let db = data_ptr.cast::<c::REPARSE_MOUNTPOINT_DATA_BUFFER>();\n         // Zero the header to ensure it's fully initialized, including reserved parameters.\n         *db = mem::zeroed();\n-        let buf = ptr::addr_of_mut!((*db).ReparseTarget).cast::<c::WCHAR>();\n-        let mut i = 0;\n+        let reparse_target_slice = {\n+            let buf_start = ptr::addr_of_mut!((*db).ReparseTarget).cast::<c::WCHAR>();\n+            // Compute offset in bytes and then divide so that we round down\n+            // rather than hit any UB (admittedly this arithmetic should work\n+            // out so that this isn't necessary)\n+            let buf_len_bytes = usize::try_from(data_end.byte_offset_from(buf_start)).unwrap();\n+            let buf_len_wchars = buf_len_bytes / core::mem::size_of::<c::WCHAR>();\n+            core::slice::from_raw_parts_mut(buf_start, buf_len_wchars)\n+        };\n+\n         // FIXME: this conversion is very hacky\n-        let v = br\"\\??\\\";\n-        let v = v.iter().map(|x| *x as u16);\n-        for c in v.chain(original.as_os_str().encode_wide()) {\n-            *buf.add(i) = c;\n+        let iter = br\"\\??\\\"\n+            .iter()\n+            .map(|x| *x as u16)\n+            .chain(original.as_os_str().encode_wide())\n+            .chain(core::iter::once(0));\n+        let mut i = 0;\n+        for c in iter {\n+            if i >= reparse_target_slice.len() {\n+                return Err(crate::io::const_io_error!(\n+                    crate::io::ErrorKind::InvalidFilename,\n+                    \"Input filename is too long\"\n+                ));\n+            }\n+            reparse_target_slice[i] = c;\n             i += 1;\n         }\n-        *buf.add(i) = 0;\n-        i += 1;\n         (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n         (*db).ReparseTargetMaximumLength = (i * 2) as c::WORD;\n         (*db).ReparseTargetLength = ((i - 1) * 2) as c::WORD;"}, {"sha": "a158d1f718e2caa494ae889bdf4e0cb9d14d34d3", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/17ed06aad2542f59221f40b7c23a3b7ef771af1c/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/17ed06aad2542f59221f40b7c23a3b7ef771af1c/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=17ed06aad2542f59221f40b7c23a3b7ef771af1c", "patch": "@@ -45,6 +45,7 @@ dependencies = [\n  \"hex\",\n  \"ignore\",\n  \"is-terminal\",\n+ \"junction\",\n  \"libc\",\n  \"object\",\n  \"once_cell\",\n@@ -349,6 +350,16 @@ version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n \n+[[package]]\n+name = \"junction\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ca39ef0d69b18e6a2fd14c2f0a1d593200f4a4ed949b240b5917ab51fac754cb\"\n+dependencies = [\n+ \"scopeguard\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\""}, {"sha": "eeda6d7c121f7c97c358bb5fa17a6c9871fd4372", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/17ed06aad2542f59221f40b7c23a3b7ef771af1c/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/17ed06aad2542f59221f40b7c23a3b7ef771af1c/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=17ed06aad2542f59221f40b7c23a3b7ef771af1c", "patch": "@@ -61,6 +61,9 @@ sysinfo = { version = \"0.26.0\", optional = true }\n [target.'cfg(not(target_os = \"solaris\"))'.dependencies]\n fd-lock = \"3.0.8\"\n \n+[target.'cfg(windows)'.dependencies.junction]\n+version = \"1.0.0\"\n+\n [target.'cfg(windows)'.dependencies.windows]\n version = \"0.46.0\"\n features = ["}, {"sha": "2e1adbf63bb102bcf85dd103101a046e758ba074", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 98, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/17ed06aad2542f59221f40b7c23a3b7ef771af1c/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ed06aad2542f59221f40b7c23a3b7ef771af1c/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=17ed06aad2542f59221f40b7c23a3b7ef771af1c", "patch": "@@ -146,106 +146,9 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n         fs::symlink(src, dest)\n     }\n \n-    // Creating a directory junction on windows involves dealing with reparse\n-    // points and the DeviceIoControl function, and this code is a skeleton of\n-    // what can be found here:\n-    //\n-    // http://www.flexhex.com/docs/articles/hard-links.phtml\n     #[cfg(windows)]\n     fn symlink_dir_inner(target: &Path, junction: &Path) -> io::Result<()> {\n-        use std::ffi::OsStr;\n-        use std::os::windows::ffi::OsStrExt;\n-\n-        use windows::{\n-            core::PCWSTR,\n-            Win32::Foundation::{CloseHandle, HANDLE},\n-            Win32::Storage::FileSystem::{\n-                CreateFileW, FILE_ACCESS_FLAGS, FILE_FLAG_BACKUP_SEMANTICS,\n-                FILE_FLAG_OPEN_REPARSE_POINT, FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE,\n-                MAXIMUM_REPARSE_DATA_BUFFER_SIZE, OPEN_EXISTING,\n-            },\n-            Win32::System::Ioctl::FSCTL_SET_REPARSE_POINT,\n-            Win32::System::SystemServices::{GENERIC_WRITE, IO_REPARSE_TAG_MOUNT_POINT},\n-            Win32::System::IO::DeviceIoControl,\n-        };\n-\n-        #[allow(non_snake_case)]\n-        #[repr(C)]\n-        struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n-            ReparseTag: u32,\n-            ReparseDataLength: u32,\n-            Reserved: u16,\n-            ReparseTargetLength: u16,\n-            ReparseTargetMaximumLength: u16,\n-            Reserved1: u16,\n-            ReparseTarget: u16,\n-        }\n-\n-        fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n-            Ok(s.as_ref().encode_wide().chain(Some(0)).collect())\n-        }\n-\n-        // We're using low-level APIs to create the junction, and these are more\n-        // picky about paths. For example, forward slashes cannot be used as a\n-        // path separator, so we should try to canonicalize the path first.\n-        let target = fs::canonicalize(target)?;\n-\n-        fs::create_dir(junction)?;\n-\n-        let path = to_u16s(junction)?;\n-\n-        let h = unsafe {\n-            CreateFileW(\n-                PCWSTR(path.as_ptr()),\n-                FILE_ACCESS_FLAGS(GENERIC_WRITE),\n-                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n-                None,\n-                OPEN_EXISTING,\n-                FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,\n-                HANDLE::default(),\n-            )\n-        }\n-        .map_err(|_| io::Error::last_os_error())?;\n-\n-        unsafe {\n-            #[repr(C, align(8))]\n-            struct Align8<T>(T);\n-            let mut data = Align8([0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize]);\n-            let db = data.0.as_mut_ptr() as *mut REPARSE_MOUNTPOINT_DATA_BUFFER;\n-            let buf = core::ptr::addr_of_mut!((*db).ReparseTarget) as *mut u16;\n-            let mut i = 0;\n-            // FIXME: this conversion is very hacky\n-            let v = br\"\\??\\\";\n-            let v = v.iter().map(|x| *x as u16);\n-            for c in v.chain(target.as_os_str().encode_wide().skip(4)) {\n-                *buf.offset(i) = c;\n-                i += 1;\n-            }\n-            *buf.offset(i) = 0;\n-            i += 1;\n-\n-            (*db).ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n-            (*db).ReparseTargetMaximumLength = (i * 2) as u16;\n-            (*db).ReparseTargetLength = ((i - 1) * 2) as u16;\n-            (*db).ReparseDataLength = ((*db).ReparseTargetLength + 12) as u32;\n-\n-            let mut ret = 0u32;\n-            DeviceIoControl(\n-                h,\n-                FSCTL_SET_REPARSE_POINT,\n-                Some(db.cast()),\n-                (*db).ReparseDataLength + 8,\n-                None,\n-                0,\n-                Some(&mut ret),\n-                None,\n-            )\n-            .ok()\n-            .map_err(|_| io::Error::last_os_error())?;\n-        }\n-\n-        unsafe { CloseHandle(h) };\n-        Ok(())\n+        junction::create(&target, &junction)\n     }\n }\n "}]}