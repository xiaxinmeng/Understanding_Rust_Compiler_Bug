{"sha": "1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZmYzYjRkZmM5YzhmZDI2MjFjOWU2ZmM2ZmEzYThhODcwZDdjMTY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-07T16:17:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-07T16:17:14Z"}, "message": "Merge #9144\n\n9144: Extend convert_tuple_struct_to_named_struct to also apply to enum tuple variants r=matklad a=joshuawarner32\n\nThis is largely copied and adapted from the existing `convert_tuple_struct_to_named_struct` code.\r\n\r\nNot sure if maybe some of this code can/should be shared between those two assists - but the differences are significant enough to make it at least seem like a non-trivial refactor.\n\nCo-authored-by: Joshua Warner <joshuawarner32@gmail.com>", "tree": {"sha": "03fb86b2da0c28eff006c6d47f01dbd1218411cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03fb86b2da0c28eff006c6d47f01dbd1218411cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgvkaKCRBK7hj4Ov3rIwAAFIgIAGnuqo4xbEgDVkgE+johnW6b\ncgrdVERuTiSnPQNJ7pdNLoRbPXZ809+ZZM/IJ69WRRlNJ5UnfWFthlklQI6xdUk2\nWBq8Rl8PA4cJBxWCk1vbJiezCUvUn6JxeGH1gfsubv/hVOdnd+PAO/gU7qWrVY+e\nUQWctrIMoqxJjMRtGuuRsHqMw07xaNshPE7Rm/jXZ8PwHocDECFKBVuQZVDnJsRx\nbRKVMS76lI+RAUrwj88MylhmJql/gwA1zLEQYIoG4J22b3yFAAErHWYz85E48CNv\n5hXQcpJXhQMAwS3e6lyOziZICcSbk/9+3AlQmiDYxufOktYi1HziF8JH06g+n5U=\n=sbhl\n-----END PGP SIGNATURE-----\n", "payload": "tree 03fb86b2da0c28eff006c6d47f01dbd1218411cc\nparent 7a807068c4d797592327aa22ad20d4696c0b1c2b\nparent 9b74dd0c04651eb22e743c6ffc91c11bb3df87d8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623082634 +0000\ncommitter GitHub <noreply@github.com> 1623082634 +0000\n\nMerge #9144\n\n9144: Extend convert_tuple_struct_to_named_struct to also apply to enum tuple variants r=matklad a=joshuawarner32\n\nThis is largely copied and adapted from the existing `convert_tuple_struct_to_named_struct` code.\r\n\r\nNot sure if maybe some of this code can/should be shared between those two assists - but the differences are significant enough to make it at least seem like a non-trivial refactor.\n\nCo-authored-by: Joshua Warner <joshuawarner32@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16", "html_url": "https://github.com/rust-lang/rust/commit/1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a807068c4d797592327aa22ad20d4696c0b1c2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a807068c4d797592327aa22ad20d4696c0b1c2b", "html_url": "https://github.com/rust-lang/rust/commit/7a807068c4d797592327aa22ad20d4696c0b1c2b"}, {"sha": "9b74dd0c04651eb22e743c6ffc91c11bb3df87d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b74dd0c04651eb22e743c6ffc91c11bb3df87d8", "html_url": "https://github.com/rust-lang/rust/commit/9b74dd0c04651eb22e743c6ffc91c11bb3df87d8"}], "stats": {"total": 352, "additions": 337, "deletions": 15}, "files": [{"sha": "fc5a17f052ccbb4593989cd9d204fb8d12d83a92", "filename": "crates/ide_assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 337, "deletions": 15, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16", "patch": "@@ -1,3 +1,4 @@\n+use either::Either;\n use ide_db::defs::{Definition, NameRefClass};\n use syntax::{\n     ast::{self, AstNode, GenericParamsOwner, VisibilityOwner},\n@@ -8,7 +9,7 @@ use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind,\n \n // Assist: convert_tuple_struct_to_named_struct\n //\n-// Converts tuple struct to struct with named fields.\n+// Converts tuple struct to struct with named fields, and analogously for tuple enum variants.\n //\n // ```\n // struct Point$0(f32, f32);\n@@ -49,14 +50,21 @@ pub(crate) fn convert_tuple_struct_to_named_struct(\n     acc: &mut Assists,\n     ctx: &AssistContext,\n ) -> Option<()> {\n-    let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n-    let tuple_fields = match strukt.field_list()? {\n+    let strukt = ctx\n+        .find_node_at_offset::<ast::Struct>()\n+        .map(Either::Left)\n+        .or_else(|| ctx.find_node_at_offset::<ast::Variant>().map(Either::Right))?;\n+    let field_list = strukt.as_ref().either(|s| s.field_list(), |v| v.field_list())?;\n+    let tuple_fields = match field_list {\n         ast::FieldList::TupleFieldList(it) => it,\n         ast::FieldList::RecordFieldList(_) => return None,\n     };\n-    let strukt_def = ctx.sema.to_def(&strukt)?;\n+    let strukt_def = match &strukt {\n+        Either::Left(s) => Either::Left(ctx.sema.to_def(s)?),\n+        Either::Right(v) => Either::Right(ctx.sema.to_def(v)?),\n+    };\n+    let target = strukt.as_ref().either(|s| s.syntax(), |v| v.syntax()).text_range();\n \n-    let target = strukt.syntax().text_range();\n     acc.add(\n         AssistId(\"convert_tuple_struct_to_named_struct\", AssistKind::RefactorRewrite),\n         \"Convert to named struct\",\n@@ -73,7 +81,7 @@ pub(crate) fn convert_tuple_struct_to_named_struct(\n fn edit_struct_def(\n     ctx: &AssistContext,\n     edit: &mut AssistBuilder,\n-    strukt: &ast::Struct,\n+    strukt: &Either<ast::Struct, ast::Variant>,\n     tuple_fields: ast::TupleFieldList,\n     names: Vec<ast::Name>,\n ) {\n@@ -86,27 +94,40 @@ fn edit_struct_def(\n \n     edit.edit_file(ctx.frange.file_id);\n \n-    if let Some(w) = strukt.where_clause() {\n-        edit.delete(w.syntax().text_range());\n-        edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_newline().text());\n-        edit.insert(tuple_fields_text_range.start(), w.syntax().text());\n-        edit.insert(tuple_fields_text_range.start(), \",\");\n-        edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_newline().text());\n+    if let Either::Left(strukt) = strukt {\n+        if let Some(w) = strukt.where_clause() {\n+            edit.delete(w.syntax().text_range());\n+            edit.insert(\n+                tuple_fields_text_range.start(),\n+                ast::make::tokens::single_newline().text(),\n+            );\n+            edit.insert(tuple_fields_text_range.start(), w.syntax().text());\n+            edit.insert(tuple_fields_text_range.start(), \",\");\n+            edit.insert(\n+                tuple_fields_text_range.start(),\n+                ast::make::tokens::single_newline().text(),\n+            );\n+        } else {\n+            edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_space().text());\n+        }\n+        strukt.semicolon_token().map(|t| edit.delete(t.text_range()));\n     } else {\n         edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_space().text());\n     }\n \n     edit.replace(tuple_fields_text_range, record_fields.to_string());\n-    strukt.semicolon_token().map(|t| edit.delete(t.text_range()));\n }\n \n fn edit_struct_references(\n     ctx: &AssistContext,\n     edit: &mut AssistBuilder,\n-    strukt: hir::Struct,\n+    strukt: Either<hir::Struct, hir::Variant>,\n     names: &[ast::Name],\n ) {\n-    let strukt_def = Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(strukt)));\n+    let strukt_def = match strukt {\n+        Either::Left(s) => Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(s))),\n+        Either::Right(v) => Definition::ModuleDef(hir::ModuleDef::Variant(v)),\n+    };\n     let usages = strukt_def.usages(&ctx.sema).include_self_refs().all();\n \n     let edit_node = |edit: &mut AssistBuilder, node: SyntaxNode| -> Option<()> {\n@@ -510,6 +531,307 @@ where\n     T: Display,\n { field1: T }\n \n+\"#,\n+        );\n+    }\n+    #[test]\n+    fn not_applicable_other_than_tuple_variant() {\n+        check_assist_not_applicable(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"enum Enum { Variant$0 { value: usize } };\"#,\n+        );\n+        check_assist_not_applicable(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"enum Enum { Variant$0 }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_simple_variant() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+enum A {\n+    $0Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_referenced_via_self_kw() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+enum A {\n+    $0Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_destructured_variant() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+enum A {\n+    $0Variant(usize),\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant(first) = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant(first) = self;\n+        first\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant { field1: first } = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant { field1: first } = self;\n+        first\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_wrapped_references() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+enum Inner {\n+    $0Variant(usize),\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant { field1: usize },\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant { field1: 42 })\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant { field1: x }) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    $0Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    Variant { field1: Inner },\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant { field1: Inner::Variant(42) }\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant { field1: Inner::Variant(x) } = self;\n+        x\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_multi_file_references() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant(Inner);\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant { field1: Inner };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_directly_used_variant() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant(Inner);\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant { field1: Inner };\n+}\n \"#,\n         );\n     }"}]}