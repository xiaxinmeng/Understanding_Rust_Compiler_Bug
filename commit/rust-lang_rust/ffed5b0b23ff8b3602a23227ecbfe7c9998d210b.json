{"sha": "ffed5b0b23ff8b3602a23227ecbfe7c9998d210b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZWQ1YjBiMjNmZjhiMzYwMmEyMzIyN2VjYmZlN2M5OTk4ZDIxMGI=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-25T16:26:20Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-25T16:28:05Z"}, "message": "loops: use a whitelist for the \"x.iter() -> &x\" lint (fixes #236)", "tree": {"sha": "8faf605c615419452bf6fd04426872d0bcbcad52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8faf605c615419452bf6fd04426872d0bcbcad52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffed5b0b23ff8b3602a23227ecbfe7c9998d210b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffed5b0b23ff8b3602a23227ecbfe7c9998d210b", "html_url": "https://github.com/rust-lang/rust/commit/ffed5b0b23ff8b3602a23227ecbfe7c9998d210b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffed5b0b23ff8b3602a23227ecbfe7c9998d210b/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53d72faca4222dbe03523cff74bf86318a206342", "url": "https://api.github.com/repos/rust-lang/rust/commits/53d72faca4222dbe03523cff74bf86318a206342", "html_url": "https://github.com/rust-lang/rust/commit/53d72faca4222dbe03523cff74bf86318a206342"}], "stats": {"total": 75, "additions": 61, "deletions": 14}, "files": [{"sha": "d12393dba688833e4b5d25e9657f3051069f53f1", "filename": "src/loops.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ffed5b0b23ff8b3602a23227ecbfe7c9998d210b/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffed5b0b23ff8b3602a23227ecbfe7c9998d210b/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=ffed5b0b23ff8b3602a23227ecbfe7c9998d210b", "patch": "@@ -1,9 +1,11 @@\n use rustc::lint::*;\n use syntax::ast::*;\n use syntax::visit::{Visitor, walk_expr};\n+use rustc::middle::ty;\n use std::collections::HashSet;\n \n-use utils::{snippet, span_lint, get_parent_expr, match_trait_method};\n+use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, walk_ptrs_ty};\n+use utils::{VEC_PATH, LL_PATH};\n \n declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n                \"for-looping over a range of indices where an iterator over items would do\" }\n@@ -55,18 +57,17 @@ impl LintPass for LoopsPass {\n                 if args.len() == 1 {\n                     let method_name = method.node.name;\n                     // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n-                    if method_name == \"iter\" {\n-                        let object = snippet(cx, args[0].span, \"_\");\n-                        span_lint(cx, EXPLICIT_ITER_LOOP, expr.span, &format!(\n-                            \"it is more idiomatic to loop over `&{}` instead of `{}.iter()`\",\n-                            object, object));\n-                    } else if method_name == \"iter_mut\" {\n-                        let object = snippet(cx, args[0].span, \"_\");\n-                        span_lint(cx, EXPLICIT_ITER_LOOP, expr.span, &format!(\n-                            \"it is more idiomatic to loop over `&mut {}` instead of `{}.iter_mut()`\",\n-                            object, object));\n+                    if method_name == \"iter\" || method_name == \"iter_mut\" {\n+                        if is_ref_iterable_type(cx, &args[0]) {\n+                            let object = snippet(cx, args[0].span, \"_\");\n+                            span_lint(cx, EXPLICIT_ITER_LOOP, expr.span, &format!(\n+                                \"it is more idiomatic to loop over `&{}{}` instead of `{}.{}()`\",\n+                                if method_name == \"iter_mut\" { \"mut \" } else { \"\" },\n+                                object, object, method_name));\n+                        }\n+                    }\n                     // check for looping over Iterator::next() which is not what you want\n-                    } else if method_name == \"next\" {\n+                    else if method_name == \"next\" {\n                         if match_trait_method(cx, arg, &[\"core\", \"iter\", \"Iterator\"]) {\n                             span_lint(cx, ITER_NEXT_LOOP, expr.span,\n                                       \"you are iterating over `Iterator::next()` which is an Option; \\\n@@ -134,3 +135,26 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n         walk_expr(self, expr);\n     }\n }\n+\n+/// Return true if the type of expr is one that provides IntoIterator impls\n+/// for &T and &mut T, such as Vec.\n+fn is_ref_iterable_type(cx: &Context, e: &Expr) -> bool {\n+    let ty = walk_ptrs_ty(cx.tcx.expr_ty(e));\n+    println!(\"mt {:?} {:?}\", e, ty);\n+    is_array(ty) ||\n+        match_type(cx, ty, &VEC_PATH) ||\n+        match_type(cx, ty, &LL_PATH) ||\n+        match_type(cx, ty, &[\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"]) ||\n+        match_type(cx, ty, &[\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"]) ||\n+        match_type(cx, ty, &[\"collections\", \"vec_deque\", \"VecDeque\"]) ||\n+        match_type(cx, ty, &[\"collections\", \"binary_heap\", \"BinaryHeap\"]) ||\n+        match_type(cx, ty, &[\"collections\", \"btree\", \"map\", \"BTreeMap\"]) ||\n+        match_type(cx, ty, &[\"collections\", \"btree\", \"set\", \"BTreeSet\"])\n+}\n+\n+fn is_array(ty: ty::Ty) -> bool {\n+    match ty.sty {\n+        ty::TyArray(..) => true,\n+        _ => false\n+    }\n+}"}, {"sha": "d3ab2a586eac1aed0f2f3109b814383e1d353f2e", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ffed5b0b23ff8b3602a23227ecbfe7c9998d210b/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffed5b0b23ff8b3602a23227ecbfe7c9998d210b/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=ffed5b0b23ff8b3602a23227ecbfe7c9998d210b", "patch": "@@ -39,8 +39,7 @@ pub fn in_external_macro(cx: &Context, span: Span) -> bool {\n /// usage e.g. with\n /// `match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])`\n pub fn match_def_path(cx: &Context, def_id: DefId, path: &[&str]) -> bool {\n-    cx.tcx.with_path(def_id, |iter| iter.map(|elem| elem.name())\n-        .zip(path.iter()).all(|(nm, p)| nm == p))\n+    cx.tcx.with_path(def_id, |iter| iter.zip(path).all(|(nm, p)| nm.name() == p))\n }\n \n /// check if type is struct or enum type with given def path"}, {"sha": "eb7667b7fbd83c6e327644d2bc55a46381dc87a7", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ffed5b0b23ff8b3602a23227ecbfe7c9998d210b/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffed5b0b23ff8b3602a23227ecbfe7c9998d210b/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=ffed5b0b23ff8b3602a23227ecbfe7c9998d210b", "patch": "@@ -1,14 +1,21 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n+use std::collections::*;\n+\n struct Unrelated(Vec<u8>);\n impl Unrelated {\n     fn next(&self) -> std::slice::Iter<u8> {\n         self.0.iter()\n     }\n+\n+    fn iter(&self) -> std::slice::Iter<u8> {\n+        self.0.iter()\n+    }\n }\n \n #[deny(needless_range_loop, explicit_iter_loop, iter_next_loop)]\n+#[allow(linkedlist)]\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];\n     let vec2 = vec![1, 2, 3, 4];\n@@ -28,8 +35,25 @@ fn main() {\n     for _v in &vec { } // these are fine\n     for _v in &mut vec { } // these are fine\n \n+    for _v in [1, 2, 3].iter() { } //~ERROR it is more idiomatic to loop over `&[\n+    let ll: LinkedList<()> = LinkedList::new();\n+    for _v in ll.iter() { } //~ERROR it is more idiomatic to loop over `&ll`\n+    let vd: VecDeque<()> = VecDeque::new();\n+    for _v in vd.iter() { } //~ERROR it is more idiomatic to loop over `&vd`\n+    let bh: BinaryHeap<()> = BinaryHeap::new();\n+    for _v in bh.iter() { } //~ERROR it is more idiomatic to loop over `&bh`\n+    let hm: HashMap<(), ()> = HashMap::new();\n+    for _v in hm.iter() { } //~ERROR it is more idiomatic to loop over `&hm`\n+    let bt: BTreeMap<(), ()> = BTreeMap::new();\n+    for _v in bt.iter() { } //~ERROR it is more idiomatic to loop over `&bt`\n+    let hs: HashSet<()> = HashSet::new();\n+    for _v in hs.iter() { } //~ERROR it is more idiomatic to loop over `&hs`\n+    let bs: BTreeSet<()> = BTreeSet::new();\n+    for _v in bs.iter() { } //~ERROR it is more idiomatic to loop over `&bs`\n+\n     for _v in vec.iter().next() { } //~ERROR you are iterating over `Iterator::next()`\n \n     let u = Unrelated(vec![]);\n     for _v in u.next() { } // no error\n+    for _v in u.iter() { } // no error\n }"}]}