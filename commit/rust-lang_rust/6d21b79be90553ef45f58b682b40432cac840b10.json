{"sha": "6d21b79be90553ef45f58b682b40432cac840b10", "node_id": "C_kwDOAAsO6NoAKDZkMjFiNzliZTkwNTUzZWY0NWY1OGI2ODJiNDA0MzJjYWM4NDBiMTA", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-30T01:29:43Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:48:27Z"}, "message": "Fix `needless_borrow` suggestion when calling a trait method taking `self`", "tree": {"sha": "1e9b2c904b1c61a7bb28e88abb6787e4c1f75f71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e9b2c904b1c61a7bb28e88abb6787e4c1f75f71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d21b79be90553ef45f58b682b40432cac840b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d21b79be90553ef45f58b682b40432cac840b10", "html_url": "https://github.com/rust-lang/rust/commit/6d21b79be90553ef45f58b682b40432cac840b10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d21b79be90553ef45f58b682b40432cac840b10/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b4ba734cbd6758948cb18210437b4768e139fa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4ba734cbd6758948cb18210437b4768e139fa9", "html_url": "https://github.com/rust-lang/rust/commit/0b4ba734cbd6758948cb18210437b4768e139fa9"}], "stats": {"total": 129, "additions": 117, "deletions": 12}, "files": [{"sha": "9418c4a66b6072bdc288cae4f6efb254bb3a3cc9", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6d21b79be90553ef45f58b682b40432cac840b10/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d21b79be90553ef45f58b682b40432cac840b10/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=6d21b79be90553ef45f58b682b40432cac840b10", "patch": "@@ -11,11 +11,13 @@ use rustc_hir::{\n     ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind, Path, QPath, TraitItem,\n     TraitItemKind, TyKind, UnOp,\n };\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_trait_selection::infer::InferCtxtExt;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -165,7 +167,6 @@ struct StateData {\n \n struct DerefedBorrow {\n     count: usize,\n-    required_precedence: i8,\n     msg: &'static str,\n     position: Position,\n }\n@@ -329,19 +330,19 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             \"this expression creates a reference which is immediately dereferenced by the compiler\";\n                         let borrow_msg = \"this expression borrows a value the compiler would automatically borrow\";\n \n-                        let (required_refs, required_precedence, msg) = if position.can_auto_borrow() {\n-                            (1, PREC_POSTFIX, if deref_count == 1 { borrow_msg } else { deref_msg })\n+                        let (required_refs, msg) = if position.can_auto_borrow() {\n+                            (1, if deref_count == 1 { borrow_msg } else { deref_msg })\n                         } else if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n                             next_adjust.map(|a| &a.kind)\n                         {\n                             if matches!(mutability, AutoBorrowMutability::Mut { .. }) && !position.is_reborrow_stable()\n                             {\n-                                (3, 0, deref_msg)\n+                                (3, deref_msg)\n                             } else {\n-                                (2, 0, deref_msg)\n+                                (2, deref_msg)\n                             }\n                         } else {\n-                            (2, 0, deref_msg)\n+                            (2, deref_msg)\n                         };\n \n                         if deref_count >= required_refs {\n@@ -350,7 +351,6 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                     // One of the required refs is for the current borrow expression, the remaining ones\n                                     // can't be removed without breaking the code. See earlier comment.\n                                     count: deref_count - required_refs,\n-                                    required_precedence,\n                                     msg,\n                                     position,\n                                 }),\n@@ -601,6 +601,8 @@ fn deref_method_same_type<'tcx>(result_ty: Ty<'tcx>, arg_ty: Ty<'tcx>) -> bool {\n #[derive(Clone, Copy)]\n enum Position {\n     MethodReceiver,\n+    /// The method is defined on a reference type. e.g. `impl Foo for &T`\n+    MethodReceiverRefImpl,\n     Callee,\n     FieldAccess(Symbol),\n     Postfix,\n@@ -627,6 +629,13 @@ impl Position {\n     fn lint_explicit_deref(self) -> bool {\n         matches!(self, Self::Other | Self::DerefStable | Self::ReborrowStable)\n     }\n+\n+    fn needs_parens(self, precedence: i8) -> bool {\n+        matches!(\n+            self,\n+            Self::MethodReceiver | Self::MethodReceiverRefImpl | Self::Callee | Self::FieldAccess(_) | Self::Postfix\n+        ) && precedence < PREC_POSTFIX\n+    }\n }\n \n /// Walks up the parent expressions attempting to determine both how stable the auto-deref result\n@@ -730,10 +739,34 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n                     args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n                         if i == 0 {\n-                            if e.hir_id == child_id {\n-                                Position::MethodReceiver\n-                            } else {\n+                            // Check for calls to trait methods where the trait is implemented on a reference.\n+                            // Two cases need to be handled:\n+                            // * `self` methods on `&T` will never have auto-borrow\n+                            // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n+                            //   priority.\n+                            if e.hir_id != child_id {\n                                 Position::ReborrowStable\n+                            } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n+                                && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n+                                && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n+                                && let subs = cx.typeck_results().node_substs_opt(child_id).unwrap_or_else(\n+                                    || cx.tcx.mk_substs([].iter())\n+                                ) && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n+                                    // Trait methods taking `&self`\n+                                    sub_ty\n+                                } else {\n+                                    // Trait methods taking `self`\n+                                    arg_ty\n+                                } && impl_ty.is_ref()\n+                                && cx.tcx.infer_ctxt().enter(|infcx|\n+                                    infcx\n+                                        .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n+                                        .must_apply_modulo_regions()\n+                                )\n+                            {\n+                                Position::MethodReceiverRefImpl\n+                            } else {\n+                                Position::MethodReceiver\n                             }\n                         } else {\n                             param_auto_deref_stability(cx.tcx.fn_sig(id).skip_binder().inputs()[i])\n@@ -964,7 +997,7 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n             let mut app = Applicability::MachineApplicable;\n             let snip = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app).0;\n             span_lint_hir_and_then(cx, NEEDLESS_BORROW, data.hir_id, data.span, state.msg, |diag| {\n-                let sugg = if state.required_precedence > expr.precedence().order() && !has_enclosing_paren(&snip) {\n+                let sugg = if state.position.needs_parens(expr.precedence().order()) && !has_enclosing_paren(&snip) {\n                     format!(\"({})\", snip)\n                 } else {\n                     snip.into()"}, {"sha": "cb005122436019f2a2be9ac1c8fb219d8257e534", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6d21b79be90553ef45f58b682b40432cac840b10/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6d21b79be90553ef45f58b682b40432cac840b10/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=6d21b79be90553ef45f58b682b40432cac840b10", "patch": "@@ -85,6 +85,36 @@ fn main() {\n     let _ = x.0;\n     let x = &x as *const (i32, i32);\n     let _ = unsafe { (*x).0 };\n+\n+    // Issue #8367\n+    trait Foo {\n+        fn foo(self);\n+    }\n+    impl Foo for &'_ () {\n+        fn foo(self) {}\n+    }\n+    (&()).foo(); // Don't lint. `()` doesn't implement `Foo`\n+    (&()).foo();\n+\n+    impl Foo for i32 {\n+        fn foo(self) {}\n+    }\n+    impl Foo for &'_ i32 {\n+        fn foo(self) {}\n+    }\n+    (&5).foo(); // Don't lint. `5` will call `<i32 as Foo>::foo`\n+    (&5).foo();\n+\n+    trait FooRef {\n+        fn foo_ref(&self);\n+    }\n+    impl FooRef for () {\n+        fn foo_ref(&self) {}\n+    }\n+    impl FooRef for &'_ () {\n+        fn foo_ref(&self) {}\n+    }\n+    (&&()).foo_ref(); // Don't lint. `&()` will call `<() as FooRef>::foo_ref`\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "d636a40100378c0f5bebc5cbb3f85b9f902ab365", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6d21b79be90553ef45f58b682b40432cac840b10/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d21b79be90553ef45f58b682b40432cac840b10/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=6d21b79be90553ef45f58b682b40432cac840b10", "patch": "@@ -85,6 +85,36 @@ fn main() {\n     let _ = (&x).0;\n     let x = &x as *const (i32, i32);\n     let _ = unsafe { (&*x).0 };\n+\n+    // Issue #8367\n+    trait Foo {\n+        fn foo(self);\n+    }\n+    impl Foo for &'_ () {\n+        fn foo(self) {}\n+    }\n+    (&()).foo(); // Don't lint. `()` doesn't implement `Foo`\n+    (&&()).foo();\n+\n+    impl Foo for i32 {\n+        fn foo(self) {}\n+    }\n+    impl Foo for &'_ i32 {\n+        fn foo(self) {}\n+    }\n+    (&5).foo(); // Don't lint. `5` will call `<i32 as Foo>::foo`\n+    (&&5).foo();\n+\n+    trait FooRef {\n+        fn foo_ref(&self);\n+    }\n+    impl FooRef for () {\n+        fn foo_ref(&self) {}\n+    }\n+    impl FooRef for &'_ () {\n+        fn foo_ref(&self) {}\n+    }\n+    (&&()).foo_ref(); // Don't lint. `&()` will call `<() as FooRef>::foo_ref`\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "8a2e2b9895908f1ac5fb1d2d2737b5a5a230e5a7", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d21b79be90553ef45f58b682b40432cac840b10/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d21b79be90553ef45f58b682b40432cac840b10/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=6d21b79be90553ef45f58b682b40432cac840b10", "patch": "@@ -108,5 +108,17 @@ error: this expression borrows a value the compiler would automatically borrow\n LL |     let _ = unsafe { (&*x).0 };\n    |                      ^^^^^ help: change this to: `(*x)`\n \n-error: aborting due to 18 previous errors\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:97:5\n+   |\n+LL |     (&&()).foo();\n+   |     ^^^^^^ help: change this to: `(&())`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:106:5\n+   |\n+LL |     (&&5).foo();\n+   |     ^^^^^ help: change this to: `(&5)`\n+\n+error: aborting due to 20 previous errors\n "}]}