{"sha": "69d575e58dc21175a7365577c84c435a243029eb", "node_id": "C_kwDOAAsO6NoAKDY5ZDU3NWU1OGRjMjExNzVhNzM2NTU3N2M4NGM0MzVhMjQzMDI5ZWI", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-05-26T09:40:23Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-06-02T08:19:15Z"}, "message": "eagerly fetch the typeck_results", "tree": {"sha": "f195d31d73c9c1828a2f550eb59f24c98d713941", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f195d31d73c9c1828a2f550eb59f24c98d713941"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69d575e58dc21175a7365577c84c435a243029eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69d575e58dc21175a7365577c84c435a243029eb", "html_url": "https://github.com/rust-lang/rust/commit/69d575e58dc21175a7365577c84c435a243029eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69d575e58dc21175a7365577c84c435a243029eb/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc0d12cc6ccf5c6d8d9c44e67871a5b75f5a44cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc0d12cc6ccf5c6d8d9c44e67871a5b75f5a44cf", "html_url": "https://github.com/rust-lang/rust/commit/bc0d12cc6ccf5c6d8d9c44e67871a5b75f5a44cf"}], "stats": {"total": 80, "additions": 52, "deletions": 28}, "files": [{"sha": "1c06c45a923f4d0b5cb31e5af205e3c9e4bb07d5", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/69d575e58dc21175a7365577c84c435a243029eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69d575e58dc21175a7365577c84c435a243029eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=69d575e58dc21175a7365577c84c435a243029eb", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMut\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, InferConst};\n-use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_middle::ty::{Ty, TyCtxt, TypeckResults};\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{BytePos, Span};\n use std::borrow::Cow;\n@@ -272,7 +272,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         parent: None,\n                     }\n                 } else {\n-                    // FIXME: This code seems a bit wrong, idk.\n+                    // If we end up here the `FindInferSourceVisitor`\n+                    // won't work, as its expected argument isn't an inference variable.\n+                    //\n+                    // FIXME: Ideally we should look into the generic constant\n+                    // to figure out which inference var is actually unresolved so that\n+                    // this path is unreachable.\n                     let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::ValueNS);\n                     if let Some(highlight) = highlight {\n                         printer.region_highlight_mode = highlight;\n@@ -289,6 +294,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Used as a fallback in [InferCtxt::emit_inference_failure_err]\n+    /// in case we weren't able to get a better error.\n+    fn bad_inference_failure_err(\n+        &self,\n+        span: Span,\n+        arg_data: InferenceDiagnosticsData,\n+        error_code: TypeAnnotationNeeded,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        let error_code = error_code.into();\n+        let mut err = self.tcx.sess.struct_span_err_with_code(\n+            span,\n+            &format!(\"type annotations needed\"),\n+            error_code,\n+        );\n+        err.span_label(span, arg_data.cannot_infer_msg());\n+        err\n+    }\n+\n     pub fn emit_inference_failure_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n@@ -301,25 +324,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let arg = self.resolve_vars_if_possible(arg);\n         let arg_data = self.extract_inference_diagnostics_data(arg, None);\n \n-        let mut local_visitor = FindInferSourceVisitor::new(&self, arg);\n+        let Some(typeck_results) = self.in_progress_typeck_results else {\n+            // If we don't have any typeck results we're outside\n+            // of a body, so we won't be able to get better info\n+            // here.\n+            return self.bad_inference_failure_err(span, arg_data, error_code);\n+        };\n+        let typeck_results = typeck_results.borrow();\n+        let typeck_results = &typeck_results;\n+\n+        let mut local_visitor = FindInferSourceVisitor::new(&self, typeck_results, arg);\n         if let Some(body_id) = body_id {\n             let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n             debug!(?expr);\n             local_visitor.visit_expr(expr);\n         }\n \n         let Some(InferSource { span, kind }) = local_visitor.infer_source else {\n-            let error_code = error_code.into();\n-            let mut err = self.tcx.sess.struct_span_err_with_code(\n-                span,\n-                &format!(\"type annotations needed\"),\n-                error_code,\n-            );\n-            err.span_label(\n-                span,\n-                arg_data.cannot_infer_msg(),\n-            );\n-            return err;\n+            return self.bad_inference_failure_err(span, arg_data, error_code)\n         };\n \n         let error_code = error_code.into();\n@@ -394,8 +416,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n             }\n             InferSourceKind::FullyQualifiedMethodCall { receiver, successor, substs, def_id } => {\n-                let typeck_results = self.in_progress_typeck_results.unwrap();\n-                let typeck_results = typeck_results.borrow();\n                 let printer = fmt_printer(self, Namespace::ValueNS);\n                 let def_path = printer.print_def_path(def_id, substs).unwrap().into_buffer();\n \n@@ -548,6 +568,8 @@ struct InsertableGenericArgs<'tcx> {\n /// For details on how we rank spots, see [Self::source_cost]\n struct FindInferSourceVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n+    typeck_results: &'a TypeckResults<'tcx>,\n+\n     target: GenericArg<'tcx>,\n \n     attempt: usize,\n@@ -556,9 +578,15 @@ struct FindInferSourceVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target: GenericArg<'tcx>) -> Self {\n+    fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        typeck_results: &'a TypeckResults<'tcx>,\n+        target: GenericArg<'tcx>,\n+    ) -> Self {\n         FindInferSourceVisitor {\n             infcx,\n+            typeck_results,\n+\n             target,\n \n             attempt: 0,\n@@ -603,7 +631,6 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                 variant_cost + generic_args.iter().map(|&arg| arg_cost(arg)).sum::<usize>()\n             }\n             InferSourceKind::FullyQualifiedMethodCall { substs, .. } => {\n-                // FIXME: We should also consider the cost of lifetimes and constants here.\n                 20 + substs.iter().map(|arg| arg_cost(arg)).sum::<usize>()\n             }\n             InferSourceKind::ClosureReturn { ty, should_wrap_expr, .. } => {\n@@ -625,7 +652,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n     }\n \n     fn opt_node_type(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n-        let ty = self.infcx.in_progress_typeck_results?.borrow().node_type_opt(hir_id);\n+        let ty = self.typeck_results.node_type_opt(hir_id);\n         self.infcx.resolve_vars_if_possible(ty)\n     }\n \n@@ -698,10 +725,9 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Box<dyn Iterator<Item = InsertableGenericArgs<'tcx>> + 'a> {\n         let tcx = self.infcx.tcx;\n-        let typeck_results = self.infcx.in_progress_typeck_results.unwrap().borrow();\n         match expr.kind {\n             hir::ExprKind::Path(ref path) => {\n-                if let Some(substs) = typeck_results.node_substs_opt(expr.hir_id) {\n+                if let Some(substs) = self.typeck_results.node_substs_opt(expr.hir_id) {\n                     return self.path_inferred_subst_iter(expr.hir_id, substs, path);\n                 }\n             }\n@@ -713,13 +739,13 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprKind::MethodCall(segment, _, _) => {\n-                if let Some(def_id) = typeck_results.type_dependent_def_id(expr.hir_id) {\n+                if let Some(def_id) = self.typeck_results.type_dependent_def_id(expr.hir_id) {\n                     let generics = tcx.generics_of(def_id);\n                     let insertable: Option<_> = try {\n                         if generics.has_impl_trait() {\n                             None?\n                         }\n-                        let substs = typeck_results.node_substs_opt(expr.hir_id)?;\n+                        let substs = self.typeck_results.node_substs_opt(expr.hir_id)?;\n                         let span = tcx.hir().span(segment.hir_id?);\n                         let insert_span = segment.ident.span.shrink_to_hi().with_hi(span.hi());\n                         InsertableGenericArgs {\n@@ -793,13 +819,12 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n         qpath: &'tcx hir::QPath<'tcx>,\n     ) -> Box<dyn Iterator<Item = InsertableGenericArgs<'tcx>> + 'a> {\n         let tcx = self.infcx.tcx;\n-        let typeck_results = self.infcx.in_progress_typeck_results.unwrap().borrow();\n         match qpath {\n             hir::QPath::Resolved(_self_ty, path) => {\n                 Box::new(self.resolved_path_inferred_subst_iter(path, substs))\n             }\n             hir::QPath::TypeRelative(ty, segment) => {\n-                let Some(def_id) = typeck_results.type_dependent_def_id(hir_id) else {\n+                let Some(def_id) = self.typeck_results.type_dependent_def_id(hir_id) else {\n                     return Box::new(iter::empty());\n                 };\n \n@@ -996,10 +1021,9 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n             .any(|generics| generics.has_impl_trait())\n         };\n         if let ExprKind::MethodCall(path, args, span) = expr.kind\n-            && let Some(typeck_results) = self.infcx.in_progress_typeck_results\n-            && let Some(substs) = typeck_results.borrow().node_substs_opt(expr.hir_id)\n+            && let Some(substs) = self.typeck_results.node_substs_opt(expr.hir_id)\n             && substs.iter().any(|arg| self.generic_arg_contains_target(arg))\n-            && let Some(def_id) = typeck_results.borrow().type_dependent_def_id(expr.hir_id)\n+            && let Some(def_id) = self.typeck_results.type_dependent_def_id(expr.hir_id)\n             && self.infcx.tcx.trait_of_item(def_id).is_some()\n             && !has_impl_trait(def_id)\n         {"}]}