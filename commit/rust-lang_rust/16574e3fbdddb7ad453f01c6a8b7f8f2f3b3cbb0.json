{"sha": "16574e3fbdddb7ad453f01c6a8b7f8f2f3b3cbb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NTc0ZTNmYmRkZGI3YWQ0NTNmMDFjNmE4YjdmOGYyZjNiM2NiYjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-09T18:44:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-10T10:11:28Z"}, "message": "Replace the use of the rather randomly named boolean `custom` to mean\n\"highlight end\" and instead add a variant to `RenderSpan`", "tree": {"sha": "a0be6cb49a82e00cd3bc35da42f3a13455c1981a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0be6cb49a82e00cd3bc35da42f3a13455c1981a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16574e3fbdddb7ad453f01c6a8b7f8f2f3b3cbb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16574e3fbdddb7ad453f01c6a8b7f8f2f3b3cbb0", "html_url": "https://github.com/rust-lang/rust/commit/16574e3fbdddb7ad453f01c6a8b7f8f2f3b3cbb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16574e3fbdddb7ad453f01c6a8b7f8f2f3b3cbb0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b95d8bed8afff7262ec5623677e320bf63d2230", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b95d8bed8afff7262ec5623677e320bf63d2230", "html_url": "https://github.com/rust-lang/rust/commit/6b95d8bed8afff7262ec5623677e320bf63d2230"}], "stats": {"total": 67, "additions": 37, "deletions": 30}, "files": [{"sha": "7841059f53ab5e609b4bd4221f91baab1bde2558", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/16574e3fbdddb7ad453f01c6a8b7f8f2f3b3cbb0/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16574e3fbdddb7ad453f01c6a8b7f8f2f3b3cbb0/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=16574e3fbdddb7ad453f01c6a8b7f8f2f3b3cbb0", "patch": "@@ -35,21 +35,25 @@ pub enum RenderSpan {\n     /// the source code covered by the span.\n     FullSpan(Span),\n \n+    /// Similar to a FullSpan, but the cited position is the end of\n+    /// the span, instead of the start. Used, at least, for telling\n+    /// compiletest/runtest to look at the last line of the span\n+    /// (since `end_highlight_lines` displays an arrow to the end\n+    /// of the span).\n+    EndSpan(Span),\n+\n     /// A FileLine renders with just a line for the message prefixed\n     /// by file:linenum.\n     FileLine(Span),\n }\n \n impl RenderSpan {\n-    fn span(self) -> Span {\n-        match self {\n-            FullSpan(s) | FileLine(s) => s\n-        }\n-    }\n-    fn is_full_span(&self) -> bool {\n-        match self {\n-            &FullSpan(..) => true,\n-            &FileLine(..) => false,\n+    fn span(&self) -> Span {\n+        match *self {\n+            FullSpan(s) |\n+            EndSpan(s) |\n+            FileLine(s) =>\n+                s\n         }\n     }\n }\n@@ -115,7 +119,7 @@ impl SpanHandler {\n         self.handler.emit(Some((&self.cm, sp)), msg, Note);\n     }\n     pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, FullSpan(sp), msg, Note);\n+        self.handler.custom_emit(&self.cm, EndSpan(sp), msg, Note);\n     }\n     pub fn span_help(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&self.cm, sp)), msg, Help);\n@@ -407,8 +411,8 @@ impl Emitter for EmitterWriter {\n         let error = match cmsp {\n             Some((cm, COMMAND_LINE_SP)) => emit(self, cm,\n                                                 FileLine(COMMAND_LINE_SP),\n-                                                msg, code, lvl, false),\n-            Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, code, lvl, false),\n+                                                msg, code, lvl),\n+            Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, code, lvl),\n             None => print_diagnostic(self, \"\", lvl, msg, code),\n         };\n \n@@ -420,43 +424,46 @@ impl Emitter for EmitterWriter {\n \n     fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: RenderSpan, msg: &str, lvl: Level) {\n-        match emit(self, cm, sp, msg, None, lvl, true) {\n+        match emit(self, cm, sp, msg, None, lvl) {\n             Ok(()) => {}\n             Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n         }\n     }\n }\n \n fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n-        msg: &str, code: Option<&str>, lvl: Level, custom: bool) -> io::Result<()> {\n+        msg: &str, code: Option<&str>, lvl: Level) -> io::Result<()> {\n     let sp = rsp.span();\n \n     // We cannot check equality directly with COMMAND_LINE_SP\n     // since PartialEq is manually implemented to ignore the ExpnId\n     let ss = if sp.expn_id == COMMAND_LINE_EXPN {\n         \"<command line option>\".to_string()\n+    } else if let EndSpan(_) = rsp {\n+        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n+        cm.span_to_string(span_end)\n     } else {\n         cm.span_to_string(sp)\n     };\n-    if custom {\n-        // we want to tell compiletest/runtest to look at the last line of the\n-        // span (since `custom_highlight_lines` displays an arrow to the end of\n-        // the span)\n-        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n-        let ses = cm.span_to_string(span_end);\n-        try!(print_diagnostic(dst, &ses[..], lvl, msg, code));\n-        if rsp.is_full_span() {\n-            try!(custom_highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n-        }\n-    } else {\n-        try!(print_diagnostic(dst, &ss[..], lvl, msg, code));\n-        if rsp.is_full_span() {\n+\n+    try!(print_diagnostic(dst, &ss[..], lvl, msg, code));\n+\n+    match rsp {\n+        FullSpan(_) => {\n             try!(highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n         }\n+        EndSpan(_) => {\n+            try!(end_highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n+        }\n+        FileLine(..) => {\n+            // no source text in this case!\n+        }\n     }\n+\n     if sp != COMMAND_LINE_SP {\n         try!(print_macro_backtrace(dst, cm, sp));\n     }\n+\n     match code {\n         Some(code) =>\n             match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n@@ -575,12 +582,12 @@ fn highlight_lines(err: &mut EmitterWriter,\n }\n \n /// Here are the differences between this and the normal `highlight_lines`:\n-/// `custom_highlight_lines` will always put arrow on the last byte of the\n+/// `end_highlight_lines` will always put arrow on the last byte of the\n /// span (instead of the first byte). Also, when the span is too long (more\n-/// than 6 lines), `custom_highlight_lines` will print the first line, then\n+/// than 6 lines), `end_highlight_lines` will print the first line, then\n /// dot dot dot, then last line, whereas `highlight_lines` prints the first\n /// six lines.\n-fn custom_highlight_lines(w: &mut EmitterWriter,\n+fn end_highlight_lines(w: &mut EmitterWriter,\n                           cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,"}]}