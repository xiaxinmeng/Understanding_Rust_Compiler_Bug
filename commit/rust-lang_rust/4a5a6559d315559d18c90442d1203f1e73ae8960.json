{"sha": "4a5a6559d315559d18c90442d1203f1e73ae8960", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNWE2NTU5ZDMxNTU1OWQxOGM5MDQ0MmQxMjAzZjFlNzNhZTg5NjA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-25T09:01:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-25T09:01:05Z"}, "message": "Rollup merge of #72525 - RalfJung:miri-cast-checks, r=eddyb\n\nMiri casts: do not blindly rely on dest type\n\nMake sure that we notice when the MIR is bad and the casted-to and destination type are e.g. of different size, as suggested by @eddyb.", "tree": {"sha": "ffb7a37323677172690d8ae2a9824f1d855d1b37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffb7a37323677172690d8ae2a9824f1d855d1b37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a5a6559d315559d18c90442d1203f1e73ae8960", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJey4lRCRBK7hj4Ov3rIwAAdHIIAIP+B+XeCmI9KPFxIdYce3n5\n0lkEqGxliud2IEEnrASdjgeJ1UE2q2wDmu85+FVVF3prjxY9bVsvtj80vJH8oeKB\nTRPhA6NQIuCVBrlJa/VWW8qBkCsQHRUMv84rocldEMTlT7m8tCC3H4LhTokRrhxw\nZVyCQ2MsAFZW6izKi/eALy26jtqueVLCJxGAY2Y3xcL8rMK7ztNTXrW81bEkmyEI\nfVVmtyaJMktwR0uH4w7VRng+95AAcly9vbXke2Btwlf7hyjQfLvp/lCwmAICX7S7\nDbkt6/HBLOZKta8BfdR5Hu7XXseujqzqQzjdt7CZ4a7nT/cSEYv4NC01Q9ePNEU=\n=hsA4\n-----END PGP SIGNATURE-----\n", "payload": "tree ffb7a37323677172690d8ae2a9824f1d855d1b37\nparent bf816e0349ca9ede06b3e9a99b521a6d0b74e855\nparent 8b5ba4a3c62e9f663d5f8db1dc4fff245d291c4b\nauthor Ralf Jung <post@ralfj.de> 1590397265 +0200\ncommitter GitHub <noreply@github.com> 1590397265 +0200\n\nRollup merge of #72525 - RalfJung:miri-cast-checks, r=eddyb\n\nMiri casts: do not blindly rely on dest type\n\nMake sure that we notice when the MIR is bad and the casted-to and destination type are e.g. of different size, as suggested by @eddyb.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a5a6559d315559d18c90442d1203f1e73ae8960", "html_url": "https://github.com/rust-lang/rust/commit/4a5a6559d315559d18c90442d1203f1e73ae8960", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a5a6559d315559d18c90442d1203f1e73ae8960/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf816e0349ca9ede06b3e9a99b521a6d0b74e855", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf816e0349ca9ede06b3e9a99b521a6d0b74e855", "html_url": "https://github.com/rust-lang/rust/commit/bf816e0349ca9ede06b3e9a99b521a6d0b74e855"}, {"sha": "8b5ba4a3c62e9f663d5f8db1dc4fff245d291c4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b5ba4a3c62e9f663d5f8db1dc4fff245d291c4b", "html_url": "https://github.com/rust-lang/rust/commit/8b5ba4a3c62e9f663d5f8db1dc4fff245d291c4b"}], "stats": {"total": 195, "additions": 101, "deletions": 94}, "files": [{"sha": "0fd695586eb9876e562909e6e16689c5a669a4d1", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 98, "deletions": 92, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/4a5a6559d315559d18c90442d1203f1e73ae8960/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5a6559d315559d18c90442d1203f1e73ae8960/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=4a5a6559d315559d18c90442d1203f1e73ae8960", "patch": "@@ -1,36 +1,47 @@\n use std::convert::TryFrom;\n \n-use super::{FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::{Float, FloatConvert};\n use rustc_ast::ast::FloatTy;\n+use rustc_attr as attr;\n use rustc_middle::mir::interpret::{InterpResult, PointerArithmetic, Scalar};\n use rustc_middle::mir::CastKind;\n use rustc_middle::ty::adjustment::PointerCast;\n-use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::ty::layout::{IntegerExt, TyAndLayout};\n use rustc_middle::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc_span::symbol::sym;\n-use rustc_target::abi::{LayoutOf, Size, Variants};\n+use rustc_target::abi::{Integer, LayoutOf, Variants};\n+\n+use super::{truncate, FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy};\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn cast(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n-        kind: CastKind,\n+        cast_kind: CastKind,\n+        cast_ty: Ty<'tcx>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         use rustc_middle::mir::CastKind::*;\n-        match kind {\n+        // FIXME: In which cases should we trigger UB when the source is uninit?\n+        match cast_kind {\n             Pointer(PointerCast::Unsize) => {\n-                self.unsize_into(src, dest)?;\n+                let cast_ty = self.layout_of(cast_ty)?;\n+                self.unsize_into(src, cast_ty, dest)?;\n             }\n \n-            Misc | Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer) => {\n+            Misc => {\n                 let src = self.read_immediate(src)?;\n-                let res = self.cast_immediate(src, dest.layout)?;\n+                let res = self.misc_cast(src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n \n+            Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer) => {\n+                // These are NOPs, but can be wide pointers.\n+                let v = self.read_immediate(src)?;\n+                self.write_immediate(*v, dest)?;\n+            }\n+\n             Pointer(PointerCast::ReifyFnPointer) => {\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.kind {\n@@ -61,12 +72,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Pointer(PointerCast::UnsafeFnPointer) => {\n                 let src = self.read_immediate(src)?;\n-                match dest.layout.ty.kind {\n+                match cast_ty.kind {\n                     ty::FnPtr(_) => {\n                         // No change to value\n                         self.write_immediate(*src, dest)?;\n                     }\n-                    _ => bug!(\"fn to unsafe fn cast on {:?}\", dest.layout.ty),\n+                    _ => bug!(\"fn to unsafe fn cast on {:?}\", cast_ty),\n                 }\n             }\n \n@@ -95,25 +106,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn cast_immediate(\n+    fn misc_cast(\n         &self,\n         src: ImmTy<'tcx, M::PointerTag>,\n-        dest_layout: TyAndLayout<'tcx>,\n+        cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n         use rustc_middle::ty::TyKind::*;\n-        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, dest_layout.ty);\n+        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, cast_ty);\n \n         match src.layout.ty.kind {\n             // Floating point\n             Float(FloatTy::F32) => {\n-                return Ok(self\n-                    .cast_from_float(src.to_scalar()?.to_f32()?, dest_layout.ty)?\n-                    .into());\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f32()?, cast_ty).into());\n             }\n             Float(FloatTy::F64) => {\n-                return Ok(self\n-                    .cast_from_float(src.to_scalar()?.to_f64()?, dest_layout.ty)?\n-                    .into());\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f64()?, cast_ty).into());\n             }\n             // The rest is integer/pointer-\"like\", including fn ptr casts and casts from enums that\n             // are represented as integers.\n@@ -128,121 +135,118 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ),\n         }\n \n+        // # First handle non-scalar source values.\n+\n         // Handle cast from a univariant (ZST) enum.\n         match src.layout.variants {\n             Variants::Single { index } => {\n                 if let Some(discr) = src.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     assert!(src.layout.is_zst());\n                     let discr_layout = self.layout_of(discr.ty)?;\n-                    return Ok(self\n-                        .cast_from_int_like(discr.val, discr_layout, dest_layout)?\n-                        .into());\n+                    return Ok(self.cast_from_scalar(discr.val, discr_layout, cast_ty).into());\n                 }\n             }\n             Variants::Multiple { .. } => {}\n         }\n \n-        // Handle casting the metadata away from a fat pointer.\n-        if src.layout.ty.is_unsafe_ptr()\n-            && dest_layout.ty.is_unsafe_ptr()\n-            && dest_layout.size != src.layout.size\n-        {\n-            assert_eq!(src.layout.size, 2 * self.memory.pointer_size());\n-            assert_eq!(dest_layout.size, self.memory.pointer_size());\n-            assert!(dest_layout.ty.is_unsafe_ptr());\n-            match *src {\n-                Immediate::ScalarPair(data, _) => return Ok(data.into()),\n-                Immediate::Scalar(..) => bug!(\n-                    \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n-                    *src,\n-                    src.layout.ty,\n-                    dest_layout.ty\n-                ),\n-            };\n-        }\n-\n         // Handle casting any ptr to raw ptr (might be a fat ptr).\n-        if src.layout.ty.is_any_ptr() && dest_layout.ty.is_unsafe_ptr() {\n-            // The only possible size-unequal case was handled above.\n-            assert_eq!(src.layout.size, dest_layout.size);\n-            return Ok(*src);\n+        if src.layout.ty.is_any_ptr() && cast_ty.is_unsafe_ptr() {\n+            let dest_layout = self.layout_of(cast_ty)?;\n+            if dest_layout.size == src.layout.size {\n+                // Thin or fat pointer that just hast the ptr kind of target type changed.\n+                return Ok(*src);\n+            } else {\n+                // Casting the metadata away from a fat ptr.\n+                assert_eq!(src.layout.size, 2 * self.memory.pointer_size());\n+                assert_eq!(dest_layout.size, self.memory.pointer_size());\n+                assert!(src.layout.ty.is_unsafe_ptr());\n+                return match *src {\n+                    Immediate::ScalarPair(data, _) => Ok(data.into()),\n+                    Immediate::Scalar(..) => bug!(\n+                        \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n+                        *src,\n+                        src.layout.ty,\n+                        cast_ty\n+                    ),\n+                };\n+            }\n         }\n \n+        // # The remaining source values are scalar.\n+\n         // For all remaining casts, we either\n         // (a) cast a raw ptr to usize, or\n         // (b) cast from an integer-like (including bool, char, enums).\n         // In both cases we want the bits.\n         let bits = self.force_bits(src.to_scalar()?, src.layout.size)?;\n-        Ok(self.cast_from_int_like(bits, src.layout, dest_layout)?.into())\n+        Ok(self.cast_from_scalar(bits, src.layout, cast_ty).into())\n     }\n \n-    fn cast_from_int_like(\n+    pub(super) fn cast_from_scalar(\n         &self,\n-        v: u128, // raw bits\n+        v: u128, // raw bits (there is no ScalarTy so we separate data+layout)\n         src_layout: TyAndLayout<'tcx>,\n-        dest_layout: TyAndLayout<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        cast_ty: Ty<'tcx>,\n+    ) -> Scalar<M::PointerTag> {\n         // Let's make sure v is sign-extended *if* it has a signed type.\n-        let signed = src_layout.abi.is_signed();\n+        let signed = src_layout.abi.is_signed(); // Also asserts that abi is `Scalar`.\n         let v = if signed { self.sign_extend(v, src_layout) } else { v };\n-        trace!(\"cast_from_int: {}, {}, {}\", v, src_layout.ty, dest_layout.ty);\n+        trace!(\"cast_from_scalar: {}, {} -> {}\", v, src_layout.ty, cast_ty);\n         use rustc_middle::ty::TyKind::*;\n-        match dest_layout.ty.kind {\n+        match cast_ty.kind {\n             Int(_) | Uint(_) | RawPtr(_) => {\n-                let v = self.truncate(v, dest_layout);\n-                Ok(Scalar::from_uint(v, dest_layout.size))\n+                let size = match cast_ty.kind {\n+                    Int(t) => Integer::from_attr(self, attr::IntType::SignedInt(t)).size(),\n+                    Uint(t) => Integer::from_attr(self, attr::IntType::UnsignedInt(t)).size(),\n+                    RawPtr(_) => self.pointer_size(),\n+                    _ => bug!(),\n+                };\n+                let v = truncate(v, size);\n+                Scalar::from_uint(v, size)\n             }\n \n-            Float(FloatTy::F32) if signed => {\n-                Ok(Scalar::from_f32(Single::from_i128(v as i128).value))\n-            }\n-            Float(FloatTy::F64) if signed => {\n-                Ok(Scalar::from_f64(Double::from_i128(v as i128).value))\n-            }\n-            Float(FloatTy::F32) => Ok(Scalar::from_f32(Single::from_u128(v).value)),\n-            Float(FloatTy::F64) => Ok(Scalar::from_f64(Double::from_u128(v).value)),\n+            Float(FloatTy::F32) if signed => Scalar::from_f32(Single::from_i128(v as i128).value),\n+            Float(FloatTy::F64) if signed => Scalar::from_f64(Double::from_i128(v as i128).value),\n+            Float(FloatTy::F32) => Scalar::from_f32(Single::from_u128(v).value),\n+            Float(FloatTy::F64) => Scalar::from_f64(Double::from_u128(v).value),\n \n             Char => {\n                 // `u8` to `char` cast\n-                Ok(Scalar::from_u32(u8::try_from(v).unwrap().into()))\n+                Scalar::from_u32(u8::try_from(v).unwrap().into())\n             }\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-            _ => bug!(\"invalid int to {:?} cast\", dest_layout.ty),\n+            _ => bug!(\"invalid int to {:?} cast\", cast_ty),\n         }\n     }\n \n-    fn cast_from_float<F>(\n-        &self,\n-        f: F,\n-        dest_ty: Ty<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>>\n+    fn cast_from_float<F>(&self, f: F, dest_ty: Ty<'tcx>) -> Scalar<M::PointerTag>\n     where\n         F: Float + Into<Scalar<M::PointerTag>> + FloatConvert<Single> + FloatConvert<Double>,\n     {\n         use rustc_middle::ty::TyKind::*;\n         match dest_ty.kind {\n             // float -> uint\n             Uint(t) => {\n-                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits());\n+                let size = Integer::from_attr(self, attr::IntType::UnsignedInt(t)).size();\n                 // `to_u128` is a saturating cast, which is what we need\n                 // (https://doc.rust-lang.org/nightly/nightly-rustc/rustc_apfloat/trait.Float.html#method.to_i128_r).\n-                let v = f.to_u128(usize::try_from(width).unwrap()).value;\n+                let v = f.to_u128(size.bits_usize()).value;\n                 // This should already fit the bit width\n-                Ok(Scalar::from_uint(v, Size::from_bits(width)))\n+                Scalar::from_uint(v, size)\n             }\n             // float -> int\n             Int(t) => {\n-                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits());\n+                let size = Integer::from_attr(self, attr::IntType::SignedInt(t)).size();\n                 // `to_i128` is a saturating cast, which is what we need\n                 // (https://doc.rust-lang.org/nightly/nightly-rustc/rustc_apfloat/trait.Float.html#method.to_i128_r).\n-                let v = f.to_i128(usize::try_from(width).unwrap()).value;\n-                Ok(Scalar::from_int(v, Size::from_bits(width)))\n+                let v = f.to_i128(size.bits_usize()).value;\n+                Scalar::from_int(v, size)\n             }\n             // float -> f32\n-            Float(FloatTy::F32) => Ok(Scalar::from_f32(f.convert(&mut false).value)),\n+            Float(FloatTy::F32) => Scalar::from_f32(f.convert(&mut false).value),\n             // float -> f64\n-            Float(FloatTy::F64) => Ok(Scalar::from_f64(f.convert(&mut false).value)),\n+            Float(FloatTy::F64) => Scalar::from_f64(f.convert(&mut false).value),\n             // That's it.\n             _ => bug!(\"invalid float to {:?} cast\", dest_ty),\n         }\n@@ -254,11 +258,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         dest: PlaceTy<'tcx, M::PointerTag>,\n         // The pointee types\n         source_ty: Ty<'tcx>,\n-        dest_ty: Ty<'tcx>,\n+        cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx> {\n         // A<Struct> -> A<Trait> conversion\n         let (src_pointee_ty, dest_pointee_ty) =\n-            self.tcx.struct_lockstep_tails_erasing_lifetimes(source_ty, dest_ty, self.param_env);\n+            self.tcx.struct_lockstep_tails_erasing_lifetimes(source_ty, cast_ty, self.param_env);\n \n         match (&src_pointee_ty.kind, &dest_pointee_ty.kind) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n@@ -286,48 +290,50 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_immediate(val, dest)\n             }\n \n-            _ => bug!(\"invalid unsizing {:?} -> {:?}\", src.layout.ty, dest.layout.ty),\n+            _ => bug!(\"invalid unsizing {:?} -> {:?}\", src.layout.ty, cast_ty),\n         }\n     }\n \n     fn unsize_into(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n+        cast_ty: TyAndLayout<'tcx>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"Unsizing {:?} into {:?}\", src, dest);\n-        match (&src.layout.ty.kind, &dest.layout.ty.kind) {\n-            (&ty::Ref(_, s, _), &ty::Ref(_, d, _) | &ty::RawPtr(TypeAndMut { ty: d, .. }))\n-            | (&ty::RawPtr(TypeAndMut { ty: s, .. }), &ty::RawPtr(TypeAndMut { ty: d, .. })) => {\n-                self.unsize_into_ptr(src, dest, s, d)\n+        trace!(\"Unsizing {:?} of type {} into {:?}\", *src, src.layout.ty, cast_ty.ty);\n+        match (&src.layout.ty.kind, &cast_ty.ty.kind) {\n+            (&ty::Ref(_, s, _), &ty::Ref(_, c, _) | &ty::RawPtr(TypeAndMut { ty: c, .. }))\n+            | (&ty::RawPtr(TypeAndMut { ty: s, .. }), &ty::RawPtr(TypeAndMut { ty: c, .. })) => {\n+                self.unsize_into_ptr(src, dest, s, c)\n             }\n             (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n                 assert_eq!(def_a, def_b);\n                 if def_a.is_box() || def_b.is_box() {\n                     if !def_a.is_box() || !def_b.is_box() {\n-                        bug!(\"invalid unsizing between {:?} -> {:?}\", src.layout, dest.layout);\n+                        bug!(\"invalid unsizing between {:?} -> {:?}\", src.layout.ty, cast_ty.ty);\n                     }\n                     return self.unsize_into_ptr(\n                         src,\n                         dest,\n                         src.layout.ty.boxed_ty(),\n-                        dest.layout.ty.boxed_ty(),\n+                        cast_ty.ty.boxed_ty(),\n                     );\n                 }\n \n                 // unsizing of generic struct with pointer fields\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n                 for i in 0..src.layout.fields.count() {\n-                    let dst_field = self.place_field(dest, i)?;\n-                    if dst_field.layout.is_zst() {\n+                    let cast_ty_field = cast_ty.field(self, i)?;\n+                    if cast_ty_field.is_zst() {\n                         continue;\n                     }\n                     let src_field = self.operand_field(src, i)?;\n-                    if src_field.layout.ty == dst_field.layout.ty {\n+                    let dst_field = self.place_field(dest, i)?;\n+                    if src_field.layout.ty == cast_ty_field.ty {\n                         self.copy_op(src_field, dst_field)?;\n                     } else {\n-                        self.unsize_into(src_field, dst_field)?;\n+                        self.unsize_into(src_field, cast_ty_field, dst_field)?;\n                     }\n                 }\n                 Ok(())"}, {"sha": "fd9815975c19f613efa5beca7d398a5149840404", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a5a6559d315559d18c90442d1203f1e73ae8960/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5a6559d315559d18c90442d1203f1e73ae8960/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=4a5a6559d315559d18c90442d1203f1e73ae8960", "patch": "@@ -253,9 +253,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(Scalar::from_machine_usize(layout.size.bytes(), self), dest)?;\n             }\n \n-            Cast(kind, ref operand, _) => {\n+            Cast(cast_kind, ref operand, cast_ty) => {\n                 let src = self.eval_operand(operand, None)?;\n-                self.cast(src, kind, dest)?;\n+                let cast_ty = self.subst_from_current_frame_and_normalize_erasing_regions(cast_ty);\n+                self.cast(src, cast_kind, cast_ty, dest)?;\n             }\n \n             Discriminant(place) => {"}]}