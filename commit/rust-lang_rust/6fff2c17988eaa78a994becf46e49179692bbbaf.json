{"sha": "6fff2c17988eaa78a994becf46e49179692bbbaf", "node_id": "C_kwDOAAsO6NoAKDZmZmYyYzE3OTg4ZWFhNzhhOTk0YmVjZjQ2ZTQ5MTc5NjkyYmJiYWY", "commit": {"author": {"name": "iDawer", "email": "ilnur.iskhakov.oss@outlook.com", "date": "2022-04-09T17:07:44Z"}, "committer": {"name": "iDawer", "email": "ilnur.iskhakov.oss@outlook.com", "date": "2022-04-09T17:07:44Z"}, "message": "`extract_module`: Refactor loops", "tree": {"sha": "e54b93c8a2c3a4fafe3e68bb863e2ba29bb42e05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e54b93c8a2c3a4fafe3e68bb863e2ba29bb42e05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fff2c17988eaa78a994becf46e49179692bbbaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fff2c17988eaa78a994becf46e49179692bbbaf", "html_url": "https://github.com/rust-lang/rust/commit/6fff2c17988eaa78a994becf46e49179692bbbaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fff2c17988eaa78a994becf46e49179692bbbaf/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e71ac286b4a7fc35eda050edc8d4988c2ac1e13", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e71ac286b4a7fc35eda050edc8d4988c2ac1e13", "html_url": "https://github.com/rust-lang/rust/commit/1e71ac286b4a7fc35eda050edc8d4988c2ac1e13"}], "stats": {"total": 136, "additions": 52, "deletions": 84}, "files": [{"sha": "b5ed5699c90c6c7cbab88aa218d104dd2db3f723", "filename": "crates/ide_assists/src/handlers/extract_module.rs", "status": "modified", "additions": 52, "deletions": 84, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/6fff2c17988eaa78a994becf46e49179692bbbaf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fff2c17988eaa78a994becf46e49179692bbbaf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=6fff2c17988eaa78a994becf46e49179692bbbaf", "patch": "@@ -1,4 +1,7 @@\n-use std::collections::{HashMap, HashSet};\n+use std::{\n+    collections::{HashMap, HashSet},\n+    iter,\n+};\n \n use hir::{HasSource, ModuleSource};\n use ide_db::{\n@@ -207,31 +210,25 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n #[derive(Debug)]\n struct Module {\n     text_range: TextRange,\n-    name: String,\n-    body_items: Vec<ast::Item>, // All items except use items\n-    use_items: Vec<ast::Item>, // Use items are kept separately as they help when the selection is inside an impl block, we can directly take these items and keep them outside generated impl block inside generated module\n+    name: &'static str,\n+    /// All items except use items.\n+    body_items: Vec<ast::Item>,\n+    /// Use items are kept separately as they help when the selection is inside an impl block,\n+    /// we can directly take these items and keep them outside generated impl block inside\n+    /// generated module.\n+    use_items: Vec<ast::Item>,\n }\n \n fn extract_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Module> {\n-    let mut use_items = vec![];\n-\n-    let mut body_items: Vec<ast::Item> = node\n+    let selected_nodes = node\n         .children()\n-        .filter(|child| selection_range.contains_range(child.text_range()))\n-        .filter_map(|child| match ast::Item::cast(child) {\n-            Some(it @ ast::Item::Use(_)) => {\n-                use_items.push(it);\n-                None\n-            }\n-            item => item,\n-        })\n-        .collect();\n-\n-    if let Some(node_item) = ast::Item::cast(node.clone()) {\n-        body_items.push(node_item);\n-    }\n+        .filter(|node| selection_range.contains_range(node.text_range()))\n+        .chain(iter::once(node.clone()));\n+    let (use_items, body_items) = selected_nodes\n+        .filter_map(ast::Item::cast)\n+        .partition(|item| matches!(item, ast::Item::Use(..)));\n \n-    Some(Module { text_range: selection_range, name: \"modname\".to_string(), body_items, use_items })\n+    Some(Module { text_range: selection_range, name: \"modname\", body_items, use_items })\n }\n \n impl Module {\n@@ -245,7 +242,7 @@ impl Module {\n         //Here impl is not included as each item inside impl will be tied to the parent of\n         //implementing block(a struct, enum, etc), if the parent is in selected module, it will\n         //get updated by ADT section given below or if it is not, then we dont need to do any operation\n-        self.body_items.iter().cloned().for_each(|item| {\n+        for item in &self.body_items {\n             match_ast! {\n                 match (item.syntax()) {\n                     ast::Adt(it) => {\n@@ -314,7 +311,7 @@ impl Module {\n                     _ => (),\n                 }\n             }\n-        });\n+        }\n \n         (refs, adt_fields)\n     }\n@@ -323,36 +320,17 @@ impl Module {\n         &self,\n         ctx: &AssistContext,\n         node_def: Definition,\n-        refs: &mut HashMap<FileId, Vec<(TextRange, String)>>,\n+        refs_in_files: &mut HashMap<FileId, Vec<(TextRange, String)>>,\n     ) {\n         for (file_id, references) in node_def.usages(&ctx.sema).all() {\n-            if let Some(file_refs) = refs.get_mut(&file_id) {\n-                let mut usages = self.expand_ref_to_usages(references, ctx, file_id);\n-                file_refs.append(&mut usages);\n-            } else {\n-                refs.insert(file_id, self.expand_ref_to_usages(references, ctx, file_id));\n-            }\n+            let source_file = ctx.sema.parse(file_id);\n+            let usages_in_file = references\n+                .into_iter()\n+                .filter_map(|usage| self.get_usage_to_be_processed(&source_file, usage));\n+            refs_in_files.entry(file_id).or_default().extend(usages_in_file);\n         }\n     }\n \n-    fn expand_ref_to_usages(\n-        &self,\n-        refs: Vec<FileReference>,\n-        ctx: &AssistContext,\n-        file_id: FileId,\n-    ) -> Vec<(TextRange, String)> {\n-        let source_file = ctx.sema.parse(file_id);\n-\n-        let mut usages_to_be_processed_for_file = Vec::new();\n-        for usage in refs {\n-            if let Some(x) = self.get_usage_to_be_processed(&source_file, usage) {\n-                usages_to_be_processed_for_file.push(x);\n-            }\n-        }\n-\n-        usages_to_be_processed_for_file\n-    }\n-\n     fn get_usage_to_be_processed(\n         &self,\n         source_file: &SourceFile,\n@@ -380,36 +358,30 @@ impl Module {\n         let (mut replacements, record_field_parents, impls) =\n             get_replacements_for_visibilty_change(&mut self.body_items, false);\n \n-        let mut impl_items = Vec::new();\n-        for impl_ in impls {\n-            let mut this_impl_items = Vec::new();\n-            for node in impl_.syntax().descendants() {\n-                if let Some(item) = ast::Item::cast(node) {\n-                    this_impl_items.push(item);\n-                }\n-            }\n-\n-            impl_items.append(&mut this_impl_items);\n-        }\n+        let mut impl_items: Vec<ast::Item> = impls\n+            .into_iter()\n+            .flat_map(|impl_| impl_.syntax().descendants())\n+            .filter_map(ast::Item::cast)\n+            .collect();\n \n         let (mut impl_item_replacements, _, _) =\n             get_replacements_for_visibilty_change(&mut impl_items, true);\n \n         replacements.append(&mut impl_item_replacements);\n \n-        record_field_parents.into_iter().for_each(|x| {\n-            x.1.descendants().filter_map(ast::RecordField::cast).for_each(|desc| {\n+        for (_, field_owner) in record_field_parents {\n+            for desc in field_owner.descendants().filter_map(ast::RecordField::cast) {\n                 let is_record_field_present =\n                     record_fields.clone().into_iter().any(|x| x.to_string() == desc.to_string());\n                 if is_record_field_present {\n                     replacements.push((desc.visibility(), desc.syntax().clone()));\n                 }\n-            });\n-        });\n+            }\n+        }\n \n-        replacements.into_iter().for_each(|(vis, syntax)| {\n+        for (vis, syntax) in replacements {\n             add_change_vis(vis, syntax.first_child_or_token());\n-        });\n+        }\n     }\n \n     fn resolve_imports(\n@@ -420,8 +392,8 @@ impl Module {\n         let mut import_paths_to_be_removed: Vec<TextRange> = vec![];\n         let mut node_set: HashSet<String> = HashSet::new();\n \n-        self.body_items.clone().into_iter().for_each(|item| {\n-            item.syntax().descendants().for_each(|x| {\n+        for item in self.body_items.clone() {\n+            for x in item.syntax().descendants() {\n                 if let Some(name) = ast::Name::cast(x.clone()) {\n                     if let Some(name_classify) = NameClass::classify(&ctx.sema, &name) {\n                         //Necessary to avoid two same names going through\n@@ -473,8 +445,8 @@ impl Module {\n                         }\n                     }\n                 }\n-            });\n-        });\n+            }\n+        }\n \n         import_paths_to_be_removed\n     }\n@@ -495,8 +467,8 @@ impl Module {\n \n         let mut exists_inside_sel = false;\n         let mut exists_outside_sel = false;\n-        usage_res.clone().into_iter().for_each(|x| {\n-            let mut non_use_nodes_itr = (&x.1).iter().filter_map(|x| {\n+        for (_, refs) in usage_res.iter() {\n+            let mut non_use_nodes_itr = refs.iter().filter_map(|x| {\n                 if find_node_at_range::<ast::Use>(file.syntax(), x.range).is_none() {\n                     let path_opt = find_node_at_range::<ast::Path>(file.syntax(), x.range);\n                     return path_opt;\n@@ -514,7 +486,7 @@ impl Module {\n             if non_use_nodes_itr.any(|x| selection_range.contains_range(x.syntax().text_range())) {\n                 exists_inside_sel = true;\n             }\n-        });\n+        }\n \n         let source_exists_outside_sel_in_same_mod = does_source_exists_outside_sel_in_same_mod(\n             def,\n@@ -524,18 +496,14 @@ impl Module {\n             curr_file_id,\n         );\n \n-        let use_stmt_opt: Option<ast::Use> = usage_res.into_iter().find_map(|x| {\n-            let file_id = x.0;\n-            let mut use_opt: Option<ast::Use> = None;\n+        let use_stmt_opt: Option<ast::Use> = usage_res.into_iter().find_map(|(file_id, refs)| {\n             if file_id == curr_file_id {\n-                (&x.1).iter().for_each(|x| {\n-                    let node_opt: Option<ast::Use> = find_node_at_range(file.syntax(), x.range);\n-                    if let Some(node) = node_opt {\n-                        use_opt = Some(node);\n-                    }\n-                });\n+                refs.into_iter()\n+                    .rev()\n+                    .find_map(|fref| find_node_at_range(file.syntax(), fref.range))\n+            } else {\n+                None\n             }\n-            use_opt\n         });\n \n         let mut use_tree_str_opt: Option<Vec<ast::Path>> = None;\n@@ -811,7 +779,7 @@ fn get_replacements_for_visibilty_change(\n     let mut record_field_parents = Vec::new();\n     let mut impls = Vec::new();\n \n-    items.into_iter().for_each(|item| {\n+    for item in items {\n         if !is_clone_for_updated {\n             *item = item.clone_for_update();\n         }\n@@ -838,7 +806,7 @@ fn get_replacements_for_visibilty_change(\n             }\n             _ => (),\n         }\n-    });\n+    }\n \n     (replacements, record_field_parents, impls)\n }"}]}