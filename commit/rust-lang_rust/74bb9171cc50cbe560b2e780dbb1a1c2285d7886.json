{"sha": "74bb9171cc50cbe560b2e780dbb1a1c2285d7886", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YmI5MTcxY2M1MGNiZTU2MGIyZTc4MGRiYjFhMWMyMjg1ZDc4ODY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-01T14:03:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-05T09:03:56Z"}, "message": "add location table\n\nThis will be used in fact generation.", "tree": {"sha": "5dc4c78798a675bd10e24a1e702d946ca1304e1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dc4c78798a675bd10e24a1e702d946ca1304e1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74bb9171cc50cbe560b2e780dbb1a1c2285d7886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74bb9171cc50cbe560b2e780dbb1a1c2285d7886", "html_url": "https://github.com/rust-lang/rust/commit/74bb9171cc50cbe560b2e780dbb1a1c2285d7886", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74bb9171cc50cbe560b2e780dbb1a1c2285d7886/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53eb9e582f41d39e8f320c6e5a959605ec9daf5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/53eb9e582f41d39e8f320c6e5a959605ec9daf5f", "html_url": "https://github.com/rust-lang/rust/commit/53eb9e582f41d39e8f320c6e5a959605ec9daf5f"}], "stats": {"total": 132, "additions": 132, "deletions": 0}, "files": [{"sha": "e09f0ee9e2a20b273e33ee4ce0ebdcfa88c2a56b", "filename": "src/librustc_mir/borrow_check/location.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/74bb9171cc50cbe560b2e780dbb1a1c2285d7886/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bb9171cc50cbe560b2e780dbb1a1c2285d7886/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs?ref=74bb9171cc50cbe560b2e780dbb1a1c2285d7886", "patch": "@@ -0,0 +1,126 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)] // TODO -- will be used in a later commit, remove then\n+\n+use rustc::mir::{BasicBlock, Location, Mir};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+\n+/// Maps between a MIR Location, which identifies the a particular\n+/// statement within a basic block, to a \"rich location\", which\n+/// identifies at a finer granularity. In particular, we distinguish\n+/// the *start* of a statement and the *mid-point*. The mid-point is\n+/// the point *just* before the statement takes effect; in particular,\n+/// for an assignment `A = B`, it is the point where B is about to be\n+/// written into A. This mid-point is a kind of hack to work around\n+/// our inability to track the position information at sufficient\n+/// granularity through outlives relations; however, the rich location\n+/// table serves another purpose: it compresses locations from\n+/// multiple words into a single u32.\n+crate struct LocationTable {\n+    num_points: usize,\n+    statements_before_block: IndexVec<BasicBlock, usize>,\n+}\n+\n+newtype_index!(LocationIndex { DEBUG_FORMAT = \"LocationIndex({})\" });\n+\n+#[derive(Copy, Clone, Debug)]\n+crate enum RichLocation {\n+    Start(Location),\n+    Mid(Location),\n+}\n+\n+impl LocationTable {\n+    crate fn new(mir: &Mir<'_>) -> Self {\n+        let mut num_points = 0;\n+        let statements_before_block = mir.basic_blocks()\n+            .iter()\n+            .map(|block_data| {\n+                let v = num_points;\n+                num_points += (block_data.statements.len() + 1) * 2;\n+                v\n+            })\n+            .collect();\n+\n+        debug!(\n+            \"LocationTable(statements_before_block={:#?})\",\n+            statements_before_block\n+        );\n+        debug!(\"LocationTable: num_points={:#?}\", num_points);\n+\n+        Self {\n+            num_points,\n+            statements_before_block,\n+        }\n+    }\n+\n+    #[allow(dead_code)] // TODO\n+    crate fn all_points(&self) -> impl Iterator<Item = LocationIndex> {\n+        (0..self.num_points).map(LocationIndex::new)\n+    }\n+\n+    crate fn start_index(&self, location: Location) -> LocationIndex {\n+        let Location {\n+            block,\n+            statement_index,\n+        } = location;\n+        let start_index = self.statements_before_block[block];\n+        LocationIndex::new(start_index + statement_index * 2)\n+    }\n+\n+    crate fn mid_index(&self, location: Location) -> LocationIndex {\n+        let Location {\n+            block,\n+            statement_index,\n+        } = location;\n+        let start_index = self.statements_before_block[block];\n+        LocationIndex::new(start_index + statement_index * 2 + 1)\n+    }\n+\n+    crate fn to_location(&self, index: LocationIndex) -> RichLocation {\n+        let point_index = index.index();\n+\n+        // Find the basic block. We have a vector with the\n+        // starting index of the statement in each block. Imagine\n+        // we have statement #22, and we have a vector like:\n+        //\n+        // [0, 10, 20]\n+        //\n+        // In that case, this represents point_index 2 of\n+        // basic block BB2. We know this because BB0 accounts for\n+        // 0..10, BB1 accounts for 11..20, and BB2 accounts for\n+        // 20...\n+        //\n+        // To compute this, we could do a binary search, but\n+        // because I am lazy we instead iterate through to find\n+        // the last point where the \"first index\" (0, 10, or 20)\n+        // was less than the statement index (22). In our case, this will\n+        // be (BB2, 20).\n+        let (block, &first_index) = self.statements_before_block\n+            .iter_enumerated()\n+            .filter(|(_, first_index)| **first_index <= point_index)\n+            .last()\n+            .unwrap();\n+\n+        let statement_index = (point_index - first_index) / 2;\n+        if index.is_start() {\n+            RichLocation::Start(Location { block, statement_index })\n+        } else {\n+            RichLocation::Mid(Location { block, statement_index })\n+        }\n+    }\n+}\n+\n+impl LocationIndex {\n+    fn is_start(&self) -> bool {\n+        // even indices are start points; odd indices are mid points\n+        (self.index() % 2) == 0\n+    }\n+}"}, {"sha": "3e3f510e308c330b82fbd16e524aa2e033c2ce2a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74bb9171cc50cbe560b2e780dbb1a1c2285d7886/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bb9171cc50cbe560b2e780dbb1a1c2285d7886/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=74bb9171cc50cbe560b2e780dbb1a1c2285d7886", "patch": "@@ -50,12 +50,14 @@ use std::iter;\n \n use self::borrow_set::{BorrowSet, BorrowData};\n use self::flows::Flows;\n+use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n crate mod borrow_set;\n mod error_reporting;\n mod flows;\n+mod location;\n crate mod place_ext;\n mod prefixes;\n \n@@ -110,6 +112,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let mut mir: Mir<'tcx> = input_mir.clone();\n     let free_regions = nll::replace_regions_in_mir(infcx, def_id, param_env, &mut mir);\n     let mir = &mir; // no further changes\n+    let location_table = &LocationTable::new(mir);\n \n     let move_data: MoveData<'tcx> = match MoveData::gather_moves(mir, tcx) {\n         Ok(move_data) => move_data,\n@@ -199,6 +202,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         def_id,\n         free_regions,\n         mir,\n+        location_table,\n         param_env,\n         &mut flow_inits,\n         &mdpe.move_data,"}, {"sha": "80ad3ecb9f85ffc1e150e5856fc7dec8d37a94ea", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bb9171cc50cbe560b2e780dbb1a1c2285d7886/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bb9171cc50cbe560b2e780dbb1a1c2285d7886/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=74bb9171cc50cbe560b2e780dbb1a1c2285d7886", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use borrow_check::borrow_set::BorrowSet;\n+use borrow_check::location::LocationTable;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{ClosureRegionRequirements, ClosureOutlivesSubject, Mir};\n use rustc::infer::InferCtxt;\n@@ -70,6 +71,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n+    _location_table: &LocationTable,\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,"}]}