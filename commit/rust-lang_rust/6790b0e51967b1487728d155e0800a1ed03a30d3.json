{"sha": "6790b0e51967b1487728d155e0800a1ed03a30d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3OTBiMGU1MTk2N2IxNDg3NzI4ZDE1NWUwODAwYTFlZDAzYTMwZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-11T18:31:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-11T18:31:59Z"}, "message": "Auto merge of #24328 - Manishearth:rollup, r=Manishearth", "tree": {"sha": "51c11cb951751d408b68c401a487c5f2fbe26157", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51c11cb951751d408b68c401a487c5f2fbe26157"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6790b0e51967b1487728d155e0800a1ed03a30d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6790b0e51967b1487728d155e0800a1ed03a30d3", "html_url": "https://github.com/rust-lang/rust/commit/6790b0e51967b1487728d155e0800a1ed03a30d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6790b0e51967b1487728d155e0800a1ed03a30d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67a8f61730418768f07d8ed0f9735a31d0c5d84d", "url": "https://api.github.com/repos/rust-lang/rust/commits/67a8f61730418768f07d8ed0f9735a31d0c5d84d", "html_url": "https://github.com/rust-lang/rust/commit/67a8f61730418768f07d8ed0f9735a31d0c5d84d"}, {"sha": "0a2885ad944aa1a5f60a72a7551b1b45367637f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2885ad944aa1a5f60a72a7551b1b45367637f6", "html_url": "https://github.com/rust-lang/rust/commit/0a2885ad944aa1a5f60a72a7551b1b45367637f6"}], "stats": {"total": 3121, "additions": 1592, "deletions": 1529}, "files": [{"sha": "8d3a6ec39864c7256d4cc4d10a69a311c2bf0455", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 178, "deletions": 25, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,39 +1,192 @@\n % The Rust Programming Language\n \n-Welcome! This book will teach you about [the Rust Programming\n-Language](http://www.rust-lang.org/). Rust is a modern systems programming\n-language focusing on safety and speed. It accomplishes these goals by being\n-memory safe without using garbage collection.\n+Welcome! This book will teach you about the [Rust Programming Language][rust].\n+Rust is a systems programming language focused on three goals: safety, speed,\n+and concurrency. It maintains these goals without having a garbage collector,\n+making it a useful language for a number of use cases other languages aren\u2019t\n+good at: embedding in other languages, programs with specific space and time\n+requirements, and writing low-level code, like device drivers and operating\n+systems. It improves on current languages targeting this space by having a\n+number of compile-time safety checks that produce no runtime overhead, while\n+eliminating all data races. Rust also aims to achieve \u2018zero-cost abstrations\u2019\n+even though some of these abstractions feel like those of a high-level\n+language. Even then, Rust still allows precise control like a low-level\n+language would.\n \n-\"The Rust Programming Language\" is split into three sections, which you can\n-navigate through the menu on the left.\n+[rust]: http://rust-lang.org\n \n-<h2 class=\"section-header\"><a href=\"basic.html\">Basics</a></h2>\n+\u201cThe Rust Programming Language\u201d is split into seven sections. This introduction\n+is the first. After this:\n \n-This section is a linear introduction to the basic syntax and semantics of\n-Rust. It has individual sections on each part of Rust's syntax.\n+* [Getting started][gs] - Set up your computer for Rust development.\n+* [Learn Rust][lr] - Learn Rust programming through small projects.\n+* [Effective Rust][er] - Higher-level concepts for writing excellent Rust code.\n+* [Syntax and Semantics][ss] - Each bit of Rust, broken down into small chunks.\n+* [Nightly Rust][nr] - Cutting-edge features that aren\u2019t in stable builds yet.\n+* [Glossary][gl] - A reference of terms used in the book.\n \n-After reading \"Basics,\" you will have a good foundation to learn more about\n-Rust, and can write very simple programs.\n+[gs]: getting-started.html\n+[lr]: learn-rust.html\n+[er]: effective-rust.html\n+[ss]: syntax-and-semantics.html\n+[nr]: nightly-rust.html\n+[gl]: glossary.html\n \n-<h2 class=\"section-header\"><a href=\"intermediate.html\">Intermediate</a></h2>\n+After reading this introduction, you\u2019ll want to dive into either \u2018Learn Rust\u2019\n+or \u2018Syntax and Semantics\u2019, depending on your preference: \u2018Learn Rust\u2019 if you\n+want to dive in with a project, or \u2018Syntax and Semantics\u2019 if you prefer to\n+start small, and learn a single concept thoroughly before moving onto the next.\n+Copious cross-linking connects these parts together.\n \n-This section contains individual chapters, which are self-contained. They focus\n-on specific topics, and can be read in any order.\n+## A brief introduction to Rust\n \n-After reading \"Intermediate,\" you will have a solid understanding of Rust,\n-and will be able to understand most Rust code and write more complex programs.\n+Is Rust a language you might be interested in? Let\u2019s examine a few small code\n+samples to show off a few of its strengths.\n \n-<h2 class=\"section-header\"><a href=\"advanced.html\">Advanced</a></h2>\n+The main concept that makes Rust unique is called \u2018ownership\u2019. Consider this\n+small example:\n \n-In a similar fashion to \"Intermediate,\" this section is full of individual,\n-deep-dive chapters, which stand alone and can be read in any order. These\n-chapters focus on Rust's most complex features.\n+```rust\n+fn main() {\n+    let mut x = vec![\"Hello\", \"world\"];\n+}\n+```\n \n-<h2 class=\"section-header\"><a href=\"unstable.html\">Unstable</a></h2>\n+This program makes a [variable binding][var] named `x`. The value of this\n+binding is a `Vec<T>`, a \u2018vector\u2019, that we create through a [macro][macro]\n+defined in the standard library. This macro is called `vec`, and we invoke\n+macros with a `!`. This follows a general principle of Rust: make things\n+explicit. Macros can do significantly more complicated things than function\n+calls, and so they\u2019re visually distinct. The `!` also helps with parsing,\n+making tooling easier to write, which is also important.\n \n-In a similar fashion to \"Intermediate,\" this section is full of individual,\n-deep-dive chapters, which stand alone and can be read in any order.\n+We used `mut` to make `x` mutable: bindings are immutable by default in Rust.\n+We\u2019ll be mutating this vector later in the example.\n \n-This chapter contains things that are only available on the nightly channel of\n-Rust.\n+It\u2019s also worth noting that we didn\u2019t need a type annotation here: while Rust\n+is statically typed, we didn\u2019t need to explicitly annotate the type. Rust has\n+type inference to balance out the power of static typing with the verbosity of\n+annotating types.\n+\n+Rust prefers stack allocation to heap allocation: `x` is placed directly on the\n+stack. However, the `Vec<T>` type allocates space for the elements of the\n+vector on the heap. If you\u2019re not familiar with this distinction, you can\n+ignore it for now, or check out [\u2018The Stack and the Heap\u2019][heap]. As a systems\n+programming language, Rust gives you the ability to control how your memory is\n+allocated, but when we\u2019re getting started, it\u2019s less of a big deal.\n+\n+[var]: variable-bindings.html\n+[macro]: macros.html\n+[heap]: the-stack-and-the-heap.html\n+\n+Earlier, we mentioned that \u2018ownership\u2019 is the key new concept in Rust. In Rust\n+parlance, `x` is said to \u2018own\u2019 the vector. This means that when `x` goes out of\n+scope, the vector\u2019s memory will be de-allocated. This is done deterministically\n+by the Rust compiler, rather than through a mechanism such as a garbage\n+collector. In other words, in Rust, you don\u2019t call functions like `malloc` and\n+`free` yourself: the compiler statically determines when you need to allocate\n+or deallocate memory, and inserts those calls itself. To err is to be human,\n+but compilers never forget.\n+\n+Let\u2019s add another line to our example:\n+\n+```rust\n+fn main() {\n+    let mut x = vec![\"Hello\", \"world\"];\n+\n+    let y = &x[0];\n+}\n+```\n+\n+We\u2019ve introduced another binding, `y`. In this case, `y` is a \u2018reference\u2019 to\n+the first element of the vector. Rust\u2019s references are similar to pointers in\n+other languages, but with additional compile-time safety checks. References\n+interact with the ownership system by [\u2018borrowing\u2019][borrowing] what they point\n+to, rather than owning it. The difference is, when the reference goes out of\n+scope, it will not deallocate the underlying memory. If it did, we\u2019d\n+de-allocate twice, which is bad!\n+\n+[borrowing]: references-and-borrowing.html\n+\n+Let\u2019s add a third line. It looks innocent enough, but causes a compiler error:\n+\n+```rust,ignore\n+fn main() {\n+    let mut x = vec![\"Hello\", \"world\"];\n+\n+    let y = &x[0];\n+\n+    x.push(\"foo\");\n+}\n+```\n+\n+`push` is a method on vectors that appends another element to the end of the\n+vector. When we try to compile this program, we get an error:\n+\n+```text\n+error: cannot borrow `x` as mutable because it is also borrowed as immutable\n+    x.push(4);\n+    ^\n+note: previous borrow of `x` occurs here; the immutable borrow prevents\n+subsequent moves or mutable borrows of `x` until the borrow ends\n+    let y = &x[0];\n+             ^\n+note: previous borrow ends here\n+fn main() {\n+\n+}\n+^\n+```\n+\n+Whew! The Rust compiler gives quite detailed errors at times, and this is one\n+of those times. As the error explains, while we made our binding mutable, we\n+still cannot call `push`. This is because we already have a reference to an\n+element of the vector, `y`. Mutating something while another reference exists\n+is dangerous, because we may invalidate the reference. In this specific case,\n+when we create the vector, we may have only allocated space for three elements.\n+Adding a fourth would mean allocating a new chunk of memory for all those elements,\n+copying the old values over, and updating the internal pointer to that memory.\n+That all works just fine. The problem is that `y` wouldn\u2019t get updated, and so\n+we\u2019d have a \u2018dangling pointer\u2019. That\u2019s bad. Any use of `y` would be an error in\n+this case, and so the compiler has caught this for us.\n+\n+So how do we solve this problem? There are two approaches we can take. The first\n+is making a copy rather than using a reference:\n+\n+```rust\n+fn main() {\n+    let mut x = vec![\"Hello\", \"world\"];\n+\n+    let y = x[0].clone();\n+\n+    x.push(\"foo\");\n+}\n+```\n+\n+Rust has [move semantics][move] by default, so if we want to make a copy of some\n+data, we call the `clone()` method. In this example, `y` is no longer a reference\n+to the vector stored in `x`, but a copy of its first element, `\"hello\"`. Now\n+that we don\u2019t have a reference, our `push()` works just fine.\n+\n+[move]: move-semantics.html\n+\n+If we truly want a reference, we need the other option: ensure that our reference\n+goes out of scope before we try to do the mutation. That looks like this:\n+\n+```rust\n+fn main() {\n+    let mut x = vec![\"Hello\", \"world\"];\n+\n+    {\n+        let y = &x[0];\n+    }\n+\n+    x.push(\"foo\");\n+}\n+```\n+\n+We created an inner scope with an additional set of curly braces. `y` will go out of\n+scope before we call `push()`, and so we\u2019re all good.\n+\n+This concept of ownership isn\u2019t just good for preventing danging pointers, but an\n+entire set of related problems, like iterator invalidation, concurrency, and more."}, {"sha": "f2d1666048d89773cb3a5745616edc4e0dc7d30f", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -7,47 +7,45 @@\n * [Learn Rust](learn-rust.md)\n * [Effective Rust](effective-rust.md)\n     * [The Stack and the Heap](the-stack-and-the-heap.md)\n-    * [`Debug` and `Display`](debug-and-display.md)\n+    * [Debug and Display](debug-and-display.md)\n     * [Testing](testing.md)\n     * [Documentation](documentation.md)\n     * [Iterators](iterators.md)\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n     * [FFI](ffi.md)\n-    * [`Deref` coercions](deref-coercions.md)\n+    * [Deref coercions](deref-coercions.md)\n * [Syntax and Semantics](syntax-and-semantics.md)\n     * [Variable Bindings](variable-bindings.md)\n-    * [Primitive Types](primitive-types.md)\n     * [Functions](functions.md)\n+    * [Primitive Types](primitive-types.md)\n     * [Comments](comments.md)\n-    * [Structs](structs.md)\n-    * [Mutability](mutability.md)\n-    * [Method Syntax](method-syntax.md)\n-    * [Enums](enums.md)\n-    * [`if`](if.md)\n-    * [Match](match.md)\n-    * [Patterns](patterns.md)\n-    * [`for` loops](for-loops.md)\n-    * [`while` loops](while-loops.md)\n+    * [if](if.md)\n+    * [for loops](for-loops.md)\n+    * [while loops](while-loops.md)\n     * [Ownership](ownership.md)\n     * [References and Borrowing](references-and-borrowing.md)\n     * [Lifetimes](lifetimes.md)\n+    * [Mutability](mutability.md)\n     * [Move semantics](move-semantics.md)\n+    * [Enums](enums.md)\n+    * [Match](match.md)\n+    * [Patterns](patterns.md)\n+    * [Structs](structs.md)\n+    * [Method Syntax](method-syntax.md)\n     * [Drop](drop.md)\n     * [Vectors](vectors.md)\n-    * [Arrays](arrays.md)\n-    * [Slices](slices.md)\n     * [Strings](strings.md)\n     * [Traits](traits.md)\n     * [Operators and Overloading](operators-and-overloading.md)\n     * [Generics](generics.md)\n+    * [if let](if-let.md)\n     * [Trait Objects](trait-objects.md)\n     * [Closures](closures.md)\n     * [Universal Function Call Syntax](ufcs.md)\n     * [Crates and Modules](crates-and-modules.md)\n     * [`static`](static.md)\n     * [`const`](const.md)\n-    * [Tuples](tuples.md)\n     * [Tuple Structs](tuple-structs.md)\n     * [Attributes](attributes.md)\n     * [Conditional Compilation](conditional-compilation.md)\n@@ -66,4 +64,6 @@\n     * [Link args](link-args.md)\n     * [Benchmark Tests](benchmark-tests.md)\n     * [Box Syntax and Patterns](box-syntax-and-patterns.md)\n+    * [Slice Patterns](slice-patterns.md)\n * [Glossary](glossary.md)\n+* [Academic Research](academic-research.md)"}, {"sha": "f4f066fb3dfe3c5243f458bce92f2c3e9ef2d790", "filename": "src/doc/trpl/academic-research.md", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Facademic-research.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Facademic-research.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Facademic-research.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,46 @@\n+% Academic Research\n+\n+An incomplete list of papers that have had some influence in Rust.\n+\n+Recommended for inspiration and a better understanding of Rust's background.\n+\n+### Type system\n+\n+* [Region based memory management in Cyclone](http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handouts/cyclone-regions.pdf)\n+* [Safe manual memory management in Cyclone](http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf)\n+* [Typeclasses: making ad-hoc polymorphism less ad hoc](http://www.ps.uni-sb.de/courses/typen-ws99/class.ps.gz)\n+* [Macros that work together](https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf)\n+* [Traits: composable units of behavior](http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf)\n+* [Alias burying](http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps) - We tried something similar and abandoned it.\n+* [External uniqueness is unique enough](http://www.computingscience.nl/research/techreps/repo/CS-2002/2002-048.pdf)\n+* [Uniqueness and Reference Immutability for Safe Parallelism](https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf)\n+* [Region Based Memory Management](http://www.cs.ucla.edu/~palsberg/tba/papers/tofte-talpin-iandc97.pdf)\n+\n+### Concurrency\n+\n+* [Singularity: rethinking the software stack](https://research.microsoft.com/pubs/69431/osr2007_rethinkingsoftwarestack.pdf)\n+* [Language support for fast and reliable message passing in singularity OS](https://research.microsoft.com/pubs/67482/singsharp.pdf)\n+* [Scheduling multithreaded computations by work stealing](http://supertech.csail.mit.edu/papers/steal.pdf)\n+* [Thread scheduling for multiprogramming multiprocessors](http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf)\n+* [The data locality of work stealing](http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf)\n+* [Dynamic circular work stealing deque](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&rep=rep1&type=pdf) - The Chase/Lev deque\n+* [Work-first and help-first scheduling policies for async-finish task parallelism](http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf) - More general than fully-strict work stealing\n+* [A Java fork/join calamity](http://www.coopsoft.com/ar/CalamityArticle.html) - critique of Java's fork/join library, particularly its application of work stealing to non-strict computation\n+* [Scheduling techniques for concurrent systems](http://www.ece.rutgers.edu/%7Eparashar/Classes/ece572-papers/05/ps-ousterhout.pdf)\n+* [Contention aware scheduling](http://www.blagodurov.net/files/a8-blagodurov.pdf)\n+* [Balanced work stealing for time-sharing multicores](http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-12-1.pdf)\n+* [Three layer cake](http://www.upcrc.illinois.edu/workshops/paraplop10/papers/paraplop10_submission_8.pdf)\n+* [Non-blocking steal-half work queues](http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pdf)\n+* [Reagents: expressing and composing fine-grained concurrency](http://www.mpi-sws.org/~turon/reagents.pdf)\n+* [Algorithms for scalable synchronization of shared-memory multiprocessors](https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf)\n+\n+### Others\n+\n+* [Crash-only software](https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf)\n+* [Composing High-Performance Memory Allocators](http://people.cs.umass.edu/~emery/pubs/berger-pldi2001.pdf)\n+* [Reconsidering Custom Memory Allocation](http://people.cs.umass.edu/~emery/pubs/berger-oopsla2002.pdf)\n+\n+### Papers *about* Rust\n+\n+* [GPU programming in Rust](http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf)\n+* [Parallel closures: a new twist on an old idea](https://www.usenix.org/conference/hotpar12/parallel-closures-new-twist-old-idea) - not exactly about rust, but by nmatsakis"}, {"sha": "a6ecac962d60de4acb58795e19bcb03b0a98ec7e", "filename": "src/doc/trpl/arrays.md", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/67a8f61730418768f07d8ed0f9735a31d0c5d84d/src%2Fdoc%2Ftrpl%2Farrays.md", "raw_url": "https://github.com/rust-lang/rust/raw/67a8f61730418768f07d8ed0f9735a31d0c5d84d/src%2Fdoc%2Ftrpl%2Farrays.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays.md?ref=67a8f61730418768f07d8ed0f9735a31d0c5d84d", "patch": "@@ -1,48 +0,0 @@\n-% Arrays\n-\n-Like many programming languages, Rust has list types to represent a sequence of\n-things. The most basic is the *array*, a fixed-size list of elements of the\n-same type. By default, arrays are immutable.\n-\n-```{rust}\n-let a = [1, 2, 3]; // a: [i32; 3]\n-let mut m = [1, 2, 3]; // mut m: [i32; 3]\n-```\n-\n-There's a shorthand for initializing each element of an array to the same\n-value. In this example, each element of `a` will be initialized to `0`:\n-\n-```{rust}\n-let a = [0; 20]; // a: [i32; 20]\n-```\n-\n-Arrays have type `[T; N]`. We'll talk about this `T` notation later, when we\n-cover generics.\n-\n-You can get the number of elements in an array `a` with `a.len()`, and use\n-`a.iter()` to iterate over them with a for loop. This code will print each\n-number in order:\n-\n-```{rust}\n-let a = [1, 2, 3];\n-\n-println!(\"a has {} elements\", a.len());\n-for e in a.iter() {\n-    println!(\"{}\", e);\n-}\n-```\n-\n-You can access a particular element of an array with *subscript notation*:\n-\n-```{rust}\n-let names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str; 3]\n-\n-println!(\"The second name is: {}\", names[1]);\n-```\n-\n-Subscripts start at zero, like in most programming languages, so the first name\n-is `names[0]` and the second name is `names[1]`. The above example prints\n-`The second name is: Brian`. If you try to use a subscript that is not in the\n-array, you will get an error: array access is bounds-checked at run-time. Such\n-errant access is the source of many bugs in other systems programming\n-languages."}, {"sha": "918f4c440ac32d5901d65a8d9710d08c4403f062", "filename": "src/doc/trpl/debug-and-display.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,3 +1,3 @@\n-% `Debug` and `Display`\n+% Debug and Display\n \n Coming soon!"}, {"sha": "582ed3b7e65c56a256c60f8a76e0fc3629328f5d", "filename": "src/doc/trpl/effective-rust.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Feffective-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Feffective-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Feffective-rust.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1 +1,8 @@\n % Effective Rust\n+\n+So you\u2019ve learned how to write some Rust code. But there\u2019s a difference between\n+writing *any* Rust code and writing *good* Rust code.\n+\n+This section consists of relatively independent tutorials which show you how to\n+take your Rust to the next level. Common patterns and standard library features\n+will be introduced. Read these sections in any order of your choosing."}, {"sha": "1e3f2fa54bcc6c292bef7912c1ea1699b8603dc5", "filename": "src/doc/trpl/for-loops.md", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Ffor-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Ffor-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffor-loops.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,44 +1,43 @@\n-% `for` Loops\n+% for Loops\n \n-The `for` loop is used to loop a particular number of times. Rust's `for` loops\n-work a bit differently than in other systems languages, however. Rust's `for`\n-loop doesn't look like this \"C-style\" `for` loop:\n+The `for` loop is used to loop a particular number of times. Rust\u2019s `for` loops\n+work a bit differently than in other systems languages, however. Rust\u2019s `for`\n+loop doesn\u2019t look like this \u201cC-style\u201d `for` loop:\n \n-```{c}\n+```c\n for (x = 0; x < 10; x++) {\n     printf( \"%d\\n\", x );\n }\n ```\n \n Instead, it looks like this:\n \n-```{rust}\n+```rust\n for x in 0..10 {\n     println!(\"{}\", x); // x: i32\n }\n ```\n \n In slightly more abstract terms,\n \n-```{ignore}\n+```ignore\n for var in expression {\n     code\n }\n ```\n \n-The expression is an iterator, which we will discuss in more depth later in the\n-guide. The iterator gives back a series of elements. Each element is one\n-iteration of the loop. That value is then bound to the name `var`, which is\n-valid for the loop body. Once the body is over, the next value is fetched from\n-the iterator, and we loop another time. When there are no more values, the\n-`for` loop is over.\n+The expression is an [iterator][iterator]. The iterator gives back a series of\n+elements. Each element is one iteration of the loop. That value is then bound\n+to the name `var`, which is valid for the loop body. Once the body is over, the\n+next value is fetched from the iterator, and we loop another time. When there\n+are no more values, the `for` loop is over.\n+\n+[iterator]: iterators.html\n \n In our example, `0..10` is an expression that takes a start and an end position,\n and gives an iterator over those values. The upper bound is exclusive, though,\n so our loop will print `0` through `9`, not `10`.\n \n-Rust does not have the \"C-style\" `for` loop on purpose. Manually controlling\n+Rust does not have the \u201cC-style\u201d `for` loop on purpose. Manually controlling\n each element of the loop is complicated and error prone, even for experienced C\n developers.\n-\n-We'll talk more about `for` when we cover *iterators*, later in the Guide."}, {"sha": "555d40e65970618b2ed122362da5a15ec8159599", "filename": "src/doc/trpl/getting-started.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgetting-started.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1 +1,5 @@\n % Getting Started\n+\n+This first section of the book will get you going with Rust and its tooling.\n+First, we\u2019ll install Rust. Then: the classic \u2018Hello World\u2019 program. Finally,\n+we\u2019ll talk about Cargo, Rust\u2019s build system and package manager."}, {"sha": "8d8b17343343e08ed21e7cfbb3d6533650415622", "filename": "src/doc/trpl/hello-cargo.md", "status": "modified", "additions": 79, "deletions": 49, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-cargo.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,26 +1,27 @@\n % Hello, Cargo!\n \n-[Cargo](http://crates.io) is a tool that Rustaceans use to help manage their\n-Rust projects. Cargo is currently in a pre-1.0 state, just like Rust, and so it\n-is still a work in progress. However, it is already good enough to use for many\n-Rust projects, and so it is assumed that Rust projects will use Cargo from the\n-beginning.\n+[Cargo][cratesio] is a tool that Rustaceans use to help manage their Rust\n+projects. Cargo is currently in a pre-1.0 state, and so it is still a work in\n+progress. However, it is already good enough to use for many Rust projects, and\n+so it is assumed that Rust projects will use Cargo from the beginning.\n+\n+[cratesio]: https://doc.crates.io\n \n Cargo manages three things: building your code, downloading the dependencies\n your code needs, and building those dependencies. At first, your\n-program doesn't have any dependencies, so we'll only be using the first part of\n-its functionality. Eventually, we'll add more. Since we started off by using\n+program doesn\u2019t have any dependencies, so we\u2019ll only be using the first part of\n+its functionality. Eventually, we\u2019ll add more. Since we started off by using\n Cargo, it'll be easy to add later.\n \n-If you installed Rust via the official installers you will also have\n-Cargo. If you installed Rust some other way, you may want to [check\n-the Cargo\n-README](https://github.com/rust-lang/cargo#installing-cargo-from-nightlies)\n-for specific instructions about installing it.\n+If you installed Rust via the official installers you will also have Cargo. If\n+you installed Rust some other way, you may want to [check the Cargo\n+README][cargoreadme] for specific instructions about installing it.\n+\n+[cargoreadme]: https://github.com/rust-lang/cargo#installing-cargo-from-nightlies\n \n ## Converting to Cargo\n \n-Let's convert Hello World to Cargo.\n+Let\u2019s convert Hello World to Cargo.\n \n To Cargo-ify our project, we need to do two things: Make a `Cargo.toml`\n configuration file, and put our source file in the right place. Let's\n@@ -52,14 +53,9 @@ Put this inside:\n name = \"hello_world\"\n version = \"0.0.1\"\n authors = [ \"Your name <you@example.com>\" ]\n-\n-[[bin]]\n-\n-name = \"hello_world\"\n ```\n \n-This file is in the [TOML](https://github.com/toml-lang/toml) format. Let's let\n-it explain itself to you:\n+This file is in the [TOML][toml] format. Let\u2019s let it explain itself to you:\n \n > TOML aims to be a minimal configuration file format that's easy to read due\n > to obvious semantics. TOML is designed to map unambiguously to a hash table.\n@@ -68,10 +64,7 @@ it explain itself to you:\n \n TOML is very similar to INI, but with some extra goodies.\n \n-Anyway, there are two *tables* in this file: `package` and `bin`. The first\n-tells Cargo metadata about your package. The second tells Cargo that we're\n-interested in building a binary, not a library (though we could do both!), as\n-well as what it is named.\n+[toml]: https://github.com/toml-lang/toml\n \n Once you have this file in place, we should be ready to build! Try this:\n \n@@ -83,13 +76,32 @@ Hello, world!\n ```\n \n Bam! We build our project with `cargo build`, and run it with\n-`./target/debug/hello_world`. This hasn't bought us a whole lot over our simple use\n-of `rustc`, but think about the future: when our project has more than one\n-file, we would need to call `rustc` more than once and pass it a bunch of options to\n-tell it to build everything together. With Cargo, as our project grows, we can\n-just `cargo build`, and it'll work the right way. When your project is finally\n-ready for release, you can use `cargo build --release` to compile your crates with\n-optimizations.\n+`./target/debug/hello_world`. We can do both in one step with `cargo run`:\n+\n+```bash\n+$ cargo run\n+     Running `target/debug/hello_world`\n+Hello, world!\n+```\n+\n+Notice that we didn\u2019t re-build the project this time. Cargo figured out that\n+we hadn\u2019t changed the source file, and so it just ran the binary. If we had\n+made a modification, we would have seen it do both:\n+\n+```bash\n+$ cargo build\n+   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)\n+     Running `target/debug/hello_world`\n+Hello, world!\n+```\n+\n+This hasn\u2019t bought us a whole lot over our simple use of `rustc`, but think\n+about the future: when our project gets more complex, we would need to do more\n+things to get all of the parts to properly compile. With Cargo, as our project\n+grows, we can just `cargo build`, and it\u2019ll work the right way.\n+\n+When your project is finally ready for release, you can use\n+`cargo build --release` to compile your project with optimizations.\n \n You'll also notice that Cargo has created a new file: `Cargo.lock`.\n \n@@ -100,27 +112,34 @@ version = \"0.0.1\"\n ```\n \n This file is used by Cargo to keep track of dependencies in your application.\n-Right now, we don't have any, so it's a bit sparse. You won't ever need\n+Right now, we don\u2019t have any, so it\u2019s a bit sparse. You won't ever need\n to touch this file yourself, just let Cargo handle it.\n \n-That's it! We've successfully built `hello_world` with Cargo. Even though our\n-program is simple, it's using much of the real tooling that you'll use for the\n-rest of your Rust career.\n+That\u2019s it! We\u2019ve successfully built `hello_world` with Cargo. Even though our\n+program is simple, it\u2019s using much of the real tooling that you\u2019ll use for the\n+rest of your Rust career. You can expect to do this to get started with\n+virtually all Rust projects:\n+\n+```bash\n+$ git clone someurl.com/foo\n+$ cd foo\n+$ cargo build\n+```\n \n ## A New Project\n \n-You don't have to go through this whole process every time you want to start a new\n-project! Cargo has the ability to make a bare-bones project directory in which you\n-can start developing right away.\n+You don\u2019t have to go through this whole process every time you want to start a\n+new project! Cargo has the ability to make a bare-bones project directory in\n+which you can start developing right away.\n \n To start a new project with Cargo, use `cargo new`:\n \n ```bash\n $ cargo new hello_world --bin\n ```\n \n-We're passing `--bin` because we're making a binary program: if we\n-were making a library, we'd leave it off.\n+We\u2019re passing `--bin` because we're making a binary program: if we were making\n+a library, we'd leave it off.\n \n Let's check out what Cargo has generated for us:\n \n@@ -135,10 +154,10 @@ $ tree .\n 1 directory, 2 files\n ```\n \n-If you don't have the `tree` command, you can probably get it from your distro's package\n-manager. It's not necessary, but it's certainly useful.\n+If you don't have the `tree` command, you can probably get it from your\n+distribution\u2019s package manager. It\u2019s not necessary, but it\u2019s certainly useful.\n \n-This is all we need to get started. First, let's check out `Cargo.toml`:\n+This is all we need to get started. First, let\u2019s check out `Cargo.toml`:\n \n ```toml\n [package]\n@@ -148,21 +167,32 @@ version = \"0.0.1\"\n authors = [\"Your Name <you@example.com>\"]\n ```\n \n-Cargo has populated this file with reasonable defaults based off the arguments you gave\n-it and your `git` global configuration. You may notice that Cargo has also initialized\n-the `hello_world` directory as a `git` repository.\n+Cargo has populated this file with reasonable defaults based off the arguments\n+you gave it and your `git` global configuration. You may notice that Cargo has\n+also initialized the `hello_world` directory as a `git` repository.\n \n-Here's what's in `src/main.rs`:\n+Here\u2019s what\u2019s in `src/main.rs`:\n \n ```rust\n fn main() {\n     println!(\"Hello, world!\");\n }\n ```\n \n-Cargo has generated a \"Hello World!\" for us, and you're ready to start coding! A\n-much more in-depth guide to Cargo can be found [here](http://doc.crates.io/guide.html).\n+Cargo has generated a \"Hello World!\" for us, and you\u2019re ready to start coding! Cargo\n+has its own [guide][guide] which covers Cargo\u2019s features in much more depth.\n \n-Now that you've got the tools down, let's actually learn more about the Rust\n+[guide]: http://doc.crates.io/guide.html\n+\n+Now that you\u2019ve got the tools down, let\u2019s actually learn more about the Rust\n language itself. These are the basics that will serve you well through the rest\n of your time with Rust.\n+\n+You have two options: Dive into a project with \u2018[Learn Rust][learnrust]\u2019, or\n+start from the bottom and work your way up with \u2018[Syntax and\n+Semantics][syntax]\u2019. More experienced systems programmers will probably prefer\n+\u2018Learn Rust\u2019, while those from dynamic backgrounds may enjoy either. Different\n+people learn differently! Choose whatever\u2019s right for you.\n+\n+[learnrust]: learn-rust.html\n+[syntax]: syntax-and-semantics.html"}, {"sha": "6c320d27ba6548f234531dbde47ffb4c7abb6f1b", "filename": "src/doc/trpl/hello-world.md", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fhello-world.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fhello-world.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-world.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,9 +1,9 @@\n % Hello, world!\n \n-Now that you have Rust installed, let's write your first Rust program. It's\n+Now that you have Rust installed, let\u2019s write your first Rust program. It\u2019s\n traditional to make your first program in any new language one that prints the\n-text \"Hello, world!\" to the screen. The nice thing about starting with such a\n-simple program is that you can verify that your compiler isn't just installed,\n+text \u201cHello, world!\u201d to the screen. The nice thing about starting with such a\n+simple program is that you can verify that your compiler isn\u2019t just installed,\n but also working properly. And printing information to the screen is a pretty\n common thing to do.\n \n@@ -12,152 +12,152 @@ to make a `projects` directory in my home directory, and keep all my projects\n there. Rust does not care where your code lives.\n \n This actually leads to one other concern we should address: this guide will\n-assume that you have basic familiarity with the command line. Rust does not\n-require that you know a whole ton about the command line, but until the\n-language is in a more finished state, IDE support is spotty. Rust makes no\n-specific demands on your editing tooling, or where your code lives.\n+assume that you have basic familiarity with the command line. Rust itself makes\n+no specific demands on your editing tooling, or where your code lives. If you\n+prefer an IDE to the command line, you may want to check out\n+[SolidOak][solidoak], or wherever plugins are for your favorite IDE. There are\n+a number of extensions of varying quality in development by the community. The\n+Rust team also ships [plugins for various editors][plugins]. Configuring your\n+editor or IDE is out of the scope of this tutorial, so check the documentation\n+for your setup, specifically.\n \n-With that said, let's make a directory in our projects directory.\n+[solidoak]: https://github.com/oakes/SolidOak\n+[plugins]: https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md\n \n-```{bash}\n+With that said, let\u2019s make a directory in our projects directory.\n+\n+```bash\n $ mkdir ~/projects\n $ cd ~/projects\n $ mkdir hello_world\n $ cd hello_world\n ```\n \n-If you're on Windows and not using PowerShell, the `~` may not work. Consult\n+If you\u2019re on Windows and not using PowerShell, the `~` may not work. Consult\n the documentation for your shell for more details.\n \n-Let's make a new source file next. I'm going to use the syntax `editor\n-filename` to represent editing a file in these examples, but you should use\n-whatever method you want. We'll call our file `main.rs`:\n-\n-```{bash}\n-$ editor main.rs\n-```\n+Let\u2019s make a new source file next. We\u2019ll call our file `main.rs`. Rust files\n+always end in a `.rs` extension. If you\u2019re using more than one word in your\n+filename, use an underscore: `hello_world.rs` rather than `helloworld.rs`.\n \n-Rust files always end in a `.rs` extension. If you're using more than one word\n-in your filename, use an underscore. `hello_world.rs` rather than\n-`helloworld.rs`.\n+Now that you\u2019ve got your file open, type this in:\n \n-Now that you've got your file open, type this in:\n-\n-```{rust}\n+```rust\n fn main() {\n     println!(\"Hello, world!\");\n }\n ```\n \n Save the file, and then type this into your terminal window:\n \n-```{bash}\n+```bash\n $ rustc main.rs\n $ ./main # or main.exe on Windows\n Hello, world!\n ```\n \n-You can also run these examples on [play.rust-lang.org](http://play.rust-lang.org/) by clicking on the arrow that appears in the upper right of the example when you mouse over the code.\n-\n-Success! Let's go over what just happened in detail.\n+Success! Let\u2019s go over what just happened in detail.\n \n-```{rust}\n+```rust\n fn main() {\n \n }\n ```\n \n These lines define a *function* in Rust. The `main` function is special:\n-it's the beginning of every Rust program. The first line says \"I'm declaring a\n-function named `main`, which takes no arguments and returns nothing.\" If there\n+it's the beginning of every Rust program. The first line says \"I\u2019m declaring a\n+function named `main` which takes no arguments and returns nothing.\" If there\n were arguments, they would go inside the parentheses (`(` and `)`), and because\n-we aren't returning anything from this function, we can omit the return type\n-entirely. We'll get to it later.\n+we aren\u2019t returning anything from this function, we can omit the return type\n+entirely. We\u2019ll get to it later.\n \n-You'll also note that the function is wrapped in curly braces (`{` and `}`).\n+You\u2019ll also note that the function is wrapped in curly braces (`{` and `}`).\n Rust requires these around all function bodies. It is also considered good\n style to put the opening curly brace on the same line as the function\n declaration, with one space in between.\n \n Next up is this line:\n \n-```{rust}\n+```rust\n     println!(\"Hello, world!\");\n ```\n \n This line does all of the work in our little program. There are a number of\n-details that are important here. The first is that it's indented with four\n+details that are important here. The first is that it\u2019s indented with four\n spaces, not tabs. Please configure your editor of choice to insert four spaces\n with the tab key. We provide some [sample configurations for various\n editors][configs].\n \n [configs]: https://github.com/rust-lang/rust/tree/master/src/etc/CONFIGS.md\n \n-The second point is the `println!()` part. This is calling a Rust *macro*,\n+The second point is the `println!()` part. This is calling a Rust [macro][macro],\n which is how metaprogramming is done in Rust. If it were a function instead, it\n-would look like this: `println()`. For our purposes, we don't need to worry\n-about this difference. Just know that sometimes, you'll see a `!`, and that\n-means that you're calling a macro instead of a normal function. Rust implements\n-`println!` as a macro rather than a function for good reasons, but that's a\n-very advanced topic. You'll learn more when we talk about macros later. One\n-last thing to mention: Rust's macros are significantly different from C macros,\n-if you've used those. Don't be scared of using macros. We'll get to the details\n-eventually, you'll just have to trust us for now.\n-\n-Next, `\"Hello, world!\"` is a *string*. Strings are a surprisingly complicated\n-topic in a systems programming language, and this is a *statically allocated*\n-string. We will talk more about different kinds of allocation later. We pass\n-this string as an argument to `println!`, which prints the string to the\n-screen. Easy enough!\n-\n-Finally, the line ends with a semicolon (`;`). Rust is an *expression\n-oriented* language, which means that most things are expressions. The `;` is\n-used to indicate that this expression is over, and the next one is ready to\n-begin. Most lines of Rust code end with a `;`. We will cover this in-depth\n-later in the guide.\n-\n-Finally, actually *compiling* and *running* our program. We can compile\n-with our compiler, `rustc`, by passing it the name of our source file:\n-\n-```{bash}\n+would look like this: `println()`. For our purposes, we don\u2019t need to worry\n+about this difference. Just know that sometimes, you\u2019ll see a `!`, and that\n+means that you\u2019re calling a macro instead of a normal function. Rust implements\n+`println!` as a macro rather than a function for good reasons, but that's an\n+advanced topic. One last thing to mention: Rust\u2019s macros are significantly\n+different from C macros, if you\u2019ve used those. Don\u2019t be scared of using macros.\n+We\u2019ll get to the details eventually, you\u2019ll just have to trust us for now.\n+\n+[macro]: macros.html\n+\n+Next, `\"Hello, world!\"` is a \u2018string\u2019. Strings are a surprisingly complicated\n+topic in a systems programming language, and this is a \u2018statically allocated\u2019\n+string. If you want to read further about allocation, check out [the stack and\n+the heap], but you don\u2019t need to right now if you don\u2019t want to. We pass this\n+string as an argument to `println!`, which prints the string to the screen.\n+Easy enough!\n+\n+[allocation]: the-stack-and-the-heap.html\n+\n+Finally, the line ends with a semicolon (`;`). Rust is an \u2018expression oriented\u2019\n+language, which means that most things are expressions, rather than statements.\n+The `;` is used to indicate that this expression is over, and the next one is\n+ready to begin. Most lines of Rust code end with a `;`.\n+\n+Finally, actually compiling and running our program. We can compile with our\n+compiler, `rustc`, by passing it the name of our source file:\n+\n+```bash\n $ rustc main.rs\n ```\n \n This is similar to `gcc` or `clang`, if you come from a C or C++ background. Rust\n will output a binary executable. You can see it with `ls`:\n \n-```{bash}\n+```bash\n $ ls\n main  main.rs\n ```\n \n Or on Windows:\n \n-```{bash}\n+```bash\n $ dir\n main.exe  main.rs\n ```\n \n There are now two files: our source code, with the `.rs` extension, and the\n executable (`main.exe` on Windows, `main` everywhere else)\n \n-```{bash}\n+```bash\n $ ./main  # or main.exe on Windows\n ```\n \n This prints out our `Hello, world!` text to our terminal.\n \n If you come from a dynamically typed language like Ruby, Python, or JavaScript,\n you may not be used to these two steps being separate. Rust is an\n-*ahead-of-time compiled language*, which means that you can compile a\n-program, give it to someone else, and they don't need to have Rust installed.\n-If you give someone a `.rb` or `.py` or `.js` file, they need to have a\n+\u2018ahead-of-time compiled language\u2019, which means that you can compile a program,\n+give it to someone else, and they don't need to have Rust installed. If you\n+give someone a `.rb` or `.py` or `.js` file, they need to have a\n Ruby/Python/JavaScript implementation installed, but you just need one command\n-to both compile and run your program. Everything is a tradeoff in language design,\n-and Rust has made its choice.\n+to both compile and run your program. Everything is a tradeoff in language\n+design, and Rust has made its choice.\n \n Congratulations! You have officially written a Rust program. That makes you a\n-Rust programmer! Welcome.\n+Rust programmer! Welcome. \ud83c\udf8a\ud83c\udf89\ud83d\udc4d\n \n Next, I'd like to introduce you to another tool, Cargo, which is used to write\n real-world Rust programs. Just using `rustc` is nice for simple things, but as"}, {"sha": "9e010b020c1810faa30811880c72672a681eb906", "filename": "src/doc/trpl/if-let.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fif-let.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fif-let.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif-let.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,3 @@\n+% if let\n+\n+COMING SOON"}, {"sha": "a532dabf8d12d894a7b9f13e7d6081d7b2f2040e", "filename": "src/doc/trpl/if.md", "status": "modified", "additions": 12, "deletions": 96, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,10 +1,10 @@\n-% `if`\n+% if\n \n-Rust's take on `if` is not particularly complex, but it's much more like the\n-`if` you'll find in a dynamically typed language than in a more traditional\n-systems language. So let's talk about it, to make sure you grasp the nuances.\n+Rust\u2019s take on `if` is not particularly complex, but it\u2019s much more like the\n+`if` you\u2019ll find in a dynamically typed language than in a more traditional\n+systems language. So let\u2019s talk about it, to make sure you grasp the nuances.\n \n-`if` is a specific form of a more general concept, the *branch*. The name comes\n+`if` is a specific form of a more general concept, the \u2018branch\u2019. The name comes\n from a branch in a tree: a decision point, where depending on a choice,\n multiple paths can be taken.\n \n@@ -20,11 +20,11 @@ if x == 5 {\n \n If we changed the value of `x` to something else, this line would not print.\n More specifically, if the expression after the `if` evaluates to `true`, then\n-the block is executed. If it's `false`, then it is not.\n+the block is executed. If it\u2019s `false`, then it is not.\n \n If you want something to happen in the `false` case, use an `else`:\n \n-```{rust}\n+```rust\n let x = 5;\n \n if x == 5 {\n@@ -50,8 +50,7 @@ if x == 5 {\n \n This is all pretty standard. However, you can also do this:\n \n-\n-```{rust}\n+```rust\n let x = 5;\n \n let y = if x == 5 {\n@@ -63,95 +62,12 @@ let y = if x == 5 {\n \n Which we can (and probably should) write like this:\n \n-```{rust}\n+```rust\n let x = 5;\n \n let y = if x == 5 { 10 } else { 15 }; // y: i32\n ```\n \n-This reveals two interesting things about Rust: it is an expression-based\n-language, and semicolons are different from semicolons in other 'curly brace\n-and semicolon'-based languages. These two things are related.\n-\n-## Expressions vs. Statements\n-\n-Rust is primarily an expression based language. There are only two kinds of\n-statements, and everything else is an expression.\n-\n-So what's the difference? Expressions return a value, and statements do not.\n-In many languages, `if` is a statement, and therefore, `let x = if ...` would\n-make no sense. But in Rust, `if` is an expression, which means that it returns\n-a value. We can then use this value to initialize the binding.\n-\n-Speaking of which, bindings are a kind of the first of Rust's two statements.\n-The proper name is a *declaration statement*. So far, `let` is the only kind\n-of declaration statement we've seen. Let's talk about that some more.\n-\n-In some languages, variable bindings can be written as expressions, not just\n-statements. Like Ruby:\n-\n-```{ruby}\n-x = y = 5\n-```\n-\n-In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n-following will produce a compile-time error:\n-\n-```{ignore}\n-let x = (let y = 5); // expected identifier, found keyword `let`\n-```\n-\n-The compiler is telling us here that it was expecting to see the beginning of\n-an expression, and a `let` can only begin a statement, not an expression.\n-\n-Note that assigning to an already-bound variable (e.g. `y = 5`) is still an\n-expression, although its value is not particularly useful. Unlike C, where an\n-assignment evaluates to the assigned value (e.g. `5` in the previous example),\n-in Rust the value of an assignment is the unit type `()` (which we'll cover later).\n-\n-The second kind of statement in Rust is the *expression statement*. Its\n-purpose is to turn any expression into a statement. In practical terms, Rust's\n-grammar expects statements to follow other statements. This means that you use\n-semicolons to separate expressions from each other. This means that Rust\n-looks a lot like most other languages that require you to use semicolons\n-at the end of every line, and you will see semicolons at the end of almost\n-every line of Rust code you see.\n-\n-What is this exception that makes us say \"almost\"? You saw it already, in this\n-code:\n-\n-```{rust}\n-let x = 5;\n-\n-let y: i32 = if x == 5 { 10 } else { 15 };\n-```\n-\n-Note that I've added the type annotation to `y`, to specify explicitly that I\n-want `y` to be an integer.\n-\n-This is not the same as this, which won't compile:\n-\n-```{ignore}\n-let x = 5;\n-\n-let y: i32 = if x == 5 { 10; } else { 15; };\n-```\n-\n-Note the semicolons after the 10 and 15. Rust will give us the following error:\n-\n-```text\n-error: mismatched types: expected `i32`, found `()` (expected i32, found ())\n-```\n-\n-We expected an integer, but we got `()`. `()` is pronounced *unit*, and is a\n-special type in Rust's type system. In Rust, `()` is _not_ a valid value for a\n-variable of type `i32`. It's only a valid value for variables of the type `()`,\n-which aren't very useful. Remember how we said statements don't return a value?\n-Well, that's the purpose of unit in this case. The semicolon turns any\n-expression into a statement by throwing away its value and returning unit\n-instead.\n-\n-There's one more time in which you won't see a semicolon at the end of a line\n-of Rust code. For that, we'll need our next concept: functions.\n-\n-TODO: `if let`\n+This works because `if` is an expression. The value of the expression is the\n+value of the last expression in whichever branch was chosen. An `if` without an\n+`else` always results in `()` as the value."}, {"sha": "e4054a097989d203341f3cbe2d25e6d3f3f29f98", "filename": "src/doc/trpl/installing-rust.md", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finstalling-rust.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,27 +1,32 @@\n % Installing Rust\n \n The first step to using Rust is to install it! There are a number of ways to\n-install Rust, but the easiest is to use the `rustup` script. If you're on\n-Linux or a Mac, all you need to do is this (note that you don't need to type\n-in the `$`s, they just indicate the start of each command):\n+install Rust, but the easiest is to use the `rustup` script. If you're on Linux\n+or a Mac, all you need to do is this (note that you don't need to type in the\n+`$`s, they just indicate the start of each command):\n \n ```bash\n $ curl -sf -L https://static.rust-lang.org/rustup.sh | sudo sh\n ```\n \n-If you're concerned about the [potential insecurity](http://curlpipesh.tumblr.com/) of using `curl | sudo sh`,\n-please keep reading and see our disclaimer below. And feel free to use a two-step version of the installation and examine our installation script:\n+If you're concerned about the [potential insecurity][insecurity] of using `curl\n+| sudo sh`, please keep reading and see our disclaimer below. And feel free to\n+use a two-step version of the installation and examine our installation script:\n \n ```bash\n $ curl -f -L https://static.rust-lang.org/rustup.sh -O\n $ sudo sh rustup.sh\n ```\n \n-If you're on Windows, please download either the [32-bit\n-installer](https://static.rust-lang.org/dist/rust-1.0.0-beta-i686-pc-windows-gnu.exe)\n-or the [64-bit\n-installer](https://static.rust-lang.org/dist/rust-1.0.0-beta-x86_64-pc-windows-gnu.exe)\n-and run it.\n+[insecurity]: http://curlpipesh.tumblr.com\n+\n+If you're on Windows, please download either the [32-bit installer][win32] or\n+the [64-bit installer][win64] and run it.\n+\n+[win32]: https://static.rust-lang.org/dist/rust-1.0.0-beta-i686-pc-windows-gnu.msi\n+[win64]: https://static.rust-lang.org/dist/rust-1.0.0-beta-x86_64-pc-windows-gnu.msi\n+\n+## Uninstalling\n \n If you decide you don't want Rust anymore, we'll be a bit sad, but that's okay.\n Not every programming language is great for everyone. Just run the uninstall\n@@ -31,22 +36,20 @@ script:\n $ sudo /usr/local/lib/rustlib/uninstall.sh\n ```\n \n-If you used the Windows installer, just re-run the `.exe` and it will give you\n+If you used the Windows installer, just re-run the `.msi` and it will give you\n an uninstall option.\n \n-You can re-run this script any time you want to update Rust. Which, at this\n-point, is often. Rust is still pre-1.0, and so people assume that you're using\n-a very recent Rust.\n+Some people, and somewhat rightfully so, get very upset when we tell you to\n+`curl | sudo sh`. Basically, when you do this, you are trusting that the good\n+people who maintain Rust aren't going to hack your computer and do bad things.\n+That's a good instinct! If you're one of those people, please check out the\n+documentation on [building Rust from Source][from source], or [the official\n+binary downloads][install page]. And we promise that this method will not be\n+the way to install Rust forever: it's just the easiest way to keep people\n+updated while Rust is in its alpha state.\n \n-This brings me to one other point: some people, and somewhat rightfully so, get\n-very upset when we tell you to `curl | sudo sh`. And they should be! Basically,\n-when you do this, you are trusting that the good people who maintain Rust\n-aren't going to hack your computer and do bad things. That's a good instinct!\n-If you're one of those people, please check out the documentation on [building\n-Rust from Source](https://github.com/rust-lang/rust#building-from-source), or\n-[the official binary downloads](http://www.rust-lang.org/install.html). And we\n-promise that this method will not be the way to install Rust forever: it's just\n-the easiest way to keep people updated while Rust is in its alpha state.\n+[from source]: https://github.com/rust-lang/rust#building-from-source\n+[install page]: http://www.rust-lang.org/install.html\n \n Oh, we should also mention the officially supported platforms:\n \n@@ -73,7 +76,7 @@ $ rustc --version\n You should see the version number, commit hash, commit date and build date:\n \n ```bash\n-rustc 1.0.0-nightly (f11f3e7ba 2015-01-04) (built 2015-01-06)\n+rustc 1.0.0-beta (9854143cb 2015-04-02) (built 2015-04-02)\n ```\n \n If you did, Rust has been installed successfully! Congrats!\n@@ -84,10 +87,13 @@ On Windows, it's in a `share/doc` directory, inside wherever you installed Rust\n to.\n \n If not, there are a number of places where you can get help. The easiest is\n-[the #rust IRC channel on irc.mozilla.org](irc://irc.mozilla.org/#rust), which\n-you can access through\n-[Mibbit](http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust). Click\n-that link, and you'll be chatting with other Rustaceans (a silly nickname we\n-call ourselves), and we can help you out. Other great resources include [the\n-/r/rust subreddit](http://www.reddit.com/r/rust), and [Stack\n-Overflow](http://stackoverflow.com/questions/tagged/rust).\n+[the #rust IRC channel on irc.mozilla.org][irc], which you can access through\n+[Mibbit][mibbit]. Click that link, and you'll be chatting with other Rustaceans\n+(a silly nickname we call ourselves), and we can help you out. Other great\n+resources include [the user\u2019s forum][users], and [Stack Overflow][stack\n+overflow].\n+\n+[irc]: irc://irc.mozilla.org/#rust\n+[mibbit]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n+[users]: http://users.rust-lang.org/ \n+[stack overflow]: http://stackoverflow.com/questions/tagged/rust"}, {"sha": "3d8ef8090bfb79808745453b8c3b0ca9953fc24b", "filename": "src/doc/trpl/learn-rust.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flearn-rust.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1 +1,4 @@\n % Learn Rust\n+\n+This section is coming soon! It will eventually have a few tutorials with\n+building real Rust projects, but they are under development."}, {"sha": "33d603f326af3a19f09ef9182605ef207c44d04f", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 23, "deletions": 117, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,13 +1,13 @@\n % Match\n \n-Often, a simple `if`/`else` isn't enough, because you have more than two\n+Often, a simple `if`/`else` isn\u2019t enough, because you have more than two\n possible options. Also, `else` conditions can get incredibly complicated, so\n-what's the solution?\n+what\u2019s the solution?\n \n Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n groupings with something more powerful. Check it out:\n \n-```{rust}\n+```rust\n let x = 5;\n \n match x {\n@@ -21,11 +21,14 @@ match x {\n ```\n \n `match` takes an expression and then branches based on its value. Each *arm* of\n-the branch is of the form `val => expression`. When the value matches, that arm's\n-expression will be evaluated. It's called `match` because of the term 'pattern\n-matching', which `match` is an implementation of.\n+the branch is of the form `val => expression`. When the value matches, that arm\u2019s\n+expression will be evaluated. It\u2019s called `match` because of the term \u2018pattern\n+matching\u2019, which `match` is an implementation of. There\u2019s an [entire section on\n+patterns][patterns] coming up next, that covers all the options that fit here.\n \n-So what's the big advantage here? Well, there are a few. First of all, `match`\n+[patterns]: patterns.html\n+\n+So what\u2019s the big advantage here? Well, there are a few. First of all, `match`\n enforces *exhaustiveness checking*. Do you see that last arm, the one with the\n underscore (`_`)? If we remove that arm, Rust will give us an error:\n \n@@ -36,121 +39,24 @@ error: non-exhaustive patterns: `_` not covered\n In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n integer, Rust knows that it can have a number of different values \u2013 for example,\n `6`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n-to compile. `_` acts like a *catch-all arm*. If none of the other arms match,\n+to compile. `_` acts like a \u2018catch-all arm\u2019. If none of the other arms match,\n the arm with `_` will, and since we have this catch-all arm, we now have an arm\n for every possible value of `x`, and so our program will compile successfully.\n \n-`match` statements also destructure enums, as well. Remember this code from the\n-section on enums?\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y);\n-\n-    if ordering == Ordering::Less {\n-        println!(\"less\");\n-    } else if ordering == Ordering::Greater {\n-        println!(\"greater\");\n-    } else if ordering == Ordering::Equal {\n-        println!(\"equal\");\n-    }\n-}\n-```\n-\n-We can re-write this as a `match`:\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    match cmp(x, y) {\n-        Ordering::Less => println!(\"less\"),\n-        Ordering::Greater => println!(\"greater\"),\n-        Ordering::Equal => println!(\"equal\"),\n-    }\n-}\n-```\n-\n-This version has way less noise, and it also checks exhaustively to make sure\n-that we have covered all possible variants of `Ordering`. With our `if`/`else`\n-version, if we had forgotten the `Greater` case, for example, our program would\n-have happily compiled. If we forget in the `match`, it will not. Rust helps us\n-make sure to cover all of our bases.\n-\n-`match` expressions also allow us to get the values contained in an `enum`\n-(also known as destructuring) as follows:\n-\n-```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-\n-fn main() {\n-    let x = OptionalInt::Value(5);\n-    let y = OptionalInt::Missing;\n-\n-    match x {\n-        OptionalInt::Value(n) => println!(\"x is {}\", n),\n-        OptionalInt::Missing => println!(\"x is missing!\"),\n-    }\n-\n-    match y {\n-        OptionalInt::Value(n) => println!(\"y is {}\", n),\n-        OptionalInt::Missing => println!(\"y is missing!\"),\n-    }\n-}\n-```\n-\n-That is how you can get and use the values contained in `enum`s.\n-It can also allow us to handle errors or unexpected computations; for example, a\n-function that is not guaranteed to be able to compute a result (an `i32` here)\n-could return an `OptionalInt`, and we would handle that value with a `match`.\n-As you can see, `enum` and `match` used together are quite useful!\n-\n `match` is also an expression, which means we can use it on the right-hand\n-side of a `let` binding or directly where an expression is used. We could\n-also implement the previous example like this:\n-\n-```{rust}\n-use std::cmp::Ordering;\n+side of a `let` binding or directly where an expression is used:\n \n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n+```rust\n+let x = 5;\n \n-    println!(\"{}\", match cmp(x, y) {\n-        Ordering::Less => \"less\",\n-        Ordering::Greater => \"greater\",\n-        Ordering::Equal => \"equal\",\n-    });\n-}\n+let numer = match x {\n+    1 => \"one\",\n+    2 => \"two\",\n+    3 => \"three\",\n+    4 => \"four\",\n+    5 => \"five\",\n+    _ => \"something else\",\n+};\n ```\n \n-Sometimes, it's a nice pattern.\n+Sometimes, it\u2019s a nice way of converting things."}, {"sha": "ae83a930a187ce78053bf0895b979f58f6c526ea", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -4,15 +4,15 @@ Functions are great, but if you want to call a bunch of them on some data, it\n can be awkward. Consider this code:\n \n ```{rust,ignore}\n-baz(bar(foo(x)));\n+baz(bar(foo)));\n ```\n \n We would read this left-to right, and so we see \"baz bar foo.\" But this isn't the\n order that the functions would get called in, that's inside-out: \"foo bar baz.\"\n Wouldn't it be nice if we could do this instead?\n \n ```{rust,ignore}\n-x.foo().bar().baz();\n+foo.bar().baz();\n ```\n \n Luckily, as you may have guessed with the leading question, you can! Rust provides\n@@ -47,8 +47,8 @@ This will print `12.566371`.\n We've made a struct that represents a circle. We then write an `impl` block,\n and inside it, define a method, `area`. Methods take a  special first\n parameter, of which there are three variants: `self`, `&self`, and `&mut self`.\n-You can think of this first parameter as being the `x` in `x.foo()`. The three\n-variants correspond to the three kinds of thing `x` could be: `self` if it's\n+You can think of this first parameter as being the `foo` in `foo.bar()`. The three\n+variants correspond to the three kinds of things `foo` could be: `self` if it's\n just a value on the stack, `&self` if it's a reference, and `&mut self` if it's\n a mutable reference. We should default to using `&self`, as you should prefer\n borrowing over taking ownership, as well as taking immutable references"}, {"sha": "da6985da19f48987c6835ebfc9323f26f2de8655", "filename": "src/doc/trpl/nightly-rust.md", "status": "modified", "additions": 73, "deletions": 22, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fnightly-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fnightly-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fnightly-rust.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -2,27 +2,34 @@\n \n Rust provides three distribution channels for Rust: nightly, beta, and stable.\n Unstable features are only available on nightly Rust. For more details on this\n-process, see [this post](http://blog.rust-lang.org/2014/10/30/Stability.html).\n+process, see \u2018[Stability as a deliverable][stability]\u2019.\n+\n+[stability]: http://blog.rust-lang.org/2014/10/30/Stability.html\n \n To install nightly Rust, you can use `rustup.sh`:\n \n ```bash\n $ curl -s https://static.rust-lang.org/rustup.sh | sudo sh -s -- --channel=nightly\n ```\n \n-If you're concerned about the [potential insecurity](http://curlpipesh.tumblr.com/) of using `curl | sudo sh`,\n-please keep reading and see our disclaimer below. And feel free to use a two-step version of the installation and examine our installation script:\n+If you're concerned about the [potential insecurity][insecurity] of using `curl\n+| sudo sh`, please keep reading and see our disclaimer below. And feel free to\n+use a two-step version of the installation and examine our installation script:\n \n ```bash\n $ curl -f -L https://static.rust-lang.org/rustup.sh -O\n-$ sudo sh rustup.sh --channel=nightly\n+$ sudo sh rustup.sh\n ```\n \n-If you're on Windows, please download either the [32-bit\n-installer](https://static.rust-lang.org/dist/rust-nightly-i686-pc-windows-gnu.exe)\n-or the [64-bit\n-installer](https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.exe)\n-and run it.\n+[insecurity]: http://curlpipesh.tumblr.com\n+\n+If you're on Windows, please download either the [32-bit installer][win32] or\n+the [64-bit installer][win64] and run it.\n+\n+[win32]: https://static.rust-lang.org/dist/rust-1.0.0-beta-i686-pc-windows-gnu.msi\n+[win64]: https://static.rust-lang.org/dist/rust-1.0.0-beta-x86_64-pc-windows-gnu.msi\n+\n+## Uninstalling\n \n If you decide you don't want Rust anymore, we'll be a bit sad, but that's okay.\n Not every programming language is great for everyone. Just run the uninstall\n@@ -32,20 +39,64 @@ script:\n $ sudo /usr/local/lib/rustlib/uninstall.sh\n ```\n \n-If you used the Windows installer, just re-run the `.exe` and it will give you\n+If you used the Windows installer, just re-run the `.msi` and it will give you\n an uninstall option.\n \n-You can re-run this script any time you want to update Rust. Which, at this\n-point, is often. Rust is still pre-1.0, and so people assume that you're using\n-a very recent Rust.\n+Some people, and somewhat rightfully so, get very upset when we tell you to\n+`curl | sudo sh`. Basically, when you do this, you are trusting that the good\n+people who maintain Rust aren't going to hack your computer and do bad things.\n+That's a good instinct! If you're one of those people, please check out the\n+documentation on [building Rust from Source][from source], or [the official\n+binary downloads][install page]. And we promise that this method will not be\n+the way to install Rust forever: it's just the easiest way to keep people\n+updated while Rust is in its alpha state.\n+\n+[from source]: https://github.com/rust-lang/rust#building-from-source\n+[install page]: http://www.rust-lang.org/install.html\n+\n+Oh, we should also mention the officially supported platforms:\n+\n+* Windows (7, 8, Server 2008 R2)\n+* Linux (2.6.18 or later, various distributions), x86 and x86-64\n+* OSX 10.7 (Lion) or greater, x86 and x86-64\n+\n+We extensively test Rust on these platforms, and a few others, too, like\n+Android. But these are the ones most likely to work, as they have the most\n+testing.\n+\n+Finally, a comment about Windows. Rust considers Windows to be a first-class\n+platform upon release, but if we're honest, the Windows experience isn't as\n+integrated as the Linux/OS X experience is. We're working on it! If anything\n+does not work, it is a bug. Please let us know if that happens. Each and every\n+commit is tested against Windows just like any other platform.\n+\n+If you've got Rust installed, you can open up a shell, and type this:\n+\n+```bash\n+$ rustc --version\n+```\n+\n+You should see the version number, commit hash, commit date and build date:\n+\n+```bash\n+rustc 1.0.0-nightly (f11f3e7ba 2015-01-04) (built 2015-01-06)\n+```\n+\n+If you did, Rust has been installed successfully! Congrats!\n+\n+This installer also installs a copy of the documentation locally, so you can\n+read it offline. On UNIX systems, `/usr/local/share/doc/rust` is the location.\n+On Windows, it's in a `share/doc` directory, inside wherever you installed Rust\n+to.\n \n-This brings me to one other point: some people, and somewhat rightfully so, get\n-very upset when we tell you to `curl | sudo sh`. And they should be! Basically,\n-when you do this, you are trusting that the good people who maintain Rust\n-aren't going to hack your computer and do bad things. That's a good instinct!\n-If you're one of those people, please check out the documentation on [building\n-Rust from Source](https://github.com/rust-lang/rust#building-from-source), or\n-[the official binary downloads](http://www.rust-lang.org/install.html). And we\n-promise that this method will not be the way to install Rust forever: it's just\n-the easiest way to keep people updated while Rust is in its alpha state.\n+If not, there are a number of places where you can get help. The easiest is\n+[the #rust IRC channel on irc.mozilla.org][irc], which you can access through\n+[Mibbit][mibbit]. Click that link, and you'll be chatting with other Rustaceans\n+(a silly nickname we call ourselves), and we can help you out. Other great\n+resources include [the user\u2019s forum][users], and [Stack Overflow][stack\n+overflow].\n \n+[irc]: irc://irc.mozilla.org/#rust\n+[mibbit]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n+[users]: http://users.rust-lang.org/ \n+[stack overflow]: http://stackoverflow.com/questions/tagged/rust"}, {"sha": "c88e3a0f9edf5f71564270e369c7233455ec2849", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,13 +1,16 @@\n % Patterns\n \n-We've made use of patterns a few times in the guide: first with `let` bindings,\n-then with `match` statements. Let's go on a whirlwind tour of all of the things\n-patterns can do!\n+Patterns are quite common in Rust. We use them in [variable\n+bindings][bindings], [match statements][match], and other places, too. Let\u2019s go\n+on a whirlwind tour of all of the things patterns can do!\n+\n+[bindings]: variable-bindings.html\n+[match]: match.html\n \n A quick refresher: you can match against literals directly, and `_` acts as an\n-*any* case:\n+\u2018any\u2019 case:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -18,9 +21,11 @@ match x {\n }\n ```\n \n+# Multiple patterns\n+\n You can match multiple patterns with `|`:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -30,9 +35,11 @@ match x {\n }\n ```\n \n+# Ranges\n+\n You can match a range of values with `...`:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -43,10 +50,12 @@ match x {\n \n Ranges are mostly used with integers and single characters.\n \n-If you're matching multiple things, via a `|` or a `...`, you can bind\n+# Bindings\n+\n+If you\u2019re matching multiple things, via a `|` or a `...`, you can bind\n the value to a name with `@`:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -55,10 +64,12 @@ match x {\n }\n ```\n \n-If you're matching on an enum which has variants, you can use `..` to\n+# Ignoring variants\n+\n+If you\u2019re matching on an enum which has variants, you can use `..` to\n ignore the value and type in the variant:\n \n-```{rust}\n+```rust\n enum OptionalInt {\n     Value(i32),\n     Missing,\n@@ -72,9 +83,11 @@ match x {\n }\n ```\n \n-You can introduce *match guards* with `if`:\n+# Guards\n+\n+You can introduce \u2018match guards\u2019 with `if`:\n \n-```{rust}\n+```rust\n enum OptionalInt {\n     Value(i32),\n     Missing,\n@@ -89,47 +102,38 @@ match x {\n }\n ```\n \n-If you're matching on a pointer, you can use the same syntax as you declared it\n-with. First, `&`:\n-\n-```{rust}\n-let x = &5;\n-\n-match x {\n-    &val => println!(\"Got a value: {}\", val),\n-}\n-```\n-\n-Here, the `val` inside the `match` has type `i32`. In other words, the left-hand\n-side of the pattern destructures the value. If we have `&5`, then in `&val`, `val`\n-would be `5`.\n+# ref and ref mut\n \n-If you want to get a reference, use the `ref` keyword:\n+If you want to get a [reference][ref], use the `ref` keyword:\n \n-```{rust}\n+```rust\n let x = 5;\n \n match x {\n     ref r => println!(\"Got a reference to {}\", r),\n }\n ```\n \n+[ref]: references-and-borrowing.html\n+\n Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n keyword _creates_ a reference, for use in the pattern. If you need a mutable\n reference, `ref mut` will work in the same way:\n \n-```{rust}\n+```rust\n let mut x = 5;\n \n match x {\n     ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n }\n ```\n \n-If you have a struct, you can destructure it inside of a pattern:\n+# Destructuring\n+\n+If you have a compound data type, like a `struct`, you can destructure it\n+inside of a pattern:\n \n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n+```rust\n struct Point {\n     x: i32,\n     y: i32,\n@@ -142,10 +146,9 @@ match origin {\n }\n ```\n \n-If we only care about some of the values, we don't have to give them all names:\n+If we only care about some of the values, we don\u2019t have to give them all names:\n \n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n+```rust\n struct Point {\n     x: i32,\n     y: i32,\n@@ -160,8 +163,7 @@ match origin {\n \n You can do this kind of match on any member, not just the first:\n \n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n+```rust\n struct Point {\n     x: i32,\n     y: i32,\n@@ -174,22 +176,16 @@ match origin {\n }\n ```\n \n-If you want to match against a slice or array, you can use `&`:\n+This \u2018destructuring\u2019 behavior works on any compound data type, like\n+[tuples][tuples] or [enums][enums].\n \n-```{rust}\n-# #![feature(slice_patterns)]\n-fn main() {\n-    let v = vec![\"match_this\", \"1\"];\n+[tuples]: primitive-types.html#tuples\n+[enums]: enums.html\n \n-    match &v[..] {\n-        [\"match_this\", second] => println!(\"The second element is {}\", second),\n-        _ => {},\n-    }\n-}\n-```\n+# Mix and Match\n \n-Whew! That's a lot of different ways to match things, and they can all be\n-mixed and matched, depending on what you're doing:\n+Whew! That\u2019s a lot of different ways to match things, and they can all be\n+mixed and matched, depending on what you\u2019re doing:\n \n ```{rust,ignore}\n match x {"}, {"sha": "fcbe2b2f8bf7073f4674c0dde222a3e88bed760d", "filename": "src/doc/trpl/primitive-types.md", "status": "modified", "additions": 266, "deletions": 1, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,3 +1,268 @@\n % Primitive Types\n \n-Coming Soon!\n+The Rust language has a number of types that are considered \u2018primitive\u2019. This\n+means that they\u2019re built-in to the language. Rust is structured in such a way\n+that the standard library also provides a number of useful types built on top\n+of these ones, as well, but these are the most primitive.\n+\n+# Booleans\n+\n+Rust has a built in boolean type, named `bool`. It has two values, `true` and `false`:\n+\n+```rust\n+let x = true;\n+\n+let y: bool = false;\n+```\n+\n+A common use of booleans is in [`if` statements][if].\n+\n+[if]: if.html\n+\n+You can find more documentation for `bool`s [in the standard library\n+documentation][bool].\n+\n+[bool]: ../std/primitive.bool.html\n+\n+# `char`\n+\n+The `char` type represents a single Unicode scalar value. You can create `char`s\n+with a single tick: (`'`)\n+\n+```rust\n+let x = 'x';\n+let two_hearts = '\ud83d\udc95';\n+```\n+\n+Unlike some other languages, this means that Rust\u2019s `char` is not a single byte,\n+but four.\n+\n+You can find more documentation for `char`s [in the standard library\n+documentation][char].\n+\n+[char]: ../std/primitive.char.html\n+\n+# Numeric types\n+\n+Rust has a variety of numeric types in a few categories: signed and unsigned,\n+fixed and variable, floating-point and integer.\n+\n+These types consist of two parts: the category, and the size. For example,\n+`u16` is an unsigned type with sixteen bits of size. More bits lets you have\n+bigger numbers.\n+\n+If a number literal has nothing to cause its type to be inferred, it defaults:\n+\n+```rust\n+let x = 42; // x has type i32\n+\n+let y = 1.0; // y has type f64\n+```\n+\n+Here\u2019s a list of the different numeric types, with links to their documentation\n+in the standard library:\n+\n+* [i16](../std/primitive.i16.html)\n+* [i32](../std/primitive.i32.html)\n+* [i64](../std/primitive.i64.html)\n+* [i8](../std/primitive.i8.html)\n+* [u16](../std/primitive.u16.html)\n+* [u32](../std/primitive.u32.html)\n+* [u64](../std/primitive.u64.html)\n+* [u8](../std/primitive.u8.html)\n+* [isize](../std/primitive.isize.html)\n+* [usize](../std/primitive.usize.html)\n+* [f32](../std/primitive.f32.html)\n+* [f64](../std/primitive.f64.html)\n+\n+Let\u2019s go over them by category:\n+\n+## Signed and Unsigned\n+\n+Integer types come in two varieties: signed and unsigned. To understand the\n+difference, let\u2019s consider a number with four bits of size. A signed, four-bit\n+number would let you store numbers from `-8` to `+7`. Signed numbers use\n+\u2018two\u2019s compliment representation\u2019. An unsigned four bit number, since it does\n+not need to store negatives, can store values from `0` to `+15`.\n+\n+Unsigned types use a `u` for their category, and signed types use `i`. The `i`\n+is for \u2018integer\u2019. So `u8` is an eight-bit unsigned number, and `i8` is an\n+eight-bit signed number. \n+\n+## Fixed size types\n+\n+Fixed size types have a specific number of bits in their representation. Valid\n+bit sizes are `8`, `16`, `32`, and `64`. So, `u32` is an unsigned, 32-bit integer,\n+and `i64` is a signed, 64-bit integer.\n+\n+## Variable sized types\n+\n+Rust also provides types whose size depends on the size of a pointer of the\n+underlying machine. These types have \u2018size\u2019 as the category, and come in signed\n+and unsigned varieties. This makes for two types: `isize` and `usize`.\n+\n+## Floating-point types\n+\n+Rust also two floating point types: `f32` and `f64`. These correspond to \n+IEEE-754 single and double precision numbers.\n+\n+# Arrays\n+\n+Like many programming languages, Rust has list types to represent a sequence of\n+things. The most basic is the *array*, a fixed-size list of elements of the\n+same type. By default, arrays are immutable.\n+\n+```rust\n+let a = [1, 2, 3]; // a: [i32; 3]\n+let mut m = [1, 2, 3]; // m: [i32; 3]\n+```\n+\n+Arrays have type `[T; N]`. We\u2019ll talk about this `T` notation [in the generics\n+section][generics]. The `N` is a compile-time constant, for the length of the\n+array.\n+\n+There\u2019s a shorthand for initializing each element of an array to the same\n+value. In this example, each element of `a` will be initialized to `0`:\n+\n+```rust\n+let a = [0; 20]; // a: [i32; 20]\n+```\n+\n+You can get the number of elements in an array `a` with `a.len()`:\n+\n+```rust\n+let a = [1, 2, 3];\n+\n+println!(\"a has {} elements\", a.len());\n+```\n+\n+You can access a particular element of an array with *subscript notation*:\n+\n+```rust\n+let names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str; 3]\n+\n+println!(\"The second name is: {}\", names[1]);\n+```\n+\n+Subscripts start at zero, like in most programming languages, so the first name\n+is `names[0]` and the second name is `names[1]`. The above example prints\n+`The second name is: Brian`. If you try to use a subscript that is not in the\n+array, you will get an error: array access is bounds-checked at run-time. Such\n+errant access is the source of many bugs in other systems programming\n+languages.\n+\n+You can find more documentation for `array`s [in the standard library\n+documentation][array].\n+\n+[array]: ../std/primitive.array.html\n+\n+# Slices\n+\n+A \u2018slice\u2019 is a reference to (or \u201cview\u201d into) another data structure. They are\n+useful for allowing safe, efficient access to a portion of an array without\n+copying. For example, you might want to reference just one line of a file read\n+into memory. By nature, a slice is not created directly, but from an existing\n+variable. Slices have a length, can be mutable or not, and in many ways behave\n+like arrays:\n+\n+```rust\n+let a = [0, 1, 2, 3, 4];\n+let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n+```\n+\n+Slices have type `&[T]`. We\u2019ll talk about that `T` when we cover\n+[generics][generics].\n+\n+[generics]: generics.html\n+\n+You can find more documentation for `slices`s [in the standard library\n+documentation][slice].\n+\n+[slice]: ../std/primitive.slice.html\n+\n+# `str`\n+\n+Rust\u2019s `str` type is the most primitive string type. As an [unsized type][dst],\n+it\u2019s not very useful by itself, but becomes useful when placed behind a reference,\n+like [`&str`][strings]. As such, we\u2019ll just leave it at that.\n+\n+[dst]: unsized-types.html\n+[strings]: strings.html\n+\n+You can find more documentation for `str` [in the standard library\n+documentation][str].\n+\n+[str]: ../std/primitive.str.html\n+\n+# Tuples\n+\n+A tuple is an ordered list of fixed size. Like this:\n+\n+```rust\n+let x = (1, \"hello\");\n+```\n+\n+The parentheses and commas form this two-length tuple. Here\u2019s the same code, but\n+with the type annotated:\n+\n+```rust\n+let x: (i32, &str) = (1, \"hello\");\n+```\n+\n+As you can see, the type of a tuple looks just like the tuple, but with each\n+position having a type name rather than the value. Careful readers will also\n+note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.\n+In systems programming languages, strings are a bit more complex than in other\n+languages. For now, just read `&str` as a *string slice*, and we\u2019ll learn more\n+soon.\n+\n+You can access the fields in a tuple through a *destructuring let*. Here\u2019s\n+an example:\n+\n+```rust\n+let (x, y, z) = (1, 2, 3);\n+\n+println!(\"x is {}\", x);\n+```\n+\n+Remember [before][let] when I said the left-hand side of a `let` statement was more\n+powerful than just assigning a binding? Here we are. We can put a pattern on\n+the left-hand side of the `let`, and if it matches up to the right-hand side,\n+we can assign multiple bindings at once. In this case, `let` \"destructures,\"\n+or \"breaks up,\" the tuple, and assigns the bits to three bindings.\n+\n+[let]: variable-bindings.html\n+\n+This pattern is very powerful, and we\u2019ll see it repeated more later.\n+\n+There are also a few things you can do with a tuple as a whole, without\n+destructuring. You can assign one tuple into another, if they have the same\n+contained types and [arity]. Tuples have the same arity when they have the same\n+length.\n+\n+[arity]: glossary.html#arity\n+\n+```rust\n+let mut x = (1, 2); // x: (i32, i32)\n+let y = (2, 3); // y: (i32, i32)\n+\n+x = y;\n+```\n+\n+You can find more documentation for tuples [in the standard library\n+documentation][tuple].\n+\n+[tuple]: ../std/primitive.tuple.html\n+\n+# Functions\n+\n+Functions also have a type! They look like this:\n+\n+```\n+fn foo(x: i32) -> i32 { x }\n+\n+let x: fn(i32) -> i32 = foo;\n+```\n+\n+In this case, `x` is a \u2018function pointer\u2019 to a function that takes an `i32` and\n+returns an `i32`."}, {"sha": "4599333a77a05e88d326126621762f6f27c4388e", "filename": "src/doc/trpl/slice-patterns.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fslice-patterns.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,18 @@\n+% Slice patterns\n+\n+If you want to match against a slice or array, you can use `&` with the\n+`slice_patterns` feature:\n+\n+```rust\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    let v = vec![\"match_this\", \"1\"];\n+\n+    match &v[..] {\n+        [\"match_this\", second] => println!(\"The second element is {}\", second),\n+        _ => {},\n+    }\n+}\n+```\n+"}, {"sha": "a31c0ac3c4e69f5dfc5829571feceed4ddd2688d", "filename": "src/doc/trpl/slices.md", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/67a8f61730418768f07d8ed0f9735a31d0c5d84d/src%2Fdoc%2Ftrpl%2Fslices.md", "raw_url": "https://github.com/rust-lang/rust/raw/67a8f61730418768f07d8ed0f9735a31d0c5d84d/src%2Fdoc%2Ftrpl%2Fslices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fslices.md?ref=67a8f61730418768f07d8ed0f9735a31d0c5d84d", "patch": "@@ -1,21 +0,0 @@\n-% Slices\n-\n-A *slice* is a reference to (or \"view\" into) an array. They are useful for\n-allowing safe, efficient access to a portion of an array without copying. For\n-example, you might want to reference just one line of a file read into memory.\n-By nature, a slice is not created directly, but from an existing variable.\n-Slices have a length, can be mutable or not, and in many ways behave like\n-arrays:\n-\n-```{rust}\n-let a = [0, 1, 2, 3, 4];\n-let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n-\n-for e in middle.iter() {\n-    println!(\"{}\", e); // Prints 1, 2, 3\n-}\n-```\n-\n-You can also take a slice of a vector, `String`, or `&str`, because they are\n-backed by arrays. Slices have type `&[T]`, which we'll talk about when we cover\n-generics."}, {"sha": "cce985c9e484c1436179e5773e396b47a35ecad4", "filename": "src/doc/trpl/syntax-and-semantics.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fsyntax-and-semantics.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fsyntax-and-semantics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fsyntax-and-semantics.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1 +1,10 @@\n % Syntax and Semantics\n+\n+This section breaks Rust down into small chunks, one for each concept.\n+\n+If you\u2019d like to learn Rust from the bottom up, reading this in order is a\n+great way to do that.\n+\n+These sections also form a reference for each concept, so if you\u2019re reading\n+another tutorial and find something confusing, you can find it explained\n+somewhere in here."}, {"sha": "dd526d05b671e1d8904aa072a9b0273ad56c70c4", "filename": "src/doc/trpl/tuples.md", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/67a8f61730418768f07d8ed0f9735a31d0c5d84d/src%2Fdoc%2Ftrpl%2Ftuples.md", "raw_url": "https://github.com/rust-lang/rust/raw/67a8f61730418768f07d8ed0f9735a31d0c5d84d/src%2Fdoc%2Ftrpl%2Ftuples.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftuples.md?ref=67a8f61730418768f07d8ed0f9735a31d0c5d84d", "patch": "@@ -1,97 +0,0 @@\n-% Tuples\n-\n-The first compound data type we're going to talk about is called the *tuple*.\n-A tuple is an ordered list of fixed size. Like this:\n-\n-```rust\n-let x = (1, \"hello\");\n-```\n-\n-The parentheses and commas form this two-length tuple. Here's the same code, but\n-with the type annotated:\n-\n-```rust\n-let x: (i32, &str) = (1, \"hello\");\n-```\n-\n-As you can see, the type of a tuple looks just like the tuple, but with each\n-position having a type name rather than the value. Careful readers will also\n-note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.\n-You have briefly seen `&str` used as a type before, and we'll discuss the\n-details of strings later. In systems programming languages, strings are a bit\n-more complex than in other languages. For now, just read `&str` as a *string\n-slice*, and we'll learn more soon.\n-\n-You can access the fields in a tuple through a *destructuring let*. Here's\n-an example:\n-\n-```rust\n-let (x, y, z) = (1, 2, 3);\n-\n-println!(\"x is {}\", x);\n-```\n-\n-Remember before when I said the left-hand side of a `let` statement was more\n-powerful than just assigning a binding? Here we are. We can put a pattern on\n-the left-hand side of the `let`, and if it matches up to the right-hand side,\n-we can assign multiple bindings at once. In this case, `let` \"destructures,\"\n-or \"breaks up,\" the tuple, and assigns the bits to three bindings.\n-\n-This pattern is very powerful, and we'll see it repeated more later.\n-\n-There are also a few things you can do with a tuple as a whole, without\n-destructuring. You can assign one tuple into another, if they have the same\n-contained types and [arity]. Tuples have the same arity when they have the same\n-length.\n-\n-```rust\n-let mut x = (1, 2); // x: (i32, i32)\n-let y = (2, 3); // y: (i32, i32)\n-\n-x = y;\n-```\n-\n-You can also check for equality with `==`. Again, this will only compile if the\n-tuples have the same type.\n-\n-```rust\n-let x = (1, 2, 3);\n-let y = (2, 2, 4);\n-\n-if x == y {\n-    println!(\"yes\");\n-} else {\n-    println!(\"no\");\n-}\n-```\n-\n-This will print `no`, because some of the values aren't equal.\n-\n-Note that the order of the values is considered when checking for equality,\n-so the following example will also print `no`.\n-\n-```rust\n-let x = (1, 2, 3);\n-let y = (2, 1, 3);\n-\n-if x == y {\n-    println!(\"yes\");\n-} else {\n-    println!(\"no\");\n-}\n-```\n-\n-One other use of tuples is to return multiple values from a function:\n-\n-```rust\n-fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }\n-\n-fn main() {\n-    let (x, y) = next_two(5);\n-    println!(\"x, y = {}, {}\", x, y);\n-}\n-```\n-\n-Even though Rust functions can only return one value, a tuple *is* one value,\n-that happens to be made up of more than one value. You can also see in this\n-example how you can destructure a pattern returned by a function, as well."}, {"sha": "d971e557a9a2edba517ad91e859e4b8675f46ea3", "filename": "src/doc/trpl/variable-bindings.md", "status": "modified", "additions": 57, "deletions": 49, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,44 +1,48 @@\n % Variable Bindings\n \n-The first thing we'll learn about are *variable bindings*. They look like this:\n+Vitually every non-\u2019Hello World\u2019 Rust program uses *variable bindings*. They\n+look like this:\n \n-```{rust}\n+```rust\n fn main() {\n     let x = 5;\n }\n ```\n \n-Putting `fn main() {` in each example is a bit tedious, so we'll leave that out\n-in the future. If you're following along, make sure to edit your `main()`\n-function, rather than leaving it off. Otherwise, you'll get an error.\n+Putting `fn main() {` in each example is a bit tedious, so we\u2019ll leave that out\n+in the future. If you\u2019re following along, make sure to edit your `main()`\n+function, rather than leaving it off. Otherwise, you\u2019ll get an error.\n \n-In many languages, this is called a *variable*. But Rust's variable bindings\n-have a few tricks up their sleeves. Rust has a very powerful feature called\n-*pattern matching* that we'll get into detail with later, but the left\n-hand side of a `let` expression is a full pattern, not just a variable name.\n-This means we can do things like:\n+In many languages, this is called a *variable*, but Rust\u2019s variable bindings\n+have a few tricks up their sleeves. For example the left-hand side of a `let`\n+expression is a \u2018[pattern][pattern]\u2019, not just a variable name. This means we\n+can do things like:\n \n-```{rust}\n+```rust\n let (x, y) = (1, 2);\n ```\n \n After this expression is evaluated, `x` will be one, and `y` will be two.\n-Patterns are really powerful, but this is about all we can do with them so far.\n-So let's just keep this in the back of our minds as we go forward.\n+Patterns are really powerful, and have [their own section][pattern] in the\n+book. We don\u2019t need those features for now, so we\u2019ll just keep this in the back\n+of our minds as we go forward.\n+\n+[pattern]: patterns.html\n \n Rust is a statically typed language, which means that we specify our types up\n-front. So why does our first example compile? Well, Rust has this thing called\n-*type inference*. If it can figure out what the type of something is, Rust\n-doesn't require you to actually type it out.\n+front, and they\u2019re checked at compile time. So why does our first example\n+compile? Well, Rust has this thing called \u2018type inference\u2019. If it can figure\n+out what the type of something is, Rust doesn\u2019t require you to actually type it\n+out.\n \n We can add the type if we want to, though. Types come after a colon (`:`):\n \n-```{rust}\n+```rust\n let x: i32 = 5;\n ```\n \n-If I asked you to read this out loud to the rest of the class, you'd say \"`x`\n-is a binding with the type `i32` and the value `five`.\"\n+If I asked you to read this out loud to the rest of the class, you\u2019d say \u201c`x`\n+is a binding with the type `i32` and the value `five`.\u201d\n \n In this case we chose to represent `x` as a 32-bit signed integer. Rust has\n many different primitive integer types. They begin with `i` for signed integers\n@@ -48,19 +52,20 @@ bits.\n In future examples, we may annotate the type in a comment. The examples will\n look like this:\n \n-```{rust}\n+```rust\n fn main() {\n     let x = 5; // x: i32\n }\n ```\n \n-Note the similarities between this annotation and the syntax you use with `let`.\n-Including these kinds of comments is not idiomatic Rust, but we'll occasionally\n-include them to help you understand what the types that Rust infers are.\n+Note the similarities between this annotation and the syntax you use with\n+`let`. Including these kinds of comments is not idiomatic Rust, but we'll\n+occasionally include them to help you understand what the types that Rust\n+infers are.\n \n By default, bindings are *immutable*. This code will not compile:\n \n-```{ignore}\n+```rust,ignore\n let x = 5;\n x = 10;\n ```\n@@ -75,62 +80,63 @@ error: re-assignment of immutable variable `x`\n \n If you want a binding to be mutable, you can use `mut`:\n \n-```{rust}\n+```rust\n let mut x = 5; // mut x: i32\n x = 10;\n ```\n \n There is no single reason that bindings are immutable by default, but we can\n-think about it through one of Rust's primary focuses: safety. If you forget to\n+think about it through one of Rust\u2019s primary focuses: safety. If you forget to\n say `mut`, the compiler will catch it, and let you know that you have mutated\n something you may not have intended to mutate. If bindings were mutable by\n default, the compiler would not be able to tell you this. If you _did_ intend\n mutation, then the solution is quite easy: add `mut`.\n \n-There are other good reasons to avoid mutable state when possible, but they're\n+There are other good reasons to avoid mutable state when possible, but they\u2019re\n out of the scope of this guide. In general, you can often avoid explicit\n mutation, and so it is preferable in Rust. That said, sometimes, mutation is\n-what you need, so it's not verboten.\n+what you need, so it\u2019s not verboten.\n \n-Let's get back to bindings. Rust variable bindings have one more aspect that\n+Let\u2019s get back to bindings. Rust variable bindings have one more aspect that\n differs from other languages: bindings are required to be initialized with a\n value before you're allowed to use them.\n \n-Let's try it out. Change your `src/main.rs` file to look like this:\n+Let\u2019s try it out. Change your `src/main.rs` file to look like this:\n \n-```{rust}\n+```rust\n fn main() {\n     let x: i32;\n \n     println!(\"Hello world!\");\n }\n ```\n \n-You can use `cargo build` on the command line to build it. You'll get a warning,\n-but it will still print \"Hello, world!\":\n+You can use `cargo build` on the command line to build it. You\u2019ll get a\n+warning, but it will still print \"Hello, world!\":\n \n ```text\n    Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n-src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default\n+src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]\n+   on by default\n src/main.rs:2     let x: i32;\n                       ^\n ```\n \n-Rust warns us that we never use the variable binding, but since we never use it,\n-no harm, no foul. Things change if we try to actually use this `x`, however. Let's\n-do that. Change your program to look like this:\n+Rust warns us that we never use the variable binding, but since we never use\n+it, no harm, no foul. Things change if we try to actually use this `x`,\n+however. Let\u2019s do that. Change your program to look like this:\n \n-```{rust,ignore}\n+```rust,ignore\n fn main() {\n     let x: i32;\n \n     println!(\"The value of x is: {}\", x);\n }\n ```\n \n-And try to build it. You'll get an error:\n+And try to build it. You\u2019ll get an error:\n \n-```{bash}\n+```bash\n $ cargo build\n    Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`\n@@ -144,18 +150,20 @@ error: aborting due to previous error\n Could not compile `hello_world`.\n ```\n \n-Rust will not let us use a value that has not been initialized. Next, let's\n+Rust will not let us use a value that has not been initialized. Next, let\u2019s\n talk about this stuff we've added to `println!`.\n \n If you include two curly braces (`{}`, some call them moustaches...) in your\n string to print, Rust will interpret this as a request to interpolate some sort\n of value. *String interpolation* is a computer science term that means \"stick\n in the middle of a string.\" We add a comma, and then `x`, to indicate that we\n-want `x` to be the value we're interpolating. The comma is used to separate\n-arguments we pass to functions and macros, if you're passing more than one.\n-\n-When you just use the curly braces, Rust will attempt to display the\n-value in a meaningful way by checking out its type. If you want to specify the\n-format in a more detailed manner, there are a [wide number of options\n-available](../std/fmt/index.html). For now, we'll just stick to the default:\n-integers aren't very complicated to print.\n+want `x` to be the value we\u2019re interpolating. The comma is used to separate\n+arguments we pass to functions and macros, if you\u2019re passing more than one.\n+\n+When you just use the curly braces, Rust will attempt to display the value in a\n+meaningful way by checking out its type. If you want to specify the format in a\n+more detailed manner, there are a [wide number of options available][format].\n+For now, we'll just stick to the default: integers aren't very complicated to\n+print.\n+\n+[format]: ../std/fmt/index.html"}, {"sha": "f2e2f6b6f49a7403048a36ff755ac18cf8119fc1", "filename": "src/doc/trpl/while-loops.md", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1,53 +1,59 @@\n-% `while` loops\n+% while loops\n \n-The other kind of looping construct in Rust is the `while` loop. It looks like\n-this:\n+Rust also has a `while` loop. It looks like this:\n \n ```{rust}\n let mut x = 5; // mut x: u32\n let mut done = false; // mut done: bool\n \n while !done {\n     x += x - 3;\n+\n     println!(\"{}\", x);\n-    if x % 5 == 0 { done = true; }\n+\n+    if x % 5 == 0 {\n+        done = true;\n+    }\n }\n ```\n \n-`while` loops are the correct choice when you're not sure how many times\n+`while` loops are the correct choice when you\u2019re not sure how many times\n you need to loop.\n \n If you need an infinite loop, you may be tempted to write this:\n \n-```{rust,ignore}\n+```rust,ignore\n while true {\n ```\n \n However, Rust has a dedicated keyword, `loop`, to handle this case:\n \n-```{rust,ignore}\n+```rust,ignore\n loop {\n ```\n \n-Rust's control-flow analysis treats this construct differently than a\n-`while true`, since we know that it will always loop. The details of what\n-that _means_ aren't super important to understand at this stage, but in\n-general, the more information we can give to the compiler, the better it\n-can do with safety and code generation, so you should always prefer\n-`loop` when you plan to loop infinitely.\n+Rust\u2019s control-flow analysis treats this construct differently than a `while\n+true`, since we know that it will always loop. In general, the more information\n+we can give to the compiler, the better it can do with safety and code\n+generation, so you should always prefer `loop` when you plan to loop\n+infinitely.\n \n ## Ending iteration early\n \n-Let's take a look at that `while` loop we had earlier:\n+Let\u2019s take a look at that `while` loop we had earlier:\n \n-```{rust}\n+```rust\n let mut x = 5;\n let mut done = false;\n \n while !done {\n     x += x - 3;\n+\n     println!(\"{}\", x);\n-    if x % 5 == 0 { done = true; }\n+\n+    if x % 5 == 0 {\n+        done = true;\n+    }\n }\n ```\n \n@@ -57,12 +63,14 @@ modifying iteration: `break` and `continue`.\n \n In this case, we can write the loop in a better way with `break`:\n \n-```{rust}\n+```rust\n let mut x = 5;\n \n loop {\n     x += x - 3;\n+\n     println!(\"{}\", x);\n+\n     if x % 5 == 0 { break; }\n }\n ```\n@@ -72,12 +80,14 @@ We now loop forever with `loop` and use `break` to break out early.\n `continue` is similar, but instead of ending the loop, goes to the next\n iteration. This will only print the odd numbers:\n \n-```{rust}\n+```rust\n for x in 0..10 {\n     if x % 2 == 0 { continue; }\n \n     println!(\"{}\", x);\n }\n ```\n \n-Both `continue` and `break` are valid in both kinds of loops.\n+Both `continue` and `break` are valid in both `while` loops and [`for` loops][for].\n+\n+[for]: for-loops.html"}, {"sha": "7c207385393c92f2262b278263799893c8d3af10", "filename": "src/etc/rustup.sh", "status": "removed", "additions": 0, "deletions": 615, "changes": 615, "blob_url": "https://github.com/rust-lang/rust/blob/67a8f61730418768f07d8ed0f9735a31d0c5d84d/src%2Fetc%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/67a8f61730418768f07d8ed0f9735a31d0c5d84d/src%2Fetc%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frustup.sh?ref=67a8f61730418768f07d8ed0f9735a31d0c5d84d", "patch": "@@ -1,615 +0,0 @@\n-#!/bin/sh\n-# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-\n-msg() {\n-    echo \"rustup: $1\"\n-}\n-\n-step_msg() {\n-    msg\n-    msg \"$1\"\n-    msg\n-}\n-\n-warn() {\n-    echo \"rustup: WARNING: $1\"\n-}\n-\n-err() {\n-    echo \"rustup: error: $1\"\n-    exit 1\n-}\n-\n-need_ok() {\n-    if [ $? -ne 0 ]\n-    then\n-        err \"$1\"\n-    fi\n-}\n-\n-\n-putvar() {\n-    local T\n-    eval T=\\$$1\n-    eval TLEN=\\${#$1}\n-    if [ $TLEN -gt 35 ]\n-    then\n-        printf \"rustup: %-20s := %.35s ...\\n\" $1 \"$T\"\n-    else\n-        printf \"rustup: %-20s := %s %s\\n\" $1 \"$T\" \"$2\"\n-    fi\n-}\n-\n-probe() {\n-    local V=$1\n-    shift\n-    local P\n-    local T\n-    for P\n-    do\n-        T=$(which $P 2>&1)\n-        if [ $? -eq 0 ]\n-        then\n-            VER0=$($P --version 2>/dev/null | head -1 \\\n-                |  sed -e 's/[^0-9]*\\([vV]\\?[0-9.]\\+[^ ]*\\).*/\\1/' )\n-            if [ $? -eq 0 -a \"x${VER0}\" != \"x\" ]\n-            then\n-              VER=\"($VER0)\"\n-            else\n-              VER=\"\"\n-            fi\n-            break\n-        else\n-            VER=\"\"\n-            T=\"\"\n-        fi\n-    done\n-    eval $V=\\$T\n-    putvar $V \"$VER\"\n-}\n-\n-probe_need() {\n-    local V=$1\n-    probe $*\n-    eval VV=\\$$V\n-    if [ -z \"$VV\" ]\n-    then\n-        err \"needed, but unable to find any of: $*\"\n-    fi\n-}\n-\n-\n-valopt() {\n-    VAL_OPTIONS=\"$VAL_OPTIONS $1\"\n-\n-    local OP=$1\n-    local DEFAULT=$2\n-    shift\n-    shift\n-    local DOC=\"$*\"\n-    if [ $HELP -eq 0 ]\n-    then\n-        local UOP=$(echo $OP | tr '[:lower:]' '[:upper:]' | tr '\\-' '\\_')\n-        local V=\"CFG_${UOP}\"\n-        eval $V=\"$DEFAULT\"\n-        for arg in $CFG_ARGS\n-        do\n-            if echo \"$arg\" | grep -q -- \"--$OP=\"\n-            then\n-                val=$(echo \"$arg\" | cut -f2 -d=)\n-                eval $V=$val\n-            fi\n-        done\n-        putvar $V\n-    else\n-        if [ -z \"$DEFAULT\" ]\n-        then\n-            DEFAULT=\"<none>\"\n-        fi\n-        OP=\"${OP}=[${DEFAULT}]\"\n-        printf \"    --%-30s %s\\n\" \"$OP\" \"$DOC\"\n-    fi\n-}\n-\n-opt() {\n-    BOOL_OPTIONS=\"$BOOL_OPTIONS $1\"\n-\n-    local OP=$1\n-    local DEFAULT=$2\n-    shift\n-    shift\n-    local DOC=\"$*\"\n-    local FLAG=\"\"\n-\n-    if [ $DEFAULT -eq 0 ]\n-    then\n-        FLAG=\"enable\"\n-    else\n-        FLAG=\"disable\"\n-        DOC=\"don't $DOC\"\n-    fi\n-\n-    if [ $HELP -eq 0 ]\n-    then\n-        for arg in $CFG_ARGS\n-        do\n-            if [ \"$arg\" = \"--${FLAG}-${OP}\" ]\n-            then\n-                OP=$(echo $OP | tr 'a-z-' 'A-Z_')\n-                FLAG=$(echo $FLAG | tr 'a-z' 'A-Z')\n-                local V=\"CFG_${FLAG}_${OP}\"\n-                eval $V=1\n-                putvar $V\n-            fi\n-        done\n-    else\n-        if [ ! -z \"$META\" ]\n-        then\n-            OP=\"$OP=<$META>\"\n-        fi\n-        printf \"    --%-30s %s\\n\" \"$FLAG-$OP\" \"$DOC\"\n-     fi\n-}\n-\n-flag() {\n-    BOOL_OPTIONS=\"$BOOL_OPTIONS $1\"\n-\n-    local OP=$1\n-    shift\n-    local DOC=\"$*\"\n-\n-    if [ $HELP -eq 0 ]\n-    then\n-        for arg in $CFG_ARGS\n-        do\n-            if [ \"$arg\" = \"--${OP}\" ]\n-            then\n-                OP=$(echo $OP | tr 'a-z-' 'A-Z_')\n-                local V=\"CFG_${OP}\"\n-                eval $V=1\n-                putvar $V\n-            fi\n-        done\n-    else\n-        if [ ! -z \"$META\" ]\n-        then\n-            OP=\"$OP=<$META>\"\n-        fi\n-        printf \"    --%-30s %s\\n\" \"$OP\" \"$DOC\"\n-     fi\n-}\n-\n-validate_opt() {\n-    for arg in $CFG_ARGS\n-    do\n-        isArgValid=0\n-        for option in $BOOL_OPTIONS\n-        do\n-            if test --disable-$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-            if test --enable-$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-            if test --$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-        done\n-        for option in $VAL_OPTIONS\n-        do\n-            if echo \"$arg\" | grep -q -- \"--$option=\"\n-            then\n-                isArgValid=1\n-            fi\n-        done\n-        if [ \"$arg\" = \"--help\" ]\n-        then\n-            echo\n-            echo \"No more help available for Configure options,\"\n-            echo \"check the Wiki or join our IRC channel\"\n-            break\n-        else\n-            if test $isArgValid -eq 0\n-            then\n-                err \"Option '$arg' is not recognized\"\n-            fi\n-        fi\n-    done\n-}\n-\n-create_tmp_dir() {\n-    local TMP_DIR=`pwd`/rustup-tmp-install\n-\n-    rm -Rf \"${TMP_DIR}\"\n-    need_ok \"failed to remove temporary installation directory\"\n-\n-    mkdir -p \"${TMP_DIR}\"\n-    need_ok \"failed to create create temporary installation directory\"\n-\n-    echo $TMP_DIR\n-}\n-\n-# Make `tr` locale independent\n-LC_CTYPE=C\n-\n-probe_need CFG_CURL  curl\n-probe_need CFG_TAR   tar\n-probe_need CFG_FILE  file\n-\n-probe CFG_SHA256SUM sha256sum\n-probe CFG_SHASUM shasum\n-\n-if [ -z \"$CFG_SHA256SUM\" -a -z \"$CFG_SHASUM\" ]; then\n-    err \"unable to find either sha256sum or shasum\"\n-fi\n-\n-calculate_hash() {\n-    if [ -n \"$CFG_SHA256SUM\" ]; then\n-        ${CFG_SHA256SUM} $@\n-    else\n-        ${CFG_SHASUM} -a 256 $@\n-    fi\n-}\n-\n-CFG_SRC_DIR=\"$(cd $(dirname $0) && pwd)/\"\n-CFG_SELF=\"$0\"\n-CFG_ARGS=\"$@\"\n-\n-HELP=0\n-if [ \"$1\" = \"--help\" ]\n-then\n-    HELP=1\n-    shift\n-    echo\n-    echo \"Usage: $CFG_SELF [options]\"\n-    echo\n-    echo \"Options:\"\n-    echo\n-else\n-    step_msg \"processing $CFG_SELF args\"\n-fi\n-\n-OPTIONS=\"\"\n-BOOL_OPTIONS=\"\"\n-VAL_OPTIONS=\"\"\n-\n-flag uninstall \"only uninstall from the installation prefix\"\n-valopt prefix \"${RUSTUP_PREFIX}\" \"set installation prefix\"\n-valopt date \"\" \"use the YYYY-MM-DD nightly instead of the current nightly\"\n-valopt channel \"beta\" \"use the selected release channel [beta]\"\n-flag save \"save the downloaded nightlies to ~/.rustup\"\n-\n-if [ $HELP -eq 1 ]\n-then\n-    echo\n-    exit 0\n-fi\n-\n-step_msg \"validating $CFG_SELF args\"\n-validate_opt\n-\n-\n-# Platform detection copied from `configure`\n-\n-CFG_OSTYPE=$(uname -s)\n-CFG_CPUTYPE=$(uname -m)\n-\n-if [ $CFG_OSTYPE = Darwin -a $CFG_CPUTYPE = i386 ]\n-then\n-    # Darwin's `uname -m` lies and always returns i386. We have to use sysctl\n-    # instead.\n-    if sysctl hw.optional.x86_64 | grep -q ': 1'\n-    then\n-        CFG_CPUTYPE=x86_64\n-    fi\n-fi\n-\n-# The goal here is to come up with the same triple as LLVM would,\n-# at least for the subset of platforms we're willing to target.\n-\n-case $CFG_OSTYPE in\n-\n-    Linux)\n-        CFG_OSTYPE=unknown-linux-gnu\n-        ;;\n-\n-    FreeBSD)\n-        CFG_OSTYPE=unknown-freebsd\n-        ;;\n-\n-    Darwin)\n-        CFG_OSTYPE=apple-darwin\n-        ;;\n-\n-    MINGW32*)\n-        CFG_OSTYPE=pc-mingw32\n-        ;;\n-# Thad's Cygwin identifiers below\n-\n-#   Vista 32 bit\n-    CYGWIN_NT-6.0)\n-        CFG_OSTYPE=pc-mingw32\n-        CFG_CPUTYPE=i686\n-        ;;\n-\n-#   Vista 64 bit\n-    CYGWIN_NT-6.0-WOW64)\n-        CFG_OSTYPE=w64-mingw32\n-        CFG_CPUTYPE=x86_64\n-        ;;\n-\n-#   Win 7 32 bit\n-    CYGWIN_NT-6.1)\n-        CFG_OSTYPE=pc-mingw32\n-        CFG_CPUTYPE=i686\n-        ;;\n-\n-#   Win 7 64 bit\n-    CYGWIN_NT-6.1-WOW64)\n-        CFG_OSTYPE=w64-mingw32\n-        CFG_CPUTYPE=x86_64\n-        ;;\n-\n-# We do not detect other OS such as XP/2003 using 64 bit using uname.\n-# If we want to in the future, we will need to use Cygwin\n-# Chuck's csih helper in /usr/lib/csih/winProductName.exe or alternative.\n-    *)\n-        err \"unknown OS type: $CFG_OSTYPE\"\n-        ;;\n-esac\n-\n-\n-case $CFG_CPUTYPE in\n-\n-    i386 | i486 | i686 | i786 | x86)\n-        CFG_CPUTYPE=i686\n-        ;;\n-\n-    xscale | arm)\n-        CFG_CPUTYPE=arm\n-        ;;\n-\n-    x86_64 | x86-64 | x64 | amd64)\n-        CFG_CPUTYPE=x86_64\n-        ;;\n-\n-    *)\n-        err \"unknown CPU type: $CFG_CPUTYPE\"\n-esac\n-\n-# Detect 64 bit linux systems with 32 bit userland and force 32 bit compilation\n-if [ $CFG_OSTYPE = unknown-linux-gnu -a $CFG_CPUTYPE = x86_64 ]\n-then\n-    \"${CFG_FILE}\" -L \"$SHELL\" | grep -q \"x86[_-]64\"\n-    if [ $? != 0 ]; then\n-        CFG_CPUTYPE=i686\n-    fi\n-fi\n-\n-HOST_TRIPLE=\"${CFG_CPUTYPE}-${CFG_OSTYPE}\"\n-\n-# Is this a triple we have nightlies for?\n-case $HOST_TRIPLE in\n-\n-        x86_64-unknown-linux-gnu)\n-                ;;\n-\n-        i686-unknown-linux-gnu)\n-                ;;\n-\n-        x86_64-apple-darwin)\n-                ;;\n-\n-        i686-apple-darwin)\n-                ;;\n-\n-        *)\n-                err \"rustup.sh doesn't work for host $HOST_TRIPLE\"\n-\n-esac\n-\n-msg \"host triple: ${HOST_TRIPLE}\"\n-\n-CFG_INSTALL_FLAGS=\"\"\n-if [ -n \"${CFG_UNINSTALL}\" ]\n-then\n-    CFG_INSTALL_FLAGS=\"${CFG_INSTALL_FLAGS} --uninstall\"\n-fi\n-\n-if [ -n \"${CFG_PREFIX}\" ]\n-then\n-    CFG_INSTALL_FLAGS=\"${CFG_INSTALL_FLAGS} --prefix=${CFG_PREFIX}\"\n-fi\n-\n-CFG_TMP_DIR=$(mktemp -d 2>/dev/null \\\n-           || mktemp -d -t 'rustup-tmp-install' 2>/dev/null \\\n-           || create_tmp_dir)\n-\n-# If we're saving nightlies and we didn't specify which one, grab the latest\n-# version from the perspective of the server. Buildbot has typically finished\n-# building and uploading by ~8UTC, but we want to include a little buffer.\n-#\n-# FIXME It would be better to use the known most recent nightly that has been\n-# built. This is waiting on a change to have buildbot publish metadata that\n-# can be queried.\n-if [ -n \"${CFG_SAVE}\" -a -z \"${CFG_DATE}\" ];\n-then\n-    CFG_DATE=`TZ=Etc/UTC+9 date \"+%Y-%m-%d\"`\n-fi\n-\n-RUST_URL=\"https://static.rust-lang.org/dist\"\n-case \"$CFG_CHANNEL\" in\n-    nightly)\n-        # add a date suffix if we want a particular nightly.\n-        if [ -n \"${CFG_DATE}\" ];\n-        then\n-            RUST_URL=\"${RUST_URL}/${CFG_DATE}\"\n-        fi\n-\n-        RUST_PACKAGE_NAME=rust-nightly\n-        ;;\n-    beta)\n-        RUST_PACKAGE_NAME=rust-1.0.0-beta\n-        ;;\n-    *)\n-        err \"Currently 'beta' and 'nightly' are the only supported channels\"\n-esac\n-\n-RUST_PACKAGE_NAME_AND_TRIPLE=\"${RUST_PACKAGE_NAME}-${HOST_TRIPLE}\"\n-RUST_TARBALL_NAME=\"${RUST_PACKAGE_NAME_AND_TRIPLE}.tar.gz\"\n-RUST_LOCAL_INSTALL_DIR=\"${CFG_TMP_DIR}/${RUST_PACKAGE_NAME_AND_TRIPLE}\"\n-RUST_LOCAL_INSTALL_SCRIPT=\"${RUST_LOCAL_INSTALL_DIR}/install.sh\"\n-\n-download_hash() {\n-    msg \"Downloading ${remote_sha256}\"\n-    remote_sha256=`\"${CFG_CURL}\" -f \"${remote_sha256}\"`\n-    if [ -n \"${CFG_SAVE}\" ]; then\n-        echo \"${remote_sha256}\" > \"${local_sha_file}\"\n-    fi\n-    if [ \"$?\" -ne 0 ]; then\n-        rm -Rf \"${CFG_TMP_DIR}\"\n-        err \"Failed to download ${remote_url}\"\n-    fi\n-}\n-\n-verify_hash() {\n-    remote_sha256=\"$1\"\n-    local_file=\"$2\"\n-    local_sha_file=\"${local_file}.sha256\"\n-\n-    if [ -n \"${CFG_SAVE}\" ]; then\n-        if [ -f \"${local_sha_file}\" ]; then\n-            msg \"Local ${local_sha_file} exists, treating as remote hash\"\n-            remote_sha256=`cat \"${local_sha_file}\"`\n-        else\n-            download_hash\n-        fi\n-    else\n-        download_hash\n-    fi\n-\n-    msg \"Verifying hash\"\n-    local_sha256=$(calculate_hash \"${local_file}\")\n-    if [ \"$?\" -ne 0 ]; then\n-        rm -Rf \"${CFG_TMP_DIR}\"\n-        err \"Failed to compute hash for ${local_tarball}\"\n-    fi\n-\n-    # We only need the sha, not the filenames\n-    remote_sha256=`echo ${remote_sha256} | cut -f 1 -d ' '`\n-    local_sha256=`echo ${local_sha256} | cut -f 1 -d ' '`\n-\n-    if [ \"${remote_sha256}\" != \"${local_sha256}\" ]; then\n-        rm -Rf \"${CFG_TMP_DIR}\"\n-        errmsg=\"invalid sha256.\\n\"\n-        errmsg=\"$errmsg ${remote_sha256}\\t${remote_tarball}\\n\"\n-        errmsg=\"$errmsg ${local_sha256}\\t${local_tarball}\"\n-        err \"$errmsg\"\n-    fi\n-}\n-\n-# Fetch the package. Optionally caches the tarballs.\n-download_package() {\n-    remote_tarball=\"$1\"\n-    local_tarball=\"$2\"\n-    remote_sha256=\"${remote_tarball}.sha256\"\n-\n-    # Check if we've already downloaded this file.\n-    if [ -e \"${local_tarball}.tmp\" ]; then\n-        msg \"Resuming ${remote_tarball} to ${local_tarball}\"\n-\n-        \"${CFG_CURL}\" -f -C - -o \"${local_tarball}.tmp\" \"${remote_tarball}\"\n-        if [ $? -ne 0 ]\n-        then\n-            rm -Rf \"${CFG_TMP_DIR}\"\n-            err \"failed to download installer\"\n-        fi\n-\n-        mv \"${local_tarball}.tmp\" \"${local_tarball}\"\n-    elif [ ! -e \"${local_tarball}\" ]; then\n-        msg \"Downloading ${remote_tarball} to ${local_tarball}\"\n-\n-        \"${CFG_CURL}\" -f -o \"${local_tarball}.tmp\" \"${remote_tarball}\"\n-        if [ $? -ne 0 ]\n-        then\n-            rm -Rf \"${CFG_TMP_DIR}\"\n-            err \"failed to download installer\"\n-        fi\n-\n-        mv \"${local_tarball}.tmp\" \"${local_tarball}\"\n-    fi\n-\n-    verify_hash \"${remote_sha256}\" \"${local_tarball}\"\n-}\n-\n-# Wrap all the commands needed to install a package.\n-install_package() {\n-    local_tarball=\"$1\"\n-    install_script=\"$2\"\n-\n-    msg \"Extracting ${local_tarball}\"\n-    (cd \"${CFG_TMP_DIR}\" && \"${CFG_TAR}\" -xzf \"${local_tarball}\")\n-    if [ $? -ne 0 ]; then\n-        rm -Rf \"${CFG_TMP_DIR}\"\n-        err \"failed to unpack installer\"\n-    fi\n-\n-    sh \"${install_script}\" \"${CFG_INSTALL_FLAGS}\"\n-    if [ $? -ne 0 ]\n-    then\n-        rm -Rf \"${CFG_TMP_DIR}\"\n-        err \"failed to install Rust\"\n-    fi\n-}\n-\n-# It's possible that curl could be interrupted partway though downloading\n-# `rustup.sh`, truncating the file. This could be especially bad if we were in\n-# the middle of a line that would run \"rm -rf \". To protect against this, we\n-# wrap up the `rustup.sh` destructive functionality in this helper function,\n-# which we call as the last thing we do. This means we will not do anything\n-# unless we have the entire file downloaded.\n-install_packages() {\n-    rm -Rf \"${CFG_TMP_DIR}\"\n-    need_ok \"failed to remove temporary installation directory\"\n-\n-    mkdir -p \"${CFG_TMP_DIR}\"\n-    need_ok \"failed to create create temporary installation directory\"\n-\n-    # If we're saving our nightlies, put them in $HOME/.rustup.\n-    if [ -n \"${CFG_SAVE}\" ]\n-    then\n-        RUST_DOWNLOAD_DIR=\"${HOME}/.rustup/${CFG_DATE}\"\n-    else\n-        RUST_DOWNLOAD_DIR=\"${CFG_TMP_DIR}\"\n-    fi\n-\n-    mkdir -p \"${RUST_DOWNLOAD_DIR}\"\n-    need_ok \"failed to create create download directory\"\n-\n-    RUST_LOCAL_TARBALL=\"${RUST_DOWNLOAD_DIR}/${RUST_TARBALL_NAME}\"\n-\n-    download_package \\\n-        \"${RUST_URL}/${RUST_TARBALL_NAME}\" \\\n-        \"${RUST_LOCAL_TARBALL}\"\n-\n-    install_package \\\n-        \"${RUST_LOCAL_TARBALL}\" \\\n-        \"${RUST_LOCAL_INSTALL_SCRIPT}\"\n-\n-    rm -Rf \"${CFG_TMP_DIR}\"\n-    need_ok \"couldn't rm temporary installation directory\"\n-}\n-\n-install_packages"}, {"sha": "e190fb422261534c83fed4f8f3825c5c464ca95e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -362,10 +362,6 @@ fn test_arena_destructors_fail() {\n }\n \n /// A faster arena that can hold objects of only one type.\n-///\n-/// Safety note: Modifying objects in the arena that have already had their\n-/// `drop` destructors run can cause leaks, because the destructor will not\n-/// run again for these objects.\n pub struct TypedArena<T> {\n     /// A pointer to the next object to be allocated.\n     ptr: Cell<*const T>,"}, {"sha": "7332bf4670ae58efd9ce4c42a7143b2e6fc6d31c", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -39,7 +39,7 @@ use self::Cow::*;\n /// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Borrow<Borrowed: ?Sized> {\n-    /// Immutably borrow from an owned value.\n+    /// Immutably borrows from an owned value.\n     ///\n     /// # Examples\n     ///\n@@ -67,7 +67,7 @@ pub trait Borrow<Borrowed: ?Sized> {\n /// Similar to `Borrow`, but for mutable borrows.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n-    /// Mutably borrow from an owned value.\n+    /// Mutably borrows from an owned value.\n     ///\n     /// # Examples\n     ///\n@@ -126,7 +126,7 @@ impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B> where B: ToOwned, <B as ToOwned>::O\n     }\n }\n \n-/// A generalization of Clone to borrowed data.\n+/// A generalization of `Clone` to borrowed data.\n ///\n /// Some types make it possible to go from borrowed to owned, usually by\n /// implementing the `Clone` trait. But `Clone` works only for going from `&T`\n@@ -137,7 +137,7 @@ pub trait ToOwned {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Owned: Borrow<Self>;\n \n-    /// Create owned data from borrowed data, usually by copying.\n+    /// Creates owned data from borrowed data, usually by cloning.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_owned(&self) -> Self::Owned;\n }\n@@ -155,9 +155,9 @@ impl<T> ToOwned for T where T: Clone {\n /// data lazily when mutation or ownership is required. The type is designed to\n /// work with general borrowed data via the `Borrow` trait.\n ///\n-/// `Cow` implements both `Deref`, which means that you can call\n+/// `Cow` implements `Deref`, which means that you can call\n /// non-mutating methods directly on the data it encloses. If mutation\n-/// is desired, `to_mut` will obtain a mutable references to an owned\n+/// is desired, `to_mut` will obtain a mutable reference to an owned\n /// value, cloning if necessary.\n ///\n /// # Examples\n@@ -200,7 +200,7 @@ impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n }\n \n impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n-    /// Acquire a mutable reference to the owned form of the data.\n+    /// Acquires a mutable reference to the owned form of the data.\n     ///\n     /// Copies the data if it is not already owned.\n     ///\n@@ -226,7 +226,7 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n         }\n     }\n \n-    /// Extract the owned data.\n+    /// Extracts the owned data.\n     ///\n     /// Copies the data if it is not already owned.\n     ///\n@@ -327,7 +327,7 @@ impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned\n     }\n }\n \n-/// Trait for moving into a `Cow`\n+/// Trait for moving into a `Cow`.\n #[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\")]\n pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n     /// Moves `self` into `Cow`"}, {"sha": "e704a956492962121206b8383c4f20f3ed58c3fa", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -313,7 +313,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     // 2) While ODS may potentially return the pair we *just* inserted after\n     // the split, we will never do this. Again, this shouldn't effect the analysis.\n \n-    /// Inserts a key-value pair from the map. If the key already had a value\n+    /// Inserts a key-value pair into the map. If the key already had a value\n     /// present in the map, that value is returned. Otherwise, `None` is returned.\n     ///\n     /// # Examples"}, {"sha": "c308cdfc8b82cbd6dfdd26e69ec6b7ccf407a8ad", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -525,8 +525,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `index` is not between `0` and the vector's length (both\n-    /// bounds inclusive).\n+    /// Panics if `index` is greater than the vector's length.\n     ///\n     /// # Examples\n     ///"}, {"sha": "3d9d8cf51ec6e2c82ff6e78023e33dbb73ee0c2a", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -576,7 +576,7 @@ impl<V> VecMap<V> {\n         }\n     }\n \n-    /// Inserts a key-value pair from the map. If the key already had a value\n+    /// Inserts a key-value pair into the map. If the key already had a value\n     /// present in the map, that value is returned. Otherwise, `None` is returned.\n     ///\n     /// # Examples"}, {"sha": "1c1ad5fd33fb8bdfbaf142e4244853db5b469170", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -10,15 +10,35 @@\n \n //! Traits for conversions between types.\n //!\n-//! The traits in this module provide a general way to talk about\n-//! conversions from one type to another. They follow the standard\n-//! Rust conventions of `as`/`to`/`into`/`from`.\n+//! The traits in this module provide a general way to talk about conversions from one type to\n+//! another. They follow the standard Rust conventions of `as`/`to`/`into`/`from`.\n+//!\n+//! Like many traits, these are often used as bounds for generic functions, to support arguments of\n+//! multiple types.\n+//!\n+//! See each trait for usage examples.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n \n /// A cheap, reference-to-reference conversion.\n+///\n+/// # Examples\n+///\n+/// Both `String` and `&str` implement `AsRef<str>`:\n+///\n+/// ```\n+/// fn is_hello<T: AsRef<str>>(s: T) {\n+///    assert_eq!(\"hello\", s.as_ref());\n+/// }\n+///\n+/// let s = \"hello\";\n+/// is_hello(s);\n+///\n+/// let s = \"hello\".to_string();\n+/// is_hello(s);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsRef<T: ?Sized> {\n     /// Performs the conversion.\n@@ -34,8 +54,21 @@ pub trait AsMut<T: ?Sized> {\n     fn as_mut(&mut self) -> &mut T;\n }\n \n-/// A conversion that consumes `self`, which may or may not be\n-/// expensive.\n+/// A conversion that consumes `self`, which may or may not be expensive.\n+///\n+/// # Examples\n+///\n+/// `String` implements `Into<Vec<u8>>`:\n+///\n+/// ```\n+/// fn is_hello<T: Into<Vec<u8>>>(s: T) {\n+///    let bytes = b\"hello\".to_vec();\n+///    assert_eq!(bytes, s.into());\n+/// }\n+///\n+/// let s = \"hello\".to_string();\n+/// is_hello(s);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Into<T>: Sized {\n     /// Performs the conversion.\n@@ -44,6 +77,19 @@ pub trait Into<T>: Sized {\n }\n \n /// Construct `Self` via a conversion.\n+///\n+/// # Examples\n+///\n+/// `String` implements `From<&str>`:\n+///\n+/// ```\n+/// let s = \"hello\";\n+/// let string = \"hello\".to_string();\n+///\n+/// let other_string: String = From::from(s);\n+///\n+/// assert_eq!(string, other_string);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait From<T> {\n     /// Performs the conversion."}, {"sha": "4e4a928d91f72cc25760e092d9dc72acaa73cadb", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -217,7 +217,7 @@ pub trait Int\n                reason = \"pending integer conventions\")]\n     fn trailing_zeros(self) -> u32;\n \n-    /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n+    /// Shifts the bits to the left by a specified amount, `n`, wrapping\n     /// the truncated bits to the end of the resulting integer.\n     ///\n     /// # Examples\n@@ -235,7 +235,7 @@ pub trait Int\n                reason = \"pending integer conventions\")]\n     fn rotate_left(self, n: u32) -> Self;\n \n-    /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n+    /// Shifts the bits to the right by a specified amount, `n`, wrapping\n     /// the truncated bits to the beginning of the resulting integer.\n     ///\n     /// # Examples\n@@ -856,9 +856,8 @@ macro_rules! int_impl {\n         ///\n         /// # Return value\n         ///\n-        /// `None` if the string did not represent a valid number.\n-        /// Otherwise, `Some(n)` where `n` is the integer represented\n-        /// by `src`.\n+        /// `Err(ParseIntError)` if the string did not represent a valid number.\n+        /// Otherwise, `Ok(n)` where `n` is the integer represented by `src`.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n@@ -937,7 +936,7 @@ macro_rules! int_impl {\n             (self as $UnsignedT).trailing_zeros()\n         }\n \n-        /// Shifts the bits to the left by a specified amount amount, `n`,\n+        /// Shifts the bits to the left by a specified amount, `n`,\n         /// wrapping the truncated bits to the end of the resulting integer.\n         ///\n         /// # Examples\n@@ -957,7 +956,7 @@ macro_rules! int_impl {\n             (self as $UnsignedT).rotate_left(n) as $T\n         }\n \n-        /// Shifts the bits to the right by a specified amount amount, `n`,\n+        /// Shifts the bits to the right by a specified amount, `n`,\n         /// wrapping the truncated bits to the beginning of the resulting\n         /// integer.\n         ///\n@@ -1224,11 +1223,10 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n+        /// ```\n+        /// let x: i32 = 2; // or any other integer type\n         ///\n-        /// assert_eq!(2.pow(4), 16);\n+        /// assert_eq!(x.pow(4), 16);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -1374,9 +1372,8 @@ macro_rules! uint_impl {\n         ///\n         /// # Return value\n         ///\n-        /// `None` if the string did not represent a valid number.\n-        /// Otherwise, `Some(n)` where `n` is the integer represented\n-        /// by `src`.\n+        /// `Err(ParseIntError)` if the string did not represent a valid number.\n+        /// Otherwise, `Ok(n)` where `n` is the integer represented by `src`.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n@@ -1457,7 +1454,7 @@ macro_rules! uint_impl {\n             unsafe { $cttz(self as $ActualT) as u32 }\n         }\n \n-        /// Shifts the bits to the left by a specified amount amount, `n`,\n+        /// Shifts the bits to the left by a specified amount, `n`,\n         /// wrapping the truncated bits to the end of the resulting integer.\n         ///\n         /// # Examples\n@@ -1479,7 +1476,7 @@ macro_rules! uint_impl {\n             (self << n) | (self >> (($BITS - n) % $BITS))\n         }\n \n-        /// Shifts the bits to the right by a specified amount amount, `n`,\n+        /// Shifts the bits to the right by a specified amount, `n`,\n         /// wrapping the truncated bits to the beginning of the resulting\n         /// integer.\n         ///\n@@ -2708,8 +2705,8 @@ macro_rules! from_str_radix_float_impl {\n             ///\n             /// # Return value\n             ///\n-            /// `None` if the string did not represent a valid number.  Otherwise,\n-            /// `Some(n)` where `n` is the floating-point number represented by `src`.\n+            /// `Err(ParseIntError)` if the string did not represent a valid number.  Otherwise,\n+            /// Otherwise, `Ok(n)` where `n` is the floating-point number represented by `src`.\n             #[inline]\n             #[allow(deprecated)]\n             fn from_str(src: &str) -> Result<$T, ParseFloatError> {\n@@ -2737,9 +2734,8 @@ macro_rules! from_str_radix_float_impl {\n             ///\n             /// # Return value\n             ///\n-            /// `None` if the string did not represent a valid number.\n-            /// Otherwise, `Some(n)` where `n` is the floating-point number\n-            /// represented by `src`.\n+            /// `Err(ParseIntError)` if the string did not represent a valid number.  Otherwise,\n+            /// Otherwise, `Ok(n)` where `n` is the floating-point number represented by `src`.\n             fn from_str_radix(src: &str, radix: u32)\n                               -> Result<$T, ParseFloatError> {\n                 use self::FloatErrorKind::*;"}, {"sha": "d21891ab23f1ceb0e52cc37a05a64039db53266d", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -26,7 +26,7 @@ use syntax::codemap::{DUMMY_SP, Span};\n use util::ppaux::Repr;\n \n #[derive(Copy, Clone)]\n-struct ParamIsLocal(bool);\n+struct InferIsLocal(bool);\n \n /// True if there exist types that satisfy both of the two given impls.\n pub fn overlapping_impls(infcx: &InferCtxt,\n@@ -60,7 +60,7 @@ fn overlap(selcx: &mut SelectionContext,\n \n     let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                 a_def_id,\n-                                                                util::free_substs_for_impl);\n+                                                                util::fresh_type_vars_for_impl);\n \n     let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                 b_def_id,\n@@ -104,7 +104,7 @@ pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRe\n \n     // if the orphan rules pass, that means that no ancestor crate can\n     // impl this, so it's up to us.\n-    if orphan_check_trait_ref(tcx, trait_ref, ParamIsLocal(false)).is_ok() {\n+    if orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(false)).is_ok() {\n         debug!(\"trait_ref_is_knowable: orphan check passed\");\n         return true;\n     }\n@@ -126,7 +126,7 @@ pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRe\n     // implemented by an upstream crate, which means that the impl\n     // must be visible to us, and -- since the trait is fundamental\n     // -- we can test.\n-    orphan_check_trait_ref(tcx, trait_ref, ParamIsLocal(true)).is_err()\n+    orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(true)).is_err()\n }\n \n type SubstsFn = for<'a,'tcx> fn(infcx: &InferCtxt<'a, 'tcx>,\n@@ -196,16 +196,16 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return Ok(());\n     }\n \n-    orphan_check_trait_ref(tcx, &trait_ref, ParamIsLocal(false))\n+    orphan_check_trait_ref(tcx, &trait_ref, InferIsLocal(false))\n }\n \n fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 trait_ref: &ty::TraitRef<'tcx>,\n-                                param_is_local: ParamIsLocal)\n+                                infer_is_local: InferIsLocal)\n                                 -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"orphan_check_trait_ref(trait_ref={}, param_is_local={})\",\n-           trait_ref.repr(tcx), param_is_local.0);\n+    debug!(\"orphan_check_trait_ref(trait_ref={}, infer_is_local={})\",\n+           trait_ref.repr(tcx), infer_is_local.0);\n \n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n@@ -215,12 +215,12 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // Find the first input type that either references a type parameter OR\n     // some local type.\n     for input_ty in input_tys {\n-        if ty_is_local(tcx, input_ty, param_is_local) {\n+        if ty_is_local(tcx, input_ty, infer_is_local) {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{}`\", input_ty.repr(tcx));\n \n             // First local input type. Check that there are no\n             // uncovered type parameters.\n-            let uncovered_tys = uncovered_tys(tcx, input_ty, param_is_local);\n+            let uncovered_tys = uncovered_tys(tcx, input_ty, infer_is_local);\n             for uncovered_ty in uncovered_tys {\n                 if let Some(param) = uncovered_ty.walk().find(|t| is_type_parameter(t)) {\n                     debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n@@ -234,7 +234,7 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Otherwise, enforce invariant that there are no type\n         // parameters reachable.\n-        if !param_is_local.0 {\n+        if !infer_is_local.0 {\n             if let Some(param) = input_ty.walk().find(|t| is_type_parameter(t)) {\n                 debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n                 return Err(OrphanCheckErr::UncoveredTy(param));\n@@ -249,14 +249,14 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n fn uncovered_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n                        ty: Ty<'tcx>,\n-                       param_is_local: ParamIsLocal)\n+                       infer_is_local: InferIsLocal)\n                        -> Vec<Ty<'tcx>>\n {\n-    if ty_is_local_constructor(tcx, ty, param_is_local) {\n+    if ty_is_local_constructor(tcx, ty, infer_is_local) {\n         vec![]\n     } else if fundamental_ty(tcx, ty) {\n         ty.walk_shallow()\n-          .flat_map(|t| uncovered_tys(tcx, t, param_is_local).into_iter())\n+          .flat_map(|t| uncovered_tys(tcx, t, infer_is_local).into_iter())\n           .collect()\n     } else {\n         vec![ty]\n@@ -271,10 +271,10 @@ fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, param_is_local: ParamIsLocal) -> bool\n+fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, infer_is_local: InferIsLocal) -> bool\n {\n-    ty_is_local_constructor(tcx, ty, param_is_local) ||\n-        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, param_is_local))\n+    ty_is_local_constructor(tcx, ty, infer_is_local) ||\n+        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, infer_is_local))\n }\n \n fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n@@ -293,7 +293,7 @@ fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n \n fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  ty: Ty<'tcx>,\n-                                 param_is_local: ParamIsLocal)\n+                                 infer_is_local: InferIsLocal)\n                                  -> bool\n {\n     debug!(\"ty_is_local_constructor({})\", ty.repr(tcx));\n@@ -310,13 +310,13 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n         ty::ty_ptr(..) |\n         ty::ty_rptr(..) |\n         ty::ty_tup(..) |\n-        ty::ty_infer(..) |\n+        ty::ty_param(..) |\n         ty::ty_projection(..) => {\n             false\n         }\n \n-        ty::ty_param(..) => {\n-            param_is_local.0\n+        ty::ty_infer(..) => {\n+            infer_is_local.0\n         }\n \n         ty::ty_enum(def_id, _) |"}, {"sha": "3a1be785580af1d4cb6746c04b6d97d88bb37dde", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::region;\n use middle::subst::{Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, AsPredicate, ToPolyTraitRef};\n@@ -304,34 +303,6 @@ pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n-// determine the `self` type, using fresh variables for all variables\n-// declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n-// would return ($0, $1) where $0 and $1 are freshly instantiated type\n-// variables.\n-pub fn free_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                      _span: Span,\n-                                      impl_def_id: ast::DefId)\n-                                      -> Substs<'tcx>\n-{\n-    let tcx = infcx.tcx;\n-    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n-\n-    let some_types = impl_generics.types.map(|def| {\n-        ty::mk_param_from_def(tcx, def)\n-    });\n-\n-    let some_regions = impl_generics.regions.map(|def| {\n-        // FIXME. This destruction scope information is pretty darn\n-        // bogus; after all, the impl might not even be in this crate!\n-        // But given what we do in coherence, it is harmless enough\n-        // for now I think. -nmatsakis\n-        let extent = region::DestructionScopeData::new(ast::DUMMY_NODE_ID);\n-        ty::free_region_from_def(extent, def)\n-    });\n-\n-    Substs::new(some_types, some_regions)\n-}\n-\n impl<'tcx, N> fmt::Debug for VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableImpl({:?})\", self.impl_def_id)"}, {"sha": "88faf1cb68ae4db505359543eff52f5c592f25d1", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -143,6 +143,13 @@ impl Session {\n     pub fn span_end_note(&self, sp: Span, msg: &str) {\n         self.diagnostic().span_end_note(sp, msg)\n     }\n+\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n+        self.diagnostic().span_suggestion(sp, msg, suggestion)\n+    }\n     pub fn span_help(&self, sp: Span, msg: &str) {\n         self.diagnostic().span_help(sp, msg)\n     }"}, {"sha": "db947a27472ada5eb768cdf9ac7f1e6cb7e2448d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -522,6 +522,16 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     pub fn report(&self, err: BckError<'tcx>) {\n+        // Catch and handle some particular cases.\n+        match (&err.code, &err.cause) {\n+            (&err_out_of_scope(ty::ReScope(_), ty::ReStatic), &euv::ClosureCapture(span)) |\n+            (&err_out_of_scope(ty::ReScope(_), ty::ReFree(..)), &euv::ClosureCapture(span)) => {\n+                return self.report_out_of_scope_escaping_closure_capture(&err, span);\n+            }\n+            _ => { }\n+        }\n+\n+        // General fallback.\n         self.span_err(\n             err.span,\n             &self.bckerr_to_string(&err));\n@@ -796,16 +806,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 format!(\"{} does not live long enough\", msg)\n             }\n             err_borrowed_pointer_too_short(..) => {\n-                let descr = match opt_loan_path(&err.cmt) {\n-                    Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_string(&*lp))\n-                    }\n-                    None => self.cmt_to_string(&*err.cmt),\n-                };\n-\n+                let descr = self.cmt_to_path_or_string(&err.cmt);\n                 format!(\"lifetime of {} is too short to guarantee \\\n-                                its contents can be safely reborrowed\",\n-                               descr)\n+                         its contents can be safely reborrowed\",\n+                        descr)\n             }\n         }\n     }\n@@ -888,6 +892,39 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn report_out_of_scope_escaping_closure_capture(&self,\n+                                                    err: &BckError<'tcx>,\n+                                                    capture_span: Span)\n+    {\n+        let cmt_path_or_string = self.cmt_to_path_or_string(&err.cmt);\n+\n+        span_err!(\n+            self.tcx.sess, err.span, E0373,\n+            \"closure may outlive the current function, \\\n+             but it borrows {}, \\\n+             which is owned by the current function\",\n+            cmt_path_or_string);\n+\n+        self.tcx.sess.span_note(\n+            capture_span,\n+            &format!(\"{} is borrowed here\",\n+                     cmt_path_or_string));\n+\n+        let suggestion =\n+            match self.tcx.sess.codemap().span_to_snippet(err.span) {\n+                Ok(string) => format!(\"move {}\", string),\n+                Err(_) => format!(\"move |<args>| <body>\")\n+            };\n+\n+        self.tcx.sess.span_suggestion(\n+            err.span,\n+            &format!(\"to force the closure to take ownership of {} \\\n+                      (and any other referenced variables), \\\n+                      use the `move` keyword, as shown:\",\n+                     cmt_path_or_string),\n+            suggestion);\n+    }\n+\n     pub fn note_and_explain_bckerr(&self, err: BckError<'tcx>) {\n         let code = err.code;\n         match code {\n@@ -1035,6 +1072,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn cmt_to_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n         cmt.descriptive_string(self.tcx)\n     }\n+\n+    pub fn cmt_to_path_or_string(&self, cmt: &mc::cmt<'tcx>) -> String {\n+        match opt_loan_path(cmt) {\n+            Some(lp) => format!(\"`{}`\", self.loan_path_to_string(&lp)),\n+            None => self.cmt_to_string(cmt),\n+        }\n+    }\n }\n \n fn is_statement_scope(tcx: &ty::ctxt, region: ty::Region) -> bool {"}, {"sha": "981b28593f9a4d20bba49937fda8b822b6e2bbc2", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_diagnostics! {\n+    E0373 // closure may outlive current fn, but it borrows {}, which is owned by current fn\n+}\n+\n+__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "647ea3555ba913984c8ed71be606c13e41851c86", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -40,6 +40,10 @@ pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n pub use borrowck::FnPartsWithCFG;\n \n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostics;\n+\n mod borrowck;\n \n pub mod graphviz;"}, {"sha": "54a3a0557686dca6e7f0b1d2e3983616a2e9c70d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -1107,7 +1107,7 @@ impl<K, V, S> HashMap<K, V, S>\n         self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n \n-    /// Inserts a key-value pair from the map. If the key already had a value\n+    /// Inserts a key-value pair into the map. If the key already had a value\n     /// present in the map, that value is returned. Otherwise, `None` is returned.\n     ///\n     /// # Examples"}, {"sha": "93b27b6ce9efdc7f9cc3ad54e00553ee0e559348", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -345,8 +345,8 @@ pub struct SendError<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RecvError;\n \n-/// This enumeration is the list of the possible reasons that try_recv could not\n-/// return data when called.\n+/// This enumeration is the list of the possible reasons that `try_recv` could\n+/// not return data when called.\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryRecvError {"}, {"sha": "f893ae243bbb6cf4926cf526d3f704d28d5797d2", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -367,7 +367,7 @@ impl Builder {\n ///\n /// # Panics\n ///\n-/// Panicks if the OS fails to create a thread; use `Builder::spawn`\n+/// Panics if the OS fails to create a thread; use `Builder::spawn`\n /// to recover from such errors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn spawn<F>(f: F) -> JoinHandle where F: FnOnce(), F: Send + 'static {\n@@ -385,7 +385,7 @@ pub fn spawn<F>(f: F) -> JoinHandle where F: FnOnce(), F: Send + 'static {\n ///\n /// # Panics\n ///\n-/// Panicks if the OS fails to create a thread; use `Builder::scoped`\n+/// Panics if the OS fails to create a thread; use `Builder::scoped`\n /// to recover from such errors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where"}, {"sha": "7635c8eadc26efab0fb7fce588aa10d33c04daba", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 92, "deletions": 13, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -49,7 +49,7 @@ pub struct BytePos(pub u32);\n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[derive(Copy, Clone, PartialEq, Hash, PartialOrd, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Debug)]\n pub struct CharPos(pub usize);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -305,9 +305,21 @@ impl ExpnId {\n \n pub type FileName = String;\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct LineInfo {\n+    /// Index of line, starting from 0.\n+    pub line_index: usize,\n+\n+    /// Column in line where span begins, starting from 0.\n+    pub start_col: CharPos,\n+\n+    /// Column in line where span ends, starting from 0, exclusive.\n+    pub end_col: CharPos,\n+}\n+\n pub struct FileLines {\n     pub file: Rc<FileMap>,\n-    pub lines: Vec<usize>\n+    pub lines: Vec<LineInfo>\n }\n \n /// Identifies an offset of a multi-byte character in a FileMap\n@@ -479,9 +491,9 @@ impl FileMap {\n         lines.push(pos);\n     }\n \n-    /// get a line from the list of pre-computed line-beginnings\n-    ///\n-    pub fn get_line(&self, line_number: usize) -> Option<String> {\n+    /// get a line from the list of pre-computed line-beginnings.\n+    /// line-number here is 0-based.\n+    pub fn get_line(&self, line_number: usize) -> Option<&str> {\n         match self.src {\n             Some(ref src) => {\n                 let lines = self.lines.borrow();\n@@ -492,7 +504,7 @@ impl FileMap {\n                     match slice.find('\\n') {\n                         Some(e) => &slice[..e],\n                         None => slice\n-                    }.to_string()\n+                    }\n                 })\n             }\n             None => None\n@@ -661,10 +673,29 @@ impl CodeMap {\n     pub fn span_to_lines(&self, sp: Span) -> FileLines {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n-        let mut lines = Vec::new();\n-        for i in lo.line - 1..hi.line {\n-            lines.push(i);\n-        };\n+        let mut lines = Vec::with_capacity(hi.line - lo.line + 1);\n+\n+        // The span starts partway through the first line,\n+        // but after that it starts from offset 0.\n+        let mut start_col = lo.col;\n+\n+        // For every line but the last, it extends from `start_col`\n+        // and to the end of the line. Be careful because the line\n+        // numbers in Loc are 1-based, so we subtract 1 to get 0-based\n+        // lines.\n+        for line_index in lo.line-1 .. hi.line-1 {\n+            let line_len = lo.file.get_line(line_index).map(|s| s.len()).unwrap_or(0);\n+            lines.push(LineInfo { line_index: line_index,\n+                                  start_col: start_col,\n+                                  end_col: CharPos::from_usize(line_len) });\n+            start_col = CharPos::from_usize(0);\n+        }\n+\n+        // For the last line, it extends from `start_col` to `hi.col`:\n+        lines.push(LineInfo { line_index: hi.line - 1,\n+                              start_col: start_col,\n+                              end_col: hi.col });\n+\n         FileLines {file: lo.file, lines: lines}\n     }\n \n@@ -919,17 +950,18 @@ pub struct MalformedCodemapPositions {\n #[cfg(test)]\n mod test {\n     use super::*;\n+    use std::rc::Rc;\n \n     #[test]\n     fn t1 () {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(\"blork.rs\".to_string(),\n                                 \"first line.\\nsecond line\".to_string());\n         fm.next_line(BytePos(0));\n-        assert_eq!(fm.get_line(0), Some(\"first line.\".to_string()));\n+        assert_eq!(fm.get_line(0), Some(\"first line.\"));\n         // TESTING BROKEN BEHAVIOR:\n         fm.next_line(BytePos(10));\n-        assert_eq!(fm.get_line(1), Some(\".\".to_string()));\n+        assert_eq!(fm.get_line(1), Some(\".\"));\n     }\n \n     #[test]\n@@ -1057,7 +1089,54 @@ mod test {\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n         assert_eq!(file_lines.lines.len(), 1);\n-        assert_eq!(file_lines.lines[0], 1);\n+        assert_eq!(file_lines.lines[0].line_index, 1);\n+    }\n+\n+    /// Given a string like \" ^~~~~~~~~~~~ \", produces a span\n+    /// coverting that range. The idea is that the string has the same\n+    /// length as the input, and we uncover the byte positions.  Note\n+    /// that this can span lines and so on.\n+    fn span_from_selection(input: &str, selection: &str) -> Span {\n+        assert_eq!(input.len(), selection.len());\n+        let left_index = selection.find('^').unwrap() as u32;\n+        let right_index = selection.rfind('~').unwrap() as u32;\n+        Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n+    }\n+\n+    fn new_filemap_and_lines(cm: &CodeMap, filename: &str, input: &str) -> Rc<FileMap> {\n+        let fm = cm.new_filemap(filename.to_string(), input.to_string());\n+        let mut byte_pos: u32 = 0;\n+        for line in input.lines() {\n+            // register the start of this line\n+            fm.next_line(BytePos(byte_pos));\n+\n+            // update byte_pos to include this line and the \\n at the end\n+            byte_pos += line.len() as u32 + 1;\n+        }\n+        fm\n+    }\n+\n+    /// Test span_to_snippet and span_to_lines for a span coverting 3\n+    /// lines in the middle of a file.\n+    #[test]\n+    fn span_to_snippet_and_lines_spanning_multiple_lines() {\n+        let cm = CodeMap::new();\n+        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n+        let selection = \"     \\n    ^~\\n~~~\\n~~~~~     \\n   \\n\";\n+        new_filemap_and_lines(&cm, \"blork.rs\", inputtext);\n+        let span = span_from_selection(inputtext, selection);\n+\n+        // check that we are extracting the text we thought we were extracting\n+        assert_eq!(&cm.span_to_snippet(span).unwrap(), \"BB\\nCCC\\nDDDDD\");\n+\n+        // check that span_to_lines gives us the complete result with the lines/cols we expected\n+        let lines = cm.span_to_lines(span);\n+        let expected = vec![\n+            LineInfo { line_index: 1, start_col: CharPos(4), end_col: CharPos(6) },\n+            LineInfo { line_index: 2, start_col: CharPos(0), end_col: CharPos(3) },\n+            LineInfo { line_index: 3, start_col: CharPos(0), end_col: CharPos(5) }\n+            ];\n+        assert_eq!(lines.lines, expected);\n     }\n \n     #[test]"}, {"sha": "ed7bdcd898e9357ebcfa60cd65d187623ba3aa0d", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 143, "deletions": 58, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -18,6 +18,7 @@ use codemap;\n use diagnostics;\n \n use std::cell::{RefCell, Cell};\n+use std::cmp;\n use std::fmt;\n use std::io::prelude::*;\n use std::io;\n@@ -28,28 +29,39 @@ use libc;\n /// maximum number of lines we will print for each error; arbitrary.\n const MAX_LINES: usize = 6;\n \n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n pub enum RenderSpan {\n     /// A FullSpan renders with both with an initial line for the\n     /// message, prefixed by file:linenum, followed by a summary of\n     /// the source code covered by the span.\n     FullSpan(Span),\n \n+    /// Similar to a FullSpan, but the cited position is the end of\n+    /// the span, instead of the start. Used, at least, for telling\n+    /// compiletest/runtest to look at the last line of the span\n+    /// (since `end_highlight_lines` displays an arrow to the end\n+    /// of the span).\n+    EndSpan(Span),\n+\n+    /// A suggestion renders with both with an initial line for the\n+    /// message, prefixed by file:linenum, followed by a summary\n+    /// of hypothetical source code, where the `String` is spliced\n+    /// into the lines in place of the code covered by the span.\n+    Suggestion(Span, String),\n+\n     /// A FileLine renders with just a line for the message prefixed\n     /// by file:linenum.\n     FileLine(Span),\n }\n \n impl RenderSpan {\n-    fn span(self) -> Span {\n-        match self {\n-            FullSpan(s) | FileLine(s) => s\n-        }\n-    }\n-    fn is_full_span(&self) -> bool {\n-        match self {\n-            &FullSpan(..) => true,\n-            &FileLine(..) => false,\n+    fn span(&self) -> Span {\n+        match *self {\n+            FullSpan(s) |\n+            Suggestion(s, _) |\n+            EndSpan(s) |\n+            FileLine(s) =>\n+                s\n         }\n     }\n }\n@@ -115,11 +127,17 @@ impl SpanHandler {\n         self.handler.emit(Some((&self.cm, sp)), msg, Note);\n     }\n     pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, FullSpan(sp), msg, Note);\n+        self.handler.custom_emit(&self.cm, EndSpan(sp), msg, Note);\n     }\n     pub fn span_help(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&self.cm, sp)), msg, Help);\n     }\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n+        self.handler.custom_emit(&self.cm, Suggestion(sp, suggestion), msg, Help);\n+    }\n     pub fn fileline_note(&self, sp: Span, msg: &str) {\n         self.handler.custom_emit(&self.cm, FileLine(sp), msg, Note);\n     }\n@@ -407,8 +425,8 @@ impl Emitter for EmitterWriter {\n         let error = match cmsp {\n             Some((cm, COMMAND_LINE_SP)) => emit(self, cm,\n                                                 FileLine(COMMAND_LINE_SP),\n-                                                msg, code, lvl, false),\n-            Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, code, lvl, false),\n+                                                msg, code, lvl),\n+            Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, code, lvl),\n             None => print_diagnostic(self, \"\", lvl, msg, code),\n         };\n \n@@ -420,43 +438,49 @@ impl Emitter for EmitterWriter {\n \n     fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: RenderSpan, msg: &str, lvl: Level) {\n-        match emit(self, cm, sp, msg, None, lvl, true) {\n+        match emit(self, cm, sp, msg, None, lvl) {\n             Ok(()) => {}\n             Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n         }\n     }\n }\n \n fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n-        msg: &str, code: Option<&str>, lvl: Level, custom: bool) -> io::Result<()> {\n+        msg: &str, code: Option<&str>, lvl: Level) -> io::Result<()> {\n     let sp = rsp.span();\n \n     // We cannot check equality directly with COMMAND_LINE_SP\n     // since PartialEq is manually implemented to ignore the ExpnId\n     let ss = if sp.expn_id == COMMAND_LINE_EXPN {\n         \"<command line option>\".to_string()\n+    } else if let EndSpan(_) = rsp {\n+        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n+        cm.span_to_string(span_end)\n     } else {\n         cm.span_to_string(sp)\n     };\n-    if custom {\n-        // we want to tell compiletest/runtest to look at the last line of the\n-        // span (since `custom_highlight_lines` displays an arrow to the end of\n-        // the span)\n-        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n-        let ses = cm.span_to_string(span_end);\n-        try!(print_diagnostic(dst, &ses[..], lvl, msg, code));\n-        if rsp.is_full_span() {\n-            try!(custom_highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n-        }\n-    } else {\n-        try!(print_diagnostic(dst, &ss[..], lvl, msg, code));\n-        if rsp.is_full_span() {\n+\n+    try!(print_diagnostic(dst, &ss[..], lvl, msg, code));\n+\n+    match rsp {\n+        FullSpan(_) => {\n             try!(highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n         }\n+        EndSpan(_) => {\n+            try!(end_highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n+        }\n+        Suggestion(_, ref suggestion) => {\n+            try!(highlight_suggestion(dst, cm, sp, suggestion));\n+        }\n+        FileLine(..) => {\n+            // no source text in this case!\n+        }\n     }\n+\n     if sp != COMMAND_LINE_SP {\n         try!(print_macro_backtrace(dst, cm, sp));\n     }\n+\n     match code {\n         Some(code) =>\n             match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n@@ -472,29 +496,90 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n     Ok(())\n }\n \n+fn highlight_suggestion(err: &mut EmitterWriter,\n+                        cm: &codemap::CodeMap,\n+                        sp: Span,\n+                        suggestion: &str)\n+                        -> io::Result<()>\n+{\n+    let lines = cm.span_to_lines(sp);\n+    assert!(!lines.lines.is_empty());\n+\n+    // To build up the result, we want to take the snippet from the first\n+    // line that precedes the span, prepend that with the suggestion, and\n+    // then append the snippet from the last line that trails the span.\n+    let fm = &lines.file;\n+\n+    let first_line = &lines.lines[0];\n+    let prefix = fm.get_line(first_line.line_index)\n+                   .map(|l| &l[..first_line.start_col.0])\n+                   .unwrap_or(\"\");\n+\n+    let last_line = lines.lines.last().unwrap();\n+    let suffix = fm.get_line(last_line.line_index)\n+                   .map(|l| &l[last_line.end_col.0..])\n+                   .unwrap_or(\"\");\n+\n+    let complete = format!(\"{}{}{}\", prefix, suggestion, suffix);\n+\n+    // print the suggestion without any line numbers, but leave\n+    // space for them. This helps with lining up with previous\n+    // snippets from the actual error being reported.\n+    let fm = &*lines.file;\n+    let mut lines = complete.lines();\n+    for (line, line_index) in lines.by_ref().take(MAX_LINES).zip(first_line.line_index..) {\n+        let elided_line_num = format!(\"{}\", line_index+1);\n+        try!(write!(&mut err.dst, \"{0}:{1:2$} {3}\\n\",\n+                    fm.name, \"\", elided_line_num.len(), line));\n+    }\n+\n+    // if we elided some lines, add an ellipsis\n+    if lines.next().is_some() {\n+        let elided_line_num = format!(\"{}\", first_line.line_index + MAX_LINES + 1);\n+        try!(write!(&mut err.dst, \"{0:1$} {0:2$} ...\\n\",\n+                    \"\", fm.name.len(), elided_line_num.len()));\n+    }\n+\n+    Ok(())\n+}\n+\n fn highlight_lines(err: &mut EmitterWriter,\n                    cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: codemap::FileLines) -> io::Result<()> {\n+                   lines: codemap::FileLines)\n+                   -> io::Result<()>\n+{\n     let fm = &*lines.file;\n \n-    let mut elided = false;\n-    let mut display_lines = &lines.lines[..];\n-    if display_lines.len() > MAX_LINES {\n-        display_lines = &display_lines[0..MAX_LINES];\n-        elided = true;\n-    }\n+    let line_strings: Option<Vec<&str>> =\n+        lines.lines.iter()\n+                   .map(|info| fm.get_line(info.line_index))\n+                   .collect();\n+\n+    let line_strings = match line_strings {\n+        None => { return Ok(()); }\n+        Some(line_strings) => line_strings\n+    };\n+\n+    // Display only the first MAX_LINES lines.\n+    let all_lines = lines.lines.len();\n+    let display_lines = cmp::min(all_lines, MAX_LINES);\n+    let display_line_infos = &lines.lines[..display_lines];\n+    let display_line_strings = &line_strings[..display_lines];\n+\n     // Print the offending lines\n-    for &line_number in display_lines {\n-        if let Some(line) = fm.get_line(line_number) {\n-            try!(write!(&mut err.dst, \"{}:{} {}\\n\", fm.name,\n-                        line_number + 1, line));\n-        }\n+    for (line_info, line) in display_line_infos.iter().zip(display_line_strings.iter()) {\n+        try!(write!(&mut err.dst, \"{}:{} {}\\n\",\n+                    fm.name,\n+                    line_info.line_index + 1,\n+                    line));\n     }\n-    if elided {\n-        let last_line = display_lines[display_lines.len() - 1];\n-        let s = format!(\"{}:{} \", fm.name, last_line + 1);\n+\n+    // If we elided something, put an ellipsis.\n+    if display_lines < all_lines {\n+        let last_line_index = display_line_infos.last().unwrap().line_index;\n+        let s = format!(\"{}:{} \", fm.name, last_line_index + 1);\n         try!(write!(&mut err.dst, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n@@ -503,7 +588,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     if lines.lines.len() == 1 {\n         let lo = cm.lookup_char_pos(sp.lo);\n         let mut digits = 0;\n-        let mut num = (lines.lines[0] + 1) / 10;\n+        let mut num = (lines.lines[0].line_index + 1) / 10;\n \n         // how many digits must be indent past?\n         while num > 0 { num /= 10; digits += 1; }\n@@ -515,7 +600,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n         for _ in 0..skip {\n             s.push(' ');\n         }\n-        if let Some(orig) = fm.get_line(lines.lines[0]) {\n+        if let Some(orig) = fm.get_line(lines.lines[0].line_index) {\n             let mut col = skip;\n             let mut lastc = ' ';\n             let mut iter = orig.chars().enumerate();\n@@ -575,12 +660,12 @@ fn highlight_lines(err: &mut EmitterWriter,\n }\n \n /// Here are the differences between this and the normal `highlight_lines`:\n-/// `custom_highlight_lines` will always put arrow on the last byte of the\n+/// `end_highlight_lines` will always put arrow on the last byte of the\n /// span (instead of the first byte). Also, when the span is too long (more\n-/// than 6 lines), `custom_highlight_lines` will print the first line, then\n+/// than 6 lines), `end_highlight_lines` will print the first line, then\n /// dot dot dot, then last line, whereas `highlight_lines` prints the first\n /// six lines.\n-fn custom_highlight_lines(w: &mut EmitterWriter,\n+fn end_highlight_lines(w: &mut EmitterWriter,\n                           cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n@@ -590,32 +675,32 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n \n     let lines = &lines.lines[..];\n     if lines.len() > MAX_LINES {\n-        if let Some(line) = fm.get_line(lines[0]) {\n+        if let Some(line) = fm.get_line(lines[0].line_index) {\n             try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                        lines[0] + 1, line));\n+                        lines[0].line_index + 1, line));\n         }\n         try!(write!(&mut w.dst, \"...\\n\"));\n-        let last_line_number = lines[lines.len() - 1];\n-        if let Some(last_line) = fm.get_line(last_line_number) {\n+        let last_line_index = lines[lines.len() - 1].line_index;\n+        if let Some(last_line) = fm.get_line(last_line_index) {\n             try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                        last_line_number + 1, last_line));\n+                        last_line_index + 1, last_line));\n         }\n     } else {\n-        for &line_number in lines {\n-            if let Some(line) = fm.get_line(line_number) {\n+        for line_info in lines {\n+            if let Some(line) = fm.get_line(line_info.line_index) {\n                 try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                            line_number + 1, line));\n+                            line_info.line_index + 1, line));\n             }\n         }\n     }\n-    let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1]+1);\n+    let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n     let hi = cm.lookup_char_pos(sp.hi);\n     let skip = last_line_start.width(false);\n     let mut s = String::new();\n     for _ in 0..skip {\n         s.push(' ');\n     }\n-    if let Some(orig) = fm.get_line(lines[0]) {\n+    if let Some(orig) = fm.get_line(lines[0].line_index) {\n         let iter = orig.chars().enumerate();\n         for (pos, ch) in iter {\n             // Span seems to use half-opened interval, so subtract 1"}, {"sha": "87e40df7663baacabd7c522321104fc0e7c82a61", "filename": "src/test/compile-fail/borrowck-escaping-closure-error-1.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-1.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::thread::spawn;\n+\n+// Test that we give a custom error (E0373) for the case where a\n+// closure is escaping current frame, and offer a suggested code edit.\n+// I refrained from including the precise message here, but the\n+// original text as of the time of this writing is:\n+//\n+//    closure may outlive the current function, but it borrows `books`,\n+//    which is owned by the current function\n+\n+fn main() {\n+    let mut books = vec![1,2,3];\n+    spawn(|| books.push(4));\n+    //~^ ERROR E0373\n+}"}, {"sha": "67700be890b1faa8a9c9090fdb0ea8382ddfd854", "filename": "src/test/compile-fail/borrowck-escaping-closure-error-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-2.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we give a custom error (E0373) for the case where a\n+// closure is escaping current frame, and offer a suggested code edit.\n+// I refrained from including the precise message here, but the\n+// original text as of the time of this writing is:\n+//\n+//    closure may outlive the current function, but it borrows `books`,\n+//    which is owned by the current function\n+\n+fn foo<'a>(x: &'a i32) -> Box<FnMut()+'a> {\n+    let mut books = vec![1,2,3];\n+    Box::new(|| books.push(4))\n+    //~^ ERROR E0373\n+}\n+\n+fn main() { }"}, {"sha": "3fd635b3d616f33840d8571ef21d620c7f22ebc4", "filename": "src/test/compile-fail/coherence-overlap-all-t-and-tuple.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we detect an overlap here in the case where:\n+//\n+//    for some type X:\n+//      T = (X,)\n+//      T11 = X, U11 = X\n+//\n+// Seems pretty basic, but then there was issue #24241. :)\n+\n+trait From<U> {\n+}\n+\n+impl <T> From<T> for T { //~ ERROR E0119\n+}\n+\n+impl <T11, U11> From<(U11,)> for (T11,) {\n+}\n+\n+fn main() { }"}, {"sha": "b4abef0bd280b914aa20d155a0ac18f07740f432", "filename": "src/test/compile-fail/issue-16747.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -18,10 +18,10 @@ trait Collection { fn len(&self) -> usize; }\n \n struct List<'a, T: ListItem<'a>> {\n //~^ ERROR the parameter type `T` may not live long enough\n-//~^^ NOTE ...so that the reference type `&'a [T]` does not outlive the data it points at\n+//~| HELP consider adding an explicit lifetime bound\n+//~| NOTE ...so that the reference type `&'a [T]` does not outlive the data it points at\n     slice: &'a [T]\n }\n-//~^ HELP consider adding an explicit lifetime bound\n impl<'a, T: ListItem<'a>> Collection for List<'a, T> {\n     fn len(&self) -> usize {\n         0"}, {"sha": "44c92f946f03d1f3bc4436b0aa5bec9ca8530deb", "filename": "src/test/compile-fail/issue-20772.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait T : Iterator<Item=Self::Item>\n+//~^ ERROR unsupported cyclic reference between types/traits detected\n+{}\n+\n+fn main() {}"}, {"sha": "88197166ee08215b50af4204f551a269283c93e2", "filename": "src/test/compile-fail/issue-20939.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-20939.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-20939.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20939.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {}\n+\n+impl<'a> Foo for Foo+'a {}\n+//~^ ERROR the object type `Foo + 'a` automatically implements the trait `Foo`\n+\n+fn main() {}"}, {"sha": "315a4cd90c5f2f84e0fb0a5e74859f06b2650456", "filename": "src/test/compile-fail/issue-21950.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-21950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-21950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21950.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+use std::ops::Add;\n+\n+fn main() {\n+    let x = &10 as\n+            //~^ ERROR the value of the associated type `Output` (from the trait `core::ops::Add`) must be specified\n+            &Add;\n+            //~^ ERROR the type parameter `RHS` must be explicitly specified in an object type because its default value `Self` references the type `Self`\n+}"}, {"sha": "004e33b76a9fe23679dff739c6b145d1da56e41b", "filename": "src/test/compile-fail/issue-22034.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate libc;\n+\n+fn main() {\n+    let foo: *mut libc::c_void;\n+    let cb: &mut Fn() = unsafe {\n+        &mut *(foo as *mut Fn())\n+        //~^ ERROR use of possibly uninitialized variable: `foo`\n+    };\n+}"}, {"sha": "0089bff3e8fd89c56d0870bd3edc8648e285068b", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -15,7 +15,7 @@ fn id<T>(t: T) -> T { t }\n fn f<'r, T>(v: &'r T) -> Box<FnMut() -> T + 'r> {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     id(Box::new(|| *v))\n-        //~^ ERROR `v` does not live long enough\n+        //~^ ERROR E0373\n         //~| ERROR cannot move out of borrowed content\n }\n "}, {"sha": "948dc8cd219689301a9b30ba2702422a39294451", "filename": "src/test/compile-fail/regions-nested-fns-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -13,7 +13,7 @@ fn ignore<F>(_f: F) where F: for<'z> FnOnce(&'z isize) -> &'z isize {}\n fn nested() {\n     let y = 3;\n     ignore(\n-        |z| { //~ ERROR `y` does not live long enough\n+        |z| { //~ ERROR E0373\n             if false { &y } else { z }\n         });\n }"}, {"sha": "ca4b72f9e5bd0efda6625111e3c5413c4195e9ef", "filename": "src/test/run-pass/issue-19097.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Frun-pass%2Fissue-19097.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6790b0e51967b1487728d155e0800a1ed03a30d3/src%2Ftest%2Frun-pass%2Fissue-19097.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19097.rs?ref=6790b0e51967b1487728d155e0800a1ed03a30d3", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// regression test for #19097\n+\n+struct Foo<T>(T);\n+\n+impl<'a, T> Foo<&'a T> {\n+    fn foo(&self) {}\n+}\n+impl<'a, T> Foo<&'a mut T> {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {}"}]}