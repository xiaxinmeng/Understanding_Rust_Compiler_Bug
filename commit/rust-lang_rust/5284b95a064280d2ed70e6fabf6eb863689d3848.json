{"sha": "5284b95a064280d2ed70e6fabf6eb863689d3848", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyODRiOTVhMDY0MjgwZDJlZDcwZTZmYWJmNmViODYzNjg5ZDM4NDg=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-01-24T04:58:53Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-01-24T04:58:53Z"}, "message": "Fix `expect_fun_call` lint suggestions\n\nThis commit corrects some bad suggestions produced by the\n`expect_fun_call` lint and enables `rust-fix` checking on the tests.\n\nAddresses #3630", "tree": {"sha": "89af7d72617f047b460dc1140288d7649fe84fbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89af7d72617f047b460dc1140288d7649fe84fbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5284b95a064280d2ed70e6fabf6eb863689d3848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5284b95a064280d2ed70e6fabf6eb863689d3848", "html_url": "https://github.com/rust-lang/rust/commit/5284b95a064280d2ed70e6fabf6eb863689d3848", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5284b95a064280d2ed70e6fabf6eb863689d3848/comments", "author": null, "committer": null, "parents": [{"sha": "99c5388ce65568fc8517d401dbae9773a0272840", "url": "https://api.github.com/repos/rust-lang/rust/commits/99c5388ce65568fc8517d401dbae9773a0272840", "html_url": "https://github.com/rust-lang/rust/commit/99c5388ce65568fc8517d401dbae9773a0272840"}], "stats": {"total": 354, "additions": 238, "deletions": 116}, "files": [{"sha": "0571f1d92d707886fec6698ca89c15976026d0b9", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/5284b95a064280d2ed70e6fabf6eb863689d3848/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5284b95a064280d2ed70e6fabf6eb863689d3848/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=5284b95a064280d2ed70e6fabf6eb863689d3848", "patch": "@@ -1148,28 +1148,6 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n \n /// Checks for the `EXPECT_FUN_CALL` lint.\n fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n-    fn extract_format_args(arg: &hir::Expr) -> Option<(&hir::Expr, &hir::Expr)> {\n-        let arg = match &arg.node {\n-            hir::ExprKind::AddrOf(_, expr) => expr,\n-            hir::ExprKind::MethodCall(method_name, _, args)\n-                if method_name.ident.name == \"as_str\" || method_name.ident.name == \"as_ref\" =>\n-            {\n-                &args[0]\n-            },\n-            _ => arg,\n-        };\n-\n-        if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg.node {\n-            if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1 {\n-                if let hir::ExprKind::Call(_, format_args) = &inner_args[0].node {\n-                    return Some((&format_args[0], &format_args[1]));\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n     fn generate_format_arg_snippet(\n         cx: &LateContext<'_, '_>,\n         a: &hir::Expr,\n@@ -1189,93 +1167,115 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         unreachable!()\n     }\n \n-    fn check_general_case(\n-        cx: &LateContext<'_, '_>,\n-        name: &str,\n-        method_span: Span,\n-        self_expr: &hir::Expr,\n-        arg: &hir::Expr,\n-        span: Span,\n-    ) {\n-        fn is_call(node: &hir::ExprKind) -> bool {\n-            match node {\n-                hir::ExprKind::AddrOf(_, expr) => {\n-                    is_call(&expr.node)\n-                },\n-                hir::ExprKind::Call(..)\n-                | hir::ExprKind::MethodCall(..)\n-                // These variants are debatable or require further examination\n-                | hir::ExprKind::If(..)\n-                | hir::ExprKind::Match(..)\n-                | hir::ExprKind::Block{ .. } => true,\n-                _ => false,\n-            }\n-        }\n-\n-        if name != \"expect\" {\n-            return;\n+    fn is_call(node: &hir::ExprKind) -> bool {\n+        match node {\n+            hir::ExprKind::AddrOf(_, expr) => {\n+                is_call(&expr.node)\n+            },\n+            hir::ExprKind::Call(..)\n+            | hir::ExprKind::MethodCall(..)\n+            // These variants are debatable or require further examination\n+            | hir::ExprKind::If(..)\n+            | hir::ExprKind::Match(..)\n+            | hir::ExprKind::Block{ .. } => true,\n+            _ => false,\n         }\n+    }\n \n-        let self_type = cx.tables.expr_ty(self_expr);\n-        let known_types = &[&paths::OPTION, &paths::RESULT];\n-\n-        // if not a known type, return early\n-        if known_types.iter().all(|&k| !match_type(cx, self_type, k)) {\n-            return;\n-        }\n+    if args.len() != 2 || name != \"expect\" || !is_call(&args[1].node) {\n+        return;\n+    }\n \n-        if !is_call(&arg.node) {\n-            return;\n-        }\n+    let receiver_type = cx.tables.expr_ty(&args[0]);\n+    let closure_args = if match_type(cx, receiver_type, &paths::OPTION) {\n+        \"||\"\n+    } else if match_type(cx, receiver_type, &paths::RESULT) {\n+        \"|_|\"\n+    } else {\n+        return;\n+    };\n \n-        let closure = if match_type(cx, self_type, &paths::OPTION) {\n-            \"||\"\n-        } else {\n-            \"|_|\"\n+    // Strip off `&`, `as_ref()` and `as_str()` until we're left with either a `String` or `&str`\n+    // which we call `arg_root`.\n+    let mut arg_root = &args[1];\n+    loop {\n+        arg_root = match &arg_root.node {\n+            hir::ExprKind::AddrOf(_, expr) => expr,\n+            hir::ExprKind::MethodCall(method_name, _, call_args) => {\n+                if call_args.len() == 1\n+                    && (method_name.ident.name == \"as_str\" || method_name.ident.name == \"as_ref\")\n+                    && {\n+                        let arg_type = cx.tables.expr_ty(&call_args[0]);\n+                        let base_type = walk_ptrs_ty(arg_type);\n+                        base_type.sty == ty::Str || match_type(cx, base_type, &paths::STRING)\n+                    }\n+                {\n+                    &call_args[0]\n+                } else {\n+                    break;\n+                }\n+            },\n+            _ => break,\n         };\n-        let span_replace_word = method_span.with_hi(span.hi());\n+    }\n \n-        if let Some((fmt_spec, fmt_args)) = extract_format_args(arg) {\n-            let mut applicability = Applicability::MachineApplicable;\n-            let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n+    let span_replace_word = method_span.with_hi(expr.span.hi());\n \n-            args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n+    let mut applicability = Applicability::MachineApplicable;\n \n-            let sugg = args.join(\", \");\n+    //Special handling for `format!` as arg_root\n+    if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg_root.node {\n+        if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1 {\n+            if let hir::ExprKind::Call(_, format_args) = &inner_args[0].node {\n+                let fmt_spec = &format_args[0];\n+                let fmt_args = &format_args[1];\n \n-            span_lint_and_sugg(\n-                cx,\n-                EXPECT_FUN_CALL,\n-                span_replace_word,\n-                &format!(\"use of `{}` followed by a function call\", name),\n-                \"try this\",\n-                format!(\"unwrap_or_else({} panic!({}))\", closure, sugg),\n-                applicability,\n-            );\n+                let mut applicability = Applicability::MachineApplicable;\n+                let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n \n-            return;\n-        }\n+                args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n \n-        let mut applicability = Applicability::MachineApplicable;\n-        let sugg: Cow<'_, _> = snippet_with_applicability(cx, arg.span, \"..\", &mut applicability);\n+                let sugg = args.join(\", \");\n \n-        span_lint_and_sugg(\n-            cx,\n-            EXPECT_FUN_CALL,\n-            span_replace_word,\n-            &format!(\"use of `{}` followed by a function call\", name),\n-            \"try this\",\n-            format!(\"unwrap_or_else({} {{ let msg = {}; panic!(msg) }}))\", closure, sugg),\n-            applicability,\n-        );\n+                span_lint_and_sugg(\n+                    cx,\n+                    EXPECT_FUN_CALL,\n+                    span_replace_word,\n+                    &format!(\"use of `{}` followed by a function call\", name),\n+                    \"try this\",\n+                    format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n+                    applicability,\n+                );\n+\n+                return;\n+            }\n+        }\n     }\n \n-    if args.len() == 2 {\n-        match args[1].node {\n-            hir::ExprKind::Lit(_) => {},\n-            _ => check_general_case(cx, name, method_span, &args[0], &args[1], expr.span),\n+    // If root_arg is `&'static str` or `String` we can use it directly in the `panic!` call otherwise\n+    // we must use `to_string` to convert it.\n+    let mut arg_root_snippet: Cow<'_, _> = snippet_with_applicability(cx, arg_root.span, \"..\", &mut applicability);\n+    let arg_root_ty = cx.tables.expr_ty(arg_root);\n+    let mut requires_conv = !match_type(cx, arg_root_ty, &paths::STRING);\n+    if let ty::Ref(ty::ReStatic, ty, ..) = arg_root_ty.sty {\n+        if ty.sty == ty::Str {\n+            requires_conv = false;\n         }\n+    };\n+\n+    if requires_conv {\n+        arg_root_snippet.to_mut().push_str(\".to_string()\");\n     }\n+\n+    span_lint_and_sugg(\n+        cx,\n+        EXPECT_FUN_CALL,\n+        span_replace_word,\n+        &format!(\"use of `{}` followed by a function call\", name),\n+        \"try this\",\n+        format!(\"unwrap_or_else({} {{ panic!({}) }})\", closure_args, arg_root_snippet),\n+        applicability,\n+    );\n }\n \n /// Checks for the `CLONE_ON_COPY` lint."}, {"sha": "1f74f6b8cf14be08ef0b6c2887a8191478552586", "filename": "tests/ui/expect_fun_call.fixed", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5284b95a064280d2ed70e6fabf6eb863689d3848/tests%2Fui%2Fexpect_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5284b95a064280d2ed70e6fabf6eb863689d3848/tests%2Fui%2Fexpect_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_fun_call.fixed?ref=5284b95a064280d2ed70e6fabf6eb863689d3848", "patch": "@@ -0,0 +1,84 @@\n+// run-rustfix\n+\n+#![warn(clippy::expect_fun_call)]\n+\n+/// Checks implementation of the `EXPECT_FUN_CALL` lint\n+\n+fn main() {\n+    struct Foo;\n+\n+    impl Foo {\n+        fn new() -> Self {\n+            Foo\n+        }\n+\n+        fn expect(&self, msg: &str) {\n+            panic!(\"{}\", msg)\n+        }\n+    }\n+\n+    let with_some = Some(\"value\");\n+    with_some.expect(\"error\");\n+\n+    let with_none: Option<i32> = None;\n+    with_none.expect(\"error\");\n+\n+    let error_code = 123_i32;\n+    let with_none_and_format: Option<i32> = None;\n+    with_none_and_format.unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code));\n+\n+    let with_none_and_as_str: Option<i32> = None;\n+    with_none_and_as_str.unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code));\n+\n+    let with_ok: Result<(), ()> = Ok(());\n+    with_ok.expect(\"error\");\n+\n+    let with_err: Result<(), ()> = Err(());\n+    with_err.expect(\"error\");\n+\n+    let error_code = 123_i32;\n+    let with_err_and_format: Result<(), ()> = Err(());\n+    with_err_and_format.unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code));\n+\n+    let with_err_and_as_str: Result<(), ()> = Err(());\n+    with_err_and_as_str.unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code));\n+\n+    let with_dummy_type = Foo::new();\n+    with_dummy_type.expect(\"another test string\");\n+\n+    let with_dummy_type_and_format = Foo::new();\n+    with_dummy_type_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+\n+    let with_dummy_type_and_as_str = Foo::new();\n+    with_dummy_type_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+\n+    //Issue #2937\n+    Some(\"foo\").unwrap_or_else(|| panic!(\"{} {}\", 1, 2));\n+\n+    //Issue #2979 - this should not lint\n+    {\n+        let msg = \"bar\";\n+        Some(\"foo\").expect(msg);\n+    }\n+\n+    {\n+        fn get_string() -> String {\n+            \"foo\".to_string()\n+        }\n+\n+        fn get_static_str() -> &'static str {\n+            \"foo\"\n+        }\n+\n+        fn get_non_static_str(_: &u32) -> &str {\n+            \"foo\"\n+        }\n+\n+        Some(\"foo\").unwrap_or_else(|| { panic!(get_string()) });\n+        Some(\"foo\").unwrap_or_else(|| { panic!(get_string()) });\n+        Some(\"foo\").unwrap_or_else(|| { panic!(get_string()) });\n+\n+        Some(\"foo\").unwrap_or_else(|| { panic!(get_static_str()) });\n+        Some(\"foo\").unwrap_or_else(|| { panic!(get_non_static_str(&0).to_string()) });\n+    }\n+}"}, {"sha": "2d8b4925f358a117dfa7d55ec6c0adbd0f819a04", "filename": "tests/ui/expect_fun_call.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5284b95a064280d2ed70e6fabf6eb863689d3848/tests%2Fui%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5284b95a064280d2ed70e6fabf6eb863689d3848/tests%2Fui%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_fun_call.rs?ref=5284b95a064280d2ed70e6fabf6eb863689d3848", "patch": "@@ -1,9 +1,10 @@\n+// run-rustfix\n+\n #![warn(clippy::expect_fun_call)]\n-#![allow(clippy::useless_format)]\n \n /// Checks implementation of the `EXPECT_FUN_CALL` lint\n \n-fn expect_fun_call() {\n+fn main() {\n     struct Foo;\n \n     impl Foo {\n@@ -51,14 +52,33 @@ fn expect_fun_call() {\n     let with_dummy_type_and_as_str = Foo::new();\n     with_dummy_type_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n \n+    //Issue #2937\n+    Some(\"foo\").expect(format!(\"{} {}\", 1, 2).as_ref());\n+\n     //Issue #2979 - this should not lint\n-    let msg = \"bar\";\n-    Some(\"foo\").expect(msg);\n+    {\n+        let msg = \"bar\";\n+        Some(\"foo\").expect(msg);\n+    }\n \n-    Some(\"foo\").expect({ &format!(\"error\") });\n-    Some(\"foo\").expect(format!(\"error\").as_ref());\n+    {\n+        fn get_string() -> String {\n+            \"foo\".to_string()\n+        }\n \n-    Some(\"foo\").expect(format!(\"{} {}\", 1, 2).as_ref());\n-}\n+        fn get_static_str() -> &'static str {\n+            \"foo\"\n+        }\n+\n+        fn get_non_static_str(_: &u32) -> &str {\n+            \"foo\"\n+        }\n \n-fn main() {}\n+        Some(\"foo\").expect(&get_string());\n+        Some(\"foo\").expect(get_string().as_ref());\n+        Some(\"foo\").expect(get_string().as_str());\n+\n+        Some(\"foo\").expect(get_static_str());\n+        Some(\"foo\").expect(get_non_static_str(&0));\n+    }\n+}"}, {"sha": "900e251d964c20b2b91da0ee38fa3363c804214b", "filename": "tests/ui/expect_fun_call.stderr", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5284b95a064280d2ed70e6fabf6eb863689d3848/tests%2Fui%2Fexpect_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5284b95a064280d2ed70e6fabf6eb863689d3848/tests%2Fui%2Fexpect_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_fun_call.stderr?ref=5284b95a064280d2ed70e6fabf6eb863689d3848", "patch": "@@ -1,46 +1,64 @@\n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:27:26\n+  --> $DIR/expect_fun_call.rs:28:26\n    |\n LL |     with_none_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code))`\n    |\n    = note: `-D clippy::expect-fun-call` implied by `-D warnings`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:30:26\n+  --> $DIR/expect_fun_call.rs:31:26\n    |\n LL |     with_none_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:40:25\n+  --> $DIR/expect_fun_call.rs:41:25\n    |\n LL |     with_err_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:43:25\n+  --> $DIR/expect_fun_call.rs:44:25\n    |\n LL |     with_err_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:58:17\n+  --> $DIR/expect_fun_call.rs:56:17\n    |\n-LL |     Some(\"foo\").expect({ &format!(\"error\") });\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { let msg = { &format!(\"error\") }; panic!(msg) }))`\n+LL |     Some(\"foo\").expect(format!(\"{} {}\", 1, 2).as_ref());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"{} {}\", 1, 2))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:59:17\n+  --> $DIR/expect_fun_call.rs:77:21\n    |\n-LL |     Some(\"foo\").expect(format!(\"error\").as_ref());\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"error\"))`\n+LL |         Some(\"foo\").expect(&get_string());\n+   |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(get_string()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:61:17\n+  --> $DIR/expect_fun_call.rs:78:21\n    |\n-LL |     Some(\"foo\").expect(format!(\"{} {}\", 1, 2).as_ref());\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"{} {}\", 1, 2))`\n+LL |         Some(\"foo\").expect(get_string().as_ref());\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(get_string()) })`\n+\n+error: use of `expect` followed by a function call\n+  --> $DIR/expect_fun_call.rs:79:21\n+   |\n+LL |         Some(\"foo\").expect(get_string().as_str());\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(get_string()) })`\n+\n+error: use of `expect` followed by a function call\n+  --> $DIR/expect_fun_call.rs:81:21\n+   |\n+LL |         Some(\"foo\").expect(get_static_str());\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(get_static_str()) })`\n+\n+error: use of `expect` followed by a function call\n+  --> $DIR/expect_fun_call.rs:82:21\n+   |\n+LL |         Some(\"foo\").expect(get_non_static_str(&0));\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(get_non_static_str(&0).to_string()) })`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 10 previous errors\n "}]}