{"sha": "f80743712eea6e90c4fd73b596bf45c43d9c9e58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MDc0MzcxMmVlYTZlOTBjNGZkNzNiNTk2YmY0NWM0M2Q5YzllNTg=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-07-01T00:41:15Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-07-22T19:25:55Z"}, "message": "Use `ty::Instance::resolve` to identify `'static` bound source", "tree": {"sha": "1f56166a7b8705f67cbe79cad7ddeeb7ade77548", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f56166a7b8705f67cbe79cad7ddeeb7ade77548"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f80743712eea6e90c4fd73b596bf45c43d9c9e58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f80743712eea6e90c4fd73b596bf45c43d9c9e58", "html_url": "https://github.com/rust-lang/rust/commit/f80743712eea6e90c4fd73b596bf45c43d9c9e58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f80743712eea6e90c4fd73b596bf45c43d9c9e58/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bf39fa9d965535f815326e3f1c48799b8077ea6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bf39fa9d965535f815326e3f1c48799b8077ea6", "html_url": "https://github.com/rust-lang/rust/commit/7bf39fa9d965535f815326e3f1c48799b8077ea6"}], "stats": {"total": 378, "additions": 196, "deletions": 182}, "files": [{"sha": "9c2e02968f607bc3472e82d008f259b3ead21013", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 100, "deletions": 121, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=f80743712eea6e90c4fd73b596bf45c43d9c9e58", "patch": "@@ -3,18 +3,20 @@\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n-use crate::traits::ObligationCauseCode;\n+use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{self as hir, GenericBound, Item, ItemKind, Lifetime, LifetimeName, Node, TyKind};\n-use rustc_middle::ty::{\n-    self, AssocItem, AssocItemContainer, RegionKind, Ty, TypeFoldable, TypeVisitor,\n+use rustc_hir::{\n+    self as hir, GenericBound, ImplItem, Item, ItemKind, Lifetime, LifetimeName, Node, TraitItem,\n+    TyKind,\n };\n+use rustc_middle::ty::{self, AssocItemContainer, RegionKind, Ty, TypeFoldable, TypeVisitor};\n use rustc_span::{MultiSpan, Span};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    /// Print the error message for lifetime errors when the return type is a static impl Trait.\n+    /// Print the error message for lifetime errors when the return type is a static `impl Trait`,\n+    /// `dyn Trait` or if a method call on a trait object introduces a static requirement.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         debug!(\"try_report_static_impl_trait(error={:?})\", self.error);\n         let tcx = self.tcx();\n@@ -34,8 +36,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 sub_r,\n                 sup_r,\n             ) if **sub_r == RegionKind::ReStatic => {\n-                // This is for the implicit `'static` requirement coming from `impl dyn Trait {}`.\n-                if let ObligationCauseCode::UnifyReceiver(assoc) = &cause.code {\n+                // This is for an implicit `'static` requirement coming from `impl dyn Trait {}`.\n+                if let ObligationCauseCode::UnifyReceiver(ctxt) = &cause.code {\n                     let param = self.find_param_with_region(sup_r, sub_r)?;\n                     let lifetime = if sup_r.has_name() {\n                         format!(\"lifetime `{}`\", sup_r)\n@@ -55,23 +57,23 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             .map(|s| format!(\"`{}`\", s))\n                             .unwrap_or_else(|| \"`fn` parameter\".to_string()),\n                         lifetime,\n-                        assoc.ident,\n+                        ctxt.assoc_item.ident,\n                     );\n                     err.span_label(param.param_ty_span, &format!(\"this data with {}...\", lifetime));\n                     err.span_label(\n                         cause.span,\n                         &format!(\n                             \"...is captured and required to live as long as `'static` here \\\n                              because of an implicit lifetime bound on the {}\",\n-                            match assoc.container {\n+                            match ctxt.assoc_item.container {\n                                 AssocItemContainer::TraitContainer(id) =>\n                                     format!(\"`impl` of `{}`\", tcx.def_path_str(id)),\n                                 AssocItemContainer::ImplContainer(_) =>\n                                     \"inherent `impl`\".to_string(),\n                             },\n                         ),\n                     );\n-                    if self.find_impl_on_dyn_trait(&mut err, param.param_ty, assoc) {\n+                    if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt) {\n                         err.emit();\n                         return Some(ErrorReported);\n                     } else {\n@@ -117,25 +119,26 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         let mut postfix = String::new();\n         if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sup_origin {\n-            if let ObligationCauseCode::UnifyReceiver(assoc) = &cause.code {\n-                if self.find_impl_on_dyn_trait(&mut err, param.param_ty, assoc)\n+            if let ObligationCauseCode::UnifyReceiver(ctxt) = &cause.code {\n+                if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt)\n                     && fn_returns.is_empty()\n                 {\n                     err.code(rustc_errors::error_code!(E0767));\n                     err.set_primary_message(&format!(\n                         \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\\n                          requirement\",\n-                        param_name, lifetime, assoc.ident,\n+                        param_name, lifetime, ctxt.assoc_item.ident,\n                     ));\n                     postfix = format!(\n                         \" because of an implicit lifetime on the {}\",\n-                        match assoc.container {\n+                        match ctxt.assoc_item.container {\n                             AssocItemContainer::TraitContainer(id) =>\n                                 format!(\"`impl` of `{}`\", tcx.def_path_str(id)),\n                             AssocItemContainer::ImplContainer(_) => \"inherent `impl`\".to_string(),\n                         },\n                     );\n                 }\n+                // }\n             }\n         }\n \n@@ -316,128 +319,104 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     }\n \n     /// When we call a method coming from an `impl Foo for dyn Bar`, `dyn Bar` introduces a default\n-    /// `'static` obligation. Find `impl` blocks that are implemented\n+    /// `'static` obligation. Suggest relaxing that implicit bound.\n     fn find_impl_on_dyn_trait(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         ty: Ty<'_>,\n-        assoc: &AssocItem,\n+        ctxt: &UnifyReceiverContext<'tcx>,\n     ) -> bool {\n         let tcx = self.tcx();\n         let mut suggested = false;\n \n-        // Find the trait object types in the argument.\n-        let mut v = TraitObjectVisitor(vec![]);\n-        v.visit_ty(ty);\n-\n-        let container_id = match assoc.container {\n-            // When the obligation comes from an `impl Foo for dyn Bar {}`, we\n-            // have the `DefId` of the `trait` itself, not the relevant `impl`\n-            // block. Because of this, we have to look at all the `trait`s\n-            // available, and filter out all that are not of `Foo` (this `def_id`)\n-            // and not of `Bar` (the `filter_map` later in this method).\n-            AssocItemContainer::TraitContainer(def_id) => def_id,\n+        // Find the method being called.\n+        let instance = match ty::Instance::resolve(\n+            tcx,\n+            ctxt.param_env,\n+            ctxt.assoc_item.def_id,\n+            self.infcx.resolve_vars_if_possible(&ctxt.substs),\n+        ) {\n+            Ok(Some(instance)) => instance,\n+            _ => return false,\n+        };\n \n-            // When the obligation comes from an `impl dyn Trait {}`, we already\n-            // have the `DefId` of the relevant `Item`, so we use it directly.\n-            AssocItemContainer::ImplContainer(def_id) => {\n-                if let Some(Node::Item(Item { kind: ItemKind::Impl { self_ty, .. }, .. })) =\n-                    tcx.hir().get_if_local(def_id)\n-                {\n-                    for found_did in &v.0 {\n-                        let mut hir_v = HirTraitObjectVisitor(vec![], *found_did);\n-                        hir_v.visit_ty(self_ty);\n-                        if let [span] = &hir_v.0[..] {\n-                            let mut multi_span: MultiSpan = vec![*span].into();\n-                            multi_span.push_span_label(\n-                                *span,\n-                                \"this has an implicit `'static` lifetime requirement\".to_string(),\n-                            );\n-                            multi_span.push_span_label(\n-                                assoc.ident.span,\n-                                \"`'static` requirement is introduced when calling this method\"\n-                                    .to_string(),\n-                            );\n-                            err.span_note(\n-                                multi_span,\n-                                &format!(\n-                                    \"`{}`'s inherent `impl` has a `'static` requirement\",\n-                                    tcx.def_path_str(*found_did),\n-                                ),\n-                            );\n-                            err.span_suggestion_verbose(\n-                                span.shrink_to_hi(),\n-                                \"consider relaxing the implicit `'static` requirement\",\n-                                \" + '_\".to_string(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            suggested = true;\n-                        }\n+        // Get the `Ident` of the method being called and the corresponding `impl` (to point at\n+        // `Bar` in `impl Foo for dyn Bar {}` and the definition of the method being called).\n+        let (ident, self_ty) = match tcx.hir().get_if_local(instance.def_id()) {\n+            Some(Node::ImplItem(ImplItem { ident, hir_id, .. })) => {\n+                match tcx.hir().find(tcx.hir().get_parent_item(*hir_id)) {\n+                    Some(Node::Item(Item { kind: ItemKind::Impl { self_ty, .. }, .. })) => {\n+                        (ident, self_ty)\n                     }\n+                    _ => return false,\n                 }\n-                return suggested;\n             }\n-        };\n-\n-        // Find all the `impl`s in the local scope that can be called on the type parameter. And\n-        // retain all that are `impl`s of the trait that originated the `'static` obligation.\n-        // This doesn't find `impl dyn Trait { /**/ }`, but that case is handled above.\n-        let impl_self_tys = tcx\n-            .all_traits(LOCAL_CRATE)\n-            .iter()\n-            .flat_map(|trait_did| tcx.hir().trait_impls(*trait_did))\n-            .filter_map(|impl_node| {\n-                let impl_did = tcx.hir().local_def_id(*impl_node);\n-                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n-                    Some(Node::Item(Item {\n-                        kind: ItemKind::Impl { self_ty, of_trait: Some(of_trait), items, .. },\n-                        ..\n-                    })) if of_trait.trait_def_id() == Some(container_id) => Some((\n-                        self_ty,\n-                        // Get the ident of the method, in order to use its `Span`.\n-                        items\n+            Some(Node::TraitItem(TraitItem { ident, hir_id, .. })) => {\n+                let parent_id = tcx.hir().get_parent_item(*hir_id);\n+                match tcx.hir().find(parent_id) {\n+                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n+                        // The method being called is defined in the `trait`, but the `'static`\n+                        // obligation comes from the `impl`. Find that `impl` so that we can point\n+                        // at it in the suggestion.\n+                        let trait_did = tcx.hir().local_def_id(parent_id).to_def_id();\n+                        match tcx.hir().trait_impls(trait_did)\n                             .iter()\n-                            .filter(|item| item.ident == assoc.ident)\n-                            .map(|item| item.ident)\n+                            .filter_map(|impl_node| {\n+                                let impl_did = tcx.hir().local_def_id(*impl_node);\n+                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n+                                    Some(Node::Item(Item {\n+                                        kind: ItemKind::Impl { self_ty, of_trait: Some(of_trait), .. },\n+                                        ..\n+                                    })) if of_trait.trait_def_id() == Some(trait_did) => Some(self_ty),\n+                                    _ => None,\n+                                }\n+                            })\n                             .next()\n-                            .unwrap_or(assoc.ident),\n-                    )),\n-                    _ => None,\n+                        {\n+                            Some(self_ty) => (ident, self_ty),\n+                            _ => return false,\n+                        }\n+                    }\n+                    _ => return false,\n                 }\n-            });\n+            }\n+            _ => return false,\n+        };\n \n-        // Given all the `impl`s of the relevant `trait`, look for those that are implemented for\n-        // the trait object in the `fn` parameter type.\n-        for (self_ty, method) in impl_self_tys {\n-            for found_did in &v.0 {\n-                let mut hir_v = HirTraitObjectVisitor(vec![], *found_did);\n-                hir_v.visit_ty(self_ty);\n-                if let [span] = &hir_v.0[..] {\n-                    let mut multi_span: MultiSpan = vec![*span].into();\n-                    multi_span.push_span_label(\n-                        *span,\n-                        \"this has an implicit `'static` lifetime requirement\".to_string(),\n-                    );\n-                    multi_span.push_span_label(\n-                        method.span,\n-                        \"`'static` requirement is introduced when calling this method\".to_string(),\n-                    );\n-                    err.span_note(\n-                        multi_span,\n-                        &format!(\n-                            \"`{}`'s `impl` of `{}` has an implicit `'static` requirement\",\n-                            tcx.def_path_str(*found_did),\n-                            tcx.def_path_str(container_id),\n-                        ),\n-                    );\n-                    err.span_suggestion_verbose(\n-                        span.shrink_to_hi(),\n-                        \"consider relaxing the implicit `'static` requirement\",\n-                        \" + '_\".to_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    suggested = true;\n-                }\n+        // Find the trait object types in the argument, so we point at *only* the trait object.\n+        let mut v = TraitObjectVisitor(vec![]);\n+        v.visit_ty(ty);\n+        for found_did in &v.0 {\n+            let mut hir_v = HirTraitObjectVisitor(vec![], *found_did);\n+            hir_v.visit_ty(self_ty);\n+            for span in &hir_v.0 {\n+                let mut multi_span: MultiSpan = vec![*span].into();\n+                multi_span.push_span_label(\n+                    *span,\n+                    \"this has an implicit `'static` lifetime requirement\".to_string(),\n+                );\n+                multi_span.push_span_label(\n+                    ident.span,\n+                    \"calling this method introduces the `impl`'s 'static` requirement\".to_string(),\n+                );\n+                err.span_note(\n+                    multi_span,\n+                    &format!(\n+                        \"{} has a `'static` requirement\",\n+                        match ctxt.assoc_item.container {\n+                            AssocItemContainer::TraitContainer(id) =>\n+                                format!(\"`impl` of `{}`\", tcx.def_path_str(id)),\n+                            AssocItemContainer::ImplContainer(_) => \"inherent `impl`\".to_string(),\n+                        },\n+                    ),\n+                );\n+                err.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    \"consider relaxing the implicit `'static` requirement\",\n+                    \" + '_\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                suggested = true;\n             }\n         }\n         suggested"}, {"sha": "d2747e5fc659b9efcef4b621e1d6fea8eb33f347", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=f80743712eea6e90c4fd73b596bf45c43d9c9e58", "patch": "@@ -169,6 +169,13 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct UnifyReceiverContext<'tcx> {\n+    pub assoc_item: ty::AssocItem,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from the span.\n@@ -300,7 +307,7 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Method receiver\n     MethodReceiver,\n \n-    UnifyReceiver(Rc<ty::AssocItem>),\n+    UnifyReceiver(Box<UnifyReceiverContext<'tcx>>),\n \n     /// `return` with no expression\n     ReturnNoExpression,"}, {"sha": "18b4371053a89c77b3340161b2eaab7cefaa92c2", "filename": "src/librustc_middle/traits/structural_impls.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs?ref=f80743712eea6e90c4fd73b596bf45c43d9c9e58", "patch": "@@ -213,13 +213,26 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::StartFunctionType => Some(super::StartFunctionType),\n             super::IntrinsicType => Some(super::IntrinsicType),\n             super::MethodReceiver => Some(super::MethodReceiver),\n-            super::UnifyReceiver(ref assoc) => Some(super::UnifyReceiver(assoc.clone())),\n+            super::UnifyReceiver(ref ctxt) => tcx.lift(ctxt).map(|ctxt| super::UnifyReceiver(ctxt)),\n             super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n             super::TrivialBound => Some(super::TrivialBound),\n         }\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for traits::UnifyReceiverContext<'a> {\n+    type Lifted = traits::UnifyReceiverContext<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.param_env).and_then(|param_env| {\n+            tcx.lift(&self.substs).map(|substs| traits::UnifyReceiverContext {\n+                assoc_item: self.assoc_item,\n+                param_env,\n+                substs,\n+            })\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n     type Lifted = traits::DerivedObligationCause<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {"}, {"sha": "dd7ea55cc1043693be0a1e0e96399a602c21c32e", "filename": "src/librustc_trait_selection/traits/codegen/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs?ref=f80743712eea6e90c4fd73b596bf45c43d9c9e58", "patch": "@@ -6,6 +6,7 @@\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::{\n     FulfillmentContext, ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngine,\n+    Unimplemented,\n };\n use rustc_errors::ErrorReported;\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -58,6 +59,18 @@ pub fn codegen_fulfill_obligation<'tcx>(\n                 );\n                 return Err(ErrorReported);\n             }\n+            Err(Unimplemented) => {\n+                // This can trigger when we probe for the source of a `'static` lifetime requirement\n+                // on a trait object: `impl Foo for dyn Trait {}` has an implicit `'static` bound.\n+                infcx.tcx.sess.delay_span_bug(\n+                    rustc_span::DUMMY_SP,\n+                    &format!(\n+                        \"Encountered error `Unimplemented` selecting `{:?}` during codegen\",\n+                        trait_ref\n+                    ),\n+                );\n+                return Err(ErrorReported);\n+            }\n             Err(e) => {\n                 bug!(\"Encountered error `{:?}` selecting `{:?}` during codegen\", e, trait_ref)\n             }"}, {"sha": "0632ce2319aeef1d462898e2537243cbcd7f0d42", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f80743712eea6e90c4fd73b596bf45c43d9c9e58", "patch": "@@ -1706,7 +1706,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             | ObligationCauseCode::IntrinsicType\n             | ObligationCauseCode::MethodReceiver\n             | ObligationCauseCode::ReturnNoExpression\n-            | ObligationCauseCode::UnifyReceiver(_)\n+            | ObligationCauseCode::UnifyReceiver(..)\n             | ObligationCauseCode::MiscObligation => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");"}, {"sha": "ed84095ae6b0cbc4a5a6d7094edb3eea07cd9509", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f80743712eea6e90c4fd73b596bf45c43d9c9e58", "patch": "@@ -6,7 +6,7 @@ use crate::hir::def_id::DefId;\n use crate::hir::GenericArg;\n use rustc_hir as hir;\n use rustc_infer::infer::{self, InferOk};\n-use rustc_middle::traits::ObligationCauseCode;\n+use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -16,7 +16,6 @@ use rustc_span::Span;\n use rustc_trait_selection::traits;\n \n use std::ops::Deref;\n-use std::rc::Rc;\n \n struct ConfirmContext<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -97,7 +96,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             \"confirm: self_ty={:?} method_sig_rcvr={:?} method_sig={:?} method_predicates={:?}\",\n             self_ty, method_sig_rcvr, method_sig, method_predicates\n         );\n-        self.unify_receivers(self_ty, method_sig_rcvr, &pick);\n+        self.unify_receivers(self_ty, method_sig_rcvr, &pick, all_substs);\n \n         let (method_sig, method_predicates) =\n             self.normalize_associated_types_in(self.span, &(method_sig, method_predicates));\n@@ -345,12 +344,20 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         self_ty: Ty<'tcx>,\n         method_self_ty: Ty<'tcx>,\n         pick: &probe::Pick<'tcx>,\n+        substs: SubstsRef<'tcx>,\n     ) {\n         debug!(\n             \"unify_receivers: self_ty={:?} method_self_ty={:?} span={:?} pick={:?}\",\n             self_ty, method_self_ty, self.span, pick\n         );\n-        let cause = self.cause(self.span, ObligationCauseCode::UnifyReceiver(Rc::new(pick.item)));\n+        let cause = self.cause(\n+            self.span,\n+            ObligationCauseCode::UnifyReceiver(Box::new(UnifyReceiverContext {\n+                assoc_item: pick.item,\n+                param_env: self.param_env,\n+                substs,\n+            })),\n+        );\n         match self.at(&cause, self.param_env).sup(method_self_ty, self_ty) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);"}, {"sha": "45e6cfdb821318a44eb1cb9d575e42c26615c577", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.fixed", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.fixed?ref=f80743712eea6e90c4fd73b596bf45c43d9c9e58", "patch": "@@ -5,19 +5,19 @@ mod foo {\n     trait OtherTrait<'a> {}\n     impl<'a> OtherTrait<'a> for &'a () {}\n \n-    trait ObjectTrait {}\n-    trait MyTrait {\n-        fn use_self(&self) -> &();\n+    trait ObjectTrait<T> {}\n+    trait MyTrait<T> {\n+        fn use_self<K>(&self) -> &();\n     }\n     trait Irrelevant {}\n \n-    impl MyTrait for dyn ObjectTrait + '_ {\n-        fn use_self(&self) -> &() { panic!() }\n+    impl<T> MyTrait<T> for dyn ObjectTrait<T> + '_ {\n+        fn use_self<K>(&self) -> &() { panic!() }\n     }\n-    impl Irrelevant for dyn ObjectTrait {}\n+    impl<T> Irrelevant for dyn ObjectTrait<T> {}\n \n-    fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n-        val.use_self() //~ ERROR E0759\n+    fn use_it<'a, T>(val: &'a dyn ObjectTrait<T>) -> impl OtherTrait<'a> + 'a {\n+        val.use_self::<T>() //~ ERROR E0759\n     }\n }\n \n@@ -76,19 +76,16 @@ mod ban {\n \n     trait ObjectTrait {}\n     trait MyTrait {\n-        fn use_self(&self) -> &();\n+        fn use_self(&self) -> &() { panic!() }\n     }\n     trait Irrelevant {}\n \n-    impl MyTrait for dyn ObjectTrait + '_ {\n-        fn use_self(&self) -> &() { panic!() }\n-    }\n+    impl MyTrait for dyn ObjectTrait + '_ {}\n     impl Irrelevant for dyn ObjectTrait {}\n \n     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n         val.use_self() //~ ERROR E0759\n     }\n }\n \n-\n fn main() {}"}, {"sha": "fb6e62e76da8817e0a881a571b380b58556bb6b9", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.nll.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.nll.stderr?ref=f80743712eea6e90c4fd73b596bf45c43d9c9e58", "patch": "@@ -1,10 +1,10 @@\n error[E0521]: borrowed data escapes outside of function\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:20:9\n    |\n-LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n-   |                   --- `val` is a reference that is only valid in the function body\n-LL |         val.use_self()\n-   |         ^^^^^^^^^^^^^^ `val` escapes the function body here\n+LL |     fn use_it<'a, T>(val: &'a dyn ObjectTrait<T>) -> impl OtherTrait<'a> + 'a {\n+   |                      --- `val` is a reference that is only valid in the function body\n+LL |         val.use_self::<T>()\n+   |         ^^^^^^^^^^^^^^^^^^^ `val` escapes the function body here\n    |\n    = help: consider replacing `'a` with `'static`\n \n@@ -19,7 +19,7 @@ LL |         val.use_self()\n    = help: consider replacing `'a` with `'static`\n \n error[E0521]: borrowed data escapes outside of function\n-  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:89:9\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:87:9\n    |\n LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> {\n    |                   --- `val` is a reference that is only valid in the function body"}, {"sha": "7de11f4f8fc5173fe1be67e961553e9522a6962c", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.rs?ref=f80743712eea6e90c4fd73b596bf45c43d9c9e58", "patch": "@@ -5,19 +5,19 @@ mod foo {\n     trait OtherTrait<'a> {}\n     impl<'a> OtherTrait<'a> for &'a () {}\n \n-    trait ObjectTrait {}\n-    trait MyTrait {\n-        fn use_self(&self) -> &();\n+    trait ObjectTrait<T> {}\n+    trait MyTrait<T> {\n+        fn use_self<K>(&self) -> &();\n     }\n     trait Irrelevant {}\n \n-    impl MyTrait for dyn ObjectTrait {\n-        fn use_self(&self) -> &() { panic!() }\n+    impl<T> MyTrait<T> for dyn ObjectTrait<T> {\n+        fn use_self<K>(&self) -> &() { panic!() }\n     }\n-    impl Irrelevant for dyn ObjectTrait {}\n+    impl<T> Irrelevant for dyn ObjectTrait<T> {}\n \n-    fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n-        val.use_self() //~ ERROR E0759\n+    fn use_it<'a, T>(val: &'a dyn ObjectTrait<T>) -> impl OtherTrait<'a> + 'a {\n+        val.use_self::<T>() //~ ERROR E0759\n     }\n }\n \n@@ -76,19 +76,16 @@ mod ban {\n \n     trait ObjectTrait {}\n     trait MyTrait {\n-        fn use_self(&self) -> &();\n+        fn use_self(&self) -> &() { panic!() }\n     }\n     trait Irrelevant {}\n \n-    impl MyTrait for dyn ObjectTrait {\n-        fn use_self(&self) -> &() { panic!() }\n-    }\n+    impl MyTrait for dyn ObjectTrait {}\n     impl Irrelevant for dyn ObjectTrait {}\n \n     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> {\n         val.use_self() //~ ERROR E0759\n     }\n }\n \n-\n fn main() {}"}, {"sha": "1375ac8db8dedacf04cf340fd95157adb555bd67", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.stderr", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f80743712eea6e90c4fd73b596bf45c43d9c9e58/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr?ref=f80743712eea6e90c4fd73b596bf45c43d9c9e58", "patch": "@@ -1,22 +1,22 @@\n error[E0759]: `val` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:20:13\n    |\n-LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n-   |                        ------------------- this data with lifetime `'a`...\n-LL |         val.use_self()\n+LL |     fn use_it<'a, T>(val: &'a dyn ObjectTrait<T>) -> impl OtherTrait<'a> + 'a {\n+   |                           ---------------------- this data with lifetime `'a`...\n+LL |         val.use_self::<T>()\n    |             ^^^^^^^^ ...is captured and required to live as long as `'static` here\n    |\n-note: `foo::ObjectTrait`'s `impl` of `foo::MyTrait` has an implicit `'static` requirement\n-  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:14:26\n+note: `impl` of `foo::MyTrait` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:14:32\n    |\n-LL |     impl MyTrait for dyn ObjectTrait {\n-   |                          ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n-LL |         fn use_self(&self) -> &() { panic!() }\n-   |            -------- `'static` requirement is introduced when calling this method\n+LL |     impl<T> MyTrait<T> for dyn ObjectTrait<T> {\n+   |                                ^^^^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+LL |         fn use_self<K>(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n help: consider relaxing the implicit `'static` requirement\n    |\n-LL |     impl MyTrait for dyn ObjectTrait + '_ {\n-   |                                      ^^^^\n+LL |     impl<T> MyTrait<T> for dyn ObjectTrait<T> + '_ {\n+   |                                               ^^^^\n \n error[E0767]: `val` has lifetime `'a` but calling `use_self` introduces an implicit `'static` lifetime requirement\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:69:13\n@@ -26,36 +26,37 @@ LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n LL |         val.use_self()\n    |             ^^^^^^^^ ...is captured and required to live as long as `'static` here because of an implicit lifetime bound on the inherent `impl`\n    |\n-note: `bat::ObjectTrait`'s inherent `impl` has a `'static` requirement\n+note: inherent `impl` has a `'static` requirement\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:64:14\n    |\n LL |     impl dyn ObjectTrait {\n    |              ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n LL |         fn use_self(&self) -> &() { panic!() }\n-   |            -------- `'static` requirement is introduced when calling this method\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n help: consider relaxing the implicit `'static` requirement\n    |\n LL |     impl dyn ObjectTrait + '_ {\n    |                          ^^^^\n \n error[E0759]: `val` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:89:13\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:87:13\n    |\n LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> {\n    |                        ------------------- this data with lifetime `'a`...\n LL |         val.use_self()\n    |             ^^^^^^^^ ...is captured and required to live as long as `'static` here\n    |\n-note: `ban::ObjectTrait`'s `impl` of `ban::MyTrait` has an implicit `'static` requirement\n+note: `impl` of `ban::MyTrait` has a `'static` requirement\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:83:26\n    |\n-LL |     impl MyTrait for dyn ObjectTrait {\n-   |                          ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n LL |         fn use_self(&self) -> &() { panic!() }\n-   |            -------- `'static` requirement is introduced when calling this method\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+...\n+LL |     impl MyTrait for dyn ObjectTrait {}\n+   |                          ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n help: consider relaxing the implicit `'static` requirement\n    |\n-LL |     impl MyTrait for dyn ObjectTrait + '_ {\n+LL |     impl MyTrait for dyn ObjectTrait + '_ {}\n    |                                      ^^^^\n help: to declare that the `impl Trait` captures data from argument `val`, you can add an explicit `'a` lifetime bound\n    |\n@@ -70,13 +71,13 @@ LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> &'a () {\n LL |         val.use_self()\n    |             ^^^^^^^^ ...is captured and required to live as long as `'static` here because of an implicit lifetime on the `impl` of `bar::MyTrait`\n    |\n-note: `bar::ObjectTrait`'s `impl` of `bar::MyTrait` has an implicit `'static` requirement\n+note: `impl` of `bar::MyTrait` has a `'static` requirement\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:31:26\n    |\n LL |     impl MyTrait for dyn ObjectTrait {\n    |                          ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n LL |         fn use_self(&self) -> &() { panic!() }\n-   |            -------- `'static` requirement is introduced when calling this method\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n help: consider relaxing the implicit `'static` requirement\n    |\n LL |     impl MyTrait for dyn ObjectTrait + '_ {\n@@ -90,13 +91,13 @@ LL |     fn use_it<'a>(val: &'a Box<dyn ObjectTrait + 'a>) -> &'a () {\n LL |         val.use_self()\n    |             ^^^^^^^^ ...is captured and required to live as long as `'static` here because of an implicit lifetime on the `impl` of `baz::MyTrait`\n    |\n-note: `baz::ObjectTrait`'s `impl` of `baz::MyTrait` has an implicit `'static` requirement\n+note: `impl` of `baz::MyTrait` has a `'static` requirement\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:48:30\n    |\n LL |     impl MyTrait for Box<dyn ObjectTrait> {\n    |                              ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n LL |         fn use_self(&self) -> &() { panic!() }\n-   |            -------- `'static` requirement is introduced when calling this method\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n help: consider relaxing the implicit `'static` requirement\n    |\n LL |     impl MyTrait for Box<dyn ObjectTrait + '_> {"}]}