{"sha": "6f5853f5a1767e0c418fd5f348a795b76d701b3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNTg1M2Y1YTE3NjdlMGM0MThmZDVmMzQ4YTc5NWI3NmQ3MDFiM2U=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-13T03:04:27Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-13T03:08:29Z"}, "message": "Libc/os/run/rand/io reorganization. Close #1373. Close #1638.\n\n - Move io, run and rand to core.\n - Remove incorrect ctypes module (use libc).\n - Remove os-specific modules for os and fs.\n - Split fs between core::path and core::os.", "tree": {"sha": "7d054b8471a75c47854edbd52a14d8d2acf81c9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d054b8471a75c47854edbd52a14d8d2acf81c9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f5853f5a1767e0c418fd5f348a795b76d701b3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f5853f5a1767e0c418fd5f348a795b76d701b3e", "html_url": "https://github.com/rust-lang/rust/commit/6f5853f5a1767e0c418fd5f348a795b76d701b3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f5853f5a1767e0c418fd5f348a795b76d701b3e/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac57bb38560fa35d883505af2e8e68498b436fe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac57bb38560fa35d883505af2e8e68498b436fe7", "html_url": "https://github.com/rust-lang/rust/commit/ac57bb38560fa35d883505af2e8e68498b436fe7"}], "stats": {"total": 3228, "additions": 798, "deletions": 2430}, "files": [{"sha": "bffce15e0a26fed2c29cd96cab4f061531b6474d", "filename": "doc/tutorial.md", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -132,24 +132,23 @@ Rust program files are, by convention, given the extension `.rs`. Say\n we have a file `hello.rs` containing this program:\n \n ~~~~\n-use std;\n fn main(args: [str]) {\n-    std::io::println(\"hello world from '\" + args[0] + \"'!\");\n+    io::println(\"hello world from '\" + args[0] + \"'!\");\n }\n ~~~~\n \n If the Rust compiler was installed successfully, running `rustc\n hello.rs` will produce a binary called `hello` (or `hello.exe`).\n \n-If you modify the program to make it invalid (for example, remove the\n-`use std` line), and then compile it, you'll see an error message like\n-this:\n+If you modify the program to make it invalid (for example, change the\n+function to an unknown name), and then compile it, you'll see an error\n+message like this:\n \n ~~~~\n ## notrust\n-hello.rs:2:4: 2:20 error: unresolved modulename: std\n-hello.rs:2     std::io::println(\"hello world!\");\n-               ^~~~~~~~~~~~~~~~\n+hello.rs:2:4: 2:16 error: unresolved name: io::print_it\n+hello.rs:2     io::print_it(\"hello world from '\" + args[0] + \"'!\");\n+               ^~~~~~~~~~~~\n ~~~~\n \n The Rust compiler tries to provide useful information when it runs\n@@ -278,8 +277,8 @@ NOTE: The parser doesn't currently recognize non-ascii alphabetic\n characters. This is a bug that will eventually be fixed.\n \n The double-colon (`::`) is used as a module separator, so\n-`std::io::println` means 'the thing named `println` in the module\n-named `io` in the module named `std`'.\n+`io::println` means 'the thing named `println` in the module\n+named `io`.\n \n Rust will normally emit warnings about unused variables. These can be\n suppressed by using a variable name that starts with an underscore.\n@@ -300,7 +299,7 @@ const repeat: uint = 5u;\n fn main() {\n     let count = 0u;\n     while count < repeat {\n-        std::io::println(\"Hi!\");\n+        io::println(\"Hi!\");\n         count += 1u;\n     }\n }\n@@ -535,7 +534,7 @@ one is `#fmt`, a printf-style text formatting macro that is expanded\n at compile time.\n \n ~~~~\n-std::io::println(#fmt(\"%s is %d\", \"the answer\", 42));\n+io::println(#fmt(\"%s is %d\", \"the answer\", 42));\n ~~~~\n \n `#fmt` supports most of the directives that [printf][pf] supports, but\n@@ -549,7 +548,7 @@ All syntax extensions look like `#word`. Another built-in one is\n compile-time.\n \n ~~~~\n-std::io::println(#env(\"PATH\"));\n+io::println(#env(\"PATH\"));\n ~~~~\n # Control structures\n \n@@ -561,11 +560,11 @@ compulsory, an optional `else` clause can be appended, and multiple\n \n ~~~~\n if false {\n-    std::io::println(\"that's odd\");\n+    io::println(\"that's odd\");\n } else if true {\n-    std::io::println(\"right\");\n+    io::println(\"right\");\n } else {\n-    std::io::println(\"neither true nor false\");\n+    io::println(\"neither true nor false\");\n }\n ~~~~\n \n@@ -598,10 +597,10 @@ the value.\n ~~~~\n # let my_number = 1;\n alt my_number {\n-  0       { std::io::println(\"zero\"); }\n-  1 | 2   { std::io::println(\"one or two\"); }\n-  3 to 10 { std::io::println(\"three to ten\"); }\n-  _       { std::io::println(\"something else\"); }\n+  0       { io::println(\"zero\"); }\n+  1 | 2   { io::println(\"one or two\"); }\n+  3 to 10 { io::println(\"three to ten\"); }\n+  _       { io::println(\"something else\"); }\n }\n ~~~~\n \n@@ -675,7 +674,7 @@ let x = 5;\n while true {\n     x += x - 3;\n     if x % 5 == 0 { break; }\n-    std::io::println(int::str(x));\n+    io::println(int::str(x));\n }\n ~~~~\n \n@@ -697,7 +696,7 @@ When iterating over a vector, use `for` instead.\n \n ~~~~\n for elt in [\"red\", \"green\", \"blue\"] {\n-    std::io::println(elt);\n+    io::println(elt);\n }\n ~~~~\n \n@@ -864,7 +863,7 @@ fn mk_appender(suffix: str) -> fn@(str) -> str {\n \n fn main() {\n     let shout = mk_appender(\"!\");\n-    std::io::println(shout(\"hey ho, let's go\"));\n+    io::println(shout(\"hey ho, let's go\"));\n }\n ~~~~\n \n@@ -1267,7 +1266,7 @@ with square brackets (zero-based):\n \n ~~~~\n let myvec = [true, false, true, false];\n-if myvec[1] { std::io::println(\"boom\"); }\n+if myvec[1] { io::println(\"boom\"); }\n ~~~~\n \n By default, vectors are immutable\u2014you can not replace their elements.\n@@ -1669,7 +1668,7 @@ mod farm {\n     fn cow() -> str { \"mooo\" }\n }\n fn main() {\n-    std::io::println(farm::chicken());\n+    io::println(farm::chicken());\n }\n ~~~~\n \n@@ -1788,7 +1787,7 @@ fn world() -> str { \"world\" }\n // main.rs\n use std;\n use mylib;\n-fn main() { std::io::println(\"hello \" + mylib::world()); }\n+fn main() { io::println(\"hello \" + mylib::world()); }\n ~~~~\n \n Now compile and run like this (adjust to your platform if necessary):\n@@ -1810,21 +1809,21 @@ identifiers at the top of a file, module, or block.\n \n ~~~~\n use std;\n-import std::io::println;\n+import io::println;\n fn main() {\n     println(\"that was easy\");\n }\n ~~~~\n \n It is also possible to import just the name of a module (`import\n-std::io;`, then use `io::println`), to import all identifiers exported\n-by a given module (`import std::io::*`), or to import a specific set\n+std::list;`, then use `list::find`), to import all identifiers exported\n+by a given module (`import io::*`), or to import a specific set\n of identifiers (`import math::{min, max, pi}`).\n \n You can rename an identifier when importing using the `=` operator:\n \n ~~~~\n-import prnt = std::io::println;\n+import prnt = io::println;\n ~~~~\n \n ## Exporting\n@@ -2158,7 +2157,7 @@ fn sha1(data: str) -> str unsafe {\n }\n \n fn main(args: [str]) {\n-    std::io::println(sha1(args[1]));\n+    io::println(sha1(args[1]));\n }\n ~~~~\n \n@@ -2376,8 +2375,8 @@ module `task`.  Let's begin with the simplest one, `task::spawn()`:\n ~~~~\n let some_value = 22;\n task::spawn {||\n-    std::io::println(\"This executes in the child task.\");\n-    std::io::println(#fmt(\"%d\", some_value));\n+    io::println(\"This executes in the child task.\");\n+    io::println(#fmt(\"%d\", some_value));\n }\n ~~~~\n "}, {"sha": "9a19cfc0220299e4d5a1744a72d8fdaf35db531b", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -10,15 +10,11 @@ import rustc::util::filesearch::{get_cargo_root, get_cargo_root_nearest,\n import rustc::driver::diagnostic;\n \n import result::{ok, err};\n-import std::fs;\n-import std::io;\n import io::writer_util;\n import std::json;\n import result;\n import std::map;\n import std::map::hashmap;\n-import std::os;\n-import std::run;\n import str;\n import std::tempfile;\n import vec;\n@@ -184,8 +180,8 @@ fn rest(s: str, start: uint) -> str {\n }\n \n fn need_dir(s: str) {\n-    if fs::path_is_dir(s) { ret; }\n-    if !fs::make_dir(s, 0x1c0i32) {\n+    if os::path_is_dir(s) { ret; }\n+    if !os::make_dir(s, 0x1c0i32) {\n         fail #fmt[\"can't make_dir %s\", s];\n     }\n }\n@@ -225,7 +221,7 @@ fn parse_source(name: str, j: json::json) -> source {\n }\n \n fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n-    if !fs::path_exists(filename)  { ret; }\n+    if !os::path_exists(filename)  { ret; }\n     let c = io::read_whole_file_str(filename);\n     alt json::from_str(result::get(c)) {\n         ok(json::dict(j)) {\n@@ -314,9 +310,9 @@ fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n \n fn load_source_packages(&c: cargo, &src: source) {\n     log(debug, \"Loading source: \" + src.name);\n-    let dir = fs::connect(c.sourcedir, src.name);\n-    let pkgfile = fs::connect(dir, \"packages.json\");\n-    if !fs::path_exists(pkgfile) { ret; }\n+    let dir = path::connect(c.sourcedir, src.name);\n+    let pkgfile = path::connect(dir, \"packages.json\");\n+    if !os::path_exists(pkgfile) { ret; }\n     let pkgstr = io::read_whole_file_str(pkgfile);\n     alt json::from_str(result::get(pkgstr)) {\n         ok(json::list(js)) {\n@@ -392,15 +388,15 @@ fn configure(opts: options) -> cargo {\n     };\n \n     let sources = map::new_str_hash::<source>();\n-    try_parse_sources(fs::connect(syscargo, \"sources.json\"), sources);\n-    try_parse_sources(fs::connect(syscargo, \"local-sources.json\"), sources);\n+    try_parse_sources(path::connect(syscargo, \"sources.json\"), sources);\n+    try_parse_sources(path::connect(syscargo, \"local-sources.json\"), sources);\n     let c = {\n         pgp: pgp::supported(),\n         root: p,\n-        bindir: fs::connect(p, \"bin\"),\n-        libdir: fs::connect(p, \"lib\"),\n-        workdir: fs::connect(p, \"work\"),\n-        sourcedir: fs::connect(syscargo, \"sources\"),\n+        bindir: path::connect(p, \"bin\"),\n+        libdir: path::connect(p, \"lib\"),\n+        workdir: path::connect(p, \"work\"),\n+        sourcedir: path::connect(syscargo, \"sources\"),\n         sources: sources,\n         opts: opts\n     };\n@@ -438,7 +434,7 @@ fn for_each_package(c: cargo, b: fn(source, package)) {\n \n // FIXME: deduplicate code with install_one_crate\n fn test_one_crate(_c: cargo, _path: str, cf: str, _p: pkg) {\n-    let buildpath = fs::connect(_path, \"/test\");\n+    let buildpath = path::connect(_path, \"/test\");\n     need_dir(buildpath);\n     #debug(\"Testing: %s -> %s\", cf, buildpath);\n     let p = run::program_output(rustc_sysroot(),\n@@ -447,14 +443,14 @@ fn test_one_crate(_c: cargo, _path: str, cf: str, _p: pkg) {\n         error(#fmt[\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out]);\n         ret;\n     }\n-    let new = fs::list_dir(buildpath);\n+    let new = os::list_dir(buildpath);\n     for ct: str in new {\n         run::run_program(ct, []);\n     }\n }\n \n fn install_one_crate(c: cargo, _path: str, cf: str, _p: pkg) {\n-    let buildpath = fs::connect(_path, \"/build\");\n+    let buildpath = path::connect(_path, \"/build\");\n     need_dir(buildpath);\n     #debug(\"Installing: %s -> %s\", cf, buildpath);\n     let p = run::program_output(rustc_sysroot(),\n@@ -463,14 +459,14 @@ fn install_one_crate(c: cargo, _path: str, cf: str, _p: pkg) {\n         error(#fmt[\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out]);\n         ret;\n     }\n-    let new = fs::list_dir(buildpath);\n-    let exec_suffix = os::exec_suffix();\n+    let new = os::list_dir(buildpath);\n+    let exec_suffix = os::exe_suffix();\n     for ct: str in new {\n         if (exec_suffix != \"\" && str::ends_with(ct, exec_suffix)) ||\n-            (exec_suffix == \"\" && !str::starts_with(fs::basename(ct),\n+            (exec_suffix == \"\" && !str::starts_with(path::basename(ct),\n                                                     \"lib\")) {\n             #debug(\"  bin: %s\", ct);\n-            // FIXME: need libstd fs::copy or something\n+            // FIXME: need libstd os::copy or something\n             run::run_program(\"cp\", [ct, c.bindir]);\n             if c.opts.mode == system_mode {\n                 install_one_crate_to_sysroot(ct, \"bin\");\n@@ -486,11 +482,11 @@ fn install_one_crate(c: cargo, _path: str, cf: str, _p: pkg) {\n }\n \n fn install_one_crate_to_sysroot(ct: str, target: str) {\n-    alt os::get_exe_path() {\n+    alt os::self_exe_path() {\n         some(_path) {\n             let path = [_path, \"..\", target];\n             check vec::is_not_empty(path);\n-            let target_dir = fs::normalize(fs::connect_many(path));\n+            let target_dir = path::normalize(path::connect_many(path));\n             let p = run::program_output(\"cp\", [ct, target_dir]);\n             if p.status != 0 {\n                 warn(#fmt[\"Copying %s to %s is failed\", ct, target_dir]);\n@@ -501,11 +497,11 @@ fn install_one_crate_to_sysroot(ct: str, target: str) {\n }\n \n fn rustc_sysroot() -> str {\n-    alt os::get_exe_path() {\n+    alt os::self_exe_path() {\n         some(_path) {\n             let path = [_path, \"..\", \"bin\", \"rustc\"];\n             check vec::is_not_empty(path);\n-            let rustc = fs::normalize(fs::connect_many(path));\n+            let rustc = path::normalize(path::connect_many(path));\n             #debug(\"  rustc: %s\", rustc);\n             rustc\n         }\n@@ -515,8 +511,8 @@ fn rustc_sysroot() -> str {\n \n fn install_source(c: cargo, path: str) {\n     #debug(\"source: %s\", path);\n-    fs::change_dir(path);\n-    let contents = fs::list_dir(\".\");\n+    os::change_dir(path);\n+    let contents = os::list_dir(\".\");\n \n     #debug(\"contents: %s\", str::connect(contents, \", \"));\n \n@@ -545,15 +541,15 @@ fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n     run::run_program(\"git\", [\"clone\", url, wd]);\n     if option::is_some::<str>(ref) {\n         let r = option::get::<str>(ref);\n-        fs::change_dir(wd);\n+        os::change_dir(wd);\n         run::run_program(\"git\", [\"checkout\", r]);\n     }\n \n     install_source(c, wd);\n }\n \n fn install_curl(c: cargo, wd: str, url: str) {\n-    let tarpath = fs::connect(wd, \"pkg.tar\");\n+    let tarpath = path::connect(wd, \"pkg.tar\");\n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\",\n                                          tarpath, url]);\n     if p.status != 0 {\n@@ -684,7 +680,7 @@ fn cmd_install(c: cargo) unsafe {\n \n     let target = c.opts.free[2];\n \n-    let wd = alt tempfile::mkdtemp(c.workdir + fs::path_sep(), \"\") {\n+    let wd = alt tempfile::mkdtemp(c.workdir + path::path_sep(), \"\") {\n         some(_wd) { _wd }\n         none { fail \"needed temp dir\"; }\n     };\n@@ -717,11 +713,11 @@ fn cmd_install(c: cargo) unsafe {\n }\n \n fn sync_one(c: cargo, name: str, src: source) {\n-    let dir = fs::connect(c.sourcedir, name);\n-    let pkgfile = fs::connect(dir, \"packages.json.new\");\n-    let destpkgfile = fs::connect(dir, \"packages.json\");\n-    let sigfile = fs::connect(dir, \"packages.json.sig\");\n-    let keyfile = fs::connect(dir, \"key.gpg\");\n+    let dir = path::connect(c.sourcedir, name);\n+    let pkgfile = path::connect(dir, \"packages.json.new\");\n+    let destpkgfile = path::connect(dir, \"packages.json\");\n+    let sigfile = path::connect(dir, \"packages.json.sig\");\n+    let keyfile = path::connect(dir, \"key.gpg\");\n     let url = src.url;\n     need_dir(dir);\n     info(#fmt[\"fetching source %s...\", name]);\n@@ -784,9 +780,9 @@ fn cmd_init(c: cargo) {\n     let srcurl = \"http://www.rust-lang.org/cargo/sources.json\";\n     let sigurl = \"http://www.rust-lang.org/cargo/sources.json.sig\";\n \n-    let srcfile = fs::connect(c.root, \"sources.json.new\");\n-    let sigfile = fs::connect(c.root, \"sources.json.sig\");\n-    let destsrcfile = fs::connect(c.root, \"sources.json\");\n+    let srcfile = path::connect(c.root, \"sources.json.new\");\n+    let sigfile = path::connect(c.root, \"sources.json.sig\");\n+    let destsrcfile = path::connect(c.root, \"sources.json\");\n \n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcfile, srcurl]);\n     if p.status != 0 {"}, {"sha": "7756f08e8f440d26defe3dbc00e7a413c55b43dd", "filename": "src/cargo/pgp.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fpgp.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,8 +1,5 @@\n use std;\n \n-import std::fs;\n-import std::run;\n-\n fn gpg(args: [str]) -> { status: int, out: str, err: str } {\n     ret run::program_output(\"gpg\", args);\n }\n@@ -69,9 +66,9 @@ fn supported() -> bool {\n }\n \n fn init(root: str) {\n-    let p = fs::connect(root, \"gpg\");\n-    if !fs::path_is_dir(p) {\n-        fs::make_dir(p, 0x1c0i32);\n+    let p = path::connect(root, \"gpg\");\n+    if !os::path_is_dir(p) {\n+        os::make_dir(p, 0x1c0i32);\n         let p = run::start_program(\"gpg\", [\"--homedir\", p, \"--import\"]);\n         p.input().write_str(signing_key());\n         let s = p.finish();\n@@ -82,15 +79,15 @@ fn init(root: str) {\n }\n \n fn add(root: str, key: str) {\n-    let path = fs::connect(root, \"gpg\");\n+    let path = path::connect(root, \"gpg\");\n     let p = run::program_output(\"gpg\", [\"--homedir\", path, \"--import\", key]);\n     if p.status != 0 {\n         fail \"pgp add failed: \" + p.out;\n     }\n }\n \n fn verify(root: str, data: str, sig: str, keyfp: str) -> bool {\n-    let path = fs::connect(root, \"gpg\");\n+    let path = path::connect(root, \"gpg\");\n     let p = gpg([\"--homedir\", path, \"--with-fingerprint\", \"--verify\", sig,\n                  data]);\n     let res = \"Primary key fingerprint: \" + keyfp;"}, {"sha": "09ab34a9ade1ef5842a39a560ac32ad828c7d4de", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -4,7 +4,6 @@\n import option;\n import std::getopts;\n import std::test;\n-import std::fs;\n import str;\n import vec;\n import task;\n@@ -131,7 +130,7 @@ fn test_opts(config: config) -> test::test_opts {\n fn make_tests(config: config) -> [test::test_desc] {\n     #debug(\"making tests from %s\", config.src_base);\n     let tests = [];\n-    for file: str in fs::list_dir(config.src_base) {\n+    for file: str in os::list_dir(config.src_base) {\n         let file = file;\n         #debug(\"inspecting file %s\", file);\n         if is_test(config, file) {\n@@ -146,7 +145,7 @@ fn is_test(config: config, testfile: str) -> bool {\n     let valid_extensions =\n         alt config.mode { mode_pretty { [\".rs\"] } _ { [\".rc\", \".rs\"] } };\n     let invalid_prefixes = [\".\", \"#\", \"~\"];\n-    let name = fs::basename(testfile);\n+    let name = path::basename(testfile);\n \n     let valid = false;\n "}, {"sha": "f8487ad44cf4996ae239a44fafe0f7af88eda387", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,6 +1,4 @@\n-import std::io;\n import io::reader_util;\n-import std::fs;\n \n import common::config;\n "}, {"sha": "654c49b2dee54d3238effe29b9312c550519a9ce", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,8 +1,6 @@\n import option;\n import str;\n-import std::io;\n import io::reader_util;\n-import std::fs;\n \n import common::config;\n \n@@ -67,7 +65,7 @@ fn is_test_ignored(config: config, testfile: str) -> bool {\n     ret found;\n \n     fn xfail_target() -> str {\n-        \"xfail-\" + std::os::target_os()\n+        \"xfail-\" + os::sysname()\n     }\n }\n \n@@ -103,7 +101,7 @@ fn parse_pp_exact(line: str, testfile: str) -> option<str> {\n       option::some(s) { option::some(s) }\n       option::none {\n         if parse_name_directive(line, \"pp-exact\") {\n-            option::some(fs::basename(testfile))\n+            option::some(path::basename(testfile))\n         } else {\n             option::none\n         }"}, {"sha": "f382839d4a6614c85fa862e6a597499cb52066e2", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,16 +1,13 @@\n-import std::run;\n-import std::run::spawn_process;\n-import std::io;\n-import std::os;\n+import run::spawn_process;\n import io::writer_util;\n-import ctypes::{pid_t, fd_t};\n+import libc::{c_int, pid_t};\n \n export run;\n \n #[cfg(target_os = \"win32\")]\n fn target_env(lib_path: str, prog: str) -> option<[(str,str)]> {\n \n-    let env = std::generic_os::env();\n+    let env = os::env();\n \n     env = vec::map(env) {|pair|\n         let (k,v) = pair;\n@@ -81,7 +78,7 @@ fn run(lib_path: str, prog: str, args: [str],\n     ret {status: status, out: outs, err: errs};\n }\n \n-fn writeclose(fd: fd_t, s: option<str>) {\n+fn writeclose(fd: c_int, s: option<str>) {\n     if option::is_some(s) {\n         let writer = io::fd_writer(fd, false);\n         writer.write_str(option::get(s));\n@@ -90,9 +87,9 @@ fn writeclose(fd: fd_t, s: option<str>) {\n     os::close(fd);\n }\n \n-fn readclose(fd: fd_t) -> str {\n+fn readclose(fd: c_int) -> str {\n     // Copied from run::program_output\n-    let file = os::fd_FILE(fd);\n+    let file = os::fdopen(fd);\n     let reader = io::FILE_reader(file, false);\n     let buf = \"\";\n     while !reader.eof() {"}, {"sha": "92316e9a2b0a621b1ef2b035630f57339e75c07e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,7 +1,4 @@\n-import std::io;\n import io::writer_util;\n-import std::fs;\n-import std::os;\n \n import common::mode_run_pass;\n import common::mode_run_fail;\n@@ -115,7 +112,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: str) {\n     let expected =\n         alt props.pp_exact {\n           option::some(file) {\n-            let filepath = fs::connect(fs::dirname(testfile), file);\n+            let filepath = path::connect(path::dirname(testfile), file);\n             result::get(io::read_whole_file_str(filepath))\n           }\n           option::none { srcs[vec::len(srcs) - 2u] }\n@@ -289,7 +286,7 @@ type procres = {status: int, stdout: str, stderr: str, cmdline: str};\n fn compile_test(config: config, props: test_props,\n                 testfile: str) -> procres {\n     vec::iter(props.aux_builds) {|rel_ab|\n-        let abs_ab = fs::connect(config.aux_base, rel_ab);\n+        let abs_ab = path::connect(config.aux_base, rel_ab);\n         let auxres = compose_and_run(config, abs_ab,\n                                      make_compile_args(_, props, [\"--lib\"],\n                                                        make_lib_name, _),\n@@ -338,7 +335,7 @@ fn make_lib_name(config: config, testfile: str) -> str {\n }\n \n fn make_exe_name(config: config, testfile: str) -> str {\n-    output_base_name(config, testfile) + os::exec_suffix()\n+    output_base_name(config, testfile) + os::exe_suffix()\n }\n \n fn make_run_args(config: config, _props: test_props, testfile: str) ->\n@@ -434,7 +431,7 @@ fn make_out_name(config: config, testfile: str, extension: str) -> str {\n fn output_base_name(config: config, testfile: str) -> str {\n     let base = config.build_base;\n     let filename = {\n-        let parts = str::split_char(fs::basename(testfile), '.');\n+        let parts = str::split_char(path::basename(testfile), '.');\n         str::connect(vec::slice(parts, 0u, vec::len(parts) - 1u), \".\")\n     };\n     #fmt[\"%s%s.%s\", base, filename, config.stage_id]"}, {"sha": "b29b0d968c4fa9e65800d8bc4c80d19d74b755e9", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,6 +1,5 @@\n import option;\n-import std::generic_os::getenv;\n-import std::io;\n+import os::getenv;\n \n import common::config;\n "}, {"sha": "ae56ff7324caf9d4a1742b43902ab313d2175a35", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -54,9 +54,9 @@ def scrub(b):\n d.write(\"use std;\\n\")\n d.write(\"use run_pass_stage2;\\n\")\n d.write(\"import run_pass_stage2::*;\\n\")\n-d.write(\"import std::io::writer_util;\\n\");\n+d.write(\"import io::writer_util;\\n\");\n d.write(\"fn main() {\\n\");\n-d.write(\"    let out = std::io::stdout();\\n\");\n+d.write(\"    let out = io::stdout();\\n\");\n i = 0\n for t in stage2_tests:\n     p = os.path.join(\"test\", \"run-pass\", t)"}, {"sha": "9acc122f32b99d7c37057f7b11be9fad32b60ebb", "filename": "src/etc/libc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fetc%2Flibc.c", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fetc%2Flibc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flibc.c?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -167,15 +167,15 @@ void posix88_consts() {\n   put_const(X_OK, int);\n #endif\n \n-#ifdef STDERR_FILENO\n-  put_const(STDERR_FILENO, int);\n-#endif\n #ifdef STDIN_FILENO\n   put_const(STDIN_FILENO, int);\n #endif\n #ifdef STDOUT_FILENO\n   put_const(STDOUT_FILENO, int);\n #endif\n+#ifdef STDERR_FILENO\n+  put_const(STDERR_FILENO, int);\n+#endif\n \n #ifdef F_LOCK\n   put_const(F_LOCK, int);"}, {"sha": "b0b1d5c5f6669e6fa48538809e179c1ae14ea499", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,4 +1,3 @@\n-import std::{fs, io};\n import io::writer_util;\n \n import rustc::syntax::{ast, ast_util, fold, visit, codemap};\n@@ -23,10 +22,10 @@ fn find_rust_files(&files: [str], path: str) {\n     if str::ends_with(path, \".rs\") && !contains(path, \"utf8\") {\n         // ignoring \"utf8\" tests because something is broken\n         files += [path];\n-    } else if fs::path_is_dir(path)\n+    } else if os::path_is_dir(path)\n         && !contains(path, \"compile-fail\")\n         && !contains(path, \"build\") {\n-        for p in fs::list_dir(path) {\n+        for p in os::list_dir(path) {\n             find_rust_files(files, p);\n         }\n     }\n@@ -323,17 +322,17 @@ fn check_whole_compiler(code: str, suggested_filename_prefix: str, allow_running\n fn removeIfExists(filename: str) {\n     // So sketchy!\n     assert !contains(filename, \" \");\n-    std::run::program_output(\"bash\", [\"-c\", \"rm \" + filename]);\n+    run::program_output(\"bash\", [\"-c\", \"rm \" + filename]);\n }\n \n fn removeDirIfExists(filename: str) {\n     // So sketchy!\n     assert !contains(filename, \" \");\n-    std::run::program_output(\"bash\", [\"-c\", \"rm -r \" + filename]);\n+    run::program_output(\"bash\", [\"-c\", \"rm -r \" + filename]);\n }\n \n fn check_running(exe_filename: str) -> happiness {\n-    let p = std::run::program_output(\"/Users/jruderman/scripts/timed_run_rust_program.py\", [exe_filename]);\n+    let p = run::program_output(\"/Users/jruderman/scripts/timed_run_rust_program.py\", [exe_filename]);\n     let comb = p.out + \"\\n\" + p.err;\n     if str::len(comb) > 1u {\n         log(error, \"comb comb comb: \" + comb);\n@@ -362,7 +361,7 @@ fn check_running(exe_filename: str) -> happiness {\n }\n \n fn check_compiling(filename: str) -> happiness {\n-    let p = std::run::program_output(\n+    let p = run::program_output(\n             \"/Users/jruderman/code/rust/build/x86_64-apple-darwin/stage1/bin/rustc\",\n             [filename]);\n \n@@ -506,9 +505,9 @@ fn check_roundtrip_convergence(code: @str, maxIters: uint) {\n         #error(\"Did not converge after %u iterations!\", i);\n         write_file(\"round-trip-a.rs\", *old);\n         write_file(\"round-trip-b.rs\", *new);\n-        std::run::run_program(\"diff\",\n-                              [\"-w\", \"-u\", \"round-trip-a.rs\",\n-                               \"round-trip-b.rs\"]);\n+        run::run_program(\"diff\",\n+                         [\"-w\", \"-u\", \"round-trip-a.rs\",\n+                          \"round-trip-b.rs\"]);\n         fail \"Mismatch\";\n     }\n }"}, {"sha": "ba2bad81906cca16bc5d757346334ea88d54051f", "filename": "src/libcore/cmath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmath.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -7,9 +7,9 @@ export c_double;\n export c_float_targ_consts;\n export c_double_targ_consts;\n \n-import ctypes::c_int;\n-import ctypes::c_float;\n-import ctypes::c_double;\n+import libc::c_int;\n+import libc::c_float;\n+import libc::c_double;\n \n // function names are almost identical to C's libmath, a few have been\n // renamed, grep for \"rename:\""}, {"sha": "e4f0663c44390d0ca77a7d862ee9c468c1522918", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -41,20 +41,20 @@ native mod rustrt {\n     fn get_task_id() -> task_id;\n     fn chan_id_send<T: send>(t: *sys::type_desc,\n                             target_task: task_id, target_port: port_id,\n-                            data: T) -> ctypes::uintptr_t;\n+                            data: T) -> libc::uintptr_t;\n \n-    fn new_port(unit_sz: ctypes::size_t) -> *rust_port;\n+    fn new_port(unit_sz: libc::size_t) -> *rust_port;\n     fn del_port(po: *rust_port);\n     fn rust_port_begin_detach(po: *rust_port,\n-                              yield: *ctypes::uintptr_t);\n+                              yield: *libc::uintptr_t);\n     fn rust_port_end_detach(po: *rust_port);\n     fn get_port_id(po: *rust_port) -> port_id;\n-    fn rust_port_size(po: *rust_port) -> ctypes::size_t;\n+    fn rust_port_size(po: *rust_port) -> libc::size_t;\n     fn port_recv(dptr: *uint, po: *rust_port,\n-                 yield: *ctypes::uintptr_t);\n+                 yield: *libc::uintptr_t);\n     fn rust_port_select(dptr: **rust_port, ports: **rust_port,\n-                        n_ports: ctypes::size_t,\n-                        yield: *ctypes::uintptr_t);\n+                        n_ports: libc::size_t,\n+                        yield: *libc::uintptr_t);\n }\n \n #[abi = \"rust-intrinsic\"]\n@@ -147,7 +147,7 @@ fn recv_<T: send>(p: *rust_port) -> T {\n     // that will grab the value of the return pointer, then call this\n     // function, which we will then use to call the runtime.\n     fn recv(dptr: *uint, port: *rust_port,\n-            yield: *ctypes::uintptr_t) unsafe {\n+            yield: *libc::uintptr_t) unsafe {\n         rustrt::port_recv(dptr, port, yield);\n     }\n     let yield = 0u;\n@@ -170,13 +170,13 @@ fn select2<A: send, B: send>(\n ) -> either::t<A, B> unsafe {\n \n     fn select(dptr: **rust_port, ports: **rust_port,\n-              n_ports: ctypes::size_t, yield: *ctypes::uintptr_t) {\n+              n_ports: libc::size_t, yield: *libc::uintptr_t) {\n         rustrt::rust_port_select(dptr, ports, n_ports, yield)\n     }\n \n     let mut ports = [];\n     ports += [***p_a, ***p_b];\n-    let n_ports = 2 as ctypes::size_t;\n+    let n_ports = 2 as libc::size_t;\n     let yield = 0u;\n     let yieldp = ptr::addr_of(yield);\n \n@@ -209,7 +209,7 @@ fn select2<A: send, B: send>(\n \n #[doc = \"Returns true if there are messages available\"]\n fn peek<T: send>(p: port<T>) -> bool {\n-    rustrt::rust_port_size(***p) != 0u as ctypes::size_t\n+    rustrt::rust_port_size(***p) != 0u as libc::size_t\n }\n \n #[doc = \""}, {"sha": "c28ad0a0282a5623cc2ac4fdeb0a619a85400284", "filename": "src/libcore/core.rc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -31,7 +31,7 @@ export uint, u8, u16, u32, u64;\n export float, f32, f64;\n export box, char, str, ptr, vec, bool;\n export either, option, result, iter;\n-export libc, os, ctypes, sys, unsafe, logging;\n+export libc, os, io, run, rand, sys, unsafe, logging;\n export comm, task, future;\n export extfmt;\n export tuple;\n@@ -79,9 +79,11 @@ mod to_str;\n \n mod libc;\n mod os;\n+mod io;\n+mod run;\n+mod rand;\n mod path;\n \n-mod ctypes;\n mod cmath;\n mod sys;\n mod unsafe;"}, {"sha": "23974b789c384e46a7a0ac08ef9d5978afa10c39", "filename": "src/libcore/io.rs", "status": "renamed", "additions": 105, "deletions": 79, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -4,14 +4,17 @@ Module: io\n Basic input/output\n */\n \n-import core::ctypes::fd_t;\n-import core::ctypes::c_int;\n+import libc::{c_int, c_uint, c_void, size_t, ssize_t};\n+import libc::consts::os::posix88::*;\n+import libc::consts::os::extra::*;\n+\n+type fd_t = c_int;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn rust_get_stdin() -> os::FILE;\n-    fn rust_get_stdout() -> os::FILE;\n-    fn rust_get_stderr() -> os::FILE;\n+    fn rust_get_stdin() -> *libc::FILE;\n+    fn rust_get_stdout() -> *libc::FILE;\n+    fn rust_get_stderr() -> *libc::FILE;\n }\n \n // Reading\n@@ -37,7 +40,7 @@ impl reader_util for reader {\n     fn read_chars(n: uint) -> [char] {\n         // returns the (consumed offset, n_req), appends characters to &chars\n         fn chars_from_buf(buf: [u8], &chars: [char]) -> (uint, uint) {\n-            let i = 0u;\n+            let mut i = 0u;\n             while i < vec::len(buf) {\n                 let b0 = buf[i];\n                 let w = str::utf8_char_width(b0);\n@@ -52,7 +55,7 @@ impl reader_util for reader {\n                 if end > vec::len(buf) {\n                     ret (i - 1u, end - vec::len(buf));\n                 }\n-                let val = 0u;\n+                let mut val = 0u;\n                 while i < end {\n                     let next = buf[i] as int;\n                     i += 1u;\n@@ -68,10 +71,10 @@ impl reader_util for reader {\n             }\n             ret (i, 0u);\n         }\n-        let buf: [u8] = [];\n-        let chars: [char] = [];\n+        let mut buf: [u8] = [];\n+        let mut chars: [char] = [];\n         // might need more bytes, but reading n will never over-read\n-        let nbread = n;\n+        let mut nbread = n;\n         while nbread > 0u {\n             let data = self.read_bytes(nbread);\n             if vec::len(data) == 0u {\n@@ -103,8 +106,8 @@ impl reader_util for reader {\n     }\n \n     fn read_line() -> str {\n-        let buf: [u8] = [];\n-        loop {\n+        let mut buf: [u8] = [];\n+        while true {\n             let ch = self.read_byte();\n             if ch == -1 || ch == 10 { break; }\n             buf += [ch as u8];\n@@ -113,8 +116,8 @@ impl reader_util for reader {\n     }\n \n     fn read_c_str() -> str {\n-        let buf: [u8] = [];\n-        loop {\n+        let mut buf: [u8] = [];\n+        while true {\n             let ch = self.read_byte();\n             if ch < 1 { break; } else { buf += [ch as u8]; }\n         }\n@@ -123,7 +126,7 @@ impl reader_util for reader {\n \n     // FIXME deal with eof?\n     fn read_le_uint(size: uint) -> uint {\n-        let val = 0u, pos = 0u, i = size;\n+        let mut val = 0u, pos = 0u, i = size;\n         while i > 0u {\n             val += (self.read_byte() as uint) << pos;\n             pos += 8u;\n@@ -132,7 +135,7 @@ impl reader_util for reader {\n         val\n     }\n     fn read_le_int(size: uint) -> int {\n-        let val = 0u, pos = 0u, i = size;\n+        let mut val = 0u, pos = 0u, i = size;\n         while i > 0u {\n             val += (self.read_byte() as uint) << pos;\n             pos += 8u;\n@@ -141,7 +144,7 @@ impl reader_util for reader {\n         val as int\n     }\n     fn read_be_uint(size: uint) -> uint {\n-        let val = 0u, i = size;\n+        let mut val = 0u, i = size;\n         while i > 0u {\n             i -= 1u;\n             val += (self.read_byte() as uint) << i * 8u;\n@@ -150,7 +153,7 @@ impl reader_util for reader {\n     }\n \n     fn read_whole_stream() -> [u8] {\n-        let buf: [u8] = [];\n+        let mut buf: [u8] = [];\n         while !self.eof() { buf += self.read_bytes(2048u); }\n         buf\n     }\n@@ -166,21 +169,25 @@ fn convert_whence(whence: seek_style) -> i32 {\n     };\n }\n \n-impl of reader for os::FILE {\n+impl of reader for *libc::FILE {\n     fn read_bytes(len: uint) -> [u8] unsafe {\n-        let buf = [];\n+        let mut buf : [mutable u8] = [mutable];\n         vec::reserve(buf, len);\n-        let read = os::libc::fread(vec::unsafe::to_ptr(buf), 1u, len, self);\n-        vec::unsafe::set_len(buf, read);\n-        ret buf;\n+        vec::as_mut_buf(buf) {|b|\n+            let read = libc::fread(b as *mutable c_void, 1u,\n+                                   len, self);\n+            vec::unsafe::set_len(buf, read);\n+        }\n+        ret vec::from_mut(buf);\n     }\n-    fn read_byte() -> int { ret os::libc::fgetc(self) as int; }\n-    fn unread_byte(byte: int) { os::libc::ungetc(byte as i32, self); }\n-    fn eof() -> bool { ret os::libc::feof(self) != 0i32; }\n+    fn read_byte() -> int { ret libc::fgetc(self) as int; }\n+    fn unread_byte(byte: int) { libc::ungetc(byte as c_int, self); }\n+    fn eof() -> bool { ret libc::feof(self) != 0 as c_int; }\n     fn seek(offset: int, whence: seek_style) {\n-        assert os::libc::fseek(self, offset, convert_whence(whence)) == 0i32;\n+        assert libc::fseek(self, offset, convert_whence(whence))\n+            == 0 as c_int;\n     }\n-    fn tell() -> uint { ret os::libc::ftell(self) as uint; }\n+    fn tell() -> uint { ret libc::ftell(self) as uint; }\n }\n \n // A forwarding impl of reader that also holds on to a resource for the\n@@ -195,9 +202,9 @@ impl <T: reader, C> of reader for {base: T, cleanup: C} {\n     fn tell() -> uint { self.base.tell() }\n }\n \n-resource FILE_res(f: os::FILE) { os::libc::fclose(f); }\n+resource FILE_res(f: *libc::FILE) { libc::fclose(f); }\n \n-fn FILE_reader(f: os::FILE, cleanup: bool) -> reader {\n+fn FILE_reader(f: *libc::FILE, cleanup: bool) -> reader {\n     if cleanup {\n         {base: f, cleanup: FILE_res(f)} as reader\n     } else {\n@@ -212,9 +219,9 @@ fn FILE_reader(f: os::FILE, cleanup: bool) -> reader {\n fn stdin() -> reader { rustrt::rust_get_stdin() as reader }\n \n fn file_reader(path: str) -> result::t<reader, str> {\n-    let f = str::as_buf(path, {|pathbuf|\n-        str::as_buf(\"r\", {|modebuf|\n-            os::libc::fopen(pathbuf, modebuf)\n+    let f = os::as_c_charp(path, {|pathbuf|\n+        os::as_c_charp(\"r\", {|modebuf|\n+            libc::fopen(pathbuf, modebuf)\n         })\n     });\n     ret if f as uint == 0u { result::err(\"error opening \" + path) }\n@@ -232,7 +239,7 @@ type byte_buf = {buf: [u8], mutable pos: uint, len: uint};\n impl of reader for byte_buf {\n     fn read_bytes(len: uint) -> [u8] {\n         let rest = self.len - self.pos;\n-        let to_read = len;\n+        let mut to_read = len;\n         if rest < to_read { to_read = rest; }\n         let range = vec::slice(self.buf, self.pos, self.pos + to_read);\n         self.pos += to_read;\n@@ -299,21 +306,27 @@ impl <T: writer, C> of writer for {base: T, cleanup: C} {\n     fn flush() -> int { self.base.flush() }\n }\n \n-impl of writer for os::FILE {\n+impl of writer for *libc::FILE {\n     fn write(v: [const u8]) unsafe {\n         let len = vec::len(v);\n-        let vbuf = vec::unsafe::to_ptr(v);\n-        let nout = os::libc::fwrite(vbuf, len, 1u, self);\n-        if nout < 1u { #error(\"error dumping buffer\"); }\n+        vec::as_buf(v) {|vbuf|\n+            let nout = libc::fwrite(vbuf as *c_void, len, 1u, self);\n+            if nout < 1 as size_t {\n+                #error(\"error writing buffer\");\n+                log(error, sys::last_os_error());\n+                fail;\n+            }\n+        }\n     }\n     fn seek(offset: int, whence: seek_style) {\n-        assert os::libc::fseek(self, offset, convert_whence(whence)) == 0i32;\n+        assert libc::fseek(self, offset, convert_whence(whence))\n+            == 0 as c_int;\n     }\n-    fn tell() -> uint { os::libc::ftell(self) as uint }\n-    fn flush() -> int { os::libc::fflush(self) as int }\n+    fn tell() -> uint { libc::ftell(self) as uint }\n+    fn flush() -> int { libc::fflush(self) as int }\n }\n \n-fn FILE_writer(f: os::FILE, cleanup: bool) -> writer {\n+fn FILE_writer(f: *libc::FILE, cleanup: bool) -> writer {\n     if cleanup {\n         {base: f, cleanup: FILE_res(f)} as writer\n     } else {\n@@ -324,17 +337,18 @@ fn FILE_writer(f: os::FILE, cleanup: bool) -> writer {\n impl of writer for fd_t {\n     fn write(v: [const u8]) unsafe {\n         let len = vec::len(v);\n-        let count = 0u;\n-        let vbuf;\n-        while count < len {\n-            vbuf = ptr::offset(vec::unsafe::to_ptr(v), count);\n-            let nout = os::libc::write(self, vbuf, len);\n-            if nout < 0 {\n-                #error(\"error dumping buffer\");\n-                log(error, sys::last_os_error());\n-                fail;\n+        let mut count = 0u;\n+        vec::as_buf(v) {|vbuf|\n+            while count < len {\n+                let vb = ptr::offset(vbuf, count) as *c_void;\n+                let nout = libc::write(self, vb, len);\n+                if nout < 0 as ssize_t {\n+                    #error(\"error writing buffer\");\n+                    log(error, sys::last_os_error());\n+                    fail;\n+                }\n+                count += nout as uint;\n             }\n-            count += nout as uint;\n         }\n     }\n     fn seek(_offset: int, _whence: seek_style) {\n@@ -348,7 +362,7 @@ impl of writer for fd_t {\n     fn flush() -> int { 0 }\n }\n \n-resource fd_res(fd: fd_t) { os::libc::close(fd); }\n+resource fd_res(fd: fd_t) { libc::close(fd); }\n \n fn fd_writer(fd: fd_t, cleanup: bool) -> writer {\n     if cleanup {\n@@ -358,23 +372,32 @@ fn fd_writer(fd: fd_t, cleanup: bool) -> writer {\n     }\n }\n \n+\n fn mk_file_writer(path: str, flags: [fileflag])\n     -> result::t<writer, str> {\n-    let fflags: i32 =\n-        os::libc_constants::O_WRONLY | os::libc_constants::O_BINARY;\n+\n+    #[cfg(target_os = \"win32\")]\n+    fn wb() -> c_int { (O_WRONLY | O_BINARY) as c_int }\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn wb() -> c_int { O_WRONLY as c_int }\n+\n+    let mut fflags: c_int = wb();\n     for f: fileflag in flags {\n         alt f {\n-          append { fflags |= os::libc_constants::O_APPEND; }\n-          create { fflags |= os::libc_constants::O_CREAT; }\n-          truncate { fflags |= os::libc_constants::O_TRUNC; }\n+          append { fflags |= O_APPEND as c_int; }\n+          create { fflags |= O_CREAT as c_int; }\n+          truncate { fflags |= O_TRUNC as c_int; }\n           no_flag { }\n         }\n     }\n-    let fd = str::as_buf(path, {|pathbuf|\n-        os::libc::open(pathbuf, fflags, os::libc_constants::S_IRUSR |\n-                       os::libc_constants::S_IWUSR)\n-    });\n-    if fd < 0i32 {\n+    let fd = os::as_c_charp(path) {|pathbuf|\n+        libc::open(pathbuf, fflags,\n+                   (S_IRUSR | S_IWUSR) as c_int)\n+    };\n+    if fd < (0 as c_int) {\n         // FIXME don't log this! put it in the returned error string\n         log(error, sys::last_os_error());\n         result::err(\"error opening \" + path)\n@@ -384,7 +407,7 @@ fn mk_file_writer(path: str, flags: [fileflag])\n }\n \n fn u64_to_le_bytes(n: u64, size: uint) -> [u8] {\n-    let bytes: [u8] = [], i = size, n = n;\n+    let mut bytes: [u8] = [], i = size, n = n;\n     while i > 0u {\n         bytes += [(n & 255_u64) as u8];\n         n >>= 8_u64;\n@@ -395,8 +418,8 @@ fn u64_to_le_bytes(n: u64, size: uint) -> [u8] {\n \n fn u64_to_be_bytes(n: u64, size: uint) -> [u8] {\n     assert size <= 8u;\n-    let bytes: [u8] = [];\n-    let i = size;\n+    let mut bytes: [u8] = [];\n+    let mut i = size;\n     while i > 0u {\n         let shift = ((i - 1u) * 8u) as u64;\n         bytes += [(n >> shift) as u8];\n@@ -406,10 +429,10 @@ fn u64_to_be_bytes(n: u64, size: uint) -> [u8] {\n }\n \n fn u64_from_be_bytes(data: [u8], start: uint, size: uint) -> u64 {\n-    let sz = size;\n+    let mut sz = size;\n     assert (sz <= 8u);\n-    let val = 0_u64;\n-    let pos = start;\n+    let mut val = 0_u64;\n+    let mut pos = start;\n     while sz > 0u {\n         sz -= 1u;\n         val += (data[pos] as u64) << ((sz * 8u) as u64);\n@@ -471,16 +494,19 @@ fn file_writer(path: str, flags: [fileflag]) -> result::t<writer, str> {\n \n // FIXME: fileflags\n fn buffered_file_writer(path: str) -> result::t<writer, str> {\n-    let f = str::as_buf(path, {|pathbuf|\n-        str::as_buf(\"w\", {|modebuf| os::libc::fopen(pathbuf, modebuf) })\n-    });\n+    let f = os::as_c_charp(path) {|pathbuf|\n+        os::as_c_charp(\"w\") {|modebuf|\n+            libc::fopen(pathbuf, modebuf)\n+        }\n+    };\n     ret if f as uint == 0u { result::err(\"error opening \" + path) }\n     else { result::ok(FILE_writer(f, true)) }\n }\n \n // FIXME it would be great if this could be a const\n-fn stdout() -> writer { fd_writer(1i32, false) }\n-fn stderr() -> writer { fd_writer(2i32, false) }\n+// FIXME why are these different from the way stdin() is implemented?\n+fn stdout() -> writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n+fn stderr() -> writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n \n fn print(s: str) { stdout().write_str(s); }\n fn println(s: str) { stdout().write_line(s); }\n@@ -498,7 +524,7 @@ impl of writer for mem_buffer {\n         }\n         // FIXME: Optimize: These should be unique pointers.\n         let vlen = vec::len(v);\n-        let vpos = 0u;\n+        let mut vpos = 0u;\n         while vpos < vlen {\n             let b = v[vpos];\n             if self.pos == vec::len(self.buf) {\n@@ -544,7 +570,7 @@ fn with_buf_writer(f: fn(writer)) -> [u8] {\n // Utility functions\n fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n    uint {\n-    let bpos = pos as int;\n+    let mut bpos = pos as int;\n     let blen = len as int;\n     alt whence {\n       seek_set { bpos = offset; }\n@@ -607,11 +633,11 @@ mod fsync {\n     // fsync file after executing blk\n     // FIXME find better way to create resources within lifetime of outer res\n     fn FILE_res_sync(&&file: FILE_res, opt_level: option<level>,\n-                  blk: fn(&&res<os::FILE>)) {\n+                  blk: fn(&&res<*libc::FILE>)) {\n         blk(res({\n             val: *file, opt_level: opt_level,\n-            fsync_fn: fn@(&&file: os::FILE, l: level) -> int {\n-                ret os::fsync_fd(os::libc::fileno(file), l) as int;\n+            fsync_fn: fn@(&&file: *libc::FILE, l: level) -> int {\n+                ret os::fsync_fd(libc::fileno(file), l) as int;\n             }\n         }));\n     }", "previous_filename": "src/libstd/io.rs"}, {"sha": "876e58818718afe5f2563a906fe683a73faa87ed", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -96,6 +96,14 @@ export size_t, ptrdiff_t, clock_t, time_t;\n export c_longlong, c_ulonglong, intptr_t, uintptr_t;\n export off_t, dev_t, ino_t, pid_t, mode_t, ssize_t;\n \n+export EXIT_FAILURE, EXIT_SUCCESS, RAND_MAX,\n+       EOF, SEEK_SET, SEEK_CUR, SEEK_END, _IOFBF, _IONBF, _IOLBF,\n+       BUFSIZ, FOPEN_MAX, FILENAME_MAX, L_tmpnam, TMP_MAX,\n+       O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, O_CREAT, O_EXCL, O_TRUNC,\n+       S_IFIFO, S_IFCHR, S_IFBLK, S_IFDIR, S_IFREG, S_IFMT, S_IEXEC,\n+       S_IWRITE, S_IREAD, S_IRWXU, S_IXUSR, S_IWUSR, S_IRUSR, F_OK, R_OK,\n+       W_OK, X_OK, STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO;\n+\n export isalnum, isalpha, iscntrl, isdigit, islower, isprint, ispunct,\n        isspace, isupper, isxdigit, tolower, toupper;\n \n@@ -111,7 +119,7 @@ export strcpy, strncpy, strcat, strncat, strcmp, strncmp, strcoll, strchr,\n        strxfrm, memcpy, memmove, memcmp, memchr, memset;\n \n export chmod, mkdir;\n-export popen, pclose, fdopen;\n+export popen, pclose, fdopen, fileno;\n export open, creat;\n export access, chdir, close, dup, dup2, execv, execve, execvp, getcwd,\n        getpid, isatty, lseek, pipe, read, rmdir, unlink, write;\n@@ -495,9 +503,9 @@ mod consts {\n             const R_OK : int = 4;\n             const W_OK : int = 2;\n             const X_OK : int = 1;\n-            const STDERR_FILENO : int = 2;\n             const STDIN_FILENO : int = 0;\n             const STDOUT_FILENO : int = 1;\n+            const STDERR_FILENO : int = 2;\n         }\n         mod posix01 { }\n         mod posix08 { }\n@@ -558,6 +566,9 @@ mod consts {\n             const R_OK : int = 4;\n             const W_OK : int = 2;\n             const X_OK : int = 1;\n+            const STDIN_FILENO : int = 0;\n+            const STDOUT_FILENO : int = 1;\n+            const STDERR_FILENO : int = 2;\n             const F_LOCK : int = 1;\n             const F_TEST : int = 3;\n             const F_TLOCK : int = 2;\n@@ -618,9 +629,9 @@ mod consts {\n             const R_OK : int = 4;\n             const W_OK : int = 2;\n             const X_OK : int = 1;\n-            const STDERR_FILENO : int = 2;\n             const STDIN_FILENO : int = 0;\n             const STDOUT_FILENO : int = 1;\n+            const STDERR_FILENO : int = 2;\n             const F_LOCK : int = 1;\n             const F_TEST : int = 3;\n             const F_TLOCK : int = 2;\n@@ -682,9 +693,9 @@ mod consts {\n             const R_OK : int = 4;\n             const W_OK : int = 2;\n             const X_OK : int = 1;\n-            const STDERR_FILENO : int = 2;\n             const STDIN_FILENO : int = 0;\n             const STDOUT_FILENO : int = 1;\n+            const STDERR_FILENO : int = 2;\n             const F_LOCK : int = 1;\n             const F_TEST : int = 3;\n             const F_TLOCK : int = 2;\n@@ -744,7 +755,8 @@ mod funcs {\n             fn setbuf(stream: *FILE, buf: *c_char);\n             // Omitted: printf and scanf variants.\n             fn fgetc(stream: *FILE) -> c_int;\n-            fn fgets(buf: *c_char, n: c_int, stream: *FILE) -> *c_char;\n+            fn fgets(buf: *mutable c_char, n: c_int,\n+                     stream: *FILE) -> *c_char;\n             fn fputc(c: c_int, stream: *FILE) -> c_int;\n             fn fputs(s: *c_char, stream: *FILE) -> *c_char;\n             // Omitted: getc, getchar (might be macros).\n@@ -755,7 +767,7 @@ mod funcs {\n             // Omitted: putc, putchar (might be macros).\n             fn puts(s: *c_char) -> c_int;\n             fn ungetc(c: c_int, stream: *FILE) -> c_int;\n-            fn fread(ptr: *c_void, size: size_t,\n+            fn fread(ptr: *mutable c_void, size: size_t,\n                      nobj: size_t, stream: *FILE) -> size_t;\n             fn fwrite(ptr: *c_void, size: size_t,\n                       nobj: size_t, stream: *FILE) -> size_t;\n@@ -863,7 +875,7 @@ mod funcs {\n         #[abi = \"cdecl\"]\n         native mod fcntl {\n             #[link_name = \"_open\"]\n-            fn open(path: *c_char, oflag: c_int) -> c_int;\n+            fn open(path: *c_char, oflag: c_int, mode: c_int) -> c_int;\n \n             #[link_name = \"_creat\"]\n             fn creat(path: *c_char, mode: c_int) -> c_int;\n@@ -923,7 +935,7 @@ mod funcs {\n                     textmode: c_int) -> c_int;\n \n             #[link_name = \"_read\"]\n-            fn read(fd: c_int, buf: *c_void, count: c_uint) -> c_int;\n+            fn read(fd: c_int, buf: *mutable c_void, count: c_uint) -> c_int;\n \n             #[link_name = \"_rmdir\"]\n             fn rmdir(path: *c_char) -> c_int;\n@@ -932,7 +944,7 @@ mod funcs {\n             fn unlink(c: *c_char) -> c_int;\n \n             #[link_name = \"_write\"]\n-            fn write(fd: c_int, buf: *c_void, count: c_uint) -> c_uint;\n+            fn write(fd: c_int, buf: *c_void, count: c_uint) -> c_int;\n \n         }\n     }\n@@ -964,7 +976,7 @@ mod funcs {\n         #[nolink]\n         #[abi = \"cdecl\"]\n         native mod fcntl {\n-            fn open(path: *c_char, oflag: c_int) -> c_int;\n+            fn open(path: *c_char, oflag: c_int, mode: c_int) -> c_int;\n             fn creat(path: *c_char, mode: mode_t) -> c_int;\n             fn fcntl(fd: c_int, cmd: c_int) -> c_int;\n         }\n@@ -999,7 +1011,7 @@ mod funcs {\n             fn getegid() -> gid_t;\n             fn geteuid() -> uid_t;\n             fn getgid() -> gid_t ;\n-            fn getgroups(ngroups_max: c_int, groups: *gid_t) -> c_int;\n+            fn getgroups(ngroups_max: c_int, groups: *mutable gid_t) -> c_int;\n             fn getlogin() -> *c_char;\n             fn getopt(argc: c_int, argv: **c_char, optstr: *c_char) -> c_int;\n             fn getpgrp() -> pid_t;\n@@ -1012,7 +1024,8 @@ mod funcs {\n             fn pathconf(path: *c_char, name: c_int) -> c_long;\n             fn pause() -> c_int;\n             fn pipe(fds: *mutable c_int) -> c_int;\n-            fn read(fd: c_int, buf: *c_void, count: size_t) -> ssize_t;\n+            fn read(fd: c_int, buf: *mutable c_void,\n+                    count: size_t) -> ssize_t;\n             fn rmdir(path: *c_char) -> c_int;\n             fn setgid(gid: gid_t) -> c_int;\n             fn setpgid(pid: pid_t, pgid: pid_t) -> c_int;"}, {"sha": "eeca52f7bc0d3feb45309c6a084e07a0c4739d15", "filename": "src/libcore/os.rs", "status": "modified", "additions": 121, "deletions": 30, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -26,11 +26,15 @@ import option = option::t;\n import getcwd = rustrt::rust_getcwd;\n import consts::*;\n \n-export close, fclose, fsync_fd;\n+export close, fclose, fsync_fd, waitpid;\n export env, getenv, setenv, fdopen, pipe;\n export getcwd, dll_filename, self_exe_path;\n export exe_suffix, dll_suffix, sysname;\n-export homedir, list_dir, path_is_dir, path_exists;\n+export homedir, list_dir, path_is_dir, path_exists, make_absolute,\n+       make_dir, remove_dir, change_dir, remove_file;\n+\n+// FIXME: move these to str perhaps?\n+export as_c_charp, fill_charp_buf;\n \n native mod rustrt {\n     fn rust_env_pairs() -> [str];\n@@ -76,16 +80,32 @@ mod win32 {\n \n     fn fill_utf16_buf_and_decode(f: fn(*mutable u16, dword) -> dword)\n         -> option<str> {\n-        let buf = vec::to_mut(vec::init_elt(tmpbuf_sz, 0u16));\n-        vec::as_mut_buf(buf) {|b|\n-            let k : dword = f(b, tmpbuf_sz as dword);\n-            if k == (0 as dword) {\n-                none\n-            } else {\n-                let sub = vec::slice(buf, 0u, k as uint);\n-                option::some::<str>(str::from_utf16(sub))\n+\n+        // FIXME: remove these when export globs work properly.\n+        import libc::funcs::extra::kernel32::*;\n+        import libc::consts::os::extra::*;\n+\n+        let mut n = tmpbuf_sz;\n+        let mut res = none;\n+        let mut done = false;\n+        while !done {\n+            let buf = vec::to_mut(vec::init_elt(n, 0u16));\n+            vec::as_mut_buf(buf) {|b|\n+                let k : dword = f(b, tmpbuf_sz as dword);\n+                if k == (0 as dword) {\n+                    done = true;\n+                } else if (k == n &&\n+                           GetLastError() ==\n+                           ERROR_INSUFFICIENT_BUFFER as dword) {\n+                    n *= (2 as dword);\n+                } else {\n+                    let sub = vec::slice(buf, 0u, k as uint);\n+                    res = option::some::<str>(str::from_utf16(sub));\n+                    done = true;\n+                }\n             }\n         }\n+        ret res;\n     }\n \n     fn as_utf16_p<T>(s: str, f: fn(*u16) -> T) -> T {\n@@ -160,41 +180,29 @@ fn fdopen(fd: c_int) -> *FILE {\n \n // fsync related\n \n-enum fsync_level {\n-    // whatever fsync does on that platform\n-    fsync,\n-\n-    // fdatasync on linux, similiar or more on other platforms\n-    fdatasync,\n-\n-    // full fsync\n-    //\n-    // You must additionally sync the parent directory as well!\n-    fullfsync,\n-}\n-\n #[cfg(target_os = \"win32\")]\n-fn fsync_fd(fd: c_int, _level: fsync_level) -> c_int {\n+fn fsync_fd(fd: c_int, _level: io::fsync::level) -> c_int {\n     import libc::funcs::extra::msvcrt::*;\n     ret commit(fd);\n }\n \n #[cfg(target_os = \"linux\")]\n-fn fsync_fd(fd: c_int, level: fsync_level) -> c_int {\n+fn fsync_fd(fd: c_int, level: io::fsync::level) -> c_int {\n     import libc::funcs::posix01::unistd::*;\n     alt level {\n-      fsync | fullfsync { ret fsync(fd); }\n-      fdatasync { ret fdatasync(fd); }\n+      io::fsync::fsync\n+      | io::fsync::fullfsync { ret fsync(fd); }\n+      io::fsync::fdatasync { ret fdatasync(fd); }\n     }\n }\n \n #[cfg(target_os = \"macos\")]\n-fn fsync_fd(fd: c_int, level: fsync_level) -> c_int {\n+fn fsync_fd(fd: c_int, level: io::fsync::level) -> c_int {\n     import libc::consts::os::extra::*;\n     import libc::funcs::posix88::fcntl::*;\n     import libc::funcs::posix01::unistd::*;\n     alt level {\n-      fsync { ret fsync(fd); }\n+      io::fsync::fsync { ret fsync(fd); }\n       _ {\n         // According to man fnctl, the ok retval is only specified to be !=-1\n         if (fcntl(F_FULLFSYNC as c_int, fd) == -1 as c_int)\n@@ -206,7 +214,7 @@ fn fsync_fd(fd: c_int, level: fsync_level) -> c_int {\n }\n \n #[cfg(target_os = \"freebsd\")]\n-fn fsync_fd(fd: c_int, _l: fsync_level) -> c_int {\n+fn fsync_fd(fd: c_int, _l: io::fsync::level) -> c_int {\n     import libc::funcs::posix01::unistd::*;\n     ret fsync(fd);\n }\n@@ -577,6 +585,89 @@ mod consts {\n #[cfg(test)]\n mod tests {\n \n+\n+    fn make_rand_name() -> str {\n+        import rand;\n+        let rng: rand::rng = rand::mk_rng();\n+        let n = \"TEST\" + rng.gen_str(10u);\n+        assert option::is_none(getenv(n));\n+        n\n+    }\n+\n+    #[test]\n+    #[ignore(reason = \"fails periodically on mac\")]\n+    fn test_setenv() {\n+        let n = make_rand_name();\n+        setenv(n, \"VALUE\");\n+        assert getenv(n) == option::some(\"VALUE\");\n+    }\n+\n+    #[test]\n+    #[ignore(reason = \"fails periodically on mac\")]\n+    fn test_setenv_overwrite() {\n+        let n = make_rand_name();\n+        setenv(n, \"1\");\n+        setenv(n, \"2\");\n+        assert getenv(n) == option::some(\"2\");\n+        setenv(n, \"\");\n+        assert getenv(n) == option::some(\"\");\n+    }\n+\n+    // Windows GetEnvironmentVariable requires some extra work to make sure\n+    // the buffer the variable is copied into is the right size\n+    #[test]\n+    #[ignore(reason = \"fails periodically on mac\")]\n+    fn test_getenv_big() {\n+        let s = \"\";\n+        let i = 0;\n+        while i < 100 { s += \"aaaaaaaaaa\"; i += 1; }\n+        let n = make_rand_name();\n+        setenv(n, s);\n+        log(debug, s);\n+        assert getenv(n) == option::some(s);\n+    }\n+\n+    #[test]\n+    fn test_self_exe_path() {\n+        let path = os::self_exe_path();\n+        assert option::is_some(path);\n+        let path = option::get(path);\n+        log(debug, path);\n+\n+        // Hard to test this function\n+        if os::sysname() != \"win32\" {\n+            assert str::starts_with(path, path::path_sep());\n+        } else {\n+            assert path[1] == ':' as u8;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_env_getenv() {\n+        let e = env();\n+        assert vec::len(e) > 0u;\n+        for (n, v) in e {\n+            log(debug, n);\n+            let v2 = getenv(n);\n+            // MingW seems to set some funky environment variables like\n+            // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n+            // from env() but not visible from getenv().\n+            assert option::is_none(v2) || v2 == option::some(v);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_env_setenv() {\n+        let n = make_rand_name();\n+\n+        let e = env();\n+        setenv(n, \"VALUE\");\n+        assert !vec::contains(e, (n, \"VALUE\"));\n+\n+        e = env();\n+        assert vec::contains(e, (n, \"VALUE\"));\n+    }\n+\n     #[test]\n     fn test() {\n         assert (!path::path_is_absolute(\"test-path\"));"}, {"sha": "72552d318d2977411232bf08b3be3f48a6248038", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -12,9 +12,9 @@ export memmove;\n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n     fn addr_of<T>(val: T) -> *T;\n-    fn ptr_offset<T>(ptr: *T, count: ctypes::uintptr_t) -> *T;\n-    fn memcpy<T>(dst: *T, src: *T, count: ctypes::uintptr_t);\n-    fn memmove<T>(dst: *T, src: *T, count: ctypes::uintptr_t);\n+    fn ptr_offset<T>(ptr: *T, count: libc::uintptr_t) -> *T;\n+    fn memcpy<T>(dst: *T, src: *T, count: libc::uintptr_t);\n+    fn memmove<T>(dst: *T, src: *T, count: libc::uintptr_t);\n }\n \n #[doc = \"Get an unsafe pointer to a value\"]"}, {"sha": "5744323fe774fa675c1766ea0f5bf5a244875f63", "filename": "src/libcore/rand.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -41,8 +41,8 @@ fn mk_rng() -> rng {\n             let charset = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                           \"abcdefghijklmnopqrstuvwxyz\" +\n                           \"0123456789\";\n-            let s = \"\";\n-            let i = 0u;\n+            let mut s = \"\";\n+            let mut i = 0u;\n             while (i < len) {\n                 let n = rustrt::rand_next(**self) as uint %\n                     str::len(charset);\n@@ -52,8 +52,8 @@ fn mk_rng() -> rng {\n             s\n         }\n         fn gen_bytes(len: uint) -> [u8] {\n-            let v = [];\n-            let i = 0u;\n+            let mut v = [];\n+            let mut i = 0u;\n             while i < len {\n                 let n = rustrt::rand_next(**self) as uint;\n                 v += [(n % (u8::max_value as uint)) as u8];", "previous_filename": "src/libstd/rand.rs"}, {"sha": "4777b74c00eaad0b5a93bd86a92c50d1c0009f15", "filename": "src/libcore/run.rs", "status": "renamed", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,7 +1,7 @@\n #[doc =\"Process spawning\"];\n import option::{some, none};\n import str::sbuf;\n-import ctypes::{fd_t, pid_t, void};\n+import libc::{pid_t, c_void, c_int};\n \n export program;\n export run_program;\n@@ -12,8 +12,8 @@ export waitpid;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn rust_run_program(argv: *sbuf, envp: *void, dir: sbuf,\n-                        in_fd: fd_t, out_fd: fd_t, err_fd: fd_t)\n+    fn rust_run_program(argv: *sbuf, envp: *c_void, dir: sbuf,\n+                        in_fd: c_int, out_fd: c_int, err_fd: c_int)\n         -> pid_t;\n }\n \n@@ -65,7 +65,7 @@ The process id of the spawned process\n fn spawn_process(prog: str, args: [str],\n                  env: option<[(str,str)]>,\n                  dir: option<str>,\n-                 in_fd: fd_t, out_fd: fd_t, err_fd: fd_t)\n+                 in_fd: c_int, out_fd: c_int, err_fd: c_int)\n    -> pid_t unsafe {\n     with_argv(prog, args) {|argv|\n         with_envp(env) { |envp|\n@@ -79,8 +79,8 @@ fn spawn_process(prog: str, args: [str],\n \n fn with_argv<T>(prog: str, args: [str],\n                 cb: fn(*sbuf) -> T) -> T unsafe {\n-    let argptrs = str::as_buf(prog) {|b| [b] };\n-    let tmps = [];\n+    let mut argptrs = str::as_buf(prog) {|b| [b] };\n+    let mut tmps = [];\n     for arg in args {\n         let t = @arg;\n         tmps += [t];\n@@ -94,13 +94,13 @@ fn with_argv<T>(prog: str, args: [str],\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"freebsd\")]\n fn with_envp<T>(env: option<[(str,str)]>,\n-                cb: fn(*void) -> T) -> T unsafe {\n+                cb: fn(*c_void) -> T) -> T unsafe {\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n     alt env {\n       some (es) {\n-        let tmps = [];\n-        let ptrs = [];\n+        let mut tmps = [];\n+        let mut ptrs = [];\n \n         for (k,v) in es {\n             let t = @(#fmt(\"%s=%s\", k, v));\n@@ -118,16 +118,16 @@ fn with_envp<T>(env: option<[(str,str)]>,\n \n #[cfg(target_os = \"win32\")]\n fn with_envp<T>(env: option<[(str,str)]>,\n-                cb: fn(*void) -> T) -> T unsafe {\n+                cb: fn(*c_void) -> T) -> T unsafe {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n     alt env {\n       some (es) {\n-        let blk : [u8] = [];\n+        let mut blk : [u8] = [];\n         for (k,v) in es {\n             let t = #fmt(\"%s=%s\", k, v);\n-            let v : [u8] = ::unsafe::reinterpret_cast(t);\n+            let mut v : [u8] = ::unsafe::reinterpret_cast(t);\n             blk += v;\n             ::unsafe::leak(v);\n         }\n@@ -191,20 +191,20 @@ fn start_program(prog: str, args: [str]) -> program {\n                       pipe_err.out);\n \n     if pid == -1i32 { fail; }\n-    os::libc::close(pipe_input.in);\n-    os::libc::close(pipe_output.out);\n-    os::libc::close(pipe_err.out);\n+    libc::close(pipe_input.in);\n+    libc::close(pipe_output.out);\n+    libc::close(pipe_err.out);\n \n     type prog_repr = {pid: pid_t,\n-                      mutable in_fd: fd_t,\n-                      out_file: os::FILE,\n-                      err_file: os::FILE,\n+                      mutable in_fd: c_int,\n+                      out_file: *libc::FILE,\n+                      err_file: *libc::FILE,\n                       mutable finished: bool};\n \n     fn close_repr_input(r: prog_repr) {\n         let invalid_fd = -1i32;\n         if r.in_fd != invalid_fd {\n-            os::libc::close(r.in_fd);\n+            libc::close(r.in_fd);\n             r.in_fd = invalid_fd;\n         }\n     }\n@@ -216,8 +216,8 @@ fn start_program(prog: str, args: [str]) -> program {\n     }\n     fn destroy_repr(r: prog_repr) {\n         finish_repr(r);\n-        os::libc::fclose(r.out_file);\n-        os::libc::fclose(r.err_file);\n+       libc::fclose(r.out_file);\n+       libc::fclose(r.err_file);\n     }\n     resource prog_res(r: prog_repr) { destroy_repr(r); }\n \n@@ -232,14 +232,14 @@ fn start_program(prog: str, args: [str]) -> program {\n     }\n     let repr = {pid: pid,\n                 mutable in_fd: pipe_input.out,\n-                out_file: os::fd_FILE(pipe_output.in),\n-                err_file: os::fd_FILE(pipe_err.in),\n+                out_file: os::fdopen(pipe_output.in),\n+                err_file: os::fdopen(pipe_err.in),\n                 mutable finished: false};\n     ret prog_res(repr) as program;\n }\n \n fn read_all(rd: io::reader) -> str {\n-    let buf = \"\";\n+    let mut buf = \"\";\n     while !rd.eof() {\n         let bytes = rd.read_bytes(4096u);\n         buf += str::from_bytes(bytes);\n@@ -318,7 +318,6 @@ fn waitpid(pid: pid_t) -> int {\n mod tests {\n \n     import io::writer_util;\n-    import ctypes::fd_t;\n \n     // Regression test for memory leaks\n     #[ignore(cfg(target_os = \"win32\"))] // FIXME\n@@ -353,17 +352,17 @@ mod tests {\n         log(debug, actual);\n         assert (expected == actual);\n \n-        fn writeclose(fd: fd_t, s: str) {\n+        fn writeclose(fd: c_int, s: str) {\n             #error(\"writeclose %d, %s\", fd as int, s);\n             let writer = io::fd_writer(fd, false);\n             writer.write_str(s);\n \n             os::close(fd);\n         }\n \n-        fn readclose(fd: fd_t) -> str {\n+        fn readclose(fd: c_int) -> str {\n             // Copied from run::program_output\n-            let file = os::fd_FILE(fd);\n+            let file = os::fdopen(fd);\n             let reader = io::FILE_reader(file, false);\n             let buf = \"\";\n             while !reader.eof() {", "previous_filename": "src/libstd/run_program.rs"}, {"sha": "b057d8d14831c26bb19700d26beb884c6020f077", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -99,7 +99,7 @@ export\n #[abi = \"cdecl\"]\n native mod rustrt {\n     fn rust_str_push(&s: str, ch: u8);\n-    fn str_reserve_shared(&ss: str, nn: ctypes::size_t);\n+    fn str_reserve_shared(&ss: str, nn: libc::size_t);\n }\n \n // FIXME: add pure to a lot of functions"}, {"sha": "b402f98ed26eda02c2e2e04d0d19deec0e739cfc", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -10,9 +10,9 @@ export log_str;\n export set_exit_status;\n \n enum type_desc = {\n-    first_param: **ctypes::c_int,\n-    size: ctypes::size_t,\n-    align: ctypes::size_t\n+    first_param: **libc::c_int,\n+    size: libc::size_t,\n+    align: libc::size_t\n     // Remaining fields not listed\n };\n \n@@ -22,10 +22,10 @@ native mod rustrt {\n     // available outside this crate. Otherwise it's\n     // visible-in-crate, but not re-exported.\n     fn last_os_error() -> str;\n-    fn refcount<T>(t: @T) -> ctypes::intptr_t;\n+    fn refcount<T>(t: @T) -> libc::intptr_t;\n     fn unsupervise();\n     fn shape_log_str<T>(t: *sys::type_desc, data: T) -> str;\n-    fn rust_set_exit_status(code: ctypes::intptr_t);\n+    fn rust_set_exit_status(code: libc::intptr_t);\n }\n \n #[abi = \"rust-intrinsic\"]\n@@ -34,7 +34,7 @@ native mod rusti {\n \n     // Invokes __builtin_frame_address().\n     // See <http://gcc.gnu.org/onlinedocs/gcc/Return-Address.html>.\n-    fn frame_address(n: ctypes::c_uint) -> ctypes::uintptr_t;\n+    fn frame_address(n: libc::c_uint) -> libc::uintptr_t;\n }\n \n #[doc = \"\n@@ -64,7 +64,7 @@ fn align_of<T>() -> uint unsafe {\n \n #[doc = \"Returns the refcount of a shared box\"]\n fn refcount<T>(t: @T) -> uint {\n-    ret rustrt::refcount::<T>(t);\n+    ret rustrt::refcount::<T>(t) as uint;\n }\n \n fn log_str<T>(t: T) -> str {\n@@ -80,7 +80,7 @@ supervised by the scheduler then any user-specified exit status is ignored and\n the process exits with the default failure status\n \"]\n fn set_exit_status(code: int) {\n-    rustrt::rust_set_exit_status(code as ctypes::intptr_t);\n+    rustrt::rust_set_exit_status(code as libc::intptr_t);\n }\n \n #[cfg(test)]"}, {"sha": "580636043edb2a77e71e28bca3df59d8f312a56a", "filename": "src/libcore/task.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -465,8 +465,8 @@ type task_id = int;\n \n // These are both opaque runtime/compiler types that we don't know the\n // structure of and should only deal with via unsafe pointer\n-type rust_task = ctypes::void;\n-type rust_closure = ctypes::void;\n+type rust_task = libc::c_void;\n+type rust_closure = libc::c_void;\n \n fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n \n@@ -537,7 +537,7 @@ native mod rusti {\n \n native mod rustrt {\n     fn rust_get_sched_id() -> sched_id;\n-    fn rust_new_sched(num_threads: ctypes::uintptr_t) -> sched_id;\n+    fn rust_new_sched(num_threads: libc::uintptr_t) -> sched_id;\n \n     fn get_task_id() -> task_id;\n     fn rust_get_task() -> *rust_task;\n@@ -749,12 +749,12 @@ fn test_spawn_sched_childs_on_same_sched() {\n #[nolink]\n #[cfg(test)]\n native mod testrt {\n-    fn rust_dbg_lock_create() -> *ctypes::void;\n-    fn rust_dbg_lock_destroy(lock: *ctypes::void);\n-    fn rust_dbg_lock_lock(lock: *ctypes::void);\n-    fn rust_dbg_lock_unlock(lock: *ctypes::void);\n-    fn rust_dbg_lock_wait(lock: *ctypes::void);\n-    fn rust_dbg_lock_signal(lock: *ctypes::void);\n+    fn rust_dbg_lock_create() -> *libc::c_void;\n+    fn rust_dbg_lock_destroy(lock: *libc::c_void);\n+    fn rust_dbg_lock_lock(lock: *libc::c_void);\n+    fn rust_dbg_lock_unlock(lock: *libc::c_void);\n+    fn rust_dbg_lock_wait(lock: *libc::c_void);\n+    fn rust_dbg_lock_signal(lock: *libc::c_void);\n }\n \n #[test]"}, {"sha": "cf2d208955b999097bfdb5a1fc517f8cdf9bf1b4", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -73,17 +73,17 @@ export u8;\n \n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n-    fn vec_len<T>(&&v: [const T]) -> ctypes::size_t;\n+    fn vec_len<T>(&&v: [const T]) -> libc::size_t;\n }\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n     fn vec_reserve_shared<T>(t: *sys::type_desc,\n                              &v: [const T],\n-                             n: ctypes::size_t);\n+                             n: libc::size_t);\n     fn vec_from_buf_shared<T>(t: *sys::type_desc,\n                               ptr: *T,\n-                              count: ctypes::size_t) -> [T];\n+                              count: libc::size_t) -> [T];\n }\n \n #[doc = \"A function used to initialize the elements of a vector\"]\n@@ -912,7 +912,7 @@ mod u8 {\n     pure fn cmp(&&a: [u8], &&b: [u8]) -> int unsafe {\n         let a_len = len(a);\n         let b_len = len(b);\n-        let n = uint::min(a_len, b_len) as ctypes::size_t;\n+        let n = uint::min(a_len, b_len) as libc::size_t;\n         let r = libc::memcmp(unsafe::to_ptr(a) as *libc::c_void,\n                              unsafe::to_ptr(b) as *libc::c_void, n) as int;\n "}, {"sha": "9923372536294e7230e16d2d5ffeae5bf99c8820", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -126,21 +126,15 @@ unsafe fn ptr<T>(t: t<T>) -> *mutable T {\n \n #[cfg(test)]\n mod tests {\n-    import ctypes::*;\n-\n-    #[nolink]\n-    #[abi = \"cdecl\"]\n-    native mod libc {\n-        fn malloc(n: size_t) -> *mutable u8;\n-        fn free(m: *mutable u8);\n-    }\n+    import libc::*;\n \n     fn malloc(n: size_t) -> t<u8> {\n         let mem = libc::malloc(n);\n \n         assert mem as int != 0;\n \n-        ret unsafe { create_with_dtor(mem, n, bind libc::free(mem)) };\n+        ret unsafe { create_with_dtor(mem as *mutable u8, n,\n+                                      bind free(mem)) };\n     }\n \n     #[test]"}, {"sha": "6fbe0b00fde5c0899bdd6446508d501fcadfa031", "filename": "src/libstd/freebsd_os.rs", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Ffreebsd_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Ffreebsd_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffreebsd_os.rs?ref=ac57bb38560fa35d883505af2e8e68498b436fe7", "patch": "@@ -1,160 +0,0 @@\n-/*\n-Module: os\n-\n-TODO: Restructure and document\n-*/\n-\n-import core::option;\n-import core::ctypes::*;\n-\n-export libc;\n-export libc_constants;\n-export pipe;\n-export FILE, fd_FILE;\n-export close;\n-export fclose;\n-export waitpid;\n-export getcwd;\n-export exec_suffix;\n-export target_os;\n-export dylib_filename;\n-export get_exe_path;\n-export fsync_fd;\n-export rustrt;\n-\n-// FIXME Somehow merge stuff duplicated here and macosx_os.rs. Made difficult\n-// by https://github.com/graydon/rust/issues#issue/268\n-\n-enum FILE_opaque {}\n-type FILE = *FILE_opaque;\n-enum dir {}\n-enum dirent {}\n-\n-#[nolink]\n-#[abi = \"cdecl\"]\n-native mod libc {\n-    fn read(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n-    fn write(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n-    fn fread(buf: *u8, size: size_t, n: size_t, f: FILE) -> size_t;\n-    fn fwrite(buf: *u8, size: size_t, n: size_t, f: FILE) -> size_t;\n-    fn open(s: str::sbuf, flags: c_int, mode: unsigned) -> fd_t;\n-    fn close(fd: fd_t) -> c_int;\n-    fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n-    fn fdopen(fd: fd_t, mode: str::sbuf) -> FILE;\n-    fn fclose(f: FILE);\n-    fn fflush(f: FILE) -> c_int;\n-    fn fsync(fd: fd_t) -> c_int;\n-    fn fileno(f: FILE) -> fd_t;\n-    fn fgetc(f: FILE) -> c_int;\n-    fn ungetc(c: c_int, f: FILE);\n-    fn feof(f: FILE) -> c_int;\n-    fn fseek(f: FILE, offset: long, whence: c_int) -> c_int;\n-    fn ftell(f: FILE) -> long;\n-    fn opendir(d: str::sbuf) -> *dir;\n-    fn closedir(d: *dir) -> c_int;\n-    fn readdir(d: *dir) -> *dirent;\n-    fn getenv(n: str::sbuf) -> str::sbuf;\n-    fn setenv(n: str::sbuf, v: str::sbuf, overwrite: c_int) -> c_int;\n-    fn unsetenv(n: str::sbuf) -> c_int;\n-    fn pipe(buf: *mutable fd_t) -> c_int;\n-    fn waitpid(pid: pid_t, &status: c_int, options: c_int) -> pid_t;\n-    fn readlink(path: str::sbuf, buf: str::sbuf, bufsize: size_t) -> ssize_t;\n-    fn mkdir(path: str::sbuf, mode: c_int) -> c_int;\n-    fn rmdir(path: str::sbuf) -> c_int;\n-    fn chdir(path: str::sbuf) -> c_int;\n-    fn unlink(path: str::sbuf) -> c_int;\n-\n-    fn sysctl(name: *c_int, namelen: c_uint,\n-              oldp: *u8, &oldlenp: size_t,\n-              newp: *u8, newlen: size_t) -> c_int;\n-}\n-\n-mod libc_constants {\n-    const O_RDONLY: c_int = 0i32;\n-    const O_WRONLY: c_int = 1i32;\n-    const O_RDWR: c_int   = 2i32;\n-    const O_APPEND: c_int = 8i32;\n-    const O_CREAT: c_int  = 512i32;\n-    const O_EXCL: c_int   = 2048i32;\n-    const O_TRUNC: c_int  = 1024i32;\n-    const O_TEXT: c_int   = 0i32;     // nonexistent in FreeBSD libc\n-    const O_BINARY: c_int = 0i32;     // nonexistent in FreeBSD libc\n-\n-    const S_IRUSR: unsigned = 256u32;\n-    const S_IWUSR: unsigned = 128u32;\n-\n-    const CTL_KERN: c_int = 1i32;\n-    const KERN_PROC: c_int = 14i32;\n-    const KERN_PROC_PATHNAME: c_int = 12i32;\n-}\n-\n-fn pipe() -> {in: fd_t, out: fd_t} {\n-    let fds = {mutable in: 0i32, mutable out: 0i32};\n-    assert (os::libc::pipe(ptr::mut_addr_of(fds.in)) == 0i32);\n-    ret {in: fds.in, out: fds.out};\n-}\n-\n-fn fd_FILE(fd: fd_t) -> FILE {\n-    ret str::as_buf(\"r\", {|modebuf| libc::fdopen(fd, modebuf) });\n-}\n-\n-fn close(fd: fd_t) -> c_int {\n-    libc::close(fd)\n-}\n-\n-fn fclose(file: FILE) {\n-    libc::fclose(file)\n-}\n-\n-fn fsync_fd(fd: fd_t, _l: io::fsync::level) -> c_int {\n-    ret libc::fsync(fd);\n-}\n-\n-fn waitpid(pid: pid_t) -> i32 {\n-    let status = 0i32;\n-    assert (os::libc::waitpid(pid, status, 0i32) != -1i32);\n-    ret status;\n-}\n-\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn rust_env_pairs() -> [str];\n-    fn rust_getcwd() -> str;\n-}\n-\n-fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n-\n-fn exec_suffix() -> str { ret \"\"; }\n-\n-fn target_os() -> str { ret \"freebsd\"; }\n-\n-fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n-\n-/// Returns the directory containing the running program\n-/// followed by a path separator\n-fn get_exe_path() -> option<fs::path> unsafe {\n-    let bufsize = 1023u;\n-    // FIXME: path \"strings\" will likely need fixing...\n-    let path = str::from_bytes(vec::init_elt(bufsize, 0u8));\n-    let mib = [libc_constants::CTL_KERN,\n-               libc_constants::KERN_PROC,\n-               libc_constants::KERN_PROC_PATHNAME, -1i32];\n-    ret str::as_buf(path, { |path_buf|\n-        if libc::sysctl(vec::unsafe::to_ptr(mib),\n-                        vec::len(mib) as c_uint,\n-                        path_buf, bufsize,\n-                        ptr::null(), 0u) == 0i32 {\n-            option::some(fs::dirname(path) + fs::path_sep())\n-        } else {\n-            option::none\n-        }\n-    });\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "8a5b88f7480f36fd577cf00faea97d2757a9648f", "filename": "src/libstd/fs.rs", "status": "removed", "additions": 0, "deletions": 765, "changes": 765, "blob_url": "https://github.com/rust-lang/rust/blob/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=ac57bb38560fa35d883505af2e8e68498b436fe7", "patch": "@@ -1,765 +0,0 @@\n-/*\n-Module: fs\n-\n-File system manipulation\n-*/\n-\n-import core::ctypes;\n-import core::vec;\n-import core::option;\n-import os;\n-import os::getcwd;\n-import os_fs;\n-\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn rust_path_is_dir(path: str::sbuf) -> ctypes::c_int;\n-    fn rust_path_exists(path: str::sbuf) -> ctypes::c_int;\n-}\n-\n-/*\n-Function: path_sep\n-\n-Get the default path separator for the host platform\n-*/\n-fn path_sep() -> str { ret str::from_char(os_fs::path_sep); }\n-\n-// FIXME: This type should probably be constrained\n-/*\n-Type: path\n-\n-A path or fragment of a filesystem path\n-*/\n-type path = str;\n-\n-fn split_dirname_basename (pp: path) -> {dirname: str, basename: str} {\n-    alt str::rfind(pp, {|ch|\n-        ch == os_fs::path_sep || ch == os_fs::alt_path_sep\n-    }) {\n-      some(i) {\n-        {dirname: str::slice(pp, 0u, i),\n-         basename: str::slice(pp, i + 1u, str::len(pp))}\n-      }\n-      none { {dirname: \".\", basename: pp} }\n-    }\n-}\n-\n-/*\n-Function: dirname\n-\n-Get the directory portion of a path\n-\n-Returns all of the path up to, but excluding, the final path separator.\n-The dirname of \"/usr/share\" will be \"/usr\", but the dirname of\n-\"/usr/share/\" is \"/usr/share\".\n-\n-If the path is not prefixed with a directory, then \".\" is returned.\n-*/\n-fn dirname(pp: path) -> path {\n-    ret split_dirname_basename(pp).dirname;\n-}\n-\n-/*\n-Function: basename\n-\n-Get the file name portion of a path\n-\n-Returns the portion of the path after the final path separator.\n-The basename of \"/usr/share\" will be \"share\". If there are no\n-path separators in the path then the returned path is identical to\n-the provided path. If an empty path is provided or the path ends\n-with a path separator then an empty path is returned.\n-*/\n-fn basename(pp: path) -> path {\n-    ret split_dirname_basename(pp).basename;\n-}\n-\n-// FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n-/*\n-Function: connect\n-\n-Connects to path segments\n-\n-Given paths `pre` and `post, removes any trailing path separator on `pre` and\n-any leading path separator on `post`, and returns the concatenation of the two\n-with a single path separator between them.\n-*/\n-\n-fn connect(pre: path, post: path) -> path unsafe {\n-    let pre_ = pre;\n-    let post_ = post;\n-    let sep = os_fs::path_sep as u8;\n-    let pre_len  = str::len(pre);\n-    let post_len = str::len(post);\n-    if pre_len > 1u && pre[pre_len-1u] == sep { str::unsafe::pop_byte(pre_); }\n-    if post_len > 1u && post[0] == sep { str::unsafe::shift_byte(post_); }\n-    ret pre_ + path_sep() + post_;\n-}\n-\n-/*\n-Function: connect_many\n-\n-Connects a vector of path segments into a single path.\n-\n-Inserts path separators as needed.\n-*/\n-fn connect_many(paths: [path]) -> path {\n-    ret if vec::len(paths) == 1u {\n-        paths[0]\n-    } else {\n-        let rest = vec::slice(paths, 1u, vec::len(paths));\n-        connect(paths[0], connect_many(rest))\n-    }\n-}\n-\n-/*\n-Function: path_is_dir\n-\n-Indicates whether a path represents a directory.\n-*/\n-fn path_is_dir(p: path) -> bool {\n-    ret str::as_buf(p, {|buf|\n-        rustrt::rust_path_is_dir(buf) != 0 as ctypes::c_int\n-    });\n-}\n-\n-/*\n-Function: path_exists\n-\n-Indicates whether a path exists.\n-*/\n-fn path_exists(p: path) -> bool {\n-    ret str::as_buf(p, {|buf|\n-        rustrt::rust_path_exists(buf) != 0 as ctypes::c_int\n-    });\n-}\n-\n-/*\n-Function: make_dir\n-\n-Creates a directory at the specified path.\n-*/\n-fn make_dir(p: path, mode: ctypes::c_int) -> bool {\n-    ret mkdir(p, mode);\n-\n-    #[cfg(target_os = \"win32\")]\n-    fn mkdir(_p: path, _mode: ctypes::c_int) -> bool unsafe {\n-        // FIXME: turn mode into something useful?\n-        ret str::as_buf(_p, {|buf|\n-            os::kernel32::CreateDirectoryA(\n-                buf, unsafe::reinterpret_cast(0))\n-        });\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"macos\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    fn mkdir(_p: path, _mode: ctypes::c_int) -> bool {\n-        ret str::as_buf(_p, {|buf| os::libc::mkdir(buf, _mode) == 0i32 });\n-    }\n-}\n-\n-/*\n-Function: list_dir\n-\n-Lists the contents of a directory.\n-*/\n-fn list_dir(p: path) -> [str] {\n-    let p = p;\n-    let pl = str::len(p);\n-    if pl == 0u || p[pl - 1u] as char != os_fs::path_sep { p += path_sep(); }\n-    let full_paths: [str] = [];\n-    for filename: str in os_fs::list_dir(p) {\n-        if !str::eq(filename, \".\") {\n-            if !str::eq(filename, \"..\") { full_paths += [p + filename]; }\n-        }\n-    }\n-    ret full_paths;\n-}\n-\n-/*\n-Function: remove_dir\n-\n-Removes a directory at the specified path.\n-*/\n-fn remove_dir(p: path) -> bool {\n-   ret rmdir(p);\n-\n-    #[cfg(target_os = \"win32\")]\n-    fn rmdir(_p: path) -> bool {\n-        ret str::as_buf(_p, {|buf| os::kernel32::RemoveDirectoryA(buf)});\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"macos\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    fn rmdir(_p: path) -> bool {\n-        ret str::as_buf(_p, {|buf| os::libc::rmdir(buf) == 0i32 });\n-    }\n-}\n-\n-fn change_dir(p: path) -> bool {\n-    ret chdir(p);\n-\n-    #[cfg(target_os = \"win32\")]\n-    fn chdir(_p: path) -> bool {\n-        ret str::as_buf(_p, {|buf| os::kernel32::SetCurrentDirectoryA(buf)});\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"macos\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    fn chdir(_p: path) -> bool {\n-        ret str::as_buf(_p, {|buf| os::libc::chdir(buf) == 0i32 });\n-    }\n-}\n-\n-/*\n-Function: path_is_absolute\n-\n-Indicates whether a path is absolute.\n-\n-A path is considered absolute if it begins at the filesystem root (\"/\") or,\n-on Windows, begins with a drive letter.\n-*/\n-fn path_is_absolute(p: path) -> bool { ret os_fs::path_is_absolute(p); }\n-\n-// FIXME: under Windows, we should prepend the current drive letter to paths\n-// that start with a slash.\n-/*\n-Function: make_absolute\n-\n-Convert a relative path to an absolute path\n-\n-If the given path is relative, return it prepended with the current working\n-directory. If the given path is already an absolute path, return it\n-as is.\n-*/\n-fn make_absolute(p: path) -> path {\n-    if path_is_absolute(p) { ret p; } else { ret connect(getcwd(), p); }\n-}\n-\n-/*\n-Function: split\n-\n-Split a path into it's individual components\n-\n-Splits a given path by path separators and returns a vector containing\n-each piece of the path. On Windows, if the path is absolute then\n-the first element of the returned vector will be the drive letter\n-followed by a colon.\n-*/\n-fn split(p: path) -> [path] {\n-    str::split_nonempty(p, {|c|\n-        c == os_fs::path_sep || c == os_fs::alt_path_sep\n-    })\n-}\n-\n-/*\n-Function: splitext\n-\n-Split a path into a pair of strings with the first element being the filename\n-without the extension and the second being either empty or the file extension\n-including the period. Leading periods in the basename are ignored.  If the\n-path includes directory components then they are included in the filename part\n-of the result pair.\n-*/\n-fn splitext(p: path) -> (str, str) {\n-    if str::is_empty(p) { (\"\", \"\") }\n-    else {\n-        let parts = str::split_char(p, '.');\n-        if vec::len(parts) > 1u {\n-            let base = str::connect(vec::init(parts), \".\");\n-            // We just checked that parts is non-empty\n-            let ext = \".\" + vec::last(parts);\n-\n-            fn is_dotfile(base: str) -> bool {\n-                str::is_empty(base)\n-                    || str::ends_with(\n-                        base, str::from_char(os_fs::path_sep))\n-                    || str::ends_with(\n-                        base, str::from_char(os_fs::alt_path_sep))\n-            }\n-\n-            fn ext_contains_sep(ext: str) -> bool {\n-                vec::len(split(ext)) > 1u\n-            }\n-\n-            fn no_basename(ext: str) -> bool {\n-                str::ends_with(\n-                    ext, str::from_char(os_fs::path_sep))\n-                    || str::ends_with(\n-                        ext, str::from_char(os_fs::alt_path_sep))\n-            }\n-\n-            if is_dotfile(base)\n-                || ext_contains_sep(ext)\n-                || no_basename(ext) {\n-                (p, \"\")\n-            } else {\n-                (base, ext)\n-            }\n-        } else {\n-            (p, \"\")\n-        }\n-    }\n-}\n-\n-/*\n-Function: normalize\n-\n-Removes extra \".\" and \"..\" entries from paths.\n-\n-Does not follow symbolic links.\n-*/\n-fn normalize(p: path) -> path {\n-    let s = split(p);\n-    let s = strip_dots(s);\n-    let s = rollup_doubledots(s);\n-\n-    let s = if check vec::is_not_empty(s) {\n-        connect_many(s)\n-    } else {\n-        \"\"\n-    };\n-    let s = reabsolute(p, s);\n-    let s = reterminate(p, s);\n-\n-    let s = if str::len(s) == 0u {\n-        \".\"\n-    } else {\n-        s\n-    };\n-\n-    ret s;\n-\n-    fn strip_dots(s: [path]) -> [path] {\n-        vec::filter_map(s, { |elem|\n-            if elem == \".\" {\n-                option::none\n-            } else {\n-                option::some(elem)\n-            }\n-        })\n-    }\n-\n-    fn rollup_doubledots(s: [path]) -> [path] {\n-        if vec::is_empty(s) {\n-            ret [];\n-        }\n-\n-        let t = [];\n-        let i = vec::len(s);\n-        let skip = 0;\n-        do {\n-            i -= 1u;\n-            if s[i] == \"..\" {\n-                skip += 1;\n-            } else {\n-                if skip == 0 {\n-                    t += [s[i]];\n-                } else {\n-                    skip -= 1;\n-                }\n-            }\n-        } while i != 0u;\n-        let t = vec::reversed(t);\n-        while skip > 0 {\n-            t += [\"..\"];\n-            skip -= 1;\n-        }\n-        ret t;\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"macos\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    fn reabsolute(orig: path, new: path) -> path {\n-        if path_is_absolute(orig) {\n-            path_sep() + new\n-        } else {\n-            new\n-        }\n-    }\n-\n-    #[cfg(target_os = \"win32\")]\n-    fn reabsolute(orig: path, new: path) -> path {\n-       if path_is_absolute(orig) && orig[0] == os_fs::path_sep as u8 {\n-           str::from_char(os_fs::path_sep) + new\n-       } else {\n-           new\n-       }\n-    }\n-\n-    fn reterminate(orig: path, new: path) -> path {\n-        let last = orig[str::len(orig) - 1u];\n-        if last == os_fs::path_sep as u8\n-            || last == os_fs::path_sep as u8 {\n-            ret new + path_sep();\n-        } else {\n-            ret new;\n-        }\n-    }\n-}\n-\n-/*\n-Function: homedir\n-\n-Returns the path to the user's home directory, if known.\n-\n-On Unix, returns the value of the \"HOME\" environment variable if it is set and\n-not equal to the empty string.\n-\n-On Windows, returns the value of the \"HOME\" environment variable if it is set\n-and not equal to the empty string. Otherwise, returns the value of the\n-\"USERPROFILE\" environment variable if it is set and not equal to the empty\n-string.\n-\n-Otherwise, homedir returns option::none.\n-*/\n-fn homedir() -> option<path> {\n-    ret alt generic_os::getenv(\"HOME\") {\n-        some(p) {\n-            if !str::is_empty(p) {\n-                some(p)\n-            } else {\n-                secondary()\n-            }\n-        }\n-        none {\n-            secondary()\n-        }\n-    };\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"macos\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    fn secondary() -> option<path> {\n-        none\n-    }\n-\n-    #[cfg(target_os = \"win32\")]\n-    fn secondary() -> option<path> {\n-        option::maybe(none, generic_os::getenv(\"USERPROFILE\")) {|p|\n-            if !str::is_empty(p) {\n-                some(p)\n-            } else {\n-                none\n-            }\n-        }\n-    }\n-}\n-\n-/*\n-Function: remove_file\n-\n-Deletes an existing file.\n-*/\n-fn remove_file(p: path) -> bool {\n-    ret unlink(p);\n-\n-    #[cfg(target_os = \"win32\")]\n-    fn unlink(p: path) -> bool {\n-        ret str::as_buf(p, {|buf| os::kernel32::DeleteFileA(buf)});\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"macos\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    fn unlink(_p: path) -> bool {\n-        ret str::as_buf(_p, {|buf| os::libc::unlink(buf) == 0i32 });\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    #[test]\n-    fn test_connect() {\n-        let slash = fs::path_sep();\n-        log(error, fs::connect(\"a\", \"b\"));\n-        assert (fs::connect(\"a\", \"b\") == \"a\" + slash + \"b\");\n-        assert (fs::connect(\"a\" + slash, \"b\") == \"a\" + slash + \"b\");\n-    }\n-\n-    // Issue #712\n-    #[test]\n-    fn test_list_dir_no_invalid_memory_access() { fs::list_dir(\".\"); }\n-\n-    #[test]\n-    fn list_dir() {\n-        let dirs = fs::list_dir(\".\");\n-        // Just assuming that we've got some contents in the current directory\n-        assert (vec::len(dirs) > 0u);\n-\n-        for dir in dirs { log(debug, dir); }\n-    }\n-\n-    #[test]\n-    fn path_is_dir() {\n-        assert (fs::path_is_dir(\".\"));\n-        assert (!fs::path_is_dir(\"test/stdtest/fs.rs\"));\n-    }\n-\n-    #[test]\n-    fn path_exists() {\n-        assert (fs::path_exists(\".\"));\n-        assert (!fs::path_exists(\"test/nonexistent-bogus-path\"));\n-    }\n-\n-    fn ps() -> str {\n-        fs::path_sep()\n-    }\n-\n-    fn aps() -> str {\n-        \"/\"\n-    }\n-\n-    #[test]\n-    fn split1() {\n-        let actual = fs::split(\"a\" + ps() + \"b\");\n-        let expected = [\"a\", \"b\"];\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn split2() {\n-        let actual = fs::split(\"a\" + aps() + \"b\");\n-        let expected = [\"a\", \"b\"];\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn split3() {\n-        let actual = fs::split(ps() + \"a\" + ps() + \"b\");\n-        let expected = [\"a\", \"b\"];\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn split4() {\n-        let actual = fs::split(\"a\" + ps() + \"b\" + aps() + \"c\");\n-        let expected = [\"a\", \"b\", \"c\"];\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn normalize1() {\n-        let actual = fs::normalize(\"a/b/..\");\n-        let expected = \"a\";\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn normalize2() {\n-        let actual = fs::normalize(\"/a/b/..\");\n-        let expected = \"/a\";\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn normalize3() {\n-        let actual = fs::normalize(\"a/../b\");\n-        let expected = \"b\";\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn normalize4() {\n-        let actual = fs::normalize(\"/a/../b\");\n-        let expected = \"/b\";\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn normalize5() {\n-        let actual = fs::normalize(\"a/.\");\n-        let expected = \"a\";\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn normalize6() {\n-        let actual = fs::normalize(\"a/./b/\");\n-        let expected = \"a/b/\";\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn normalize7() {\n-        let actual = fs::normalize(\"a/..\");\n-        let expected = \".\";\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn normalize8() {\n-        let actual = fs::normalize(\"../../..\");\n-        let expected = \"../../..\";\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn normalize9() {\n-        let actual = fs::normalize(\"a/b/../../..\");\n-        let expected = \"..\";\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn normalize10() {\n-        let actual = fs::normalize(\"/a/b/c/../d/./../../e/\");\n-        let expected = \"/a/e/\";\n-        log(error, actual);\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    fn normalize11() {\n-        let actual = fs::normalize(\"/a/..\");\n-        let expected = \"/\";\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    #[cfg(target_os = \"win32\")]\n-    fn normalize12() {\n-        let actual = fs::normalize(\"C:/whatever\");\n-        let expected = \"C:/whatever\";\n-        log(error, actual);\n-        assert actual == expected;\n-    }\n-\n-    #[test]\n-    #[cfg(target_os = \"win32\")]\n-    fn path_is_absolute_win32() {\n-        assert fs::path_is_absolute(\"C:/whatever\");\n-    }\n-\n-    #[test]\n-    fn splitext_empty() {\n-        let (base, ext) = fs::splitext(\"\");\n-        assert base == \"\";\n-        assert ext == \"\";\n-    }\n-\n-    #[test]\n-    fn splitext_ext() {\n-        let (base, ext) = fs::splitext(\"grum.exe\");\n-        assert base == \"grum\";\n-        assert ext == \".exe\";\n-    }\n-\n-    #[test]\n-    fn splitext_noext() {\n-        let (base, ext) = fs::splitext(\"grum\");\n-        assert base == \"grum\";\n-        assert ext == \"\";\n-    }\n-\n-    #[test]\n-    fn splitext_dotfile() {\n-        let (base, ext) = fs::splitext(\".grum\");\n-        assert base == \".grum\";\n-        assert ext == \"\";\n-    }\n-\n-    #[test]\n-    fn splitext_path_ext() {\n-        let (base, ext) = fs::splitext(\"oh/grum.exe\");\n-        assert base == \"oh/grum\";\n-        assert ext == \".exe\";\n-    }\n-\n-    #[test]\n-    fn splitext_path_noext() {\n-        let (base, ext) = fs::splitext(\"oh/grum\");\n-        assert base == \"oh/grum\";\n-        assert ext == \"\";\n-    }\n-\n-    #[test]\n-    fn splitext_dot_in_path() {\n-        let (base, ext) = fs::splitext(\"oh.my/grum\");\n-        assert base == \"oh.my/grum\";\n-        assert ext == \"\";\n-    }\n-\n-    #[test]\n-    fn splitext_nobasename() {\n-        let (base, ext) = fs::splitext(\"oh.my/\");\n-        assert base == \"oh.my/\";\n-        assert ext == \"\";\n-    }\n-\n-    #[test]\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"macos\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    fn homedir() {\n-        import getenv = generic_os::getenv;\n-        import setenv = generic_os::setenv;\n-\n-        let oldhome = getenv(\"HOME\");\n-\n-        setenv(\"HOME\", \"/home/MountainView\");\n-        assert fs::homedir() == some(\"/home/MountainView\");\n-\n-        setenv(\"HOME\", \"\");\n-        assert fs::homedir() == none;\n-\n-        option::may(oldhome, {|s| setenv(\"HOME\", s)});\n-    }\n-\n-    #[test]\n-    #[cfg(target_os = \"win32\")]\n-    fn homedir() {\n-        import getenv = generic_os::getenv;\n-        import setenv = generic_os::setenv;\n-\n-        let oldhome = getenv(\"HOME\");\n-        let olduserprofile = getenv(\"USERPROFILE\");\n-\n-        setenv(\"HOME\", \"\");\n-        setenv(\"USERPROFILE\", \"\");\n-\n-        assert fs::homedir() == none;\n-\n-        setenv(\"HOME\", \"/home/MountainView\");\n-        assert fs::homedir() == some(\"/home/MountainView\");\n-\n-        setenv(\"HOME\", \"\");\n-\n-        setenv(\"USERPROFILE\", \"/home/MountainView\");\n-        assert fs::homedir() == some(\"/home/MountainView\");\n-\n-        setenv(\"USERPROFILE\", \"/home/MountainView\");\n-        assert fs::homedir() == some(\"/home/MountainView\");\n-\n-        setenv(\"HOME\", \"/home/MountainView\");\n-        setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n-        assert fs::homedir() == some(\"/home/MountainView\");\n-\n-        option::may(oldhome, {|s| setenv(\"HOME\", s)});\n-        option::may(olduserprofile, {|s| setenv(\"USERPROFILE\", s)});\n-    }\n-}\n-\n-\n-#[test]\n-fn test() {\n-    assert (!fs::path_is_absolute(\"test-path\"));\n-\n-    log(debug, \"Current working directory: \" + os::getcwd());\n-\n-    log(debug, fs::make_absolute(\"test-path\"));\n-    log(debug, fs::make_absolute(\"/usr/bin\"));\n-}\n-\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "77542cd11f871bda431666b09d34a9045fe55372", "filename": "src/libstd/generic_os.rs", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgeneric_os.rs?ref=ac57bb38560fa35d883505af2e8e68498b436fe7", "patch": "@@ -1,190 +0,0 @@\n-/*\n-Module: generic_os\n-\n-Some miscellaneous platform functions.\n-\n-These should be rolled into another module.\n-*/\n-\n-import core::option;\n-\n-// Wow, this is an ugly way to write doc comments\n-\n-#[cfg(bogus)]\n-#[doc = \"Get the value of an environment variable\"]\n-fn getenv(n: str) -> option<str> { }\n-\n-#[cfg(bogus)]\n-#[doc = \"Set the value of an environment variable\"]\n-fn setenv(n: str, v: str) { }\n-\n-fn env() -> [(str,str)] {\n-    let pairs = [];\n-    for p in os::rustrt::rust_env_pairs() {\n-        let vs = str::splitn_char(p, '=', 1u);\n-        assert vec::len(vs) == 2u;\n-        pairs += [(vs[0], vs[1])];\n-    }\n-    ret pairs;\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-fn getenv(n: str) -> option<str> unsafe {\n-    let s = str::as_buf(n, {|buf| os::libc::getenv(buf) });\n-    ret if unsafe::reinterpret_cast(s) == 0 {\n-            option::none::<str>\n-        } else {\n-            let s = unsafe::reinterpret_cast(s);\n-            option::some::<str>(str::from_cstr(s))\n-        };\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-fn setenv(n: str, v: str) {\n-    // FIXME (868)\n-    str::as_buf(\n-        n,\n-        // FIXME (868)\n-        {|nbuf|\n-            str::as_buf(\n-                v,\n-                {|vbuf|\n-                    os::libc::setenv(nbuf, vbuf, 1i32)})});\n-}\n-\n-#[cfg(target_os = \"win32\")]\n-fn getenv(n: str) -> option<str> {\n-    let nsize = 256u;\n-    loop {\n-        let v: [u8] = [];\n-        vec::reserve(v, nsize);\n-        let res =\n-            str::as_buf(n,\n-                        {|nbuf|\n-                            unsafe {\n-                            let vbuf = vec::unsafe::to_ptr(v);\n-                            os::kernel32::GetEnvironmentVariableA(nbuf, vbuf,\n-                                                                  nsize)\n-                        }\n-                        });\n-        if res == 0u {\n-            ret option::none;\n-        } else if res < nsize {\n-            unsafe {\n-                vec::unsafe::set_len(v, res);\n-            }\n-            ret option::some(str::from_bytes(v)); // UTF-8 or fail\n-        } else { nsize = res; }\n-    };\n-}\n-\n-#[cfg(target_os = \"win32\")]\n-fn setenv(n: str, v: str) {\n-    // FIXME (868)\n-    let _: () =\n-        str::as_buf(n, {|nbuf|\n-            let _: () =\n-                str::as_buf(v, {|vbuf|\n-                    os::kernel32::SetEnvironmentVariableA(nbuf, vbuf);\n-                });\n-        });\n-}\n-\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    fn make_rand_name() -> str {\n-        import rand;\n-        let rng: rand::rng = rand::mk_rng();\n-        let n = \"TEST\" + rng.gen_str(10u);\n-        assert option::is_none(getenv(n));\n-        n\n-    }\n-\n-    #[test]\n-    #[ignore(reason = \"fails periodically on mac\")]\n-    fn test_setenv() {\n-        let n = make_rand_name();\n-        setenv(n, \"VALUE\");\n-        assert getenv(n) == option::some(\"VALUE\");\n-    }\n-\n-    #[test]\n-    #[ignore(reason = \"fails periodically on mac\")]\n-    fn test_setenv_overwrite() {\n-        let n = make_rand_name();\n-        setenv(n, \"1\");\n-        setenv(n, \"2\");\n-        assert getenv(n) == option::some(\"2\");\n-        setenv(n, \"\");\n-        assert getenv(n) == option::some(\"\");\n-    }\n-\n-    // Windows GetEnvironmentVariable requires some extra work to make sure\n-    // the buffer the variable is copied into is the right size\n-    #[test]\n-    #[ignore(reason = \"fails periodically on mac\")]\n-    fn test_getenv_big() {\n-        let s = \"\";\n-        let i = 0;\n-        while i < 100 { s += \"aaaaaaaaaa\"; i += 1; }\n-        let n = make_rand_name();\n-        setenv(n, s);\n-        log(debug, s);\n-        assert getenv(n) == option::some(s);\n-    }\n-\n-    #[test]\n-    fn test_get_exe_path() {\n-        let path = os::get_exe_path();\n-        assert option::is_some(path);\n-        let path = option::get(path);\n-        log(debug, path);\n-\n-        // Hard to test this function\n-        if os::target_os() != \"win32\" {\n-            assert str::starts_with(path, fs::path_sep());\n-        } else {\n-            assert path[1] == ':' as u8;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_env_getenv() {\n-        let e = env();\n-        assert vec::len(e) > 0u;\n-        for (n, v) in e {\n-            log(debug, n);\n-            let v2 = getenv(n);\n-            // MingW seems to set some funky environment variables like\n-            // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n-            // from env() but not visible from getenv().\n-            assert option::is_none(v2) || v2 == option::some(v);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_env_setenv() {\n-        let n = make_rand_name();\n-\n-        let e = env();\n-        setenv(n, \"VALUE\");\n-        assert !vec::contains(e, (n, \"VALUE\"));\n-\n-        e = env();\n-        assert vec::contains(e, (n, \"VALUE\"));\n-    }\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "bfbbaf52ff2275921d7b2daf58b95b096f21af0b", "filename": "src/libstd/linux_os.rs", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flinux_os.rs?ref=ac57bb38560fa35d883505af2e8e68498b436fe7", "patch": "@@ -1,152 +0,0 @@\n-/*\n-Module: os\n-\n-TODO: Restructure and document\n-*/\n-\n-import core::option;\n-import core::ctypes::*;\n-\n-export libc;\n-export libc_constants;\n-export pipe;\n-export FILE, fd_FILE;\n-export close;\n-export fclose;\n-export waitpid;\n-export getcwd;\n-export exec_suffix;\n-export target_os;\n-export dylib_filename;\n-export get_exe_path;\n-export fsync_fd;\n-export rustrt;\n-\n-// FIXME Somehow merge stuff duplicated here and macosx_os.rs. Made difficult\n-// by https://github.com/graydon/rust/issues#issue/268\n-\n-enum FILE_opaque {}\n-type FILE = *FILE_opaque;\n-enum dir {}\n-enum dirent {}\n-\n-#[nolink]\n-#[abi = \"cdecl\"]\n-native mod libc {\n-    fn read(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n-    fn write(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n-    fn fread(buf: *u8, size: size_t, n: size_t, f: FILE) -> size_t;\n-    fn fwrite(buf: *u8, size: size_t, n: size_t, f: FILE) -> size_t;\n-    fn open(s: str::sbuf, flags: c_int, mode: unsigned) -> fd_t;\n-    fn close(fd: fd_t) -> c_int;\n-    fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n-    fn fdopen(fd: fd_t, mode: str::sbuf) -> FILE;\n-    fn fclose(f: FILE);\n-    fn fflush(f: FILE) -> c_int;\n-    fn fsync(fd: fd_t) -> c_int;\n-    fn fdatasync(fd: fd_t) -> c_int;\n-    fn fileno(f: FILE) -> fd_t;\n-    fn fgetc(f: FILE) -> c_int;\n-    fn ungetc(c: c_int, f: FILE);\n-    fn feof(f: FILE) -> c_int;\n-    fn fseek(f: FILE, offset: long, whence: c_int) -> c_int;\n-    fn ftell(f: FILE) -> long;\n-    fn opendir(d: str::sbuf) -> *dir;\n-    fn closedir(d: *dir) -> c_int;\n-    fn readdir(d: *dir) -> *dirent;\n-    fn getenv(n: str::sbuf) -> str::sbuf;\n-    fn setenv(n: str::sbuf, v: str::sbuf, overwrite: c_int) -> c_int;\n-    fn unsetenv(n: str::sbuf) -> c_int;\n-    fn pipe(buf: *mutable fd_t) -> c_int;\n-    fn waitpid(pid: pid_t, &status: c_int, options: c_int) -> pid_t;\n-    fn readlink(path: str::sbuf, buf: str::sbuf, bufsize: size_t) -> ssize_t;\n-    fn mkdir(path: str::sbuf, mode: c_int) -> c_int;\n-    fn rmdir(path: str::sbuf) -> c_int;\n-    fn chdir(path: str::sbuf) -> c_int;\n-    fn unlink(path: str::sbuf) -> c_int;\n-}\n-\n-mod libc_constants {\n-    const O_RDONLY: c_int = 0i32;\n-    const O_WRONLY: c_int = 1i32;\n-    const O_RDWR: c_int   = 2i32;\n-    const O_APPEND: c_int = 1024i32;\n-    const O_CREAT: c_int  = 64i32;\n-    const O_EXCL: c_int   = 128i32;\n-    const O_TRUNC: c_int  = 512i32;\n-    const O_TEXT: c_int   = 0i32;     // nonexistent in linux libc\n-    const O_BINARY: c_int = 0i32;     // nonexistent in linux libc\n-\n-    const S_IRUSR: unsigned = 256u32;\n-    const S_IWUSR: unsigned = 128u32;\n-}\n-\n-fn pipe() -> {in: fd_t, out: fd_t} {\n-    let fds = {mutable in: 0i32, mutable out: 0i32};\n-    assert (os::libc::pipe(ptr::mut_addr_of(fds.in)) == 0i32);\n-    ret {in: fds.in, out: fds.out};\n-}\n-\n-fn fd_FILE(fd: fd_t) -> FILE {\n-    ret str::as_buf(\"r\", {|modebuf| libc::fdopen(fd, modebuf) });\n-}\n-\n-fn close(fd: fd_t) -> c_int {\n-    libc::close(fd)\n-}\n-\n-fn fclose(file: FILE) {\n-    libc::fclose(file)\n-}\n-\n-fn fsync_fd(fd: fd_t, level: io::fsync::level) -> c_int {\n-    alt level {\n-      io::fsync::fsync | io::fsync::fullfsync { ret libc::fsync(fd); }\n-      io::fsync::fdatasync { ret libc::fdatasync(fd); }\n-    }\n-}\n-\n-fn waitpid(pid: pid_t) -> i32 {\n-    let status = 0i32;\n-    assert (os::libc::waitpid(pid, status, 0i32) != -1i32);\n-    ret status;\n-}\n-\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn rust_env_pairs() -> [str];\n-    fn rust_getcwd() -> str;\n-}\n-\n-fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n-\n-fn exec_suffix() -> str { ret \"\"; }\n-\n-fn target_os() -> str { ret \"linux\"; }\n-\n-fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n-\n-/// Returns the directory containing the running program\n-/// followed by a path separator\n-fn get_exe_path() -> option<fs::path> {\n-    let bufsize = 1023u;\n-    // FIXME: path \"strings\" will likely need fixing...\n-    let path = str::from_bytes(vec::init_elt(bufsize, 0u8));\n-    ret str::as_buf(\"/proc/self/exe\", { |proc_self_buf|\n-        str::as_buf(path, { |path_buf|\n-            if libc::readlink(proc_self_buf, path_buf, bufsize) != -1 {\n-                option::some(fs::dirname(path) + fs::path_sep())\n-            } else {\n-                option::none\n-            }\n-        })\n-    });\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "bb9efdcbc0922d98a99a69a754b0a5bfaf1b9a93", "filename": "src/libstd/macos_os.rs", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacos_os.rs?ref=ac57bb38560fa35d883505af2e8e68498b436fe7", "patch": "@@ -1,160 +0,0 @@\n-import core::option;\n-import core::ctypes::*;\n-\n-export libc;\n-export libc_constants;\n-export pipe;\n-export FILE, fd_FILE;\n-export close;\n-export fclose;\n-export waitpid;\n-export getcwd;\n-export exec_suffix;\n-export target_os;\n-export dylib_filename;\n-export get_exe_path;\n-export fsync_fd;\n-export rustrt;\n-\n-// FIXME Refactor into unix_os module or some such. Doesn't\n-// seem to work right now.\n-\n-enum FILE_opaque {}\n-type FILE = *FILE_opaque;\n-enum dir {}\n-enum dirent {}\n-\n-#[nolink]\n-#[abi = \"cdecl\"]\n-native mod libc {\n-    fn read(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n-    fn write(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n-    fn fread(buf: *u8, size: size_t, n: size_t, f: FILE) -> size_t;\n-    fn fwrite(buf: *u8, size: size_t, n: size_t, f: FILE) -> size_t;\n-    fn open(s: str::sbuf, flags: c_int, mode: unsigned) -> fd_t;\n-    fn close(fd: fd_t) -> c_int;\n-    fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n-    fn fdopen(fd: fd_t, mode: str::sbuf) -> FILE;\n-    fn fflush(f: FILE) -> c_int;\n-    fn fsync(fd: fd_t) -> c_int;\n-    fn fileno(f: FILE) -> fd_t;\n-    fn fclose(f: FILE);\n-    fn fgetc(f: FILE) -> c_int;\n-    fn ungetc(c: c_int, f: FILE);\n-    fn feof(f: FILE) -> c_int;\n-    fn fseek(f: FILE, offset: long, whence: c_int) -> c_int;\n-    fn ftell(f: FILE) -> long;\n-    fn opendir(d: str::sbuf) -> *dir;\n-    fn closedir(d: *dir) -> c_int;\n-    fn readdir(d: *dir) -> *dirent;\n-    fn getenv(n: str::sbuf) -> str::sbuf;\n-    fn setenv(n: str::sbuf, v: str::sbuf, overwrite: c_int) -> c_int;\n-    fn unsetenv(n: str::sbuf) -> c_int;\n-    fn pipe(buf: *mutable c_int) -> c_int;\n-    fn waitpid(pid: pid_t, &status: c_int, options: c_int) -> c_int;\n-    fn mkdir(s: str::sbuf, mode: c_int) -> c_int;\n-    fn rmdir(s: str::sbuf) -> c_int;\n-    fn chdir(s: str::sbuf) -> c_int;\n-    fn unlink(path: str::sbuf) -> c_int;\n-\n-    // FIXME: Needs varags\n-    fn fcntl(fd: fd_t, cmd: c_int) -> c_int;\n-}\n-\n-mod libc_constants {\n-    const O_RDONLY: c_int    = 0i32;\n-    const O_WRONLY: c_int    = 1i32;\n-    const O_RDWR: c_int      = 2i32;\n-    const O_APPEND: c_int    = 8i32;\n-    const O_CREAT: c_int     = 512i32;\n-    const O_EXCL: c_int      = 2048i32;\n-    const O_TRUNC: c_int     = 1024i32;\n-    const O_TEXT: c_int      = 0i32;    // nonexistent in darwin libc\n-    const O_BINARY: c_int    = 0i32;    // nonexistent in darwin libc\n-\n-    const S_IRUSR: unsigned  = 256u32;\n-    const S_IWUSR: unsigned  = 128u32;\n-\n-    const F_FULLFSYNC: c_int = 51i32;\n-}\n-\n-fn pipe() -> {in: fd_t, out: fd_t} {\n-    let fds = {mutable in: 0i32, mutable out: 0i32};\n-    assert (os::libc::pipe(ptr::mut_addr_of(fds.in)) == 0i32);\n-    ret {in: fds.in, out: fds.out};\n-}\n-\n-fn fd_FILE(fd: fd_t) -> FILE {\n-    ret str::as_buf(\"r\", {|modebuf| libc::fdopen(fd, modebuf) });\n-}\n-\n-fn close(fd: fd_t) -> c_int {\n-    libc::close(fd)\n-}\n-\n-fn fclose(file: FILE) {\n-    libc::fclose(file)\n-}\n-\n-fn waitpid(pid: pid_t) -> i32 {\n-    let status = 0i32;\n-    assert (os::libc::waitpid(pid, status, 0i32) != -1i32);\n-    ret status;\n-}\n-\n-fn fsync_fd(fd: fd_t, level: io::fsync::level) -> c_int {\n-    alt level {\n-      io::fsync::fsync { ret libc::fsync(fd); }\n-      _ {\n-        // According to man fnctl, the ok retval is only specified to be !=-1\n-        if (libc::fcntl(libc_constants::F_FULLFSYNC, fd) == -1 as c_int)\n-            { ret -1 as c_int; }\n-        else\n-            { ret 0 as c_int; }\n-      }\n-    }\n-}\n-\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn rust_env_pairs() -> [str];\n-    fn rust_getcwd() -> str;\n-}\n-\n-fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n-\n-#[nolink]\n-#[abi = \"cdecl\"]\n-native mod mac_libc {\n-    fn _NSGetExecutablePath(buf: str::sbuf,\n-                            bufsize: *mutable uint32_t) -> c_int;\n-}\n-\n-fn exec_suffix() -> str { ret \"\"; }\n-\n-fn target_os() -> str { ret \"macos\"; }\n-\n-fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".dylib\"; }\n-\n-fn get_exe_path() -> option<fs::path> {\n-    // FIXME: This doesn't handle the case where the buffer is too small\n-    // FIXME: path \"strings\" will likely need fixing...\n-    let bufsize = 1023u32;\n-    let path = str::from_bytes(vec::init_elt(bufsize as uint, 0u8));\n-    ret str::as_buf(path, { |path_buf|\n-        if mac_libc::_NSGetExecutablePath(path_buf,\n-                                          ptr::mut_addr_of(bufsize)) == 0i32 {\n-            option::some(fs::dirname(path) + fs::path_sep())\n-        } else {\n-            option::none\n-        }\n-    });\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "e774650f980b5b208fc585e03865a0d6603ea880", "filename": "src/libstd/posix_fs.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fposix_fs.rs?ref=ac57bb38560fa35d883505af2e8e68498b436fe7", "patch": "@@ -1,46 +0,0 @@\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn rust_list_files(path: str) -> [str];\n-}\n-\n-fn list_dir(path: str) -> [str] {\n-    ret rustrt::rust_list_files(path);\n-\n-    // FIXME: No idea why, but this appears to corrupt memory on OSX. I\n-    // suspect it has to do with the tasking primitives somehow, or perhaps\n-    // the FFI. Worth investigating more when we're digging into the FFI and\n-    // unsafe mode in more detail; in the meantime we just call list_files\n-    // above and skip this code.\n-\n-    /*\n-    auto dir = os::libc::opendir(str::buf(path));\n-    assert (dir as uint != 0u);\n-    let vec<str> result = [];\n-    while (true) {\n-        auto ent = os::libc::readdir(dir);\n-        if (ent as int == 0) {\n-            os::libc::closedir(dir);\n-            ret result;\n-        }\n-        vec::push::<str>(result, rustrt::rust_dirent_filename(ent));\n-    }\n-    os::libc::closedir(dir);\n-    ret result;\n-    */\n-\n-}\n-\n-// FIXME make pure when str::char_at is\n-fn path_is_absolute(p: str) -> bool { ret str::char_at(p, 0u) == '/'; }\n-\n-const path_sep: char = '/';\n-\n-const alt_path_sep: char = '/';\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "a06cca77f752bfbe54944bf36f297a988801f075", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 42, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -6,26 +6,19 @@\n #[comment = \"The Rust standard library\"];\n #[license = \"MIT\"];\n #[crate_type = \"lib\"];\n-\n #[doc = \"The Rust standard library\"];\n \n-export fs, io, net, run, uv;\n+export net, uv;\n export c_vec, four, tri, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope;\n export ebml, dbg, getopts, json, rand, sha1, term, time;\n export test, tempfile, serialization;\n-// FIXME: generic_os and os_fs shouldn't be exported\n-export generic_os, os, os_fs;\n \n \n // General io and system-services modules\n \n-mod fs;\n-mod io;\n mod net;\n-#[path =  \"run_program.rs\"]\n-mod run;\n mod uv;\n \n \n@@ -57,7 +50,6 @@ mod ebml;\n mod dbg;\n mod getopts;\n mod json;\n-mod rand;\n mod sha1;\n mod md4;\n mod tempfile;\n@@ -73,39 +65,6 @@ mod unicode;\n mod test;\n mod serialization;\n \n-// Target-os module.\n-\n-// TODO: Have each os module re-export everything from genericos.\n-mod generic_os;\n-\n-#[cfg(target_os = \"win32\")]\n-#[path = \"win32_os.rs\"]\n-mod os;\n-#[cfg(target_os = \"win32\")]\n-#[path = \"win32_fs.rs\"]\n-mod os_fs;\n-\n-#[cfg(target_os = \"macos\")]\n-#[path = \"macos_os.rs\"]\n-mod os;\n-#[cfg(target_os = \"macos\")]\n-#[path = \"posix_fs.rs\"]\n-mod os_fs;\n-\n-#[cfg(target_os = \"linux\")]\n-#[path = \"linux_os.rs\"]\n-mod os;\n-#[cfg(target_os = \"linux\")]\n-#[path = \"posix_fs.rs\"]\n-mod os_fs;\n-\n-#[cfg(target_os = \"freebsd\")]\n-#[path = \"freebsd_os.rs\"]\n-mod os;\n-#[cfg(target_os = \"freebsd\")]\n-#[path = \"posix_fs.rs\"]\n-mod os_fs;\n-\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "3ed70bb95350a05636abe5e699f344597bc74662", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,7 +1,6 @@\n #[doc = \"Temporary files and directories\"];\n \n import core::option;\n-import fs;\n import option::{none, some};\n import rand;\n \n@@ -10,7 +9,7 @@ fn mkdtemp(prefix: str, suffix: str) -> option<str> {\n     let i = 0u;\n     while (i < 1000u) {\n         let s = prefix + r.gen_str(16u) + suffix;\n-        if fs::make_dir(s, 0x1c0i32) {  // FIXME: u+rwx\n+        if os::make_dir(s, 0x1c0i32) {  // FIXME: u+rwx\n             ret some(s);\n         }\n         i += 1u;\n@@ -23,7 +22,7 @@ fn test_mkdtemp() {\n     let r = mkdtemp(\"./\", \"foobar\");\n     alt r {\n         some(p) {\n-            fs::remove_dir(p);\n+            os::remove_dir(p);\n             assert(str::ends_with(p, \"foobar\"));\n         }\n         _ { assert(false); }"}, {"sha": "302852a8edf6dcffc2950cf9b5949613ff053cf5", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -35,7 +35,7 @@ fn reset(writer: io::writer) {\n fn color_supported() -> bool {\n     let supported_terms = [\"xterm-color\", \"xterm\",\n                            \"screen-bce\", \"xterm-256color\"];\n-    ret alt generic_os::getenv(\"TERM\") {\n+    ret alt os::getenv(\"TERM\") {\n           option::some(env) {\n             for term: str in supported_terms {\n                 if str::eq(term, env) { ret true; }"}, {"sha": "540966b2a7826ac9cf4e18a8232ed5af8d2fb2b1", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -7,7 +7,6 @@\n \n import result::{ok, err};\n import io::writer_util;\n-import core::ctypes;\n \n export test_name;\n export test_fn;\n@@ -22,7 +21,7 @@ export run_tests_console;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn sched_threads() -> ctypes::size_t;\n+    fn sched_threads() -> libc::size_t;\n }\n \n // The name of a test. By convention this follows the rules for rust"}, {"sha": "d91f43335608b3ede140044f686e9c4ff19228c6", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -7,11 +7,11 @@ export timer_init, timer_start, timer_stop;\n // process_operation() crust fn below\n enum uv_operation {\n     op_async_init([u8]),\n-    op_close(uv_handle, *ctypes::void),\n+    op_close(uv_handle, *libc::c_void),\n     op_timer_init([u8]),\n-    op_timer_start([u8], *ctypes::void, u32, u32),\n-    op_timer_stop([u8], *ctypes::void, fn~(uv_handle)),\n-    op_teardown(*ctypes::void)\n+    op_timer_start([u8], *libc::c_void, u32, u32),\n+    op_timer_stop([u8], *libc::c_void, fn~(uv_handle)),\n+    op_teardown(*libc::c_void)\n }\n \n enum uv_handle {\n@@ -31,10 +31,10 @@ enum uv_msg {\n     msg_timer_stop([u8], fn~(uv_handle)),\n \n     // dispatches from libuv\n-    uv_async_init([u8], *ctypes::void),\n+    uv_async_init([u8], *libc::c_void),\n     uv_async_send([u8]),\n     uv_close([u8]),\n-    uv_timer_init([u8], *ctypes::void),\n+    uv_timer_init([u8], *libc::c_void),\n     uv_timer_call([u8]),\n     uv_timer_stop([u8], fn~(uv_handle)),\n     uv_end(),\n@@ -47,37 +47,37 @@ type uv_loop_data = {\n };\n \n enum uv_loop {\n-    uv_loop_new(comm::chan<uv_msg>, *ctypes::void)\n+    uv_loop_new(comm::chan<uv_msg>, *libc::c_void)\n }\n \n #[nolink]\n native mod rustrt {\n-    fn rust_uv_loop_new() -> *ctypes::void;\n-    fn rust_uv_loop_delete(lp: *ctypes::void);\n+    fn rust_uv_loop_new() -> *libc::c_void;\n+    fn rust_uv_loop_delete(lp: *libc::c_void);\n     fn rust_uv_loop_set_data(\n-        lp: *ctypes::void,\n+        lp: *libc::c_void,\n         data: *uv_loop_data);\n-    fn rust_uv_bind_op_cb(lp: *ctypes::void, cb: *u8)\n-        -> *ctypes::void;\n-    fn rust_uv_stop_op_cb(handle: *ctypes::void);\n-    fn rust_uv_run(loop_handle: *ctypes::void);\n-    fn rust_uv_close(handle: *ctypes::void, cb: *u8);\n-    fn rust_uv_close_async(handle: *ctypes::void);\n-    fn rust_uv_close_timer(handle: *ctypes::void);\n-    fn rust_uv_async_send(handle: *ctypes::void);\n+    fn rust_uv_bind_op_cb(lp: *libc::c_void, cb: *u8)\n+        -> *libc::c_void;\n+    fn rust_uv_stop_op_cb(handle: *libc::c_void);\n+    fn rust_uv_run(loop_handle: *libc::c_void);\n+    fn rust_uv_close(handle: *libc::c_void, cb: *u8);\n+    fn rust_uv_close_async(handle: *libc::c_void);\n+    fn rust_uv_close_timer(handle: *libc::c_void);\n+    fn rust_uv_async_send(handle: *libc::c_void);\n     fn rust_uv_async_init(\n-        loop_handle: *ctypes::void,\n+        loop_handle: *libc::c_void,\n         cb: *u8,\n-        id: *u8) -> *ctypes::void;\n+        id: *u8) -> *libc::c_void;\n     fn rust_uv_timer_init(\n-        loop_handle: *ctypes::void,\n+        loop_handle: *libc::c_void,\n         cb: *u8,\n-        id: *u8) -> *ctypes::void;\n+        id: *u8) -> *libc::c_void;\n     fn rust_uv_timer_start(\n-        timer_handle: *ctypes::void,\n-        timeout: ctypes::c_uint,\n-        repeat: ctypes::c_uint);\n-    fn rust_uv_timer_stop(handle: *ctypes::void);\n+        timer_handle: *libc::c_void,\n+        timeout: libc::c_uint,\n+        repeat: libc::c_uint);\n+    fn rust_uv_timer_stop(handle: *libc::c_void);\n }\n \n // public functions\n@@ -130,7 +130,7 @@ fn loop_new() -> uv_loop unsafe {\n             process_operation);\n \n         // all state goes here\n-        let handles: map::hashmap<[u8], *ctypes::void> =\n+        let handles: map::hashmap<[u8], *libc::c_void> =\n             map::new_bytes_hash();\n         let id_to_handle: map::hashmap<[u8], uv_handle> =\n             map::new_bytes_hash();\n@@ -399,13 +399,13 @@ fn timer_stop(the_timer: uv_handle, after_cb: fn~(uv_handle)) {\n \n // internal functions\n fn pass_to_libuv(\n-        op_handle: *ctypes::void,\n+        op_handle: *libc::c_void,\n         operation_chan: comm::chan<uv_operation>,\n         op: uv_operation) unsafe {\n     comm::send(operation_chan, copy(op));\n     do_send(op_handle);\n }\n-fn do_send(h: *ctypes::void) {\n+fn do_send(h: *libc::c_void) {\n     rustrt::rust_uv_async_send(h);\n }\n fn gen_handle_id() -> [u8] {\n@@ -434,7 +434,7 @@ fn get_loop_chan_from_handle(handle: uv_handle)\n     }\n }\n \n-fn get_loop_ptr_from_uv_loop(lp: uv_loop) -> *ctypes::void {\n+fn get_loop_ptr_from_uv_loop(lp: uv_loop) -> *libc::c_void {\n     alt lp {\n       uv_loop_new(loop_chan, loop_ptr) {\n         ret loop_ptr;\n@@ -462,7 +462,7 @@ fn get_id_from_handle(handle: uv_handle) -> [u8] {\n \n // crust\n crust fn process_operation(\n-        lp: *ctypes::void,\n+        lp: *libc::c_void,\n         data: *uv_loop_data) unsafe {\n     let op_port = (*data).operation_port;\n     let loop_chan = get_loop_chan_from_data(data);\n@@ -512,7 +512,7 @@ crust fn process_operation(\n     }\n }\n \n-fn handle_op_close(handle: uv_handle, handle_ptr: *ctypes::void) {\n+fn handle_op_close(handle: uv_handle, handle_ptr: *libc::c_void) {\n     // it's just like im doing C\n     alt handle {\n       uv_async(id, lp) {\n@@ -557,7 +557,7 @@ fn process_close_common(id: [u8], data: *uv_loop_data)\n \n crust fn process_close_async(\n     id_buf: *u8,\n-    handle_ptr: *ctypes::void,\n+    handle_ptr: *libc::c_void,\n     data: *uv_loop_data)\n     unsafe {\n     let id = get_handle_id_from(id_buf);\n@@ -571,7 +571,7 @@ crust fn process_close_async(\n \n crust fn process_close_timer(\n     id_buf: *u8,\n-    handle_ptr: *ctypes::void,\n+    handle_ptr: *libc::c_void,\n     data: *uv_loop_data)\n     unsafe {\n     let id = get_handle_id_from(id_buf);"}, {"sha": "bca09fcf835acd17fcdac080602893a96df64817", "filename": "src/libstd/win32_fs.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fwin32_fs.rs?ref=ac57bb38560fa35d883505af2e8e68498b436fe7", "patch": "@@ -1,35 +0,0 @@\n-\n-\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn rust_list_files(path: str) -> [str];\n-}\n-\n-fn list_dir(path: str) -> [str] {\n-    let path = path + \"*\";\n-    ret rustrt::rust_list_files(path);\n-}\n-\n-fn path_is_absolute(p: str) -> bool {\n-    ret str::char_at(p, 0u) == '/' ||\n-            str::char_at(p, 1u) == ':'\n-            && (str::char_at(p, 2u) == path_sep\n-            || str::char_at(p, 2u) == alt_path_sep);\n-}\n-\n-/* FIXME: win32 path handling actually accepts '/' or '\\' and has subtly\n- * different semantics for each. Since we build on mingw, we are usually\n- * dealing with /-separated paths. But the whole interface to splitting and\n- * joining pathnames needs a bit more abstraction on win32. Possibly a vec or\n- * enum type.\n- */\n-const path_sep: char = '/';\n-\n-const alt_path_sep: char = '\\\\';\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "74de2c14668c9a3ee34d28d1a31804e7eecb8275", "filename": "src/libstd/win32_os.rs", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac57bb38560fa35d883505af2e8e68498b436fe7/src%2Flibstd%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fwin32_os.rs?ref=ac57bb38560fa35d883505af2e8e68498b436fe7", "patch": "@@ -1,140 +0,0 @@\n-import core::option;\n-import core::ctypes::*;\n-\n-enum FILE_opaque {}\n-type FILE = *FILE_opaque;\n-\n-#[abi = \"cdecl\"]\n-#[nolink]\n-native mod libc {\n-    fn read(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n-    fn write(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n-    fn fread(buf: *u8, size: size_t, n: size_t, f: FILE) -> size_t;\n-    fn fwrite(buf: *u8, size: size_t, n: size_t, f: FILE) -> size_t;\n-    #[link_name = \"_open\"]\n-    fn open(s: str::sbuf, flags: c_int, mode: unsigned) -> c_int;\n-    #[link_name = \"_close\"]\n-    fn close(fd: fd_t) -> c_int;\n-    fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n-    fn _fdopen(fd: fd_t, mode: str::sbuf) -> FILE;\n-    fn fclose(f: FILE);\n-    fn fflush(f: FILE) -> c_int;\n-    fn fileno(f: FILE) -> fd_t;\n-    fn fgetc(f: FILE) -> c_int;\n-    fn ungetc(c: c_int, f: FILE);\n-    fn feof(f: FILE) -> c_int;\n-    fn fseek(f: FILE, offset: long, whence: c_int) -> c_int;\n-    fn ftell(f: FILE) -> long;\n-    fn _pipe(fds: *mutable fd_t, size: unsigned, mode: c_int) -> c_int;\n-}\n-\n-mod libc_constants {\n-    const O_RDONLY: c_int    = 0i32;\n-    const O_WRONLY: c_int    = 1i32;\n-    const O_RDWR: c_int      = 2i32;\n-    const O_APPEND: c_int    = 8i32;\n-    const O_CREAT: c_int     = 256i32;\n-    const O_EXCL: c_int      = 1024i32;\n-    const O_TRUNC: c_int     = 512i32;\n-    const O_TEXT: c_int      = 16384i32;\n-    const O_BINARY: c_int    = 32768i32;\n-    const O_NOINHERIT: c_int = 128i32;\n-    const S_IRUSR: unsigned  = 256u32; // really _S_IREAD  in win32\n-    const S_IWUSR: unsigned  = 128u32; // really _S_IWRITE in win32\n-}\n-\n-type DWORD = u32;\n-type HMODULE = c_uint;\n-type LPTSTR = str::sbuf;\n-type LPCTSTR = str::sbuf;\n-\n-type LPSECURITY_ATTRIBUTES = *ctypes::void;\n-\n-#[abi = \"stdcall\"]\n-native mod kernel32 {\n-    fn GetEnvironmentVariableA(n: str::sbuf, v: str::sbuf, nsize: c_uint) ->\n-       c_uint;\n-    fn SetEnvironmentVariableA(n: str::sbuf, v: str::sbuf) -> c_int;\n-    fn GetModuleFileNameA(hModule: HMODULE,\n-                          lpFilename: LPTSTR,\n-                          nSize: DWORD) -> DWORD;\n-    fn CreateDirectoryA(lpPathName: LPCTSTR,\n-                        lpSecurityAttributes: LPSECURITY_ATTRIBUTES) -> bool;\n-    fn RemoveDirectoryA(lpPathName: LPCTSTR) -> bool;\n-    fn SetCurrentDirectoryA(lpPathName: LPCTSTR) -> bool;\n-    fn DeleteFileA(lpFileName: LPCTSTR) -> bool;\n-}\n-\n-// FIXME turn into constants\n-fn exec_suffix() -> str { ret \".exe\"; }\n-fn target_os() -> str { ret \"win32\"; }\n-\n-fn dylib_filename(base: str) -> str { ret base + \".dll\"; }\n-\n-fn pipe() -> {in: fd_t, out: fd_t} {\n-    // Windows pipes work subtly differently than unix pipes, and their\n-    // inheritance has to be handled in a different way that I don't fully\n-    // understand. Here we explicitly make the pipe non-inheritable,\n-    // which means to pass it to a subprocess they need to be duplicated\n-    // first, as in rust_run_program.\n-    let fds = {mutable in: 0i32, mutable out: 0i32};\n-    let res =\n-        os::libc::_pipe(ptr::mut_addr_of(fds.in), 1024u32,\n-                        libc_constants::O_BINARY |\n-                            libc_constants::O_NOINHERIT);\n-    assert (res == 0i32);\n-    assert (fds.in != -1i32 && fds.in != 0i32);\n-    assert (fds.out != -1i32 && fds.in != 0i32);\n-    ret {in: fds.in, out: fds.out};\n-}\n-\n-fn fd_FILE(fd: fd_t) -> FILE {\n-    ret str::as_buf(\"r\", {|modebuf| libc::_fdopen(fd, modebuf) });\n-}\n-\n-fn close(fd: fd_t) -> c_int {\n-    libc::close(fd)\n-}\n-\n-fn fclose(file: FILE) {\n-    libc::fclose(file)\n-}\n-\n-fn fsync_fd(_fd: fd_t, _level: io::fsync::level) -> c_int {\n-    // FIXME (1253)\n-    fail;\n-}\n-\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn rust_env_pairs() -> [str];\n-    fn rust_process_wait(handle: c_int) -> c_int;\n-    fn rust_getcwd() -> str;\n-}\n-\n-fn waitpid(pid: pid_t) -> i32 { ret rustrt::rust_process_wait(pid); }\n-\n-fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n-\n-fn get_exe_path() -> option<fs::path> {\n-    // FIXME: This doesn't handle the case where the buffer is too small\n-    // FIXME: path \"strings\" will likely need fixing...\n-    let bufsize = 1023u;\n-    let path = str::from_bytes(vec::init_elt(bufsize, 0u8));\n-    ret str::as_buf(path, { |path_buf|\n-        if kernel32::GetModuleFileNameA(0u, path_buf,\n-                                        bufsize as u32) != 0u32 {\n-            option::some(fs::dirname(path) + fs::path_sep())\n-        } else {\n-            option::none\n-        }\n-    });\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "bf7d9aaf75bf913f333108e03014cf82c05f01bd", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,14 +1,12 @@\n-import ctypes::{c_int, c_uint};\n+import libc::{c_int, c_uint};\n import driver::session;\n import session::session;\n import lib::llvm::llvm;\n import front::attr;\n import middle::ty;\n import metadata::{encoder, cstore};\n import middle::trans::common::crate_ctxt;\n-import std::fs;\n import std::map::hashmap;\n-import std::run;\n import std::sha1::sha1;\n import syntax::ast;\n import syntax::print::pprust;\n@@ -435,7 +433,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n               none {\n                 let name =\n                     {\n-                        let os = str::split_char(fs::basename(output), '.');\n+                        let os = str::split_char(path::basename(output), '.');\n                         if (vec::len(os) < 2u) {\n                             sess.fatal(#fmt(\"output file name %s doesn't\\\n                               appear to have an extension\", output));\n@@ -584,14 +582,14 @@ fn link_binary(sess: session,\n \n     let output = if sess.building_library {\n         let long_libname =\n-            std::os::dylib_filename(#fmt(\"%s-%s-%s\",\n-                                         lm.name, lm.extras_hash, lm.vers));\n+            os::dll_filename(#fmt(\"%s-%s-%s\",\n+                                  lm.name, lm.extras_hash, lm.vers));\n         #debug(\"link_meta.name:  %s\", lm.name);\n         #debug(\"long_libname: %s\", long_libname);\n         #debug(\"out_filename: %s\", out_filename);\n-        #debug(\"dirname(out_filename): %s\", fs::dirname(out_filename));\n+        #debug(\"dirname(out_filename): %s\", path::dirname(out_filename));\n \n-        fs::connect(fs::dirname(out_filename), long_libname)\n+        path::connect(path::dirname(out_filename), long_libname)\n     } else { out_filename };\n \n     log(debug, \"output: \" + output);\n@@ -626,9 +624,9 @@ fn link_binary(sess: session,\n             cont;\n         }\n         let cratepath = cratepath;\n-        let dir = fs::dirname(cratepath);\n+        let dir = path::dirname(cratepath);\n         if dir != \"\" { cc_args += [\"-L\" + dir]; }\n-        let libarg = unlib(sess.targ_cfg, fs::basename(cratepath));\n+        let libarg = unlib(sess.targ_cfg, path::basename(cratepath));\n         cc_args += [\"-l\" + libarg];\n     }\n \n@@ -645,7 +643,7 @@ fn link_binary(sess: session,\n         // be rpathed\n         if sess.targ_cfg.os == session::os_macos {\n             cc_args += [\"-Wl,-install_name,@rpath/\"\n-                        + fs::basename(output)];\n+                        + path::basename(output)];\n         }\n     } else {\n         // FIXME: why do we hardcode -lm?"}, {"sha": "b121d69723be6782c98d2a2a9c57a4897d422957", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,4 +1,4 @@\n-import std::{os, fs, os_fs, map};\n+import std::map;\n import std::map::hashmap;\n import metadata::cstore;\n import driver::session;\n@@ -36,20 +36,20 @@ fn get_rpath_flags(sess: session::session, out_filename: str) -> [str] {\n     rpaths_to_flags(rpaths)\n }\n \n-fn get_sysroot_absolute_rt_lib(sess: session::session) -> fs::path {\n+fn get_sysroot_absolute_rt_lib(sess: session::session) -> path::path {\n     let path = [sess.filesearch.sysroot()]\n         + filesearch::relative_target_lib_path(\n             sess.opts.target_triple)\n-        + [os::dylib_filename(\"rustrt\")];\n-    fs::connect_many(path)\n+        + [os::dll_filename(\"rustrt\")];\n+    path::connect_many(path)\n }\n \n fn rpaths_to_flags(rpaths: [str]) -> [str] {\n     vec::map(rpaths, { |rpath| #fmt(\"-Wl,-rpath,%s\",rpath)})\n }\n \n-fn get_rpaths(os: session::os, cwd: fs::path, sysroot: fs::path,\n-              output: fs::path, libs: [fs::path],\n+fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n+              output: path::path, libs: [path::path],\n               target_triple: str) -> [str] {\n     #debug(\"cwd: %s\", cwd);\n     #debug(\"sysroot: %s\", sysroot);\n@@ -91,21 +91,21 @@ fn get_rpaths(os: session::os, cwd: fs::path, sysroot: fs::path,\n }\n \n fn get_rpaths_relative_to_output(os: session::os,\n-                                 cwd: fs::path,\n-                                 output: fs::path,\n-                                 libs: [fs::path]) -> [str] {\n+                                 cwd: path::path,\n+                                 output: path::path,\n+                                 libs: [path::path]) -> [str] {\n     vec::map(libs, bind get_rpath_relative_to_output(os, cwd, output, _))\n }\n \n fn get_rpath_relative_to_output(os: session::os,\n-                                cwd: fs::path,\n-                                output: fs::path,\n-                                &&lib: fs::path) : not_win32(os) -> str {\n+                                cwd: path::path,\n+                                output: path::path,\n+                                &&lib: path::path) : not_win32(os) -> str {\n     // Mac doesn't appear to support $ORIGIN\n     let prefix = alt os {\n-        session::os_linux { \"$ORIGIN\" + fs::path_sep() }\n-        session::os_freebsd { \"$ORIGIN\" + fs::path_sep() }\n-        session::os_macos { \"@executable_path\" + fs::path_sep() }\n+        session::os_linux { \"$ORIGIN\" + path::path_sep() }\n+        session::os_freebsd { \"$ORIGIN\" + path::path_sep() }\n+        session::os_macos { \"@executable_path\" + path::path_sep() }\n         session::os_win32 { core::unreachable(); }\n     };\n \n@@ -115,15 +115,15 @@ fn get_rpath_relative_to_output(os: session::os,\n }\n \n // Find the relative path from one file to another\n-fn get_relative_to(abs1: fs::path, abs2: fs::path) -> fs::path {\n-    assert fs::path_is_absolute(abs1);\n-    assert fs::path_is_absolute(abs2);\n+fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n+    assert path::path_is_absolute(abs1);\n+    assert path::path_is_absolute(abs2);\n     #debug(\"finding relative path from %s to %s\",\n            abs1, abs2);\n-    let normal1 = fs::normalize(abs1);\n-    let normal2 = fs::normalize(abs2);\n-    let split1 = str::split_char(normal1, os_fs::path_sep);\n-    let split2 = str::split_char(normal2, os_fs::path_sep);\n+    let normal1 = path::normalize(abs1);\n+    let normal2 = path::normalize(abs2);\n+    let split1 = path::split(normal1);\n+    let split2 = path::split(normal2);\n     let len1 = vec::len(split1);\n     let len2 = vec::len(split2);\n     assert len1 > 0u;\n@@ -143,29 +143,29 @@ fn get_relative_to(abs1: fs::path, abs2: fs::path) -> fs::path {\n     path += vec::slice(split2, start_idx, len2 - 1u);\n \n     if check vec::is_not_empty(path) {\n-        ret fs::connect_many(path);\n+        ret path::connect_many(path);\n     } else {\n         ret \".\";\n     }\n }\n \n-fn get_absolute_rpaths(cwd: fs::path, libs: [fs::path]) -> [str] {\n+fn get_absolute_rpaths(cwd: path::path, libs: [path::path]) -> [str] {\n     vec::map(libs, bind get_absolute_rpath(cwd, _))\n }\n \n-fn get_absolute_rpath(cwd: fs::path, &&lib: fs::path) -> str {\n-    fs::dirname(get_absolute(cwd, lib))\n+fn get_absolute_rpath(cwd: path::path, &&lib: path::path) -> str {\n+    path::dirname(get_absolute(cwd, lib))\n }\n \n-fn get_absolute(cwd: fs::path, lib: fs::path) -> fs::path {\n-    if fs::path_is_absolute(lib) {\n+fn get_absolute(cwd: path::path, lib: path::path) -> path::path {\n+    if path::path_is_absolute(lib) {\n         lib\n     } else {\n-        fs::connect(cwd, lib)\n+        path::connect(cwd, lib)\n     }\n }\n \n-fn get_install_prefix_rpath(cwd: fs::path, target_triple: str) -> str {\n+fn get_install_prefix_rpath(cwd: path::path, target_triple: str) -> str {\n     let install_prefix = #env(\"CFG_PREFIX\");\n \n     if install_prefix == \"\" {\n@@ -174,7 +174,7 @@ fn get_install_prefix_rpath(cwd: fs::path, target_triple: str) -> str {\n \n     let path = [install_prefix]\n         + filesearch::relative_target_lib_path(target_triple);\n-    get_absolute(cwd, fs::connect_many(path))\n+    get_absolute(cwd, path::connect_many(path))\n }\n \n fn minimize_rpaths(rpaths: [str]) -> [str] {\n@@ -218,14 +218,14 @@ mod test {\n     #[test]\n     fn test_prefix_rpath() {\n         let res = get_install_prefix_rpath(\"/usr/lib\", \"triple\");\n-        let d = fs::connect(#env(\"CFG_PREFIX\"), \"/lib/rustc/triple/lib\");\n+        let d = path::connect(#env(\"CFG_PREFIX\"), \"/lib/rustc/triple/lib\");\n         assert str::ends_with(res, d);\n     }\n \n     #[test]\n     fn test_prefix_rpath_abs() {\n         let res = get_install_prefix_rpath(\"/usr/lib\", \"triple\");\n-        assert fs::path_is_absolute(res);\n+        assert path::path_is_absolute(res);\n     }\n \n     #[test]"}, {"sha": "9cda2bb20bca49201dc97532f02cdc2f3c49e35c", "filename": "src/rustc/driver/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fdriver%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fdriver%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdiagnostic.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,4 +1,4 @@\n-import std::{io, term};\n+import std::term;\n import io::writer_util;\n import syntax::codemap;\n import codemap::span;"}, {"sha": "dbdd5325e1afeab93d67f5a52820cc316507c727", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,4 +1,3 @@\n-\n // -*- rust -*-\n import metadata::{creader, cstore};\n import session::session;\n@@ -11,7 +10,7 @@ import syntax::print::{pp, pprust};\n import util::{ppaux, filesearch};\n import back::link;\n import result::{ok, err};\n-import std::{fs, io, getopts};\n+import std::getopts;\n import io::{reader_util, writer_util};\n import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n import back::{x86, x86_64};\n@@ -37,7 +36,7 @@ fn default_configuration(sess: session, argv0: str, input: str) ->\n     };\n \n     ret [ // Target bindings.\n-         mk(\"target_os\", std::os::target_os()),\n+         mk(\"target_os\", os::sysname()),\n          mk(\"target_arch\", arch),\n          mk(\"target_libc\", libc),\n          // Build bindings.\n@@ -489,7 +488,7 @@ fn build_session_(\n       span_diagnostic: span_diagnostic_handler,\n       filesearch: filesearch,\n       mutable building_library: false,\n-      working_dir: fs::dirname(input)}\n+      working_dir: path::dirname(input)}\n }\n \n fn parse_pretty(sess: session, &&name: str) -> pp_mode {\n@@ -559,27 +558,27 @@ fn build_output_filenames(ifile: str,\n           some(d) { d }\n           none {\n             if input_is_stdin(ifile) {\n-                std::os::getcwd()\n+                os::getcwd()\n             } else {\n-                fs::dirname(ifile)\n+                path::dirname(ifile)\n             }\n           }\n         };\n \n         let base_filename = if !input_is_stdin(ifile) {\n-            let (path, _) = fs::splitext(ifile);\n-            fs::basename(path)\n+            let (path, _) = path::splitext(ifile);\n+            path::basename(path)\n         } else {\n             \"rust_out\"\n         };\n-        let base_path = fs::connect(dirname, base_filename);\n+        let base_path = path::connect(dirname, base_filename);\n \n \n         if sess.building_library {\n-            let basename = fs::basename(base_path);\n-            let dylibname = std::os::dylib_filename(basename);\n-            out_path = fs::connect(dirname, dylibname);\n-            obj_path = fs::connect(dirname, basename + \".\" + obj_suffix);\n+            let basename = path::basename(base_path);\n+            let dylibname = os::dll_filename(basename);\n+            out_path = path::connect(dirname, dylibname);\n+            obj_path = path::connect(dirname, basename + \".\" + obj_suffix);\n         } else {\n             out_path = base_path;\n             obj_path = base_path + \".\" + obj_suffix;\n@@ -591,7 +590,7 @@ fn build_output_filenames(ifile: str,\n         obj_path = if stop_after_codegen {\n             out_file\n         } else {\n-            let (base, _) = fs::splitext(out_file);\n+            let (base, _) = path::splitext(out_file);\n             let modified = base + \".\" + obj_suffix;\n             modified\n         };"}, {"sha": "005f6ad8b49ac4543931e4c3d9d72f162d04a17d", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -3,7 +3,7 @@ use rustc;\n \n // -*- rust -*-\n import result::{ok, err};\n-import std::{io, getopts};\n+import std::getopts;\n import io::writer_util;\n import getopts::{opt_present};\n import rustc::driver::driver::*;"}, {"sha": "2832a7a902a8364c96bfaf965164de34677e3b31", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,11 +1,11 @@\n import str::sbuf;\n import std::map::hashmap;\n \n-import ctypes::{c_int, c_uint, unsigned, longlong, ulonglong};\n+import libc::{c_int, c_uint, c_longlong, c_ulonglong};\n \n type Opcode = u32;\n-type Bool = unsigned;\n-const True: Bool = 1u32;\n+type Bool = c_uint;\n+const True: Bool = 1u32; // FIXME: should be '1 as Bool'\n const False: Bool = 0u32;\n \n // Consts for the LLVM CallConv type, pre-cast to uint.\n@@ -148,9 +148,9 @@ native mod llvm {\n     fn LLVMContextCreate() -> ContextRef;\n     fn LLVMGetGlobalContext() -> ContextRef;\n     fn LLVMContextDispose(C: ContextRef);\n-    fn LLVMGetMDKindIDInContext(C: ContextRef, Name: sbuf, SLen: unsigned) ->\n-       unsigned;\n-    fn LLVMGetMDKindID(Name: sbuf, SLen: unsigned) -> unsigned;\n+    fn LLVMGetMDKindIDInContext(C: ContextRef, Name: sbuf, SLen: c_uint) ->\n+       c_uint;\n+    fn LLVMGetMDKindID(Name: sbuf, SLen: c_uint) -> c_uint;\n \n     /* Create and destroy modules. */\n     fn LLVMModuleCreateWithNameInContext(ModuleID: sbuf, C: ContextRef) ->\n@@ -188,15 +188,15 @@ native mod llvm {\n     fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n     fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n     fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMIntTypeInContext(C: ContextRef, NumBits: unsigned) -> TypeRef;\n+    fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint) -> TypeRef;\n \n     fn LLVMInt1Type() -> TypeRef;\n     fn LLVMInt8Type() -> TypeRef;\n     fn LLVMInt16Type() -> TypeRef;\n     fn LLVMInt32Type() -> TypeRef;\n     fn LLVMInt64Type() -> TypeRef;\n-    fn LLVMIntType(NumBits: unsigned) -> TypeRef;\n-    fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> unsigned;\n+    fn LLVMIntType(NumBits: c_uint) -> TypeRef;\n+    fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n \n     /* Operations on real types */\n     fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n@@ -213,34 +213,34 @@ native mod llvm {\n \n     /* Operations on function types */\n     fn LLVMFunctionType(ReturnType: TypeRef, ParamTypes: *TypeRef,\n-                        ParamCount: unsigned, IsVarArg: Bool) -> TypeRef;\n+                        ParamCount: c_uint, IsVarArg: Bool) -> TypeRef;\n     fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n     fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n-    fn LLVMCountParamTypes(FunctionTy: TypeRef) -> unsigned;\n+    fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n     fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *TypeRef);\n \n     /* Operations on struct types */\n     fn LLVMStructTypeInContext(C: ContextRef, ElementTypes: *TypeRef,\n-                               ElementCount: unsigned,\n+                               ElementCount: c_uint,\n                                Packed: Bool) -> TypeRef;\n-    fn LLVMStructType(ElementTypes: *TypeRef, ElementCount: unsigned,\n+    fn LLVMStructType(ElementTypes: *TypeRef, ElementCount: c_uint,\n                       Packed: Bool) -> TypeRef;\n-    fn LLVMCountStructElementTypes(StructTy: TypeRef) -> unsigned;\n+    fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n     fn LLVMGetStructElementTypes(StructTy: TypeRef, Dest: *TypeRef);\n     fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n \n     /* Operations on array, pointer, and vector types (sequence types) */\n     fn LLVMArrayType(ElementType: TypeRef,\n-                     ElementCount: unsigned) -> TypeRef;\n+                     ElementCount: c_uint) -> TypeRef;\n     fn LLVMPointerType(ElementType: TypeRef,\n-                       AddressSpace: unsigned) -> TypeRef;\n+                       AddressSpace: c_uint) -> TypeRef;\n     fn LLVMVectorType(ElementType: TypeRef,\n-                      ElementCount: unsigned) -> TypeRef;\n+                      ElementCount: c_uint) -> TypeRef;\n \n     fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n-    fn LLVMGetArrayLength(ArrayTy: TypeRef) -> unsigned;\n-    fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> unsigned;\n-    fn LLVMGetVectorSize(VectorTy: TypeRef) -> unsigned;\n+    fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n+    fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n+    fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n     /* Operations on other types */\n     fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n@@ -258,8 +258,8 @@ native mod llvm {\n     fn LLVMDumpValue(Val: ValueRef);\n     fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n     fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n-    fn LLVMGetMetadata(Val: ValueRef, KindID: unsigned) -> ValueRef;\n-    fn LLVMSetMetadata(Val: ValueRef, KindID: unsigned, Node: ValueRef);\n+    fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n+    fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n \n     /* Operations on Uses */\n     fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n@@ -268,8 +268,8 @@ native mod llvm {\n     fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n \n     /* Operations on Users */\n-    fn LLVMGetOperand(Val: ValueRef, Index: unsigned) -> ValueRef;\n-    fn LLVMSetOperand(Val: ValueRef, Index: unsigned, Op: ValueRef);\n+    fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n+    fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n \n     /* Operations on constants of any type */\n     fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n@@ -283,46 +283,46 @@ native mod llvm {\n     fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n \n     /* Operations on metadata */\n-    fn LLVMMDStringInContext(C: ContextRef, Str: sbuf, SLen: unsigned) ->\n+    fn LLVMMDStringInContext(C: ContextRef, Str: sbuf, SLen: c_uint) ->\n        ValueRef;\n-    fn LLVMMDString(Str: sbuf, SLen: unsigned) -> ValueRef;\n-    fn LLVMMDNodeInContext(C: ContextRef, Vals: *ValueRef, Count: unsigned) ->\n+    fn LLVMMDString(Str: sbuf, SLen: c_uint) -> ValueRef;\n+    fn LLVMMDNodeInContext(C: ContextRef, Vals: *ValueRef, Count: c_uint) ->\n        ValueRef;\n-    fn LLVMMDNode(Vals: *ValueRef, Count: unsigned) -> ValueRef;\n+    fn LLVMMDNode(Vals: *ValueRef, Count: c_uint) -> ValueRef;\n     fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: sbuf,\n                                    Val: ValueRef);\n \n     /* Operations on scalar constants */\n-    fn LLVMConstInt(IntTy: TypeRef, N: ulonglong, SignExtend: Bool) ->\n+    fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) ->\n        ValueRef;\n     // FIXME: radix is actually u8, but our native layer can't handle this\n     // yet.  lucky for us we're little-endian. Small miracles.\n     fn LLVMConstIntOfString(IntTy: TypeRef, Text: sbuf, Radix: c_int) ->\n        ValueRef;\n-    fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: sbuf, SLen: unsigned,\n+    fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: sbuf, SLen: c_uint,\n                                    Radix: u8) -> ValueRef;\n     fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n     fn LLVMConstRealOfString(RealTy: TypeRef, Text: sbuf) -> ValueRef;\n     fn LLVMConstRealOfStringAndSize(RealTy: TypeRef, Text: sbuf,\n-                                    SLen: unsigned) -> ValueRef;\n-    fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> ulonglong;\n-    fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> longlong;\n+                                    SLen: c_uint) -> ValueRef;\n+    fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n+    fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n \n \n     /* Operations on composite constants */\n-    fn LLVMConstStringInContext(C: ContextRef, Str: sbuf, Length: unsigned,\n+    fn LLVMConstStringInContext(C: ContextRef, Str: sbuf, Length: c_uint,\n                                 DontNullTerminate: Bool) -> ValueRef;\n     fn LLVMConstStructInContext(C: ContextRef, ConstantVals: *ValueRef,\n-                                Count: unsigned, Packed: Bool) -> ValueRef;\n+                                Count: c_uint, Packed: Bool) -> ValueRef;\n \n-    fn LLVMConstString(Str: sbuf, Length: unsigned,\n+    fn LLVMConstString(Str: sbuf, Length: c_uint,\n                        DontNullTerminate: Bool) -> ValueRef;\n     fn LLVMConstArray(ElementTy: TypeRef, ConstantVals: *ValueRef,\n-                      Length: unsigned) -> ValueRef;\n+                      Length: c_uint) -> ValueRef;\n     fn LLVMConstStruct(ConstantVals: *ValueRef,\n-                       Count: unsigned, Packed: Bool) -> ValueRef;\n+                       Count: c_uint, Packed: Bool) -> ValueRef;\n     fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n-                       Size: unsigned) -> ValueRef;\n+                       Size: c_uint) -> ValueRef;\n \n     /* Constant expressions */\n     fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n@@ -376,9 +376,9 @@ native mod llvm {\n     fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n        ValueRef;\n     fn LLVMConstGEP(ConstantVal: ValueRef, ConstantIndices: *uint,\n-                    NumIndices: unsigned) -> ValueRef;\n+                    NumIndices: c_uint) -> ValueRef;\n     fn LLVMConstInBoundsGEP(ConstantVal: ValueRef, ConstantIndices: *uint,\n-                            NumIndices: unsigned) -> ValueRef;\n+                            NumIndices: c_uint) -> ValueRef;\n     fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n     fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n     fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n@@ -413,10 +413,10 @@ native mod llvm {\n                               VectorBConstant: ValueRef,\n                               MaskConstant: ValueRef) -> ValueRef;\n     fn LLVMConstExtractValue(AggConstant: ValueRef, IdxList: *uint,\n-                             NumIdx: unsigned) -> ValueRef;\n+                             NumIdx: c_uint) -> ValueRef;\n     fn LLVMConstInsertValue(AggConstant: ValueRef,\n                             ElementValueConstant: ValueRef, IdxList: *uint,\n-                            NumIdx: unsigned) -> ValueRef;\n+                            NumIdx: c_uint) -> ValueRef;\n     fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: sbuf, Constraints: sbuf,\n                           HasSideEffects: Bool, IsAlignStack: Bool) ->\n        ValueRef;\n@@ -427,20 +427,20 @@ native mod llvm {\n     /* Operations on global variables, functions, and aliases (globals) */\n     fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n     fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n-    fn LLVMGetLinkage(Global: ValueRef) -> unsigned;\n-    fn LLVMSetLinkage(Global: ValueRef, Link: unsigned);\n+    fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n+    fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n     fn LLVMGetSection(Global: ValueRef) -> sbuf;\n     fn LLVMSetSection(Global: ValueRef, Section: sbuf);\n-    fn LLVMGetVisibility(Global: ValueRef) -> unsigned;\n-    fn LLVMSetVisibility(Global: ValueRef, Viz: unsigned);\n-    fn LLVMGetAlignment(Global: ValueRef) -> unsigned;\n-    fn LLVMSetAlignment(Global: ValueRef, Bytes: unsigned);\n+    fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n+    fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n+    fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n+    fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n \n \n     /* Operations on global variables */\n     fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: sbuf) -> ValueRef;\n     fn LLVMAddGlobalInAddressSpace(M: ModuleRef, Ty: TypeRef, Name: sbuf,\n-                                   AddressSpace: unsigned) -> ValueRef;\n+                                   AddressSpace: c_uint) -> ValueRef;\n     fn LLVMGetNamedGlobal(M: ModuleRef, Name: sbuf) -> ValueRef;\n     fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n     fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n@@ -469,35 +469,35 @@ native mod llvm {\n     fn LLVMDeleteFunction(Fn: ValueRef);\n     fn LLVMGetOrInsertFunction(M: ModuleRef, Name: sbuf, FunctionTy: TypeRef)\n        -> ValueRef;\n-    fn LLVMGetIntrinsicID(Fn: ValueRef) -> unsigned;\n-    fn LLVMGetFunctionCallConv(Fn: ValueRef) -> unsigned;\n-    fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: unsigned);\n+    fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n+    fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n+    fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n     fn LLVMGetGC(Fn: ValueRef) -> sbuf;\n     fn LLVMSetGC(Fn: ValueRef, Name: sbuf);\n-    fn LLVMAddFunctionAttr(Fn: ValueRef, PA: unsigned, HighPA: unsigned);\n-    fn LLVMGetFunctionAttr(Fn: ValueRef) -> unsigned;\n-    fn LLVMRemoveFunctionAttr(Fn: ValueRef, PA: unsigned, HighPA: unsigned);\n+    fn LLVMAddFunctionAttr(Fn: ValueRef, PA: c_uint, HighPA: c_uint);\n+    fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n+    fn LLVMRemoveFunctionAttr(Fn: ValueRef, PA: c_uint, HighPA: c_uint);\n \n     /* Operations on parameters */\n-    fn LLVMCountParams(Fn: ValueRef) -> unsigned;\n+    fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n     fn LLVMGetParams(Fn: ValueRef, Params: *ValueRef);\n-    fn LLVMGetParam(Fn: ValueRef, Index: unsigned) -> ValueRef;\n+    fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n     fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n     fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n     fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n     fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n     fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n-    fn LLVMAddAttribute(Arg: ValueRef, PA: unsigned);\n-    fn LLVMRemoveAttribute(Arg: ValueRef, PA: unsigned);\n-    fn LLVMGetAttribute(Arg: ValueRef) -> unsigned;\n-    fn LLVMSetParamAlignment(Arg: ValueRef, align: unsigned);\n+    fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n+    fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n+    fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n+    fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n \n     /* Operations on basic blocks */\n     fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n     fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n     fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n     fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n-    fn LLVMCountBasicBlocks(Fn: ValueRef) -> unsigned;\n+    fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n     fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *ValueRef);\n     fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n     fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n@@ -523,25 +523,25 @@ native mod llvm {\n     fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n \n     /* Operations on call sites */\n-    fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: unsigned);\n-    fn LLVMGetInstructionCallConv(Instr: ValueRef) -> unsigned;\n-    fn LLVMAddInstrAttribute(Instr: ValueRef, index: unsigned, IA: unsigned);\n-    fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: unsigned,\n-                                IA: unsigned);\n-    fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: unsigned,\n-                                  align: unsigned);\n+    fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n+    fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n+    fn LLVMAddInstrAttribute(Instr: ValueRef, index: c_uint, IA: c_uint);\n+    fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: c_uint,\n+                                IA: c_uint);\n+    fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: c_uint,\n+                                  align: c_uint);\n \n     /* Operations on call instructions (only) */\n     fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n     fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n \n     /* Operations on phi nodes */\n     fn LLVMAddIncoming(PhiNode: ValueRef, IncomingValues: *ValueRef,\n-                       IncomingBlocks: *BasicBlockRef, Count: unsigned);\n-    fn LLVMCountIncoming(PhiNode: ValueRef) -> unsigned;\n-    fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: unsigned) -> ValueRef;\n+                       IncomingBlocks: *BasicBlockRef, Count: c_uint);\n+    fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n+    fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint) -> ValueRef;\n     fn LLVMGetIncomingBlock(PhiNode: ValueRef,\n-                            Index: unsigned) -> BasicBlockRef;\n+                            Index: c_uint) -> BasicBlockRef;\n \n     /* Instruction builders */\n     fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n@@ -566,19 +566,19 @@ native mod llvm {\n     fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n     fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n     fn LLVMBuildAggregateRet(B: BuilderRef, RetVals: *ValueRef,\n-                             N: unsigned) -> ValueRef;\n+                             N: c_uint) -> ValueRef;\n     fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n     fn LLVMBuildCondBr(B: BuilderRef, If: ValueRef, Then: BasicBlockRef,\n                        Else: BasicBlockRef) -> ValueRef;\n     fn LLVMBuildSwitch(B: BuilderRef, V: ValueRef, Else: BasicBlockRef,\n-                       NumCases: unsigned) -> ValueRef;\n+                       NumCases: c_uint) -> ValueRef;\n     fn LLVMBuildIndirectBr(B: BuilderRef, Addr: ValueRef,\n-                           NumDests: unsigned) -> ValueRef;\n+                           NumDests: c_uint) -> ValueRef;\n     fn LLVMBuildInvoke(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n-                       NumArgs: unsigned, Then: BasicBlockRef,\n+                       NumArgs: c_uint, Then: BasicBlockRef,\n                        Catch: BasicBlockRef, Name: sbuf) -> ValueRef;\n     fn LLVMBuildLandingPad(B: BuilderRef, Ty: TypeRef, PersFn: ValueRef,\n-                           NumClauses: unsigned, Name: sbuf) -> ValueRef;\n+                           NumClauses: c_uint, Name: sbuf) -> ValueRef;\n     fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n     fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n \n@@ -666,12 +666,12 @@ native mod llvm {\n     fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef) ->\n        ValueRef;\n     fn LLVMBuildGEP(B: BuilderRef, Pointer: ValueRef, Indices: *ValueRef,\n-                    NumIndices: unsigned, Name: sbuf) -> ValueRef;\n+                    NumIndices: c_uint, Name: sbuf) -> ValueRef;\n     fn LLVMBuildInBoundsGEP(B: BuilderRef, Pointer: ValueRef,\n-                            Indices: *ValueRef, NumIndices: unsigned,\n+                            Indices: *ValueRef, NumIndices: c_uint,\n                             Name: sbuf)\n        -> ValueRef;\n-    fn LLVMBuildStructGEP(B: BuilderRef, Pointer: ValueRef, Idx: unsigned,\n+    fn LLVMBuildStructGEP(B: BuilderRef, Pointer: ValueRef, Idx: c_uint,\n                           Name: sbuf) -> ValueRef;\n     fn LLVMBuildGlobalString(B: BuilderRef, Str: sbuf, Name: sbuf) ->\n        ValueRef;\n@@ -719,15 +719,15 @@ native mod llvm {\n                        Name: sbuf) -> ValueRef;\n \n     /* Comparisons */\n-    fn LLVMBuildICmp(B: BuilderRef, Op: unsigned, LHS: ValueRef,\n+    fn LLVMBuildICmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n                      RHS: ValueRef, Name: sbuf) -> ValueRef;\n-    fn LLVMBuildFCmp(B: BuilderRef, Op: unsigned, LHS: ValueRef,\n+    fn LLVMBuildFCmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n                      RHS: ValueRef, Name: sbuf) -> ValueRef;\n \n     /* Miscellaneous instructions */\n     fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: sbuf) -> ValueRef;\n     fn LLVMBuildCall(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n-                     NumArgs: unsigned, Name: sbuf) -> ValueRef;\n+                     NumArgs: c_uint, Name: sbuf) -> ValueRef;\n     fn LLVMBuildSelect(B: BuilderRef, If: ValueRef, Then: ValueRef,\n                        Else: ValueRef, Name: sbuf) -> ValueRef;\n     fn LLVMBuildVAArg(B: BuilderRef, list: ValueRef, Ty: TypeRef, Name: sbuf)\n@@ -739,10 +739,10 @@ native mod llvm {\n        -> ValueRef;\n     fn LLVMBuildShuffleVector(B: BuilderRef, V1: ValueRef, V2: ValueRef,\n                               Mask: ValueRef, Name: sbuf) -> ValueRef;\n-    fn LLVMBuildExtractValue(B: BuilderRef, AggVal: ValueRef, Index: unsigned,\n+    fn LLVMBuildExtractValue(B: BuilderRef, AggVal: ValueRef, Index: c_uint,\n                              Name: sbuf) -> ValueRef;\n     fn LLVMBuildInsertValue(B: BuilderRef, AggVal: ValueRef, EltVal: ValueRef,\n-                            Index: unsigned, Name: sbuf) -> ValueRef;\n+                            Index: c_uint, Name: sbuf) -> ValueRef;\n \n     fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: sbuf) -> ValueRef;\n     fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: sbuf) ->\n@@ -761,11 +761,11 @@ native mod llvm {\n     /** Adds the target data to the given pass manager. The pass manager\n         references the target data only weakly. */\n     fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n-    /** Returns the size of a type. FIXME: rv is actually a ULongLong! */\n-    fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef) -> unsigned;\n+    /** Returns the size of a type. FIXME: rv is actually a C_Ulonglong! */\n+    fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n     /** Returns the alignment of a type. */\n     fn LLVMPreferredAlignmentOfType(TD: TargetDataRef,\n-                                    Ty: TypeRef) -> unsigned;\n+                                    Ty: TypeRef) -> c_uint;\n     /** Disposes target data. */\n     fn LLVMDisposeTargetData(TD: TargetDataRef);\n \n@@ -818,7 +818,7 @@ native mod llvm {\n     fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n     fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n     fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n-                                         OptimizationLevel: unsigned);\n+                                         OptimizationLevel: c_uint);\n     fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n                                           Value: Bool);\n     fn LLVMPassManagerBuilderSetDisableUnitAtATime(PMB: PassManagerBuilderRef,\n@@ -828,7 +828,7 @@ native mod llvm {\n     fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls\n         (PMB: PassManagerBuilderRef, Value: Bool);\n     fn LLVMPassManagerBuilderUseInlinerWithThreshold\n-        (PMB: PassManagerBuilderRef, threshold: unsigned);\n+        (PMB: PassManagerBuilderRef, threshold: c_uint);\n     fn LLVMPassManagerBuilderPopulateModulePassManager\n         (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n@@ -859,7 +859,7 @@ native mod llvm {\n     /** Returns the current section name. */\n     fn LLVMGetSectionName(SI: SectionIteratorRef) -> sbuf;\n     /** Returns the current section size. */\n-    fn LLVMGetSectionSize(SI: SectionIteratorRef) -> ulonglong;\n+    fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n     /** Returns the current section contents as a string buffer. */\n     fn LLVMGetSectionContents(SI: SectionIteratorRef) -> sbuf;\n \n@@ -883,8 +883,8 @@ native mod llvm {\n     /** Parses LLVM asm in the given file */\n     fn LLVMRustParseAssemblyFile(Filename: sbuf) -> ModuleRef;\n \n-    /** FiXME: Hacky adaptor for lack of ULongLong in FFI: */\n-    fn LLVMRustConstInt(IntTy: TypeRef, N_hi: unsigned, N_lo: unsigned,\n+    /** FiXME: Hacky adaptor for lack of c_ulonglong in FFI: */\n+    fn LLVMRustConstInt(IntTy: TypeRef, N_hi: c_uint, N_lo: c_uint,\n                         SignExtend: Bool) -> ValueRef;\n \n     fn LLVMRustAddPrintModulePass(PM: PassManagerRef, M: ModuleRef,\n@@ -899,24 +899,24 @@ native mod llvm {\n     fn LLVMStructCreateNamed(C: ContextRef, Name: sbuf) -> TypeRef;\n \n     fn LLVMStructSetBody(StructTy: TypeRef, ElementTypes: *TypeRef,\n-                         ElementCount: unsigned, Packed: Bool);\n+                         ElementCount: c_uint, Packed: Bool);\n \n     fn LLVMConstNamedStruct(S: TypeRef, ConstantVals: *ValueRef,\n-                            Count: unsigned) -> ValueRef;\n+                            Count: c_uint) -> ValueRef;\n \n     /** Links LLVM modules together. `Src` is destroyed by this call and\n         must never be referenced again. */\n     fn LLVMLinkModules(Dest: ModuleRef, Src: ModuleRef) -> Bool;\n }\n \n fn SetInstructionCallConv(Instr: ValueRef, CC: CallConv) {\n-    llvm::LLVMSetInstructionCallConv(Instr, CC as unsigned);\n+    llvm::LLVMSetInstructionCallConv(Instr, CC as c_uint);\n }\n fn SetFunctionCallConv(Fn: ValueRef, CC: CallConv) {\n-    llvm::LLVMSetFunctionCallConv(Fn, CC as unsigned);\n+    llvm::LLVMSetFunctionCallConv(Fn, CC as c_uint);\n }\n fn SetLinkage(Global: ValueRef, Link: Linkage) {\n-    llvm::LLVMSetLinkage(Global, Link as unsigned);\n+    llvm::LLVMSetLinkage(Global, Link as c_uint);\n }\n \n /* Memory-managed object interface to type handles. */"}, {"sha": "606053914b1b2033478703664ab96a3702d4ac10", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -24,7 +24,6 @@ import c = common;\n import e = encoder;\n \n // used in testing:\n-import std::io;\n import driver::diagnostic;\n import syntax::codemap;\n import syntax::parse::parser;"}, {"sha": "c5b8e4c45c4e9365ac37a1dfb7b581461db217ae", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -8,7 +8,6 @@ import front::attr;\n import syntax::visit;\n import syntax::codemap::span;\n import util::{filesearch};\n-import std::{io, fs};\n import io::writer_util;\n import std::map::{hashmap, new_int_hash};\n import syntax::print::pprust;\n@@ -178,7 +177,7 @@ fn find_library_crate_aux(sess: session::session,\n \n     ret filesearch::search(filesearch, { |path|\n         #debug(\"inspecting file %s\", path);\n-        let f: str = fs::basename(path);\n+        let f: str = path::basename(path);\n         if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n             #debug(\"skipping %s, doesn't look like %s*%s\", path, prefix,\n                    suffix);"}, {"sha": "6b5169a5296640ea7fca72e5dcd360a7f48f83e3", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,6 +1,6 @@\n // Decoding metadata from a single crate's metadata\n \n-import std::{ebml, map, io};\n+import std::{ebml, map};\n import std::map::hashmap;\n import io::writer_util;\n import syntax::{ast, ast_util};"}, {"sha": "9f36fd6cd1731ca03ad9636897a548392ee415dd", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,6 +1,6 @@\n // Metadata encoding\n \n-import std::{io, ebml, map, list};\n+import std::{ebml, map, list};\n import std::map::hashmap;\n import io::writer_util;\n import ebml::writer;"}, {"sha": "92ede8890166d0c4f839bf3e9536ff5e2669a673", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,6 +1,5 @@\n // Type encoding\n \n-import std::io;\n import io::writer_util;\n import std::map::hashmap;\n import syntax::ast::*;"}, {"sha": "282a1a32f6a8cc65daa58a131a87fe1eee3abb26", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -2,7 +2,6 @@ import driver::session::session;\n import middle::ty::ctxt;\n import syntax::{ast, visit};\n import front::attr;\n-import std::io;\n import std::map::hashmap;\n import io::writer_util;\n \n@@ -106,13 +105,13 @@ fn check_ctypes(tcx: ty::ctxt, crate: @ast::crate) {\n                     tcx.sess.span_warn(\n                         ty.span,\n                         \"found rust type `int` in native module, while \\\n-                         ctypes::c_int or ctypes::long should be used\");\n+                         libc::c_int or libc::c_long should be used\");\n                   }\n                   ast::def_prim_ty(ast::ty_uint(ast::ty_u)) {\n                     tcx.sess.span_warn(\n                         ty.span,\n                         \"found rust type `uint` in native module, while \\\n-                         ctypes::c_uint or ctypes::ulong should be used\");\n+                         libc::c_uint or libc::c_ulong should be used\");\n                   }\n                   _ { }\n                 }"}, {"sha": "62fa134b2836a2d013b0ace9d0b7f24797fd2fea", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -13,7 +13,7 @@\n //     but many TypeRefs correspond to one ty::t; for instance, tup(int, int,\n //     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n-import ctypes::c_uint;\n+import libc::c_uint;\n import std::{map, time};\n import std::map::hashmap;\n import std::map::{new_int_hash, new_str_hash};"}, {"sha": "46449b2363beace8d0603cb041d8861e7abd3d00", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,4 +1,4 @@\n-import ctypes::{c_uint, c_int};\n+import libc::{c_uint, c_int};\n import str::sbuf;\n import lib::llvm::llvm;\n import syntax::codemap;"}, {"sha": "25215be9ef906d1b7c46ab4f8e6519e3e81cef25", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,4 +1,4 @@\n-import core::ctypes::c_uint;\n+import libc::c_uint;\n import syntax::ast;\n import syntax::ast_util;\n import lib::llvm::llvm;"}, {"sha": "64ed01f80f6fbde3e206d27e6f5091214d67b3a7", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -3,7 +3,7 @@\n \n */\n \n-import ctypes::unsigned;\n+import libc::c_uint;\n import vec::unsafe::to_ptr;\n import std::map::hashmap;\n import syntax::ast;\n@@ -512,7 +512,7 @@ fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n \n fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef unsafe {\n     ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n-                               inputs.len() as unsigned,\n+                               inputs.len() as c_uint,\n                                False);\n }\n \n@@ -521,11 +521,11 @@ fn T_fn_pair(cx: crate_ctxt, tfn: TypeRef) -> TypeRef {\n }\n \n fn T_ptr(t: TypeRef) -> TypeRef {\n-    ret llvm::LLVMPointerType(t, 0u as unsigned);\n+    ret llvm::LLVMPointerType(t, 0u as c_uint);\n }\n \n fn T_struct(elts: [TypeRef]) -> TypeRef unsafe {\n-    ret llvm::LLVMStructType(to_ptr(elts), elts.len() as unsigned, False);\n+    ret llvm::LLVMStructType(to_ptr(elts), elts.len() as c_uint, False);\n }\n \n fn T_named_struct(name: str) -> TypeRef {\n@@ -535,7 +535,7 @@ fn T_named_struct(name: str) -> TypeRef {\n \n fn set_struct_body(t: TypeRef, elts: [TypeRef]) unsafe {\n     llvm::LLVMStructSetBody(t, to_ptr(elts),\n-                            elts.len() as unsigned, False);\n+                            elts.len() as c_uint, False);\n }\n \n fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n@@ -607,7 +607,7 @@ fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n }\n \n fn T_array(t: TypeRef, n: uint) -> TypeRef {\n-    ret llvm::LLVMArrayType(t, n as unsigned);\n+    ret llvm::LLVMArrayType(t, n as c_uint);\n }\n \n // Interior vector.\n@@ -740,8 +740,8 @@ fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n fn C_null(t: TypeRef) -> ValueRef { ret llvm::LLVMConstNull(t); }\n \n fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n-    let u_hi = (u >> 32u64) as unsigned;\n-    let u_lo = u as unsigned;\n+    let u_hi = (u >> 32u64) as c_uint;\n+    let u_lo = u as c_uint;\n     ret llvm::LLVMRustConstInt(t, u_hi, u_lo, sign_extend);\n }\n \n@@ -784,7 +784,7 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i as u64, False); }\n // our boxed-and-length-annotated strings.\n fn C_cstr(cx: crate_ctxt, s: str) -> ValueRef {\n     let sc = str::as_buf(s) {|buf|\n-        llvm::LLVMConstString(buf, str::len(s) as unsigned, False)\n+        llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n     let g =\n         str::as_buf(cx.names(\"str\"),\n@@ -798,7 +798,7 @@ fn C_cstr(cx: crate_ctxt, s: str) -> ValueRef {\n // Returns a Plain Old LLVM String:\n fn C_postr(s: str) -> ValueRef {\n     ret str::as_buf(s) {|buf|\n-        llvm::LLVMConstString(buf, str::len(s) as unsigned, False)\n+        llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n }\n \n@@ -807,28 +807,28 @@ fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n     let elts: [ValueRef] = [];\n     while i < size { elts += [C_u8(0u)]; i += 1u; }\n     ret llvm::LLVMConstArray(T_i8(), vec::unsafe::to_ptr(elts),\n-                             elts.len() as unsigned);\n+                             elts.len() as c_uint);\n }\n \n fn C_struct(elts: [ValueRef]) -> ValueRef unsafe {\n     ret llvm::LLVMConstStruct(vec::unsafe::to_ptr(elts),\n-                              elts.len() as unsigned, False);\n+                              elts.len() as c_uint, False);\n }\n \n fn C_named_struct(T: TypeRef, elts: [ValueRef]) -> ValueRef unsafe {\n     ret llvm::LLVMConstNamedStruct(T, vec::unsafe::to_ptr(elts),\n-                                   elts.len() as unsigned);\n+                                   elts.len() as c_uint);\n }\n \n fn C_array(ty: TypeRef, elts: [ValueRef]) -> ValueRef unsafe {\n     ret llvm::LLVMConstArray(ty, vec::unsafe::to_ptr(elts),\n-                             elts.len() as unsigned);\n+                             elts.len() as c_uint);\n }\n \n fn C_bytes(bytes: [u8]) -> ValueRef unsafe {\n     ret llvm::LLVMConstString(\n         unsafe::reinterpret_cast(vec::unsafe::to_ptr(bytes)),\n-        bytes.len() as unsigned, False);\n+        bytes.len() as c_uint, False);\n }\n \n fn C_shape(ccx: crate_ctxt, bytes: [u8]) -> ValueRef {"}, {"sha": "6daa980b0adf8a533a22eeff10e3c4dd39c0cec0", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,4 +1,3 @@\n-import std::fs;\n import std::map::hashmap;\n import lib::llvm::llvm;\n import lib::llvm::ValueRef;\n@@ -48,7 +47,7 @@ const DW_ATE_unsigned_char: int = 0x08;\n \n fn llstr(s: str) -> ValueRef {\n     str::as_buf(s, {|sbuf|\n-        llvm::LLVMMDString(sbuf, str::len(s) as ctypes::c_uint)\n+        llvm::LLVMMDString(sbuf, str::len(s) as libc::c_uint)\n     })\n }\n fn lltag(lltag: int) -> ValueRef {\n@@ -65,7 +64,7 @@ fn lli1(bval: bool) -> ValueRef {\n }\n fn llmdnode(elems: [ValueRef]) -> ValueRef unsafe {\n     llvm::LLVMMDNode(vec::unsafe::to_ptr(elems),\n-                     vec::len(elems) as ctypes::c_uint)\n+                     vec::len(elems) as libc::c_uint)\n }\n fn llunused() -> ValueRef {\n     lli32(0x0)\n@@ -206,8 +205,8 @@ fn create_file(cx: crate_ctxt, full_path: str) -> @metadata<file_md> {\n         option::none {}\n     }\n \n-    let fname = fs::basename(full_path);\n-    let path = fs::dirname(full_path);\n+    let fname = path::basename(full_path);\n+    let path = path::dirname(full_path);\n     let unit_node = create_compile_unit(cx, full_path).node;\n     let file_md = [lltag(tg),\n                    llstr(fname),\n@@ -337,7 +336,7 @@ fn create_pointer_type(cx: crate_ctxt, t: ty::t, span: span,\n       option::some(md) { ret md; }\n       option::none {}\n     }*/\n-    let (size, align) = size_and_align_of::<ctypes::intptr_t>();\n+    let (size, align) = size_and_align_of::<libc::intptr_t>();\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     //let cu_node = create_compile_unit(cx, fname);\n@@ -488,10 +487,10 @@ fn create_vec(cx: crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     let scx = create_structure(file_node, ty_to_str(cx.tcx, vec_t), 0);\n     let size_t_type = create_basic_type(cx, ty::mk_uint(cx.tcx),\n                                         ast::ty_uint(ast::ty_u), vec_ty_span);\n-    add_member(scx, \"fill\", 0, sys::size_of::<ctypes::size_t>() as int,\n-               sys::align_of::<ctypes::size_t>() as int, size_t_type.node);\n-    add_member(scx, \"alloc\", 0, sys::size_of::<ctypes::size_t>() as int,\n-               sys::align_of::<ctypes::size_t>() as int, size_t_type.node);\n+    add_member(scx, \"fill\", 0, sys::size_of::<libc::size_t>() as int,\n+               sys::align_of::<libc::size_t>() as int, size_t_type.node);\n+    add_member(scx, \"alloc\", 0, sys::size_of::<libc::size_t>() as int,\n+               sys::align_of::<libc::size_t>() as int, size_t_type.node);\n     let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(0)]);\n     let (arr_size, arr_align) = member_size_and_align(cx.tcx, elem_ty);\n     let data_ptr = create_composite_type(ArrayTypeTag, \"\", file_node.node, 0,\n@@ -536,7 +535,7 @@ fn member_size_and_align(tcx: ty::ctxt, ty: @ast::ty) -> (int, int) {\n         }\n       }\n       ast::ty_box(_) | ast::ty_uniq(_) {\n-        size_and_align_of::<ctypes::uintptr_t>()\n+        size_and_align_of::<libc::uintptr_t>()\n       }\n       ast::ty_rec(fields) {\n         let total_size = 0;\n@@ -547,7 +546,7 @@ fn member_size_and_align(tcx: ty::ctxt, ty: @ast::ty) -> (int, int) {\n         (total_size, 64) //XXX different align for other arches?\n       }\n       ast::ty_vec(_) {\n-        size_and_align_of::<ctypes::uintptr_t>()\n+        size_and_align_of::<libc::uintptr_t>()\n       }\n       _ { fail \"member_size_and_align: can't handle this type\"; }\n     }"}, {"sha": "ee8c2449f379450195c76de5b199752bf87a98d3", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,4 +1,4 @@\n-import ctypes::c_uint;\n+import libc::c_uint;\n import base::*;\n import common::*;\n import type_of::*;"}, {"sha": "20ffa345271684982fb5562e3b2a8f05e06eefb7", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,6 +1,6 @@\n import driver::session::session;\n import syntax::codemap::span;\n-import ctypes::c_uint;\n+import libc::c_uint;\n import front::attr;\n import lib::llvm::{ llvm, TypeRef, ValueRef };\n import syntax::ast;"}, {"sha": "c4ef1abc3e6b4ab42251430131e1156001f50b88", "filename": "src/rustc/syntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fenv.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -4,7 +4,6 @@\n  * should all get sucked into either the compiler syntax extension plugin\n  * interface.\n  */\n-import std::generic_os;\n import base::*;\n export expand_syntax_ext;\n \n@@ -25,7 +24,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     // option<str> rather than just an maybe-empty string.\n \n     let var = expr_to_str(cx, args[0], \"#env requires a string\");\n-    alt generic_os::getenv(var) {\n+    alt os::getenv(var) {\n       option::none { ret make_new_str(cx, sp, \"\"); }\n       option::some(s) { ret make_new_str(cx, sp, s); }\n     }"}, {"sha": "23364adb744cc4bdc88d6e7d38752256c99c092e", "filename": "src/rustc/syntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Flog_syntax.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,12 +1,12 @@\n import base::*;\n import syntax::ast;\n-import std::io::writer_util;\n+import io::writer_util;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n     let arg = get_mac_arg(cx,sp,arg);\n     cx.print_backtrace();\n-    std::io::stdout().write_line(print::pprust::expr_to_str(arg));\n+    io::stdout().write_line(print::pprust::expr_to_str(arg));\n \n     //trivial expression\n     ret @{id: cx.next_id(), node: ast::expr_rec([], option::none), span: sp};"}, {"sha": "afcae2ff6908dcbdbf82e4eca5fce72d310d5fa4", "filename": "src/rustc/syntax/ext/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -10,7 +10,7 @@ import syntax::parse::parser;\n import syntax::parse::parser::{parser, parse_from_source_str};\n \n import syntax::print::*;\n-import std::io::*;\n+import io::*;\n \n import codemap::span;\n \n@@ -318,7 +318,7 @@ fn replace_ty(repls: [fragment],\n }\n \n fn print_expr(expr: @ast::expr) {\n-    let stdout = std::io::stdout();\n+    let stdout = io::stdout();\n     let pp = pprust::rust_printer(stdout);\n     pprust::print_expr(pp, expr);\n     pp::eof(pp.s);"}, {"sha": "57a91f4a32e818046b1f90603a5b28bd70d35dc8", "filename": "src/rustc/syntax/parse/eval.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Feval.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,6 +1,4 @@\n-\n import front::attr;\n-import std::{io, fs};\n import syntax::ast;\n import syntax::parse::token;\n import syntax::parse::parser::{parser, new_parser_from_file,\n@@ -53,7 +51,7 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n \n     fn companion_file(prefix: str, suffix: option<str>) -> str {\n         ret alt suffix {\n-          option::some(s) { fs::connect(prefix, s) }\n+          option::some(s) { path::connect(prefix, s) }\n           option::none { prefix }\n         } + \".rs\";\n     }\n@@ -100,9 +98,9 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n       ast::cdir_src_mod(id, attrs) {\n         let file_path = cdir_path_opt(id + \".rs\", attrs);\n         let full_path =\n-            if std::fs::path_is_absolute(file_path) {\n+            if path::path_is_absolute(file_path) {\n                 file_path\n-            } else { prefix + std::fs::path_sep() + file_path };\n+            } else { prefix + path::path_sep() + file_path };\n         let p0 =\n             new_parser_from_file(cx.sess, cx.cfg, full_path, SOURCE_FILE);\n         let inner_attrs = parse_inner_attrs_and_next(p0);\n@@ -121,9 +119,9 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n       ast::cdir_dir_mod(id, cdirs, attrs) {\n         let path = cdir_path_opt(id, attrs);\n         let full_path =\n-            if std::fs::path_is_absolute(path) {\n+            if path::path_is_absolute(path) {\n                 path\n-            } else { prefix + std::fs::path_sep() + path };\n+            } else { prefix + path::path_sep() + path };\n         let (m0, a0) = eval_crate_directives_to_mod(\n             cx, cdirs, full_path, none);\n         let i ="}, {"sha": "b1fbf1bf7a4e8c54a9f72225fad9d4b6ed4bc440", "filename": "src/rustc/syntax/parse/lexer.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,5 +1,3 @@\n-\n-import std::io;\n import io::reader_util;\n import util::interner;\n import util::interner::intern;"}, {"sha": "6fd61bc9db4e667ed416bec193d33b11d9a36c48", "filename": "src/rustc/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,4 +1,3 @@\n-import std::{io, fs};\n import either::{left, right};\n import std::map::{hashmap, new_str_hash};\n import token::can_begin_expr;\n@@ -2771,7 +2770,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n                                sess: parse_sess) -> @ast::crate {\n     let p = new_parser_from_file(sess, cfg, input, CRATE_FILE);\n     let lo = p.span.lo;\n-    let prefix = std::fs::dirname(p.reader.filemap.name);\n+    let prefix = path::dirname(p.reader.filemap.name);\n     let leading_attrs = parse_inner_attrs_and_next(p);\n     let crate_attrs = leading_attrs.inner;\n     let first_cdir_attr = leading_attrs.next;\n@@ -2782,7 +2781,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n         @{p: p,\n           sess: sess,\n           cfg: p.cfg};\n-    let (companionmod, _) = fs::splitext(fs::basename(input));\n+    let (companionmod, _) = path::splitext(path::basename(input));\n     let (m, attrs) = eval::eval_crate_directives_to_mod(\n         cx, cdirs, prefix, option::some(companionmod));\n     let hi = p.span.hi;"}, {"sha": "e5d295e1a60b2c847bfd150074a02b30d361f72c", "filename": "src/rustc/syntax/print/pp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fprint%2Fpp.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,5 +1,3 @@\n-\n-import std::io;\n import io::writer_util;\n \n /*"}, {"sha": "ec592cda700d65c3f482ac43b7e35f43ffc97bb4", "filename": "src/rustc/syntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,5 +1,3 @@\n-\n-import std::io;\n import parse::lexer;\n import syntax::codemap::codemap;\n import pp::{break_offset, word, printer,"}, {"sha": "82469b5cb325ee03b9e43657b6ea4d3f4dd534f6", "filename": "src/rustc/util/filesearch.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustc%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Ffilesearch.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -2,8 +2,6 @@\n // FIXME: I'm not happy how this module turned out. Should probably\n // just be folded into cstore.\n \n-import std::{fs, os, generic_os};\n-\n export filesearch;\n export mk_filesearch;\n export pick;\n@@ -15,29 +13,31 @@ export get_cargo_root;\n export get_cargo_root_nearest;\n export libdir;\n \n-type pick<T> = fn(path: fs::path) -> option<T>;\n+import path::path;\n+\n+type pick<T> = fn(path: path) -> option<T>;\n \n-fn pick_file(file: fs::path, path: fs::path) -> option<fs::path> {\n-    if fs::basename(path) == file { option::some(path) }\n+fn pick_file(file: path, path: path) -> option<path> {\n+    if path::basename(path) == file { option::some(path) }\n     else { option::none }\n }\n \n iface filesearch {\n-    fn sysroot() -> fs::path;\n-    fn lib_search_paths() -> [fs::path];\n-    fn get_target_lib_path() -> fs::path;\n-    fn get_target_lib_file_path(file: fs::path) -> fs::path;\n+    fn sysroot() -> path;\n+    fn lib_search_paths() -> [path];\n+    fn get_target_lib_path() -> path;\n+    fn get_target_lib_file_path(file: path) -> path;\n }\n \n-fn mk_filesearch(maybe_sysroot: option<fs::path>,\n+fn mk_filesearch(maybe_sysroot: option<path>,\n                  target_triple: str,\n-                 addl_lib_search_paths: [fs::path]) -> filesearch {\n-    type filesearch_impl = {sysroot: fs::path,\n-                            addl_lib_search_paths: [fs::path],\n+                 addl_lib_search_paths: [path]) -> filesearch {\n+    type filesearch_impl = {sysroot: path,\n+                            addl_lib_search_paths: [path],\n                             target_triple: str};\n     impl of filesearch for filesearch_impl {\n-        fn sysroot() -> fs::path { self.sysroot }\n-        fn lib_search_paths() -> [fs::path] {\n+        fn sysroot() -> path { self.sysroot }\n+        fn lib_search_paths() -> [path] {\n             self.addl_lib_search_paths\n                 + [make_target_lib_path(self.sysroot, self.target_triple)]\n                 + alt get_cargo_lib_path_nearest() {\n@@ -49,11 +49,11 @@ fn mk_filesearch(maybe_sysroot: option<fs::path>,\n                   result::err(p) { [] }\n                 }\n         }\n-        fn get_target_lib_path() -> fs::path {\n+        fn get_target_lib_path() -> path {\n             make_target_lib_path(self.sysroot, self.target_triple)\n         }\n-        fn get_target_lib_file_path(file: fs::path) -> fs::path {\n-            fs::connect(self.get_target_lib_path(), file)\n+        fn get_target_lib_file_path(file: path) -> path {\n+            path::connect(self.get_target_lib_path(), file)\n         }\n     }\n \n@@ -68,7 +68,7 @@ fn mk_filesearch(maybe_sysroot: option<fs::path>,\n fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n     for lib_search_path in filesearch.lib_search_paths() {\n         #debug(\"searching %s\", lib_search_path);\n-        for path in fs::list_dir(lib_search_path) {\n+        for path in os::list_dir(lib_search_path) {\n             #debug(\"testing %s\", path);\n             let maybe_picked = pick(path);\n             if option::is_some(maybe_picked) {\n@@ -82,84 +82,84 @@ fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n     ret option::none;\n }\n \n-fn relative_target_lib_path(target_triple: str) -> [fs::path] {\n+fn relative_target_lib_path(target_triple: str) -> [path] {\n     [libdir(), \"rustc\", target_triple, libdir()]\n }\n \n-fn make_target_lib_path(sysroot: fs::path,\n-                        target_triple: str) -> fs::path {\n+fn make_target_lib_path(sysroot: path,\n+                        target_triple: str) -> path {\n     let path = [sysroot] + relative_target_lib_path(target_triple);\n-    let path = fs::connect_many(path);\n+    let path = path::connect_many(path);\n     ret path;\n }\n \n-fn get_default_sysroot() -> fs::path {\n-    alt os::get_exe_path() {\n-      option::some(p) { fs::normalize(fs::connect(p, \"..\")) }\n+fn get_default_sysroot() -> path {\n+    alt os::self_exe_path() {\n+      option::some(p) { path::normalize(path::connect(p, \"..\")) }\n       option::none {\n         fail \"can't determine value for sysroot\";\n       }\n     }\n }\n \n-fn get_sysroot(maybe_sysroot: option<fs::path>) -> fs::path {\n+fn get_sysroot(maybe_sysroot: option<path>) -> path {\n     alt maybe_sysroot {\n       option::some(sr) { sr }\n       option::none { get_default_sysroot() }\n     }\n }\n \n-fn get_cargo_sysroot() -> result::t<fs::path, str> {\n+fn get_cargo_sysroot() -> result::t<path, str> {\n     let path = [get_default_sysroot(), libdir(), \"cargo\"];\n-    result::ok(fs::connect_many(path))\n+    result::ok(path::connect_many(path))\n }\n \n-fn get_cargo_root() -> result::t<fs::path, str> {\n-    alt generic_os::getenv(\"CARGO_ROOT\") {\n+fn get_cargo_root() -> result::t<path, str> {\n+    alt os::getenv(\"CARGO_ROOT\") {\n         some(_p) { result::ok(_p) }\n         none {\n-          alt fs::homedir() {\n-            some(_q) { result::ok(fs::connect(_q, \".cargo\")) }\n+          alt os::homedir() {\n+            some(_q) { result::ok(path::connect(_q, \".cargo\")) }\n             none { result::err(\"no CARGO_ROOT or home directory\") }\n           }\n         }\n     }\n }\n \n-fn get_cargo_root_nearest() -> result::t<fs::path, str> {\n+fn get_cargo_root_nearest() -> result::t<path, str> {\n     result::chain(get_cargo_root()) { |p|\n         let cwd = os::getcwd();\n-        let dirname = fs::dirname(cwd);\n-        let dirpath = fs::split(dirname);\n-        let cwd_cargo = fs::connect(cwd, \".cargo\");\n-        let par_cargo = fs::connect(dirname, \".cargo\");\n+        let dirname = path::dirname(cwd);\n+        let dirpath = path::split(dirname);\n+        let cwd_cargo = path::connect(cwd, \".cargo\");\n+        let par_cargo = path::connect(dirname, \".cargo\");\n \n-        if fs::path_is_dir(cwd_cargo) || cwd_cargo == p {\n+        if os::path_is_dir(cwd_cargo) || cwd_cargo == p {\n             ret result::ok(cwd_cargo);\n         }\n \n         while vec::is_not_empty(dirpath) && par_cargo != p {\n-            if fs::path_is_dir(par_cargo) {\n+            if os::path_is_dir(par_cargo) {\n                 ret result::ok(par_cargo);\n             }\n             vec::pop(dirpath);\n-            dirname = fs::dirname(dirname);\n-            par_cargo = fs::connect(dirname, \".cargo\");\n+            dirname = path::dirname(dirname);\n+            par_cargo = path::connect(dirname, \".cargo\");\n         }\n \n         result::ok(cwd_cargo)\n     }\n }\n \n-fn get_cargo_lib_path() -> result::t<fs::path, str> {\n+fn get_cargo_lib_path() -> result::t<path, str> {\n     result::chain(get_cargo_root()) { |p|\n-        result::ok(fs::connect(p, libdir()))\n+        result::ok(path::connect(p, libdir()))\n     }\n }\n \n-fn get_cargo_lib_path_nearest() -> result::t<fs::path, str> {\n+fn get_cargo_lib_path_nearest() -> result::t<path, str> {\n     result::chain(get_cargo_root_nearest()) { |p|\n-        result::ok(fs::connect(p, libdir()))\n+        result::ok(path::connect(p, libdir()))\n     }\n }\n "}, {"sha": "88ffffaa212d7f1fcd16b1bde28c5023a8174bf1", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -54,7 +54,7 @@ fn opts() -> [(getopts::opt, str)] {\n }\n \n fn usage() {\n-    import std::io::println;\n+    import io::println;\n \n     println(\"Usage: rustdoc [options] <cratefile>\\n\");\n     println(\"Options:\\n\");\n@@ -87,7 +87,7 @@ fn mock_program_output(_prog: str, _args: [str]) -> {\n }\n \n fn parse_config(args: [str]) -> result::t<config, str> {\n-    parse_config_(args, std::run::program_output)\n+    parse_config_(args, run::program_output)\n }\n \n fn parse_config_("}, {"sha": "501b5b4384e6c5972d613b98cace384fd71ad7c7", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -79,10 +79,7 @@ fn pandoc_writer(\n     ];\n \n     generic_writer {|markdown|\n-        import std::run;\n-        import std::os;\n-        import std::io;\n-        import std::io::writer_util;\n+        import io::writer_util;\n \n         #debug(\"pandoc cmd: %s\", pandoc_cmd);\n         #debug(\"pandoc args: %s\", str::connect(pandoc_args, \" \"));\n@@ -126,12 +123,9 @@ fn pandoc_writer(\n     }\n }\n \n-fn readclose(fd: ctypes::fd_t) -> str {\n-    import std::os;\n-    import std::io;\n-\n+fn readclose(fd: libc::c_int) -> str {\n     // Copied from run::program_output\n-    let file = os::fd_FILE(fd);\n+    let file = os::fdopen(fd);\n     let reader = io::FILE_reader(file, false);\n     let buf = \"\";\n     while !reader.eof() {\n@@ -165,7 +159,7 @@ fn make_local_filename(\n     page: doc::page\n ) -> str {\n     let filename = make_filename(config, page);\n-    std::fs::connect(config.output_dir, filename)\n+    path::connect(config.output_dir, filename)\n }\n \n fn make_filename(\n@@ -251,8 +245,7 @@ mod test {\n }\n \n fn write_file(path: str, s: str) {\n-    import std::io;\n-    import std::io::writer_util;\n+    import io::writer_util;\n \n     alt io::file_writer(path, [io::create, io::truncate]) {\n       result::ok(writer) {"}, {"sha": "8c50b4920536207d5e4fe779cb6c64ac8c99b0c5", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -109,7 +109,7 @@ fn main(args: [str]) {\n     let config = alt config::parse_config(args) {\n       result::ok(config) { config }\n       result::err(err) {\n-        std::io::println(#fmt(\"error: %s\", err));\n+        io::println(#fmt(\"error: %s\", err));\n         ret;\n       }\n     };"}, {"sha": "472436b0d5e047a53c1cd169003c64ac7ce6ac9e", "filename": "src/serializer/serializer.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fserializer%2Fserializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Fserializer%2Fserializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fserializer.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -9,8 +9,7 @@ import rustc::middle::ast_map;\n import rustc::util::ppaux;\n import std::map::{hashmap, map, new_int_hash};\n import std::getopts;\n-import std::io;\n-import std::io::writer_util;\n+import io::writer_util;\n import driver::build_session_options;\n import driver::build_session;\n import driver::build_configuration;"}, {"sha": "bc8749f674d4a298ae1b8da26d850c961796f985", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -5,8 +5,8 @@\n // I *think* it's the same, more or less.\n \n use std;\n-import std::io::writer;\n-import std::io::writer_util;\n+import io::writer;\n+import io::writer_util;\n \n enum request {\n     get_count,\n@@ -52,10 +52,10 @@ fn run(args: [str]) {\n     let result = comm::recv(from_child);\n     let end = std::time::precise_time_s();\n     let elapsed = end - start;\n-    std::io::stdout().write_str(#fmt(\"Count is %?\\n\", result));\n-    std::io::stdout().write_str(#fmt(\"Test took %? seconds\\n\", elapsed));\n+    io::stdout().write_str(#fmt(\"Count is %?\\n\", result));\n+    io::stdout().write_str(#fmt(\"Test took %? seconds\\n\", elapsed));\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n-    std::io::stdout().write_str(#fmt(\"Throughput=%f per sec\\n\", thruput));\n+    io::stdout().write_str(#fmt(\"Throughput=%f per sec\\n\", thruput));\n }\n \n fn main(args: [str]) {"}, {"sha": "a27195eb900e5400e9e833bedd3f1c51a92df575", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -18,5 +18,5 @@ fn main(args: [str]) {\n     } else {\n         8\n     };\n-    std::io::println(#fmt(\"Ack(3,%d): %d\\n\", n, ack(3, n)));\n+    io::println(#fmt(\"Ack(3,%d): %d\\n\", n, ack(3, n)));\n }"}, {"sha": "eecdb2ee483848a5bf146aa2d45772359bee7fcb", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -31,7 +31,7 @@ fn main(args: [str]) {\n     } else { max_depth = n; }\n     let stretch_depth = max_depth + 1;\n     let stretch_tree = bottom_up_tree(0, stretch_depth);\n-    std::io::println(#fmt(\"stretch tree of depth %d\\t check: %d\",\n+    io::println(#fmt(\"stretch tree of depth %d\\t check: %d\",\n                           stretch_depth,\n                           item_check(stretch_tree)));\n     let long_lived_tree = bottom_up_tree(0, max_depth);\n@@ -47,12 +47,12 @@ fn main(args: [str]) {\n             chk += item_check(temp_tree);\n             i += 1;\n         }\n-        std::io::println(#fmt(\"%d\\t trees of depth %d\\t check: %d\",\n-                               iterations * 2, depth,\n-                               chk));\n+        io::println(#fmt(\"%d\\t trees of depth %d\\t check: %d\",\n+                         iterations * 2, depth,\n+                         chk));\n         depth += 2;\n     }\n-    std::io::println(#fmt(\"long lived trees of depth %d\\t check: %d\",\n-                          max_depth,\n+    io::println(#fmt(\"long lived trees of depth %d\\t check: %d\",\n+                     max_depth,\n                           item_check(long_lived_tree)));\n }"}, {"sha": "ac5b66209f0b180ae8148d845eeb59cebf24ba37", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -43,7 +43,7 @@ fn fannkuch(n: int) -> int {\n         let go = true;\n         while go {\n             if r == n {\n-                std::io::println(#fmt(\"%d\", checksum));\n+                io::println(#fmt(\"%d\", checksum));\n                 ret flips;\n             }\n             let p0 = perm1[0];\n@@ -64,5 +64,5 @@ fn main(args: [str]) {\n     } else {\n         8\n     };\n-    std::io::println(#fmt(\"Pfannkuchen(%d) = %d\", n, fannkuch(n)));\n+    io::println(#fmt(\"Pfannkuchen(%d) = %d\", n, fannkuch(n)));\n }"}, {"sha": "dbe5e17c985ce72c11fa9785a1a4541faa0b828f", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -14,5 +14,5 @@ fn main(args: [str]) {\n     } else {\n         30\n     };\n-    std::io::println(#fmt(\"%d\\n\", fib(n)));\n+    io::println(#fmt(\"%d\\n\", fib(n)));\n }"}, {"sha": "a34e0d39032bae90dfd3594e985ce052f7e2390f", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -13,7 +13,7 @@\n //  writes pbm image to output path\n \n use std;\n-import std::io::writer_util;\n+import io::writer_util;\n import std::map::hashmap;\n \n type cmplx = {re: f64, im: f64};\n@@ -79,9 +79,9 @@ fn chanmb(i: uint, size: uint, ch: comm::chan<line>) -> ()\n \n type devnull = {dn: int};\n \n-impl of std::io::writer for devnull {\n+impl of io::writer for devnull {\n     fn write(_b: [const u8]) {}\n-    fn seek(_i: int, _s: std::io::seek_style) {}\n+    fn seek(_i: int, _s: io::seek_style) {}\n     fn tell() -> uint {0_u}\n     fn flush() -> int {0}\n }\n@@ -91,17 +91,17 @@ fn writer(path: str, writech: comm::chan<comm::chan<line>>, size: uint)\n     let p: comm::port<line> = comm::port();\n     let ch = comm::chan(p);\n     comm::send(writech, ch);\n-    let cout: std::io::writer = alt path {\n+    let cout: io::writer = alt path {\n         \"\" {\n-            {dn: 0} as std::io::writer\n+            {dn: 0} as io::writer\n         }\n         \"-\" {\n-            std::io::stdout()\n+            io::stdout()\n         }\n         _ {\n             result::get(\n-                std::io::file_writer(path,\n-                [std::io::create, std::io::truncate]))\n+                io::file_writer(path,\n+                [io::create, io::truncate]))\n         }\n     };\n     cout.write_line(\"P4\");"}, {"sha": "cd51c10d64512ace7537f43d0f9dec1684164a68", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -20,10 +20,10 @@ fn main(args: [str]) {\n         100000\n     };\n     let bodies: [Body::props] = NBodySystem::MakeNBodySystem();\n-    std::io::println(#fmt(\"%f\", NBodySystem::energy(bodies)));\n+    io::println(#fmt(\"%f\", NBodySystem::energy(bodies)));\n     let i: int = 0;\n     while i < n { NBodySystem::advance(bodies, 0.01); i += 1; }\n-    std::io::println(#fmt(\"%f\", NBodySystem::energy(bodies)));\n+    io::println(#fmt(\"%f\", NBodySystem::energy(bodies)));\n }\n \n // Body::props is a record of floats, so"}, {"sha": "c8f239ce884311e426375a26d98aab75c901398b", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -12,7 +12,7 @@\n \n use std;\n \n-import std::{time, io, getopts};\n+import std::{time, getopts};\n import io::writer_util;\n import int::range;\n import comm::port;"}, {"sha": "05687f2f03e877dc01ccf6b5f6a4379033ebac81", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -66,5 +66,5 @@ fn main(args: [str]) {\n         i += 1u;\n     }\n \n-    std::io::println(#fmt(\"%0.9f\\n\", float::sqrt(vBv / vv)));\n+    io::println(#fmt(\"%0.9f\\n\", float::sqrt(vBv / vv)));\n }"}, {"sha": "42a17b8d4812fb361187569bcb77dbb50a4193f9", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -23,7 +23,7 @@ fn roundtrip(id: int, p: comm::port<int>, ch: comm::chan<int>) {\n     while (true) {\n         alt comm::recv(p) {\n           1 {\n-            std::io::println(#fmt(\"%d\\n\", id));\n+            io::println(#fmt(\"%d\\n\", id));\n             ret;\n           }\n           token {"}, {"sha": "832506f5ed5fa684578441b418ce866984f029aa", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,6 +1,6 @@\n use std;\n \n-import std::{io, bitv};\n+import std::bitv;\n import io::{writer_util, reader_util};\n \n // Computes a single solution to a given 9x9 sudoku"}, {"sha": "2fd85d542c391ac8b4fdcde28e54563c3a026f6d", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -12,7 +12,7 @@ use std;\n \n import option = option;\n import option::{some, none};\n-import std::{map, io, time};\n+import std::{map, time};\n import std::map::hashmap;\n import io::reader_util;\n "}, {"sha": "ab4b8824851f2dd84e2668544c4075a85fd838e6", "filename": "src/test/compile-fail/nonscalar-cast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,8 +1,5 @@\n // error-pattern:non-scalar cast\n \n-use std;\n-import std::os;\n-\n fn main() {\n   log(debug, { x: 1 } as int);\n }"}, {"sha": "1c489e078ffa70eed9754e861d7d572a5085cbbb", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -4,7 +4,7 @@ use std;\n use rustc;\n \n import rustc::*;\n-import std::io::*;\n+import io::*;\n \n import rustc::driver::diagnostic;\n import rustc::syntax::ast;"}, {"sha": "3559df78b7dd13f5aea89e052d0f7cdee666b916", "filename": "src/test/compile-fail/unsupported-cast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,8 +1,5 @@\n // error-pattern:unsupported cast\n \n-use std;\n-import std::os;\n-\n fn main() {\n-  log(debug, 1.0 as os::FILE); // Can't cast float to native.\n+  log(debug, 1.0 as *libc::FILE); // Can't cast float to native.\n }"}, {"sha": "70c9e724f0da5fad6cb953bf3915a298748bec12", "filename": "src/test/compile-fail/warn-native-int-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fcompile-fail%2Fwarn-native-int-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Fcompile-fail%2Fwarn-native-int-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwarn-native-int-types.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,4 +1,4 @@\n-//error-pattern:ctypes::c_int or ctypes::long should be used\n+//error-pattern:libc::c_int or libc::c_long should be used\n native mod xx {\n   fn strlen(str: *u8) -> uint;\n   fn foo(x: int, y: uint);"}, {"sha": "7b844cc3b472a068d6f688dc01916f9a37776539", "filename": "src/test/run-fail/crust-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-fail%2Fcrust-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-fail%2Fcrust-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fcrust-fail.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -4,10 +4,10 @@\n \n native mod rustrt {\n     fn rust_dbg_call(cb: *u8,\n-                     data: ctypes::uintptr_t) -> ctypes::uintptr_t;\n+                     data: libc::uintptr_t) -> libc::uintptr_t;\n }\n \n-crust fn cb(data: ctypes::uintptr_t) -> ctypes::uintptr_t {\n+crust fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     if data == 1u {\n         data\n     } else {"}, {"sha": "ed9fb1c99a1833341878e6ecdf6170e1ec85619b", "filename": "src/test/run-pass/bind-native-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -3,7 +3,7 @@\n \n use std;\n import str;\n-import ctypes::*;\n+import libc::*;\n \n #[nolink]\n native mod libc {"}, {"sha": "1b9e05d4fe6d05351cdd17482fe0ba7abade6c6d", "filename": "src/test/run-pass/bind-native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fbind-native.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fbind-native.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-native.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -4,7 +4,7 @@ Can we bind native things?\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn rand_new() -> *ctypes::void;\n+    fn rand_new() -> *libc::c_void;\n }\n \n fn main() { bind rustrt::rand_new(); }"}, {"sha": "c5811d775c06d5d85f617ad1c4dc82636ed4a2b3", "filename": "src/test/run-pass/cci_impl_exe.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,9 +1,7 @@\n // xfail-fast - check-fast doesn't understand aux-build\n // aux-build:cci_impl_lib.rs\n \n-use std;\n use cci_impl_lib;\n-import std::io;\n import cci_impl_lib::helpers;\n \n fn main() {"}, {"sha": "27fd452c8edcdfbe570654a2d04e319da58df8d2", "filename": "src/test/run-pass/cci_iter_exe.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,11 +1,8 @@\n // xfail-fast - check-fast doesn't understand aux-build\n // aux-build:cci_iter_lib.rs\n \n-use std;\n use cci_iter_lib;\n \n-import std::io;\n-\n fn main() {\n     //let bt0 = sys::rusti::frame_address(1u32);\n     //#debug[\"%?\", bt0];"}, {"sha": "cf75dd6c57b23b21bc1dd7c0875f81cd5fb007d8", "filename": "src/test/run-pass/cci_nested_exe.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,9 +1,7 @@\n // xfail-fast - check-fast doesn't understand aux-build\n // aux-build:cci_nested_lib.rs\n \n-use std;\n use cci_nested_lib;\n-import std::io;\n import cci_nested_lib::*;\n \n fn main() {"}, {"sha": "f9863f12b4f0a63724a78d523644d6830b111d26", "filename": "src/test/run-pass/cci_no_inline_exe.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,12 +1,9 @@\n // xfail-fast - check-fast doesn't understand aux-build\n // aux-build:cci_no_inline_lib.rs\n \n-use std;\n use cci_no_inline_lib;\n import cci_no_inline_lib::iter;\n \n-import std::io;\n-\n fn main() {\n     // Check that a cross-crate call function not marked as inline\n     // does not, in fact, get inlined.  Also, perhaps more"}, {"sha": "b707e23a7ef204fe594373cd69433a751518bff1", "filename": "src/test/run-pass/core-export-f64-sqrt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcore-export-f64-sqrt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcore-export-f64-sqrt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-export-f64-sqrt.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,7 +1,6 @@\n // Regression test that f64 exports things properly\n \n-use std;\n-import std::io::println;\n+import io::println;\n \n fn main() {\n "}, {"sha": "5a8a9fb285cd3e6fe0133aead2a3ccb4a20b125d", "filename": "src/test/run-pass/crust-call-deep.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-call-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-call-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-call-deep.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,9 +1,9 @@\n native mod rustrt {\n     fn rust_dbg_call(cb: *u8,\n-                     data: ctypes::uintptr_t) -> ctypes::uintptr_t;\n+                     data: libc::uintptr_t) -> libc::uintptr_t;\n }\n \n-crust fn cb(data: ctypes::uintptr_t) -> ctypes::uintptr_t {\n+crust fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     if data == 1u {\n         data\n     } else {"}, {"sha": "a79a05ebde225ce61fcb224afa70a6246fb9d3a9", "filename": "src/test/run-pass/crust-call-deep2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-call-deep2.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,9 +1,9 @@\n native mod rustrt {\n     fn rust_dbg_call(cb: *u8,\n-                     data: ctypes::uintptr_t) -> ctypes::uintptr_t;\n+                     data: libc::uintptr_t) -> libc::uintptr_t;\n }\n \n-crust fn cb(data: ctypes::uintptr_t) -> ctypes::uintptr_t {\n+crust fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     if data == 1u {\n         data\n     } else {"}, {"sha": "ea8897b15190d8e63f14a94d2cd0380f3ff8410f", "filename": "src/test/run-pass/crust-call-scrub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-call-scrub.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -4,10 +4,10 @@\n \n native mod rustrt {\n     fn rust_dbg_call(cb: *u8,\n-                     data: ctypes::uintptr_t) -> ctypes::uintptr_t;\n+                     data: libc::uintptr_t) -> libc::uintptr_t;\n }\n \n-crust fn cb(data: ctypes::uintptr_t) -> ctypes::uintptr_t {\n+crust fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     if data == 1u {\n         data\n     } else {"}, {"sha": "f81c0d302f07c039da946659365f1c5e92ee2db1", "filename": "src/test/run-pass/crust-call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-call.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,9 +1,9 @@\n native mod rustrt {\n     fn rust_dbg_call(cb: *u8,\n-                     data: ctypes::uintptr_t) -> ctypes::uintptr_t;\n+                     data: libc::uintptr_t) -> libc::uintptr_t;\n }\n \n-crust fn cb(data: ctypes::uintptr_t) -> ctypes::uintptr_t {\n+crust fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     if data == 1u {\n         data\n     } else {"}, {"sha": "e96c45a8cdf970223bd00f55be030bfcd33c1543", "filename": "src/test/run-pass/crust-stress.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-stress.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -3,10 +3,10 @@\n \n native mod rustrt {\n     fn rust_dbg_call(cb: *u8,\n-                     data: ctypes::uintptr_t) -> ctypes::uintptr_t;\n+                     data: libc::uintptr_t) -> libc::uintptr_t;\n }\n \n-crust fn cb(data: ctypes::uintptr_t) -> ctypes::uintptr_t {\n+crust fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     if data == 1u {\n         data\n     } else {"}, {"sha": "d7dc4c6cf5147376415597302ba3bf419dac2924", "filename": "src/test/run-pass/crust-yield.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fcrust-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-yield.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,9 +1,9 @@\n native mod rustrt {\n     fn rust_dbg_call(cb: *u8,\n-                     data: ctypes::uintptr_t) -> ctypes::uintptr_t;\n+                     data: libc::uintptr_t) -> libc::uintptr_t;\n }\n \n-crust fn cb(data: ctypes::uintptr_t) -> ctypes::uintptr_t {\n+crust fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     if data == 1u {\n         data\n     } else {"}, {"sha": "3ad9f3305484c65518b109ab90c979fbca950681", "filename": "src/test/run-pass/native2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fnative2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fnative2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative2.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -16,7 +16,8 @@ native mod zed { }\n #[abi = \"cdecl\"]\n #[nolink]\n native mod libc {\n-    fn write(fd: int, buf: *u8, count: ctypes::size_t) -> ctypes::ssize_t;\n+    fn write(fd: int, buf: *u8,\n+             count: core::libc::size_t) -> core::libc::ssize_t;\n }\n \n #[abi = \"cdecl\"]"}, {"sha": "04aeba9093c8a2924dcf33411ae9f89a0315070e", "filename": "src/test/run-pass/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fqquote.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -4,7 +4,7 @@ use std;\n use rustc;\n \n import rustc::*;\n-import std::io::*;\n+import io::*;\n \n import rustc::driver::diagnostic;\n import rustc::syntax::ast;\n@@ -95,7 +95,7 @@ fn main() {\n \n fn check_pp<T>(expr: T, f: fn(pprust::ps, T), expect: str) {\n     let buf = mk_mem_buffer();\n-    let pp = pprust::rust_printer(buf as std::io::writer);\n+    let pp = pprust::rust_printer(buf as io::writer);\n     f(pp, expr);\n     pp::eof(pp.s);\n     let str = mem_buffer_str(buf);"}, {"sha": "94acb543e81b568c4f8e52dae3727a596dfa9cfc", "filename": "src/test/run-pass/rt-sched-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-sched-1.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -3,8 +3,8 @@\n type sched_id = int;\n type task_id = int;\n \n-type task = *ctypes::void;\n-type closure = *ctypes::void;\n+type task = *libc::c_void;\n+type closure = *libc::c_void;\n \n native mod rustrt {\n     fn rust_new_sched(num_threads: uint) -> sched_id;"}, {"sha": "55f56979b754aa966eb8c06c0b7d8ad9aea2513a", "filename": "src/test/run-pass/supported-cast.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5853f5a1767e0c418fd5f348a795b76d701b3e/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsupported-cast.rs?ref=6f5853f5a1767e0c418fd5f348a795b76d701b3e", "patch": "@@ -1,8 +1,5 @@\n-use std;\n-import std::os;\n-\n fn main() {\n-  let f = 1 as os::FILE;\n+  let f = 1 as *libc::FILE;\n   log(debug, f as int);\n   log(debug, f as uint);\n   log(debug, f as i8);\n@@ -18,7 +15,7 @@ fn main() {\n   log(debug, 1 as uint);\n   log(debug, 1 as float);\n   log(debug, 1 as bool);\n-  log(debug, 1 as os::FILE);\n+  log(debug, 1 as *libc::FILE);\n   log(debug, 1 as i8);\n   log(debug, 1 as i16);\n   log(debug, 1 as i32);\n@@ -34,7 +31,7 @@ fn main() {\n   log(debug, 1u as uint);\n   log(debug, 1u as float);\n   log(debug, 1u as bool);\n-  log(debug, 1u as os::FILE);\n+  log(debug, 1u as *libc::FILE);\n   log(debug, 1u as i8);\n   log(debug, 1u as i16);\n   log(debug, 1u as i32);\n@@ -50,7 +47,7 @@ fn main() {\n   log(debug, 1i8 as uint);\n   log(debug, 1i8 as float);\n   log(debug, 1i8 as bool);\n-  log(debug, 1i8 as os::FILE);\n+  log(debug, 1i8 as *libc::FILE);\n   log(debug, 1i8 as i8);\n   log(debug, 1i8 as i16);\n   log(debug, 1i8 as i32);\n@@ -66,7 +63,7 @@ fn main() {\n   log(debug, 1u8 as uint);\n   log(debug, 1u8 as float);\n   log(debug, 1u8 as bool);\n-  log(debug, 1u8 as os::FILE);\n+  log(debug, 1u8 as *libc::FILE);\n   log(debug, 1u8 as i8);\n   log(debug, 1u8 as i16);\n   log(debug, 1u8 as i32);\n@@ -82,7 +79,7 @@ fn main() {\n   log(debug, 1i16 as uint);\n   log(debug, 1i16 as float);\n   log(debug, 1i16 as bool);\n-  log(debug, 1i16 as os::FILE);\n+  log(debug, 1i16 as *libc::FILE);\n   log(debug, 1i16 as i8);\n   log(debug, 1i16 as i16);\n   log(debug, 1i16 as i32);\n@@ -98,7 +95,7 @@ fn main() {\n   log(debug, 1u16 as uint);\n   log(debug, 1u16 as float);\n   log(debug, 1u16 as bool);\n-  log(debug, 1u16 as os::FILE);\n+  log(debug, 1u16 as *libc::FILE);\n   log(debug, 1u16 as i8);\n   log(debug, 1u16 as i16);\n   log(debug, 1u16 as i32);\n@@ -114,7 +111,7 @@ fn main() {\n   log(debug, 1i32 as uint);\n   log(debug, 1i32 as float);\n   log(debug, 1i32 as bool);\n-  log(debug, 1i32 as os::FILE);\n+  log(debug, 1i32 as *libc::FILE);\n   log(debug, 1i32 as i8);\n   log(debug, 1i32 as i16);\n   log(debug, 1i32 as i32);\n@@ -130,7 +127,7 @@ fn main() {\n   log(debug, 1u32 as uint);\n   log(debug, 1u32 as float);\n   log(debug, 1u32 as bool);\n-  log(debug, 1u32 as os::FILE);\n+  log(debug, 1u32 as *libc::FILE);\n   log(debug, 1u32 as i8);\n   log(debug, 1u32 as i16);\n   log(debug, 1u32 as i32);\n@@ -146,7 +143,7 @@ fn main() {\n   log(debug, 1i64 as uint);\n   log(debug, 1i64 as float);\n   log(debug, 1i64 as bool);\n-  log(debug, 1i64 as os::FILE);\n+  log(debug, 1i64 as *libc::FILE);\n   log(debug, 1i64 as i8);\n   log(debug, 1i64 as i16);\n   log(debug, 1i64 as i32);\n@@ -162,7 +159,7 @@ fn main() {\n   log(debug, 1u64 as uint);\n   log(debug, 1u64 as float);\n   log(debug, 1u64 as bool);\n-  log(debug, 1u64 as os::FILE);\n+  log(debug, 1u64 as *libc::FILE);\n   log(debug, 1u64 as i8);\n   log(debug, 1u64 as i16);\n   log(debug, 1u64 as i32);\n@@ -178,7 +175,7 @@ fn main() {\n   log(debug, 1u64 as uint);\n   log(debug, 1u64 as float);\n   log(debug, 1u64 as bool);\n-  log(debug, 1u64 as os::FILE);\n+  log(debug, 1u64 as *libc::FILE);\n   log(debug, 1u64 as i8);\n   log(debug, 1u64 as i16);\n   log(debug, 1u64 as i32);\n@@ -194,7 +191,7 @@ fn main() {\n   log(debug, true as uint);\n   log(debug, true as float);\n   log(debug, true as bool);\n-  log(debug, true as os::FILE);\n+  log(debug, true as *libc::FILE);\n   log(debug, true as i8);\n   log(debug, true as i16);\n   log(debug, true as i32);"}]}