{"sha": "ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMGQ0YTNiMWRlYWNhMzE4YTFlZDJmZjgzY2NhNjUyZWY4ZThjODI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-10T11:45:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-10T11:46:14Z"}, "message": "Refactor and fix some more edge cases around name resolution", "tree": {"sha": "c3f495cd98d2a992a2f7b636f2284af2c5c86715", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3f495cd98d2a992a2f7b636f2284af2c5c86715"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82", "html_url": "https://github.com/rust-lang/rust/commit/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72b8cfb5aa99d85cd8cc936232cbbf24d1995547", "url": "https://api.github.com/repos/rust-lang/rust/commits/72b8cfb5aa99d85cd8cc936232cbbf24d1995547", "html_url": "https://github.com/rust-lang/rust/commit/72b8cfb5aa99d85cd8cc936232cbbf24d1995547"}], "stats": {"total": 401, "additions": 209, "deletions": 192}, "files": [{"sha": "88aee74372e963ae33415ab7667240105623e521", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82", "patch": "@@ -2,7 +2,7 @@\n \n use ra_cfg::CfgOptions;\n use ra_db::FileId;\n-use ra_syntax::{ast, SmolStr};\n+use ra_syntax::ast;\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n@@ -11,10 +11,8 @@ use crate::{\n     ids::{AstItemDef, LocationCtx, MacroCallId, MacroCallLoc, MacroDefId, MacroFileKind},\n     name::MACRO_RULES,\n     nameres::{\n-        diagnostics::DefDiagnostic,\n-        mod_resolution::{resolve_submodule, ParentModule},\n-        raw, Crate, CrateDefMap, CrateModuleId, ModuleData, ModuleDef, PerNs, ReachedFixedPoint,\n-        Resolution, ResolveMode,\n+        diagnostics::DefDiagnostic, mod_resolution::ModDir, raw, Crate, CrateDefMap, CrateModuleId,\n+        ModuleData, ModuleDef, PerNs, ReachedFixedPoint, Resolution, ResolveMode,\n     },\n     Adt, AstId, Const, Enum, Function, HirFileId, MacroDef, Module, Name, Path, PathKind, Static,\n     Struct, Trait, TypeAlias, Union,\n@@ -45,6 +43,7 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n         unexpanded_macros: Vec::new(),\n+        mod_dirs: FxHashMap::default(),\n         macro_stack_monitor: MacroStackMonitor::default(),\n         cfg_options,\n     };\n@@ -87,6 +86,7 @@ struct DefCollector<'a, DB> {\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n     unexpanded_macros: Vec<(CrateModuleId, AstId<ast::MacroCall>, Path)>,\n+    mod_dirs: FxHashMap<CrateModuleId, ModDir>,\n \n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n     /// To prevent stack overflow, we add a deep counter here for prevent that.\n@@ -107,11 +107,10 @@ where\n         self.def_map.modules[module_id].definition = Some(file_id);\n         ModCollector {\n             def_collector: &mut *self,\n-            attr_path: None,\n             module_id,\n             file_id: file_id.into(),\n             raw_items: &raw_items,\n-            parent_module: None,\n+            mod_dir: ModDir::root(),\n         }\n         .collect(raw_items.items());\n \n@@ -481,13 +480,13 @@ where\n         if !self.macro_stack_monitor.is_poison(macro_def_id) {\n             let file_id: HirFileId = macro_call_id.as_file(MacroFileKind::Items);\n             let raw_items = self.db.raw_items(file_id);\n+            let mod_dir = self.mod_dirs[&module_id].clone();\n             ModCollector {\n                 def_collector: &mut *self,\n                 file_id,\n-                attr_path: None,\n                 module_id,\n                 raw_items: &raw_items,\n-                parent_module: None,\n+                mod_dir,\n             }\n             .collect(raw_items.items());\n         } else {\n@@ -508,16 +507,19 @@ struct ModCollector<'a, D> {\n     def_collector: D,\n     module_id: CrateModuleId,\n     file_id: HirFileId,\n-    attr_path: Option<&'a SmolStr>,\n     raw_items: &'a raw::RawItems,\n-    parent_module: Option<ParentModule<'a>>,\n+    mod_dir: ModDir,\n }\n \n impl<DB> ModCollector<'_, &'_ mut DefCollector<'_, DB>>\n where\n     DB: DefDatabase,\n {\n     fn collect(&mut self, items: &[raw::RawItem]) {\n+        // Note: don't assert that inserted value is fresh: it's simply not true\n+        // for macros.\n+        self.def_collector.mod_dirs.insert(self.module_id, self.mod_dir.clone());\n+\n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n             if prelude_module.krate != self.def_collector.def_map.krate {\n@@ -561,15 +563,13 @@ where\n             raw::ModuleData::Definition { name, items, ast_id, attr_path, is_macro_use } => {\n                 let module_id =\n                     self.push_child_module(name.clone(), ast_id.with_file_id(self.file_id), None);\n-                let parent_module = ParentModule { name, attr_path: attr_path.as_ref() };\n \n                 ModCollector {\n                     def_collector: &mut *self.def_collector,\n                     module_id,\n-                    attr_path: attr_path.as_ref(),\n                     file_id: self.file_id,\n                     raw_items: self.raw_items,\n-                    parent_module: Some(parent_module),\n+                    mod_dir: self.mod_dir.descend_into_definition(name, attr_path.as_ref()),\n                 }\n                 .collect(&*items);\n                 if *is_macro_use {\n@@ -579,26 +579,21 @@ where\n             // out of line module, resolve, parse and recurse\n             raw::ModuleData::Declaration { name, ast_id, attr_path, is_macro_use } => {\n                 let ast_id = ast_id.with_file_id(self.file_id);\n-                let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n-                match resolve_submodule(\n+                match self.mod_dir.resolve_submodule(\n                     self.def_collector.db,\n                     self.file_id,\n-                    self.attr_path,\n                     name,\n-                    is_root,\n                     attr_path.as_ref(),\n-                    self.parent_module,\n                 ) {\n-                    Ok(file_id) => {\n+                    Ok((file_id, mod_dir)) => {\n                         let module_id = self.push_child_module(name.clone(), ast_id, Some(file_id));\n                         let raw_items = self.def_collector.db.raw_items(file_id.into());\n                         ModCollector {\n                             def_collector: &mut *self.def_collector,\n                             module_id,\n-                            attr_path: attr_path.as_ref(),\n                             file_id: file_id.into(),\n                             raw_items: &raw_items,\n-                            parent_module: None,\n+                            mod_dir,\n                         }\n                         .collect(raw_items.items());\n                         if *is_macro_use {\n@@ -747,6 +742,7 @@ mod tests {\n             glob_imports: FxHashMap::default(),\n             unresolved_imports: Vec::new(),\n             unexpanded_macros: Vec::new(),\n+            mod_dirs: FxHashMap::default(),\n             macro_stack_monitor: monitor,\n             cfg_options: &CfgOptions::default(),\n         };"}, {"sha": "f50f9abe609a77f76cb5809cfd30d04d8005f125", "filename": "crates/ra_hir/src/nameres/mod_resolution.rs", "status": "modified", "additions": 77, "deletions": 155, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82", "patch": "@@ -1,187 +1,109 @@\n //! This module resolves `mod foo;` declaration to file.\n+use std::borrow::Cow;\n \n-use std::{borrow::Cow, sync::Arc};\n-\n-use ra_db::{FileId, SourceRoot};\n+use ra_db::FileId;\n use ra_syntax::SmolStr;\n-use relative_path::RelativePathBuf;\n+use relative_path::{RelativePath, RelativePathBuf};\n \n use crate::{db::DefDatabase, HirFileId, Name};\n \n-#[derive(Clone, Copy)]\n-pub(super) struct ParentModule<'a> {\n-    pub(super) name: &'a Name,\n-    pub(super) attr_path: Option<&'a SmolStr>,\n+#[derive(Clone, Debug)]\n+pub(super) struct ModDir {\n+    /// `.` for `mod.rs`, `lib.rs`\n+    /// `./foo` for `foo.rs`\n+    /// `./foo/bar` for `mod bar { mod x; }` nested in `foo.rs`\n+    path: RelativePathBuf,\n+    /// inside `./foo.rs`, mods with `#[path]` should *not* be relative to `./foo/`\n+    root_non_dir_owner: bool,\n }\n \n-impl<'a> ParentModule<'a> {\n-    fn attribute_path(&self) -> Option<&SmolStr> {\n-        self.attr_path.filter(|p| !p.is_empty())\n+impl ModDir {\n+    pub(super) fn root() -> ModDir {\n+        ModDir { path: RelativePathBuf::default(), root_non_dir_owner: false }\n     }\n-}\n-\n-pub(super) fn resolve_submodule(\n-    db: &impl DefDatabase,\n-    file_id: HirFileId,\n-    mod_attr_path: Option<&SmolStr>,\n-    name: &Name,\n-    is_root: bool,\n-    attr_path: Option<&SmolStr>,\n-    parent_module: Option<ParentModule<'_>>,\n-) -> Result<FileId, RelativePathBuf> {\n-    let file_id = file_id.original_file(db);\n-    let source_root_id = db.file_source_root(file_id);\n-    let path = db.file_relative_path(file_id);\n-    let root = RelativePathBuf::default();\n-    let dir_path = path.parent().unwrap_or(&root);\n-    let mod_name = path.file_stem().unwrap_or(\"unknown\");\n \n-    let resolve_mode = match (attr_path.filter(|p| !p.is_empty()), parent_module) {\n-        (Some(file_path), Some(parent_module)) => {\n-            let file_path = normalize_attribute_path(file_path);\n-            match parent_module.attribute_path() {\n-                Some(parent_module_attr_path) => {\n-                    let path = dir_path\n-                        .join(format!(\n-                            \"{}/{}\",\n-                            normalize_attribute_path(parent_module_attr_path),\n-                            file_path\n-                        ))\n-                        .normalize();\n-                    ResolutionMode::InlineModuleWithAttributePath(\n-                        InsideInlineModuleMode::WithAttributePath(path),\n-                    )\n-                }\n-                None => {\n-                    let path =\n-                        dir_path.join(format!(\"{}/{}\", parent_module.name, file_path)).normalize();\n-                    ResolutionMode::InsideInlineModule(InsideInlineModuleMode::WithAttributePath(\n-                        path,\n-                    ))\n+    pub(super) fn descend_into_definition(\n+        &self,\n+        name: &Name,\n+        attr_path: Option<&SmolStr>,\n+    ) -> ModDir {\n+        let mut path = self.path.clone();\n+        match attr_path {\n+            None => path.push(&name.to_string()),\n+            Some(attr_path) => {\n+                if self.root_non_dir_owner {\n+                    path = path\n+                        .parent()\n+                        .map(|it| it.to_relative_path_buf())\n+                        .unwrap_or_else(RelativePathBuf::new);\n                 }\n+                let attr_path = &*normalize_attribute_path(attr_path);\n+                path.push(RelativePath::new(attr_path));\n             }\n         }\n-        (None, Some(parent_module)) => match parent_module.attribute_path() {\n-            Some(parent_module_attr_path) => {\n-                let path = dir_path.join(format!(\n-                    \"{}/{}.rs\",\n-                    normalize_attribute_path(parent_module_attr_path),\n-                    name\n-                ));\n-                ResolutionMode::InlineModuleWithAttributePath(InsideInlineModuleMode::File(path))\n+        ModDir { path, root_non_dir_owner: false }\n+    }\n+\n+    pub(super) fn resolve_submodule(\n+        &self,\n+        db: &impl DefDatabase,\n+        file_id: HirFileId,\n+        name: &Name,\n+        attr_path: Option<&SmolStr>,\n+    ) -> Result<(FileId, ModDir), RelativePathBuf> {\n+        let empty_path = RelativePathBuf::default();\n+        let file_id = file_id.original_file(db);\n+        let base_dir = {\n+            let path = db.file_relative_path(file_id);\n+            path.parent().unwrap_or(&empty_path).join(&self.path)\n+        };\n+\n+        let mut candidate_files = Vec::new();\n+        match attr_path {\n+            Some(attr) => {\n+                let base = if self.root_non_dir_owner {\n+                    base_dir.parent().unwrap_or(&empty_path)\n+                } else {\n+                    &base_dir\n+                };\n+                candidate_files.push(base.join(&*normalize_attribute_path(attr)))\n             }\n             None => {\n-                let path = dir_path.join(format!(\"{}/{}.rs\", parent_module.name, name));\n-                ResolutionMode::InsideInlineModule(InsideInlineModuleMode::File(path))\n+                candidate_files.push(base_dir.join(&format!(\"{}.rs\", name)));\n+                candidate_files.push(base_dir.join(&format!(\"{}/mod.rs\", name)));\n             }\n-        },\n-        (Some(file_path), None) => {\n-            let file_path = normalize_attribute_path(file_path);\n-            let path = dir_path.join(file_path.as_ref()).normalize();\n-            ResolutionMode::OutOfLine(OutOfLineMode::WithAttributePath(path))\n-        }\n-        (None, None) => {\n-            let is_dir_owner = is_root || mod_name == \"mod\" || mod_attr_path.is_some();\n-            if is_dir_owner {\n-                let file_mod = dir_path.join(format!(\"{}.rs\", name));\n-                let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n-                ResolutionMode::OutOfLine(OutOfLineMode::RootOrModRs {\n-                    file: file_mod,\n-                    directory: dir_mod,\n-                })\n-            } else {\n-                let path = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n-                ResolutionMode::OutOfLine(OutOfLineMode::FileInDirectory(path))\n+        };\n+\n+        let source_root_id = db.file_source_root(file_id);\n+        let source_root = db.source_root(source_root_id);\n+        for candidate in candidate_files.iter() {\n+            let candidate = candidate.normalize();\n+            if let Some(file_id) = source_root.file_by_relative_path(&candidate) {\n+                let mut root_non_dir_owner = false;\n+                let mut mod_path = RelativePathBuf::new();\n+                if !(candidate.ends_with(\"mod.rs\") || attr_path.is_some()) {\n+                    root_non_dir_owner = true;\n+                    mod_path.push(&name.to_string());\n+                }\n+                return Ok((file_id, ModDir { path: mod_path, root_non_dir_owner }));\n             }\n         }\n-    };\n-\n-    resolve_mode.resolve(db.source_root(source_root_id))\n+        let suggestion = candidate_files.first().unwrap();\n+        Err(base_dir.join(suggestion))\n+    }\n }\n \n-fn normalize_attribute_path(file_path: &SmolStr) -> Cow<str> {\n+fn normalize_attribute_path(file_path: &str) -> Cow<str> {\n     let current_dir = \"./\";\n     let windows_path_separator = r#\"\\\"#;\n     let current_dir_normalize = if file_path.starts_with(current_dir) {\n         &file_path[current_dir.len()..]\n     } else {\n-        file_path.as_str()\n+        file_path\n     };\n     if current_dir_normalize.contains(windows_path_separator) {\n         Cow::Owned(current_dir_normalize.replace(windows_path_separator, \"/\"))\n     } else {\n         Cow::Borrowed(current_dir_normalize)\n     }\n }\n-\n-enum OutOfLineMode {\n-    RootOrModRs { file: RelativePathBuf, directory: RelativePathBuf },\n-    FileInDirectory(RelativePathBuf),\n-    WithAttributePath(RelativePathBuf),\n-}\n-\n-impl OutOfLineMode {\n-    pub fn resolve(&self, source_root: Arc<SourceRoot>) -> Result<FileId, RelativePathBuf> {\n-        match self {\n-            OutOfLineMode::RootOrModRs { file, directory } => {\n-                match source_root.file_by_relative_path(file) {\n-                    None => resolve_simple_path(source_root, directory).map_err(|_| file.clone()),\n-                    file_id => resolve_find_result(file_id, file),\n-                }\n-            }\n-            OutOfLineMode::FileInDirectory(path) => resolve_simple_path(source_root, path),\n-            OutOfLineMode::WithAttributePath(path) => resolve_simple_path(source_root, path),\n-        }\n-    }\n-}\n-\n-enum InsideInlineModuleMode {\n-    File(RelativePathBuf),\n-    WithAttributePath(RelativePathBuf),\n-}\n-\n-impl InsideInlineModuleMode {\n-    pub fn resolve(&self, source_root: Arc<SourceRoot>) -> Result<FileId, RelativePathBuf> {\n-        match self {\n-            InsideInlineModuleMode::File(path) => resolve_simple_path(source_root, path),\n-            InsideInlineModuleMode::WithAttributePath(path) => {\n-                resolve_simple_path(source_root, path)\n-            }\n-        }\n-    }\n-}\n-\n-enum ResolutionMode {\n-    OutOfLine(OutOfLineMode),\n-    InsideInlineModule(InsideInlineModuleMode),\n-    InlineModuleWithAttributePath(InsideInlineModuleMode),\n-}\n-\n-impl ResolutionMode {\n-    pub fn resolve(&self, source_root: Arc<SourceRoot>) -> Result<FileId, RelativePathBuf> {\n-        use self::ResolutionMode::*;\n-\n-        match self {\n-            OutOfLine(mode) => mode.resolve(source_root),\n-            InsideInlineModule(mode) => mode.resolve(source_root),\n-            InlineModuleWithAttributePath(mode) => mode.resolve(source_root),\n-        }\n-    }\n-}\n-\n-fn resolve_simple_path(\n-    source_root: Arc<SourceRoot>,\n-    path: &RelativePathBuf,\n-) -> Result<FileId, RelativePathBuf> {\n-    resolve_find_result(source_root.file_by_relative_path(path), path)\n-}\n-\n-fn resolve_find_result(\n-    file_id: Option<FileId>,\n-    path: &RelativePathBuf,\n-) -> Result<FileId, RelativePathBuf> {\n-    match file_id {\n-        Some(file_id) => Ok(file_id.clone()),\n-        None => Err(path.clone()),\n-    }\n-}"}, {"sha": "4f52ad2c543ad5a3b790b50cafeb940949598e83", "filename": "crates/ra_hir/src/nameres/tests/macros.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82", "patch": "@@ -38,21 +38,34 @@ fn macro_rules_can_define_modules() {\n         }\n         m!(n1);\n \n+        mod m {\n+            m!(n3)\n+        }\n+\n         //- /n1.rs\n         m!(n2)\n         //- /n1/n2.rs\n         struct X;\n+        //- /m/n3.rs\n+        struct Y;\n         \",\n     );\n     assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22een1: t\n-   \u22ee\n-   \u22eecrate::n1\n-   \u22een2: t\n-   \u22ee\n-   \u22eecrate::n1::n2\n-   \u22eeX: t v\n+    crate\n+    m: t\n+    n1: t\n+    \n+    crate::m\n+    n3: t\n+    \n+    crate::m::n3\n+    Y: t v\n+    \n+    crate::n1\n+    n2: t\n+    \n+    crate::n1::n2\n+    X: t v\n     \"###);\n }\n "}, {"sha": "755f5723bf73c47ba4b04ee2a459327ee144a97d", "filename": "crates/ra_hir/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 93, "deletions": 7, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=ce0d4a3b1deaca318a1ed2ff83cca652ef8e8c82", "patch": "@@ -25,6 +25,33 @@ fn name_res_works_for_broken_modules() {\n     \"###);\n }\n \n+#[test]\n+fn nested_module_resolution() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod n1;\n+\n+        //- /n1.rs\n+        mod n2;\n+\n+        //- /n1/n2.rs\n+        struct X;\n+        \",\n+    );\n+\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22een1: t\n+        \u22ee\n+        \u22eecrate::n1\n+        \u22een2: t\n+        \u22ee\n+        \u22eecrate::n1::n2\n+        \u22eeX: t v\n+    \"###);\n+}\n+\n #[test]\n fn module_resolution_works_for_non_standard_filenames() {\n     let map = def_map_with_crate_graph(\n@@ -467,7 +494,7 @@ fn module_resolution_decl_inside_inline_module_empty_path() {\n             mod bar;\n         }\n \n-        //- /foo/users.rs\n+        //- /users.rs\n         pub struct Baz;\n         \"###,\n         crate_graph! {\n@@ -492,7 +519,7 @@ fn module_resolution_decl_empty_path() {\n     let map = def_map_with_crate_graph(\n         r###\"\n         //- /main.rs\n-        #[path = \"\"]\n+        #[path = \"\"] // Should try to read `/` (a directory)\n         mod foo;\n \n         //- /foo.rs\n@@ -505,10 +532,6 @@ fn module_resolution_decl_empty_path() {\n \n     assert_snapshot!(map, @r###\"\n         \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n     \"###);\n }\n \n@@ -626,7 +649,7 @@ fn module_resolution_decl_inside_inline_module_in_non_crate_root() {\n         }\n         use self::bar::baz::Baz;\n \n-        //- /bar/qwe.rs\n+        //- /foo/bar/qwe.rs\n         pub struct Baz;\n         \"###,\n         crate_graph! {\n@@ -737,3 +760,66 @@ fn module_resolution_decl_inside_module_in_non_crate_root_2() {\n         \u22eeBaz: t v\n     \"###);\n }\n+\n+#[test]\n+fn nested_out_of_line_module() {\n+    let map = def_map(\n+        r###\"\n+        //- /lib.rs\n+        mod a {\n+            mod b {\n+                mod c;\n+            }\n+        }\n+\n+        //- /a/b/c.rs\n+        struct X;\n+        \"###,\n+    );\n+\n+    assert_snapshot!(map, @r###\"\n+    crate\n+    a: t\n+    \n+    crate::a\n+    b: t\n+    \n+    crate::a::b\n+    c: t\n+    \n+    crate::a::b::c\n+    X: t v\n+    \"###);\n+}\n+\n+#[test]\n+fn nested_out_of_line_module_with_path() {\n+    let map = def_map(\n+        r###\"\n+        //- /lib.rs\n+        mod a {\n+            #[path = \"d/e\"]\n+            mod b {\n+                mod c;\n+            }\n+        }\n+\n+        //- /a/d/e/c.rs\n+        struct X;\n+        \"###,\n+    );\n+\n+    assert_snapshot!(map, @r###\"\n+    crate\n+    a: t\n+    \n+    crate::a\n+    b: t\n+    \n+    crate::a::b\n+    c: t\n+    \n+    crate::a::b::c\n+    X: t v\n+    \"###);\n+}"}]}