{"sha": "a83e73dce4f0e80ff7559b3816f4f24391d4ff53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4M2U3M2RjZTRmMGU4MGZmNzU1OWIzODE2ZjRmMjQzOTFkNGZmNTM=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-02-06T09:58:06Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-02-11T14:08:17Z"}, "message": "Move out tests of a deprecated module to work around `#[test]` bugs\n\nhttps://github.com/rust-lang/rust/issues/47238", "tree": {"sha": "d5d7f049675bcfca456ffe2452f18b651c35ecac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5d7f049675bcfca456ffe2452f18b651c35ecac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a83e73dce4f0e80ff7559b3816f4f24391d4ff53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a83e73dce4f0e80ff7559b3816f4f24391d4ff53", "html_url": "https://github.com/rust-lang/rust/commit/a83e73dce4f0e80ff7559b3816f4f24391d4ff53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a83e73dce4f0e80ff7559b3816f4f24391d4ff53/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cfc2ce46d2813f5120053929609de6f9b976cd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cfc2ce46d2813f5120053929609de6f9b976cd6", "html_url": "https://github.com/rust-lang/rust/commit/4cfc2ce46d2813f5120053929609de6f9b976cd6"}], "stats": {"total": 830, "additions": 416, "deletions": 414}, "files": [{"sha": "a8843549b8abcb7cb608bf35dadd8abb6deeed67", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a83e73dce4f0e80ff7559b3816f4f24391d4ff53/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83e73dce4f0e80ff7559b3816f4f24391d4ff53/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=a83e73dce4f0e80ff7559b3816f4f24391d4ff53", "patch": "@@ -279,6 +279,9 @@ use self::select::StartResult;\n use self::select::StartResult::*;\n use self::blocking::SignalToken;\n \n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n+mod select_tests;\n+\n mod blocking;\n mod oneshot;\n mod select;"}, {"sha": "9487c0cf674881e5f29f6cab7a8d3eb4bd5edea1", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 0, "deletions": 414, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/a83e73dce4f0e80ff7559b3816f4f24391d4ff53/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83e73dce4f0e80ff7559b3816f4f24391d4ff53/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=a83e73dce4f0e80ff7559b3816f4f24391d4ff53", "patch": "@@ -352,417 +352,3 @@ impl<'rx, T:Send+'rx> fmt::Debug for Handle<'rx, T> {\n         f.debug_struct(\"Handle\").finish()\n     }\n }\n-\n-#[allow(unused_imports)]\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests {\n-    use thread;\n-    use sync::mpsc::*;\n-\n-    // Don't use the libstd version so we can pull in the right Select structure\n-    // (std::comm points at the wrong one)\n-    macro_rules! select {\n-        (\n-            $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n-        ) => ({\n-            let sel = Select::new();\n-            $( let mut $rx = sel.handle(&$rx); )+\n-            unsafe {\n-                $( $rx.add(); )+\n-            }\n-            let ret = sel.wait();\n-            $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n-            { unreachable!() }\n-        })\n-    }\n-\n-    #[test]\n-    fn smoke() {\n-        let (tx1, rx1) = channel::<i32>();\n-        let (tx2, rx2) = channel::<i32>();\n-        tx1.send(1).unwrap();\n-        select! {\n-            foo = rx1.recv() => { assert_eq!(foo.unwrap(), 1); },\n-            _bar = rx2.recv() => { panic!() }\n-        }\n-        tx2.send(2).unwrap();\n-        select! {\n-            _foo = rx1.recv() => { panic!() },\n-            bar = rx2.recv() => { assert_eq!(bar.unwrap(), 2) }\n-        }\n-        drop(tx1);\n-        select! {\n-            foo = rx1.recv() => { assert!(foo.is_err()); },\n-            _bar = rx2.recv() => { panic!() }\n-        }\n-        drop(tx2);\n-        select! {\n-            bar = rx2.recv() => { assert!(bar.is_err()); }\n-        }\n-    }\n-\n-    #[test]\n-    fn smoke2() {\n-        let (_tx1, rx1) = channel::<i32>();\n-        let (_tx2, rx2) = channel::<i32>();\n-        let (_tx3, rx3) = channel::<i32>();\n-        let (_tx4, rx4) = channel::<i32>();\n-        let (tx5, rx5) = channel::<i32>();\n-        tx5.send(4).unwrap();\n-        select! {\n-            _foo = rx1.recv() => { panic!(\"1\") },\n-            _foo = rx2.recv() => { panic!(\"2\") },\n-            _foo = rx3.recv() => { panic!(\"3\") },\n-            _foo = rx4.recv() => { panic!(\"4\") },\n-            foo = rx5.recv() => { assert_eq!(foo.unwrap(), 4); }\n-        }\n-    }\n-\n-    #[test]\n-    fn closed() {\n-        let (_tx1, rx1) = channel::<i32>();\n-        let (tx2, rx2) = channel::<i32>();\n-        drop(tx2);\n-\n-        select! {\n-            _a1 = rx1.recv() => { panic!() },\n-            a2 = rx2.recv() => { assert!(a2.is_err()); }\n-        }\n-    }\n-\n-    #[test]\n-    fn unblocks() {\n-        let (tx1, rx1) = channel::<i32>();\n-        let (_tx2, rx2) = channel::<i32>();\n-        let (tx3, rx3) = channel::<i32>();\n-\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..20 { thread::yield_now(); }\n-            tx1.send(1).unwrap();\n-            rx3.recv().unwrap();\n-            for _ in 0..20 { thread::yield_now(); }\n-        });\n-\n-        select! {\n-            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-            _b = rx2.recv() => { panic!() }\n-        }\n-        tx3.send(1).unwrap();\n-        select! {\n-            a = rx1.recv() => { assert!(a.is_err()) },\n-            _b = rx2.recv() => { panic!() }\n-        }\n-    }\n-\n-    #[test]\n-    fn both_ready() {\n-        let (tx1, rx1) = channel::<i32>();\n-        let (tx2, rx2) = channel::<i32>();\n-        let (tx3, rx3) = channel::<()>();\n-\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..20 { thread::yield_now(); }\n-            tx1.send(1).unwrap();\n-            tx2.send(2).unwrap();\n-            rx3.recv().unwrap();\n-        });\n-\n-        select! {\n-            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-            a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n-        }\n-        select! {\n-            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-            a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n-        }\n-        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n-        assert_eq!(rx2.try_recv(), Err(TryRecvError::Empty));\n-        tx3.send(()).unwrap();\n-    }\n-\n-    #[test]\n-    fn stress() {\n-        const AMT: i32 = 10000;\n-        let (tx1, rx1) = channel::<i32>();\n-        let (tx2, rx2) = channel::<i32>();\n-        let (tx3, rx3) = channel::<()>();\n-\n-        let _t = thread::spawn(move|| {\n-            for i in 0..AMT {\n-                if i % 2 == 0 {\n-                    tx1.send(i).unwrap();\n-                } else {\n-                    tx2.send(i).unwrap();\n-                }\n-                rx3.recv().unwrap();\n-            }\n-        });\n-\n-        for i in 0..AMT {\n-            select! {\n-                i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1.unwrap()); },\n-                i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2.unwrap()); }\n-            }\n-            tx3.send(()).unwrap();\n-        }\n-    }\n-\n-    #[allow(unused_must_use)]\n-    #[test]\n-    fn cloning() {\n-        let (tx1, rx1) = channel::<i32>();\n-        let (_tx2, rx2) = channel::<i32>();\n-        let (tx3, rx3) = channel::<()>();\n-\n-        let _t = thread::spawn(move|| {\n-            rx3.recv().unwrap();\n-            tx1.clone();\n-            assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n-            tx1.send(2).unwrap();\n-            rx3.recv().unwrap();\n-        });\n-\n-        tx3.send(()).unwrap();\n-        select! {\n-            _i1 = rx1.recv() => {},\n-            _i2 = rx2.recv() => panic!()\n-        }\n-        tx3.send(()).unwrap();\n-    }\n-\n-    #[allow(unused_must_use)]\n-    #[test]\n-    fn cloning2() {\n-        let (tx1, rx1) = channel::<i32>();\n-        let (_tx2, rx2) = channel::<i32>();\n-        let (tx3, rx3) = channel::<()>();\n-\n-        let _t = thread::spawn(move|| {\n-            rx3.recv().unwrap();\n-            tx1.clone();\n-            assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n-            tx1.send(2).unwrap();\n-            rx3.recv().unwrap();\n-        });\n-\n-        tx3.send(()).unwrap();\n-        select! {\n-            _i1 = rx1.recv() => {},\n-            _i2 = rx2.recv() => panic!()\n-        }\n-        tx3.send(()).unwrap();\n-    }\n-\n-    #[test]\n-    fn cloning3() {\n-        let (tx1, rx1) = channel::<()>();\n-        let (tx2, rx2) = channel::<()>();\n-        let (tx3, rx3) = channel::<()>();\n-        let _t = thread::spawn(move|| {\n-            let s = Select::new();\n-            let mut h1 = s.handle(&rx1);\n-            let mut h2 = s.handle(&rx2);\n-            unsafe { h2.add(); }\n-            unsafe { h1.add(); }\n-            assert_eq!(s.wait(), h2.id);\n-            tx3.send(()).unwrap();\n-        });\n-\n-        for _ in 0..1000 { thread::yield_now(); }\n-        drop(tx1.clone());\n-        tx2.send(()).unwrap();\n-        rx3.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn preflight1() {\n-        let (tx, rx) = channel();\n-        tx.send(()).unwrap();\n-        select! {\n-            _n = rx.recv() => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn preflight2() {\n-        let (tx, rx) = channel();\n-        tx.send(()).unwrap();\n-        tx.send(()).unwrap();\n-        select! {\n-            _n = rx.recv() => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn preflight3() {\n-        let (tx, rx) = channel();\n-        drop(tx.clone());\n-        tx.send(()).unwrap();\n-        select! {\n-            _n = rx.recv() => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn preflight4() {\n-        let (tx, rx) = channel();\n-        tx.send(()).unwrap();\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn preflight5() {\n-        let (tx, rx) = channel();\n-        tx.send(()).unwrap();\n-        tx.send(()).unwrap();\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn preflight6() {\n-        let (tx, rx) = channel();\n-        drop(tx.clone());\n-        tx.send(()).unwrap();\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn preflight7() {\n-        let (tx, rx) = channel::<()>();\n-        drop(tx);\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn preflight8() {\n-        let (tx, rx) = channel();\n-        tx.send(()).unwrap();\n-        drop(tx);\n-        rx.recv().unwrap();\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn preflight9() {\n-        let (tx, rx) = channel();\n-        drop(tx.clone());\n-        tx.send(()).unwrap();\n-        drop(tx);\n-        rx.recv().unwrap();\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn oneshot_data_waiting() {\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            select! {\n-                _n = rx1.recv() => {}\n-            }\n-            tx2.send(()).unwrap();\n-        });\n-\n-        for _ in 0..100 { thread::yield_now() }\n-        tx1.send(()).unwrap();\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn stream_data_waiting() {\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        tx1.send(()).unwrap();\n-        tx1.send(()).unwrap();\n-        rx1.recv().unwrap();\n-        rx1.recv().unwrap();\n-        let _t = thread::spawn(move|| {\n-            select! {\n-                _n = rx1.recv() => {}\n-            }\n-            tx2.send(()).unwrap();\n-        });\n-\n-        for _ in 0..100 { thread::yield_now() }\n-        tx1.send(()).unwrap();\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn shared_data_waiting() {\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        drop(tx1.clone());\n-        tx1.send(()).unwrap();\n-        rx1.recv().unwrap();\n-        let _t = thread::spawn(move|| {\n-            select! {\n-                _n = rx1.recv() => {}\n-            }\n-            tx2.send(()).unwrap();\n-        });\n-\n-        for _ in 0..100 { thread::yield_now() }\n-        tx1.send(()).unwrap();\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn sync1() {\n-        let (tx, rx) = sync_channel::<i32>(1);\n-        tx.send(1).unwrap();\n-        select! {\n-            n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n-        }\n-    }\n-\n-    #[test]\n-    fn sync2() {\n-        let (tx, rx) = sync_channel::<i32>(0);\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..100 { thread::yield_now() }\n-            tx.send(1).unwrap();\n-        });\n-        select! {\n-            n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n-        }\n-    }\n-\n-    #[test]\n-    fn sync3() {\n-        let (tx1, rx1) = sync_channel::<i32>(0);\n-        let (tx2, rx2): (Sender<i32>, Receiver<i32>) = channel();\n-        let _t = thread::spawn(move|| { tx1.send(1).unwrap(); });\n-        let _t = thread::spawn(move|| { tx2.send(2).unwrap(); });\n-        select! {\n-            n = rx1.recv() => {\n-                let n = n.unwrap();\n-                assert_eq!(n, 1);\n-                assert_eq!(rx2.recv().unwrap(), 2);\n-            },\n-            n = rx2.recv() => {\n-                let n = n.unwrap();\n-                assert_eq!(n, 2);\n-                assert_eq!(rx1.recv().unwrap(), 1);\n-            }\n-        }\n-    }\n-}"}, {"sha": "4f9ce20fc347153bfe105b5f2ceacb564f0f4e59", "filename": "src/libstd/sync/mpsc/select_tests.rs", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/a83e73dce4f0e80ff7559b3816f4f24391d4ff53/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83e73dce4f0e80ff7559b3816f4f24391d4ff53/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs?ref=a83e73dce4f0e80ff7559b3816f4f24391d4ff53", "patch": "@@ -0,0 +1,413 @@\n+#![allow(unused_imports)]\n+\n+/// This file exists to hack around https://github.com/rust-lang/rust/issues/47238\n+\n+use thread;\n+use sync::mpsc::*;\n+\n+// Don't use the libstd version so we can pull in the right Select structure\n+// (std::comm points at the wrong one)\n+macro_rules! select {\n+    (\n+        $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n+    ) => ({\n+        let sel = Select::new();\n+        $( let mut $rx = sel.handle(&$rx); )+\n+        unsafe {\n+            $( $rx.add(); )+\n+        }\n+        let ret = sel.wait();\n+        $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n+        { unreachable!() }\n+    })\n+}\n+\n+#[test]\n+fn smoke() {\n+    let (tx1, rx1) = channel::<i32>();\n+    let (tx2, rx2) = channel::<i32>();\n+    tx1.send(1).unwrap();\n+    select! {\n+        foo = rx1.recv() => { assert_eq!(foo.unwrap(), 1); },\n+        _bar = rx2.recv() => { panic!() }\n+    }\n+    tx2.send(2).unwrap();\n+    select! {\n+        _foo = rx1.recv() => { panic!() },\n+        bar = rx2.recv() => { assert_eq!(bar.unwrap(), 2) }\n+    }\n+    drop(tx1);\n+    select! {\n+        foo = rx1.recv() => { assert!(foo.is_err()); },\n+        _bar = rx2.recv() => { panic!() }\n+    }\n+    drop(tx2);\n+    select! {\n+        bar = rx2.recv() => { assert!(bar.is_err()); }\n+    }\n+}\n+\n+#[test]\n+fn smoke2() {\n+    let (_tx1, rx1) = channel::<i32>();\n+    let (_tx2, rx2) = channel::<i32>();\n+    let (_tx3, rx3) = channel::<i32>();\n+    let (_tx4, rx4) = channel::<i32>();\n+    let (tx5, rx5) = channel::<i32>();\n+    tx5.send(4).unwrap();\n+    select! {\n+        _foo = rx1.recv() => { panic!(\"1\") },\n+        _foo = rx2.recv() => { panic!(\"2\") },\n+        _foo = rx3.recv() => { panic!(\"3\") },\n+        _foo = rx4.recv() => { panic!(\"4\") },\n+        foo = rx5.recv() => { assert_eq!(foo.unwrap(), 4); }\n+    }\n+}\n+\n+#[test]\n+fn closed() {\n+    let (_tx1, rx1) = channel::<i32>();\n+    let (tx2, rx2) = channel::<i32>();\n+    drop(tx2);\n+\n+    select! {\n+        _a1 = rx1.recv() => { panic!() },\n+        a2 = rx2.recv() => { assert!(a2.is_err()); }\n+    }\n+}\n+\n+#[test]\n+fn unblocks() {\n+    let (tx1, rx1) = channel::<i32>();\n+    let (_tx2, rx2) = channel::<i32>();\n+    let (tx3, rx3) = channel::<i32>();\n+\n+    let _t = thread::spawn(move|| {\n+        for _ in 0..20 { thread::yield_now(); }\n+        tx1.send(1).unwrap();\n+        rx3.recv().unwrap();\n+        for _ in 0..20 { thread::yield_now(); }\n+    });\n+\n+    select! {\n+        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n+        _b = rx2.recv() => { panic!() }\n+    }\n+    tx3.send(1).unwrap();\n+    select! {\n+        a = rx1.recv() => { assert!(a.is_err()) },\n+        _b = rx2.recv() => { panic!() }\n+    }\n+}\n+\n+#[test]\n+fn both_ready() {\n+    let (tx1, rx1) = channel::<i32>();\n+    let (tx2, rx2) = channel::<i32>();\n+    let (tx3, rx3) = channel::<()>();\n+\n+    let _t = thread::spawn(move|| {\n+        for _ in 0..20 { thread::yield_now(); }\n+        tx1.send(1).unwrap();\n+        tx2.send(2).unwrap();\n+        rx3.recv().unwrap();\n+    });\n+\n+    select! {\n+        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n+        a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n+    }\n+    select! {\n+        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n+        a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n+    }\n+    assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+    assert_eq!(rx2.try_recv(), Err(TryRecvError::Empty));\n+    tx3.send(()).unwrap();\n+}\n+\n+#[test]\n+fn stress() {\n+    const AMT: i32 = 10000;\n+    let (tx1, rx1) = channel::<i32>();\n+    let (tx2, rx2) = channel::<i32>();\n+    let (tx3, rx3) = channel::<()>();\n+\n+    let _t = thread::spawn(move|| {\n+        for i in 0..AMT {\n+            if i % 2 == 0 {\n+                tx1.send(i).unwrap();\n+            } else {\n+                tx2.send(i).unwrap();\n+            }\n+            rx3.recv().unwrap();\n+        }\n+    });\n+\n+    for i in 0..AMT {\n+        select! {\n+            i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1.unwrap()); },\n+            i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2.unwrap()); }\n+        }\n+        tx3.send(()).unwrap();\n+    }\n+}\n+\n+#[allow(unused_must_use)]\n+#[test]\n+fn cloning() {\n+    let (tx1, rx1) = channel::<i32>();\n+    let (_tx2, rx2) = channel::<i32>();\n+    let (tx3, rx3) = channel::<()>();\n+\n+    let _t = thread::spawn(move|| {\n+        rx3.recv().unwrap();\n+        tx1.clone();\n+        assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n+        tx1.send(2).unwrap();\n+        rx3.recv().unwrap();\n+    });\n+\n+    tx3.send(()).unwrap();\n+    select! {\n+        _i1 = rx1.recv() => {},\n+        _i2 = rx2.recv() => panic!()\n+    }\n+    tx3.send(()).unwrap();\n+}\n+\n+#[allow(unused_must_use)]\n+#[test]\n+fn cloning2() {\n+    let (tx1, rx1) = channel::<i32>();\n+    let (_tx2, rx2) = channel::<i32>();\n+    let (tx3, rx3) = channel::<()>();\n+\n+    let _t = thread::spawn(move|| {\n+        rx3.recv().unwrap();\n+        tx1.clone();\n+        assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n+        tx1.send(2).unwrap();\n+        rx3.recv().unwrap();\n+    });\n+\n+    tx3.send(()).unwrap();\n+    select! {\n+        _i1 = rx1.recv() => {},\n+        _i2 = rx2.recv() => panic!()\n+    }\n+    tx3.send(()).unwrap();\n+}\n+\n+#[test]\n+fn cloning3() {\n+    let (tx1, rx1) = channel::<()>();\n+    let (tx2, rx2) = channel::<()>();\n+    let (tx3, rx3) = channel::<()>();\n+    let _t = thread::spawn(move|| {\n+        let s = Select::new();\n+        let mut h1 = s.handle(&rx1);\n+        let mut h2 = s.handle(&rx2);\n+        unsafe { h2.add(); }\n+        unsafe { h1.add(); }\n+        assert_eq!(s.wait(), h2.id);\n+        tx3.send(()).unwrap();\n+    });\n+\n+    for _ in 0..1000 { thread::yield_now(); }\n+    drop(tx1.clone());\n+    tx2.send(()).unwrap();\n+    rx3.recv().unwrap();\n+}\n+\n+#[test]\n+fn preflight1() {\n+    let (tx, rx) = channel();\n+    tx.send(()).unwrap();\n+    select! {\n+        _n = rx.recv() => {}\n+    }\n+}\n+\n+#[test]\n+fn preflight2() {\n+    let (tx, rx) = channel();\n+    tx.send(()).unwrap();\n+    tx.send(()).unwrap();\n+    select! {\n+        _n = rx.recv() => {}\n+    }\n+}\n+\n+#[test]\n+fn preflight3() {\n+    let (tx, rx) = channel();\n+    drop(tx.clone());\n+    tx.send(()).unwrap();\n+    select! {\n+        _n = rx.recv() => {}\n+    }\n+}\n+\n+#[test]\n+fn preflight4() {\n+    let (tx, rx) = channel();\n+    tx.send(()).unwrap();\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id);\n+}\n+\n+#[test]\n+fn preflight5() {\n+    let (tx, rx) = channel();\n+    tx.send(()).unwrap();\n+    tx.send(()).unwrap();\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id);\n+}\n+\n+#[test]\n+fn preflight6() {\n+    let (tx, rx) = channel();\n+    drop(tx.clone());\n+    tx.send(()).unwrap();\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id);\n+}\n+\n+#[test]\n+fn preflight7() {\n+    let (tx, rx) = channel::<()>();\n+    drop(tx);\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id);\n+}\n+\n+#[test]\n+fn preflight8() {\n+    let (tx, rx) = channel();\n+    tx.send(()).unwrap();\n+    drop(tx);\n+    rx.recv().unwrap();\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id);\n+}\n+\n+#[test]\n+fn preflight9() {\n+    let (tx, rx) = channel();\n+    drop(tx.clone());\n+    tx.send(()).unwrap();\n+    drop(tx);\n+    rx.recv().unwrap();\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id);\n+}\n+\n+#[test]\n+fn oneshot_data_waiting() {\n+    let (tx1, rx1) = channel();\n+    let (tx2, rx2) = channel();\n+    let _t = thread::spawn(move|| {\n+        select! {\n+            _n = rx1.recv() => {}\n+        }\n+        tx2.send(()).unwrap();\n+    });\n+\n+    for _ in 0..100 { thread::yield_now() }\n+    tx1.send(()).unwrap();\n+    rx2.recv().unwrap();\n+}\n+\n+#[test]\n+fn stream_data_waiting() {\n+    let (tx1, rx1) = channel();\n+    let (tx2, rx2) = channel();\n+    tx1.send(()).unwrap();\n+    tx1.send(()).unwrap();\n+    rx1.recv().unwrap();\n+    rx1.recv().unwrap();\n+    let _t = thread::spawn(move|| {\n+        select! {\n+            _n = rx1.recv() => {}\n+        }\n+        tx2.send(()).unwrap();\n+    });\n+\n+    for _ in 0..100 { thread::yield_now() }\n+    tx1.send(()).unwrap();\n+    rx2.recv().unwrap();\n+}\n+\n+#[test]\n+fn shared_data_waiting() {\n+    let (tx1, rx1) = channel();\n+    let (tx2, rx2) = channel();\n+    drop(tx1.clone());\n+    tx1.send(()).unwrap();\n+    rx1.recv().unwrap();\n+    let _t = thread::spawn(move|| {\n+        select! {\n+            _n = rx1.recv() => {}\n+        }\n+        tx2.send(()).unwrap();\n+    });\n+\n+    for _ in 0..100 { thread::yield_now() }\n+    tx1.send(()).unwrap();\n+    rx2.recv().unwrap();\n+}\n+\n+#[test]\n+fn sync1() {\n+    let (tx, rx) = sync_channel::<i32>(1);\n+    tx.send(1).unwrap();\n+    select! {\n+        n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n+    }\n+}\n+\n+#[test]\n+fn sync2() {\n+    let (tx, rx) = sync_channel::<i32>(0);\n+    let _t = thread::spawn(move|| {\n+        for _ in 0..100 { thread::yield_now() }\n+        tx.send(1).unwrap();\n+    });\n+    select! {\n+        n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n+    }\n+}\n+\n+#[test]\n+fn sync3() {\n+    let (tx1, rx1) = sync_channel::<i32>(0);\n+    let (tx2, rx2): (Sender<i32>, Receiver<i32>) = channel();\n+    let _t = thread::spawn(move|| { tx1.send(1).unwrap(); });\n+    let _t = thread::spawn(move|| { tx2.send(2).unwrap(); });\n+    select! {\n+        n = rx1.recv() => {\n+            let n = n.unwrap();\n+            assert_eq!(n, 1);\n+            assert_eq!(rx2.recv().unwrap(), 2);\n+        },\n+        n = rx2.recv() => {\n+            let n = n.unwrap();\n+            assert_eq!(n, 2);\n+            assert_eq!(rx1.recv().unwrap(), 1);\n+        }\n+    }\n+}"}]}