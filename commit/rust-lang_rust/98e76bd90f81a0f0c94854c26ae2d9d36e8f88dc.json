{"sha": "98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc", "node_id": "C_kwDOAAsO6NoAKDk4ZTc2YmQ5MGY4MWEwZjBjOTQ4NTRjMjZhZTJkOWQzNmU4Zjg4ZGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-02T06:59:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-02T06:59:27Z"}, "message": "Auto merge of #14710 - jhgg:chore/refactor-notification-handlers, r=Veykril\n\nchore: rust-analyzer: refactor notification handlers\n\nFixes the FIXME in `on_notification`.\n\n```rust\n// FIXME: Move these implementations out into a module similar to on_request\n```\n\nNo code has changed, this just moves stuff around.", "tree": {"sha": "71fd8e27f1094802abbec9fa0c3a515ca3388b0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71fd8e27f1094802abbec9fa0c3a515ca3388b0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc", "html_url": "https://github.com/rust-lang/rust/commit/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c0c13ec8e47cfe487f46136b394c0372e957968", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c0c13ec8e47cfe487f46136b394c0372e957968", "html_url": "https://github.com/rust-lang/rust/commit/9c0c13ec8e47cfe487f46136b394c0372e957968"}, {"sha": "b9007a26a08063e45ca99eb5e208635e9a7f1c01", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9007a26a08063e45ca99eb5e208635e9a7f1c01", "html_url": "https://github.com/rust-lang/rust/commit/b9007a26a08063e45ca99eb5e208635e9a7f1c01"}], "stats": {"total": 4415, "additions": 2248, "deletions": 2167}, "files": [{"sha": "a00d0fba7c4e3efb82c2d97411680ebe7e63e935", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 6, "deletions": 1884, "changes": 1890, "blob_url": "https://github.com/rust-lang/rust/blob/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc", "patch": "@@ -2,1336 +2,14 @@\n //! Protocol. The majority of requests are fulfilled by calling into the\n //! `ide` crate.\n \n-use std::{\n-    io::Write as _,\n-    process::{self, Stdio},\n-    sync::Arc,\n-};\n+use ide::AssistResolveStrategy;\n+use lsp_types::{Diagnostic, DiagnosticTag, NumberOrString};\n+use vfs::FileId;\n \n-use anyhow::Context;\n-use ide::{\n-    AnnotationConfig, AssistKind, AssistResolveStrategy, Cancellable, FileId, FilePosition,\n-    FileRange, HoverAction, HoverGotoTypeData, Query, RangeInfo, ReferenceCategory, Runnable,\n-    RunnableKind, SingleResolve, SourceChange, TextEdit,\n-};\n-use ide_db::SymbolKind;\n-use lsp_server::ErrorCode;\n-use lsp_types::{\n-    CallHierarchyIncomingCall, CallHierarchyIncomingCallsParams, CallHierarchyItem,\n-    CallHierarchyOutgoingCall, CallHierarchyOutgoingCallsParams, CallHierarchyPrepareParams,\n-    CodeLens, CompletionItem, Diagnostic, DiagnosticTag, DocumentFormattingParams, FoldingRange,\n-    FoldingRangeParams, HoverContents, InlayHint, InlayHintParams, Location, LocationLink,\n-    NumberOrString, Position, PrepareRenameResponse, Range, RenameParams,\n-    SemanticTokensDeltaParams, SemanticTokensFullDeltaResult, SemanticTokensParams,\n-    SemanticTokensRangeParams, SemanticTokensRangeResult, SemanticTokensResult, SymbolInformation,\n-    SymbolTag, TextDocumentIdentifier, Url, WorkspaceEdit,\n-};\n-use project_model::{ManifestPath, ProjectWorkspace, TargetKind};\n-use serde_json::json;\n-use stdx::{format_to, never};\n-use syntax::{algo, ast, AstNode, TextRange, TextSize};\n-use vfs::{AbsPath, AbsPathBuf};\n+use crate::{global_state::GlobalStateSnapshot, to_proto, Result};\n \n-use crate::{\n-    cargo_target_spec::CargoTargetSpec,\n-    config::{RustfmtConfig, WorkspaceSymbolConfig},\n-    diff::diff,\n-    from_proto,\n-    global_state::{GlobalState, GlobalStateSnapshot},\n-    line_index::LineEndings,\n-    lsp_ext::{self, PositionOrRange, ViewCrateGraphParams, WorkspaceSymbolParams},\n-    lsp_utils::{all_edits_are_disjoint, invalid_params_error},\n-    to_proto, LspError, Result,\n-};\n-\n-pub(crate) fn handle_workspace_reload(state: &mut GlobalState, _: ()) -> Result<()> {\n-    state.proc_macro_clients = Arc::new([]);\n-    state.proc_macro_changed = false;\n-\n-    state.fetch_workspaces_queue.request_op(\"reload workspace request\".to_string(), ());\n-    Ok(())\n-}\n-\n-pub(crate) fn handle_proc_macros_rebuild(state: &mut GlobalState, _: ()) -> Result<()> {\n-    state.proc_macro_clients = Arc::new([]);\n-    state.proc_macro_changed = false;\n-\n-    state.fetch_build_data_queue.request_op(\"rebuild proc macros request\".to_string(), ());\n-    Ok(())\n-}\n-\n-pub(crate) fn handle_cancel_flycheck(state: &mut GlobalState, _: ()) -> Result<()> {\n-    let _p = profile::span(\"handle_stop_flycheck\");\n-    state.flycheck.iter().for_each(|flycheck| flycheck.cancel());\n-    Ok(())\n-}\n-\n-pub(crate) fn handle_analyzer_status(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_ext::AnalyzerStatusParams,\n-) -> Result<String> {\n-    let _p = profile::span(\"handle_analyzer_status\");\n-\n-    let mut buf = String::new();\n-\n-    let mut file_id = None;\n-    if let Some(tdi) = params.text_document {\n-        match from_proto::file_id(&snap, &tdi.uri) {\n-            Ok(it) => file_id = Some(it),\n-            Err(_) => format_to!(buf, \"file {} not found in vfs\", tdi.uri),\n-        }\n-    }\n-\n-    if snap.workspaces.is_empty() {\n-        buf.push_str(\"No workspaces\\n\")\n-    } else {\n-        buf.push_str(\"Workspaces:\\n\");\n-        format_to!(\n-            buf,\n-            \"Loaded {:?} packages across {} workspace{}.\\n\",\n-            snap.workspaces.iter().map(|w| w.n_packages()).sum::<usize>(),\n-            snap.workspaces.len(),\n-            if snap.workspaces.len() == 1 { \"\" } else { \"s\" }\n-        );\n-\n-        format_to!(\n-            buf,\n-            \"Workspace root folders: {:?}\",\n-            snap.workspaces\n-                .iter()\n-                .flat_map(|ws| ws.workspace_definition_path())\n-                .collect::<Vec<&AbsPath>>()\n-        );\n-    }\n-    format_to!(buf, \"\\nVfs memory usage: {}\\n\", snap.vfs_memory_usage());\n-    buf.push_str(\"\\nAnalysis:\\n\");\n-    buf.push_str(\n-        &snap\n-            .analysis\n-            .status(file_id)\n-            .unwrap_or_else(|_| \"Analysis retrieval was cancelled\".to_owned()),\n-    );\n-    Ok(buf)\n-}\n-\n-pub(crate) fn handle_memory_usage(state: &mut GlobalState, _: ()) -> Result<String> {\n-    let _p = profile::span(\"handle_memory_usage\");\n-    let mut mem = state.analysis_host.per_query_memory_usage();\n-    mem.push((\"Remaining\".into(), profile::memory_usage().allocated));\n-\n-    let mut out = String::new();\n-    for (name, bytes) in mem {\n-        format_to!(out, \"{:>8} {}\\n\", bytes, name);\n-    }\n-    Ok(out)\n-}\n-\n-pub(crate) fn handle_shuffle_crate_graph(state: &mut GlobalState, _: ()) -> Result<()> {\n-    state.analysis_host.shuffle_crate_graph();\n-    Ok(())\n-}\n-\n-pub(crate) fn handle_syntax_tree(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_ext::SyntaxTreeParams,\n-) -> Result<String> {\n-    let _p = profile::span(\"handle_syntax_tree\");\n-    let id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.file_line_index(id)?;\n-    let text_range = params.range.and_then(|r| from_proto::text_range(&line_index, r).ok());\n-    let res = snap.analysis.syntax_tree(id, text_range)?;\n-    Ok(res)\n-}\n-\n-pub(crate) fn handle_view_hir(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::TextDocumentPositionParams,\n-) -> Result<String> {\n-    let _p = profile::span(\"handle_view_hir\");\n-    let position = from_proto::file_position(&snap, params)?;\n-    let res = snap.analysis.view_hir(position)?;\n-    Ok(res)\n-}\n-\n-pub(crate) fn handle_view_mir(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::TextDocumentPositionParams,\n-) -> Result<String> {\n-    let _p = profile::span(\"handle_view_mir\");\n-    let position = from_proto::file_position(&snap, params)?;\n-    let res = snap.analysis.view_mir(position)?;\n-    Ok(res)\n-}\n-\n-pub(crate) fn handle_interpret_function(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::TextDocumentPositionParams,\n-) -> Result<String> {\n-    let _p = profile::span(\"handle_interpret_function\");\n-    let position = from_proto::file_position(&snap, params)?;\n-    let res = snap.analysis.interpret_function(position)?;\n-    Ok(res)\n-}\n-\n-pub(crate) fn handle_view_file_text(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::TextDocumentIdentifier,\n-) -> Result<String> {\n-    let file_id = from_proto::file_id(&snap, &params.uri)?;\n-    Ok(snap.analysis.file_text(file_id)?.to_string())\n-}\n-\n-pub(crate) fn handle_view_item_tree(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_ext::ViewItemTreeParams,\n-) -> Result<String> {\n-    let _p = profile::span(\"handle_view_item_tree\");\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let res = snap.analysis.view_item_tree(file_id)?;\n-    Ok(res)\n-}\n-\n-pub(crate) fn handle_view_crate_graph(\n-    snap: GlobalStateSnapshot,\n-    params: ViewCrateGraphParams,\n-) -> Result<String> {\n-    let _p = profile::span(\"handle_view_crate_graph\");\n-    let dot = snap.analysis.view_crate_graph(params.full)??;\n-    Ok(dot)\n-}\n-\n-pub(crate) fn handle_expand_macro(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_ext::ExpandMacroParams,\n-) -> Result<Option<lsp_ext::ExpandedMacro>> {\n-    let _p = profile::span(\"handle_expand_macro\");\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-    let offset = from_proto::offset(&line_index, params.position)?;\n-\n-    let res = snap.analysis.expand_macro(FilePosition { file_id, offset })?;\n-    Ok(res.map(|it| lsp_ext::ExpandedMacro { name: it.name, expansion: it.expansion }))\n-}\n-\n-pub(crate) fn handle_selection_range(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::SelectionRangeParams,\n-) -> Result<Option<Vec<lsp_types::SelectionRange>>> {\n-    let _p = profile::span(\"handle_selection_range\");\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-    let res: Result<Vec<lsp_types::SelectionRange>> = params\n-        .positions\n-        .into_iter()\n-        .map(|position| {\n-            let offset = from_proto::offset(&line_index, position)?;\n-            let mut ranges = Vec::new();\n-            {\n-                let mut range = TextRange::new(offset, offset);\n-                loop {\n-                    ranges.push(range);\n-                    let frange = FileRange { file_id, range };\n-                    let next = snap.analysis.extend_selection(frange)?;\n-                    if next == range {\n-                        break;\n-                    } else {\n-                        range = next\n-                    }\n-                }\n-            }\n-            let mut range = lsp_types::SelectionRange {\n-                range: to_proto::range(&line_index, *ranges.last().unwrap()),\n-                parent: None,\n-            };\n-            for &r in ranges.iter().rev().skip(1) {\n-                range = lsp_types::SelectionRange {\n-                    range: to_proto::range(&line_index, r),\n-                    parent: Some(Box::new(range)),\n-                }\n-            }\n-            Ok(range)\n-        })\n-        .collect();\n-\n-    Ok(Some(res?))\n-}\n-\n-pub(crate) fn handle_matching_brace(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_ext::MatchingBraceParams,\n-) -> Result<Vec<Position>> {\n-    let _p = profile::span(\"handle_matching_brace\");\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-    params\n-        .positions\n-        .into_iter()\n-        .map(|position| {\n-            let offset = from_proto::offset(&line_index, position);\n-            offset.map(|offset| {\n-                let offset = match snap.analysis.matching_brace(FilePosition { file_id, offset }) {\n-                    Ok(Some(matching_brace_offset)) => matching_brace_offset,\n-                    Err(_) | Ok(None) => offset,\n-                };\n-                to_proto::position(&line_index, offset)\n-            })\n-        })\n-        .collect()\n-}\n-\n-pub(crate) fn handle_join_lines(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_ext::JoinLinesParams,\n-) -> Result<Vec<lsp_types::TextEdit>> {\n-    let _p = profile::span(\"handle_join_lines\");\n-\n-    let config = snap.config.join_lines();\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-\n-    let mut res = TextEdit::default();\n-    for range in params.ranges {\n-        let range = from_proto::text_range(&line_index, range)?;\n-        let edit = snap.analysis.join_lines(&config, FileRange { file_id, range })?;\n-        match res.union(edit) {\n-            Ok(()) => (),\n-            Err(_edit) => {\n-                // just ignore overlapping edits\n-            }\n-        }\n-    }\n-\n-    Ok(to_proto::text_edit_vec(&line_index, res))\n-}\n-\n-pub(crate) fn handle_on_enter(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::TextDocumentPositionParams,\n-) -> Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {\n-    let _p = profile::span(\"handle_on_enter\");\n-    let position = from_proto::file_position(&snap, params)?;\n-    let edit = match snap.analysis.on_enter(position)? {\n-        None => return Ok(None),\n-        Some(it) => it,\n-    };\n-    let line_index = snap.file_line_index(position.file_id)?;\n-    let edit = to_proto::snippet_text_edit_vec(&line_index, true, edit);\n-    Ok(Some(edit))\n-}\n-\n-pub(crate) fn handle_on_type_formatting(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::DocumentOnTypeFormattingParams,\n-) -> Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {\n-    let _p = profile::span(\"handle_on_type_formatting\");\n-    let mut position = from_proto::file_position(&snap, params.text_document_position)?;\n-    let line_index = snap.file_line_index(position.file_id)?;\n-\n-    // in `ide`, the `on_type` invariant is that\n-    // `text.char_at(position) == typed_char`.\n-    position.offset -= TextSize::of('.');\n-    let char_typed = params.ch.chars().next().unwrap_or('\\0');\n-\n-    let text = snap.analysis.file_text(position.file_id)?;\n-    if stdx::never!(!text[usize::from(position.offset)..].starts_with(char_typed)) {\n-        return Ok(None);\n-    }\n-\n-    // We have an assist that inserts ` ` after typing `->` in `fn foo() ->{`,\n-    // but it requires precise cursor positioning to work, and one can't\n-    // position the cursor with on_type formatting. So, let's just toggle this\n-    // feature off here, hoping that we'll enable it one day, \ud83d\ude3f.\n-    if char_typed == '>' {\n-        return Ok(None);\n-    }\n-\n-    let edit =\n-        snap.analysis.on_char_typed(position, char_typed, snap.config.typing_autoclose_angle())?;\n-    let edit = match edit {\n-        Some(it) => it,\n-        None => return Ok(None),\n-    };\n-\n-    // This should be a single-file edit\n-    let (_, text_edit) = edit.source_file_edits.into_iter().next().unwrap();\n-\n-    let change = to_proto::snippet_text_edit_vec(&line_index, edit.is_snippet, text_edit);\n-    Ok(Some(change))\n-}\n-\n-pub(crate) fn handle_document_symbol(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::DocumentSymbolParams,\n-) -> Result<Option<lsp_types::DocumentSymbolResponse>> {\n-    let _p = profile::span(\"handle_document_symbol\");\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-\n-    let mut parents: Vec<(lsp_types::DocumentSymbol, Option<usize>)> = Vec::new();\n-\n-    for symbol in snap.analysis.file_structure(file_id)? {\n-        let mut tags = Vec::new();\n-        if symbol.deprecated {\n-            tags.push(SymbolTag::DEPRECATED)\n-        };\n-\n-        #[allow(deprecated)]\n-        let doc_symbol = lsp_types::DocumentSymbol {\n-            name: symbol.label,\n-            detail: symbol.detail,\n-            kind: to_proto::structure_node_kind(symbol.kind),\n-            tags: Some(tags),\n-            deprecated: Some(symbol.deprecated),\n-            range: to_proto::range(&line_index, symbol.node_range),\n-            selection_range: to_proto::range(&line_index, symbol.navigation_range),\n-            children: None,\n-        };\n-        parents.push((doc_symbol, symbol.parent));\n-    }\n-\n-    // Builds hierarchy from a flat list, in reverse order (so that indices\n-    // makes sense)\n-    let document_symbols = {\n-        let mut acc = Vec::new();\n-        while let Some((mut node, parent_idx)) = parents.pop() {\n-            if let Some(children) = &mut node.children {\n-                children.reverse();\n-            }\n-            let parent = match parent_idx {\n-                None => &mut acc,\n-                Some(i) => parents[i].0.children.get_or_insert_with(Vec::new),\n-            };\n-            parent.push(node);\n-        }\n-        acc.reverse();\n-        acc\n-    };\n-\n-    let res = if snap.config.hierarchical_symbols() {\n-        document_symbols.into()\n-    } else {\n-        let url = to_proto::url(&snap, file_id);\n-        let mut symbol_information = Vec::<SymbolInformation>::new();\n-        for symbol in document_symbols {\n-            flatten_document_symbol(&symbol, None, &url, &mut symbol_information);\n-        }\n-        symbol_information.into()\n-    };\n-    return Ok(Some(res));\n-\n-    fn flatten_document_symbol(\n-        symbol: &lsp_types::DocumentSymbol,\n-        container_name: Option<String>,\n-        url: &Url,\n-        res: &mut Vec<SymbolInformation>,\n-    ) {\n-        let mut tags = Vec::new();\n-\n-        #[allow(deprecated)]\n-        if let Some(true) = symbol.deprecated {\n-            tags.push(SymbolTag::DEPRECATED)\n-        }\n-\n-        #[allow(deprecated)]\n-        res.push(SymbolInformation {\n-            name: symbol.name.clone(),\n-            kind: symbol.kind,\n-            tags: Some(tags),\n-            deprecated: symbol.deprecated,\n-            location: Location::new(url.clone(), symbol.range),\n-            container_name,\n-        });\n-\n-        for child in symbol.children.iter().flatten() {\n-            flatten_document_symbol(child, Some(symbol.name.clone()), url, res);\n-        }\n-    }\n-}\n-\n-pub(crate) fn handle_workspace_symbol(\n-    snap: GlobalStateSnapshot,\n-    params: WorkspaceSymbolParams,\n-) -> Result<Option<Vec<SymbolInformation>>> {\n-    let _p = profile::span(\"handle_workspace_symbol\");\n-\n-    let config = snap.config.workspace_symbol();\n-    let (all_symbols, libs) = decide_search_scope_and_kind(&params, &config);\n-    let limit = config.search_limit;\n-\n-    let query = {\n-        let query: String = params.query.chars().filter(|&c| c != '#' && c != '*').collect();\n-        let mut q = Query::new(query);\n-        if !all_symbols {\n-            q.only_types();\n-        }\n-        if libs {\n-            q.libs();\n-        }\n-        q.limit(limit);\n-        q\n-    };\n-    let mut res = exec_query(&snap, query)?;\n-    if res.is_empty() && !all_symbols {\n-        let mut query = Query::new(params.query);\n-        query.limit(limit);\n-        res = exec_query(&snap, query)?;\n-    }\n-\n-    return Ok(Some(res));\n-\n-    fn decide_search_scope_and_kind(\n-        params: &WorkspaceSymbolParams,\n-        config: &WorkspaceSymbolConfig,\n-    ) -> (bool, bool) {\n-        // Support old-style parsing of markers in the query.\n-        let mut all_symbols = params.query.contains('#');\n-        let mut libs = params.query.contains('*');\n-\n-        // If no explicit marker was set, check request params. If that's also empty\n-        // use global config.\n-        if !all_symbols {\n-            let search_kind = match params.search_kind {\n-                Some(ref search_kind) => search_kind,\n-                None => &config.search_kind,\n-            };\n-            all_symbols = match search_kind {\n-                lsp_ext::WorkspaceSymbolSearchKind::OnlyTypes => false,\n-                lsp_ext::WorkspaceSymbolSearchKind::AllSymbols => true,\n-            }\n-        }\n-\n-        if !libs {\n-            let search_scope = match params.search_scope {\n-                Some(ref search_scope) => search_scope,\n-                None => &config.search_scope,\n-            };\n-            libs = match search_scope {\n-                lsp_ext::WorkspaceSymbolSearchScope::Workspace => false,\n-                lsp_ext::WorkspaceSymbolSearchScope::WorkspaceAndDependencies => true,\n-            }\n-        }\n-\n-        (all_symbols, libs)\n-    }\n-\n-    fn exec_query(snap: &GlobalStateSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n-        let mut res = Vec::new();\n-        for nav in snap.analysis.symbol_search(query)? {\n-            let container_name = nav.container_name.as_ref().map(|v| v.to_string());\n-\n-            #[allow(deprecated)]\n-            let info = SymbolInformation {\n-                name: nav.name.to_string(),\n-                kind: nav\n-                    .kind\n-                    .map(to_proto::symbol_kind)\n-                    .unwrap_or(lsp_types::SymbolKind::VARIABLE),\n-                tags: None,\n-                location: to_proto::location_from_nav(snap, nav)?,\n-                container_name,\n-                deprecated: None,\n-            };\n-            res.push(info);\n-        }\n-        Ok(res)\n-    }\n-}\n-\n-pub(crate) fn handle_will_rename_files(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::RenameFilesParams,\n-) -> Result<Option<lsp_types::WorkspaceEdit>> {\n-    let _p = profile::span(\"handle_will_rename_files\");\n-\n-    let source_changes: Vec<SourceChange> = params\n-        .files\n-        .into_iter()\n-        .filter_map(|file_rename| {\n-            let from = Url::parse(&file_rename.old_uri).ok()?;\n-            let to = Url::parse(&file_rename.new_uri).ok()?;\n-\n-            let from_path = from.to_file_path().ok()?;\n-            let to_path = to.to_file_path().ok()?;\n-\n-            // Limit to single-level moves for now.\n-            match (from_path.parent(), to_path.parent()) {\n-                (Some(p1), Some(p2)) if p1 == p2 => {\n-                    if from_path.is_dir() {\n-                        // add '/' to end of url -- from `file://path/to/folder` to `file://path/to/folder/`\n-                        let mut old_folder_name = from_path.file_stem()?.to_str()?.to_string();\n-                        old_folder_name.push('/');\n-                        let from_with_trailing_slash = from.join(&old_folder_name).ok()?;\n-\n-                        let imitate_from_url = from_with_trailing_slash.join(\"mod.rs\").ok()?;\n-                        let new_file_name = to_path.file_name()?.to_str()?;\n-                        Some((\n-                            snap.url_to_file_id(&imitate_from_url).ok()?,\n-                            new_file_name.to_string(),\n-                        ))\n-                    } else {\n-                        let old_name = from_path.file_stem()?.to_str()?;\n-                        let new_name = to_path.file_stem()?.to_str()?;\n-                        match (old_name, new_name) {\n-                            (\"mod\", _) => None,\n-                            (_, \"mod\") => None,\n-                            _ => Some((snap.url_to_file_id(&from).ok()?, new_name.to_string())),\n-                        }\n-                    }\n-                }\n-                _ => None,\n-            }\n-        })\n-        .filter_map(|(file_id, new_name)| {\n-            snap.analysis.will_rename_file(file_id, &new_name).ok()?\n-        })\n-        .collect();\n-\n-    // Drop file system edits since we're just renaming things on the same level\n-    let mut source_changes = source_changes.into_iter();\n-    let mut source_change = source_changes.next().unwrap_or_default();\n-    source_change.file_system_edits.clear();\n-    // no collect here because we want to merge text edits on same file ids\n-    source_change.extend(source_changes.flat_map(|it| it.source_file_edits));\n-    if source_change.source_file_edits.is_empty() {\n-        Ok(None)\n-    } else {\n-        Ok(Some(to_proto::workspace_edit(&snap, source_change)?))\n-    }\n-}\n-\n-pub(crate) fn handle_goto_definition(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::GotoDefinitionParams,\n-) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n-    let _p = profile::span(\"handle_goto_definition\");\n-    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let nav_info = match snap.analysis.goto_definition(position)? {\n-        None => return Ok(None),\n-        Some(it) => it,\n-    };\n-    let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_goto_declaration(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::request::GotoDeclarationParams,\n-) -> Result<Option<lsp_types::request::GotoDeclarationResponse>> {\n-    let _p = profile::span(\"handle_goto_declaration\");\n-    let position = from_proto::file_position(&snap, params.text_document_position_params.clone())?;\n-    let nav_info = match snap.analysis.goto_declaration(position)? {\n-        None => return handle_goto_definition(snap, params),\n-        Some(it) => it,\n-    };\n-    let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_goto_implementation(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::request::GotoImplementationParams,\n-) -> Result<Option<lsp_types::request::GotoImplementationResponse>> {\n-    let _p = profile::span(\"handle_goto_implementation\");\n-    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let nav_info = match snap.analysis.goto_implementation(position)? {\n-        None => return Ok(None),\n-        Some(it) => it,\n-    };\n-    let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_goto_type_definition(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::request::GotoTypeDefinitionParams,\n-) -> Result<Option<lsp_types::request::GotoTypeDefinitionResponse>> {\n-    let _p = profile::span(\"handle_goto_type_definition\");\n-    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let nav_info = match snap.analysis.goto_type_definition(position)? {\n-        None => return Ok(None),\n-        Some(it) => it,\n-    };\n-    let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_parent_module(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::TextDocumentPositionParams,\n-) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n-    let _p = profile::span(\"handle_parent_module\");\n-    if let Ok(file_path) = &params.text_document.uri.to_file_path() {\n-        if file_path.file_name().unwrap_or_default() == \"Cargo.toml\" {\n-            // search workspaces for parent packages or fallback to workspace root\n-            let abs_path_buf = match AbsPathBuf::try_from(file_path.to_path_buf()).ok() {\n-                Some(abs_path_buf) => abs_path_buf,\n-                None => return Ok(None),\n-            };\n-\n-            let manifest_path = match ManifestPath::try_from(abs_path_buf).ok() {\n-                Some(manifest_path) => manifest_path,\n-                None => return Ok(None),\n-            };\n-\n-            let links: Vec<LocationLink> = snap\n-                .workspaces\n-                .iter()\n-                .filter_map(|ws| match ws {\n-                    ProjectWorkspace::Cargo { cargo, .. } => cargo.parent_manifests(&manifest_path),\n-                    _ => None,\n-                })\n-                .flatten()\n-                .map(|parent_manifest_path| LocationLink {\n-                    origin_selection_range: None,\n-                    target_uri: to_proto::url_from_abs_path(&parent_manifest_path),\n-                    target_range: Range::default(),\n-                    target_selection_range: Range::default(),\n-                })\n-                .collect::<_>();\n-            return Ok(Some(links.into()));\n-        }\n-\n-        // check if invoked at the crate root\n-        let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-        let crate_id = match snap.analysis.crates_for(file_id)?.first() {\n-            Some(&crate_id) => crate_id,\n-            None => return Ok(None),\n-        };\n-        let cargo_spec = match CargoTargetSpec::for_file(&snap, file_id)? {\n-            Some(it) => it,\n-            None => return Ok(None),\n-        };\n-\n-        if snap.analysis.crate_root(crate_id)? == file_id {\n-            let cargo_toml_url = to_proto::url_from_abs_path(&cargo_spec.cargo_toml);\n-            let res = vec![LocationLink {\n-                origin_selection_range: None,\n-                target_uri: cargo_toml_url,\n-                target_range: Range::default(),\n-                target_selection_range: Range::default(),\n-            }]\n-            .into();\n-            return Ok(Some(res));\n-        }\n-    }\n-\n-    // locate parent module by semantics\n-    let position = from_proto::file_position(&snap, params)?;\n-    let navs = snap.analysis.parent_module(position)?;\n-    let res = to_proto::goto_definition_response(&snap, None, navs)?;\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_runnables(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_ext::RunnablesParams,\n-) -> Result<Vec<lsp_ext::Runnable>> {\n-    let _p = profile::span(\"handle_runnables\");\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-    let offset = params.position.and_then(|it| from_proto::offset(&line_index, it).ok());\n-    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n-\n-    let expect_test = match offset {\n-        Some(offset) => {\n-            let source_file = snap.analysis.parse(file_id)?;\n-            algo::find_node_at_offset::<ast::MacroCall>(source_file.syntax(), offset)\n-                .and_then(|it| it.path()?.segment()?.name_ref())\n-                .map_or(false, |it| it.text() == \"expect\" || it.text() == \"expect_file\")\n-        }\n-        None => false,\n-    };\n-\n-    let mut res = Vec::new();\n-    for runnable in snap.analysis.runnables(file_id)? {\n-        if should_skip_for_offset(&runnable, offset) {\n-            continue;\n-        }\n-        if should_skip_target(&runnable, cargo_spec.as_ref()) {\n-            continue;\n-        }\n-        let mut runnable = to_proto::runnable(&snap, runnable)?;\n-        if expect_test {\n-            runnable.label = format!(\"{} + expect\", runnable.label);\n-            runnable.args.expect_test = Some(true);\n-        }\n-        res.push(runnable);\n-    }\n-\n-    // Add `cargo check` and `cargo test` for all targets of the whole package\n-    let config = snap.config.runnables();\n-    match cargo_spec {\n-        Some(spec) => {\n-            for cmd in [\"check\", \"test\"] {\n-                res.push(lsp_ext::Runnable {\n-                    label: format!(\"cargo {cmd} -p {} --all-targets\", spec.package),\n-                    location: None,\n-                    kind: lsp_ext::RunnableKind::Cargo,\n-                    args: lsp_ext::CargoRunnable {\n-                        workspace_root: Some(spec.workspace_root.clone().into()),\n-                        override_cargo: config.override_cargo.clone(),\n-                        cargo_args: vec![\n-                            cmd.to_string(),\n-                            \"--package\".to_string(),\n-                            spec.package.clone(),\n-                            \"--all-targets\".to_string(),\n-                        ],\n-                        cargo_extra_args: config.cargo_extra_args.clone(),\n-                        executable_args: Vec::new(),\n-                        expect_test: None,\n-                    },\n-                })\n-            }\n-        }\n-        None => {\n-            if !snap.config.linked_projects().is_empty() {\n-                res.push(lsp_ext::Runnable {\n-                    label: \"cargo check --workspace\".to_string(),\n-                    location: None,\n-                    kind: lsp_ext::RunnableKind::Cargo,\n-                    args: lsp_ext::CargoRunnable {\n-                        workspace_root: None,\n-                        override_cargo: config.override_cargo,\n-                        cargo_args: vec![\"check\".to_string(), \"--workspace\".to_string()],\n-                        cargo_extra_args: config.cargo_extra_args,\n-                        executable_args: Vec::new(),\n-                        expect_test: None,\n-                    },\n-                });\n-            }\n-        }\n-    }\n-    Ok(res)\n-}\n-\n-fn should_skip_for_offset(runnable: &Runnable, offset: Option<TextSize>) -> bool {\n-    match offset {\n-        None => false,\n-        _ if matches!(&runnable.kind, RunnableKind::TestMod { .. }) => false,\n-        Some(offset) => !runnable.nav.full_range.contains_inclusive(offset),\n-    }\n-}\n-\n-pub(crate) fn handle_related_tests(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::TextDocumentPositionParams,\n-) -> Result<Vec<lsp_ext::TestInfo>> {\n-    let _p = profile::span(\"handle_related_tests\");\n-    let position = from_proto::file_position(&snap, params)?;\n-\n-    let tests = snap.analysis.related_tests(position, None)?;\n-    let mut res = Vec::new();\n-    for it in tests {\n-        if let Ok(runnable) = to_proto::runnable(&snap, it) {\n-            res.push(lsp_ext::TestInfo { runnable })\n-        }\n-    }\n-\n-    Ok(res)\n-}\n-\n-pub(crate) fn handle_completion(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::CompletionParams,\n-) -> Result<Option<lsp_types::CompletionResponse>> {\n-    let _p = profile::span(\"handle_completion\");\n-    let text_document_position = params.text_document_position.clone();\n-    let position = from_proto::file_position(&snap, params.text_document_position)?;\n-    let completion_trigger_character =\n-        params.context.and_then(|ctx| ctx.trigger_character).and_then(|s| s.chars().next());\n-\n-    let completion_config = &snap.config.completion();\n-    let items = match snap.analysis.completions(\n-        completion_config,\n-        position,\n-        completion_trigger_character,\n-    )? {\n-        None => return Ok(None),\n-        Some(items) => items,\n-    };\n-    let line_index = snap.file_line_index(position.file_id)?;\n-\n-    let items =\n-        to_proto::completion_items(&snap.config, &line_index, text_document_position, items);\n-\n-    let completion_list = lsp_types::CompletionList { is_incomplete: true, items };\n-    Ok(Some(completion_list.into()))\n-}\n-\n-pub(crate) fn handle_completion_resolve(\n-    snap: GlobalStateSnapshot,\n-    mut original_completion: CompletionItem,\n-) -> Result<CompletionItem> {\n-    let _p = profile::span(\"handle_completion_resolve\");\n-\n-    if !all_edits_are_disjoint(&original_completion, &[]) {\n-        return Err(invalid_params_error(\n-            \"Received a completion with overlapping edits, this is not LSP-compliant\".to_string(),\n-        )\n-        .into());\n-    }\n-\n-    let data = match original_completion.data.take() {\n-        Some(it) => it,\n-        None => return Ok(original_completion),\n-    };\n-\n-    let resolve_data: lsp_ext::CompletionResolveData = serde_json::from_value(data)?;\n-\n-    let file_id = from_proto::file_id(&snap, &resolve_data.position.text_document.uri)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-    let offset = from_proto::offset(&line_index, resolve_data.position.position)?;\n-\n-    let additional_edits = snap\n-        .analysis\n-        .resolve_completion_edits(\n-            &snap.config.completion(),\n-            FilePosition { file_id, offset },\n-            resolve_data\n-                .imports\n-                .into_iter()\n-                .map(|import| (import.full_import_path, import.imported_name)),\n-        )?\n-        .into_iter()\n-        .flat_map(|edit| edit.into_iter().map(|indel| to_proto::text_edit(&line_index, indel)))\n-        .collect::<Vec<_>>();\n-\n-    if !all_edits_are_disjoint(&original_completion, &additional_edits) {\n-        return Err(LspError::new(\n-            ErrorCode::InternalError as i32,\n-            \"Import edit overlaps with the original completion edits, this is not LSP-compliant\"\n-                .into(),\n-        )\n-        .into());\n-    }\n-\n-    if let Some(original_additional_edits) = original_completion.additional_text_edits.as_mut() {\n-        original_additional_edits.extend(additional_edits.into_iter())\n-    } else {\n-        original_completion.additional_text_edits = Some(additional_edits);\n-    }\n-\n-    Ok(original_completion)\n-}\n-\n-pub(crate) fn handle_folding_range(\n-    snap: GlobalStateSnapshot,\n-    params: FoldingRangeParams,\n-) -> Result<Option<Vec<FoldingRange>>> {\n-    let _p = profile::span(\"handle_folding_range\");\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let folds = snap.analysis.folding_ranges(file_id)?;\n-    let text = snap.analysis.file_text(file_id)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-    let line_folding_only = snap.config.line_folding_only();\n-    let res = folds\n-        .into_iter()\n-        .map(|it| to_proto::folding_range(&text, &line_index, line_folding_only, it))\n-        .collect();\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_signature_help(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::SignatureHelpParams,\n-) -> Result<Option<lsp_types::SignatureHelp>> {\n-    let _p = profile::span(\"handle_signature_help\");\n-    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let help = match snap.analysis.signature_help(position)? {\n-        Some(it) => it,\n-        None => return Ok(None),\n-    };\n-    let config = snap.config.call_info();\n-    let res = to_proto::signature_help(help, config, snap.config.signature_help_label_offsets());\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_hover(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_ext::HoverParams,\n-) -> Result<Option<lsp_ext::Hover>> {\n-    let _p = profile::span(\"handle_hover\");\n-    let range = match params.position {\n-        PositionOrRange::Position(position) => Range::new(position, position),\n-        PositionOrRange::Range(range) => range,\n-    };\n-\n-    let file_range = from_proto::file_range(&snap, params.text_document, range)?;\n-    let info = match snap.analysis.hover(&snap.config.hover(), file_range)? {\n-        None => return Ok(None),\n-        Some(info) => info,\n-    };\n-\n-    let line_index = snap.file_line_index(file_range.file_id)?;\n-    let range = to_proto::range(&line_index, info.range);\n-    let markup_kind = snap.config.hover().format;\n-    let hover = lsp_ext::Hover {\n-        hover: lsp_types::Hover {\n-            contents: HoverContents::Markup(to_proto::markup_content(\n-                info.info.markup,\n-                markup_kind,\n-            )),\n-            range: Some(range),\n-        },\n-        actions: if snap.config.hover_actions().none() {\n-            Vec::new()\n-        } else {\n-            prepare_hover_actions(&snap, &info.info.actions)\n-        },\n-    };\n-\n-    Ok(Some(hover))\n-}\n-\n-pub(crate) fn handle_prepare_rename(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::TextDocumentPositionParams,\n-) -> Result<Option<PrepareRenameResponse>> {\n-    let _p = profile::span(\"handle_prepare_rename\");\n-    let position = from_proto::file_position(&snap, params)?;\n-\n-    let change = snap.analysis.prepare_rename(position)?.map_err(to_proto::rename_error)?;\n-\n-    let line_index = snap.file_line_index(position.file_id)?;\n-    let range = to_proto::range(&line_index, change.range);\n-    Ok(Some(PrepareRenameResponse::Range(range)))\n-}\n-\n-pub(crate) fn handle_rename(\n-    snap: GlobalStateSnapshot,\n-    params: RenameParams,\n-) -> Result<Option<WorkspaceEdit>> {\n-    let _p = profile::span(\"handle_rename\");\n-    let position = from_proto::file_position(&snap, params.text_document_position)?;\n-\n-    let mut change =\n-        snap.analysis.rename(position, &params.new_name)?.map_err(to_proto::rename_error)?;\n-\n-    // this is kind of a hack to prevent double edits from happening when moving files\n-    // When a module gets renamed by renaming the mod declaration this causes the file to move\n-    // which in turn will trigger a WillRenameFiles request to the server for which we reply with a\n-    // a second identical set of renames, the client will then apply both edits causing incorrect edits\n-    // with this we only emit source_file_edits in the WillRenameFiles response which will do the rename instead\n-    // See https://github.com/microsoft/vscode-languageserver-node/issues/752 for more info\n-    if !change.file_system_edits.is_empty() && snap.config.will_rename() {\n-        change.source_file_edits.clear();\n-    }\n-    let workspace_edit = to_proto::workspace_edit(&snap, change)?;\n-    Ok(Some(workspace_edit))\n-}\n-\n-pub(crate) fn handle_references(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::ReferenceParams,\n-) -> Result<Option<Vec<Location>>> {\n-    let _p = profile::span(\"handle_references\");\n-    let position = from_proto::file_position(&snap, params.text_document_position)?;\n-\n-    let exclude_imports = snap.config.find_all_refs_exclude_imports();\n-\n-    let refs = match snap.analysis.find_all_refs(position, None)? {\n-        None => return Ok(None),\n-        Some(refs) => refs,\n-    };\n-\n-    let include_declaration = params.context.include_declaration;\n-    let locations = refs\n-        .into_iter()\n-        .flat_map(|refs| {\n-            let decl = if include_declaration {\n-                refs.declaration.map(|decl| FileRange {\n-                    file_id: decl.nav.file_id,\n-                    range: decl.nav.focus_or_full_range(),\n-                })\n-            } else {\n-                None\n-            };\n-            refs.references\n-                .into_iter()\n-                .flat_map(|(file_id, refs)| {\n-                    refs.into_iter()\n-                        .filter(|&(_, category)| {\n-                            !exclude_imports || category != Some(ReferenceCategory::Import)\n-                        })\n-                        .map(move |(range, _)| FileRange { file_id, range })\n-                })\n-                .chain(decl)\n-        })\n-        .filter_map(|frange| to_proto::location(&snap, frange).ok())\n-        .collect();\n-\n-    Ok(Some(locations))\n-}\n-\n-pub(crate) fn handle_formatting(\n-    snap: GlobalStateSnapshot,\n-    params: DocumentFormattingParams,\n-) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n-    let _p = profile::span(\"handle_formatting\");\n-\n-    run_rustfmt(&snap, params.text_document, None)\n-}\n-\n-pub(crate) fn handle_range_formatting(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::DocumentRangeFormattingParams,\n-) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n-    let _p = profile::span(\"handle_range_formatting\");\n-\n-    run_rustfmt(&snap, params.text_document, Some(params.range))\n-}\n-\n-pub(crate) fn handle_code_action(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::CodeActionParams,\n-) -> Result<Option<Vec<lsp_ext::CodeAction>>> {\n-    let _p = profile::span(\"handle_code_action\");\n-\n-    if !snap.config.code_action_literals() {\n-        // We intentionally don't support command-based actions, as those either\n-        // require either custom client-code or server-initiated edits. Server\n-        // initiated edits break causality, so we avoid those.\n-        return Ok(None);\n-    }\n-\n-    let line_index =\n-        snap.file_line_index(from_proto::file_id(&snap, &params.text_document.uri)?)?;\n-    let frange = from_proto::file_range(&snap, params.text_document.clone(), params.range)?;\n-\n-    let mut assists_config = snap.config.assist();\n-    assists_config.allowed = params\n-        .context\n-        .only\n-        .clone()\n-        .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());\n-\n-    let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n-\n-    let code_action_resolve_cap = snap.config.code_action_resolve();\n-    let resolve = if code_action_resolve_cap {\n-        AssistResolveStrategy::None\n-    } else {\n-        AssistResolveStrategy::All\n-    };\n-    let assists = snap.analysis.assists_with_fixes(\n-        &assists_config,\n-        &snap.config.diagnostics(),\n-        resolve,\n-        frange,\n-    )?;\n-    for (index, assist) in assists.into_iter().enumerate() {\n-        let resolve_data =\n-            if code_action_resolve_cap { Some((index, params.clone())) } else { None };\n-        let code_action = to_proto::code_action(&snap, assist, resolve_data)?;\n-        res.push(code_action)\n-    }\n-\n-    // Fixes from `cargo check`.\n-    for fix in snap.check_fixes.values().filter_map(|it| it.get(&frange.file_id)).flatten() {\n-        // FIXME: this mapping is awkward and shouldn't exist. Refactor\n-        // `snap.check_fixes` to not convert to LSP prematurely.\n-        let intersect_fix_range = fix\n-            .ranges\n-            .iter()\n-            .copied()\n-            .filter_map(|range| from_proto::text_range(&line_index, range).ok())\n-            .any(|fix_range| fix_range.intersect(frange.range).is_some());\n-        if intersect_fix_range {\n-            res.push(fix.action.clone());\n-        }\n-    }\n-\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_code_action_resolve(\n-    snap: GlobalStateSnapshot,\n-    mut code_action: lsp_ext::CodeAction,\n-) -> Result<lsp_ext::CodeAction> {\n-    let _p = profile::span(\"handle_code_action_resolve\");\n-    let params = match code_action.data.take() {\n-        Some(it) => it,\n-        None => return Err(invalid_params_error(\"code action without data\".to_string()).into()),\n-    };\n-\n-    let file_id = from_proto::file_id(&snap, &params.code_action_params.text_document.uri)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-    let range = from_proto::text_range(&line_index, params.code_action_params.range)?;\n-    let frange = FileRange { file_id, range };\n-\n-    let mut assists_config = snap.config.assist();\n-    assists_config.allowed = params\n-        .code_action_params\n-        .context\n-        .only\n-        .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());\n-\n-    let (assist_index, assist_resolve) = match parse_action_id(&params.id) {\n-        Ok(parsed_data) => parsed_data,\n-        Err(e) => {\n-            return Err(invalid_params_error(format!(\n-                \"Failed to parse action id string '{}': {e}\",\n-                params.id\n-            ))\n-            .into())\n-        }\n-    };\n-\n-    let expected_assist_id = assist_resolve.assist_id.clone();\n-    let expected_kind = assist_resolve.assist_kind;\n-\n-    let assists = snap.analysis.assists_with_fixes(\n-        &assists_config,\n-        &snap.config.diagnostics(),\n-        AssistResolveStrategy::Single(assist_resolve),\n-        frange,\n-    )?;\n-\n-    let assist = match assists.get(assist_index) {\n-        Some(assist) => assist,\n-        None => return Err(invalid_params_error(format!(\n-            \"Failed to find the assist for index {} provided by the resolve request. Resolve request assist id: {}\",\n-            assist_index, params.id,\n-        ))\n-        .into())\n-    };\n-    if assist.id.0 != expected_assist_id || assist.id.1 != expected_kind {\n-        return Err(invalid_params_error(format!(\n-            \"Mismatching assist at index {} for the resolve parameters given. Resolve request assist id: {}, actual id: {:?}.\",\n-            assist_index, params.id, assist.id\n-        ))\n-        .into());\n-    }\n-    let ca = to_proto::code_action(&snap, assist.clone(), None)?;\n-    code_action.edit = ca.edit;\n-    code_action.command = ca.command;\n-    Ok(code_action)\n-}\n-\n-fn parse_action_id(action_id: &str) -> Result<(usize, SingleResolve), String> {\n-    let id_parts = action_id.split(':').collect::<Vec<_>>();\n-    match id_parts.as_slice() {\n-        [assist_id_string, assist_kind_string, index_string] => {\n-            let assist_kind: AssistKind = assist_kind_string.parse()?;\n-            let index: usize = match index_string.parse() {\n-                Ok(index) => index,\n-                Err(e) => return Err(format!(\"Incorrect index string: {e}\")),\n-            };\n-            Ok((index, SingleResolve { assist_id: assist_id_string.to_string(), assist_kind }))\n-        }\n-        _ => Err(\"Action id contains incorrect number of segments\".to_string()),\n-    }\n-}\n-\n-pub(crate) fn handle_code_lens(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::CodeLensParams,\n-) -> Result<Option<Vec<CodeLens>>> {\n-    let _p = profile::span(\"handle_code_lens\");\n-\n-    let lens_config = snap.config.lens();\n-    if lens_config.none() {\n-        // early return before any db query!\n-        return Ok(Some(Vec::default()));\n-    }\n-\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let cargo_target_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n-\n-    let annotations = snap.analysis.annotations(\n-        &AnnotationConfig {\n-            binary_target: cargo_target_spec\n-                .map(|spec| {\n-                    matches!(\n-                        spec.target_kind,\n-                        TargetKind::Bin | TargetKind::Example | TargetKind::Test\n-                    )\n-                })\n-                .unwrap_or(false),\n-            annotate_runnables: lens_config.runnable(),\n-            annotate_impls: lens_config.implementations,\n-            annotate_references: lens_config.refs_adt,\n-            annotate_method_references: lens_config.method_refs,\n-            annotate_enum_variant_references: lens_config.enum_variant_refs,\n-            location: lens_config.location.into(),\n-        },\n-        file_id,\n-    )?;\n-\n-    let mut res = Vec::new();\n-    for a in annotations {\n-        to_proto::code_lens(&mut res, &snap, a)?;\n-    }\n-\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_code_lens_resolve(\n-    snap: GlobalStateSnapshot,\n-    code_lens: CodeLens,\n-) -> Result<CodeLens> {\n-    let Some(annotation) = from_proto::annotation(&snap, code_lens.clone())? else { return Ok(code_lens) };\n-    let annotation = snap.analysis.resolve_annotation(annotation)?;\n-\n-    let mut acc = Vec::new();\n-    to_proto::code_lens(&mut acc, &snap, annotation)?;\n-\n-    let res = match acc.pop() {\n-        Some(it) if acc.is_empty() => it,\n-        _ => {\n-            never!();\n-            code_lens\n-        }\n-    };\n-\n-    Ok(res)\n-}\n-\n-pub(crate) fn handle_document_highlight(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::DocumentHighlightParams,\n-) -> Result<Option<Vec<lsp_types::DocumentHighlight>>> {\n-    let _p = profile::span(\"handle_document_highlight\");\n-    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let line_index = snap.file_line_index(position.file_id)?;\n-\n-    let refs = match snap.analysis.highlight_related(snap.config.highlight_related(), position)? {\n-        None => return Ok(None),\n-        Some(refs) => refs,\n-    };\n-    let res = refs\n-        .into_iter()\n-        .map(|ide::HighlightedRange { range, category }| lsp_types::DocumentHighlight {\n-            range: to_proto::range(&line_index, range),\n-            kind: category.and_then(to_proto::document_highlight_kind),\n-        })\n-        .collect();\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_ssr(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_ext::SsrParams,\n-) -> Result<lsp_types::WorkspaceEdit> {\n-    let _p = profile::span(\"handle_ssr\");\n-    let selections = params\n-        .selections\n-        .iter()\n-        .map(|range| from_proto::file_range(&snap, params.position.text_document.clone(), *range))\n-        .collect::<Result<Vec<_>, _>>()?;\n-    let position = from_proto::file_position(&snap, params.position)?;\n-    let source_change = snap.analysis.structural_search_replace(\n-        &params.query,\n-        params.parse_only,\n-        position,\n-        selections,\n-    )??;\n-    to_proto::workspace_edit(&snap, source_change).map_err(Into::into)\n-}\n+pub(crate) mod request;\n+pub(crate) mod notification;\n \n pub(crate) fn publish_diagnostics(\n     snap: &GlobalStateSnapshot,\n@@ -1364,559 +42,3 @@ pub(crate) fn publish_diagnostics(\n         .collect();\n     Ok(diagnostics)\n }\n-\n-pub(crate) fn handle_inlay_hints(\n-    snap: GlobalStateSnapshot,\n-    params: InlayHintParams,\n-) -> Result<Option<Vec<InlayHint>>> {\n-    let _p = profile::span(\"handle_inlay_hints\");\n-    let document_uri = &params.text_document.uri;\n-    let FileRange { file_id, range } = from_proto::file_range(\n-        &snap,\n-        TextDocumentIdentifier::new(document_uri.to_owned()),\n-        params.range,\n-    )?;\n-    let line_index = snap.file_line_index(file_id)?;\n-    let inlay_hints_config = snap.config.inlay_hints();\n-    Ok(Some(\n-        snap.analysis\n-            .inlay_hints(&inlay_hints_config, file_id, Some(range))?\n-            .into_iter()\n-            .map(|it| {\n-                to_proto::inlay_hint(&snap, &line_index, inlay_hints_config.render_colons, it)\n-            })\n-            .collect::<Cancellable<Vec<_>>>()?,\n-    ))\n-}\n-\n-pub(crate) fn handle_inlay_hints_resolve(\n-    _snap: GlobalStateSnapshot,\n-    hint: InlayHint,\n-) -> Result<InlayHint> {\n-    let _p = profile::span(\"handle_inlay_hints_resolve\");\n-    Ok(hint)\n-}\n-\n-pub(crate) fn handle_call_hierarchy_prepare(\n-    snap: GlobalStateSnapshot,\n-    params: CallHierarchyPrepareParams,\n-) -> Result<Option<Vec<CallHierarchyItem>>> {\n-    let _p = profile::span(\"handle_call_hierarchy_prepare\");\n-    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-\n-    let nav_info = match snap.analysis.call_hierarchy(position)? {\n-        None => return Ok(None),\n-        Some(it) => it,\n-    };\n-\n-    let RangeInfo { range: _, info: navs } = nav_info;\n-    let res = navs\n-        .into_iter()\n-        .filter(|it| it.kind == Some(SymbolKind::Function))\n-        .map(|it| to_proto::call_hierarchy_item(&snap, it))\n-        .collect::<Cancellable<Vec<_>>>()?;\n-\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_call_hierarchy_incoming(\n-    snap: GlobalStateSnapshot,\n-    params: CallHierarchyIncomingCallsParams,\n-) -> Result<Option<Vec<CallHierarchyIncomingCall>>> {\n-    let _p = profile::span(\"handle_call_hierarchy_incoming\");\n-    let item = params.item;\n-\n-    let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange = from_proto::file_range(&snap, doc, item.selection_range)?;\n-    let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n-\n-    let call_items = match snap.analysis.incoming_calls(fpos)? {\n-        None => return Ok(None),\n-        Some(it) => it,\n-    };\n-\n-    let mut res = vec![];\n-\n-    for call_item in call_items.into_iter() {\n-        let file_id = call_item.target.file_id;\n-        let line_index = snap.file_line_index(file_id)?;\n-        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n-        res.push(CallHierarchyIncomingCall {\n-            from: item,\n-            from_ranges: call_item\n-                .ranges\n-                .into_iter()\n-                .map(|it| to_proto::range(&line_index, it))\n-                .collect(),\n-        });\n-    }\n-\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_call_hierarchy_outgoing(\n-    snap: GlobalStateSnapshot,\n-    params: CallHierarchyOutgoingCallsParams,\n-) -> Result<Option<Vec<CallHierarchyOutgoingCall>>> {\n-    let _p = profile::span(\"handle_call_hierarchy_outgoing\");\n-    let item = params.item;\n-\n-    let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange = from_proto::file_range(&snap, doc, item.selection_range)?;\n-    let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n-\n-    let call_items = match snap.analysis.outgoing_calls(fpos)? {\n-        None => return Ok(None),\n-        Some(it) => it,\n-    };\n-\n-    let mut res = vec![];\n-\n-    for call_item in call_items.into_iter() {\n-        let file_id = call_item.target.file_id;\n-        let line_index = snap.file_line_index(file_id)?;\n-        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n-        res.push(CallHierarchyOutgoingCall {\n-            to: item,\n-            from_ranges: call_item\n-                .ranges\n-                .into_iter()\n-                .map(|it| to_proto::range(&line_index, it))\n-                .collect(),\n-        });\n-    }\n-\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_semantic_tokens_full(\n-    snap: GlobalStateSnapshot,\n-    params: SemanticTokensParams,\n-) -> Result<Option<SemanticTokensResult>> {\n-    let _p = profile::span(\"handle_semantic_tokens_full\");\n-\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let text = snap.analysis.file_text(file_id)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-\n-    let mut highlight_config = snap.config.highlighting_config();\n-    // Avoid flashing a bunch of unresolved references when the proc-macro servers haven't been spawned yet.\n-    highlight_config.syntactic_name_ref_highlighting =\n-        snap.workspaces.is_empty() || !snap.proc_macros_loaded;\n-\n-    let highlights = snap.analysis.highlight(highlight_config, file_id)?;\n-    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n-\n-    // Unconditionally cache the tokens\n-    snap.semantic_tokens_cache.lock().insert(params.text_document.uri, semantic_tokens.clone());\n-\n-    Ok(Some(semantic_tokens.into()))\n-}\n-\n-pub(crate) fn handle_semantic_tokens_full_delta(\n-    snap: GlobalStateSnapshot,\n-    params: SemanticTokensDeltaParams,\n-) -> Result<Option<SemanticTokensFullDeltaResult>> {\n-    let _p = profile::span(\"handle_semantic_tokens_full_delta\");\n-\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let text = snap.analysis.file_text(file_id)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-\n-    let mut highlight_config = snap.config.highlighting_config();\n-    // Avoid flashing a bunch of unresolved references when the proc-macro servers haven't been spawned yet.\n-    highlight_config.syntactic_name_ref_highlighting =\n-        snap.workspaces.is_empty() || !snap.proc_macros_loaded;\n-\n-    let highlights = snap.analysis.highlight(highlight_config, file_id)?;\n-    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n-\n-    let mut cache = snap.semantic_tokens_cache.lock();\n-    let cached_tokens = cache.entry(params.text_document.uri).or_default();\n-\n-    if let Some(prev_id) = &cached_tokens.result_id {\n-        if *prev_id == params.previous_result_id {\n-            let delta = to_proto::semantic_token_delta(cached_tokens, &semantic_tokens);\n-            *cached_tokens = semantic_tokens;\n-            return Ok(Some(delta.into()));\n-        }\n-    }\n-\n-    *cached_tokens = semantic_tokens.clone();\n-\n-    Ok(Some(semantic_tokens.into()))\n-}\n-\n-pub(crate) fn handle_semantic_tokens_range(\n-    snap: GlobalStateSnapshot,\n-    params: SemanticTokensRangeParams,\n-) -> Result<Option<SemanticTokensRangeResult>> {\n-    let _p = profile::span(\"handle_semantic_tokens_range\");\n-\n-    let frange = from_proto::file_range(&snap, params.text_document, params.range)?;\n-    let text = snap.analysis.file_text(frange.file_id)?;\n-    let line_index = snap.file_line_index(frange.file_id)?;\n-\n-    let mut highlight_config = snap.config.highlighting_config();\n-    // Avoid flashing a bunch of unresolved references when the proc-macro servers haven't been spawned yet.\n-    highlight_config.syntactic_name_ref_highlighting =\n-        snap.workspaces.is_empty() || !snap.proc_macros_loaded;\n-\n-    let highlights = snap.analysis.highlight_range(highlight_config, frange)?;\n-    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n-    Ok(Some(semantic_tokens.into()))\n-}\n-\n-pub(crate) fn handle_open_docs(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_types::TextDocumentPositionParams,\n-) -> Result<Option<lsp_types::Url>> {\n-    let _p = profile::span(\"handle_open_docs\");\n-    let position = from_proto::file_position(&snap, params)?;\n-\n-    let remote = snap.analysis.external_docs(position)?;\n-\n-    Ok(remote.and_then(|remote| Url::parse(&remote).ok()))\n-}\n-\n-pub(crate) fn handle_open_cargo_toml(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_ext::OpenCargoTomlParams,\n-) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n-    let _p = profile::span(\"handle_open_cargo_toml\");\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-\n-    let cargo_spec = match CargoTargetSpec::for_file(&snap, file_id)? {\n-        Some(it) => it,\n-        None => return Ok(None),\n-    };\n-\n-    let cargo_toml_url = to_proto::url_from_abs_path(&cargo_spec.cargo_toml);\n-    let res: lsp_types::GotoDefinitionResponse =\n-        Location::new(cargo_toml_url, Range::default()).into();\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn handle_move_item(\n-    snap: GlobalStateSnapshot,\n-    params: lsp_ext::MoveItemParams,\n-) -> Result<Vec<lsp_ext::SnippetTextEdit>> {\n-    let _p = profile::span(\"handle_move_item\");\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let range = from_proto::file_range(&snap, params.text_document, params.range)?;\n-\n-    let direction = match params.direction {\n-        lsp_ext::MoveItemDirection::Up => ide::Direction::Up,\n-        lsp_ext::MoveItemDirection::Down => ide::Direction::Down,\n-    };\n-\n-    match snap.analysis.move_item(range, direction)? {\n-        Some(text_edit) => {\n-            let line_index = snap.file_line_index(file_id)?;\n-            Ok(to_proto::snippet_text_edit_vec(&line_index, true, text_edit))\n-        }\n-        None => Ok(vec![]),\n-    }\n-}\n-\n-fn to_command_link(command: lsp_types::Command, tooltip: String) -> lsp_ext::CommandLink {\n-    lsp_ext::CommandLink { tooltip: Some(tooltip), command }\n-}\n-\n-fn show_impl_command_link(\n-    snap: &GlobalStateSnapshot,\n-    position: &FilePosition,\n-) -> Option<lsp_ext::CommandLinkGroup> {\n-    if snap.config.hover_actions().implementations && snap.config.client_commands().show_reference {\n-        if let Some(nav_data) = snap.analysis.goto_implementation(*position).unwrap_or(None) {\n-            let uri = to_proto::url(snap, position.file_id);\n-            let line_index = snap.file_line_index(position.file_id).ok()?;\n-            let position = to_proto::position(&line_index, position.offset);\n-            let locations: Vec<_> = nav_data\n-                .info\n-                .into_iter()\n-                .filter_map(|nav| to_proto::location_from_nav(snap, nav).ok())\n-                .collect();\n-            let title = to_proto::implementation_title(locations.len());\n-            let command = to_proto::command::show_references(title, &uri, position, locations);\n-\n-            return Some(lsp_ext::CommandLinkGroup {\n-                commands: vec![to_command_link(command, \"Go to implementations\".into())],\n-                ..Default::default()\n-            });\n-        }\n-    }\n-    None\n-}\n-\n-fn show_ref_command_link(\n-    snap: &GlobalStateSnapshot,\n-    position: &FilePosition,\n-) -> Option<lsp_ext::CommandLinkGroup> {\n-    if snap.config.hover_actions().references && snap.config.client_commands().show_reference {\n-        if let Some(ref_search_res) = snap.analysis.find_all_refs(*position, None).unwrap_or(None) {\n-            let uri = to_proto::url(snap, position.file_id);\n-            let line_index = snap.file_line_index(position.file_id).ok()?;\n-            let position = to_proto::position(&line_index, position.offset);\n-            let locations: Vec<_> = ref_search_res\n-                .into_iter()\n-                .flat_map(|res| res.references)\n-                .flat_map(|(file_id, ranges)| {\n-                    ranges.into_iter().filter_map(move |(range, _)| {\n-                        to_proto::location(snap, FileRange { file_id, range }).ok()\n-                    })\n-                })\n-                .collect();\n-            let title = to_proto::reference_title(locations.len());\n-            let command = to_proto::command::show_references(title, &uri, position, locations);\n-\n-            return Some(lsp_ext::CommandLinkGroup {\n-                commands: vec![to_command_link(command, \"Go to references\".into())],\n-                ..Default::default()\n-            });\n-        }\n-    }\n-    None\n-}\n-\n-fn runnable_action_links(\n-    snap: &GlobalStateSnapshot,\n-    runnable: Runnable,\n-) -> Option<lsp_ext::CommandLinkGroup> {\n-    let hover_actions_config = snap.config.hover_actions();\n-    if !hover_actions_config.runnable() {\n-        return None;\n-    }\n-\n-    let cargo_spec = CargoTargetSpec::for_file(snap, runnable.nav.file_id).ok()?;\n-    if should_skip_target(&runnable, cargo_spec.as_ref()) {\n-        return None;\n-    }\n-\n-    let client_commands_config = snap.config.client_commands();\n-    if !(client_commands_config.run_single || client_commands_config.debug_single) {\n-        return None;\n-    }\n-\n-    let title = runnable.title();\n-    let r = to_proto::runnable(snap, runnable).ok()?;\n-\n-    let mut group = lsp_ext::CommandLinkGroup::default();\n-\n-    if hover_actions_config.run && client_commands_config.run_single {\n-        let run_command = to_proto::command::run_single(&r, &title);\n-        group.commands.push(to_command_link(run_command, r.label.clone()));\n-    }\n-\n-    if hover_actions_config.debug && client_commands_config.debug_single {\n-        let dbg_command = to_proto::command::debug_single(&r);\n-        group.commands.push(to_command_link(dbg_command, r.label));\n-    }\n-\n-    Some(group)\n-}\n-\n-fn goto_type_action_links(\n-    snap: &GlobalStateSnapshot,\n-    nav_targets: &[HoverGotoTypeData],\n-) -> Option<lsp_ext::CommandLinkGroup> {\n-    if !snap.config.hover_actions().goto_type_def\n-        || nav_targets.is_empty()\n-        || !snap.config.client_commands().goto_location\n-    {\n-        return None;\n-    }\n-\n-    Some(lsp_ext::CommandLinkGroup {\n-        title: Some(\"Go to \".into()),\n-        commands: nav_targets\n-            .iter()\n-            .filter_map(|it| {\n-                to_proto::command::goto_location(snap, &it.nav)\n-                    .map(|cmd| to_command_link(cmd, it.mod_path.clone()))\n-            })\n-            .collect(),\n-    })\n-}\n-\n-fn prepare_hover_actions(\n-    snap: &GlobalStateSnapshot,\n-    actions: &[HoverAction],\n-) -> Vec<lsp_ext::CommandLinkGroup> {\n-    actions\n-        .iter()\n-        .filter_map(|it| match it {\n-            HoverAction::Implementation(position) => show_impl_command_link(snap, position),\n-            HoverAction::Reference(position) => show_ref_command_link(snap, position),\n-            HoverAction::Runnable(r) => runnable_action_links(snap, r.clone()),\n-            HoverAction::GoToType(targets) => goto_type_action_links(snap, targets),\n-        })\n-        .collect()\n-}\n-\n-fn should_skip_target(runnable: &Runnable, cargo_spec: Option<&CargoTargetSpec>) -> bool {\n-    match runnable.kind {\n-        RunnableKind::Bin => {\n-            // Do not suggest binary run on other target than binary\n-            match &cargo_spec {\n-                Some(spec) => !matches!(\n-                    spec.target_kind,\n-                    TargetKind::Bin | TargetKind::Example | TargetKind::Test\n-                ),\n-                None => true,\n-            }\n-        }\n-        _ => false,\n-    }\n-}\n-\n-fn run_rustfmt(\n-    snap: &GlobalStateSnapshot,\n-    text_document: TextDocumentIdentifier,\n-    range: Option<lsp_types::Range>,\n-) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n-    let file_id = from_proto::file_id(snap, &text_document.uri)?;\n-    let file = snap.analysis.file_text(file_id)?;\n-\n-    // Determine the edition of the crate the file belongs to (if there's multiple, we pick the\n-    // highest edition).\n-    let editions = snap\n-        .analysis\n-        .relevant_crates_for(file_id)?\n-        .into_iter()\n-        .map(|crate_id| snap.analysis.crate_edition(crate_id))\n-        .collect::<Result<Vec<_>, _>>()?;\n-    let edition = editions.iter().copied().max();\n-\n-    let line_index = snap.file_line_index(file_id)?;\n-\n-    let mut command = match snap.config.rustfmt() {\n-        RustfmtConfig::Rustfmt { extra_args, enable_range_formatting } => {\n-            let mut cmd = process::Command::new(toolchain::rustfmt());\n-            cmd.envs(snap.config.extra_env());\n-            cmd.args(extra_args);\n-            // try to chdir to the file so we can respect `rustfmt.toml`\n-            // FIXME: use `rustfmt --config-path` once\n-            // https://github.com/rust-lang/rustfmt/issues/4660 gets fixed\n-            match text_document.uri.to_file_path() {\n-                Ok(mut path) => {\n-                    // pop off file name\n-                    if path.pop() && path.is_dir() {\n-                        cmd.current_dir(path);\n-                    }\n-                }\n-                Err(_) => {\n-                    tracing::error!(\n-                        \"Unable to get file path for {}, rustfmt.toml might be ignored\",\n-                        text_document.uri\n-                    );\n-                }\n-            }\n-            if let Some(edition) = edition {\n-                cmd.arg(\"--edition\");\n-                cmd.arg(edition.to_string());\n-            }\n-\n-            if let Some(range) = range {\n-                if !enable_range_formatting {\n-                    return Err(LspError::new(\n-                        ErrorCode::InvalidRequest as i32,\n-                        String::from(\n-                            \"rustfmt range formatting is unstable. \\\n-                            Opt-in by using a nightly build of rustfmt and setting \\\n-                            `rustfmt.rangeFormatting.enable` to true in your LSP configuration\",\n-                        ),\n-                    )\n-                    .into());\n-                }\n-\n-                let frange = from_proto::file_range(snap, text_document, range)?;\n-                let start_line = line_index.index.line_col(frange.range.start()).line;\n-                let end_line = line_index.index.line_col(frange.range.end()).line;\n-\n-                cmd.arg(\"--unstable-features\");\n-                cmd.arg(\"--file-lines\");\n-                cmd.arg(\n-                    json!([{\n-                        \"file\": \"stdin\",\n-                        \"range\": [start_line, end_line]\n-                    }])\n-                    .to_string(),\n-                );\n-            }\n-\n-            cmd\n-        }\n-        RustfmtConfig::CustomCommand { command, args } => {\n-            let mut cmd = process::Command::new(command);\n-            cmd.envs(snap.config.extra_env());\n-            cmd.args(args);\n-            cmd\n-        }\n-    };\n-\n-    let mut rustfmt = command\n-        .stdin(Stdio::piped())\n-        .stdout(Stdio::piped())\n-        .stderr(Stdio::piped())\n-        .spawn()\n-        .context(format!(\"Failed to spawn {command:?}\"))?;\n-\n-    rustfmt.stdin.as_mut().unwrap().write_all(file.as_bytes())?;\n-\n-    let output = rustfmt.wait_with_output()?;\n-    let captured_stdout = String::from_utf8(output.stdout)?;\n-    let captured_stderr = String::from_utf8(output.stderr).unwrap_or_default();\n-\n-    if !output.status.success() {\n-        let rustfmt_not_installed =\n-            captured_stderr.contains(\"not installed\") || captured_stderr.contains(\"not available\");\n-\n-        return match output.status.code() {\n-            Some(1) if !rustfmt_not_installed => {\n-                // While `rustfmt` doesn't have a specific exit code for parse errors this is the\n-                // likely cause exiting with 1. Most Language Servers swallow parse errors on\n-                // formatting because otherwise an error is surfaced to the user on top of the\n-                // syntax error diagnostics they're already receiving. This is especially jarring\n-                // if they have format on save enabled.\n-                tracing::warn!(\n-                    ?command,\n-                    %captured_stderr,\n-                    \"rustfmt exited with status 1\"\n-                );\n-                Ok(None)\n-            }\n-            _ => {\n-                // Something else happened - e.g. `rustfmt` is missing or caught a signal\n-                Err(LspError::new(\n-                    -32900,\n-                    format!(\n-                        r#\"rustfmt exited with:\n-                           Status: {}\n-                           stdout: {captured_stdout}\n-                           stderr: {captured_stderr}\"#,\n-                        output.status,\n-                    ),\n-                )\n-                .into())\n-            }\n-        };\n-    }\n-\n-    let (new_text, new_line_endings) = LineEndings::normalize(captured_stdout);\n-\n-    if line_index.endings != new_line_endings {\n-        // If line endings are different, send the entire file.\n-        // Diffing would not work here, as the line endings might be the only\n-        // difference.\n-        Ok(Some(to_proto::text_edit_vec(\n-            &line_index,\n-            TextEdit::replace(TextRange::up_to(TextSize::of(&*file)), new_text),\n-        )))\n-    } else if *file == new_text {\n-        // The document is already formatted correctly -- no edits needed.\n-        Ok(None)\n-    } else {\n-        Ok(Some(to_proto::text_edit_vec(&line_index, diff(&file, &new_text))))\n-    }\n-}"}, {"sha": "a734f4830109c77c4ef0f469438e2a8f446a9975", "filename": "crates/rust-analyzer/src/handlers/notification.rs", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs?ref=98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc", "patch": "@@ -0,0 +1,339 @@\n+//! This module is responsible for implementing handlers for Language Server\n+//! Protocol. This module specifically handles notifications.\n+\n+use std::{ops::Deref, sync::Arc};\n+\n+use itertools::Itertools;\n+use lsp_types::{\n+    CancelParams, DidChangeConfigurationParams, DidChangeTextDocumentParams,\n+    DidChangeWatchedFilesParams, DidChangeWorkspaceFoldersParams, DidCloseTextDocumentParams,\n+    DidOpenTextDocumentParams, DidSaveTextDocumentParams, WorkDoneProgressCancelParams,\n+};\n+use vfs::{AbsPathBuf, ChangeKind, VfsPath};\n+\n+use crate::{\n+    config::Config, from_proto, global_state::GlobalState, lsp_ext::RunFlycheckParams,\n+    lsp_utils::apply_document_changes, mem_docs::DocumentData, reload, Result,\n+};\n+\n+pub(crate) fn handle_cancel(state: &mut GlobalState, params: CancelParams) -> Result<()> {\n+    let id: lsp_server::RequestId = match params.id {\n+        lsp_types::NumberOrString::Number(id) => id.into(),\n+        lsp_types::NumberOrString::String(id) => id.into(),\n+    };\n+    state.cancel(id);\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_work_done_progress_cancel(\n+    state: &mut GlobalState,\n+    params: WorkDoneProgressCancelParams,\n+) -> Result<()> {\n+    if let lsp_types::NumberOrString::String(s) = &params.token {\n+        if let Some(id) = s.strip_prefix(\"rust-analyzer/flycheck/\") {\n+            if let Ok(id) = u32::from_str_radix(id, 10) {\n+                if let Some(flycheck) = state.flycheck.get(id as usize) {\n+                    flycheck.cancel();\n+                }\n+            }\n+        }\n+    }\n+\n+    // Just ignore this. It is OK to continue sending progress\n+    // notifications for this token, as the client can't know when\n+    // we accepted notification.\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_did_open_text_document(\n+    state: &mut GlobalState,\n+    params: DidOpenTextDocumentParams,\n+) -> Result<()> {\n+    let _p = profile::span(\"handle_did_open_text_document\");\n+\n+    if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+        let already_exists = state\n+            .mem_docs\n+            .insert(path.clone(), DocumentData::new(params.text_document.version))\n+            .is_err();\n+        if already_exists {\n+            tracing::error!(\"duplicate DidOpenTextDocument: {}\", path);\n+        }\n+        state.vfs.write().0.set_file_contents(path, Some(params.text_document.text.into_bytes()));\n+    }\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_did_change_text_document(\n+    state: &mut GlobalState,\n+    params: DidChangeTextDocumentParams,\n+) -> Result<()> {\n+    let _p = profile::span(\"handle_did_change_text_document\");\n+\n+    if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+        match state.mem_docs.get_mut(&path) {\n+            Some(doc) => {\n+                // The version passed in DidChangeTextDocument is the version after all edits are applied\n+                // so we should apply it before the vfs is notified.\n+                doc.version = params.text_document.version;\n+            }\n+            None => {\n+                tracing::error!(\"unexpected DidChangeTextDocument: {}\", path);\n+                return Ok(());\n+            }\n+        };\n+\n+        let vfs = &mut state.vfs.write().0;\n+        let file_id = vfs.file_id(&path).unwrap();\n+        let text = apply_document_changes(\n+            state.config.position_encoding(),\n+            || std::str::from_utf8(vfs.file_contents(file_id)).unwrap().into(),\n+            params.content_changes,\n+        );\n+\n+        vfs.set_file_contents(path, Some(text.into_bytes()));\n+    }\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_did_close_text_document(\n+    state: &mut GlobalState,\n+    params: DidCloseTextDocumentParams,\n+) -> Result<()> {\n+    let _p = profile::span(\"handle_did_close_text_document\");\n+\n+    if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+        if state.mem_docs.remove(&path).is_err() {\n+            tracing::error!(\"orphan DidCloseTextDocument: {}\", path);\n+        }\n+\n+        state.semantic_tokens_cache.lock().remove(&params.text_document.uri);\n+\n+        if let Some(path) = path.as_path() {\n+            state.loader.handle.invalidate(path.to_path_buf());\n+        }\n+    }\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_did_save_text_document(\n+    state: &mut GlobalState,\n+    params: DidSaveTextDocumentParams,\n+) -> Result<()> {\n+    if let Ok(vfs_path) = from_proto::vfs_path(&params.text_document.uri) {\n+        // Re-fetch workspaces if a workspace related file has changed\n+        if let Some(abs_path) = vfs_path.as_path() {\n+            if reload::should_refresh_for_change(abs_path, ChangeKind::Modify) {\n+                state\n+                    .fetch_workspaces_queue\n+                    .request_op(format!(\"DidSaveTextDocument {}\", abs_path.display()), ());\n+            }\n+        }\n+\n+        if !state.config.check_on_save() || run_flycheck(state, vfs_path) {\n+            return Ok(());\n+        }\n+    } else if state.config.check_on_save() {\n+        // No specific flycheck was triggered, so let's trigger all of them.\n+        for flycheck in state.flycheck.iter() {\n+            flycheck.restart();\n+        }\n+    }\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_did_change_configuration(\n+    state: &mut GlobalState,\n+    _params: DidChangeConfigurationParams,\n+) -> Result<()> {\n+    // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n+    // this notification's parameters should be ignored and the actual config queried separately.\n+    state.send_request::<lsp_types::request::WorkspaceConfiguration>(\n+        lsp_types::ConfigurationParams {\n+            items: vec![lsp_types::ConfigurationItem {\n+                scope_uri: None,\n+                section: Some(\"rust-analyzer\".to_string()),\n+            }],\n+        },\n+        |this, resp| {\n+            tracing::debug!(\"config update response: '{:?}\", resp);\n+            let lsp_server::Response { error, result, .. } = resp;\n+\n+            match (error, result) {\n+                (Some(err), _) => {\n+                    tracing::error!(\"failed to fetch the server settings: {:?}\", err)\n+                }\n+                (None, Some(mut configs)) => {\n+                    if let Some(json) = configs.get_mut(0) {\n+                        // Note that json can be null according to the spec if the client can't\n+                        // provide a configuration. This is handled in Config::update below.\n+                        let mut config = Config::clone(&*this.config);\n+                        if let Err(error) = config.update(json.take()) {\n+                            this.show_message(\n+                                lsp_types::MessageType::WARNING,\n+                                error.to_string(),\n+                                false,\n+                            );\n+                        }\n+                        this.update_configuration(config);\n+                    }\n+                }\n+                (None, None) => {\n+                    tracing::error!(\"received empty server settings response from the client\")\n+                }\n+            }\n+        },\n+    );\n+\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_did_change_workspace_folders(\n+    state: &mut GlobalState,\n+    params: DidChangeWorkspaceFoldersParams,\n+) -> Result<()> {\n+    let config = Arc::make_mut(&mut state.config);\n+\n+    for workspace in params.event.removed {\n+        let Ok(path) = workspace.uri.to_file_path() else { continue };\n+        let Ok(path) = AbsPathBuf::try_from(path) else { continue };\n+        config.remove_workspace(&path);\n+    }\n+\n+    let added = params\n+        .event\n+        .added\n+        .into_iter()\n+        .filter_map(|it| it.uri.to_file_path().ok())\n+        .filter_map(|it| AbsPathBuf::try_from(it).ok());\n+    config.add_workspaces(added);\n+\n+    if !config.has_linked_projects() && config.detached_files().is_empty() {\n+        config.rediscover_workspaces();\n+        state.fetch_workspaces_queue.request_op(\"client workspaces changed\".to_string(), ())\n+    }\n+\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_did_change_watched_files(\n+    state: &mut GlobalState,\n+    params: DidChangeWatchedFilesParams,\n+) -> Result<()> {\n+    for change in params.changes {\n+        if let Ok(path) = from_proto::abs_path(&change.uri) {\n+            state.loader.handle.invalidate(path);\n+        }\n+    }\n+    Ok(())\n+}\n+\n+fn run_flycheck(state: &mut GlobalState, vfs_path: VfsPath) -> bool {\n+    let _p = profile::span(\"run_flycheck\");\n+\n+    let file_id = state.vfs.read().0.file_id(&vfs_path);\n+    if let Some(file_id) = file_id {\n+        let world = state.snapshot();\n+        let mut updated = false;\n+        let task = move || -> std::result::Result<(), ide::Cancelled> {\n+            // Trigger flychecks for all workspaces that depend on the saved file\n+            // Crates containing or depending on the saved file\n+            let crate_ids: Vec<_> = world\n+                .analysis\n+                .crates_for(file_id)?\n+                .into_iter()\n+                .flat_map(|id| world.analysis.transitive_rev_deps(id))\n+                .flatten()\n+                .sorted()\n+                .unique()\n+                .collect();\n+\n+            let crate_root_paths: Vec<_> = crate_ids\n+                .iter()\n+                .filter_map(|&crate_id| {\n+                    world\n+                        .analysis\n+                        .crate_root(crate_id)\n+                        .map(|file_id| {\n+                            world.file_id_to_file_path(file_id).as_path().map(ToOwned::to_owned)\n+                        })\n+                        .transpose()\n+                })\n+                .collect::<ide::Cancellable<_>>()?;\n+            let crate_root_paths: Vec<_> = crate_root_paths.iter().map(Deref::deref).collect();\n+\n+            // Find all workspaces that have at least one target containing the saved file\n+            let workspace_ids = world.workspaces.iter().enumerate().filter(|(_, ws)| match ws {\n+                project_model::ProjectWorkspace::Cargo { cargo, .. } => {\n+                    cargo.packages().any(|pkg| {\n+                        cargo[pkg]\n+                            .targets\n+                            .iter()\n+                            .any(|&it| crate_root_paths.contains(&cargo[it].root.as_path()))\n+                    })\n+                }\n+                project_model::ProjectWorkspace::Json { project, .. } => {\n+                    project.crates().any(|(c, _)| crate_ids.iter().any(|&crate_id| crate_id == c))\n+                }\n+                project_model::ProjectWorkspace::DetachedFiles { .. } => false,\n+            });\n+\n+            // Find and trigger corresponding flychecks\n+            for flycheck in world.flycheck.iter() {\n+                for (id, _) in workspace_ids.clone() {\n+                    if id == flycheck.id() {\n+                        updated = true;\n+                        flycheck.restart();\n+                        continue;\n+                    }\n+                }\n+            }\n+            // No specific flycheck was triggered, so let's trigger all of them.\n+            if !updated {\n+                for flycheck in world.flycheck.iter() {\n+                    flycheck.restart();\n+                }\n+            }\n+            Ok(())\n+        };\n+        state.task_pool.handle.spawn_with_sender(move |_| {\n+            if let Err(e) = std::panic::catch_unwind(task) {\n+                tracing::error!(\"flycheck task panicked: {e:?}\")\n+            }\n+        });\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+pub(crate) fn handle_cancel_flycheck(state: &mut GlobalState, _: ()) -> Result<()> {\n+    let _p = profile::span(\"handle_stop_flycheck\");\n+    state.flycheck.iter().for_each(|flycheck| flycheck.cancel());\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_clear_flycheck(state: &mut GlobalState, _: ()) -> Result<()> {\n+    let _p = profile::span(\"handle_clear_flycheck\");\n+    state.diagnostics.clear_check_all();\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_run_flycheck(\n+    state: &mut GlobalState,\n+    params: RunFlycheckParams,\n+) -> Result<()> {\n+    let _p = profile::span(\"handle_run_flycheck\");\n+    if let Some(text_document) = params.text_document {\n+        if let Ok(vfs_path) = from_proto::vfs_path(&text_document.uri) {\n+            if run_flycheck(state, vfs_path) {\n+                return Ok(());\n+            }\n+        }\n+    }\n+    // No specific flycheck was triggered, so let's trigger all of them.\n+    for flycheck in state.flycheck.iter() {\n+        flycheck.restart();\n+    }\n+    Ok(())\n+}"}, {"sha": "03e08d9cdfc0b43383fae2cf3032a61f33c5c10a", "filename": "crates/rust-analyzer/src/handlers/request.rs", "status": "added", "additions": 1883, "deletions": 0, "changes": 1883, "blob_url": "https://github.com/rust-lang/rust/blob/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Frequest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Frequest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Frequest.rs?ref=98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc", "patch": "@@ -0,0 +1,1883 @@\n+//! This module is responsible for implementing handlers for Language Server\n+//! Protocol. This module specifically handles requests.\n+\n+use std::{\n+    io::Write as _,\n+    process::{self, Stdio},\n+    sync::Arc,\n+};\n+\n+use anyhow::Context;\n+use ide::{\n+    AnnotationConfig, AssistKind, AssistResolveStrategy, Cancellable, FilePosition, FileRange,\n+    HoverAction, HoverGotoTypeData, Query, RangeInfo, ReferenceCategory, Runnable, RunnableKind,\n+    SingleResolve, SourceChange, TextEdit,\n+};\n+use ide_db::SymbolKind;\n+use lsp_server::ErrorCode;\n+use lsp_types::{\n+    CallHierarchyIncomingCall, CallHierarchyIncomingCallsParams, CallHierarchyItem,\n+    CallHierarchyOutgoingCall, CallHierarchyOutgoingCallsParams, CallHierarchyPrepareParams,\n+    CodeLens, CompletionItem, DocumentFormattingParams, FoldingRange, FoldingRangeParams,\n+    HoverContents, InlayHint, InlayHintParams, Location, LocationLink, Position,\n+    PrepareRenameResponse, Range, RenameParams, SemanticTokensDeltaParams,\n+    SemanticTokensFullDeltaResult, SemanticTokensParams, SemanticTokensRangeParams,\n+    SemanticTokensRangeResult, SemanticTokensResult, SymbolInformation, SymbolTag,\n+    TextDocumentIdentifier, Url, WorkspaceEdit,\n+};\n+use project_model::{ManifestPath, ProjectWorkspace, TargetKind};\n+use serde_json::json;\n+use stdx::{format_to, never};\n+use syntax::{algo, ast, AstNode, TextRange, TextSize};\n+use vfs::{AbsPath, AbsPathBuf};\n+\n+use crate::{\n+    cargo_target_spec::CargoTargetSpec,\n+    config::{RustfmtConfig, WorkspaceSymbolConfig},\n+    diff::diff,\n+    from_proto,\n+    global_state::{GlobalState, GlobalStateSnapshot},\n+    line_index::LineEndings,\n+    lsp_ext::{self, PositionOrRange, ViewCrateGraphParams, WorkspaceSymbolParams},\n+    lsp_utils::{all_edits_are_disjoint, invalid_params_error},\n+    to_proto, LspError, Result,\n+};\n+\n+pub(crate) fn handle_workspace_reload(state: &mut GlobalState, _: ()) -> Result<()> {\n+    state.proc_macro_clients = Arc::new([]);\n+    state.proc_macro_changed = false;\n+\n+    state.fetch_workspaces_queue.request_op(\"reload workspace request\".to_string(), ());\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_proc_macros_rebuild(state: &mut GlobalState, _: ()) -> Result<()> {\n+    state.proc_macro_clients = Arc::new([]);\n+    state.proc_macro_changed = false;\n+\n+    state.fetch_build_data_queue.request_op(\"rebuild proc macros request\".to_string(), ());\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_analyzer_status(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::AnalyzerStatusParams,\n+) -> Result<String> {\n+    let _p = profile::span(\"handle_analyzer_status\");\n+\n+    let mut buf = String::new();\n+\n+    let mut file_id = None;\n+    if let Some(tdi) = params.text_document {\n+        match from_proto::file_id(&snap, &tdi.uri) {\n+            Ok(it) => file_id = Some(it),\n+            Err(_) => format_to!(buf, \"file {} not found in vfs\", tdi.uri),\n+        }\n+    }\n+\n+    if snap.workspaces.is_empty() {\n+        buf.push_str(\"No workspaces\\n\")\n+    } else {\n+        buf.push_str(\"Workspaces:\\n\");\n+        format_to!(\n+            buf,\n+            \"Loaded {:?} packages across {} workspace{}.\\n\",\n+            snap.workspaces.iter().map(|w| w.n_packages()).sum::<usize>(),\n+            snap.workspaces.len(),\n+            if snap.workspaces.len() == 1 { \"\" } else { \"s\" }\n+        );\n+\n+        format_to!(\n+            buf,\n+            \"Workspace root folders: {:?}\",\n+            snap.workspaces\n+                .iter()\n+                .flat_map(|ws| ws.workspace_definition_path())\n+                .collect::<Vec<&AbsPath>>()\n+        );\n+    }\n+    format_to!(buf, \"\\nVfs memory usage: {}\\n\", snap.vfs_memory_usage());\n+    buf.push_str(\"\\nAnalysis:\\n\");\n+    buf.push_str(\n+        &snap\n+            .analysis\n+            .status(file_id)\n+            .unwrap_or_else(|_| \"Analysis retrieval was cancelled\".to_owned()),\n+    );\n+    Ok(buf)\n+}\n+\n+pub(crate) fn handle_memory_usage(state: &mut GlobalState, _: ()) -> Result<String> {\n+    let _p = profile::span(\"handle_memory_usage\");\n+    let mut mem = state.analysis_host.per_query_memory_usage();\n+    mem.push((\"Remaining\".into(), profile::memory_usage().allocated));\n+\n+    let mut out = String::new();\n+    for (name, bytes) in mem {\n+        format_to!(out, \"{:>8} {}\\n\", bytes, name);\n+    }\n+    Ok(out)\n+}\n+\n+pub(crate) fn handle_shuffle_crate_graph(state: &mut GlobalState, _: ()) -> Result<()> {\n+    state.analysis_host.shuffle_crate_graph();\n+    Ok(())\n+}\n+\n+pub(crate) fn handle_syntax_tree(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::SyntaxTreeParams,\n+) -> Result<String> {\n+    let _p = profile::span(\"handle_syntax_tree\");\n+    let id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.file_line_index(id)?;\n+    let text_range = params.range.and_then(|r| from_proto::text_range(&line_index, r).ok());\n+    let res = snap.analysis.syntax_tree(id, text_range)?;\n+    Ok(res)\n+}\n+\n+pub(crate) fn handle_view_hir(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<String> {\n+    let _p = profile::span(\"handle_view_hir\");\n+    let position = from_proto::file_position(&snap, params)?;\n+    let res = snap.analysis.view_hir(position)?;\n+    Ok(res)\n+}\n+\n+pub(crate) fn handle_view_mir(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<String> {\n+    let _p = profile::span(\"handle_view_mir\");\n+    let position = from_proto::file_position(&snap, params)?;\n+    let res = snap.analysis.view_mir(position)?;\n+    Ok(res)\n+}\n+\n+pub(crate) fn handle_interpret_function(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<String> {\n+    let _p = profile::span(\"handle_interpret_function\");\n+    let position = from_proto::file_position(&snap, params)?;\n+    let res = snap.analysis.interpret_function(position)?;\n+    Ok(res)\n+}\n+\n+pub(crate) fn handle_view_file_text(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentIdentifier,\n+) -> Result<String> {\n+    let file_id = from_proto::file_id(&snap, &params.uri)?;\n+    Ok(snap.analysis.file_text(file_id)?.to_string())\n+}\n+\n+pub(crate) fn handle_view_item_tree(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::ViewItemTreeParams,\n+) -> Result<String> {\n+    let _p = profile::span(\"handle_view_item_tree\");\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let res = snap.analysis.view_item_tree(file_id)?;\n+    Ok(res)\n+}\n+\n+pub(crate) fn handle_view_crate_graph(\n+    snap: GlobalStateSnapshot,\n+    params: ViewCrateGraphParams,\n+) -> Result<String> {\n+    let _p = profile::span(\"handle_view_crate_graph\");\n+    let dot = snap.analysis.view_crate_graph(params.full)??;\n+    Ok(dot)\n+}\n+\n+pub(crate) fn handle_expand_macro(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::ExpandMacroParams,\n+) -> Result<Option<lsp_ext::ExpandedMacro>> {\n+    let _p = profile::span(\"handle_expand_macro\");\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.file_line_index(file_id)?;\n+    let offset = from_proto::offset(&line_index, params.position)?;\n+\n+    let res = snap.analysis.expand_macro(FilePosition { file_id, offset })?;\n+    Ok(res.map(|it| lsp_ext::ExpandedMacro { name: it.name, expansion: it.expansion }))\n+}\n+\n+pub(crate) fn handle_selection_range(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::SelectionRangeParams,\n+) -> Result<Option<Vec<lsp_types::SelectionRange>>> {\n+    let _p = profile::span(\"handle_selection_range\");\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.file_line_index(file_id)?;\n+    let res: Result<Vec<lsp_types::SelectionRange>> = params\n+        .positions\n+        .into_iter()\n+        .map(|position| {\n+            let offset = from_proto::offset(&line_index, position)?;\n+            let mut ranges = Vec::new();\n+            {\n+                let mut range = TextRange::new(offset, offset);\n+                loop {\n+                    ranges.push(range);\n+                    let frange = FileRange { file_id, range };\n+                    let next = snap.analysis.extend_selection(frange)?;\n+                    if next == range {\n+                        break;\n+                    } else {\n+                        range = next\n+                    }\n+                }\n+            }\n+            let mut range = lsp_types::SelectionRange {\n+                range: to_proto::range(&line_index, *ranges.last().unwrap()),\n+                parent: None,\n+            };\n+            for &r in ranges.iter().rev().skip(1) {\n+                range = lsp_types::SelectionRange {\n+                    range: to_proto::range(&line_index, r),\n+                    parent: Some(Box::new(range)),\n+                }\n+            }\n+            Ok(range)\n+        })\n+        .collect();\n+\n+    Ok(Some(res?))\n+}\n+\n+pub(crate) fn handle_matching_brace(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::MatchingBraceParams,\n+) -> Result<Vec<Position>> {\n+    let _p = profile::span(\"handle_matching_brace\");\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.file_line_index(file_id)?;\n+    params\n+        .positions\n+        .into_iter()\n+        .map(|position| {\n+            let offset = from_proto::offset(&line_index, position);\n+            offset.map(|offset| {\n+                let offset = match snap.analysis.matching_brace(FilePosition { file_id, offset }) {\n+                    Ok(Some(matching_brace_offset)) => matching_brace_offset,\n+                    Err(_) | Ok(None) => offset,\n+                };\n+                to_proto::position(&line_index, offset)\n+            })\n+        })\n+        .collect()\n+}\n+\n+pub(crate) fn handle_join_lines(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::JoinLinesParams,\n+) -> Result<Vec<lsp_types::TextEdit>> {\n+    let _p = profile::span(\"handle_join_lines\");\n+\n+    let config = snap.config.join_lines();\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.file_line_index(file_id)?;\n+\n+    let mut res = TextEdit::default();\n+    for range in params.ranges {\n+        let range = from_proto::text_range(&line_index, range)?;\n+        let edit = snap.analysis.join_lines(&config, FileRange { file_id, range })?;\n+        match res.union(edit) {\n+            Ok(()) => (),\n+            Err(_edit) => {\n+                // just ignore overlapping edits\n+            }\n+        }\n+    }\n+\n+    Ok(to_proto::text_edit_vec(&line_index, res))\n+}\n+\n+pub(crate) fn handle_on_enter(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {\n+    let _p = profile::span(\"handle_on_enter\");\n+    let position = from_proto::file_position(&snap, params)?;\n+    let edit = match snap.analysis.on_enter(position)? {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+    let line_index = snap.file_line_index(position.file_id)?;\n+    let edit = to_proto::snippet_text_edit_vec(&line_index, true, edit);\n+    Ok(Some(edit))\n+}\n+\n+pub(crate) fn handle_on_type_formatting(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::DocumentOnTypeFormattingParams,\n+) -> Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {\n+    let _p = profile::span(\"handle_on_type_formatting\");\n+    let mut position = from_proto::file_position(&snap, params.text_document_position)?;\n+    let line_index = snap.file_line_index(position.file_id)?;\n+\n+    // in `ide`, the `on_type` invariant is that\n+    // `text.char_at(position) == typed_char`.\n+    position.offset -= TextSize::of('.');\n+    let char_typed = params.ch.chars().next().unwrap_or('\\0');\n+\n+    let text = snap.analysis.file_text(position.file_id)?;\n+    if stdx::never!(!text[usize::from(position.offset)..].starts_with(char_typed)) {\n+        return Ok(None);\n+    }\n+\n+    // We have an assist that inserts ` ` after typing `->` in `fn foo() ->{`,\n+    // but it requires precise cursor positioning to work, and one can't\n+    // position the cursor with on_type formatting. So, let's just toggle this\n+    // feature off here, hoping that we'll enable it one day, \ud83d\ude3f.\n+    if char_typed == '>' {\n+        return Ok(None);\n+    }\n+\n+    let edit =\n+        snap.analysis.on_char_typed(position, char_typed, snap.config.typing_autoclose_angle())?;\n+    let edit = match edit {\n+        Some(it) => it,\n+        None => return Ok(None),\n+    };\n+\n+    // This should be a single-file edit\n+    let (_, text_edit) = edit.source_file_edits.into_iter().next().unwrap();\n+\n+    let change = to_proto::snippet_text_edit_vec(&line_index, edit.is_snippet, text_edit);\n+    Ok(Some(change))\n+}\n+\n+pub(crate) fn handle_document_symbol(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::DocumentSymbolParams,\n+) -> Result<Option<lsp_types::DocumentSymbolResponse>> {\n+    let _p = profile::span(\"handle_document_symbol\");\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.file_line_index(file_id)?;\n+\n+    let mut parents: Vec<(lsp_types::DocumentSymbol, Option<usize>)> = Vec::new();\n+\n+    for symbol in snap.analysis.file_structure(file_id)? {\n+        let mut tags = Vec::new();\n+        if symbol.deprecated {\n+            tags.push(SymbolTag::DEPRECATED)\n+        };\n+\n+        #[allow(deprecated)]\n+        let doc_symbol = lsp_types::DocumentSymbol {\n+            name: symbol.label,\n+            detail: symbol.detail,\n+            kind: to_proto::structure_node_kind(symbol.kind),\n+            tags: Some(tags),\n+            deprecated: Some(symbol.deprecated),\n+            range: to_proto::range(&line_index, symbol.node_range),\n+            selection_range: to_proto::range(&line_index, symbol.navigation_range),\n+            children: None,\n+        };\n+        parents.push((doc_symbol, symbol.parent));\n+    }\n+\n+    // Builds hierarchy from a flat list, in reverse order (so that indices\n+    // makes sense)\n+    let document_symbols = {\n+        let mut acc = Vec::new();\n+        while let Some((mut node, parent_idx)) = parents.pop() {\n+            if let Some(children) = &mut node.children {\n+                children.reverse();\n+            }\n+            let parent = match parent_idx {\n+                None => &mut acc,\n+                Some(i) => parents[i].0.children.get_or_insert_with(Vec::new),\n+            };\n+            parent.push(node);\n+        }\n+        acc.reverse();\n+        acc\n+    };\n+\n+    let res = if snap.config.hierarchical_symbols() {\n+        document_symbols.into()\n+    } else {\n+        let url = to_proto::url(&snap, file_id);\n+        let mut symbol_information = Vec::<SymbolInformation>::new();\n+        for symbol in document_symbols {\n+            flatten_document_symbol(&symbol, None, &url, &mut symbol_information);\n+        }\n+        symbol_information.into()\n+    };\n+    return Ok(Some(res));\n+\n+    fn flatten_document_symbol(\n+        symbol: &lsp_types::DocumentSymbol,\n+        container_name: Option<String>,\n+        url: &Url,\n+        res: &mut Vec<SymbolInformation>,\n+    ) {\n+        let mut tags = Vec::new();\n+\n+        #[allow(deprecated)]\n+        if let Some(true) = symbol.deprecated {\n+            tags.push(SymbolTag::DEPRECATED)\n+        }\n+\n+        #[allow(deprecated)]\n+        res.push(SymbolInformation {\n+            name: symbol.name.clone(),\n+            kind: symbol.kind,\n+            tags: Some(tags),\n+            deprecated: symbol.deprecated,\n+            location: Location::new(url.clone(), symbol.range),\n+            container_name,\n+        });\n+\n+        for child in symbol.children.iter().flatten() {\n+            flatten_document_symbol(child, Some(symbol.name.clone()), url, res);\n+        }\n+    }\n+}\n+\n+pub(crate) fn handle_workspace_symbol(\n+    snap: GlobalStateSnapshot,\n+    params: WorkspaceSymbolParams,\n+) -> Result<Option<Vec<SymbolInformation>>> {\n+    let _p = profile::span(\"handle_workspace_symbol\");\n+\n+    let config = snap.config.workspace_symbol();\n+    let (all_symbols, libs) = decide_search_scope_and_kind(&params, &config);\n+    let limit = config.search_limit;\n+\n+    let query = {\n+        let query: String = params.query.chars().filter(|&c| c != '#' && c != '*').collect();\n+        let mut q = Query::new(query);\n+        if !all_symbols {\n+            q.only_types();\n+        }\n+        if libs {\n+            q.libs();\n+        }\n+        q.limit(limit);\n+        q\n+    };\n+    let mut res = exec_query(&snap, query)?;\n+    if res.is_empty() && !all_symbols {\n+        let mut query = Query::new(params.query);\n+        query.limit(limit);\n+        res = exec_query(&snap, query)?;\n+    }\n+\n+    return Ok(Some(res));\n+\n+    fn decide_search_scope_and_kind(\n+        params: &WorkspaceSymbolParams,\n+        config: &WorkspaceSymbolConfig,\n+    ) -> (bool, bool) {\n+        // Support old-style parsing of markers in the query.\n+        let mut all_symbols = params.query.contains('#');\n+        let mut libs = params.query.contains('*');\n+\n+        // If no explicit marker was set, check request params. If that's also empty\n+        // use global config.\n+        if !all_symbols {\n+            let search_kind = match params.search_kind {\n+                Some(ref search_kind) => search_kind,\n+                None => &config.search_kind,\n+            };\n+            all_symbols = match search_kind {\n+                lsp_ext::WorkspaceSymbolSearchKind::OnlyTypes => false,\n+                lsp_ext::WorkspaceSymbolSearchKind::AllSymbols => true,\n+            }\n+        }\n+\n+        if !libs {\n+            let search_scope = match params.search_scope {\n+                Some(ref search_scope) => search_scope,\n+                None => &config.search_scope,\n+            };\n+            libs = match search_scope {\n+                lsp_ext::WorkspaceSymbolSearchScope::Workspace => false,\n+                lsp_ext::WorkspaceSymbolSearchScope::WorkspaceAndDependencies => true,\n+            }\n+        }\n+\n+        (all_symbols, libs)\n+    }\n+\n+    fn exec_query(snap: &GlobalStateSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n+        let mut res = Vec::new();\n+        for nav in snap.analysis.symbol_search(query)? {\n+            let container_name = nav.container_name.as_ref().map(|v| v.to_string());\n+\n+            #[allow(deprecated)]\n+            let info = SymbolInformation {\n+                name: nav.name.to_string(),\n+                kind: nav\n+                    .kind\n+                    .map(to_proto::symbol_kind)\n+                    .unwrap_or(lsp_types::SymbolKind::VARIABLE),\n+                tags: None,\n+                location: to_proto::location_from_nav(snap, nav)?,\n+                container_name,\n+                deprecated: None,\n+            };\n+            res.push(info);\n+        }\n+        Ok(res)\n+    }\n+}\n+\n+pub(crate) fn handle_will_rename_files(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::RenameFilesParams,\n+) -> Result<Option<lsp_types::WorkspaceEdit>> {\n+    let _p = profile::span(\"handle_will_rename_files\");\n+\n+    let source_changes: Vec<SourceChange> = params\n+        .files\n+        .into_iter()\n+        .filter_map(|file_rename| {\n+            let from = Url::parse(&file_rename.old_uri).ok()?;\n+            let to = Url::parse(&file_rename.new_uri).ok()?;\n+\n+            let from_path = from.to_file_path().ok()?;\n+            let to_path = to.to_file_path().ok()?;\n+\n+            // Limit to single-level moves for now.\n+            match (from_path.parent(), to_path.parent()) {\n+                (Some(p1), Some(p2)) if p1 == p2 => {\n+                    if from_path.is_dir() {\n+                        // add '/' to end of url -- from `file://path/to/folder` to `file://path/to/folder/`\n+                        let mut old_folder_name = from_path.file_stem()?.to_str()?.to_string();\n+                        old_folder_name.push('/');\n+                        let from_with_trailing_slash = from.join(&old_folder_name).ok()?;\n+\n+                        let imitate_from_url = from_with_trailing_slash.join(\"mod.rs\").ok()?;\n+                        let new_file_name = to_path.file_name()?.to_str()?;\n+                        Some((\n+                            snap.url_to_file_id(&imitate_from_url).ok()?,\n+                            new_file_name.to_string(),\n+                        ))\n+                    } else {\n+                        let old_name = from_path.file_stem()?.to_str()?;\n+                        let new_name = to_path.file_stem()?.to_str()?;\n+                        match (old_name, new_name) {\n+                            (\"mod\", _) => None,\n+                            (_, \"mod\") => None,\n+                            _ => Some((snap.url_to_file_id(&from).ok()?, new_name.to_string())),\n+                        }\n+                    }\n+                }\n+                _ => None,\n+            }\n+        })\n+        .filter_map(|(file_id, new_name)| {\n+            snap.analysis.will_rename_file(file_id, &new_name).ok()?\n+        })\n+        .collect();\n+\n+    // Drop file system edits since we're just renaming things on the same level\n+    let mut source_changes = source_changes.into_iter();\n+    let mut source_change = source_changes.next().unwrap_or_default();\n+    source_change.file_system_edits.clear();\n+    // no collect here because we want to merge text edits on same file ids\n+    source_change.extend(source_changes.flat_map(|it| it.source_file_edits));\n+    if source_change.source_file_edits.is_empty() {\n+        Ok(None)\n+    } else {\n+        Ok(Some(to_proto::workspace_edit(&snap, source_change)?))\n+    }\n+}\n+\n+pub(crate) fn handle_goto_definition(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::GotoDefinitionParams,\n+) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n+    let _p = profile::span(\"handle_goto_definition\");\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis.goto_definition(position)? {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+    let src = FileRange { file_id: position.file_id, range: nav_info.range };\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_goto_declaration(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::request::GotoDeclarationParams,\n+) -> Result<Option<lsp_types::request::GotoDeclarationResponse>> {\n+    let _p = profile::span(\"handle_goto_declaration\");\n+    let position = from_proto::file_position(&snap, params.text_document_position_params.clone())?;\n+    let nav_info = match snap.analysis.goto_declaration(position)? {\n+        None => return handle_goto_definition(snap, params),\n+        Some(it) => it,\n+    };\n+    let src = FileRange { file_id: position.file_id, range: nav_info.range };\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_goto_implementation(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::request::GotoImplementationParams,\n+) -> Result<Option<lsp_types::request::GotoImplementationResponse>> {\n+    let _p = profile::span(\"handle_goto_implementation\");\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis.goto_implementation(position)? {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+    let src = FileRange { file_id: position.file_id, range: nav_info.range };\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_goto_type_definition(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::request::GotoTypeDefinitionParams,\n+) -> Result<Option<lsp_types::request::GotoTypeDefinitionResponse>> {\n+    let _p = profile::span(\"handle_goto_type_definition\");\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis.goto_type_definition(position)? {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+    let src = FileRange { file_id: position.file_id, range: nav_info.range };\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_parent_module(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n+    let _p = profile::span(\"handle_parent_module\");\n+    if let Ok(file_path) = &params.text_document.uri.to_file_path() {\n+        if file_path.file_name().unwrap_or_default() == \"Cargo.toml\" {\n+            // search workspaces for parent packages or fallback to workspace root\n+            let abs_path_buf = match AbsPathBuf::try_from(file_path.to_path_buf()).ok() {\n+                Some(abs_path_buf) => abs_path_buf,\n+                None => return Ok(None),\n+            };\n+\n+            let manifest_path = match ManifestPath::try_from(abs_path_buf).ok() {\n+                Some(manifest_path) => manifest_path,\n+                None => return Ok(None),\n+            };\n+\n+            let links: Vec<LocationLink> = snap\n+                .workspaces\n+                .iter()\n+                .filter_map(|ws| match ws {\n+                    ProjectWorkspace::Cargo { cargo, .. } => cargo.parent_manifests(&manifest_path),\n+                    _ => None,\n+                })\n+                .flatten()\n+                .map(|parent_manifest_path| LocationLink {\n+                    origin_selection_range: None,\n+                    target_uri: to_proto::url_from_abs_path(&parent_manifest_path),\n+                    target_range: Range::default(),\n+                    target_selection_range: Range::default(),\n+                })\n+                .collect::<_>();\n+            return Ok(Some(links.into()));\n+        }\n+\n+        // check if invoked at the crate root\n+        let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+        let crate_id = match snap.analysis.crates_for(file_id)?.first() {\n+            Some(&crate_id) => crate_id,\n+            None => return Ok(None),\n+        };\n+        let cargo_spec = match CargoTargetSpec::for_file(&snap, file_id)? {\n+            Some(it) => it,\n+            None => return Ok(None),\n+        };\n+\n+        if snap.analysis.crate_root(crate_id)? == file_id {\n+            let cargo_toml_url = to_proto::url_from_abs_path(&cargo_spec.cargo_toml);\n+            let res = vec![LocationLink {\n+                origin_selection_range: None,\n+                target_uri: cargo_toml_url,\n+                target_range: Range::default(),\n+                target_selection_range: Range::default(),\n+            }]\n+            .into();\n+            return Ok(Some(res));\n+        }\n+    }\n+\n+    // locate parent module by semantics\n+    let position = from_proto::file_position(&snap, params)?;\n+    let navs = snap.analysis.parent_module(position)?;\n+    let res = to_proto::goto_definition_response(&snap, None, navs)?;\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_runnables(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::RunnablesParams,\n+) -> Result<Vec<lsp_ext::Runnable>> {\n+    let _p = profile::span(\"handle_runnables\");\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.file_line_index(file_id)?;\n+    let offset = params.position.and_then(|it| from_proto::offset(&line_index, it).ok());\n+    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n+\n+    let expect_test = match offset {\n+        Some(offset) => {\n+            let source_file = snap.analysis.parse(file_id)?;\n+            algo::find_node_at_offset::<ast::MacroCall>(source_file.syntax(), offset)\n+                .and_then(|it| it.path()?.segment()?.name_ref())\n+                .map_or(false, |it| it.text() == \"expect\" || it.text() == \"expect_file\")\n+        }\n+        None => false,\n+    };\n+\n+    let mut res = Vec::new();\n+    for runnable in snap.analysis.runnables(file_id)? {\n+        if should_skip_for_offset(&runnable, offset) {\n+            continue;\n+        }\n+        if should_skip_target(&runnable, cargo_spec.as_ref()) {\n+            continue;\n+        }\n+        let mut runnable = to_proto::runnable(&snap, runnable)?;\n+        if expect_test {\n+            runnable.label = format!(\"{} + expect\", runnable.label);\n+            runnable.args.expect_test = Some(true);\n+        }\n+        res.push(runnable);\n+    }\n+\n+    // Add `cargo check` and `cargo test` for all targets of the whole package\n+    let config = snap.config.runnables();\n+    match cargo_spec {\n+        Some(spec) => {\n+            for cmd in [\"check\", \"test\"] {\n+                res.push(lsp_ext::Runnable {\n+                    label: format!(\"cargo {cmd} -p {} --all-targets\", spec.package),\n+                    location: None,\n+                    kind: lsp_ext::RunnableKind::Cargo,\n+                    args: lsp_ext::CargoRunnable {\n+                        workspace_root: Some(spec.workspace_root.clone().into()),\n+                        override_cargo: config.override_cargo.clone(),\n+                        cargo_args: vec![\n+                            cmd.to_string(),\n+                            \"--package\".to_string(),\n+                            spec.package.clone(),\n+                            \"--all-targets\".to_string(),\n+                        ],\n+                        cargo_extra_args: config.cargo_extra_args.clone(),\n+                        executable_args: Vec::new(),\n+                        expect_test: None,\n+                    },\n+                })\n+            }\n+        }\n+        None => {\n+            if !snap.config.linked_projects().is_empty() {\n+                res.push(lsp_ext::Runnable {\n+                    label: \"cargo check --workspace\".to_string(),\n+                    location: None,\n+                    kind: lsp_ext::RunnableKind::Cargo,\n+                    args: lsp_ext::CargoRunnable {\n+                        workspace_root: None,\n+                        override_cargo: config.override_cargo,\n+                        cargo_args: vec![\"check\".to_string(), \"--workspace\".to_string()],\n+                        cargo_extra_args: config.cargo_extra_args,\n+                        executable_args: Vec::new(),\n+                        expect_test: None,\n+                    },\n+                });\n+            }\n+        }\n+    }\n+    Ok(res)\n+}\n+\n+fn should_skip_for_offset(runnable: &Runnable, offset: Option<TextSize>) -> bool {\n+    match offset {\n+        None => false,\n+        _ if matches!(&runnable.kind, RunnableKind::TestMod { .. }) => false,\n+        Some(offset) => !runnable.nav.full_range.contains_inclusive(offset),\n+    }\n+}\n+\n+pub(crate) fn handle_related_tests(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<Vec<lsp_ext::TestInfo>> {\n+    let _p = profile::span(\"handle_related_tests\");\n+    let position = from_proto::file_position(&snap, params)?;\n+\n+    let tests = snap.analysis.related_tests(position, None)?;\n+    let mut res = Vec::new();\n+    for it in tests {\n+        if let Ok(runnable) = to_proto::runnable(&snap, it) {\n+            res.push(lsp_ext::TestInfo { runnable })\n+        }\n+    }\n+\n+    Ok(res)\n+}\n+\n+pub(crate) fn handle_completion(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::CompletionParams,\n+) -> Result<Option<lsp_types::CompletionResponse>> {\n+    let _p = profile::span(\"handle_completion\");\n+    let text_document_position = params.text_document_position.clone();\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n+    let completion_trigger_character =\n+        params.context.and_then(|ctx| ctx.trigger_character).and_then(|s| s.chars().next());\n+\n+    let completion_config = &snap.config.completion();\n+    let items = match snap.analysis.completions(\n+        completion_config,\n+        position,\n+        completion_trigger_character,\n+    )? {\n+        None => return Ok(None),\n+        Some(items) => items,\n+    };\n+    let line_index = snap.file_line_index(position.file_id)?;\n+\n+    let items =\n+        to_proto::completion_items(&snap.config, &line_index, text_document_position, items);\n+\n+    let completion_list = lsp_types::CompletionList { is_incomplete: true, items };\n+    Ok(Some(completion_list.into()))\n+}\n+\n+pub(crate) fn handle_completion_resolve(\n+    snap: GlobalStateSnapshot,\n+    mut original_completion: CompletionItem,\n+) -> Result<CompletionItem> {\n+    let _p = profile::span(\"handle_completion_resolve\");\n+\n+    if !all_edits_are_disjoint(&original_completion, &[]) {\n+        return Err(invalid_params_error(\n+            \"Received a completion with overlapping edits, this is not LSP-compliant\".to_string(),\n+        )\n+        .into());\n+    }\n+\n+    let data = match original_completion.data.take() {\n+        Some(it) => it,\n+        None => return Ok(original_completion),\n+    };\n+\n+    let resolve_data: lsp_ext::CompletionResolveData = serde_json::from_value(data)?;\n+\n+    let file_id = from_proto::file_id(&snap, &resolve_data.position.text_document.uri)?;\n+    let line_index = snap.file_line_index(file_id)?;\n+    let offset = from_proto::offset(&line_index, resolve_data.position.position)?;\n+\n+    let additional_edits = snap\n+        .analysis\n+        .resolve_completion_edits(\n+            &snap.config.completion(),\n+            FilePosition { file_id, offset },\n+            resolve_data\n+                .imports\n+                .into_iter()\n+                .map(|import| (import.full_import_path, import.imported_name)),\n+        )?\n+        .into_iter()\n+        .flat_map(|edit| edit.into_iter().map(|indel| to_proto::text_edit(&line_index, indel)))\n+        .collect::<Vec<_>>();\n+\n+    if !all_edits_are_disjoint(&original_completion, &additional_edits) {\n+        return Err(LspError::new(\n+            ErrorCode::InternalError as i32,\n+            \"Import edit overlaps with the original completion edits, this is not LSP-compliant\"\n+                .into(),\n+        )\n+        .into());\n+    }\n+\n+    if let Some(original_additional_edits) = original_completion.additional_text_edits.as_mut() {\n+        original_additional_edits.extend(additional_edits.into_iter())\n+    } else {\n+        original_completion.additional_text_edits = Some(additional_edits);\n+    }\n+\n+    Ok(original_completion)\n+}\n+\n+pub(crate) fn handle_folding_range(\n+    snap: GlobalStateSnapshot,\n+    params: FoldingRangeParams,\n+) -> Result<Option<Vec<FoldingRange>>> {\n+    let _p = profile::span(\"handle_folding_range\");\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let folds = snap.analysis.folding_ranges(file_id)?;\n+    let text = snap.analysis.file_text(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n+    let line_folding_only = snap.config.line_folding_only();\n+    let res = folds\n+        .into_iter()\n+        .map(|it| to_proto::folding_range(&text, &line_index, line_folding_only, it))\n+        .collect();\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_signature_help(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::SignatureHelpParams,\n+) -> Result<Option<lsp_types::SignatureHelp>> {\n+    let _p = profile::span(\"handle_signature_help\");\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let help = match snap.analysis.signature_help(position)? {\n+        Some(it) => it,\n+        None => return Ok(None),\n+    };\n+    let config = snap.config.call_info();\n+    let res = to_proto::signature_help(help, config, snap.config.signature_help_label_offsets());\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_hover(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::HoverParams,\n+) -> Result<Option<lsp_ext::Hover>> {\n+    let _p = profile::span(\"handle_hover\");\n+    let range = match params.position {\n+        PositionOrRange::Position(position) => Range::new(position, position),\n+        PositionOrRange::Range(range) => range,\n+    };\n+\n+    let file_range = from_proto::file_range(&snap, params.text_document, range)?;\n+    let info = match snap.analysis.hover(&snap.config.hover(), file_range)? {\n+        None => return Ok(None),\n+        Some(info) => info,\n+    };\n+\n+    let line_index = snap.file_line_index(file_range.file_id)?;\n+    let range = to_proto::range(&line_index, info.range);\n+    let markup_kind = snap.config.hover().format;\n+    let hover = lsp_ext::Hover {\n+        hover: lsp_types::Hover {\n+            contents: HoverContents::Markup(to_proto::markup_content(\n+                info.info.markup,\n+                markup_kind,\n+            )),\n+            range: Some(range),\n+        },\n+        actions: if snap.config.hover_actions().none() {\n+            Vec::new()\n+        } else {\n+            prepare_hover_actions(&snap, &info.info.actions)\n+        },\n+    };\n+\n+    Ok(Some(hover))\n+}\n+\n+pub(crate) fn handle_prepare_rename(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<Option<PrepareRenameResponse>> {\n+    let _p = profile::span(\"handle_prepare_rename\");\n+    let position = from_proto::file_position(&snap, params)?;\n+\n+    let change = snap.analysis.prepare_rename(position)?.map_err(to_proto::rename_error)?;\n+\n+    let line_index = snap.file_line_index(position.file_id)?;\n+    let range = to_proto::range(&line_index, change.range);\n+    Ok(Some(PrepareRenameResponse::Range(range)))\n+}\n+\n+pub(crate) fn handle_rename(\n+    snap: GlobalStateSnapshot,\n+    params: RenameParams,\n+) -> Result<Option<WorkspaceEdit>> {\n+    let _p = profile::span(\"handle_rename\");\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n+\n+    let mut change =\n+        snap.analysis.rename(position, &params.new_name)?.map_err(to_proto::rename_error)?;\n+\n+    // this is kind of a hack to prevent double edits from happening when moving files\n+    // When a module gets renamed by renaming the mod declaration this causes the file to move\n+    // which in turn will trigger a WillRenameFiles request to the server for which we reply with a\n+    // a second identical set of renames, the client will then apply both edits causing incorrect edits\n+    // with this we only emit source_file_edits in the WillRenameFiles response which will do the rename instead\n+    // See https://github.com/microsoft/vscode-languageserver-node/issues/752 for more info\n+    if !change.file_system_edits.is_empty() && snap.config.will_rename() {\n+        change.source_file_edits.clear();\n+    }\n+    let workspace_edit = to_proto::workspace_edit(&snap, change)?;\n+    Ok(Some(workspace_edit))\n+}\n+\n+pub(crate) fn handle_references(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::ReferenceParams,\n+) -> Result<Option<Vec<Location>>> {\n+    let _p = profile::span(\"handle_references\");\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n+\n+    let exclude_imports = snap.config.find_all_refs_exclude_imports();\n+\n+    let refs = match snap.analysis.find_all_refs(position, None)? {\n+        None => return Ok(None),\n+        Some(refs) => refs,\n+    };\n+\n+    let include_declaration = params.context.include_declaration;\n+    let locations = refs\n+        .into_iter()\n+        .flat_map(|refs| {\n+            let decl = if include_declaration {\n+                refs.declaration.map(|decl| FileRange {\n+                    file_id: decl.nav.file_id,\n+                    range: decl.nav.focus_or_full_range(),\n+                })\n+            } else {\n+                None\n+            };\n+            refs.references\n+                .into_iter()\n+                .flat_map(|(file_id, refs)| {\n+                    refs.into_iter()\n+                        .filter(|&(_, category)| {\n+                            !exclude_imports || category != Some(ReferenceCategory::Import)\n+                        })\n+                        .map(move |(range, _)| FileRange { file_id, range })\n+                })\n+                .chain(decl)\n+        })\n+        .filter_map(|frange| to_proto::location(&snap, frange).ok())\n+        .collect();\n+\n+    Ok(Some(locations))\n+}\n+\n+pub(crate) fn handle_formatting(\n+    snap: GlobalStateSnapshot,\n+    params: DocumentFormattingParams,\n+) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n+    let _p = profile::span(\"handle_formatting\");\n+\n+    run_rustfmt(&snap, params.text_document, None)\n+}\n+\n+pub(crate) fn handle_range_formatting(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::DocumentRangeFormattingParams,\n+) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n+    let _p = profile::span(\"handle_range_formatting\");\n+\n+    run_rustfmt(&snap, params.text_document, Some(params.range))\n+}\n+\n+pub(crate) fn handle_code_action(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::CodeActionParams,\n+) -> Result<Option<Vec<lsp_ext::CodeAction>>> {\n+    let _p = profile::span(\"handle_code_action\");\n+\n+    if !snap.config.code_action_literals() {\n+        // We intentionally don't support command-based actions, as those either\n+        // require either custom client-code or server-initiated edits. Server\n+        // initiated edits break causality, so we avoid those.\n+        return Ok(None);\n+    }\n+\n+    let line_index =\n+        snap.file_line_index(from_proto::file_id(&snap, &params.text_document.uri)?)?;\n+    let frange = from_proto::file_range(&snap, params.text_document.clone(), params.range)?;\n+\n+    let mut assists_config = snap.config.assist();\n+    assists_config.allowed = params\n+        .context\n+        .only\n+        .clone()\n+        .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());\n+\n+    let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n+\n+    let code_action_resolve_cap = snap.config.code_action_resolve();\n+    let resolve = if code_action_resolve_cap {\n+        AssistResolveStrategy::None\n+    } else {\n+        AssistResolveStrategy::All\n+    };\n+    let assists = snap.analysis.assists_with_fixes(\n+        &assists_config,\n+        &snap.config.diagnostics(),\n+        resolve,\n+        frange,\n+    )?;\n+    for (index, assist) in assists.into_iter().enumerate() {\n+        let resolve_data =\n+            if code_action_resolve_cap { Some((index, params.clone())) } else { None };\n+        let code_action = to_proto::code_action(&snap, assist, resolve_data)?;\n+        res.push(code_action)\n+    }\n+\n+    // Fixes from `cargo check`.\n+    for fix in snap.check_fixes.values().filter_map(|it| it.get(&frange.file_id)).flatten() {\n+        // FIXME: this mapping is awkward and shouldn't exist. Refactor\n+        // `snap.check_fixes` to not convert to LSP prematurely.\n+        let intersect_fix_range = fix\n+            .ranges\n+            .iter()\n+            .copied()\n+            .filter_map(|range| from_proto::text_range(&line_index, range).ok())\n+            .any(|fix_range| fix_range.intersect(frange.range).is_some());\n+        if intersect_fix_range {\n+            res.push(fix.action.clone());\n+        }\n+    }\n+\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_code_action_resolve(\n+    snap: GlobalStateSnapshot,\n+    mut code_action: lsp_ext::CodeAction,\n+) -> Result<lsp_ext::CodeAction> {\n+    let _p = profile::span(\"handle_code_action_resolve\");\n+    let params = match code_action.data.take() {\n+        Some(it) => it,\n+        None => return Err(invalid_params_error(\"code action without data\".to_string()).into()),\n+    };\n+\n+    let file_id = from_proto::file_id(&snap, &params.code_action_params.text_document.uri)?;\n+    let line_index = snap.file_line_index(file_id)?;\n+    let range = from_proto::text_range(&line_index, params.code_action_params.range)?;\n+    let frange = FileRange { file_id, range };\n+\n+    let mut assists_config = snap.config.assist();\n+    assists_config.allowed = params\n+        .code_action_params\n+        .context\n+        .only\n+        .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());\n+\n+    let (assist_index, assist_resolve) = match parse_action_id(&params.id) {\n+        Ok(parsed_data) => parsed_data,\n+        Err(e) => {\n+            return Err(invalid_params_error(format!(\n+                \"Failed to parse action id string '{}': {e}\",\n+                params.id\n+            ))\n+            .into())\n+        }\n+    };\n+\n+    let expected_assist_id = assist_resolve.assist_id.clone();\n+    let expected_kind = assist_resolve.assist_kind;\n+\n+    let assists = snap.analysis.assists_with_fixes(\n+        &assists_config,\n+        &snap.config.diagnostics(),\n+        AssistResolveStrategy::Single(assist_resolve),\n+        frange,\n+    )?;\n+\n+    let assist = match assists.get(assist_index) {\n+        Some(assist) => assist,\n+        None => return Err(invalid_params_error(format!(\n+            \"Failed to find the assist for index {} provided by the resolve request. Resolve request assist id: {}\",\n+            assist_index, params.id,\n+        ))\n+        .into())\n+    };\n+    if assist.id.0 != expected_assist_id || assist.id.1 != expected_kind {\n+        return Err(invalid_params_error(format!(\n+            \"Mismatching assist at index {} for the resolve parameters given. Resolve request assist id: {}, actual id: {:?}.\",\n+            assist_index, params.id, assist.id\n+        ))\n+        .into());\n+    }\n+    let ca = to_proto::code_action(&snap, assist.clone(), None)?;\n+    code_action.edit = ca.edit;\n+    code_action.command = ca.command;\n+    Ok(code_action)\n+}\n+\n+fn parse_action_id(action_id: &str) -> Result<(usize, SingleResolve), String> {\n+    let id_parts = action_id.split(':').collect::<Vec<_>>();\n+    match id_parts.as_slice() {\n+        [assist_id_string, assist_kind_string, index_string] => {\n+            let assist_kind: AssistKind = assist_kind_string.parse()?;\n+            let index: usize = match index_string.parse() {\n+                Ok(index) => index,\n+                Err(e) => return Err(format!(\"Incorrect index string: {e}\")),\n+            };\n+            Ok((index, SingleResolve { assist_id: assist_id_string.to_string(), assist_kind }))\n+        }\n+        _ => Err(\"Action id contains incorrect number of segments\".to_string()),\n+    }\n+}\n+\n+pub(crate) fn handle_code_lens(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::CodeLensParams,\n+) -> Result<Option<Vec<CodeLens>>> {\n+    let _p = profile::span(\"handle_code_lens\");\n+\n+    let lens_config = snap.config.lens();\n+    if lens_config.none() {\n+        // early return before any db query!\n+        return Ok(Some(Vec::default()));\n+    }\n+\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let cargo_target_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n+\n+    let annotations = snap.analysis.annotations(\n+        &AnnotationConfig {\n+            binary_target: cargo_target_spec\n+                .map(|spec| {\n+                    matches!(\n+                        spec.target_kind,\n+                        TargetKind::Bin | TargetKind::Example | TargetKind::Test\n+                    )\n+                })\n+                .unwrap_or(false),\n+            annotate_runnables: lens_config.runnable(),\n+            annotate_impls: lens_config.implementations,\n+            annotate_references: lens_config.refs_adt,\n+            annotate_method_references: lens_config.method_refs,\n+            annotate_enum_variant_references: lens_config.enum_variant_refs,\n+            location: lens_config.location.into(),\n+        },\n+        file_id,\n+    )?;\n+\n+    let mut res = Vec::new();\n+    for a in annotations {\n+        to_proto::code_lens(&mut res, &snap, a)?;\n+    }\n+\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_code_lens_resolve(\n+    snap: GlobalStateSnapshot,\n+    code_lens: CodeLens,\n+) -> Result<CodeLens> {\n+    let Some(annotation) = from_proto::annotation(&snap, code_lens.clone())? else { return Ok(code_lens) };\n+    let annotation = snap.analysis.resolve_annotation(annotation)?;\n+\n+    let mut acc = Vec::new();\n+    to_proto::code_lens(&mut acc, &snap, annotation)?;\n+\n+    let res = match acc.pop() {\n+        Some(it) if acc.is_empty() => it,\n+        _ => {\n+            never!();\n+            code_lens\n+        }\n+    };\n+\n+    Ok(res)\n+}\n+\n+pub(crate) fn handle_document_highlight(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::DocumentHighlightParams,\n+) -> Result<Option<Vec<lsp_types::DocumentHighlight>>> {\n+    let _p = profile::span(\"handle_document_highlight\");\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let line_index = snap.file_line_index(position.file_id)?;\n+\n+    let refs = match snap.analysis.highlight_related(snap.config.highlight_related(), position)? {\n+        None => return Ok(None),\n+        Some(refs) => refs,\n+    };\n+    let res = refs\n+        .into_iter()\n+        .map(|ide::HighlightedRange { range, category }| lsp_types::DocumentHighlight {\n+            range: to_proto::range(&line_index, range),\n+            kind: category.and_then(to_proto::document_highlight_kind),\n+        })\n+        .collect();\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_ssr(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::SsrParams,\n+) -> Result<lsp_types::WorkspaceEdit> {\n+    let _p = profile::span(\"handle_ssr\");\n+    let selections = params\n+        .selections\n+        .iter()\n+        .map(|range| from_proto::file_range(&snap, params.position.text_document.clone(), *range))\n+        .collect::<Result<Vec<_>, _>>()?;\n+    let position = from_proto::file_position(&snap, params.position)?;\n+    let source_change = snap.analysis.structural_search_replace(\n+        &params.query,\n+        params.parse_only,\n+        position,\n+        selections,\n+    )??;\n+    to_proto::workspace_edit(&snap, source_change).map_err(Into::into)\n+}\n+\n+pub(crate) fn handle_inlay_hints(\n+    snap: GlobalStateSnapshot,\n+    params: InlayHintParams,\n+) -> Result<Option<Vec<InlayHint>>> {\n+    let _p = profile::span(\"handle_inlay_hints\");\n+    let document_uri = &params.text_document.uri;\n+    let FileRange { file_id, range } = from_proto::file_range(\n+        &snap,\n+        TextDocumentIdentifier::new(document_uri.to_owned()),\n+        params.range,\n+    )?;\n+    let line_index = snap.file_line_index(file_id)?;\n+    let inlay_hints_config = snap.config.inlay_hints();\n+    Ok(Some(\n+        snap.analysis\n+            .inlay_hints(&inlay_hints_config, file_id, Some(range))?\n+            .into_iter()\n+            .map(|it| {\n+                to_proto::inlay_hint(&snap, &line_index, inlay_hints_config.render_colons, it)\n+            })\n+            .collect::<Cancellable<Vec<_>>>()?,\n+    ))\n+}\n+\n+pub(crate) fn handle_inlay_hints_resolve(\n+    _snap: GlobalStateSnapshot,\n+    hint: InlayHint,\n+) -> Result<InlayHint> {\n+    let _p = profile::span(\"handle_inlay_hints_resolve\");\n+    Ok(hint)\n+}\n+\n+pub(crate) fn handle_call_hierarchy_prepare(\n+    snap: GlobalStateSnapshot,\n+    params: CallHierarchyPrepareParams,\n+) -> Result<Option<Vec<CallHierarchyItem>>> {\n+    let _p = profile::span(\"handle_call_hierarchy_prepare\");\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+\n+    let nav_info = match snap.analysis.call_hierarchy(position)? {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+\n+    let RangeInfo { range: _, info: navs } = nav_info;\n+    let res = navs\n+        .into_iter()\n+        .filter(|it| it.kind == Some(SymbolKind::Function))\n+        .map(|it| to_proto::call_hierarchy_item(&snap, it))\n+        .collect::<Cancellable<Vec<_>>>()?;\n+\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_call_hierarchy_incoming(\n+    snap: GlobalStateSnapshot,\n+    params: CallHierarchyIncomingCallsParams,\n+) -> Result<Option<Vec<CallHierarchyIncomingCall>>> {\n+    let _p = profile::span(\"handle_call_hierarchy_incoming\");\n+    let item = params.item;\n+\n+    let doc = TextDocumentIdentifier::new(item.uri);\n+    let frange = from_proto::file_range(&snap, doc, item.selection_range)?;\n+    let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n+\n+    let call_items = match snap.analysis.incoming_calls(fpos)? {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+\n+    let mut res = vec![];\n+\n+    for call_item in call_items.into_iter() {\n+        let file_id = call_item.target.file_id;\n+        let line_index = snap.file_line_index(file_id)?;\n+        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n+        res.push(CallHierarchyIncomingCall {\n+            from: item,\n+            from_ranges: call_item\n+                .ranges\n+                .into_iter()\n+                .map(|it| to_proto::range(&line_index, it))\n+                .collect(),\n+        });\n+    }\n+\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_call_hierarchy_outgoing(\n+    snap: GlobalStateSnapshot,\n+    params: CallHierarchyOutgoingCallsParams,\n+) -> Result<Option<Vec<CallHierarchyOutgoingCall>>> {\n+    let _p = profile::span(\"handle_call_hierarchy_outgoing\");\n+    let item = params.item;\n+\n+    let doc = TextDocumentIdentifier::new(item.uri);\n+    let frange = from_proto::file_range(&snap, doc, item.selection_range)?;\n+    let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n+\n+    let call_items = match snap.analysis.outgoing_calls(fpos)? {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+\n+    let mut res = vec![];\n+\n+    for call_item in call_items.into_iter() {\n+        let file_id = call_item.target.file_id;\n+        let line_index = snap.file_line_index(file_id)?;\n+        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n+        res.push(CallHierarchyOutgoingCall {\n+            to: item,\n+            from_ranges: call_item\n+                .ranges\n+                .into_iter()\n+                .map(|it| to_proto::range(&line_index, it))\n+                .collect(),\n+        });\n+    }\n+\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_semantic_tokens_full(\n+    snap: GlobalStateSnapshot,\n+    params: SemanticTokensParams,\n+) -> Result<Option<SemanticTokensResult>> {\n+    let _p = profile::span(\"handle_semantic_tokens_full\");\n+\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let text = snap.analysis.file_text(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n+\n+    let mut highlight_config = snap.config.highlighting_config();\n+    // Avoid flashing a bunch of unresolved references when the proc-macro servers haven't been spawned yet.\n+    highlight_config.syntactic_name_ref_highlighting =\n+        snap.workspaces.is_empty() || !snap.proc_macros_loaded;\n+\n+    let highlights = snap.analysis.highlight(highlight_config, file_id)?;\n+    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n+\n+    // Unconditionally cache the tokens\n+    snap.semantic_tokens_cache.lock().insert(params.text_document.uri, semantic_tokens.clone());\n+\n+    Ok(Some(semantic_tokens.into()))\n+}\n+\n+pub(crate) fn handle_semantic_tokens_full_delta(\n+    snap: GlobalStateSnapshot,\n+    params: SemanticTokensDeltaParams,\n+) -> Result<Option<SemanticTokensFullDeltaResult>> {\n+    let _p = profile::span(\"handle_semantic_tokens_full_delta\");\n+\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let text = snap.analysis.file_text(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n+\n+    let mut highlight_config = snap.config.highlighting_config();\n+    // Avoid flashing a bunch of unresolved references when the proc-macro servers haven't been spawned yet.\n+    highlight_config.syntactic_name_ref_highlighting =\n+        snap.workspaces.is_empty() || !snap.proc_macros_loaded;\n+\n+    let highlights = snap.analysis.highlight(highlight_config, file_id)?;\n+    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n+\n+    let mut cache = snap.semantic_tokens_cache.lock();\n+    let cached_tokens = cache.entry(params.text_document.uri).or_default();\n+\n+    if let Some(prev_id) = &cached_tokens.result_id {\n+        if *prev_id == params.previous_result_id {\n+            let delta = to_proto::semantic_token_delta(cached_tokens, &semantic_tokens);\n+            *cached_tokens = semantic_tokens;\n+            return Ok(Some(delta.into()));\n+        }\n+    }\n+\n+    *cached_tokens = semantic_tokens.clone();\n+\n+    Ok(Some(semantic_tokens.into()))\n+}\n+\n+pub(crate) fn handle_semantic_tokens_range(\n+    snap: GlobalStateSnapshot,\n+    params: SemanticTokensRangeParams,\n+) -> Result<Option<SemanticTokensRangeResult>> {\n+    let _p = profile::span(\"handle_semantic_tokens_range\");\n+\n+    let frange = from_proto::file_range(&snap, params.text_document, params.range)?;\n+    let text = snap.analysis.file_text(frange.file_id)?;\n+    let line_index = snap.file_line_index(frange.file_id)?;\n+\n+    let mut highlight_config = snap.config.highlighting_config();\n+    // Avoid flashing a bunch of unresolved references when the proc-macro servers haven't been spawned yet.\n+    highlight_config.syntactic_name_ref_highlighting =\n+        snap.workspaces.is_empty() || !snap.proc_macros_loaded;\n+\n+    let highlights = snap.analysis.highlight_range(highlight_config, frange)?;\n+    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n+    Ok(Some(semantic_tokens.into()))\n+}\n+\n+pub(crate) fn handle_open_docs(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<Option<lsp_types::Url>> {\n+    let _p = profile::span(\"handle_open_docs\");\n+    let position = from_proto::file_position(&snap, params)?;\n+\n+    let remote = snap.analysis.external_docs(position)?;\n+\n+    Ok(remote.and_then(|remote| Url::parse(&remote).ok()))\n+}\n+\n+pub(crate) fn handle_open_cargo_toml(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::OpenCargoTomlParams,\n+) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n+    let _p = profile::span(\"handle_open_cargo_toml\");\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+\n+    let cargo_spec = match CargoTargetSpec::for_file(&snap, file_id)? {\n+        Some(it) => it,\n+        None => return Ok(None),\n+    };\n+\n+    let cargo_toml_url = to_proto::url_from_abs_path(&cargo_spec.cargo_toml);\n+    let res: lsp_types::GotoDefinitionResponse =\n+        Location::new(cargo_toml_url, Range::default()).into();\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn handle_move_item(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::MoveItemParams,\n+) -> Result<Vec<lsp_ext::SnippetTextEdit>> {\n+    let _p = profile::span(\"handle_move_item\");\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let range = from_proto::file_range(&snap, params.text_document, params.range)?;\n+\n+    let direction = match params.direction {\n+        lsp_ext::MoveItemDirection::Up => ide::Direction::Up,\n+        lsp_ext::MoveItemDirection::Down => ide::Direction::Down,\n+    };\n+\n+    match snap.analysis.move_item(range, direction)? {\n+        Some(text_edit) => {\n+            let line_index = snap.file_line_index(file_id)?;\n+            Ok(to_proto::snippet_text_edit_vec(&line_index, true, text_edit))\n+        }\n+        None => Ok(vec![]),\n+    }\n+}\n+\n+fn to_command_link(command: lsp_types::Command, tooltip: String) -> lsp_ext::CommandLink {\n+    lsp_ext::CommandLink { tooltip: Some(tooltip), command }\n+}\n+\n+fn show_impl_command_link(\n+    snap: &GlobalStateSnapshot,\n+    position: &FilePosition,\n+) -> Option<lsp_ext::CommandLinkGroup> {\n+    if snap.config.hover_actions().implementations && snap.config.client_commands().show_reference {\n+        if let Some(nav_data) = snap.analysis.goto_implementation(*position).unwrap_or(None) {\n+            let uri = to_proto::url(snap, position.file_id);\n+            let line_index = snap.file_line_index(position.file_id).ok()?;\n+            let position = to_proto::position(&line_index, position.offset);\n+            let locations: Vec<_> = nav_data\n+                .info\n+                .into_iter()\n+                .filter_map(|nav| to_proto::location_from_nav(snap, nav).ok())\n+                .collect();\n+            let title = to_proto::implementation_title(locations.len());\n+            let command = to_proto::command::show_references(title, &uri, position, locations);\n+\n+            return Some(lsp_ext::CommandLinkGroup {\n+                commands: vec![to_command_link(command, \"Go to implementations\".into())],\n+                ..Default::default()\n+            });\n+        }\n+    }\n+    None\n+}\n+\n+fn show_ref_command_link(\n+    snap: &GlobalStateSnapshot,\n+    position: &FilePosition,\n+) -> Option<lsp_ext::CommandLinkGroup> {\n+    if snap.config.hover_actions().references && snap.config.client_commands().show_reference {\n+        if let Some(ref_search_res) = snap.analysis.find_all_refs(*position, None).unwrap_or(None) {\n+            let uri = to_proto::url(snap, position.file_id);\n+            let line_index = snap.file_line_index(position.file_id).ok()?;\n+            let position = to_proto::position(&line_index, position.offset);\n+            let locations: Vec<_> = ref_search_res\n+                .into_iter()\n+                .flat_map(|res| res.references)\n+                .flat_map(|(file_id, ranges)| {\n+                    ranges.into_iter().filter_map(move |(range, _)| {\n+                        to_proto::location(snap, FileRange { file_id, range }).ok()\n+                    })\n+                })\n+                .collect();\n+            let title = to_proto::reference_title(locations.len());\n+            let command = to_proto::command::show_references(title, &uri, position, locations);\n+\n+            return Some(lsp_ext::CommandLinkGroup {\n+                commands: vec![to_command_link(command, \"Go to references\".into())],\n+                ..Default::default()\n+            });\n+        }\n+    }\n+    None\n+}\n+\n+fn runnable_action_links(\n+    snap: &GlobalStateSnapshot,\n+    runnable: Runnable,\n+) -> Option<lsp_ext::CommandLinkGroup> {\n+    let hover_actions_config = snap.config.hover_actions();\n+    if !hover_actions_config.runnable() {\n+        return None;\n+    }\n+\n+    let cargo_spec = CargoTargetSpec::for_file(snap, runnable.nav.file_id).ok()?;\n+    if should_skip_target(&runnable, cargo_spec.as_ref()) {\n+        return None;\n+    }\n+\n+    let client_commands_config = snap.config.client_commands();\n+    if !(client_commands_config.run_single || client_commands_config.debug_single) {\n+        return None;\n+    }\n+\n+    let title = runnable.title();\n+    let r = to_proto::runnable(snap, runnable).ok()?;\n+\n+    let mut group = lsp_ext::CommandLinkGroup::default();\n+\n+    if hover_actions_config.run && client_commands_config.run_single {\n+        let run_command = to_proto::command::run_single(&r, &title);\n+        group.commands.push(to_command_link(run_command, r.label.clone()));\n+    }\n+\n+    if hover_actions_config.debug && client_commands_config.debug_single {\n+        let dbg_command = to_proto::command::debug_single(&r);\n+        group.commands.push(to_command_link(dbg_command, r.label));\n+    }\n+\n+    Some(group)\n+}\n+\n+fn goto_type_action_links(\n+    snap: &GlobalStateSnapshot,\n+    nav_targets: &[HoverGotoTypeData],\n+) -> Option<lsp_ext::CommandLinkGroup> {\n+    if !snap.config.hover_actions().goto_type_def\n+        || nav_targets.is_empty()\n+        || !snap.config.client_commands().goto_location\n+    {\n+        return None;\n+    }\n+\n+    Some(lsp_ext::CommandLinkGroup {\n+        title: Some(\"Go to \".into()),\n+        commands: nav_targets\n+            .iter()\n+            .filter_map(|it| {\n+                to_proto::command::goto_location(snap, &it.nav)\n+                    .map(|cmd| to_command_link(cmd, it.mod_path.clone()))\n+            })\n+            .collect(),\n+    })\n+}\n+\n+fn prepare_hover_actions(\n+    snap: &GlobalStateSnapshot,\n+    actions: &[HoverAction],\n+) -> Vec<lsp_ext::CommandLinkGroup> {\n+    actions\n+        .iter()\n+        .filter_map(|it| match it {\n+            HoverAction::Implementation(position) => show_impl_command_link(snap, position),\n+            HoverAction::Reference(position) => show_ref_command_link(snap, position),\n+            HoverAction::Runnable(r) => runnable_action_links(snap, r.clone()),\n+            HoverAction::GoToType(targets) => goto_type_action_links(snap, targets),\n+        })\n+        .collect()\n+}\n+\n+fn should_skip_target(runnable: &Runnable, cargo_spec: Option<&CargoTargetSpec>) -> bool {\n+    match runnable.kind {\n+        RunnableKind::Bin => {\n+            // Do not suggest binary run on other target than binary\n+            match &cargo_spec {\n+                Some(spec) => !matches!(\n+                    spec.target_kind,\n+                    TargetKind::Bin | TargetKind::Example | TargetKind::Test\n+                ),\n+                None => true,\n+            }\n+        }\n+        _ => false,\n+    }\n+}\n+\n+fn run_rustfmt(\n+    snap: &GlobalStateSnapshot,\n+    text_document: TextDocumentIdentifier,\n+    range: Option<lsp_types::Range>,\n+) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n+    let file_id = from_proto::file_id(snap, &text_document.uri)?;\n+    let file = snap.analysis.file_text(file_id)?;\n+\n+    // Determine the edition of the crate the file belongs to (if there's multiple, we pick the\n+    // highest edition).\n+    let editions = snap\n+        .analysis\n+        .relevant_crates_for(file_id)?\n+        .into_iter()\n+        .map(|crate_id| snap.analysis.crate_edition(crate_id))\n+        .collect::<Result<Vec<_>, _>>()?;\n+    let edition = editions.iter().copied().max();\n+\n+    let line_index = snap.file_line_index(file_id)?;\n+\n+    let mut command = match snap.config.rustfmt() {\n+        RustfmtConfig::Rustfmt { extra_args, enable_range_formatting } => {\n+            let mut cmd = process::Command::new(toolchain::rustfmt());\n+            cmd.envs(snap.config.extra_env());\n+            cmd.args(extra_args);\n+            // try to chdir to the file so we can respect `rustfmt.toml`\n+            // FIXME: use `rustfmt --config-path` once\n+            // https://github.com/rust-lang/rustfmt/issues/4660 gets fixed\n+            match text_document.uri.to_file_path() {\n+                Ok(mut path) => {\n+                    // pop off file name\n+                    if path.pop() && path.is_dir() {\n+                        cmd.current_dir(path);\n+                    }\n+                }\n+                Err(_) => {\n+                    tracing::error!(\n+                        \"Unable to get file path for {}, rustfmt.toml might be ignored\",\n+                        text_document.uri\n+                    );\n+                }\n+            }\n+            if let Some(edition) = edition {\n+                cmd.arg(\"--edition\");\n+                cmd.arg(edition.to_string());\n+            }\n+\n+            if let Some(range) = range {\n+                if !enable_range_formatting {\n+                    return Err(LspError::new(\n+                        ErrorCode::InvalidRequest as i32,\n+                        String::from(\n+                            \"rustfmt range formatting is unstable. \\\n+                            Opt-in by using a nightly build of rustfmt and setting \\\n+                            `rustfmt.rangeFormatting.enable` to true in your LSP configuration\",\n+                        ),\n+                    )\n+                    .into());\n+                }\n+\n+                let frange = from_proto::file_range(snap, text_document, range)?;\n+                let start_line = line_index.index.line_col(frange.range.start()).line;\n+                let end_line = line_index.index.line_col(frange.range.end()).line;\n+\n+                cmd.arg(\"--unstable-features\");\n+                cmd.arg(\"--file-lines\");\n+                cmd.arg(\n+                    json!([{\n+                        \"file\": \"stdin\",\n+                        \"range\": [start_line, end_line]\n+                    }])\n+                    .to_string(),\n+                );\n+            }\n+\n+            cmd\n+        }\n+        RustfmtConfig::CustomCommand { command, args } => {\n+            let mut cmd = process::Command::new(command);\n+            cmd.envs(snap.config.extra_env());\n+            cmd.args(args);\n+            cmd\n+        }\n+    };\n+\n+    let mut rustfmt = command\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .stderr(Stdio::piped())\n+        .spawn()\n+        .context(format!(\"Failed to spawn {command:?}\"))?;\n+\n+    rustfmt.stdin.as_mut().unwrap().write_all(file.as_bytes())?;\n+\n+    let output = rustfmt.wait_with_output()?;\n+    let captured_stdout = String::from_utf8(output.stdout)?;\n+    let captured_stderr = String::from_utf8(output.stderr).unwrap_or_default();\n+\n+    if !output.status.success() {\n+        let rustfmt_not_installed =\n+            captured_stderr.contains(\"not installed\") || captured_stderr.contains(\"not available\");\n+\n+        return match output.status.code() {\n+            Some(1) if !rustfmt_not_installed => {\n+                // While `rustfmt` doesn't have a specific exit code for parse errors this is the\n+                // likely cause exiting with 1. Most Language Servers swallow parse errors on\n+                // formatting because otherwise an error is surfaced to the user on top of the\n+                // syntax error diagnostics they're already receiving. This is especially jarring\n+                // if they have format on save enabled.\n+                tracing::warn!(\n+                    ?command,\n+                    %captured_stderr,\n+                    \"rustfmt exited with status 1\"\n+                );\n+                Ok(None)\n+            }\n+            _ => {\n+                // Something else happened - e.g. `rustfmt` is missing or caught a signal\n+                Err(LspError::new(\n+                    -32900,\n+                    format!(\n+                        r#\"rustfmt exited with:\n+                           Status: {}\n+                           stdout: {captured_stdout}\n+                           stderr: {captured_stderr}\"#,\n+                        output.status,\n+                    ),\n+                )\n+                .into())\n+            }\n+        };\n+    }\n+\n+    let (new_text, new_line_endings) = LineEndings::normalize(captured_stdout);\n+\n+    if line_index.endings != new_line_endings {\n+        // If line endings are different, send the entire file.\n+        // Diffing would not work here, as the line endings might be the only\n+        // difference.\n+        Ok(Some(to_proto::text_edit_vec(\n+            &line_index,\n+            TextEdit::replace(TextRange::up_to(TextSize::of(&*file)), new_text),\n+        )))\n+    } else if *file == new_text {\n+        // The document is already formatted correctly -- no edits needed.\n+        Ok(None)\n+    } else {\n+        Ok(Some(to_proto::text_edit_vec(&line_index, diff(&file, &new_text))))\n+    }\n+}"}, {"sha": "dc0ea0b17e0945bc12f33795da928c184a7511df", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 20, "deletions": 283, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=98e76bd90f81a0f0c94854c26ae2d9d36e8f88dc", "patch": "@@ -2,7 +2,6 @@\n //! requests/replies and notifications back to the client.\n use std::{\n     fmt,\n-    ops::Deref,\n     sync::Arc,\n     time::{Duration, Instant},\n };\n@@ -11,20 +10,18 @@ use always_assert::always;\n use crossbeam_channel::{select, Receiver};\n use flycheck::FlycheckHandle;\n use ide_db::base_db::{SourceDatabaseExt, VfsPath};\n-use itertools::Itertools;\n use lsp_server::{Connection, Notification, Request};\n use lsp_types::notification::Notification as _;\n-use vfs::{AbsPathBuf, ChangeKind, FileId};\n+use vfs::FileId;\n \n use crate::{\n     config::Config,\n     dispatch::{NotificationDispatcher, RequestDispatcher},\n     from_proto,\n     global_state::{file_id_to_url, url_to_file_id, GlobalState},\n-    handlers, lsp_ext,\n-    lsp_utils::{apply_document_changes, notification_is, Progress},\n-    mem_docs::DocumentData,\n-    reload::{self, BuildDataProgress, ProcMacroProgress, ProjectWorkspaceProgress},\n+    lsp_ext,\n+    lsp_utils::{notification_is, Progress},\n+    reload::{BuildDataProgress, ProcMacroProgress, ProjectWorkspaceProgress},\n     Result,\n };\n \n@@ -652,6 +649,8 @@ impl GlobalState {\n             _ => (),\n         }\n \n+        use crate::handlers::request as handlers;\n+\n         dispatcher\n             .on_sync_mut::<lsp_ext::ReloadWorkspace>(handlers::handle_workspace_reload)\n             .on_sync_mut::<lsp_ext::RebuildProcMacros>(handlers::handle_proc_macros_rebuild)\n@@ -723,284 +722,22 @@ impl GlobalState {\n \n     /// Handles an incoming notification.\n     fn on_notification(&mut self, not: Notification) -> Result<()> {\n-        // FIXME: Move these implementations out into a module similar to on_request\n-        fn run_flycheck(this: &mut GlobalState, vfs_path: VfsPath) -> bool {\n-            let file_id = this.vfs.read().0.file_id(&vfs_path);\n-            if let Some(file_id) = file_id {\n-                let world = this.snapshot();\n-                let mut updated = false;\n-                let task = move || -> std::result::Result<(), ide::Cancelled> {\n-                    // Trigger flychecks for all workspaces that depend on the saved file\n-                    // Crates containing or depending on the saved file\n-                    let crate_ids: Vec<_> = world\n-                        .analysis\n-                        .crates_for(file_id)?\n-                        .into_iter()\n-                        .flat_map(|id| world.analysis.transitive_rev_deps(id))\n-                        .flatten()\n-                        .sorted()\n-                        .unique()\n-                        .collect();\n-\n-                    let crate_root_paths: Vec<_> = crate_ids\n-                        .iter()\n-                        .filter_map(|&crate_id| {\n-                            world\n-                                .analysis\n-                                .crate_root(crate_id)\n-                                .map(|file_id| {\n-                                    world\n-                                        .file_id_to_file_path(file_id)\n-                                        .as_path()\n-                                        .map(ToOwned::to_owned)\n-                                })\n-                                .transpose()\n-                        })\n-                        .collect::<ide::Cancellable<_>>()?;\n-                    let crate_root_paths: Vec<_> =\n-                        crate_root_paths.iter().map(Deref::deref).collect();\n-\n-                    // Find all workspaces that have at least one target containing the saved file\n-                    let workspace_ids =\n-                        world.workspaces.iter().enumerate().filter(|(_, ws)| match ws {\n-                            project_model::ProjectWorkspace::Cargo { cargo, .. } => {\n-                                cargo.packages().any(|pkg| {\n-                                    cargo[pkg].targets.iter().any(|&it| {\n-                                        crate_root_paths.contains(&cargo[it].root.as_path())\n-                                    })\n-                                })\n-                            }\n-                            project_model::ProjectWorkspace::Json { project, .. } => project\n-                                .crates()\n-                                .any(|(c, _)| crate_ids.iter().any(|&crate_id| crate_id == c)),\n-                            project_model::ProjectWorkspace::DetachedFiles { .. } => false,\n-                        });\n-\n-                    // Find and trigger corresponding flychecks\n-                    for flycheck in world.flycheck.iter() {\n-                        for (id, _) in workspace_ids.clone() {\n-                            if id == flycheck.id() {\n-                                updated = true;\n-                                flycheck.restart();\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                    // No specific flycheck was triggered, so let's trigger all of them.\n-                    if !updated {\n-                        for flycheck in world.flycheck.iter() {\n-                            flycheck.restart();\n-                        }\n-                    }\n-                    Ok(())\n-                };\n-                this.task_pool.handle.spawn_with_sender(move |_| {\n-                    if let Err(e) = std::panic::catch_unwind(task) {\n-                        tracing::error!(\"flycheck task panicked: {e:?}\")\n-                    }\n-                });\n-                true\n-            } else {\n-                false\n-            }\n-        }\n+        use crate::handlers::notification as handlers;\n+        use lsp_types::notification as notifs;\n \n         NotificationDispatcher { not: Some(not), global_state: self }\n-            .on::<lsp_types::notification::Cancel>(|this, params| {\n-                let id: lsp_server::RequestId = match params.id {\n-                    lsp_types::NumberOrString::Number(id) => id.into(),\n-                    lsp_types::NumberOrString::String(id) => id.into(),\n-                };\n-                this.cancel(id);\n-                Ok(())\n-            })?\n-            .on::<lsp_types::notification::WorkDoneProgressCancel>(|this, params| {\n-                if let lsp_types::NumberOrString::String(s) = &params.token {\n-                    if let Some(id) = s.strip_prefix(\"rust-analyzer/flycheck/\") {\n-                        if let Ok(id) = u32::from_str_radix(id, 10) {\n-                            if let Some(flycheck) = this.flycheck.get(id as usize) {\n-                                flycheck.cancel();\n-                            }\n-                        }\n-                    }\n-                }\n-                // Just ignore this. It is OK to continue sending progress\n-                // notifications for this token, as the client can't know when\n-                // we accepted notification.\n-                Ok(())\n-            })?\n-            .on::<lsp_types::notification::DidOpenTextDocument>(|this, params| {\n-                if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    let already_exists = this\n-                        .mem_docs\n-                        .insert(path.clone(), DocumentData::new(params.text_document.version))\n-                        .is_err();\n-                    if already_exists {\n-                        tracing::error!(\"duplicate DidOpenTextDocument: {}\", path);\n-                    }\n-                    this.vfs\n-                        .write()\n-                        .0\n-                        .set_file_contents(path, Some(params.text_document.text.into_bytes()));\n-                }\n-                Ok(())\n-            })?\n+            .on::<notifs::Cancel>(handlers::handle_cancel)?\n+            .on::<notifs::WorkDoneProgressCancel>(handlers::handle_work_done_progress_cancel)?\n+            .on::<notifs::DidOpenTextDocument>(handlers::handle_did_open_text_document)?\n+            .on::<notifs::DidChangeTextDocument>(handlers::handle_did_change_text_document)?\n+            .on::<notifs::DidCloseTextDocument>(handlers::handle_did_close_text_document)?\n+            .on::<notifs::DidSaveTextDocument>(handlers::handle_did_save_text_document)?\n+            .on::<notifs::DidChangeConfiguration>(handlers::handle_did_change_configuration)?\n+            .on::<notifs::DidChangeWorkspaceFolders>(handlers::handle_did_change_workspace_folders)?\n+            .on::<notifs::DidChangeWatchedFiles>(handlers::handle_did_change_watched_files)?\n             .on::<lsp_ext::CancelFlycheck>(handlers::handle_cancel_flycheck)?\n-            .on::<lsp_types::notification::DidChangeTextDocument>(|this, params| {\n-                if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    match this.mem_docs.get_mut(&path) {\n-                        Some(doc) => {\n-                            // The version passed in DidChangeTextDocument is the version after all edits are applied\n-                            // so we should apply it before the vfs is notified.\n-                            doc.version = params.text_document.version;\n-                        }\n-                        None => {\n-                            tracing::error!(\"unexpected DidChangeTextDocument: {}\", path);\n-                            return Ok(());\n-                        }\n-                    };\n-\n-                    let vfs = &mut this.vfs.write().0;\n-                    let file_id = vfs.file_id(&path).unwrap();\n-                    let text = apply_document_changes(\n-                        this.config.position_encoding(),\n-                        || std::str::from_utf8(vfs.file_contents(file_id)).unwrap().into(),\n-                        params.content_changes,\n-                    );\n-\n-                    vfs.set_file_contents(path, Some(text.into_bytes()));\n-                }\n-                Ok(())\n-            })?\n-            .on::<lsp_types::notification::DidCloseTextDocument>(|this, params| {\n-                if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    if this.mem_docs.remove(&path).is_err() {\n-                        tracing::error!(\"orphan DidCloseTextDocument: {}\", path);\n-                    }\n-\n-                    this.semantic_tokens_cache.lock().remove(&params.text_document.uri);\n-\n-                    if let Some(path) = path.as_path() {\n-                        this.loader.handle.invalidate(path.to_path_buf());\n-                    }\n-                }\n-                Ok(())\n-            })?\n-            .on::<lsp_ext::ClearFlycheck>(|this, ()| {\n-                this.diagnostics.clear_check_all();\n-                Ok(())\n-            })?\n-            .on::<lsp_ext::RunFlycheck>(|this, params| {\n-                if let Some(text_document) = params.text_document {\n-                    if let Ok(vfs_path) = from_proto::vfs_path(&text_document.uri) {\n-                        if run_flycheck(this, vfs_path) {\n-                            return Ok(());\n-                        }\n-                    }\n-                }\n-                // No specific flycheck was triggered, so let's trigger all of them.\n-                for flycheck in this.flycheck.iter() {\n-                    flycheck.restart();\n-                }\n-                Ok(())\n-            })?\n-            .on::<lsp_types::notification::DidSaveTextDocument>(|this, params| {\n-                if let Ok(vfs_path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    // Re-fetch workspaces if a workspace related file has changed\n-                    if let Some(abs_path) = vfs_path.as_path() {\n-                        if reload::should_refresh_for_change(abs_path, ChangeKind::Modify) {\n-                            this.fetch_workspaces_queue.request_op(\n-                                format!(\"DidSaveTextDocument {}\", abs_path.display()),\n-                                (),\n-                            );\n-                        }\n-                    }\n-\n-                    if !this.config.check_on_save() || run_flycheck(this, vfs_path) {\n-                        return Ok(());\n-                    }\n-                } else if this.config.check_on_save() {\n-                    // No specific flycheck was triggered, so let's trigger all of them.\n-                    for flycheck in this.flycheck.iter() {\n-                        flycheck.restart();\n-                    }\n-                }\n-                Ok(())\n-            })?\n-            .on::<lsp_types::notification::DidChangeConfiguration>(|this, _params| {\n-                // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n-                // this notification's parameters should be ignored and the actual config queried separately.\n-                this.send_request::<lsp_types::request::WorkspaceConfiguration>(\n-                    lsp_types::ConfigurationParams {\n-                        items: vec![lsp_types::ConfigurationItem {\n-                            scope_uri: None,\n-                            section: Some(\"rust-analyzer\".to_string()),\n-                        }],\n-                    },\n-                    |this, resp| {\n-                        tracing::debug!(\"config update response: '{:?}\", resp);\n-                        let lsp_server::Response { error, result, .. } = resp;\n-\n-                        match (error, result) {\n-                            (Some(err), _) => {\n-                                tracing::error!(\"failed to fetch the server settings: {:?}\", err)\n-                            }\n-                            (None, Some(mut configs)) => {\n-                                if let Some(json) = configs.get_mut(0) {\n-                                    // Note that json can be null according to the spec if the client can't\n-                                    // provide a configuration. This is handled in Config::update below.\n-                                    let mut config = Config::clone(&*this.config);\n-                                    if let Err(error) = config.update(json.take()) {\n-                                        this.show_message(\n-                                            lsp_types::MessageType::WARNING,\n-                                            error.to_string(),\n-                                            false,\n-                                        );\n-                                    }\n-                                    this.update_configuration(config);\n-                                }\n-                            }\n-                            (None, None) => tracing::error!(\n-                                \"received empty server settings response from the client\"\n-                            ),\n-                        }\n-                    },\n-                );\n-\n-                Ok(())\n-            })?\n-            .on::<lsp_types::notification::DidChangeWorkspaceFolders>(|this, params| {\n-                let config = Arc::make_mut(&mut this.config);\n-\n-                for workspace in params.event.removed {\n-                    let Ok(path) = workspace.uri.to_file_path() else { continue };\n-                    let Ok(path) = AbsPathBuf::try_from(path) else { continue };\n-                    config.remove_workspace(&path);\n-                }\n-\n-                let added = params\n-                    .event\n-                    .added\n-                    .into_iter()\n-                    .filter_map(|it| it.uri.to_file_path().ok())\n-                    .filter_map(|it| AbsPathBuf::try_from(it).ok());\n-                config.add_workspaces(added);\n-                if !config.has_linked_projects() && config.detached_files().is_empty() {\n-                    config.rediscover_workspaces();\n-                    this.fetch_workspaces_queue\n-                        .request_op(\"client workspaces changed\".to_string(), ())\n-                }\n-\n-                Ok(())\n-            })?\n-            .on::<lsp_types::notification::DidChangeWatchedFiles>(|this, params| {\n-                for change in params.changes {\n-                    if let Ok(path) = from_proto::abs_path(&change.uri) {\n-                        this.loader.handle.invalidate(path);\n-                    }\n-                }\n-                Ok(())\n-            })?\n+            .on::<lsp_ext::ClearFlycheck>(handlers::handle_clear_flycheck)?\n+            .on::<lsp_ext::RunFlycheck>(handlers::handle_run_flycheck)?\n             .finish();\n         Ok(())\n     }\n@@ -1029,7 +766,7 @@ impl GlobalState {\n             let diagnostics = subscriptions\n                 .into_iter()\n                 .filter_map(|file_id| {\n-                    handlers::publish_diagnostics(&snapshot, file_id)\n+                    crate::handlers::publish_diagnostics(&snapshot, file_id)\n                         .ok()\n                         .map(|diags| (file_id, diags))\n                 })"}]}