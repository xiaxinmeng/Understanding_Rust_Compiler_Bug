{"sha": "914e1f456415eae0ae095dd39dc51c115c1ffb5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNGUxZjQ1NjQxNWVhZTBhZTA5NWRkMzlkYzUxYzExNWMxZmZiNWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-19T16:30:44Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-19T18:59:33Z"}, "message": "glue tokens when building token stream", "tree": {"sha": "9d9ae8aec35689ca0625e251ad035bac410a9bca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d9ae8aec35689ca0625e251ad035bac410a9bca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/914e1f456415eae0ae095dd39dc51c115c1ffb5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/914e1f456415eae0ae095dd39dc51c115c1ffb5a", "html_url": "https://github.com/rust-lang/rust/commit/914e1f456415eae0ae095dd39dc51c115c1ffb5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/914e1f456415eae0ae095dd39dc51c115c1ffb5a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b932dfda77f8a48f0d134c31c4b33382724a69c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b932dfda77f8a48f0d134c31c4b33382724a69c", "html_url": "https://github.com/rust-lang/rust/commit/8b932dfda77f8a48f0d134c31c4b33382724a69c"}], "stats": {"total": 44, "additions": 34, "deletions": 10}, "files": [{"sha": "e5ba7e45309dda964ca6e42699720070e00a49b6", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/914e1f456415eae0ae095dd39dc51c115c1ffb5a/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914e1f456415eae0ae095dd39dc51c115c1ffb5a/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=914e1f456415eae0ae095dd39dc51c115c1ffb5a", "patch": "@@ -39,29 +39,29 @@ struct TokenTreesReader<'a> {\n impl<'a> TokenTreesReader<'a> {\n     // Parse a stream of tokens into a list of `TokenTree`s, up to an `Eof`.\n     fn parse_all_token_trees(&mut self) -> PResult<'a, TokenStream> {\n-        let mut tts = Vec::new();\n+        let mut buf = TokenStreamBuilder::default();\n \n         self.real_token();\n         while self.token != token::Eof {\n-            tts.push(self.parse_token_tree()?);\n+            buf.push(self.parse_token_tree()?);\n         }\n \n-        Ok(TokenStream::new(tts))\n+        Ok(buf.into_token_stream())\n     }\n \n     // Parse a stream of tokens into a list of `TokenTree`s, up to a `CloseDelim`.\n     fn parse_token_trees_until_close_delim(&mut self) -> TokenStream {\n-        let mut tts = vec![];\n+        let mut buf = TokenStreamBuilder::default();\n         loop {\n             if let token::CloseDelim(..) = self.token.kind {\n-                return TokenStream::new(tts);\n+                return buf.into_token_stream();\n             }\n \n             match self.parse_token_tree() {\n-                Ok(tree) => tts.push(tree),\n+                Ok(tree) => buf.push(tree),\n                 Err(mut e) => {\n                     e.emit();\n-                    return TokenStream::new(tts);\n+                    return buf.into_token_stream();\n                 }\n             }\n         }\n@@ -223,8 +223,32 @@ impl<'a> TokenTreesReader<'a> {\n                 _ => {\n                     self.token = token;\n                     return;\n-                },\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Default)]\n+struct TokenStreamBuilder {\n+    buf: Vec<TreeAndJoint>,\n+}\n+\n+impl TokenStreamBuilder {\n+    fn push(&mut self, (tree, joint): TreeAndJoint) {\n+        if let Some((TokenTree::Token(prev_token), Joint)) = self.buf.last() {\n+            if let TokenTree::Token(token) = &tree {\n+                if let Some(glued) = prev_token.glue(token) {\n+                    self.buf.pop();\n+                    self.buf.push((TokenTree::Token(glued), joint));\n+                    return;\n+                }\n             }\n         }\n+        self.buf.push((tree, joint))\n+    }\n+\n+    fn into_token_stream(self) -> TokenStream {\n+        TokenStream::new(self.buf)\n     }\n }"}, {"sha": "1865f925165bdaeb64d916d7793991ec215afe5e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/914e1f456415eae0ae095dd39dc51c115c1ffb5a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914e1f456415eae0ae095dd39dc51c115c1ffb5a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=914e1f456415eae0ae095dd39dc51c115c1ffb5a", "patch": "@@ -551,7 +551,7 @@ impl Token {\n         }\n     }\n \n-    crate fn glue(self, joint: Token) -> Option<Token> {\n+    crate fn glue(&self, joint: &Token) -> Option<Token> {\n         let kind = match self.kind {\n             Eq => match joint.kind {\n                 Eq => EqEq,"}, {"sha": "09a1b93c7bb195819e188147ba927e476be3c642", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/914e1f456415eae0ae095dd39dc51c115c1ffb5a/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914e1f456415eae0ae095dd39dc51c115c1ffb5a/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=914e1f456415eae0ae095dd39dc51c115c1ffb5a", "patch": "@@ -414,7 +414,7 @@ impl TokenStreamBuilder {\n         let last_tree_if_joint = self.0.last().and_then(TokenStream::last_tree_if_joint);\n         if let Some(TokenTree::Token(last_token)) = last_tree_if_joint {\n             if let Some((TokenTree::Token(token), is_joint)) = stream.first_tree_and_joint() {\n-                if let Some(glued_tok) = last_token.glue(token) {\n+                if let Some(glued_tok) = last_token.glue(&token) {\n                     let last_stream = self.0.pop().unwrap();\n                     self.push_all_but_last_tree(&last_stream);\n                     let glued_tt = TokenTree::Token(glued_tok);"}]}