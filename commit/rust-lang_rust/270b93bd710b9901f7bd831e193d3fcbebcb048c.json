{"sha": "270b93bd710b9901f7bd831e193d3fcbebcb048c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MGI5M2JkNzEwYjk5MDFmN2JkODMxZTE5M2QzZmNiZWJjYjA0OGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-10T23:02:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-10T23:37:17Z"}, "message": "rustc: Move refcount decrement-and-free (drop) logic out-of-line", "tree": {"sha": "b2f7dc9e4041ead0f8e27239bcfe9ba5684f0f2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2f7dc9e4041ead0f8e27239bcfe9ba5684f0f2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/270b93bd710b9901f7bd831e193d3fcbebcb048c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/270b93bd710b9901f7bd831e193d3fcbebcb048c", "html_url": "https://github.com/rust-lang/rust/commit/270b93bd710b9901f7bd831e193d3fcbebcb048c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/270b93bd710b9901f7bd831e193d3fcbebcb048c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10d5d32537c6c0a7c5ca67c6a29b998985c822d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/10d5d32537c6c0a7c5ca67c6a29b998985c822d3", "html_url": "https://github.com/rust-lang/rust/commit/10d5d32537c6c0a7c5ca67c6a29b998985c822d3"}], "stats": {"total": 179, "additions": 124, "deletions": 55}, "files": [{"sha": "2dce726adf9cd2bfd5a0776cdac650bdfae0d188", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 124, "deletions": 55, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/270b93bd710b9901f7bd831e193d3fcbebcb048c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270b93bd710b9901f7bd831e193d3fcbebcb048c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=270b93bd710b9901f7bd831e193d3fcbebcb048c", "patch": "@@ -3,6 +3,7 @@ import std._uint;\n import std._vec;\n import std._str.rustrt.sbuf;\n import std._vec.rustrt.vbuf;\n+import std.map;\n import std.map.hashmap;\n import std.option;\n import std.option.some;\n@@ -53,6 +54,8 @@ type tag_info = rec(type_handle th,\n                     mutable vec[tup(ast.def_id,arity)] variants,\n                     mutable uint size);\n \n+type ty_info = rec(ValueRef drop_glue);\n+\n state type crate_ctxt = rec(session.session sess,\n                             ModuleRef llmod,\n                             target_data td,\n@@ -62,6 +65,7 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ast.def_id, ValueRef] item_ids,\n                             hashmap[ast.def_id, @ast.item] items,\n                             hashmap[ast.def_id, @tag_info] tags,\n+                            hashmap[@typeck.ty, @ty_info] types,\n                             @glue_fns glues,\n                             namegen names,\n                             str path);\n@@ -336,6 +340,22 @@ fn type_of_arg(@crate_ctxt cx, &typeck.arg arg) -> TypeRef {\n     ret ty;\n }\n \n+// Name sanitation. LLVM will happily accept identifiers with weird names, but\n+// gas doesn't!\n+\n+fn sanitize(str s) -> str {\n+    auto result = \"\";\n+    for (u8 c in s) {\n+        if (c == ('@' as u8)) {\n+            result += \"boxed_\";\n+        } else {\n+            auto v = vec(c);\n+            result += _str.from_bytes(v);\n+        }\n+    }\n+    ret result;\n+}\n+\n // LLVM constant constructors.\n \n fn C_null(TypeRef t) -> ValueRef {\n@@ -519,6 +539,102 @@ fn incr_refcnt(@block_ctxt cx, ValueRef box_ptr) -> result {\n     ret res(next_cx, C_nil());\n }\n \n+// Glue and referent count twiddling\n+\n+fn get_ty_info(@crate_ctxt cx, @typeck.ty ty) -> @ty_info {\n+    if (!cx.types.contains_key(ty)) {\n+        make_ty_info(cx, ty);\n+    }\n+    ret cx.types.get(ty);\n+}\n+\n+fn make_ty_info(@crate_ctxt cx, @typeck.ty ty) {\n+    cx.types.insert(ty, @rec(drop_glue=make_drop_glue(cx, ty)));\n+}\n+\n+fn make_drop_glue(@crate_ctxt cx, @typeck.ty t) -> ValueRef {\n+    auto arg_t;\n+    if (typeck.type_is_structural(t)) {\n+        arg_t = T_ptr(type_of(cx, t));\n+    } else {\n+        arg_t = type_of(cx, t);\n+    }\n+    auto llfnty = T_fn(vec(T_taskptr(), arg_t), T_void());\n+\n+    auto fn_name = cx.names.next(\"_rust_drop\") + \".\" + typeck.ty_to_str(t);\n+    fn_name = sanitize(fn_name);\n+    auto llfn = decl_fastcall_fn(cx.llmod, fn_name, llfnty);\n+\n+    auto fcx = new_fn_ctxt(cx, fn_name, llfn);\n+    auto bcx = new_top_block_ctxt(fcx);\n+\n+    auto llval = llvm.LLVMGetParam(llfn, 1u);\n+    auto res = make_drop_glue_inner(bcx, llval, t);\n+\n+    res.bcx.build.RetVoid();\n+\n+    ret llfn;\n+}\n+\n+fn make_drop_glue_inner(@block_ctxt cx, ValueRef v, @typeck.ty t) -> result {\n+    alt (t.struct) {\n+        case (typeck.ty_str) {\n+            ret decr_refcnt_and_if_zero(cx, v,\n+                                        bind trans_non_gc_free(_, v),\n+                                        \"free string\",\n+                                        T_int(), C_int(0));\n+        }\n+\n+        case (typeck.ty_vec(_)) {\n+            fn hit_zero(@block_ctxt cx, ValueRef v,\n+                        @typeck.ty t) -> result {\n+                auto res = iter_sequence(cx, v, t, bind drop_ty(_,_,_));\n+                // FIXME: switch gc/non-gc on layer of the type.\n+                ret trans_non_gc_free(res.bcx, v);\n+            }\n+            ret decr_refcnt_and_if_zero(cx, v,\n+                                        bind hit_zero(_, v, t),\n+                                        \"free vector\",\n+                                        T_int(), C_int(0));\n+        }\n+\n+        case (typeck.ty_box(?body_ty)) {\n+            fn hit_zero(@block_ctxt cx, ValueRef v,\n+                        @typeck.ty body_ty) -> result {\n+                auto body = cx.build.GEP(v,\n+                                         vec(C_int(0),\n+                                             C_int(abi.box_rc_field_body)));\n+\n+                auto body_val = load_non_structural(cx, body, body_ty);\n+                auto res = drop_ty(cx, body_val, body_ty);\n+                // FIXME: switch gc/non-gc on layer of the type.\n+                ret trans_non_gc_free(res.bcx, v);\n+            }\n+            ret decr_refcnt_and_if_zero(cx, v,\n+                                        bind hit_zero(_, v, body_ty),\n+                                        \"free box\",\n+                                        T_int(), C_int(0));\n+        }\n+\n+        case (_) {\n+            if (typeck.type_is_structural(t)) {\n+                ret iter_structural_ty(cx, v, t,\n+                                       bind drop_ty(_, _, _));\n+\n+            } else if (typeck.type_is_binding(t)) {\n+                cx.fcx.ccx.sess.unimpl(\"binding type in \" +\n+                                       \"trans.make_drop_glue_inner\");\n+\n+            } else if (typeck.type_is_scalar(t) ||\n+                       typeck.type_is_nil(t)) {\n+                ret res(cx, C_nil());\n+            }\n+        }\n+    }\n+    cx.fcx.ccx.sess.bug(\"bad type in trans.make_drop_glue_inner\");\n+    fail;\n+}\n+\n fn decr_refcnt_and_if_zero(@block_ctxt cx,\n                            ValueRef box_ptr,\n                            fn(@block_ctxt cx) -> result inner,\n@@ -777,61 +893,9 @@ fn drop_slot(@block_ctxt cx,\n fn drop_ty(@block_ctxt cx,\n            ValueRef v,\n            @typeck.ty t) -> result {\n-\n-    alt (t.struct) {\n-        case (typeck.ty_str) {\n-            ret decr_refcnt_and_if_zero(cx, v,\n-                                        bind trans_non_gc_free(_, v),\n-                                        \"free string\",\n-                                        T_int(), C_int(0));\n-        }\n-\n-        case (typeck.ty_vec(_)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v,\n-                        @typeck.ty t) -> result {\n-                auto res = iter_sequence(cx, v, t, bind drop_ty(_,_,_));\n-                // FIXME: switch gc/non-gc on layer of the type.\n-                ret trans_non_gc_free(res.bcx, v);\n-            }\n-            ret decr_refcnt_and_if_zero(cx, v,\n-                                        bind hit_zero(_, v, t),\n-                                        \"free vector\",\n-                                        T_int(), C_int(0));\n-        }\n-\n-        case (typeck.ty_box(?body_ty)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v,\n-                        @typeck.ty body_ty) -> result {\n-                auto body = cx.build.GEP(v,\n-                                         vec(C_int(0),\n-                                             C_int(abi.box_rc_field_body)));\n-\n-                auto res = drop_ty(cx, body, body_ty);\n-                // FIXME: switch gc/non-gc on layer of the type.\n-                ret trans_non_gc_free(res.bcx, v);\n-            }\n-            ret decr_refcnt_and_if_zero(cx, v,\n-                                        bind hit_zero(_, v, body_ty),\n-                                        \"free box\",\n-                                        T_int(), C_int(0));\n-        }\n-\n-        case (_) {\n-            if (typeck.type_is_structural(t)) {\n-                ret iter_structural_ty(cx, v, t,\n-                                       bind drop_ty(_, _, _));\n-\n-            } else if (typeck.type_is_binding(t)) {\n-                cx.fcx.ccx.sess.unimpl(\"binding type in trans.drop_ty\");\n-\n-            } else if (typeck.type_is_scalar(t) ||\n-                       typeck.type_is_nil(t)) {\n-                ret res(cx, C_nil());\n-            }\n-        }\n-    }\n-    cx.fcx.ccx.sess.bug(\"bad type in trans.drop_ty\");\n-    fail;\n+    cx.build.FastCall(get_ty_info(cx.fcx.ccx, t).drop_glue,\n+                      vec(cx.fcx.lltaskptr, v));\n+    ret res(cx, C_nil());\n }\n \n fn build_memcpy(@block_ctxt cx,\n@@ -2329,6 +2393,10 @@ fn trans_crate(session.session sess, @ast.crate crate, str output) {\n                       _vec.init_fn[ValueRef](bind decl_upcall(llmod, _),\n                                              abi.n_upcall_glues as uint));\n \n+    auto hasher = typeck.hash_ty;\n+    auto eqer = typeck.eq_ty;\n+    auto types = map.mk_hashmap[@typeck.ty,@ty_info](hasher, eqer);\n+\n     auto cx = @rec(sess = sess,\n                    llmod = llmod,\n                    td = td,\n@@ -2338,6 +2406,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output) {\n                    item_ids = new_def_hash[ValueRef](),\n                    items = new_def_hash[@ast.item](),\n                    tags = new_def_hash[@tag_info](),\n+                   types = types,\n                    glues = glues,\n                    names = namegen(0),\n                    path = \"_rust\");"}]}