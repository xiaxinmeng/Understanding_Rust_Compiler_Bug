{"sha": "582614fbbe76fed1b06feb640229b71a1886ffd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MjYxNGZiYmU3NmZlZDFiMDZmZWI2NDAyMjliNzFhMTg4NmZmZDc=", "commit": {"author": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-04-27T07:44:44Z"}, "committer": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-04-27T07:44:44Z"}, "message": "Extract building the suggestion of `manual_memcpy`", "tree": {"sha": "b1ecdb968e49beb82f8684c0cc18e79aa68f491d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1ecdb968e49beb82f8684c0cc18e79aa68f491d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/582614fbbe76fed1b06feb640229b71a1886ffd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/582614fbbe76fed1b06feb640229b71a1886ffd7", "html_url": "https://github.com/rust-lang/rust/commit/582614fbbe76fed1b06feb640229b71a1886ffd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/582614fbbe76fed1b06feb640229b71a1886ffd7/comments", "author": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fc6f37778789de94caa280f41afdf651bf5ae10", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fc6f37778789de94caa280f41afdf651bf5ae10", "html_url": "https://github.com/rust-lang/rust/commit/9fc6f37778789de94caa280f41afdf651bf5ae10"}], "stats": {"total": 154, "additions": 80, "deletions": 74}, "files": [{"sha": "7cf3e16bef9b8b91fde9d2b599c4ee202baed8e2", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 80, "deletions": 74, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/582614fbbe76fed1b06feb640229b71a1886ffd7/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582614fbbe76fed1b06feb640229b71a1886ffd7/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=582614fbbe76fed1b06feb640229b71a1886ffd7", "patch": "@@ -905,6 +905,85 @@ fn get_assignments<'a, 'tcx>(\n     iter_a.into_iter().flatten().chain(iter_b.into_iter())\n }\n \n+fn build_manual_memcpy_suggestion<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    start: &Expr<'_>,\n+    end: &Expr<'_>,\n+    limits: ast::RangeLimits,\n+    dst_var: FixedOffsetVar<'_>,\n+    src_var: FixedOffsetVar<'_>,\n+) -> String {\n+    fn print_sum(arg1: &str, arg2: &Offset) -> String {\n+        match (arg1, &arg2.value[..], arg2.sign) {\n+            (\"0\", \"0\", _) => \"0\".into(),\n+            (\"0\", x, OffsetSign::Positive) | (x, \"0\", _) => x.into(),\n+            (\"0\", x, OffsetSign::Negative) => format!(\"-{}\", x),\n+            (x, y, OffsetSign::Positive) => format!(\"({} + {})\", x, y),\n+            (x, y, OffsetSign::Negative) => {\n+                if x == y {\n+                    \"0\".into()\n+                } else {\n+                    format!(\"({} - {})\", x, y)\n+                }\n+            },\n+        }\n+    }\n+\n+    fn print_offset(start_str: &str, inline_offset: &Offset) -> String {\n+        let offset = print_sum(start_str, inline_offset);\n+        if offset.as_str() == \"0\" {\n+            \"\".into()\n+        } else {\n+            offset\n+        }\n+    }\n+\n+    let print_limit = |end: &Expr<'_>, offset: Offset, var: &Expr<'_>| {\n+        if_chain! {\n+            if let ExprKind::MethodCall(method, _, len_args) = end.kind;\n+            if method.ident.name == sym!(len);\n+            if len_args.len() == 1;\n+            if let Some(arg) = len_args.get(0);\n+            if var_def_id(cx, arg) == var_def_id(cx, var);\n+            then {\n+                match offset.sign {\n+                    OffsetSign::Negative => format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value),\n+                    OffsetSign::Positive => \"\".into(),\n+                }\n+            } else {\n+                let end_str = match limits {\n+                    ast::RangeLimits::Closed => {\n+                        let end = sugg::Sugg::hir(cx, end, \"<count>\");\n+                        format!(\"{}\", end + sugg::ONE)\n+                    },\n+                    ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n+                };\n+\n+                print_sum(&end_str, &offset)\n+            }\n+        }\n+    };\n+\n+    let start_str = snippet(cx, start.span, \"\").to_string();\n+    let dst_offset = print_offset(&start_str, &dst_var.offset);\n+    let dst_limit = print_limit(end, dst_var.offset, dst_var.var);\n+    let src_offset = print_offset(&start_str, &src_var.offset);\n+    let src_limit = print_limit(end, src_var.offset, src_var.var);\n+\n+    let dst_var_name = snippet_opt(cx, dst_var.var.span).unwrap_or_else(|| \"???\".into());\n+    let src_var_name = snippet_opt(cx, src_var.var.span).unwrap_or_else(|| \"???\".into());\n+\n+    let dst = if dst_offset == \"\" && dst_limit == \"\" {\n+        dst_var_name\n+    } else {\n+        format!(\"{}[{}..{}]\", dst_var_name, dst_offset, dst_limit)\n+    };\n+\n+    format!(\n+        \"{}.clone_from_slice(&{}[{}..{}])\",\n+        dst, src_var_name, src_offset, src_limit\n+    )\n+}\n /// Checks for for loops that sequentially copy items from one slice-like\n /// object to another.\n fn detect_manual_memcpy<'a, 'tcx>(\n@@ -922,57 +1001,6 @@ fn detect_manual_memcpy<'a, 'tcx>(\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n-            fn print_sum(arg1: &str, arg2: &Offset) -> String {\n-                match (arg1, &arg2.value[..], arg2.sign) {\n-                    (\"0\", \"0\", _) => \"0\".into(),\n-                    (\"0\", x, OffsetSign::Positive) | (x, \"0\", _) => x.into(),\n-                    (\"0\", x, OffsetSign::Negative) => format!(\"-{}\", x),\n-                    (x, y, OffsetSign::Positive) => format!(\"({} + {})\", x, y),\n-                    (x, y, OffsetSign::Negative) => {\n-                        if x == y {\n-                            \"0\".into()\n-                        } else {\n-                            format!(\"({} - {})\", x, y)\n-                        }\n-                    },\n-                }\n-            }\n-\n-            fn print_offset(start_str: &str, inline_offset: &Offset) -> String {\n-                let offset = print_sum(start_str, inline_offset);\n-                if offset.as_str() == \"0\" {\n-                    \"\".into()\n-                } else {\n-                    offset\n-                }\n-            }\n-\n-            let print_limit = |end: &Expr<'_>, offset: Offset, var: &Expr<'_>| {\n-                if_chain! {\n-                    if let ExprKind::MethodCall(method, _, len_args) = end.kind;\n-                    if method.ident.name == sym!(len);\n-                    if len_args.len() == 1;\n-                    if let Some(arg) = len_args.get(0);\n-                    if var_def_id(cx, arg) == var_def_id(cx, var);\n-                    then {\n-                        match offset.sign {\n-                            OffsetSign::Negative => format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value),\n-                            OffsetSign::Positive => \"\".into(),\n-                        }\n-                    } else {\n-                        let end_str = match limits {\n-                            ast::RangeLimits::Closed => {\n-                                let end = sugg::Sugg::hir(cx, end, \"<count>\");\n-                                format!(\"{}\", end + sugg::ONE)\n-                            },\n-                            ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n-                        };\n-\n-                        print_sum(&end_str, &offset)\n-                    }\n-                }\n-            };\n-\n             // The only statements in the for loops can be indexed assignments from\n             // indexed retrievals.\n             let big_sugg = get_assignments(body)\n@@ -998,29 +1026,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n                         }\n                     })\n                 })\n-                .map(|o| {\n-                    o.map(|(dst_var, src_var)| {\n-                        let start_str = snippet(cx, start.span, \"\").to_string();\n-                        let dst_offset = print_offset(&start_str, &dst_var.offset);\n-                        let dst_limit = print_limit(end, dst_var.offset, dst_var.var);\n-                        let src_offset = print_offset(&start_str, &src_var.offset);\n-                        let src_limit = print_limit(end, src_var.offset, src_var.var);\n-\n-                        let dst_var_name = snippet_opt(cx, dst_var.var.span).unwrap_or_else(|| \"???\".into());\n-                        let src_var_name = snippet_opt(cx, src_var.var.span).unwrap_or_else(|| \"???\".into());\n-\n-                        let dst = if dst_offset == \"\" && dst_limit == \"\" {\n-                            dst_var_name\n-                        } else {\n-                            format!(\"{}[{}..{}]\", dst_var_name, dst_offset, dst_limit)\n-                        };\n-\n-                        format!(\n-                            \"{}.clone_from_slice(&{}[{}..{}])\",\n-                            dst, src_var_name, src_offset, src_limit\n-                        )\n-                    })\n-                })\n+                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, dst, src)))\n                 .collect::<Option<Vec<_>>>()\n                 .filter(|v| !v.is_empty())\n                 .map(|v| v.join(\"\\n    \"));"}]}