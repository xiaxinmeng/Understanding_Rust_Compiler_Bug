{"sha": "cc80652e4a627378a36b50fab9e72349129cb56a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjODA2NTJlNGE2MjczNzhhMzZiNTBmYWI5ZTcyMzQ5MTI5Y2I1NmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-12T04:37:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-12T04:37:43Z"}, "message": "auto merge of #7060 : huonw/rust/more-str, r=thestinger\n\nThere are now only half-a-dozen or so functions left `std::str` that should be methods.\r\n\r\nHighlights:\r\n- `.substr` was removed, since most of the uses of it in the code base were actually incorrect (it had a weird mixing of a byte index and a unicode character count), adding `.slice_chars` if one wants to handle characters, and the normal `.slice` method to handle bytes.\r\n- Code duplication between the two impls for `connect` and `concat` was removed via a new `Str` trait, that is purely designed to allow an explicit -> `&str` conversion (`.as_slice()`)\r\n- Deconfuse the 5 different functions for converting to `[u8]` (3 of which had actually incorrect documentation: implying that they didn't have the null terminator), into 3: `as_bytes` (all strings), `as_bytes_with_null` (`&'static str`, `@str` and `~str`) and `as_bytes_with_null_consume` (`~str`). None of these allocate, unlike the old versions.\r\n\r\n(cc @thestinger)", "tree": {"sha": "ada1e23e714b7dc587d86aeddb54a954dded8f3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ada1e23e714b7dc587d86aeddb54a954dded8f3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc80652e4a627378a36b50fab9e72349129cb56a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc80652e4a627378a36b50fab9e72349129cb56a", "html_url": "https://github.com/rust-lang/rust/commit/cc80652e4a627378a36b50fab9e72349129cb56a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc80652e4a627378a36b50fab9e72349129cb56a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7033dfcf917ccef44fbc3e33d31814455c13b4c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7033dfcf917ccef44fbc3e33d31814455c13b4c6", "html_url": "https://github.com/rust-lang/rust/commit/7033dfcf917ccef44fbc3e33d31814455c13b4c6"}, {"sha": "9f0c85acc967110c85f9a8bdcb32df4606a6dff5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f0c85acc967110c85f9a8bdcb32df4606a6dff5", "html_url": "https://github.com/rust-lang/rust/commit/9f0c85acc967110c85f9a8bdcb32df4606a6dff5"}], "stats": {"total": 1611, "additions": 820, "deletions": 791}, "files": [{"sha": "a458036116665354c214f48f46ae181dff3fdc50", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -1410,7 +1410,7 @@ let new_favorite_crayon_name = favorite_crayon_name.trim();\n \n if favorite_crayon_name.len() > 5 {\n    // Create a substring\n-   println(favorite_crayon_name.substr(0, 5));\n+   println(favorite_crayon_name.slice_chars(0, 5));\n }\n ~~~\n "}, {"sha": "c92084781287a6655825ff64c9fed98778ea7516", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -171,8 +171,8 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n         let cr = ~\"\\r\";\n-        actual = str::replace(actual, cr, \"\");\n-        expected = str::replace(expected, cr, \"\");\n+        actual = actual.replace(cr, \"\");\n+        expected = expected.replace(cr, \"\");\n     }\n \n     compare_source(expected, actual);\n@@ -238,7 +238,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     // do not optimize debuginfo tests\n     let mut config = match config.rustcflags {\n         Some(ref flags) => config {\n-            rustcflags: Some(str::replace(*flags, \"-O\", \"\")),\n+            rustcflags: Some(flags.replace(\"-O\", \"\")),\n             .. copy *config\n         },\n         None => copy *config\n@@ -254,7 +254,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     }\n \n     // write debugger script\n-    let script_str = str::append(cmds, \"\\nquit\\n\");\n+    let script_str = cmds.append(\"\\nquit\\n\");\n     debug!(\"script_str = %s\", script_str);\n     dump_output_file(config, testfile, script_str, \"debugger.script\");\n "}, {"sha": "f4754b3e4cbe1c7f0bffbbb8549633060c4fe4d6", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -12,7 +12,6 @@\n \n use core::prelude::*;\n \n-use core::str;\n use core::vec;\n \n /// A trait for converting a value to base64 encoding.\n@@ -111,7 +110,7 @@ impl<'self> ToBase64 for &'self str {\n      *\n      */\n     fn to_base64(&self) -> ~str {\n-        str::to_bytes(*self).to_base64()\n+        self.as_bytes().to_base64()\n     }\n }\n \n@@ -224,7 +223,7 @@ impl<'self> FromBase64 for &'self str {\n      * ~~~\n      */\n     fn from_base64(&self) -> ~[u8] {\n-        str::to_bytes(*self).from_base64()\n+        self.as_bytes().from_base64()\n     }\n }\n \n@@ -245,12 +244,12 @@ mod tests {\n \n     #[test]\n     fn test_from_base64() {\n-        assert_eq!(\"\".from_base64(), str::to_bytes(\"\"));\n-        assert_eq!(\"Zg==\".from_base64(), str::to_bytes(\"f\"));\n-        assert_eq!(\"Zm8=\".from_base64(), str::to_bytes(\"fo\"));\n-        assert_eq!(\"Zm9v\".from_base64(), str::to_bytes(\"foo\"));\n-        assert_eq!(\"Zm9vYg==\".from_base64(), str::to_bytes(\"foob\"));\n-        assert_eq!(\"Zm9vYmE=\".from_base64(), str::to_bytes(\"fooba\"))\n-        assert_eq!(\"Zm9vYmFy\".from_base64(), str::to_bytes(\"foobar\"));\n+        assert_eq!(\"\".from_base64(), \"\".as_bytes().to_owned());\n+        assert_eq!(\"Zg==\".from_base64(), \"f\".as_bytes().to_owned());\n+        assert_eq!(\"Zm8=\".from_base64(), \"fo\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9v\".from_base64(), \"foo\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYg==\".from_base64(), \"foob\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYmE=\".from_base64(), \"fooba\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYmFy\".from_base64(), \"foobar\".as_bytes().to_owned());\n     }\n }"}, {"sha": "dd08f23a7a10f69ad47071bf46978ed4a69bf36a", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -607,7 +607,6 @@ pub mod writer {\n \n     use core::cast;\n     use core::io;\n-    use core::str;\n \n     // ebml writing\n     pub struct Encoder {\n@@ -725,7 +724,7 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_str(&mut self, tag_id: uint, v: &str) {\n-            str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n+            self.wr_tagged_bytes(tag_id, v.as_bytes());\n         }\n \n         pub fn wr_bytes(&mut self, b: &[u8]) {\n@@ -735,7 +734,7 @@ pub mod writer {\n \n         pub fn wr_str(&mut self, s: &str) {\n             debug!(\"Write str: %?\", s);\n-            self.writer.write(str::to_bytes(s));\n+            self.writer.write(s.as_bytes());\n         }\n     }\n "}, {"sha": "345b0e8cff769c381425b167020851e3fe7cd2a9", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -487,7 +487,7 @@ mod test {\n         let mut buf : ~[u8] = vec::from_elem(6, 0u8);\n         let count = fi.read(buf, 10);\n         assert_eq!(count, 6);\n-        assert_eq!(buf, \"0\\n1\\n2\\n\".to_bytes());\n+        assert_eq!(buf, \"0\\n1\\n2\\n\".as_bytes().to_owned());\n         assert!(fi.eof())\n         assert_eq!(fi.state().line_num, 3);\n     }"}, {"sha": "36ffbb731c87d406e774dbde967ca3b9bcf8eecc", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -450,7 +450,7 @@ pub mod flatteners {\n                               T: Decodable<D>>(\n                               buf: &[u8])\n                               -> T {\n-        let buf = vec::to_owned(buf);\n+        let buf = buf.to_owned();\n         let buf_reader = @BufReader::new(buf);\n         let reader = buf_reader as @Reader;\n         let mut deser: D = FromReader::from_reader(reader);"}, {"sha": "9fe81804bd2f4a2e912b77fd395630ce48d4234d", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -345,7 +345,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n         }\n         i += 1;\n     }\n-    return Ok(Matches {opts: vec::to_owned(opts),\n+    return Ok(Matches {opts: opts.to_owned(),\n                vals: vals,\n                free: free});\n }\n@@ -447,7 +447,7 @@ pub fn opt_default(mm: &Matches, nm: &str, def: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vals.is_empty() { return None::<~str>; }\n     return match vals[0] { Val(ref s) => Some::<~str>(copy *s),\n-                           _      => Some::<~str>(str::to_owned(def)) }\n+                           _      => Some::<~str>(def.to_owned()) }\n }\n \n #[deriving(Eq)]\n@@ -487,10 +487,10 @@ pub mod groups {\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup { short_name: str::to_owned(short_name),\n-                long_name: str::to_owned(long_name),\n-                hint: str::to_owned(hint),\n-                desc: str::to_owned(desc),\n+        return OptGroup { short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n+                hint: hint.to_owned(),\n+                desc: desc.to_owned(),\n                 hasarg: Yes,\n                 occur: Req};\n     }\n@@ -500,10 +500,10 @@ pub mod groups {\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: str::to_owned(short_name),\n-                long_name: str::to_owned(long_name),\n-                hint: str::to_owned(hint),\n-                desc: str::to_owned(desc),\n+        return OptGroup {short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n+                hint: hint.to_owned(),\n+                desc: desc.to_owned(),\n                 hasarg: Yes,\n                 occur: Optional};\n     }\n@@ -513,10 +513,10 @@ pub mod groups {\n                    desc: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: str::to_owned(short_name),\n-                long_name: str::to_owned(long_name),\n+        return OptGroup {short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n                 hint: ~\"\",\n-                desc: str::to_owned(desc),\n+                desc: desc.to_owned(),\n                 hasarg: No,\n                 occur: Optional};\n     }\n@@ -526,10 +526,10 @@ pub mod groups {\n                       desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: str::to_owned(short_name),\n-                long_name: str::to_owned(long_name),\n-                hint: str::to_owned(hint),\n-                desc: str::to_owned(desc),\n+        return OptGroup {short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n+                hint: hint.to_owned(),\n+                desc: desc.to_owned(),\n                 hasarg: Maybe,\n                 occur: Optional};\n     }\n@@ -542,10 +542,10 @@ pub mod groups {\n                     desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: str::to_owned(short_name),\n-                long_name: str::to_owned(long_name),\n-                hint: str::to_owned(hint),\n-                desc: str::to_owned(desc),\n+        return OptGroup {short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n+                hint: hint.to_owned(),\n+                desc: desc.to_owned(),\n                 hasarg: Yes,\n                 occur: Multi};\n     }\n@@ -593,7 +593,7 @@ pub mod groups {\n      */\n     pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n-        let desc_sep = ~\"\\n\" + str::repeat(\" \", 24);\n+        let desc_sep = ~\"\\n\" + \" \".repeat(24);\n \n         let rows = vec::map(opts, |optref| {\n             let OptGroup{short_name: short_name,\n@@ -603,7 +603,7 @@ pub mod groups {\n                          hasarg: hasarg,\n                          _} = copy *optref;\n \n-            let mut row = str::repeat(\" \", 4);\n+            let mut row = \" \".repeat(4);\n \n             // short option\n             row += match short_name.len() {\n@@ -629,7 +629,7 @@ pub mod groups {\n             // here we just need to indent the start of the description\n             let rowlen = row.len();\n             row += if rowlen < 24 {\n-                str::repeat(\" \", 24 - rowlen)\n+                \" \".repeat(24 - rowlen)\n             } else {\n                 copy desc_sep\n             };\n@@ -654,7 +654,7 @@ pub mod groups {\n             row\n         });\n \n-        return str::to_owned(brief) +\n+        return brief.to_owned() +\n                \"\\n\\nOptions:\\n\" +\n                rows.connect(\"\\n\") +\n                \"\\n\\n\";"}, {"sha": "94793804bb13839fa29734da11cdf823a6d2426b", "filename": "src/libextra/md4.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -10,7 +10,6 @@\n \n use core::prelude::*;\n \n-use core::str;\n use core::uint;\n use core::vec;\n \n@@ -30,7 +29,7 @@ pub fn md4(msg: &[u8]) -> Quad {\n     let orig_len: u64 = (msg.len() * 8u) as u64;\n \n     // pad message\n-    let mut msg = vec::append(vec::to_owned(msg), [0x80u8]);\n+    let mut msg = vec::append(msg.to_owned(), [0x80u8]);\n     let mut bitlen = orig_len + 8u64;\n     while (bitlen + 64u64) % 512u64 > 0u64 {\n         msg.push(0u8);\n@@ -129,7 +128,7 @@ pub fn md4_str(msg: &[u8]) -> ~str {\n \n /// Calculates the md4 hash of a string, returning the hex-encoded version of\n /// the hash\n-pub fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n+pub fn md4_text(msg: &str) -> ~str { md4_str(msg.as_bytes()) }\n \n #[test]\n fn test_md4() {"}, {"sha": "d95807f2b91c49f9aa523d32b111977748ee6c09", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -1636,7 +1636,7 @@ mod test {\n         assert_eq!(net::ip::get_port(&sock.get_peer_addr()), 8887);\n \n         // Fulfill the protocol the test server expects\n-        let resp_bytes = str::to_bytes(\"ping\");\n+        let resp_bytes = \"ping\".as_bytes().to_owned();\n         tcp_write_single(&sock, resp_bytes);\n         debug!(\"message sent\");\n         sock.read(0u);\n@@ -1756,9 +1756,7 @@ mod test {\n         buf_write(sock_buf, expected_req);\n \n         // so contrived!\n-        let actual_resp = do str::as_bytes(&expected_resp.to_str()) |resp_buf| {\n-            buf_read(sock_buf, resp_buf.len())\n-        };\n+        let actual_resp = buf_read(sock_buf, expected_resp.as_bytes().len());\n \n         let actual_req = server_result_po.recv();\n         debug!(\"REQ: expected: '%s' actual: '%s'\",\n@@ -1810,11 +1808,10 @@ mod test {\n \n     fn buf_write<W:io::Writer>(w: &W, val: &str) {\n         debug!(\"BUF_WRITE: val len %?\", val.len());\n-        do str::byte_slice(val) |b_slice| {\n-            debug!(\"BUF_WRITE: b_slice len %?\",\n-                            b_slice.len());\n-            w.write(b_slice)\n-        }\n+        let b_slice = val.as_bytes();\n+        debug!(\"BUF_WRITE: b_slice len %?\",\n+               b_slice.len());\n+        w.write(b_slice)\n     }\n \n     fn buf_read<R:io::Reader>(r: &R, len: uint) -> ~str {\n@@ -1877,7 +1874,8 @@ mod test {\n                             server_ch.send(\n                                 str::from_bytes(data));\n                             debug!(\"SERVER: before write\");\n-                            tcp_write_single(&sock, str::to_bytes(resp_cell2.take()));\n+                            let s = resp_cell2.take();\n+                            tcp_write_single(&sock, s.as_bytes().to_owned());\n                             debug!(\"SERVER: after write.. die\");\n                             kill_ch.send(None);\n                           }\n@@ -1949,7 +1947,7 @@ mod test {\n         }\n         else {\n             let sock = result::unwrap(connect_result);\n-            let resp_bytes = str::to_bytes(resp);\n+            let resp_bytes = resp.as_bytes().to_owned();\n             tcp_write_single(&sock, resp_bytes);\n             let read_result = sock.read(0u);\n             if read_result.is_err() {"}, {"sha": "31d728f18130bf7f217cfda232e1c933729da8ac", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -1060,7 +1060,7 @@ mod tests {\n         /*\n         assert_eq!(decode_form_urlencoded([]).len(), 0);\n \n-        let s = str::to_bytes(\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n+        let s = \"a=1&foo+bar=abc&foo+bar=12+%3D+34\".as_bytes();\n         let form = decode_form_urlencoded(s);\n         assert_eq!(form.len(), 2);\n         assert_eq!(form.get_ref(&~\"a\"), &~[~\"1\"]);"}, {"sha": "8c2615de26ba27388e9047dc207289e44c62156c", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -524,7 +524,7 @@ impl ToStrRadix for BigUint {\n                 let s = uint::to_str_radix(*n as uint, radix);\n                 str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n             }).concat();\n-            s.trim_left_chars(['0']).to_owned()\n+            s.trim_left_chars(&'0').to_owned()\n         }\n     }\n }\n@@ -534,7 +534,7 @@ impl FromStrRadix for BigUint {\n \n     pub fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigUint> {\n-        BigUint::parse_bytes(str::to_bytes(s), radix)\n+        BigUint::parse_bytes(s.as_bytes(), radix)\n     }\n }\n \n@@ -564,7 +564,7 @@ impl BigUint {\n     /// Creates and initializes an BigUint.\n \n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n-        return BigUint::new(vec::to_owned(slice));\n+        return BigUint::new(slice.to_owned());\n     }\n \n     /// Creates and initializes an BigUint.\n@@ -1090,7 +1090,7 @@ impl FromStrRadix for BigInt {\n \n     fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigInt> {\n-        BigInt::parse_bytes(str::to_bytes(s), radix)\n+        BigInt::parse_bytes(s.as_bytes(), radix)\n     }\n }\n "}, {"sha": "099b257380bc47a47817d21c51c600ac94090df4", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -84,9 +84,9 @@ pub fn of_str(str: @~str) -> Rope {\n  *\n  * # Return value\n  *\n- * A rope representing the same string as `str.substr(byte_offset,\n- * byte_len)`.  Depending on `byte_len`, this rope may be empty, flat\n- * or complex.\n+ * A rope representing the same string as `str.slice(byte_offset,\n+ * byte_offset + byte_len)`.  Depending on `byte_len`, this rope may\n+ * be empty, flat or complex.\n  *\n  * # Performance note\n  *\n@@ -564,7 +564,6 @@ pub mod node {\n     use rope::node;\n \n     use core::cast;\n-    use core::str;\n     use core::uint;\n     use core::vec;\n \n@@ -588,7 +587,7 @@ pub mod node {\n      * * char_len - The number of chars in the leaf.\n      * * content - Contents of the leaf.\n      *\n-     *     Note that we can have `char_len < str::char_len(content)`, if\n+     *     Note that we can have `char_len < content.char_len()`, if\n      *     this leaf is only a subset of the string. Also note that the\n      *     string can be shared between several ropes, e.g. for indexing\n      *     purposes.\n@@ -680,7 +679,7 @@ pub mod node {\n      */\n     pub fn of_substr(str: @~str, byte_start: uint, byte_len: uint) -> @Node {\n         return of_substr_unsafer(str, byte_start, byte_len,\n-                              str::count_chars(*str, byte_start, byte_len));\n+                                 str.slice(byte_start, byte_start + byte_len).char_len());\n     }\n \n     /**\n@@ -734,7 +733,7 @@ pub mod node {\n                     if i == 0u  { first_leaf_char_len }\n                     else { hint_max_leaf_char_len };\n                 let chunk_byte_len =\n-                    str::count_bytes(*str, offset, chunk_char_len);\n+                    str.slice_from(offset).slice_chars(0, chunk_char_len).len();\n                 nodes[i] = @Leaf(Leaf {\n                     byte_offset: offset,\n                     byte_len: chunk_byte_len,\n@@ -938,7 +937,7 @@ pub mod node {\n             match (*node) {\n               node::Leaf(x) => {\n                 let char_len =\n-                    str::count_chars(*x.content, byte_offset, byte_len);\n+                    x.content.slice(byte_offset, byte_offset + byte_len).char_len();\n                 return @Leaf(Leaf {\n                     byte_offset: byte_offset,\n                     byte_len: byte_len,\n@@ -1002,9 +1001,9 @@ pub mod node {\n                     return node;\n                 }\n                 let byte_offset =\n-                    str::count_bytes(*x.content, 0u, char_offset);\n+                    x.content.slice_chars(0, char_offset).len();\n                 let byte_len    =\n-                    str::count_bytes(*x.content, byte_offset, char_len);\n+                    x.content.slice_from(byte_offset).slice_chars(0, char_len).len();\n                 return @Leaf(Leaf {\n                     byte_offset: byte_offset,\n                     byte_len: byte_len,\n@@ -1312,7 +1311,7 @@ mod tests {\n         let sample = @~\"0123456789ABCDE\";\n         let r      = of_str(sample);\n \n-        assert_eq!(char_len(r), str::char_len(*sample));\n+        assert_eq!(char_len(r), sample.char_len());\n         assert!(rope_to_string(r) == *sample);\n     }\n \n@@ -1328,7 +1327,7 @@ mod tests {\n         }\n         let sample = @copy *buf;\n         let r      = of_str(sample);\n-        assert!(char_len(r) == str::char_len(*sample));\n+        assert_eq!(char_len(r), sample.char_len());\n         assert!(rope_to_string(r) == *sample);\n \n         let mut string_iter = 0u;\n@@ -1374,7 +1373,7 @@ mod tests {\n             }\n         }\n \n-        assert_eq!(len, str::char_len(*sample));\n+        assert_eq!(len, sample.char_len());\n     }\n \n     #[test]"}, {"sha": "03ceded0073012c4ac6fdbb5f9798caaa0916ff1", "filename": "src/libextra/sha1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -25,7 +25,6 @@\n use core::prelude::*;\n \n use core::iterator::IteratorUtil;\n-use core::str;\n use core::uint;\n use core::vec;\n \n@@ -246,8 +245,7 @@ pub fn sha1() -> @Sha1 {\n         }\n         fn input(&mut self, msg: &const [u8]) { add_input(self, msg); }\n         fn input_str(&mut self, msg: &str) {\n-            let bs = str::to_bytes(msg);\n-            add_input(self, bs);\n+            add_input(self, msg.as_bytes());\n         }\n         fn result(&mut self) -> ~[u8] { return mk_result(self); }\n         fn result_str(&mut self) -> ~str {"}, {"sha": "17bdf6c3a1dd2d22e2f448b3371672e92207ab8e", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -13,7 +13,6 @@\n use core::prelude::*;\n \n use core::iterator::*;\n-use core::vec;\n use core::f64;\n use core::cmp;\n use core::num;\n@@ -57,7 +56,7 @@ impl<'self> Stats for &'self [f64] {\n \n     fn median(self) -> f64 {\n         assert!(self.len() != 0);\n-        let mut tmp = vec::to_owned(self);\n+        let mut tmp = self.to_owned();\n         sort::tim_sort(tmp);\n         if tmp.len() & 1 == 0 {\n             let m = tmp.len() / 2;"}, {"sha": "40191c8992578007f9e404b8a88beb6e2436f12f", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -85,11 +85,14 @@ pub fn expand(cap: &[u8], params: &mut [Param], sta: &mut [Param], dyn: &mut [Pa\n                         _       => return Err(~\"a non-char was used with %c\")\n                     },\n                     's' => match stack.pop() {\n-                        String(s) => output.push_all(s.to_bytes()),\n+                        String(s) => output.push_all(s.as_bytes()),\n                         _         => return Err(~\"a non-str was used with %s\")\n                     },\n                     'd' => match stack.pop() {\n-                        Number(x) => output.push_all(x.to_str().to_bytes()),\n+                        Number(x) => {\n+                            let s = x.to_str();\n+                            output.push_all(s.as_bytes())\n+                        }\n                         _         => return Err(~\"a non-number was used with %d\")\n                     },\n                     'p' => state = PushParam,"}, {"sha": "1ef410252ab9378edf9928b549f966bd6c029cf4", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -12,7 +12,7 @@\n /// Does not support hashed database, only filesystem!\n \n use core::prelude::*;\n-use core::{os};\n+use core::{os, str};\n use core::os::getenv;\n use core::io::{file_reader, Reader};\n use core::iterator::IteratorUtil;\n@@ -27,7 +27,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n     let homedir = os::homedir();\n \n     let mut dirs_to_search = ~[];\n-    let first_char = term.substr(0, 1);\n+    let first_char = term.char_at(0);\n \n     // Find search directory\n     match getenv(\"TERMINFO\") {\n@@ -57,12 +57,12 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n \n     // Look for the terminal in all of the search directories\n     for dirs_to_search.each |p| {\n-        let newp = ~p.push_many(&[first_char.to_owned(), term.to_owned()]);\n+        let newp = ~p.push_many(&[str::from_char(first_char), term.to_owned()]);\n         if os::path_exists(p) && os::path_exists(newp) {\n             return Some(newp);\n         }\n         // on some installations the dir is named after the hex of the char (e.g. OS X)\n-        let newp = ~p.push_many(&[fmt!(\"%x\", first_char[0] as uint), term.to_owned()]);\n+        let newp = ~p.push_many(&[fmt!(\"%x\", first_char as uint), term.to_owned()]);\n         if os::path_exists(p) && os::path_exists(newp) {\n             return Some(newp);\n         }"}, {"sha": "8b754f8c560e515c527a18934167ade4f11fcfef", "filename": "src/libextra/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -1029,7 +1029,7 @@ mod tests {\n \n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n-              Ok(ref tm) => tm.strftime(format) == str::to_owned(s),\n+              Ok(ref tm) => tm.strftime(format) == s.to_owned(),\n               Err(e) => fail!(e)\n             }\n         }"}, {"sha": "0918ab8ddadad2013673a45edacdbd3e982a9126", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -769,10 +769,10 @@ mod test_treemap {\n     fn u8_map() {\n         let mut m = TreeMap::new();\n \n-        let k1 = str::to_bytes(\"foo\");\n-        let k2 = str::to_bytes(\"bar\");\n-        let v1 = str::to_bytes(\"baz\");\n-        let v2 = str::to_bytes(\"foobar\");\n+        let k1 = \"foo\".as_bytes();\n+        let k2 = \"bar\".as_bytes();\n+        let v1 = \"baz\".as_bytes();\n+        let v2 = \"foobar\".as_bytes();\n \n         m.insert(copy k1, copy v1);\n         m.insert(copy k2, copy v2);"}, {"sha": "744f4555d5cbd697d3721ab4bec8a63a900286fd", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -1368,7 +1368,7 @@ mod test {\n             // In C, this would be a malloc'd or stack-allocated\n             // struct that we'd cast to a void* and store as the\n             // data field in our uv_connect_t struct\n-            let req_str_bytes = str::to_bytes(req_str);\n+            let req_str_bytes = req_str.as_bytes();\n             let req_msg_ptr: *u8 = vec::raw::to_ptr(req_str_bytes);\n             debug!(\"req_msg ptr: %u\", req_msg_ptr as uint);\n             let req_msg = ~[\n@@ -1626,7 +1626,7 @@ mod test {\n             let server_write_req = write_t();\n             let server_write_req_ptr: *uv_write_t = &server_write_req;\n \n-            let resp_str_bytes = str::to_bytes(server_resp_msg);\n+            let resp_str_bytes = server_resp_msg.as_bytes();\n             let resp_msg_ptr: *u8 = vec::raw::to_ptr(resp_str_bytes);\n             debug!(\"resp_msg ptr: %u\", resp_msg_ptr as uint);\n             let resp_msg = ~["}, {"sha": "5ca25c11ba02f6b9d7a82964afa4e5d66bfeb265", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -328,7 +328,7 @@ pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n     if L < 100 {\n         do under(uint::min(L, 20)) |i| {\n             error!(\"Replacing... #%?\", uint::to_str(i));\n-            let fname = str::to_owned(filename.to_str());\n+            let fname = filename.to_str();\n             do under(uint::min(L, 30)) |j| {\n                 let fname = fname.to_str();\n                 error!(\"With... %?\", stringifier(things[j], intr));"}, {"sha": "f0d4652eb1da0818b7cbff488ad05c67de7b2493", "filename": "src/librust/rust.rc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -36,7 +36,6 @@ use core::io;\n use core::os;\n use core::run;\n use core::libc::exit;\n-use core::str;\n \n // For bootstrapping.\n mod std {\n@@ -225,7 +224,7 @@ fn usage() {\n     );\n \n     for commands.each |command| {\n-        let padding = str::repeat(\" \", indent - command.cmd.len());\n+        let padding = \" \".repeat(indent - command.cmd.len());\n         io::println(fmt!(\"    %s%s%s\",\n                          command.cmd, padding, command.usage_line));\n     }"}, {"sha": "84fb361adb9827b444ba6b360106ee76444b7a5a", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -50,8 +50,7 @@ pub enum output_type {\n }\n \n fn write_string<W:Writer>(writer: &mut W, string: &str) {\n-    let buffer = str::as_bytes_slice(string);\n-    writer.write(buffer);\n+    writer.write(string.as_bytes());\n }\n \n pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n@@ -637,7 +636,7 @@ pub fn symbol_hash(tcx: ty::ctxt,\n     write_string(symbol_hasher, encoder::encoded_ty(tcx, t));\n     let mut hash = truncated_hash_result(symbol_hasher);\n     // Prefix with _ so that it never blends into adjacent digits\n-    str::unshift_char(&mut hash, '_');\n+    hash.unshift_char('_');\n     // tjc: allocation is unfortunate; need to change core::hash\n     hash.to_managed()\n }"}, {"sha": "4b7ab6fdfc101185beb9948b513e04e4fc7508cc", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -29,7 +29,6 @@ use core::hashmap::HashMap;\n use core::int;\n use core::io;\n use core::os;\n-use core::str;\n use core::vec;\n use extra::getopts::groups::{optopt, optmulti, optflag, optflagopt};\n use extra::getopts::{opt_present};\n@@ -96,9 +95,9 @@ pub fn default_configuration(sess: Session, argv0: @~str, input: &input) ->\n     };\n \n     return ~[ // Target bindings.\n-         attr::mk_word_item(@str::to_owned(os::FAMILY)),\n+         attr::mk_word_item(@os::FAMILY.to_owned()),\n          mk(@~\"target_os\", @tos),\n-         mk(@~\"target_family\", @str::to_owned(os::FAMILY)),\n+         mk(@~\"target_family\", @os::FAMILY.to_owned()),\n          mk(@~\"target_arch\", @arch),\n          mk(@~\"target_endian\", @end),\n          mk(@~\"target_word_size\", @wordsz),\n@@ -590,12 +589,12 @@ pub fn build_session_options(binary: @~str,\n \n         // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n         // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n-        let level_short = level_name.substr(0,1);\n+        let level_short = level_name.slice_chars(0, 1);\n         let level_short = level_short.to_ascii().to_upper().to_str_ascii();\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n                                 getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n-            let lint_name = str::replace(*lint_name, \"-\", \"_\");\n+            let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find(&lint_name) {\n               None => {\n                 early_error(demitter, fmt!(\"unknown %s flag: %s\","}, {"sha": "980d318ec62f9be62a0333a9c0c93015ad6e0ef4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -570,7 +570,7 @@ pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n     let item_doc = lookup_item(id, cdata.data);\n     let path = {\n         let item_path = item_path(item_doc);\n-        vec::to_owned(item_path.init())\n+        item_path.init().to_owned()\n     };\n     match decode_inlined_item(cdata, tcx, copy path, item_doc) {\n       Some(ref ii) => csearch::found((/*bad*/copy *ii)),"}, {"sha": "b34bdafbeda5a572f8ad6d38147f4f6a20712689", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -202,7 +202,8 @@ fn encode_type_param_bounds(ebml_w: &mut writer::Encoder,\n \n fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n-    ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n+    let s = def_to_str(vid);\n+    ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n \n@@ -271,7 +272,7 @@ fn encode_symbol(ecx: @EncodeContext,\n     match ecx.item_symbols.find(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id=%?, str=%s)\", id, *x);\n-            ebml_w.writer.write(str::to_bytes(*x));\n+            ebml_w.writer.write(x.as_bytes());\n         }\n         None => {\n             ecx.diag.handler().bug(\n@@ -285,21 +286,23 @@ fn encode_discriminant(ecx: @EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::to_bytes(*ecx.discrim_symbols.get_copy(&id)));\n+    ebml_w.writer.write(ecx.discrim_symbols.get_copy(&id).as_bytes());\n     ebml_w.end_tag();\n }\n \n fn encode_disr_val(_: @EncodeContext,\n                    ebml_w: &mut writer::Encoder,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n-    ebml_w.writer.write(str::to_bytes(int::to_str(disr_val)));\n+    let s = int::to_str(disr_val);\n+    ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n \n fn encode_parent_item(ebml_w: &mut writer::Encoder, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n-    ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n+    let s = def_to_str(id);\n+    ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n \n@@ -954,7 +957,8 @@ fn encode_info_for_item(ecx: @EncodeContext,\n         for methods.each |m| {\n             ebml_w.start_tag(tag_item_impl_method);\n             let method_def_id = local_def(m.id);\n-            ebml_w.writer.write(str::to_bytes(def_to_str(method_def_id)));\n+            let s = def_to_str(method_def_id);\n+            ebml_w.writer.write(s.as_bytes());\n             ebml_w.end_tag();\n         }\n         for opt_trait.iter().advance |ast_trait_ref| {\n@@ -1218,7 +1222,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::to_bytes(*name));\n+        ebml_w.writer.write(name.as_bytes());\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n       }\n@@ -1227,10 +1231,10 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n           lit_str(value) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n-            ebml_w.writer.write(str::to_bytes(*name));\n+            ebml_w.writer.write(name.as_bytes());\n             ebml_w.end_tag();\n             ebml_w.start_tag(tag_meta_item_value);\n-            ebml_w.writer.write(str::to_bytes(*value));\n+            ebml_w.writer.write(value.as_bytes());\n             ebml_w.end_tag();\n             ebml_w.end_tag();\n           }\n@@ -1240,7 +1244,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n       meta_list(name, ref items) => {\n         ebml_w.start_tag(tag_meta_item_list);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::to_bytes(*name));\n+        ebml_w.writer.write(name.as_bytes());\n         ebml_w.end_tag();\n         for items.each |inner_item| {\n             encode_meta_item(ebml_w, *inner_item);\n@@ -1398,20 +1402,21 @@ fn encode_crate_dep(ecx: @EncodeContext,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n-    ebml_w.writer.write(str::to_bytes(*ecx.tcx.sess.str_of(dep.name)));\n+    let s = ecx.tcx.sess.str_of(dep.name);\n+    ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_vers);\n-    ebml_w.writer.write(str::to_bytes(*dep.vers));\n+    ebml_w.writer.write(dep.vers.as_bytes());\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_hash);\n-    ebml_w.writer.write(str::to_bytes(*dep.hash));\n+    ebml_w.writer.write(dep.hash.as_bytes());\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n \n fn encode_hash(ebml_w: &mut writer::Encoder, hash: &str) {\n     ebml_w.start_tag(tag_crate_hash);\n-    ebml_w.writer.write(str::to_bytes(hash));\n+    ebml_w.writer.write(hash.as_bytes());\n     ebml_w.end_tag();\n }\n \n@@ -1516,7 +1521,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n \n     let writer_bytes: &mut ~[u8] = wr.bytes;\n \n-    vec::to_owned(metadata_encoding_version) +\n+    metadata_encoding_version.to_owned() +\n         flate::deflate_bytes(*writer_bytes)\n }\n "}, {"sha": "d65e7e0ed4fe38ff348b8350200477fe4e4f7509", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -13,7 +13,6 @@ use core::prelude::*;\n use core::option;\n use core::os;\n use core::result;\n-use core::str;\n \n // A module for searching for libraries\n // FIXME (#2658): I'm not happy how this module turned out. Should\n@@ -81,7 +80,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     @FileSearchImpl {\n         sysroot: sysroot,\n         addl_lib_search_paths: addl_lib_search_paths,\n-        target_triple: str::to_owned(target_triple)\n+        target_triple: target_triple.to_owned()\n     } as @FileSearch\n }\n \n@@ -107,7 +106,7 @@ pub fn search<T:Copy>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n \n pub fn relative_target_lib_path(target_triple: &str) -> Path {\n     Path(libdir()).push_many([~\"rustc\",\n-                              str::to_owned(target_triple),\n+                              target_triple.to_owned(),\n                               libdir()])\n }\n "}, {"sha": "370804cb7507ed8915bb27f1b1c28c28b2262b00", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -80,7 +80,7 @@ fn libname(cx: &Context) -> (~str, ~str) {\n         os_freebsd => (freebsd::DLL_PREFIX, freebsd::DLL_SUFFIX),\n     };\n \n-    (str::to_owned(dll_prefix), str::to_owned(dll_suffix))\n+    (dll_prefix.to_owned(), dll_suffix.to_owned())\n }\n \n fn find_library_crate_aux("}, {"sha": "00d06f0a3d8c9366040a909df3b7c47206513ade", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -495,7 +495,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 match cx.tcx.def_map.find(&pat_id) {\n                     Some(&def_variant(_, id)) => {\n                         if variant(id) == *ctor_id {\n-                            Some(vec::to_owned(r.tail()))\n+                            Some(r.tail().to_owned())\n                         } else {\n                             None\n                         }\n@@ -533,7 +533,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             _ => fail!(\"type error\")\n                         };\n                         if match_ {\n-                            Some(vec::to_owned(r.tail()))\n+                            Some(r.tail().to_owned())\n                         } else {\n                             None\n                         }\n@@ -580,7 +580,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             _ => fail!(\"type error\")\n                         };\n                         if match_ {\n-                            Some(vec::to_owned(r.tail()))\n+                            Some(r.tail().to_owned())\n                         } else {\n                             None\n                         }\n@@ -590,7 +590,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             Some(args) => args,\n                             None => vec::from_elem(arity, wild())\n                         };\n-                        Some(vec::append(args, vec::to_owned(r.tail())))\n+                        Some(vec::append(args, r.tail().to_owned()))\n                     }\n                     def_variant(_, _) => None,\n \n@@ -602,7 +602,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             Some(args) => new_args = args,\n                             None => new_args = vec::from_elem(arity, wild())\n                         }\n-                        Some(vec::append(new_args, vec::to_owned(r.tail())))\n+                        Some(vec::append(new_args, r.tail().to_owned()))\n                     }\n                     _ => None\n                 }\n@@ -620,7 +620,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                     _ => wild()\n                                 }\n                             });\n-                            Some(vec::append(args, vec::to_owned(r.tail())))\n+                            Some(vec::append(args, r.tail().to_owned()))\n                         } else {\n                             None\n                         }\n@@ -651,7 +651,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                 _ => wild()\n                             }\n                         });\n-                        Some(vec::append(args, vec::to_owned(r.tail())))\n+                        Some(vec::append(args, r.tail().to_owned()))\n                     }\n                 }\n             }\n@@ -687,14 +687,14 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     single => true,\n                     _ => fail!(\"type error\")\n                 };\n-                if match_ { Some(vec::to_owned(r.tail())) } else { None }\n+                if match_ { Some(r.tail().to_owned()) } else { None }\n             }\n             pat_range(lo, hi) => {\n                 let (c_lo, c_hi) = match *ctor_id {\n                     val(ref v) => ((/*bad*/copy *v), (/*bad*/copy *v)),\n                     range(ref lo, ref hi) =>\n                         ((/*bad*/copy *lo), (/*bad*/copy *hi)),\n-                    single => return Some(vec::to_owned(r.tail())),\n+                    single => return Some(r.tail().to_owned()),\n                     _ => fail!(\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo);\n@@ -704,7 +704,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 let m2 = compare_const_vals(&c_hi, &v_hi);\n                 match (m1, m2) {\n                     (Some(val1), Some(val2)) if val1 >= 0 && val2 <= 0 => {\n-                        Some(vec::to_owned(r.tail()))\n+                        Some(r.tail().to_owned())\n                     },\n                     (Some(_), Some(_)) => None,\n                     _ => {\n@@ -745,7 +745,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n }\n \n pub fn default(cx: @MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n-    if is_wild(cx, r[0]) { Some(vec::to_owned(r.tail())) }\n+    if is_wild(cx, r[0]) { Some(r.tail().to_owned()) }\n     else { None }\n }\n "}, {"sha": "7f57b4b0c0d7a5b3e9236e74b979394f11068c88", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -23,7 +23,6 @@ use core::i16;\n use core::i32;\n use core::i64;\n use core::i8;\n-use core::str;\n use core::u16;\n use core::u32;\n use core::u64;\n@@ -375,7 +374,7 @@ impl Context {\n                 fmt!(\"%s [-%c %s%s]\", msg, match level {\n                         warn => 'W', deny => 'D', forbid => 'F',\n                         allow => fail!()\n-                    }, str::replace(self.lint_to_str(lint), \"_\", \"-\"),\n+                    }, self.lint_to_str(lint).replace(\"_\", \"-\"),\n                     if src == Default { \" (default)\" } else { \"\" })\n             },\n             Node(src) => {\n@@ -842,7 +841,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n-        let ident = ident.trim_chars(&['_']);\n+        let ident = ident.trim_chars(&'_');\n         char::is_uppercase(ident.char_at(0)) &&\n             !ident.contains_char('_')\n     }"}, {"sha": "1adb991c96e71c7421bb32c7eb9057865046a24f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -2678,14 +2678,14 @@ impl Resolver {\n         match module_prefix_result {\n             Failed => {\n                 let mpath = self.idents_to_str(module_path);\n-                match self.idents_to_str(module_path).rfind(':') {\n+                match mpath.rfind(':') {\n                     Some(idx) => {\n                         self.session.span_err(span, fmt!(\"unresolved import: could not find `%s` \\\n-                                                         in `%s`\", mpath.substr(idx,\n-                                                                                mpath.len() - idx),\n-                                                         // idx - 1 to account for the extra\n-                                                         // colon\n-                                                         mpath.substr(0, idx - 1)));\n+                                                         in `%s`\",\n+                                                         // idx +- 1 to account for the colons\n+                                                         // on either side\n+                                                         mpath.slice_from(idx + 1),\n+                                                         mpath.slice_to(idx - 1)));\n                     },\n                     None => (),\n                 };"}, {"sha": "3ec86688c3169c5bb6440369ceb68931ce1d8980", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -48,7 +48,6 @@ use core::iterator::IteratorUtil;\n use core::container::Map;\n use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n-use core::vec;\n \n use lib::llvm::{ValueRef, TypeRef, True, IntEQ, IntNE};\n use middle::trans::_match;\n@@ -218,7 +217,7 @@ fn mk_struct(cx: @CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n         align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n         packed: packed,\n-        fields: vec::to_owned(tys)\n+        fields: tys.to_owned()\n     }\n }\n "}, {"sha": "43a07821513b742ed18a32ab392645affb2d102e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -114,7 +114,7 @@ impl get_insn_ctxt for @CrateContext {\n     fn insn_ctxt(&self, s: &str) -> icx_popper {\n         debug!(\"new insn_ctxt: %s\", s);\n         if self.sess.count_llvm_insns() {\n-            self.stats.llvm_insn_ctxt.push(str::to_owned(s));\n+            self.stats.llvm_insn_ctxt.push(s.to_owned());\n         }\n         icx_popper(*self)\n     }"}, {"sha": "af10845181008cd1f779879eae2704a2d615125a", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -885,9 +885,9 @@ pub fn add_comment(bcx: block, text: &str) {\n     unsafe {\n         let ccx = bcx.ccx();\n         if ccx.sess.asm_comments() {\n-            let sanitized = str::replace(text, \"$\", \"\");\n+            let sanitized = text.replace(\"$\", \"\");\n             let comment_text = ~\"# \" +\n-                str::replace(sanitized, \"\\n\", \"\\n\\t# \");\n+                sanitized.replace(\"\\n\", \"\\n\\t# \");\n             let asm = str::as_c_str(comment_text, |c| {\n                 str::as_c_str(\"\", |e| {\n                     count_insn(bcx, \"inlineasm\");"}, {"sha": "65755345ac3d5f03fe7fc9843bcbcc736fd49322", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -1704,5 +1704,5 @@ fn trans_assign_op(bcx: block,\n }\n \n fn shorten(x: ~str) -> ~str {\n-    if x.len() > 60 { x.substr(0, 60).to_owned() } else { x }\n+    if x.char_len() > 60 { x.slice_chars(0, 60).to_owned() } else { x }\n }"}, {"sha": "df3bc753ae1884c3ded7357778226f04d20e6ad1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -3898,7 +3898,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n           }\n \n           ast_map::node_variant(ref variant, _, path) => {\n-            vec::append_one(vec::to_owned(vec::init(*path)),\n+            vec::append_one(path.init().to_owned(),\n                             ast_map::path_name((*variant).node.name))\n           }\n "}, {"sha": "ff19893daad9cd9f47f6de02abe32c3e8eeea5c2", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -209,7 +209,7 @@ Available lint options:\n     io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n                      padded(max_key, \"----\"), \"-------\", \"-------\"));\n     for lint_dict.each |k, v| {\n-        let k = str::replace(*k, \"_\", \"-\");\n+        let k = k.replace(\"_\", \"-\");\n         io::println(fmt!(\"    %s  %7.7s  %s\",\n                          padded(max_key, k),\n                          match v.default {"}, {"sha": "026f57df03556ef6020ab1d8a8a2e682d452abaa", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -17,7 +17,6 @@ an AST's attributes.\n \n use core::prelude::*;\n \n-use core::str;\n use syntax::ast;\n use syntax::attr;\n "}, {"sha": "ef65cc8e5a1b88483b8b78204e2907aa942bf1dd", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -262,7 +262,7 @@ mod test {\n             .. default_config(&Path(\"test\"))\n         };\n         let mock_process_output: ~fn(&str, &[~str]) -> ProcessOutput = |_, _| {\n-            ProcessOutput { status: 0, output: \"pandoc 1.8.2.1\".to_bytes(), error: ~[] }\n+            ProcessOutput { status: 0, output: \"pandoc 1.8.2.1\".as_bytes().to_owned(), error: ~[] }\n         };\n         let result = maybe_find_pandoc(&config, None, mock_process_output);\n         assert!(result == result::Ok(Some(~\"pandoc\")));"}, {"sha": "c116ccd6986924550df8e5c5b6c73e33563e8a6c", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -108,7 +108,7 @@ fn first_sentence(s: ~str) -> Option<~str> {\n     let paras = paragraphs(s);\n     if !paras.is_empty() {\n         let first_para = paras.head();\n-        Some(str::replace(first_sentence_(*first_para), \"\\n\", \" \"))\n+        Some(first_sentence_(*first_para).replace(\"\\n\", \" \"))\n     } else {\n         None\n     }\n@@ -131,13 +131,13 @@ fn first_sentence_(s: &str) -> ~str {\n     });\n     match idx {\n         Some(idx) if idx > 2u => {\n-            str::to_owned(s.slice(0, idx - 1))\n+            s.slice_to(idx - 1).to_owned()\n         }\n         _ => {\n             if s.ends_with(\".\") {\n-                str::to_owned(s)\n+                s.to_owned()\n             } else {\n-                str::to_owned(s)\n+                s.to_owned()\n             }\n         }\n     }"}, {"sha": "2f09e0a5ddc55e7d3593b92a4022b65e3beb5258", "filename": "src/librustdoc/escape_pass.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fescape_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fescape_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fescape_pass.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -13,14 +13,12 @@\n use pass::Pass;\n use text_pass;\n \n-use core::str;\n-\n pub fn mk_pass() -> Pass {\n     text_pass::mk_pass(~\"escape\", escape)\n }\n \n fn escape(s: &str) -> ~str {\n-    str::replace(s, \"\\\\\", \"\\\\\\\\\")\n+    s.replace(\"\\\\\", \"\\\\\\\\\")\n }\n \n #[test]"}, {"sha": "3634155b8a3d83a16f5e9e0cb4ae539503fefecb", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -22,8 +22,6 @@ use markdown_pass;\n use markdown_writer;\n use pass::Pass;\n \n-use core::str;\n-\n pub fn mk_pass(config: config::Config) -> Pass {\n     Pass {\n         name: ~\"markdown_index\",\n@@ -128,33 +126,33 @@ pub fn pandoc_header_id(header: &str) -> ~str {\n     return header;\n \n     fn remove_formatting(s: &str) -> ~str {\n-        str::replace(s, \"`\", \"\")\n+        s.replace(\"`\", \"\")\n     }\n     fn remove_punctuation(s: &str) -> ~str {\n-        let s = str::replace(s, \"<\", \"\");\n-        let s = str::replace(s, \">\", \"\");\n-        let s = str::replace(s, \"[\", \"\");\n-        let s = str::replace(s, \"]\", \"\");\n-        let s = str::replace(s, \"(\", \"\");\n-        let s = str::replace(s, \")\", \"\");\n-        let s = str::replace(s, \"@~\", \"\");\n-        let s = str::replace(s, \"~\", \"\");\n-        let s = str::replace(s, \"/\", \"\");\n-        let s = str::replace(s, \":\", \"\");\n-        let s = str::replace(s, \"&\", \"\");\n-        let s = str::replace(s, \"^\", \"\");\n-        let s = str::replace(s, \",\", \"\");\n-        let s = str::replace(s, \"'\", \"\");\n-        let s = str::replace(s, \"+\", \"\");\n+        let s = s.replace(\"<\", \"\");\n+        let s = s.replace(\">\", \"\");\n+        let s = s.replace(\"[\", \"\");\n+        let s = s.replace(\"]\", \"\");\n+        let s = s.replace(\"(\", \"\");\n+        let s = s.replace(\")\", \"\");\n+        let s = s.replace(\"@~\", \"\");\n+        let s = s.replace(\"~\", \"\");\n+        let s = s.replace(\"/\", \"\");\n+        let s = s.replace(\":\", \"\");\n+        let s = s.replace(\"&\", \"\");\n+        let s = s.replace(\"^\", \"\");\n+        let s = s.replace(\",\", \"\");\n+        let s = s.replace(\"'\", \"\");\n+        let s = s.replace(\"+\", \"\");\n         return s;\n     }\n     fn replace_with_hyphens(s: &str) -> ~str {\n         // Collapse sequences of whitespace to a single dash\n         // XXX: Hacky implementation here that only covers\n         // one or two spaces.\n         let s = s.trim();\n-        let s = str::replace(s, \"  \", \"-\");\n-        let s = str::replace(s, \" \", \"-\");\n+        let s = s.replace(\"  \", \"-\");\n+        let s = s.replace(\" \", \"-\");\n         return s;\n     }\n     // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use"}, {"sha": "6f480d18770770e50ee27be4c8139ecb16c25fa1", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -114,7 +114,7 @@ fn make_title(page: doc::Page) -> ~str {\n         }\n     };\n     let title = markdown_pass::header_text(item);\n-    let title = str::replace(title, \"`\", \"\");\n+    let title = title.replace(\"`\", \"\");\n     return title;\n }\n "}, {"sha": "3e1883062f33c5346fd2e26c8bee87e8f1780a7f", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -284,7 +284,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             for args.each |arg| {\n                 let (crate, filename) =\n                     if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n-                    (arg.substr(0, arg.len() - 3).to_owned(), copy *arg)\n+                    (arg.slice_to(arg.len() - 3).to_owned(), copy *arg)\n                 } else {\n                     (copy *arg, arg + \".rs\")\n                 };\n@@ -342,7 +342,8 @@ pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n         // FIXME #5898: conflicts with Cell.take(), so can't be at the top level\n         use core::iterator::IteratorUtil;\n \n-        let full = line.substr(1, line.len() - 1);\n+        // drop the : and the \\n (one byte each)\n+        let full = line.slice(1, line.len() - 1);\n         let split: ~[~str] = full.word_iter().transform(|s| s.to_owned()).collect();\n         let len = split.len();\n "}, {"sha": "161634be650cbbffadebbcdb79aea94137d50fd9", "filename": "src/librustpkg/package_path.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustpkg%2Fpackage_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustpkg%2Fpackage_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_path.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -12,7 +12,7 @@\n \n use core::path::Path;\n use core::option::Some;\n-use core::{hash, str};\n+use core::hash;\n use core::rt::io::Writer;\n use core::hash::Streaming;\n \n@@ -32,7 +32,7 @@ pub fn normalize(p_: RemotePath) -> LocalPath {\n     match p.filestem() {\n         None => LocalPath(p),\n         Some(st) => {\n-            let replaced = str::replace(st, \"-\", \"_\");\n+            let replaced = st.replace(\"-\", \"_\");\n             if replaced != st {\n                 LocalPath(p.with_filestem(replaced))\n             }\n@@ -44,8 +44,7 @@ pub fn normalize(p_: RemotePath) -> LocalPath {\n }\n \n pub fn write<W: Writer>(writer: &mut W, string: &str) {\n-    let buffer = str::as_bytes_slice(string);\n-    writer.write(buffer);\n+    writer.write(string.as_bytes());\n }\n \n pub fn hash(data: ~str) -> ~str {"}, {"sha": "6d8a6095ca4389ccfb1bd261f75ff62761dfc9ab", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -183,7 +183,7 @@ impl PkgSrc {\n         if self.libs.is_empty() && self.mains.is_empty()\n             && self.tests.is_empty() && self.benchs.is_empty() {\n \n-            note(~\"Couldn't infer any crates to build.\\n\\\n+            note(\"Couldn't infer any crates to build.\\n\\\n                          Try naming a crate `main.rs`, `lib.rs`, \\\n                          `test.rs`, or `bench.rs`.\");\n             cond.raise(copy self.id);"}, {"sha": "c0cc92723ba4ddbd68c913493d66f7431080f388", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -866,6 +866,23 @@ mod test_map {\n         assert_eq!(m.len(), i);\n         assert!(!m.is_empty());\n     }\n+\n+    #[test]\n+    fn test_find_equiv() {\n+        let mut m = HashMap::new();\n+\n+        let (foo, bar, baz) = (1,2,3);\n+        m.insert(~\"foo\", foo);\n+        m.insert(~\"bar\", bar);\n+        m.insert(~\"baz\", baz);\n+\n+\n+        assert_eq!(m.find_equiv(&(\"foo\")), Some(&foo));\n+        assert_eq!(m.find_equiv(&(\"bar\")), Some(&bar));\n+        assert_eq!(m.find_equiv(&(\"baz\")), Some(&baz));\n+\n+        assert_eq!(m.find_equiv(&(\"qux\")), None);\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "07e129e3c289a0e4d288f7ddc83da4dd04fe3443", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -761,7 +761,7 @@ impl<T:Reader> ReaderUtil for T {\n     fn read_lines(&self) -> ~[~str] {\n         do vec::build |push| {\n             for self.each_line |line| {\n-                push(str::to_owned(line));\n+                push(line.to_owned());\n             }\n         }\n     }\n@@ -1091,7 +1091,7 @@ pub fn with_bytes_reader<T>(bytes: &[u8], f: &fn(@Reader) -> T) -> T {\n }\n \n pub fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n-    str::byte_slice(s, |bytes| with_bytes_reader(bytes, f))\n+    with_bytes_reader(s.as_bytes(), f)\n }\n \n // Writing\n@@ -1462,7 +1462,7 @@ impl<T:Writer> WriterUtil for T {\n             self.write_str(str::from_char(ch));\n         }\n     }\n-    fn write_str(&self, s: &str) { str::byte_slice(s, |v| self.write(v)) }\n+    fn write_str(&self, s: &str) { self.write(s.as_bytes()) }\n     fn write_line(&self, s: &str) {\n         self.write_str(s);\n         self.write_str(&\"\\n\");"}, {"sha": "74f74d11b730275f99561c5ab0d522e8da1f35b4", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -793,27 +793,27 @@ mod tests {\n \n     #[test]\n     fn test_parse_bytes() {\n-        use str::to_bytes;\n-        assert_eq!(parse_bytes(to_bytes(\"123\"), 10u), Some(123 as $T));\n-        assert_eq!(parse_bytes(to_bytes(\"1001\"), 2u), Some(9 as $T));\n-        assert_eq!(parse_bytes(to_bytes(\"123\"), 8u), Some(83 as $T));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"123\"), 16u), Some(291 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"ffff\"), 16u), Some(65535 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"FFFF\"), 16u), Some(65535 as i32));\n-        assert_eq!(parse_bytes(to_bytes(\"z\"), 36u), Some(35 as $T));\n-        assert_eq!(parse_bytes(to_bytes(\"Z\"), 36u), Some(35 as $T));\n-\n-        assert_eq!(parse_bytes(to_bytes(\"-123\"), 10u), Some(-123 as $T));\n-        assert_eq!(parse_bytes(to_bytes(\"-1001\"), 2u), Some(-9 as $T));\n-        assert_eq!(parse_bytes(to_bytes(\"-123\"), 8u), Some(-83 as $T));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"-123\"), 16u), Some(-291 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"-ffff\"), 16u), Some(-65535 as i32));\n-        assert_eq!(i32::parse_bytes(to_bytes(\"-FFFF\"), 16u), Some(-65535 as i32));\n-        assert_eq!(parse_bytes(to_bytes(\"-z\"), 36u), Some(-35 as $T));\n-        assert_eq!(parse_bytes(to_bytes(\"-Z\"), 36u), Some(-35 as $T));\n-\n-        assert!(parse_bytes(to_bytes(\"Z\"), 35u).is_none());\n-        assert!(parse_bytes(to_bytes(\"-9\"), 2u).is_none());\n+        use str::StrSlice;\n+        assert_eq!(parse_bytes(\"123\".as_bytes(), 10u), Some(123 as $T));\n+        assert_eq!(parse_bytes(\"1001\".as_bytes(), 2u), Some(9 as $T));\n+        assert_eq!(parse_bytes(\"123\".as_bytes(), 8u), Some(83 as $T));\n+        assert_eq!(i32::parse_bytes(\"123\".as_bytes(), 16u), Some(291 as i32));\n+        assert_eq!(i32::parse_bytes(\"ffff\".as_bytes(), 16u), Some(65535 as i32));\n+        assert_eq!(i32::parse_bytes(\"FFFF\".as_bytes(), 16u), Some(65535 as i32));\n+        assert_eq!(parse_bytes(\"z\".as_bytes(), 36u), Some(35 as $T));\n+        assert_eq!(parse_bytes(\"Z\".as_bytes(), 36u), Some(35 as $T));\n+\n+        assert_eq!(parse_bytes(\"-123\".as_bytes(), 10u), Some(-123 as $T));\n+        assert_eq!(parse_bytes(\"-1001\".as_bytes(), 2u), Some(-9 as $T));\n+        assert_eq!(parse_bytes(\"-123\".as_bytes(), 8u), Some(-83 as $T));\n+        assert_eq!(i32::parse_bytes(\"-123\".as_bytes(), 16u), Some(-291 as i32));\n+        assert_eq!(i32::parse_bytes(\"-ffff\".as_bytes(), 16u), Some(-65535 as i32));\n+        assert_eq!(i32::parse_bytes(\"-FFFF\".as_bytes(), 16u), Some(-65535 as i32));\n+        assert_eq!(parse_bytes(\"-z\".as_bytes(), 36u), Some(-35 as $T));\n+        assert_eq!(parse_bytes(\"-Z\".as_bytes(), 36u), Some(-35 as $T));\n+\n+        assert!(parse_bytes(\"Z\".as_bytes(), 35u).is_none());\n+        assert!(parse_bytes(\"-9\".as_bytes(), 2u).is_none());\n     }\n \n     #[test]"}, {"sha": "3905d82cd0f5caa3c41cbfbe166c1ac583b8ffb7", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -16,6 +16,7 @@ use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n use char;\n use str;\n+use str::{StrSlice};\n use kinds::Copy;\n use vec;\n use vec::{CopyableVector, ImmutableVector};\n@@ -189,18 +190,18 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n     let _1: T = One::one();\n \n     if is_NaN(num) {\n-        return (str::to_bytes(\"NaN\"), true);\n+        return (\"NaN\".as_bytes().to_owned(), true);\n     }\n     else if is_inf(num){\n         return match sign {\n-            SignAll => (str::to_bytes(\"+inf\"), true),\n-            _       => (str::to_bytes(\"inf\"), true)\n+            SignAll => (\"+inf\".as_bytes().to_owned(), true),\n+            _       => (\"inf\".as_bytes().to_owned(), true)\n         }\n     }\n     else if is_neg_inf(num) {\n         return match sign {\n-            SignNone => (str::to_bytes(\"inf\"), true),\n-            _        => (str::to_bytes(\"-inf\"), true),\n+            SignNone => (\"inf\".as_bytes().to_owned(), true),\n+            _        => (\"-inf\".as_bytes().to_owned(), true),\n         }\n     }\n \n@@ -638,7 +639,7 @@ pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+Mul<T,T>+\n         special: bool, exponent: ExponentFormat, empty_zero: bool,\n         ignore_underscores: bool\n         ) -> Option<T> {\n-    from_str_bytes_common(str::to_bytes(buf), radix, negative,\n+    from_str_bytes_common(buf.as_bytes(), radix, negative,\n                           fractional, special, exponent, empty_zero,\n                           ignore_underscores)\n }"}, {"sha": "2bc1ca9c67330c561f879c84caf25c4cbb54461a", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -538,16 +538,16 @@ mod tests {\n \n     #[test]\n     pub fn test_parse_bytes() {\n-        use str::to_bytes;\n-        assert_eq!(parse_bytes(to_bytes(\"123\"), 10u), Some(123u as $T));\n-        assert_eq!(parse_bytes(to_bytes(\"1001\"), 2u), Some(9u as $T));\n-        assert_eq!(parse_bytes(to_bytes(\"123\"), 8u), Some(83u as $T));\n-        assert_eq!(u16::parse_bytes(to_bytes(\"123\"), 16u), Some(291u as u16));\n-        assert_eq!(u16::parse_bytes(to_bytes(\"ffff\"), 16u), Some(65535u as u16));\n-        assert_eq!(parse_bytes(to_bytes(\"z\"), 36u), Some(35u as $T));\n-\n-        assert!(parse_bytes(to_bytes(\"Z\"), 10u).is_none());\n-        assert!(parse_bytes(to_bytes(\"_\"), 2u).is_none());\n+        use str::StrSlice;\n+        assert_eq!(parse_bytes(\"123\".as_bytes(), 10u), Some(123u as $T));\n+        assert_eq!(parse_bytes(\"1001\".as_bytes(), 2u), Some(9u as $T));\n+        assert_eq!(parse_bytes(\"123\".as_bytes(), 8u), Some(83u as $T));\n+        assert_eq!(u16::parse_bytes(\"123\".as_bytes(), 16u), Some(291u as u16));\n+        assert_eq!(u16::parse_bytes(\"ffff\".as_bytes(), 16u), Some(65535u as u16));\n+        assert_eq!(parse_bytes(\"z\".as_bytes(), 36u), Some(35u as $T));\n+\n+        assert!(parse_bytes(\"Z\".as_bytes(), 10u).is_none());\n+        assert!(parse_bytes(\"_\".as_bytes(), 2u).is_none());\n     }\n \n     #[test]"}, {"sha": "044b305a0dd9db393a819d25beb0eeeb9a4eb2b0", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -1448,9 +1448,9 @@ mod tests {\n     use rand::RngUtil;\n     use rand;\n     use run;\n-    use str;\n     use str::StrSlice;\n     use vec;\n+    use vec::CopyableVector;\n     use libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n \n \n@@ -1684,7 +1684,7 @@ mod tests {\n           };\n           assert!((ostream as uint != 0u));\n           let s = ~\"hello\";\n-          let mut buf = str::to_bytes(s) + [0 as u8];\n+          let mut buf = s.as_bytes_with_null().to_owned();\n           do vec::as_mut_buf(buf) |b, _len| {\n               assert!((libc::fwrite(b as *c_void, 1u as size_t,\n                                    (s.len() + 1u) as size_t, ostream)"}, {"sha": "02772604e45ca4ac3fa214ca8905c4b56a578db6", "filename": "src/libstd/path.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -515,7 +515,7 @@ impl GenericPath for PosixPath {\n     fn with_filestem(&self, s: &str) -> PosixPath {\n         match self.filetype() {\n             None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(str::to_owned(s) + *t),\n+            Some(ref t) => self.with_filename(s.to_owned() + *t),\n         }\n     }\n \n@@ -657,7 +657,7 @@ impl GenericPath for WindowsPath {\n             (None, None) => {\n                 host = None;\n                 device = None;\n-                rest = str::to_owned(s);\n+                rest = s.to_owned();\n             }\n         }\n \n@@ -729,7 +729,7 @@ impl GenericPath for WindowsPath {\n     fn with_filestem(&self, s: &str) -> WindowsPath {\n         match self.filetype() {\n             None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(str::to_owned(s) + *t),\n+            Some(ref t) => self.with_filename(s.to_owned() + *t),\n         }\n     }\n \n@@ -947,7 +947,6 @@ pub mod windows {\n mod tests {\n     use option::{None, Some};\n     use path::{PosixPath, WindowsPath, windows};\n-    use str;\n \n     #[test]\n     fn test_double_slash_collapsing() {\n@@ -984,7 +983,7 @@ mod tests {\n     fn test_posix_paths() {\n         fn t(wp: &PosixPath, s: &str) {\n             let ss = wp.to_str();\n-            let sss = str::to_owned(s);\n+            let sss = s.to_owned();\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n@@ -1042,7 +1041,7 @@ mod tests {\n     fn test_normalize() {\n         fn t(wp: &PosixPath, s: &str) {\n             let ss = wp.to_str();\n-            let sss = str::to_owned(s);\n+            let sss = s.to_owned();\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n@@ -1105,7 +1104,7 @@ mod tests {\n     fn test_windows_paths() {\n         fn t(wp: &WindowsPath, s: &str) {\n             let ss = wp.to_str();\n-            let sss = str::to_owned(s);\n+            let sss = s.to_owned();\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);"}, {"sha": "e969c5d4e3a15d3464bc92300add41895e1ed02d", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -64,7 +64,7 @@ pub use path::PosixPath;\n pub use path::WindowsPath;\n pub use ptr::RawPtr;\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr};\n-pub use str::{StrVector, StrSlice, OwnedStr, StrUtil};\n+pub use str::{StrVector, StrSlice, OwnedStr, StrUtil, NullTerminatedStr};\n pub use from_str::{FromStr};\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};"}, {"sha": "f78502059300560bafcc6a06a9b635aed1206ea9", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -577,7 +577,7 @@ impl<R: Rng> RngUtil for R {\n \n     /// Shuffle a vec\n     fn shuffle<T:Copy>(&mut self, values: &[T]) -> ~[T] {\n-        let mut m = vec::to_owned(values);\n+        let mut m = values.to_owned();\n         self.shuffle_mut(m);\n         m\n     }"}, {"sha": "a99f5da032c39757bc0ec04b297cae74b46b8a80", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -75,5 +75,5 @@ fn super_simple_smoke_test_lets_go_read_some_files_and_have_a_good_time() {\n     let message = \"it's alright. have a good time\";\n     let filename = &Path(\"test.txt\");\n     let mut outstream = FileStream::open(filename, Create, Read).unwrap();\n-    outstream.write(message.to_bytes());\n+    outstream.write(message.as_bytes());\n }"}, {"sha": "e57b80658eef2ec377a4b561bb06673947a64cbc", "filename": "src/libstd/rt/io/flate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fflate.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -108,7 +108,7 @@ mod test {\n         let mem_writer = MemWriter::new();\n         let mut deflate_writer = DeflateWriter::new(mem_writer);\n         let in_msg = \"test\";\n-        let in_bytes = in_msg.to_bytes();\n+        let in_bytes = in_msg.as_bytes();\n         deflate_writer.write(in_bytes);\n         deflate_writer.flush();\n         let buf = deflate_writer.inner().inner();"}, {"sha": "b204cf6cfb04f0ce646cfed7091c2e9c95e52ef9", "filename": "src/libstd/run.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -741,8 +741,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n         let mut blk = ~[];\n         for es.each |&(k, v)| {\n             let kv = fmt!(\"%s=%s\", k, v);\n-            blk.push_all(str::as_bytes_slice(kv));\n-            blk.push(0);\n+            blk.push_all(kv.as_bytes_with_null_consume());\n         }\n         blk.push(0);\n         vec::as_imm_buf(blk, |p, _len|"}, {"sha": "fdf12d406e81f83a5ebb6589f8c4abedb90b9ff6", "filename": "src/libstd/str.rs", "status": "modified", "additions": 523, "deletions": 477, "changes": 1000, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -26,7 +26,7 @@ use clone::Clone;\n use cmp::{TotalOrd, Ordering, Less, Equal, Greater};\n use container::Container;\n use iter::Times;\n-use iterator::{Iterator, IteratorUtil, FilterIterator};\n+use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator};\n use libc;\n use option::{None, Option, Some};\n use old_iter::{BaseIter, EqIter};\n@@ -107,23 +107,17 @@ pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n     }\n }\n \n-/// Copy a slice into a new unique str\n-#[inline(always)]\n-pub fn to_owned(s: &str) -> ~str {\n-    unsafe { raw::slice_bytes_owned(s, 0, s.len()) }\n-}\n-\n impl ToStr for ~str {\n     #[inline(always)]\n-    fn to_str(&self) -> ~str { to_owned(*self) }\n+    fn to_str(&self) -> ~str { self.to_owned() }\n }\n impl<'self> ToStr for &'self str {\n     #[inline(always)]\n-    fn to_str(&self) -> ~str { to_owned(*self) }\n+    fn to_str(&self) -> ~str { self.to_owned() }\n }\n impl ToStr for @str {\n     #[inline(always)]\n-    fn to_str(&self) -> ~str { to_owned(*self) }\n+    fn to_str(&self) -> ~str { self.to_owned() }\n }\n \n /**\n@@ -160,110 +154,28 @@ pub fn push_str(lhs: &mut ~str, rhs: &str) {\n     lhs.push_str(rhs)\n }\n \n-/// Concatenate two strings together\n-#[inline(always)]\n-pub fn append(lhs: ~str, rhs: &str) -> ~str {\n-    let mut v = lhs;\n-    v.push_str_no_overallocate(rhs);\n-    v\n-}\n-\n #[allow(missing_doc)]\n pub trait StrVector {\n     pub fn concat(&self) -> ~str;\n     pub fn connect(&self, sep: &str) -> ~str;\n }\n \n-impl<'self> StrVector for &'self [~str] {\n+impl<'self, S: Str> StrVector for &'self [S] {\n     /// Concatenate a vector of strings.\n     pub fn concat(&self) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n-        let mut len = 0;\n-        for self.each |ss| {\n-            len += ss.len();\n-        }\n-        let mut s = ~\"\";\n-\n-        s.reserve(len);\n-\n-        unsafe {\n-            do as_buf(s) |buf, _| {\n-                let mut buf = ::cast::transmute_mut_unsafe(buf);\n-                for self.each |ss| {\n-                    do as_buf(*ss) |ssbuf, sslen| {\n-                        let sslen = sslen - 1;\n-                        ptr::copy_memory(buf, ssbuf, sslen);\n-                        buf = buf.offset(sslen);\n-                    }\n-                }\n-            }\n-            raw::set_len(&mut s, len);\n-        }\n-        s\n-    }\n-\n-    /// Concatenate a vector of strings, placing a given separator between each.\n-    pub fn connect(&self, sep: &str) -> ~str {\n-        if self.is_empty() { return ~\"\"; }\n-\n-        // concat is faster\n-        if sep.is_empty() { return self.concat(); }\n-\n-        // this is wrong without the guarantee that `self` is non-empty\n-        let mut len = sep.len() * (self.len() - 1);\n-        for self.each |ss| {\n-            len += ss.len();\n-        }\n-        let mut s = ~\"\";\n-        let mut first = true;\n-\n-        s.reserve(len);\n-\n-        unsafe {\n-            do as_buf(s) |buf, _| {\n-                do as_buf(sep) |sepbuf, seplen| {\n-                    let seplen = seplen - 1;\n-                    let mut buf = ::cast::transmute_mut_unsafe(buf);\n-                    for self.each |ss| {\n-                        do as_buf(*ss) |ssbuf, sslen| {\n-                            let sslen = sslen - 1;\n-                            if first {\n-                                first = false;\n-                            } else {\n-                                ptr::copy_memory(buf, sepbuf, seplen);\n-                                buf = buf.offset(seplen);\n-                            }\n-                            ptr::copy_memory(buf, ssbuf, sslen);\n-                            buf = buf.offset(sslen);\n-                        }\n-                    }\n-                }\n-            }\n-            raw::set_len(&mut s, len);\n-        }\n-        s\n-    }\n-}\n-\n-impl<'self> StrVector for &'self [&'self str] {\n-    /// Concatenate a vector of strings.\n-    pub fn concat(&self) -> ~str {\n-        if self.is_empty() { return ~\"\"; }\n+        let len = self.iter().transform(|s| s.as_slice().len()).sum();\n \n-        let mut len = 0;\n-        for self.each |ss| {\n-            len += ss.len();\n-        }\n         let mut s = ~\"\";\n \n         s.reserve(len);\n \n         unsafe {\n             do as_buf(s) |buf, _| {\n                 let mut buf = ::cast::transmute_mut_unsafe(buf);\n-                for self.each |ss| {\n-                    do as_buf(*ss) |ssbuf, sslen| {\n+                for self.iter().advance |ss| {\n+                    do as_buf(ss.as_slice()) |ssbuf, sslen| {\n                         let sslen = sslen - 1;\n                         ptr::copy_memory(buf, ssbuf, sslen);\n                         buf = buf.offset(sslen);\n@@ -283,10 +195,8 @@ impl<'self> StrVector for &'self [&'self str] {\n         if sep.is_empty() { return self.concat(); }\n \n         // this is wrong without the guarantee that `self` is non-empty\n-        let mut len = sep.len() * (self.len() - 1);\n-        for self.each |ss| {\n-            len += ss.len();\n-        }\n+        let len = sep.len() * (self.len() - 1)\n+            + self.iter().transform(|s| s.as_slice().len()).sum();\n         let mut s = ~\"\";\n         let mut first = true;\n \n@@ -297,8 +207,8 @@ impl<'self> StrVector for &'self [&'self str] {\n                 do as_buf(sep) |sepbuf, seplen| {\n                     let seplen = seplen - 1;\n                     let mut buf = ::cast::transmute_mut_unsafe(buf);\n-                    for self.each |ss| {\n-                        do as_buf(*ss) |ssbuf, sslen| {\n+                    for self.iter().advance |ss| {\n+                        do as_buf(ss.as_slice()) |ssbuf, sslen| {\n                             let sslen = sslen - 1;\n                             if first {\n                                 first = false;\n@@ -318,120 +228,6 @@ impl<'self> StrVector for &'self [&'self str] {\n     }\n }\n \n-/// Given a string, make a new string with repeated copies of it\n-pub fn repeat(ss: &str, nn: uint) -> ~str {\n-    do as_buf(ss) |buf, len| {\n-        let mut ret = ~\"\";\n-        // ignore the NULL terminator\n-        let len = len - 1;\n-        ret.reserve(nn * len);\n-\n-        unsafe {\n-            do as_buf(ret) |rbuf, _len| {\n-                let mut rbuf = ::cast::transmute_mut_unsafe(rbuf);\n-\n-                for nn.times {\n-                    ptr::copy_memory(rbuf, buf, len);\n-                    rbuf = rbuf.offset(len);\n-                }\n-            }\n-            raw::set_len(&mut ret, nn * len);\n-        }\n-        ret\n-    }\n-}\n-\n-/*\n-Section: Adding to and removing from a string\n-*/\n-\n-/**\n- * Remove the final character from a string and return it\n- *\n- * # Failure\n- *\n- * If the string does not contain any characters\n- */\n-pub fn pop_char(s: &mut ~str) -> char {\n-    let end = s.len();\n-    assert!(end > 0u);\n-    let CharRange {ch, next} = s.char_range_at_reverse(end);\n-    unsafe { raw::set_len(s, next); }\n-    return ch;\n-}\n-\n-/**\n- * Remove the first character from a string and return it\n- *\n- * # Failure\n- *\n- * If the string does not contain any characters\n- */\n-pub fn shift_char(s: &mut ~str) -> char {\n-    let CharRange {ch, next} = s.char_range_at(0u);\n-    *s = unsafe { raw::slice_bytes_owned(*s, next, s.len()) };\n-    return ch;\n-}\n-\n-/**\n- * Removes the first character from a string slice and returns it. This does\n- * not allocate a new string; instead, it mutates a slice to point one\n- * character beyond the character that was shifted.\n- *\n- * # Failure\n- *\n- * If the string does not contain any characters\n- */\n-#[inline]\n-pub fn slice_shift_char<'a>(s: &'a str) -> (char, &'a str) {\n-    let CharRange {ch, next} = s.char_range_at(0u);\n-    let next_s = unsafe { raw::slice_bytes(s, next, s.len()) };\n-    return (ch, next_s);\n-}\n-\n-/// Prepend a char to a string\n-pub fn unshift_char(s: &mut ~str, ch: char) {\n-    // This could be more efficient.\n-    let mut new_str = ~\"\";\n-    new_str.push_char(ch);\n-    new_str.push_str(*s);\n-    *s = new_str;\n-}\n-\n-/*\n-Section: Transforming strings\n-*/\n-\n-/**\n- * Converts a string to a unique vector of bytes\n- *\n- * The result vector is not null-terminated.\n- */\n-pub fn to_bytes(s: &str) -> ~[u8] {\n-    unsafe {\n-        let mut v: ~[u8] = ::cast::transmute(to_owned(s));\n-        vec::raw::set_len(&mut v, s.len());\n-        v\n-    }\n-}\n-\n-/// Work with the string as a byte slice, not including trailing null.\n-#[inline(always)]\n-pub fn byte_slice<T>(s: &str, f: &fn(v: &[u8]) -> T) -> T {\n-    do as_buf(s) |p,n| {\n-        unsafe { vec::raw::buf_as_slice(p, n-1u, f) }\n-    }\n-}\n-\n-/// Work with the string as a byte slice, not including trailing null, without\n-/// a callback.\n-#[inline(always)]\n-pub fn byte_slice_no_callback<'a>(s: &'a str) -> &'a [u8] {\n-    unsafe {\n-        cast::transmute(s)\n-    }\n-}\n-\n /// Something that can be used to compare against a character\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character\n@@ -459,6 +255,17 @@ impl CharEq for extern \"Rust\" fn(char) -> bool {\n     fn only_ascii(&self) -> bool { false }\n }\n \n+impl<'self, C: CharEq> CharEq for &'self [C] {\n+    #[inline(always)]\n+    fn matches(&self, c: char) -> bool {\n+        self.iter().any_(|m| m.matches(c))\n+    }\n+\n+    fn only_ascii(&self) -> bool {\n+        self.iter().all(|m| m.only_ascii())\n+    }\n+}\n+\n \n /// An iterator over the substrings of a string, separated by `sep`.\n pub struct StrCharSplitIterator<'self,Sep> {\n@@ -709,30 +516,6 @@ pub fn each_split_within<'a>(ss: &'a str,\n     return cont;\n }\n \n-/**\n- * Replace all occurrences of one string with another\n- *\n- * # Arguments\n- *\n- * * s - The string containing substrings to replace\n- * * from - The string to replace\n- * * to - The replacement string\n- *\n- * # Return value\n- *\n- * The original string with all occurances of `from` replaced with `to`\n- */\n-pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n-    let mut (result, last_end) = (~\"\", 0);\n-    for s.matches_index_iter(from).advance |(start, end)| {\n-        result.push_str(unsafe{raw::slice_bytes(s, last_end, start)});\n-        result.push_str(to);\n-        last_end = end;\n-    }\n-    result.push_str(unsafe{raw::slice_bytes(s, last_end, s.len())});\n-    result\n-}\n-\n /*\n Section: Comparing strings\n */\n@@ -976,15 +759,6 @@ fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     return true;\n }\n \n-\n-/*\n-Section: String properties\n-*/\n-\n-/// Returns the number of characters that a string holds\n-#[inline(always)]\n-pub fn char_len(s: &str) -> uint { count_chars(s, 0u, s.len()) }\n-\n /*\n Section: Misc\n */\n@@ -1102,46 +876,6 @@ pub fn with_capacity(capacity: uint) -> ~str {\n     buf\n }\n \n-/**\n- * As char_len but for a slice of a string\n- *\n- * # Arguments\n- *\n- * * s - A valid string\n- * * start - The position inside `s` where to start counting in bytes\n- * * end - The position where to stop counting\n- *\n- * # Return value\n- *\n- * The number of Unicode characters in `s` between the given indices.\n- */\n-pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n-    assert!(s.is_char_boundary(start));\n-    assert!(s.is_char_boundary(end));\n-    let mut (i, len) = (start, 0u);\n-    while i < end {\n-        let next = s.char_range_at(i).next;\n-        len += 1u;\n-        i = next;\n-    }\n-    return len;\n-}\n-\n-/// Counts the number of bytes taken by the first `n` chars in `s`\n-/// starting from `start`.\n-pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n-    assert!(s.is_char_boundary(start));\n-    let mut (end, cnt) = (start, n);\n-    let l = s.len();\n-    while cnt > 0u {\n-        assert!(end < l);\n-        let next = s.char_range_at(end).next;\n-        cnt -= 1u;\n-        end = next;\n-    }\n-    end - start\n-}\n-\n /// Given a first byte, determine how many bytes are in this UTF-8 character\n pub fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n@@ -1175,39 +909,6 @@ static tag_five_b: uint = 248u;\n static max_five_b: uint = 67108864u;\n static tag_six_b: uint = 252u;\n \n-/**\n- * Work with the byte buffer of a string.\n- *\n- * Allows for unsafe manipulation of strings, which is useful for foreign\n- * interop.\n- *\n- * # Example\n- *\n- * ~~~ {.rust}\n- * let i = str::as_bytes(\"Hello World\") { |bytes| bytes.len() };\n- * ~~~\n- */\n-#[inline]\n-pub fn as_bytes<T>(s: &const ~str, f: &fn(&~[u8]) -> T) -> T {\n-    unsafe {\n-        let v: *~[u8] = cast::transmute(copy s);\n-        f(&*v)\n-    }\n-}\n-\n-/**\n- * Work with the byte buffer of a string as a byte slice.\n- *\n- * The byte slice does not include the null terminator.\n- */\n-pub fn as_bytes_slice<'a>(s: &'a str) -> &'a [u8] {\n-    unsafe {\n-        let (ptr, len): (*u8, uint) = ::cast::transmute(s);\n-        let outgoing_tuple: (*u8, uint) = (ptr, len - 1);\n-        return ::cast::transmute(outgoing_tuple);\n-    }\n-}\n-\n /**\n  * A dummy trait to hold all the utility methods that we implement on strings.\n  */\n@@ -1237,7 +938,7 @@ impl<'self> StrUtil for &'self str {\n             // NB: len includes the trailing null.\n             assert!(len > 0);\n             if unsafe { *(ptr::offset(buf,len-1)) != 0 } {\n-                to_owned(self).as_c_str(f)\n+                self.to_owned().as_c_str(f)\n             } else {\n                 f(buf as *libc::c_char)\n             }\n@@ -1304,39 +1005,6 @@ pub fn subslice_offset(outer: &str, inner: &str) -> uint {\n     }\n }\n \n-\n-/**\n- * Returns the number of single-byte characters the string can hold without\n- * reallocating\n- */\n-pub fn capacity(s: &const ~str) -> uint {\n-    do as_bytes(s) |buf| {\n-        let vcap = vec::capacity(buf);\n-        assert!(vcap > 0u);\n-        vcap - 1u\n-    }\n-}\n-\n-/// Escape each char in `s` with char::escape_default.\n-pub fn escape_default(s: &str) -> ~str {\n-    let mut out: ~str = ~\"\";\n-    out.reserve_at_least(s.len());\n-    for s.iter().advance |c| {\n-        out.push_str(char::escape_default(c));\n-    }\n-    out\n-}\n-\n-/// Escape each char in `s` with char::escape_unicode.\n-pub fn escape_unicode(s: &str) -> ~str {\n-    let mut out: ~str = ~\"\";\n-    out.reserve_at_least(s.len());\n-    for s.iter().advance |c| {\n-        out.push_str(char::escape_unicode(c));\n-    }\n-    out\n-}\n-\n /// Unsafe operations\n pub mod raw {\n     use cast;\n@@ -1521,19 +1189,42 @@ pub mod raw {\n #[cfg(not(test))]\n pub mod traits {\n     use ops::Add;\n-    use str::append;\n-\n     impl<'self> Add<&'self str,~str> for ~str {\n         #[inline(always)]\n         fn add(&self, rhs: & &'self str) -> ~str {\n-            append(copy *self, (*rhs))\n+            let mut s = self.to_owned();\n+            s.push_str(*rhs);\n+            s\n         }\n     }\n }\n \n #[cfg(test)]\n pub mod traits {}\n \n+/// Any string that can be represented as a slice\n+pub trait Str {\n+    /// Work with `self` as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a str;\n+}\n+\n+impl<'self> Str for &'self str {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a str { *self }\n+}\n+impl<'self> Str for ~str {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a str {\n+        let s: &'a str = *self; s\n+    }\n+}\n+impl<'self> Str for @str {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a str {\n+        let s: &'a str = *self; s\n+    }\n+}\n+\n #[allow(missing_doc)]\n pub trait StrSlice<'self> {\n     fn contains<'a>(&self, needle: &'a str) -> bool;\n@@ -1556,31 +1247,39 @@ pub trait StrSlice<'self> {\n     fn is_alphanumeric(&self) -> bool;\n     fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n+\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n     fn slice_from(&self, begin: uint) -> &'self str;\n     fn slice_to(&self, end: uint) -> &'self str;\n+\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'self str;\n+\n     fn starts_with(&self, needle: &str) -> bool;\n-    fn substr(&self, begin: uint, n: uint) -> &'self str;\n     fn escape_default(&self) -> ~str;\n     fn escape_unicode(&self) -> ~str;\n     fn trim(&self) -> &'self str;\n     fn trim_left(&self) -> &'self str;\n     fn trim_right(&self) -> &'self str;\n-    fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str;\n-    fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str;\n-    fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str;\n+    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n+    fn replace(&self, from: &str, to: &str) -> ~str;\n     fn to_owned(&self) -> ~str;\n     fn to_managed(&self) -> @str;\n     fn is_char_boundary(&self, index: uint) -> bool;\n     fn char_range_at(&self, start: uint) -> CharRange;\n     fn char_at(&self, i: uint) -> char;\n     fn char_range_at_reverse(&self, start: uint) -> CharRange;\n     fn char_at_reverse(&self, i: uint) -> char;\n-    fn to_bytes(&self) -> ~[u8];\n+    fn as_bytes(&self) -> &'self [u8];\n \n     fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n     fn find_str(&self, &str) -> Option<uint>;\n+\n+    fn repeat(&self, nn: uint) -> ~str;\n+\n+    fn slice_shift_char(&self) -> (char, &'self str);\n }\n \n /// Extension methods for strings\n@@ -1635,12 +1334,12 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// An iterator over the bytes of `self`\n     #[inline]\n     fn bytes_iter(&self) -> StrBytesIterator<'self> {\n-        StrBytesIterator { it: as_bytes_slice(*self).iter() }\n+        StrBytesIterator { it: self.as_bytes().iter() }\n     }\n     /// An iterator over the bytes of `self`, in reverse order\n     #[inline]\n     fn bytes_rev_iter(&self) -> StrBytesRevIterator<'self> {\n-        StrBytesRevIterator { it: as_bytes_slice(*self).rev_iter() }\n+        StrBytesRevIterator { it: self.as_bytes().rev_iter() }\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -1753,7 +1452,8 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n     /// Returns the number of characters that a string holds\n     #[inline]\n-    fn char_len(&self) -> uint { char_len(*self) }\n+    fn char_len(&self) -> uint { self.iter().count() }\n+\n     /**\n      * Returns a slice of the given string from the byte range\n      * [`begin`..`end`)\n@@ -1784,6 +1484,32 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn slice_to(&self, end: uint) -> &'self str {\n         self.slice(0, end)\n     }\n+\n+    /// Returns a slice of the string from the char range\n+    /// [`begin`..`end`).\n+    ///\n+    /// Fails if `begin` > `end` or the either `begin` or `end` are\n+    /// beyond the last character of the string.\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'self str {\n+        assert!(begin <= end);\n+        // not sure how to use the iterators for this nicely.\n+        let mut (position, count) = (0, 0);\n+        let l = self.len();\n+        while count < begin && position < l {\n+            position = self.char_range_at(position).next;\n+            count += 1;\n+        }\n+        if count < begin { fail!(\"Attempted to begin slice_chars beyond end of string\") }\n+        let start_byte = position;\n+        while count < end && position < l {\n+            position = self.char_range_at(position).next;\n+            count += 1;\n+        }\n+        if count < end { fail!(\"Attempted to end slice_chars beyond end of string\") }\n+\n+        self.slice(start_byte, position)\n+    }\n+\n     /// Returns true if `needle` is a prefix of the string.\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n         let (self_len, needle_len) = (self.len(), needle.len());\n@@ -1792,29 +1518,32 @@ impl<'self> StrSlice<'self> for &'self str {\n         else { match_at(*self, needle, 0u) }\n     }\n     /// Returns true if `needle` is a suffix of the string.\n-    pub fn ends_with(&self, needle: &str) -> bool {\n+    fn ends_with(&self, needle: &str) -> bool {\n         let (self_len, needle_len) = (self.len(), needle.len());\n         if needle_len == 0u { true }\n         else if needle_len > self_len { false }\n         else { match_at(*self, needle, self_len - needle_len) }\n     }\n \n-    /**\n-     * Take a substring of another.\n-     *\n-     * Returns a string containing `n` characters starting at byte offset\n-     * `begin`.\n-     */\n-    #[inline]\n-    fn substr(&self, begin: uint, n: uint) -> &'self str {\n-        self.slice(begin, begin + count_bytes(*self, begin, n))\n-    }\n     /// Escape each char in `s` with char::escape_default.\n-    #[inline]\n-    fn escape_default(&self) -> ~str { escape_default(*self) }\n+    fn escape_default(&self) -> ~str {\n+        let mut out: ~str = ~\"\";\n+        out.reserve_at_least(self.len());\n+        for self.iter().advance |c| {\n+            out.push_str(char::escape_default(c));\n+        }\n+        out\n+    }\n+\n     /// Escape each char in `s` with char::escape_unicode.\n-    #[inline]\n-    fn escape_unicode(&self) -> ~str { escape_unicode(*self) }\n+    fn escape_unicode(&self) -> ~str {\n+        let mut out: ~str = ~\"\";\n+        out.reserve_at_least(self.len());\n+        for self.iter().advance |c| {\n+            out.push_str(char::escape_unicode(c));\n+        }\n+        out\n+    }\n \n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n@@ -1824,49 +1553,51 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// Returns a string with leading whitespace removed\n     #[inline]\n     fn trim_left(&self) -> &'self str {\n-        match self.find(|c| !char::is_whitespace(c)) {\n-            None => \"\",\n-            Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n-        }\n+        self.trim_left_chars(&char::is_whitespace)\n     }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n     fn trim_right(&self) -> &'self str {\n-        match self.rfind(|c| !char::is_whitespace(c)) {\n-            None => \"\",\n-            Some(last) => {\n-                let next = self.char_range_at(last).next;\n-                unsafe { raw::slice_bytes(*self, 0u, next) }\n-            }\n-        }\n+        self.trim_right_chars(&char::is_whitespace)\n     }\n \n     /**\n-     * Returns a string with leading and trailing `chars_to_trim` removed.\n+     * Returns a string with characters that match `to_trim` removed.\n      *\n      * # Arguments\n      *\n-     * * chars_to_trim - A vector of chars\n+     * * to_trim - a character matcher\n+     *\n+     * # Example\n      *\n+     * ~~~\n+     * assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\")\n+     * assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n+     * assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n+     * ~~~\n      */\n     #[inline]\n-    fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str {\n-        self.trim_left_chars(chars_to_trim).trim_right_chars(chars_to_trim)\n+    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n+        self.trim_left_chars(to_trim).trim_right_chars(to_trim)\n     }\n     /**\n      * Returns a string with leading `chars_to_trim` removed.\n      *\n      * # Arguments\n      *\n-     * * s - A string\n-     * * chars_to_trim - A vector of chars\n+     * * to_trim - a character matcher\n      *\n+     * # Example\n+     *\n+     * ~~~\n+     * assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\")\n+     * assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n+     * assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n+     * ~~~\n      */\n     #[inline]\n-    fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str {\n-        if chars_to_trim.is_empty() { return *self; }\n-\n-        match self.find(|c| !chars_to_trim.contains(&c)) {\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n+        match self.find(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n         }\n@@ -1876,15 +1607,19 @@ impl<'self> StrSlice<'self> for &'self str {\n      *\n      * # Arguments\n      *\n-     * * s - A string\n-     * * chars_to_trim - A vector of chars\n+     * * to_trim - a character matcher\n      *\n+     * # Example\n+     *\n+     * ~~~\n+     * assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\")\n+     * assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n+     * assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n+     * ~~~\n      */\n     #[inline]\n-    fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str {\n-        if chars_to_trim.is_empty() { return *self; }\n-\n-        match self.rfind(|c| !chars_to_trim.contains(&c)) {\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n+        match self.rfind(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(last) => {\n                 let next = self.char_range_at(last).next;\n@@ -1893,10 +1628,36 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n+    /**\n+     * Replace all occurrences of one string with another\n+     *\n+     * # Arguments\n+     *\n+     * * from - The string to replace\n+     * * to - The replacement string\n+     *\n+     * # Return value\n+     *\n+     * The original string with all occurances of `from` replaced with `to`\n+     */\n+    pub fn replace(&self, from: &str, to: &str) -> ~str {\n+        let mut (result, last_end) = (~\"\", 0);\n+        for self.matches_index_iter(from).advance |(start, end)| {\n+            result.push_str(unsafe{raw::slice_bytes(*self, last_end, start)});\n+            result.push_str(to);\n+            last_end = end;\n+        }\n+        result.push_str(unsafe{raw::slice_bytes(*self, last_end, self.len())});\n+        result\n+    }\n \n+    /// Copy a slice into a new unique str\n     #[inline]\n-    fn to_owned(&self) -> ~str { to_owned(*self) }\n+    fn to_owned(&self) -> ~str {\n+        unsafe { raw::slice_bytes_owned(*self, 0, self.len()) }\n+    }\n \n+    /// Copy a slice into a new @str\n     #[inline]\n     fn to_managed(&self) -> @str {\n         let v = at_vec::from_fn(self.len() + 1, |i| {\n@@ -2023,7 +1784,18 @@ impl<'self> StrSlice<'self> for &'self str {\n         self.char_range_at_reverse(i).ch\n     }\n \n-    fn to_bytes(&self) -> ~[u8] { to_bytes(*self) }\n+    /**\n+     * Work with the byte buffer of a string as a byte slice.\n+     *\n+     * The byte slice does not include the null terminator.\n+     */\n+    fn as_bytes(&self) -> &'self [u8] {\n+        unsafe {\n+            let (ptr, len): (*u8, uint) = ::cast::transmute(*self);\n+            let outgoing_tuple: (*u8, uint) = (ptr, len - 1);\n+            ::cast::transmute(outgoing_tuple)\n+        }\n+    }\n \n     /**\n      * Returns the byte index of the first character of `self` that matches `search`\n@@ -2094,15 +1866,108 @@ impl<'self> StrSlice<'self> for &'self str {\n                 .map_consume(|(start, _end)| start)\n         }\n     }\n+\n+    /// Given a string, make a new string with repeated copies of it.\n+    fn repeat(&self, nn: uint) -> ~str {\n+        do as_buf(*self) |buf, len| {\n+            let mut ret = ~\"\";\n+            // ignore the NULL terminator\n+            let len = len - 1;\n+            ret.reserve(nn * len);\n+\n+            unsafe {\n+                do as_buf(ret) |rbuf, _len| {\n+                    let mut rbuf = ::cast::transmute_mut_unsafe(rbuf);\n+\n+                    for nn.times {\n+                        ptr::copy_memory(rbuf, buf, len);\n+                        rbuf = rbuf.offset(len);\n+                    }\n+                }\n+                raw::set_len(&mut ret, nn * len);\n+            }\n+            ret\n+        }\n+    }\n+\n+    /**\n+     * Retrieves the first character from a string slice and returns\n+     * it. This does not allocate a new string; instead, it returns a\n+     * slice that point one character beyond the character that was\n+     * shifted.\n+     *\n+     * # Failure\n+     *\n+     * If the string does not contain any characters\n+     */\n+    #[inline]\n+    fn slice_shift_char(&self) -> (char, &'self str) {\n+        let CharRange {ch, next} = self.char_range_at(0u);\n+        let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n+        return (ch, next_s);\n+    }\n+\n+\n+}\n+\n+#[allow(missing_doc)]\n+pub trait NullTerminatedStr {\n+    fn as_bytes_with_null<'a>(&'a self) -> &'a [u8];\n+}\n+\n+impl NullTerminatedStr for ~str {\n+    /**\n+     * Work with the byte buffer of a string as a byte slice.\n+     *\n+     * The byte slice does include the null terminator.\n+     */\n+    #[inline]\n+    fn as_bytes_with_null<'a>(&'a self) -> &'a [u8] {\n+        let ptr: &'a ~[u8] = unsafe { ::cast::transmute(self) };\n+        let slice: &'a [u8] = *ptr;\n+        slice\n+    }\n+}\n+impl NullTerminatedStr for @str {\n+    /**\n+     * Work with the byte buffer of a string as a byte slice.\n+     *\n+     * The byte slice does include the null terminator.\n+     */\n+    #[inline]\n+    fn as_bytes_with_null<'a>(&'a self) -> &'a [u8] {\n+        let ptr: &'a ~[u8] = unsafe { ::cast::transmute(self) };\n+        let slice: &'a [u8] = *ptr;\n+        slice\n+    }\n+}\n+// static strings are the only slices guaranteed to a nul-terminator\n+impl NullTerminatedStr for &'static str {\n+    /**\n+     * Work with the byte buffer of a string as a byte slice.\n+     *\n+     * The byte slice does include the null terminator.\n+     */\n+    #[inline]\n+    fn as_bytes_with_null(&self) -> &'static [u8] {\n+        unsafe { ::cast::transmute(*self) }\n+    }\n }\n \n #[allow(missing_doc)]\n pub trait OwnedStr {\n     fn push_str_no_overallocate(&mut self, rhs: &str);\n     fn push_str(&mut self, rhs: &str);\n     fn push_char(&mut self, c: char);\n+    fn pop_char(&mut self) -> char;\n+    fn shift_char(&mut self) -> char;\n+    fn unshift_char(&mut self, ch: char);\n+    fn append(&self, rhs: &str) -> ~str; // FIXME #4850: this should consume self.\n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n+    fn capacity(&self) -> uint;\n+\n+    fn as_bytes_with_null_consume(self) -> ~[u8];\n }\n \n impl OwnedStr for ~str {\n@@ -2198,6 +2063,51 @@ impl OwnedStr for ~str {\n             raw::set_len(self, new_len);\n         }\n     }\n+    /**\n+     * Remove the final character from a string and return it\n+     *\n+     * # Failure\n+     *\n+     * If the string does not contain any characters\n+     */\n+    fn pop_char(&mut self) -> char {\n+        let end = self.len();\n+        assert!(end > 0u);\n+        let CharRange {ch, next} = self.char_range_at_reverse(end);\n+        unsafe { raw::set_len(self, next); }\n+        return ch;\n+    }\n+\n+    /**\n+     * Remove the first character from a string and return it\n+     *\n+     * # Failure\n+     *\n+     * If the string does not contain any characters\n+     */\n+    fn shift_char(&mut self) -> char {\n+        let CharRange {ch, next} = self.char_range_at(0u);\n+        *self = unsafe { raw::slice_bytes_owned(*self, next, self.len()) };\n+        return ch;\n+    }\n+\n+    /// Prepend a char to a string\n+    fn unshift_char(&mut self, ch: char) {\n+        // This could be more efficient.\n+        let mut new_str = ~\"\";\n+        new_str.push_char(ch);\n+        new_str.push_str(*self);\n+        *self = new_str;\n+    }\n+\n+    /// Concatenate two strings together.\n+    #[inline]\n+    fn append(&self, rhs: &str) -> ~str {\n+        // FIXME #4850: this should consume self, but that causes segfaults\n+        let mut v = self.clone();\n+        v.push_str_no_overallocate(rhs);\n+        v\n+    }\n \n     /**\n      * Reserves capacity for exactly `n` bytes in the given string, not including\n@@ -2247,12 +2157,30 @@ impl OwnedStr for ~str {\n     fn reserve_at_least(&mut self, n: uint) {\n         self.reserve(uint::next_power_of_two(n + 1u) - 1u)\n     }\n+\n+    /**\n+     * Returns the number of single-byte characters the string can hold without\n+     * reallocating\n+     */\n+    fn capacity(&self) -> uint {\n+        let buf: &const ~[u8] = unsafe { cast::transmute(self) };\n+        let vcap = vec::capacity(buf);\n+        assert!(vcap > 0u);\n+        vcap - 1u\n+    }\n+\n+    /// Convert to a vector of bytes. This does not allocate a new\n+    /// string, and includes the null terminator.\n+    #[inline]\n+    fn as_bytes_with_null_consume(self) -> ~[u8] {\n+        unsafe { ::cast::transmute(self) }\n+    }\n }\n \n impl Clone for ~str {\n     #[inline(always)]\n     fn clone(&self) -> ~str {\n-        to_owned(*self)\n+        self.to_owned()\n     }\n }\n \n@@ -2332,7 +2260,7 @@ mod tests {\n     use ptr;\n     use str::*;\n     use vec;\n-    use vec::ImmutableVector;\n+    use vec::{ImmutableVector, CopyableVector};\n     use cmp::{TotalOrd, Less, Equal, Greater};\n \n     #[test]\n@@ -2367,14 +2295,14 @@ mod tests {\n         assert_eq!(\"\\u2620\".len(), 3u);\n         assert_eq!(\"\\U0001d11e\".len(), 4u);\n \n-        assert_eq!(char_len(\"\"), 0u);\n-        assert_eq!(char_len(\"hello world\"), 11u);\n-        assert_eq!(char_len(\"\\x63\"), 1u);\n-        assert_eq!(char_len(\"\\xa2\"), 1u);\n-        assert_eq!(char_len(\"\\u03c0\"), 1u);\n-        assert_eq!(char_len(\"\\u2620\"), 1u);\n-        assert_eq!(char_len(\"\\U0001d11e\"), 1u);\n-        assert_eq!(char_len(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"), 19u);\n+        assert_eq!(\"\".char_len(), 0u);\n+        assert_eq!(\"hello world\".char_len(), 11u);\n+        assert_eq!(\"\\x63\".char_len(), 1u);\n+        assert_eq!(\"\\xa2\".char_len(), 1u);\n+        assert_eq!(\"\\u03c0\".char_len(), 1u);\n+        assert_eq!(\"\\u2620\".char_len(), 1u);\n+        assert_eq!(\"\\U0001d11e\".char_len(), 1u);\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".char_len(), 19u);\n     }\n \n     #[test]\n@@ -2397,18 +2325,39 @@ mod tests {\n         assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|c: char| c == '\u534e'), Some(30u));\n     }\n \n+    #[test]\n+    fn test_push_str() {\n+        let mut s = ~\"\";\n+        s.push_str(\"\");\n+        assert_eq!(s.slice_from(0), \"\");\n+        s.push_str(\"abc\");\n+        assert_eq!(s.slice_from(0), \"abc\");\n+        s.push_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(s.slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+    }\n+    #[test]\n+    fn test_append() {\n+        let mut s = ~\"\";\n+        s = s.append(\"\");\n+        assert_eq!(s.slice_from(0), \"\");\n+        s = s.append(\"abc\");\n+        assert_eq!(s.slice_from(0), \"abc\");\n+        s = s.append(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(s.slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+    }\n+\n     #[test]\n     fn test_pop_char() {\n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let cc = pop_char(&mut data);\n+        let cc = data.pop_char();\n         assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n         assert_eq!('\u534e', cc);\n     }\n \n     #[test]\n     fn test_pop_char_2() {\n         let mut data2 = ~\"\u534e\";\n-        let cc2 = pop_char(&mut data2);\n+        let cc2 = data2.pop_char();\n         assert_eq!(~\"\", data2);\n         assert_eq!('\u534e', cc2);\n     }\n@@ -2418,7 +2367,29 @@ mod tests {\n     #[ignore(cfg(windows))]\n     fn test_pop_char_fail() {\n         let mut data = ~\"\";\n-        let _cc3 = pop_char(&mut data);\n+        let _cc3 = data.pop_char();\n+    }\n+\n+    #[test]\n+    fn test_push_char() {\n+        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+        data.push_char('\u534e');\n+        assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", data);\n+    }\n+\n+    #[test]\n+    fn test_shift_char() {\n+        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+        let cc = data.shift_char();\n+        assert_eq!(~\"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n+        assert_eq!('\u0e1b', cc);\n+    }\n+\n+    #[test]\n+    fn test_unshift_char() {\n+        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+        data.unshift_char('\u534e');\n+        assert_eq!(~\"\u534e\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n     }\n \n     #[test]\n@@ -2466,13 +2437,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_substr() {\n-        fn t(a: &str, b: &str, start: int) {\n-            assert_eq!(a.substr(start as uint, b.len()), b);\n+    fn test_slice_chars() {\n+        fn t(a: &str, b: &str, start: uint) {\n+            assert_eq!(a.slice_chars(start, start + b.char_len()), b);\n         }\n         t(\"hello\", \"llo\", 2);\n         t(\"hello\", \"el\", 1);\n-        assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".substr(6u, 6u));\n+        assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".slice_chars(2, 8));\n     }\n \n     #[test]\n@@ -2522,11 +2493,11 @@ mod tests {\n \n     #[test]\n     fn test_repeat() {\n-        assert_eq!(repeat(\"x\", 4), ~\"xxxx\");\n-        assert_eq!(repeat(\"hi\", 4), ~\"hihihihi\");\n-        assert_eq!(repeat(\"\u0e44\u0e17\u534e\", 3), ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\");\n-        assert_eq!(repeat(\"\", 4), ~\"\");\n-        assert_eq!(repeat(\"hi\", 0), ~\"\");\n+        assert_eq!(\"x\".repeat(4), ~\"xxxx\");\n+        assert_eq!(\"hi\".repeat(4), ~\"hihihihi\");\n+        assert_eq!(\"\u0e44\u0e17\u534e\".repeat(3), ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\");\n+        assert_eq!(\"\".repeat(4), ~\"\");\n+        assert_eq!(\"hi\".repeat(0), ~\"\");\n     }\n \n     #[test]\n@@ -2578,13 +2549,13 @@ mod tests {\n     #[test]\n     fn test_replace() {\n         let a = \"a\";\n-        assert_eq!(replace(\"\", a, \"b\"), ~\"\");\n-        assert_eq!(replace(\"a\", a, \"b\"), ~\"b\");\n-        assert_eq!(replace(\"ab\", a, \"b\"), ~\"bb\");\n+        assert_eq!(\"\".replace(a, \"b\"), ~\"\");\n+        assert_eq!(\"a\".replace(a, \"b\"), ~\"b\");\n+        assert_eq!(\"ab\".replace(a, \"b\"), ~\"bb\");\n         let test = \"test\";\n-        assert!(replace(\" test test \", test, \"toast\") ==\n+        assert!(\" test test \".replace(test, \"toast\") ==\n             ~\" toast toast \");\n-        assert_eq!(replace(\" test test \", test, \"\"), ~\"   \");\n+        assert_eq!(\" test test \".replace(test, \"\"), ~\"   \");\n     }\n \n     #[test]\n@@ -2594,7 +2565,7 @@ mod tests {\n \n         let a = ~\"\u0e1b\u0e23\u0e30\u0e40\";\n         let A = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(replace(data, a, repl), A);\n+        assert_eq!(data.replace(a, repl), A);\n     }\n \n     #[test]\n@@ -2604,7 +2575,7 @@ mod tests {\n \n         let b = ~\"\u0e30\u0e40\";\n         let B = ~\"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(replace(data, b,   repl), B);\n+        assert_eq!(data.replace(b,   repl), B);\n     }\n \n     #[test]\n@@ -2614,7 +2585,7 @@ mod tests {\n \n         let c = ~\"\u4e2d\u534e\";\n         let C = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-        assert_eq!(replace(data, c, repl), C);\n+        assert_eq!(data.replace(c, repl), C);\n     }\n \n     #[test]\n@@ -2623,7 +2594,7 @@ mod tests {\n         let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n         let d = ~\"\u0e44\u0e17\u534e\";\n-        assert_eq!(replace(data, d, repl), data);\n+        assert_eq!(data.replace(d, repl), data);\n     }\n \n     #[test]\n@@ -2707,26 +2678,41 @@ mod tests {\n \n     #[test]\n     fn test_trim_left_chars() {\n-        assert_eq!(\" *** foo *** \".trim_left_chars([]), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_left_chars(['*', ' ']), \"foo *** \");\n-        assert_eq!(\" ***  *** \".trim_left_chars(['*', ' ']), \"\");\n-        assert_eq!(\"foo *** \".trim_left_chars(['*', ' ']), \"foo *** \");\n+        let v: &[char] = &[];\n+        assert_eq!(\" *** foo *** \".trim_left_chars(&v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_left_chars(& &['*', ' ']), \"foo *** \");\n+        assert_eq!(\" ***  *** \".trim_left_chars(& &['*', ' ']), \"\");\n+        assert_eq!(\"foo *** \".trim_left_chars(& &['*', ' ']), \"foo *** \");\n+\n+        assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\");\n+        assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\");\n+        assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n-        assert_eq!(\" *** foo *** \".trim_right_chars([]), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_right_chars(['*', ' ']), \" *** foo\");\n-        assert_eq!(\" ***  *** \".trim_right_chars(['*', ' ']), \"\");\n-        assert_eq!(\" *** foo\".trim_right_chars(['*', ' ']), \" *** foo\");\n+        let v: &[char] = &[];\n+        assert_eq!(\" *** foo *** \".trim_right_chars(&v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_right_chars(& &['*', ' ']), \" *** foo\");\n+        assert_eq!(\" ***  *** \".trim_right_chars(& &['*', ' ']), \"\");\n+        assert_eq!(\" *** foo\".trim_right_chars(& &['*', ' ']), \" *** foo\");\n+\n+        assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\");\n+        assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n-        assert_eq!(\" *** foo *** \".trim_chars([]), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_chars(['*', ' ']), \"foo\");\n-        assert_eq!(\" ***  *** \".trim_chars(['*', ' ']), \"\");\n-        assert_eq!(\"foo\".trim_chars(['*', ' ']), \"foo\");\n+        let v: &[char] = &[];\n+        assert_eq!(\" *** foo *** \".trim_chars(&v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_chars(& &['*', ' ']), \"foo\");\n+        assert_eq!(\" ***  *** \".trim_chars(& &['*', ' ']), \"\");\n+        assert_eq!(\"foo\".trim_chars(& &['*', ' ']), \"foo\");\n+\n+        assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\");\n+        assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\");\n     }\n \n     #[test]\n@@ -2905,12 +2891,70 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_as_bytes() {\n+        // no null\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        assert_eq!(\"\".as_bytes(), &[]);\n+        assert_eq!(\"abc\".as_bytes(), &['a' as u8, 'b' as u8, 'c' as u8]);\n+        assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v);\n+    }\n+\n+    #[test]\n+    fn test_as_bytes_with_null() {\n+        // has null\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109, 0\n+        ];\n+\n+        assert_eq!(\"\".as_bytes_with_null(), &[0]);\n+        assert_eq!(\"abc\".as_bytes_with_null(), &['a' as u8, 'b' as u8, 'c' as u8, 0]);\n+        assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes_with_null(), v);\n+\n+        let s1 = @\"\";\n+        let s2 = @\"abc\";\n+        let s3 = @\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert_eq!(s1.as_bytes_with_null(), &[0]);\n+        assert_eq!(s2.as_bytes_with_null(), &['a' as u8, 'b' as u8, 'c' as u8, 0]);\n+        assert_eq!(s3.as_bytes_with_null(), v);\n+\n+        let s1 = ~\"\";\n+        let s2 = ~\"abc\";\n+        let s3 = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert_eq!(s1.as_bytes_with_null(), &[0]);\n+        assert_eq!(s2.as_bytes_with_null(), &['a' as u8, 'b' as u8, 'c' as u8, 0]);\n+        assert_eq!(s3.as_bytes_with_null(), v);\n+    }\n+\n+    #[test]\n+    fn test_as_bytes_with_null_consume() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~[\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109, 0\n+        ];\n+        assert_eq!((~\"\").as_bytes_with_null_consume(), ~[0]);\n+        assert_eq!((~\"abc\").as_bytes_with_null_consume(),\n+                   ~['a' as u8, 'b' as u8, 'c' as u8, 0]);\n+        assert_eq!(s.as_bytes_with_null_consume(), v);\n+    }\n+\n     #[test]\n     #[ignore(cfg(windows))]\n     #[should_fail]\n     fn test_as_bytes_fail() {\n-        // Don't double free\n-        as_bytes::<()>(&~\"\", |_bytes| fail!() );\n+        // Don't double free. (I'm not sure if this exercises the\n+        // original problem code path anymore.)\n+        let s = ~\"\";\n+        let _bytes = s.as_bytes_with_null();\n+        fail!();\n     }\n \n     #[test]\n@@ -2985,7 +3029,7 @@ mod tests {\n     fn vec_str_conversions() {\n         let s1: ~str = ~\"All mimsy were the borogoves\";\n \n-        let v: ~[u8] = to_bytes(s1);\n+        let v: ~[u8] = s1.as_bytes().to_owned();\n         let s2: ~str = from_bytes(v);\n         let mut i: uint = 0u;\n         let n1: uint = s1.len();\n@@ -3104,37 +3148,39 @@ mod tests {\n \n     #[test]\n     fn test_escape_unicode() {\n-        assert_eq!(escape_unicode(\"abc\"), ~\"\\\\x61\\\\x62\\\\x63\");\n-        assert_eq!(escape_unicode(\"a c\"), ~\"\\\\x61\\\\x20\\\\x63\");\n-        assert_eq!(escape_unicode(\"\\r\\n\\t\"), ~\"\\\\x0d\\\\x0a\\\\x09\");\n-        assert_eq!(escape_unicode(\"'\\\"\\\\\"), ~\"\\\\x27\\\\x22\\\\x5c\");\n-        assert!(escape_unicode(\"\\x00\\x01\\xfe\\xff\") ==\n-                     ~\"\\\\x00\\\\x01\\\\xfe\\\\xff\");\n-        assert_eq!(escape_unicode(\"\\u0100\\uffff\"), ~\"\\\\u0100\\\\uffff\");\n-        assert!(escape_unicode(\"\\U00010000\\U0010ffff\") ==\n-            ~\"\\\\U00010000\\\\U0010ffff\");\n-        assert_eq!(escape_unicode(\"ab\\ufb00\"), ~\"\\\\x61\\\\x62\\\\ufb00\");\n-        assert_eq!(escape_unicode(\"\\U0001d4ea\\r\"), ~\"\\\\U0001d4ea\\\\x0d\");\n+        assert_eq!(\"abc\".escape_unicode(), ~\"\\\\x61\\\\x62\\\\x63\");\n+        assert_eq!(\"a c\".escape_unicode(), ~\"\\\\x61\\\\x20\\\\x63\");\n+        assert_eq!(\"\\r\\n\\t\".escape_unicode(), ~\"\\\\x0d\\\\x0a\\\\x09\");\n+        assert_eq!(\"'\\\"\\\\\".escape_unicode(), ~\"\\\\x27\\\\x22\\\\x5c\");\n+        assert_eq!(\"\\x00\\x01\\xfe\\xff\".escape_unicode(), ~\"\\\\x00\\\\x01\\\\xfe\\\\xff\");\n+        assert_eq!(\"\\u0100\\uffff\".escape_unicode(), ~\"\\\\u0100\\\\uffff\");\n+        assert_eq!(\"\\U00010000\\U0010ffff\".escape_unicode(), ~\"\\\\U00010000\\\\U0010ffff\");\n+        assert_eq!(\"ab\\ufb00\".escape_unicode(), ~\"\\\\x61\\\\x62\\\\ufb00\");\n+        assert_eq!(\"\\U0001d4ea\\r\".escape_unicode(), ~\"\\\\U0001d4ea\\\\x0d\");\n     }\n \n     #[test]\n     fn test_escape_default() {\n-        assert_eq!(escape_default(\"abc\"), ~\"abc\");\n-        assert_eq!(escape_default(\"a c\"), ~\"a c\");\n-        assert_eq!(escape_default(\"\\r\\n\\t\"), ~\"\\\\r\\\\n\\\\t\");\n-        assert_eq!(escape_default(\"'\\\"\\\\\"), ~\"\\\\'\\\\\\\"\\\\\\\\\");\n-        assert_eq!(escape_default(\"\\u0100\\uffff\"), ~\"\\\\u0100\\\\uffff\");\n-        assert!(escape_default(\"\\U00010000\\U0010ffff\") ==\n-            ~\"\\\\U00010000\\\\U0010ffff\");\n-        assert_eq!(escape_default(\"ab\\ufb00\"), ~\"ab\\\\ufb00\");\n-        assert_eq!(escape_default(\"\\U0001d4ea\\r\"), ~\"\\\\U0001d4ea\\\\r\");\n+        assert_eq!(\"abc\".escape_default(), ~\"abc\");\n+        assert_eq!(\"a c\".escape_default(), ~\"a c\");\n+        assert_eq!(\"\\r\\n\\t\".escape_default(), ~\"\\\\r\\\\n\\\\t\");\n+        assert_eq!(\"'\\\"\\\\\".escape_default(), ~\"\\\\'\\\\\\\"\\\\\\\\\");\n+        assert_eq!(\"\\u0100\\uffff\".escape_default(), ~\"\\\\u0100\\\\uffff\");\n+        assert_eq!(\"\\U00010000\\U0010ffff\".escape_default(), ~\"\\\\U00010000\\\\U0010ffff\");\n+        assert_eq!(\"ab\\ufb00\".escape_default(), ~\"ab\\\\ufb00\");\n+        assert_eq!(\"\\U0001d4ea\\r\".escape_default(), ~\"\\\\U0001d4ea\\\\r\");\n     }\n \n     #[test]\n     fn test_to_managed() {\n         assert_eq!(\"abc\".to_managed(), @\"abc\");\n         assert_eq!(\"abcdef\".slice(1, 5).to_managed(), @\"bcde\");\n     }\n+    #[test]\n+    fn test_to_owned() {\n+        assert_eq!(\"abc\".to_owned(), ~\"abc\");\n+        assert_eq!(\"abcdef\".slice(1, 5).to_owned(), ~\"bcde\");\n+    }\n \n     #[test]\n     fn test_total_ord() {"}, {"sha": "c0c8b729f9ea656dd1738485c900aabb4ddbd124", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -18,7 +18,7 @@ use io;\n use io::Writer;\n use option::{None, Option, Some};\n use old_iter::BaseIter;\n-use str;\n+use str::StrSlice;\n \n pub type Cb<'self> = &'self fn(buf: &[u8]) -> bool;\n \n@@ -239,27 +239,25 @@ impl<A:IterBytes> IterBytes for @[A] {\n impl<'self> IterBytes for &'self str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        do str::byte_slice(*self) |bytes| {\n-            f(bytes)\n-        }\n+        f(self.as_bytes())\n     }\n }\n \n impl IterBytes for ~str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        do str::byte_slice(*self) |bytes| {\n-            f(bytes)\n-        }\n+        // this should possibly include the null terminator, but that\n+        // breaks .find_equiv on hashmaps.\n+        f(self.as_bytes())\n     }\n }\n \n impl IterBytes for @str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        do str::byte_slice(*self) |bytes| {\n-            f(bytes)\n-        }\n+        // this should possibly include the null terminator, but that\n+        // breaks .find_equiv on hashmaps.\n+        f(self.as_bytes())\n     }\n }\n "}, {"sha": "7d9ce585d7c5239a0730ef9602e701f81ceff2ff", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -325,7 +325,7 @@ pub mod ct {\n             'o' => TyOctal,\n             'f' => TyFloat,\n             '?' => TyPoly,\n-            _ => err(~\"unknown type in conversion: \" + s.substr(i, 1))\n+            _ => err(fmt!(\"unknown type in conversion: %c\", s.char_at(i)))\n         };\n \n         Parsed::new(t, i + 1)\n@@ -546,7 +546,7 @@ pub mod rt {\n         // displayed\n         let unpadded = match cv.precision {\n           CountImplied => s,\n-          CountIs(max) => if (max as uint) < str::char_len(s) {\n+          CountIs(max) => if (max as uint) < s.char_len() {\n             s.slice(0, max as uint)\n           } else {\n             s\n@@ -584,7 +584,7 @@ pub mod rt {\n                 ~\"\"\n             } else {\n                 let s = uint::to_str_radix(num, radix);\n-                let len = str::char_len(s);\n+                let len = s.char_len();\n                 if len < prec {\n                     let diff = prec - len;\n                     let pad = str::from_chars(vec::from_elem(diff, '0'));\n@@ -614,7 +614,7 @@ pub mod rt {\n             }\n             CountIs(width) => { width as uint }\n         };\n-        let strlen = str::char_len(s) + headsize;\n+        let strlen = s.char_len() + headsize;\n         if uwidth <= strlen {\n             for head.iter().advance |&c| {\n                 buf.push_char(c);"}, {"sha": "52cb20458ea54fe44ca5fa1792ede62589973f2d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -171,11 +171,6 @@ pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n     }\n }\n \n-/// Creates a new unique vector with the same contents as the slice\n-pub fn to_owned<T:Copy>(t: &[T]) -> ~[T] {\n-    from_fn(t.len(), |i| t[i])\n-}\n-\n /// Creates a new vector with a capacity of `capacity`\n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     let mut vec = ~[];\n@@ -1787,7 +1782,7 @@ pub trait CopyableVector<T> {\n \n /// Extension methods for vectors\n impl<'self,T:Copy> CopyableVector<T> for &'self [T] {\n-    /// Returns a copy of `v`.\n+    /// Creates a new unique vector with the same contents as the slice\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n         let mut result = ~[];\n@@ -1796,7 +1791,6 @@ impl<'self,T:Copy> CopyableVector<T> for &'self [T] {\n             result.push(copy *e);\n         }\n         result\n-\n     }\n }\n \n@@ -3361,19 +3355,19 @@ mod tests {\n         let mut results: ~[~[int]];\n \n         results = ~[];\n-        for each_permutation([]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([]) |v| { results.push(v.to_owned()); }\n         assert_eq!(results, ~[~[]]);\n \n         results = ~[];\n-        for each_permutation([7]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([7]) |v| { results.push(v.to_owned()); }\n         assert_eq!(results, ~[~[7]]);\n \n         results = ~[];\n-        for each_permutation([1,1]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([1,1]) |v| { results.push(v.to_owned()); }\n         assert_eq!(results, ~[~[1,1],~[1,1]]);\n \n         results = ~[];\n-        for each_permutation([5,2,0]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([5,2,0]) |v| { results.push(v.to_owned()); }\n         assert!(results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n     }"}, {"sha": "da5874f7b0522f9a04bb41aadcee59d601dd8857", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -259,7 +259,7 @@ pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: &str)\n \n pub fn sort_meta_items(items: &[@ast::meta_item]) -> ~[@ast::meta_item] {\n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let mut v = vec::to_owned(items);\n+    let mut v = items.to_owned();\n     do extra::sort::quick_sort(v) |ma, mb| {\n         get_meta_item_name(*ma) <= get_meta_item_name(*mb)\n     }"}, {"sha": "f9f9f7216a4f6cb1742f0b70fcebc8a454916399", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -21,8 +21,6 @@ use ext::base::*;\n use parse;\n use parse::token;\n \n-use core::vec;\n-\n enum State {\n     Asm,\n     Outputs,\n@@ -45,7 +43,7 @@ pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n                -> base::MacResult {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),\n-                                       vec::to_owned(tts));\n+                                       tts.to_owned());\n \n     let mut asm = ~\"\";\n     let mut outputs = ~[];"}, {"sha": "73f68735bcd35d9d217d5c4feeb44ca2d07f8bfa", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -22,7 +22,6 @@ use parse::token;\n use parse::token::{ident_to_str, intern, str_to_ident};\n \n use core::hashmap::HashMap;\n-use core::vec;\n \n // new-style macro! tt code:\n //\n@@ -367,7 +366,7 @@ pub fn get_exprs_from_tts(cx: @ExtCtxt, tts: &[ast::token_tree])\n                        -> ~[@ast::expr] {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),\n-                                       vec::to_owned(tts));\n+                                       tts.to_owned());\n     let mut es = ~[];\n     while *p.token != token::EOF {\n         if es.len() != 0 {"}, {"sha": "ff8b492c943840ea32338d9f2a7cd7bca025e922", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -18,7 +18,6 @@ use print;\n use parse::token::{get_ident_interner};\n \n use core::io;\n-use core::vec;\n \n pub fn expand_syntax_ext(cx: @ExtCtxt,\n                          sp: codemap::span,\n@@ -28,7 +27,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt,\n     cx.print_backtrace();\n     io::stdout().write_line(\n         print::pprust::tt_to_str(\n-            ast::tt_delim(vec::to_owned(tt)),\n+            ast::tt_delim(tt.to_owned()),\n             get_ident_interner()));\n \n     //trivial expression"}, {"sha": "92727c73977489f5373b4ec49155cf2612bf3556", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -19,8 +19,6 @@ use parse::token::*;\n use parse::token;\n use parse;\n \n-use core::vec;\n-\n /**\n *\n * Quasiquoting works via token trees.\n@@ -40,8 +38,6 @@ pub mod rt {\n     use parse;\n     use print::pprust;\n \n-    use core::str;\n-\n     pub use ast::*;\n     pub use parse::token::*;\n     pub use parse::new_parser_from_tts;\n@@ -128,7 +124,7 @@ pub mod rt {\n \n     impl<'self> ToSource for &'self str {\n         fn to_source(&self) -> ~str {\n-            let lit = dummy_spanned(ast::lit_str(@str::to_owned(*self)));\n+            let lit = dummy_spanned(ast::lit_str(@self.to_owned()));\n             pprust::lit_to_str(@lit)\n         }\n     }\n@@ -661,7 +657,7 @@ fn expand_tts(cx: @ExtCtxt,\n     let p = parse::new_parser_from_tts(\n         cx.parse_sess(),\n         cx.cfg(),\n-        vec::to_owned(tts)\n+        tts.to_owned()\n     );\n     *p.quote_depth += 1u;\n     let tts = p.parse_all_token_trees();"}, {"sha": "09b3fd2343400159b76e84cf171de76116426177", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -18,8 +18,6 @@ use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n use parse::token::keywords;\n \n-use core::vec;\n-\n pub fn expand_trace_macros(cx: @ExtCtxt,\n                            sp: span,\n                            tt: &[ast::token_tree])\n@@ -29,7 +27,7 @@ pub fn expand_trace_macros(cx: @ExtCtxt,\n     let tt_rdr = new_tt_reader(\n         copy cx.parse_sess().span_diagnostic,\n         None,\n-        vec::to_owned(tt)\n+        tt.to_owned()\n     );\n     let rdr = tt_rdr as @reader;\n     let rust_parser = Parser("}, {"sha": "7805e7364677cacc9b883fbb6628fbc37fee467a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -26,7 +26,6 @@ use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt};\n use print;\n \n use core::io;\n-use core::vec;\n \n pub fn add_new_extension(cx: @ExtCtxt,\n                          sp: span,\n@@ -84,7 +83,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n             io::println(fmt!(\"%s! { %s }\",\n                              cx.str_of(name),\n                              print::pprust::tt_to_str(\n-                                 ast::tt_delim(vec::to_owned(arg)),\n+                                 ast::tt_delim(arg.to_owned()),\n                                  get_ident_interner())));\n         }\n \n@@ -101,7 +100,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n                 let arg_rdr = new_tt_reader(\n                     s_d,\n                     None,\n-                    vec::to_owned(arg)\n+                    arg.to_owned()\n                 ) as @reader;\n                 match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n                   success(named_matches) => {"}, {"sha": "91605db77b54adbbd889068c6aa0fc825e3564d5", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -193,7 +193,7 @@ pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n         }\n         body\n       }\n-      LIT_STR(ref s) => { ~\"\\\"\" + str::escape_default(*ident_to_str(s)) + \"\\\"\" }\n+      LIT_STR(ref s) => { ~\"\\\"\" + ident_to_str(s).escape_default() + \"\\\"\" }\n \n       /* Name components */\n       IDENT(s, _) => copy *in.get(s.name),"}, {"sha": "ea33c04dbb5f60bca361d4ad308c48b2476fbd94", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -31,7 +31,6 @@ use print::pprust;\n \n use core::char;\n use core::io;\n-use core::str;\n use core::u64;\n use core::uint;\n use core::iterator::IteratorUtil;\n@@ -2113,7 +2112,7 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n \n pub fn print_string(s: @ps, st: &str) {\n     word(s.s, \"\\\"\");\n-    word(s.s, str::escape_default(st));\n+    word(s.s, st.escape_default());\n     word(s.s, \"\\\"\");\n }\n "}, {"sha": "3d5fc01afa6a287da2a0d953e26e373f59b687b2", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -93,7 +93,7 @@ impl RepeatFasta {\n             let stdout = self.stdout;\n             let alu_len = self.alu.len();\n             let mut buf = vec::from_elem(alu_len + LINE_LEN, 0u8);\n-            let alu: &[u8] = str::byte_slice_no_callback(self.alu);\n+            let alu: &[u8] = self.alu.as_bytes_with_null();\n \n             copy_memory(buf, alu, alu_len);\n             copy_memory(vec::mut_slice(buf, alu_len, buf.len()),"}, {"sha": "b7969fb0552e3e06818c72ff65f020740283ada2", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -81,7 +81,8 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n fn find(mm: &HashMap<~[u8], uint>, key: ~str) -> uint {\n    // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n    // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n-   match mm.find(&str::to_bytes(key.to_ascii().to_lower().to_str_ascii())) {\n+   let key = key.to_ascii().to_lower().to_str_ascii();\n+   match mm.find_equiv(&key.as_bytes()) {\n       option::None      => { return 0u; }\n       option::Some(&num) => { return num; }\n    }\n@@ -208,10 +209,10 @@ fn main() {\n \n          // process the sequence for k-mers\n          (_, true) => {\n-            let line_bytes = str::to_bytes(line);\n+            let line_bytes = line.as_bytes();\n \n            for sizes.eachi |ii, _sz| {\n-               let mut lb = copy line_bytes;\n+               let mut lb = line_bytes.to_owned();\n                to_child[ii].send(lb);\n             }\n          }"}, {"sha": "646b9788f706a7aabc5a5efd04ac833fda10c3b7", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -218,8 +218,7 @@ fn read_stdin() -> ~[u8] {\n         fstat(fileno(stdin), &mut st);\n         let mut buf = vec::from_elem(st.st_size as uint, 0);\n \n-        let header = str::byte_slice_no_callback(\">THREE\");\n-        let header = vec::slice(header, 0, 6);\n+        let header = \">THREE\".as_bytes();\n \n         {\n             let mut window: &mut [u8] = buf;"}, {"sha": "b869aa0e342cbfd6e256cae373451021e01eb8df", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -111,8 +111,7 @@ fn main() {\n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = uint::parse_bytes(str::to_bytes(args[1]),\n-                                                10u).get() as int;\n+        let max = uint::parse_bytes(args[1].as_bytes(), 10u).get() as int;\n \n         let num_trials = 10;\n "}, {"sha": "36ac10915c06f3557595fdefc787c361a9c3dab4", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -26,7 +26,7 @@ mod libc {\n fn strlen(str: ~str) -> uint {\n     unsafe {\n         // C string is terminated with a zero\n-        let bytes = str::to_bytes(str) + ~[0u8];\n+        let bytes = str.as_bytes_with_null_consume();\n         return libc::my_strlen(vec::raw::to_ptr(bytes));\n     }\n }"}, {"sha": "eae2f507c51972aa6ffa81072b30cff5c48c7d2f", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -48,7 +48,7 @@ mod map_reduce {\n             }\n             let (pp, cc) = stream();\n             error!(\"sending find_reducer\");\n-            ctrl.send(find_reducer(str::to_bytes(key), cc));\n+            ctrl.send(find_reducer(key.as_bytes().to_owned(), cc));\n             error!(\"receiving\");\n             let c = pp.recv();\n             error!(c);"}, {"sha": "103679a13eff90e8eddf64ec6105017c99772ce0", "filename": "src/test/run-pass/issue-1696.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1696.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -15,6 +15,6 @@ use std::str;\n \n pub fn main() {\n     let mut m = HashMap::new();\n-    m.insert(str::to_bytes(~\"foo\"), str::to_bytes(~\"bar\"));\n+    m.insert(\"foo\".as_bytes().to_owned(), \"bar\".as_bytes().to_owned());\n     error!(m);\n }"}, {"sha": "42908a339d200dbea1210087747f71cbaeebfaa7", "filename": "src/test/run-pass/struct-order-of-eval-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -14,5 +14,5 @@ struct S { f0: ~str, f1: int }\n \n pub fn main() {\n     let s = ~\"Hello, world!\";\n-    let _s = S { f0: str::to_owned(s), ..S { f0: s, f1: 23 } };\n+    let _s = S { f0: s.to_owned(), ..S { f0: s, f1: 23 } };\n }"}, {"sha": "b6851a728882a94fe4fafe912ef436f7b7722505", "filename": "src/test/run-pass/struct-order-of-eval-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -14,5 +14,5 @@ struct S { f0: ~str, f1: ~str }\n \n pub fn main() {\n     let s = ~\"Hello, world!\";\n-    let _s = S { f1: str::to_owned(s), f0: s };\n+    let _s = S { f1: s.to_owned(), f0: s };\n }"}, {"sha": "c126a84e78227c5e5db672a180cae48b08b5c50d", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc80652e4a627378a36b50fab9e72349129cb56a/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=cc80652e4a627378a36b50fab9e72349129cb56a", "patch": "@@ -21,24 +21,24 @@ pub fn main() {\n     let schs: ~[char] = s.iter().collect();\n \n     assert!(s.len() == 10u);\n-    assert!(str::char_len(s) == 4u);\n+    assert!(s.char_len() == 4u);\n     assert!(schs.len() == 4u);\n     assert!(str::from_chars(schs) == s);\n     assert!(s.char_at(0u) == 'e');\n     assert!(s.char_at(1u) == '\u00e9');\n \n-    assert!((str::is_utf8(str::to_bytes(s))));\n+    assert!((str::is_utf8(s.as_bytes())));\n     assert!((!str::is_utf8(~[0x80_u8])));\n     assert!((!str::is_utf8(~[0xc0_u8])));\n     assert!((!str::is_utf8(~[0xc0_u8, 0x10_u8])));\n \n     let mut stack = ~\"a\u00d7c\u20ac\";\n-    assert_eq!(str::pop_char(&mut stack), '\u20ac');\n-    assert_eq!(str::pop_char(&mut stack), 'c');\n+    assert_eq!(stack.pop_char(), '\u20ac');\n+    assert_eq!(stack.pop_char(), 'c');\n     stack.push_char('u');\n     assert!(stack == ~\"a\u00d7u\");\n-    assert_eq!(str::shift_char(&mut stack), 'a');\n-    assert_eq!(str::shift_char(&mut stack), '\u00d7');\n-    str::unshift_char(&mut stack, '\u00df');\n+    assert_eq!(stack.shift_char(), 'a');\n+    assert_eq!(stack.shift_char(), '\u00d7');\n+    stack.unshift_char('\u00df');\n     assert!(stack == ~\"\u00dfu\");\n }"}]}