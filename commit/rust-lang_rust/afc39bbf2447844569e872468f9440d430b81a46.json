{"sha": "afc39bbf2447844569e872468f9440d430b81a46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYzM5YmJmMjQ0Nzg0NDU2OWU4NzI0NjhmOTQ0MGQ0MzBiODFhNDY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-13T22:32:15Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-14T15:58:32Z"}, "message": "Run `rustfmt --file-lines ...` for changes from previous commits.", "tree": {"sha": "ba1bef6bb7dc8058e219457bdfac702738ab8f58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba1bef6bb7dc8058e219457bdfac702738ab8f58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afc39bbf2447844569e872468f9440d430b81a46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afc39bbf2447844569e872468f9440d430b81a46", "html_url": "https://github.com/rust-lang/rust/commit/afc39bbf2447844569e872468f9440d430b81a46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afc39bbf2447844569e872468f9440d430b81a46/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3f9d6dfd92dfaeb14df891ad27b2531809dd734", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f9d6dfd92dfaeb14df891ad27b2531809dd734", "html_url": "https://github.com/rust-lang/rust/commit/f3f9d6dfd92dfaeb14df891ad27b2531809dd734"}], "stats": {"total": 1972, "additions": 813, "deletions": 1159}, "files": [{"sha": "4f618457d6c6a9773c4bac251572c2a4c16ad136", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -506,12 +506,12 @@ fn stable_non_narrow_char(swc: ::syntax_pos::NonNarrowChar,\n     (pos.0 - source_file_start.0, width as u32)\n }\n \n-\n-\n impl<'tcx> HashStable<StableHashingContext<'tcx>> for feature_gate::Features {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'tcx>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n         // Unfortunately we cannot exhaustively list fields here, since the\n         // struct is macro generated.\n         self.declared_lang_features.hash_stable(hcx, hasher);"}, {"sha": "9b144b1ba3d2ade28403a903ad59c15be1276a54", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -11,9 +11,10 @@ use crate::middle::region;\n use crate::ty;\n use crate::mir;\n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>>\n-for &'tcx ty::List<T>\n-    where T: HashStable<StableHashingContext<'a>> {\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for &'tcx ty::List<T>\n+where\n+    T: HashStable<StableHashingContext<'a>>,\n+{\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -41,7 +42,8 @@ for &'tcx ty::List<T>\n }\n \n impl<'a, 'tcx, T> ToStableHashKey<StableHashingContext<'a>> for &'tcx ty::List<T>\n-    where T: HashStable<StableHashingContext<'a>>\n+where\n+    T: HashStable<StableHashingContext<'a>>,\n {\n     type KeyType = Fingerprint;\n \n@@ -119,18 +121,22 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::ConstVid<'tcx> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n         self.index.hash_stable(hcx, hasher);\n     }\n }\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for ty::BoundVar {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'tcx>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n         self.index().hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "0bb939889a89ab85fdd336765c43c035611d69f4", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -44,11 +44,11 @@ pub struct Trace<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[inline]\n-    pub fn at(&'a self,\n-              cause: &'a ObligationCause<'tcx>,\n-              param_env: ty::ParamEnv<'tcx>)\n-              -> At<'a, 'tcx>\n-    {\n+    pub fn at(\n+        &'a self,\n+        cause: &'a ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> At<'a, 'tcx> {\n         At { infcx: self, cause, param_env }\n     }\n }\n@@ -186,24 +186,19 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     /// error-reporting, but doesn't actually perform any operation\n     /// yet (this is useful when you want to set the trace using\n     /// distinct values from those you wish to operate upon).\n-    pub fn trace<T>(self,\n-                    expected: T,\n-                    actual: T)\n-                    -> Trace<'a, 'tcx>\n-        where T: ToTrace<'tcx>\n+    pub fn trace<T>(self, expected: T, actual: T) -> Trace<'a, 'tcx>\n+    where\n+        T: ToTrace<'tcx>,\n     {\n         self.trace_exp(true, expected, actual)\n     }\n \n     /// Like `trace`, but the expected value is determined by the\n     /// boolean argument (if true, then the first argument `a` is the\n     /// \"expected\" value).\n-    pub fn trace_exp<T>(self,\n-                        a_is_expected: bool,\n-                        a: T,\n-                        b: T)\n-                        -> Trace<'a, 'tcx>\n-        where T: ToTrace<'tcx>\n+    pub fn trace_exp<T>(self, a_is_expected: bool, a: T, b: T) -> Trace<'a, 'tcx>\n+    where\n+        T: ToTrace<'tcx>,\n     {\n         let trace = ToTrace::to_trace(self.cause, a_is_expected, a, b);\n         Trace { at: self, trace: trace, a_is_expected }"}, {"sha": "8b11ebf9b924b7d5af7909c0295ed256355620b4", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -49,8 +49,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     pub fn enter_canonical_trait_query<K, R>(\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'_, 'tcx>, &mut dyn TraitEngine<'tcx>, K)\n-            -> Fallible<R>,\n+        operation: impl FnOnce(&InferCtxt<'_, 'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n@@ -126,7 +125,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     pub fn make_query_response_ignoring_pending_obligations<T>(\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n-        answer: T\n+        answer: T,\n     ) -> Canonical<'tcx, QueryResponse<'tcx, <T as Lift<'tcx>>::Lifted>>\n     where\n         T: Debug + Lift<'tcx> + TypeFoldable<'tcx>,"}, {"sha": "39d8241e6b4273b3b2226dd6dbc7580b8f4f2e27", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -17,9 +17,10 @@ pub struct Equate<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n }\n \n impl<'combine, 'infcx, 'tcx> Equate<'combine, 'infcx, 'tcx> {\n-    pub fn new(fields: &'combine mut CombineFields<'infcx, 'tcx>, a_is_expected: bool)\n-        -> Equate<'combine, 'infcx, 'tcx>\n-    {\n+    pub fn new(\n+        fields: &'combine mut CombineFields<'infcx, 'tcx>,\n+        a_is_expected: bool,\n+    ) -> Equate<'combine, 'infcx, 'tcx> {\n         Equate { fields: fields, a_is_expected: a_is_expected }\n     }\n }"}, {"sha": "362a680f53c9a94771a2238d0648c36f8ec2fca3", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -74,7 +74,6 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n     }\n }\n \n-\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn extract_type_name(\n         &self,\n@@ -102,7 +101,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         body_id: Option<hir::BodyId>,\n         span: Span,\n-        ty: Ty<'tcx>\n+        ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n@@ -229,7 +228,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn need_type_info_err_in_generator(\n         &self,\n         span: Span,\n-        ty: Ty<'tcx>\n+        ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);"}, {"sha": "645f2b023380031aaff0aa6796c00a00be4136f1", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -50,8 +50,7 @@ pub struct TypeFreshener<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>)\n-               -> TypeFreshener<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeFreshener<'a, 'tcx> {\n         TypeFreshener {\n             infcx,\n             ty_freshen_count: 0,"}, {"sha": "7f184d3424f2f69d80e2ac584f07b5a0371507ea", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -14,9 +14,10 @@ pub struct Glb<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n }\n \n impl<'combine, 'infcx, 'tcx> Glb<'combine, 'infcx, 'tcx> {\n-    pub fn new(fields: &'combine mut CombineFields<'infcx, 'tcx>, a_is_expected: bool)\n-        -> Glb<'combine, 'infcx, 'tcx>\n-    {\n+    pub fn new(\n+        fields: &'combine mut CombineFields<'infcx, 'tcx>,\n+        a_is_expected: bool,\n+    ) -> Glb<'combine, 'infcx, 'tcx> {\n         Glb { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n@@ -85,9 +86,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx>\n-    for Glb<'combine, 'infcx, 'tcx>\n-{\n+impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx, 'tcx> {\n     fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'tcx> {\n         self.fields.infcx\n     }"}, {"sha": "c7766636e04e0e5fbf2f3e7c1b4d9071d62ec886", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -41,11 +41,14 @@ pub trait LatticeDir<'f, 'tcx: 'f>: TypeRelation<'tcx> {\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n-pub fn super_lattice_tys<'a, 'tcx, L>(this: &mut L,\n-                                            a: Ty<'tcx>,\n-                                            b: Ty<'tcx>)\n-                                            -> RelateResult<'tcx, Ty<'tcx>>\n-    where L: LatticeDir<'a, 'tcx>, 'tcx: 'a\n+pub fn super_lattice_tys<'a, 'tcx, L>(\n+    this: &mut L,\n+    a: Ty<'tcx>,\n+    b: Ty<'tcx>,\n+) -> RelateResult<'tcx, Ty<'tcx>>\n+where\n+    L: LatticeDir<'a, 'tcx>,\n+    'tcx: 'a,\n {\n     debug!(\"{}.lattice_tys({:?}, {:?})\",\n            this.tag(),"}, {"sha": "aa4bbcad6d5bc5468713d63809e629d71d9a6fb3", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -46,8 +46,8 @@ graphs will be printed.                                                     \\n\\\n \n pub fn maybe_print_constraints_for<'a, 'tcx>(\n     region_data: &RegionConstraintData<'tcx>,\n-    region_rels: &RegionRelations<'a, 'tcx>)\n-{\n+    region_rels: &RegionRelations<'a, 'tcx>,\n+) {\n     let tcx = region_rels.tcx;\n     let context = region_rels.context;\n \n@@ -127,10 +127,11 @@ enum Edge<'tcx> {\n }\n \n impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n-    fn new(name: String,\n-           region_rels: &'a RegionRelations<'a, 'tcx>,\n-           map: &'a ConstraintMap<'tcx>)\n-           -> ConstraintGraph<'a, 'tcx> {\n+    fn new(\n+        name: String,\n+        region_rels: &'a RegionRelations<'a, 'tcx>,\n+        map: &'a ConstraintMap<'tcx>,\n+    ) -> ConstraintGraph<'a, 'tcx> {\n         let mut i = 0;\n         let mut node_ids = FxHashMap::default();\n         {\n@@ -246,10 +247,11 @@ impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n \n pub type ConstraintMap<'tcx> = BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n \n-fn dump_region_data_to<'a, 'tcx>(region_rels: &RegionRelations<'a, 'tcx>,\n-                                       map: &ConstraintMap<'tcx>,\n-                                       path: &str)\n-                                       -> io::Result<()> {\n+fn dump_region_data_to<'a, 'tcx>(\n+    region_rels: &RegionRelations<'a, 'tcx>,\n+    map: &ConstraintMap<'tcx>,\n+    path: &str,\n+) -> io::Result<()> {\n     debug!(\"dump_region_data map (len: {}) path: {}\",\n            map.len(),\n            path);"}, {"sha": "16f5a9d3b36c4944be2937f8af2e3ad48946dc1c", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -33,10 +33,7 @@ pub fn resolve<'tcx>(\n     region_rels: &RegionRelations<'_, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n-) -> (\n-    LexicalRegionResolutions<'tcx>,\n-    Vec<RegionResolutionError<'tcx>>,\n-) {\n+) -> (LexicalRegionResolutions<'tcx>, Vec<RegionResolutionError<'tcx>>) {\n     debug!(\"RegionConstraintData: resolve_regions()\");\n     let mut errors = vec![];\n     let mut resolver = LexicalResolver {"}, {"sha": "2a9f5856eb8552d6b94fe2f7df268184faaa5c2a", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -14,9 +14,10 @@ pub struct Lub<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n }\n \n impl<'combine, 'infcx, 'tcx> Lub<'combine, 'infcx, 'tcx> {\n-    pub fn new(fields: &'combine mut CombineFields<'infcx, 'tcx>, a_is_expected: bool)\n-        -> Lub<'combine, 'infcx, 'tcx>\n-    {\n+    pub fn new(\n+        fields: &'combine mut CombineFields<'infcx, 'tcx>,\n+        a_is_expected: bool,\n+    ) -> Lub<'combine, 'infcx, 'tcx> {\n         Lub { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n@@ -85,9 +86,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx>\n-    for Lub<'combine, 'infcx, 'tcx>\n-{\n+impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx, 'tcx> {\n     fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'tcx> {\n         self.fields.infcx\n     }"}, {"sha": "4b5df444148be3ebe8b154684635e59543ed8de8", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -190,11 +190,8 @@ impl<'a, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     /// contain inference variables, it must be supplied, in which\n     /// case we will register \"givens\" on the inference context. (See\n     /// `RegionConstraintData`.)\n-    fn add_outlives_bounds<I>(\n-        &mut self,\n-        infcx: Option<&InferCtxt<'a, 'tcx>>,\n-        outlives_bounds: I,\n-    ) where\n+    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'a, 'tcx>>, outlives_bounds: I)\n+    where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n         // Record relationships such as `T:'x` that don't go into the"}, {"sha": "810c64185a71d82422caa0e6ff2c113b74dcb7f0", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -105,7 +105,7 @@ pub struct UnresolvedTypeFinder<'a, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n \n     /// Used to find the type parameter name and location for error reporting.\n-    pub first_unresolved: Option<(Ty<'tcx>,Option<Span>)>,\n+    pub first_unresolved: Option<(Ty<'tcx>, Option<Span>)>,\n }\n \n impl<'a, 'tcx> UnresolvedTypeFinder<'a, 'tcx> {\n@@ -157,9 +157,9 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n /// Full type resolution replaces all type and region variables with\n /// their concrete results. If any variable cannot be replaced (never unified, etc)\n /// then an `Err` result is returned.\n-pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        value: &T) -> FixupResult<'tcx, T>\n-    where T : TypeFoldable<'tcx>\n+pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>, value: &T) -> FixupResult<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n {\n     let mut full_resolver = FullTypeResolver { infcx: infcx, err: None };\n     let result = value.fold_with(&mut full_resolver);"}, {"sha": "ed84e3f63ae1b80e5770f0271544d8a1c36c7bc0", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -17,9 +17,10 @@ pub struct Sub<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n }\n \n impl<'combine, 'infcx, 'tcx> Sub<'combine, 'infcx, 'tcx> {\n-    pub fn new(f: &'combine mut CombineFields<'infcx, 'tcx>, a_is_expected: bool)\n-        -> Sub<'combine, 'infcx, 'tcx>\n-    {\n+    pub fn new(\n+        f: &'combine mut CombineFields<'infcx, 'tcx>,\n+        a_is_expected: bool,\n+    ) -> Sub<'combine, 'infcx, 'tcx> {\n         Sub { fields: f, a_is_expected: a_is_expected }\n     }\n "}, {"sha": "468d909e5497b89de34ef38bb590f66dc3957b58", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -1456,10 +1456,7 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tc\n     })\n }\n \n-fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx>,\n-    builtin_lints: T,\n-) {\n+fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n     let mut passes = tcx.sess.lint_store.borrow().late_passes.lock().take().unwrap();\n \n     if !tcx.sess.opts.debugging_opts.no_interleave_lints {"}, {"sha": "d9e7caebb982992a0281e5cc9ea68f72f0461584", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -140,10 +140,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n     }\n }\n \n-fn configure_main(\n-    tcx: TyCtxt<'_>,\n-    visitor: &EntryContext<'_, '_>,\n-) -> Option<(DefId, EntryFnType)> {\n+fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(DefId, EntryFnType)> {\n     if let Some((hir_id, _)) = visitor.start_fn {\n         Some((tcx.hir().local_def_id_from_hir_id(hir_id), EntryFnType::Start))\n     } else if let Some((hir_id, _)) = visitor.attr_main_fn {"}, {"sha": "202788093046acf35ce508e660af3eb3487df4bb", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -52,11 +52,7 @@ impl<'tcx> ExportedSymbol<'tcx> {\n         }\n     }\n \n-    pub fn compare_stable(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        other: &ExportedSymbol<'tcx>,\n-    ) -> cmp::Ordering {\n+    pub fn compare_stable(&self, tcx: TyCtxt<'tcx>, other: &ExportedSymbol<'tcx>) -> cmp::Ordering {\n         match *self {\n             ExportedSymbol::NonGeneric(self_def_id) => match *other {\n                 ExportedSymbol::NonGeneric(other_def_id) => {"}, {"sha": "61770e6f4870510a2821824e3770221120ed21a7", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -288,14 +288,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n-    pub fn with_infer(delegate: &'a mut (dyn Delegate<'tcx>+'a),\n-                      infcx: &'a InferCtxt<'a, 'tcx>,\n-                      body_owner: DefId,\n-                      param_env: ty::ParamEnv<'tcx>,\n-                      region_scope_tree: &'a region::ScopeTree,\n-                      tables: &'a ty::TypeckTables<'tcx>)\n-                      -> Self\n-    {\n+    pub fn with_infer(\n+        delegate: &'a mut (dyn Delegate<'tcx> + 'a),\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        body_owner: DefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        region_scope_tree: &'a region::ScopeTree,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+    ) -> Self {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::with_infer(\n                 infcx,\n@@ -974,12 +974,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     }\n }\n \n-fn copy_or_move<'a, 'tcx>(mc: &mc::MemCategorizationContext<'a, 'tcx>,\n-                                param_env: ty::ParamEnv<'tcx>,\n-                                cmt: &mc::cmt_<'tcx>,\n-                                move_reason: MoveReason)\n-                                -> ConsumeMode\n-{\n+fn copy_or_move<'a, 'tcx>(\n+    mc: &mc::MemCategorizationContext<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cmt: &mc::cmt_<'tcx>,\n+    move_reason: MoveReason,\n+) -> ConsumeMode {\n     if !mc.type_is_copy_modulo_regions(param_env, cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {"}, {"sha": "3b21b81df7b434bc51e6a7867d3f773fc9f79e28", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -432,11 +432,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ///   temporaries may be overly conservative;\n     /// - similarly, as the results of upvar analysis are not yet\n     ///   known, the results around upvar accesses may be incorrect.\n-    pub fn with_infer(infcx: &'a InferCtxt<'a, 'tcx>,\n-                      body_owner: DefId,\n-                      region_scope_tree: &'a region::ScopeTree,\n-                      tables: &'a ty::TypeckTables<'tcx>)\n-                      -> MemCategorizationContext<'a, 'tcx> {\n+    pub fn with_infer(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        body_owner: DefId,\n+        region_scope_tree: &'a region::ScopeTree,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+    ) -> MemCategorizationContext<'a, 'tcx> {\n         let tcx = infcx.tcx;\n \n         // Subtle: we can't do rvalue promotion analysis until the\n@@ -586,10 +587,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n-        fn helper<'a, 'tcx>(mc: &MemCategorizationContext<'a, 'tcx>,\n-                                  expr: &hir::Expr,\n-                                  adjustments: &[adjustment::Adjustment<'tcx>])\n-                                  -> McResult<cmt_<'tcx>> {\n+        fn helper<'a, 'tcx>(\n+            mc: &MemCategorizationContext<'a, 'tcx>,\n+            expr: &hir::Expr,\n+            adjustments: &[adjustment::Adjustment<'tcx>],\n+        ) -> McResult<cmt_<'tcx>> {\n             match adjustments.split_last() {\n                 None => mc.cat_expr_unadjusted(expr),\n                 Some((adjustment, previous)) => {"}, {"sha": "8b1eeeb7f51b72e649111026020f95f4e53f6ecb", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -646,11 +646,7 @@ impl<'tcx> ScopeTree {\n \n     /// Assuming that the provided region was defined within this `ScopeTree`,\n     /// returns the outermost `Scope` that the region outlives.\n-    pub fn early_free_scope(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        br: &ty::EarlyBoundRegion,\n-    ) -> Scope {\n+    pub fn early_free_scope(&self, tcx: TyCtxt<'tcx>, br: &ty::EarlyBoundRegion) -> Scope {\n         let param_owner = tcx.parent(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();"}, {"sha": "8bc3158bd3c7de3fdd9d8f441f05c1257b9719e1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -1125,12 +1125,7 @@ fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_>, params: &P<[hir::Gener\n     }\n }\n \n-fn signal_shadowing_problem(\n-    tcx: TyCtxt<'_>,\n-    name: ast::Name,\n-    orig: Original,\n-    shadower: Shadower,\n-) {\n+fn signal_shadowing_problem(tcx: TyCtxt<'_>, name: ast::Name, orig: Original, shadower: Shadower) {\n     let mut err = if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n         // lifetime/lifetime shadowing is an error\n         struct_span_err!("}, {"sha": "afabcdfadd03c15de8fce7d45954a6bc165a2543", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -234,12 +234,7 @@ impl<'tcx> Operand<'tcx> {\n }\n \n impl<'tcx> BinOp {\n-    pub fn ty(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        lhs_ty: Ty<'tcx>,\n-        rhs_ty: Ty<'tcx>,\n-    ) -> Ty<'tcx> {\n+    pub fn ty(&self, tcx: TyCtxt<'tcx>, lhs_ty: Ty<'tcx>, rhs_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // FIXME: handle SIMD correctly\n         match self {\n             &BinOp::Add | &BinOp::Sub | &BinOp::Mul | &BinOp::Div | &BinOp::Rem |"}, {"sha": "0c7c94b684a9fc43ec98825ec36dd5e80fc75d84", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -30,7 +30,7 @@ impl FulfillmentContext<'tcx> {\n \n fn in_environment(\n     infcx: &InferCtxt<'_, 'tcx>,\n-    obligation: PredicateObligation<'tcx>\n+    obligation: PredicateObligation<'tcx>,\n ) -> InEnvironment<'tcx, PredicateObligation<'tcx>> {\n     assert!(!infcx.is_in_snapshot());\n     let obligation = infcx.resolve_vars_if_possible(&obligation);"}, {"sha": "bb4095333f19db96bc17894e2f426d2f00c5eced", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -116,7 +116,7 @@ impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n // # Global Cache\n \n pub struct ProjectionCache<'tcx> {\n-    data: PhantomData<&'tcx ()>\n+    data: PhantomData<&'tcx ()>,\n }\n \n impl<'tcx> DepTrackingMapConfig for ProjectionCache<'tcx> {\n@@ -137,11 +137,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// type inference variables that appear in `result` to be\n     /// unified, and hence we need to process those obligations to get\n     /// the complete picture of the type.\n-    fn drain_fulfillment_cx_or_panic<T>(&self,\n-                                        fulfill_cx: &mut FulfillmentContext<'tcx>,\n-                                        result: &T)\n-                                        -> T::Lifted\n-        where T: TypeFoldable<'tcx> + ty::Lift<'tcx>\n+    fn drain_fulfillment_cx_or_panic<T>(\n+        &self,\n+        fulfill_cx: &mut FulfillmentContext<'tcx>,\n+        result: &T,\n+    ) -> T::Lifted\n+    where\n+        T: TypeFoldable<'tcx> + ty::Lift<'tcx>,\n     {\n         debug!(\"drain_fulfillment_cx_or_panic()\");\n "}, {"sha": "d8087af60acdf3abe8be2523ff50822434cde0d4", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -87,11 +87,11 @@ where\n     })\n }\n \n-fn with_fresh_ty_vars<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n-                                       param_env: ty::ParamEnv<'tcx>,\n-                                       impl_def_id: DefId)\n-                                       -> ty::ImplHeader<'tcx>\n-{\n+fn with_fresh_ty_vars<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    impl_def_id: DefId,\n+) -> ty::ImplHeader<'tcx> {\n     let tcx = selcx.tcx();\n     let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n "}, {"sha": "42bde3563492f497df085dc35ddb340f6ae84273", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -1249,10 +1249,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         expected_ref: ty::PolyTraitRef<'tcx>,\n         found: ty::PolyTraitRef<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n-        fn build_fn_sig_string<'tcx>(\n-            tcx: TyCtxt<'tcx>,\n-            trait_ref: &ty::TraitRef<'tcx>,\n-        ) -> String {\n+        fn build_fn_sig_string<'tcx>(tcx: TyCtxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n             let sig = if let ty::Tuple(inputs) = inputs.sty {\n                 tcx.mk_fn_sig(\n@@ -1456,7 +1453,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> bool {\n         struct ParamToVarFolder<'a, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'tcx>,\n-            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n+            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n         }\n \n         impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx> {"}, {"sha": "5e2c949c7d8d60a35acb0e45a038ef78a62092b7", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -95,8 +95,10 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     /// Attempts to select obligations using `selcx`.\n-    fn select(&mut self, selcx: &mut SelectionContext<'a, 'tcx>)\n-              -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+    fn select(\n+        &mut self,\n+        selcx: &mut SelectionContext<'a, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n         debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n \n         let mut errors = Vec::new();\n@@ -143,13 +145,13 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     /// `SomeTrait` or a where-clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n-    fn normalize_projection_type(&mut self,\n-                                 infcx: &InferCtxt<'_, 'tcx>,\n-                                 param_env: ty::ParamEnv<'tcx>,\n-                                 projection_ty: ty::ProjectionTy<'tcx>,\n-                                 cause: ObligationCause<'tcx>)\n-                                 -> Ty<'tcx>\n-    {\n+    fn normalize_projection_type(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+    ) -> Ty<'tcx> {\n         debug!(\"normalize_projection_type(projection_ty={:?})\",\n                projection_ty);\n \n@@ -172,10 +174,11 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         normalized_ty\n     }\n \n-    fn register_predicate_obligation(&mut self,\n-                                     infcx: &InferCtxt<'_, 'tcx>,\n-                                     obligation: PredicateObligation<'tcx>)\n-    {\n+    fn register_predicate_obligation(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    ) {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n         let obligation = infcx.resolve_vars_if_possible(&obligation);\n@@ -192,9 +195,8 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n     fn select_all_or_error(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>\n-    ) -> Result<(),Vec<FulfillmentError<'tcx>>>\n-    {\n+        infcx: &InferCtxt<'_, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n         self.select_where_possible(infcx)?;\n \n         let errors: Vec<_> =\n@@ -209,10 +211,10 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         }\n     }\n \n-    fn select_where_possible(&mut self,\n-                             infcx: &InferCtxt<'_, 'tcx>)\n-                             -> Result<(),Vec<FulfillmentError<'tcx>>>\n-    {\n+    fn select_where_possible(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n         let mut selcx = SelectionContext::new(infcx);\n         self.select(&mut selcx)\n     }\n@@ -224,7 +226,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n struct FulfillProcessor<'a, 'b: 'a, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    register_region_obligations: bool\n+    register_region_obligations: bool,\n }\n \n fn mk_pending(os: Vec<PredicateObligation<'tcx>>) -> Vec<PendingPredicateObligation<'tcx>> {\n@@ -514,9 +516,10 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n }\n \n /// Returns the set of type variables contained in a trait ref\n-fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n-                                       t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n-{\n+fn trait_ref_type_vars<'a, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'tcx>,\n+    t: ty::PolyTraitRef<'tcx>,\n+) -> Vec<Ty<'tcx>> {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n      .input_types()\n      .map(|t| selcx.infcx().resolve_vars_if_possible(&t))"}, {"sha": "f5c91a77517cdc2e676f2b6a67b627de22013fcb", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -909,9 +909,10 @@ pub fn fully_normalize<'a, 'tcx, T>(\n     mut fulfill_cx: FulfillmentContext<'tcx>,\n     cause: ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    value: &T)\n-    -> Result<T, Vec<FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx>\n+    value: &T,\n+) -> Result<T, Vec<FulfillmentError<'tcx>>>\n+where\n+    T: TypeFoldable<'tcx>,\n {\n     debug!(\"fully_normalize_with_fulfillcx(value={:?})\", value);\n     let selcx = &mut SelectionContext::new(infcx);"}, {"sha": "d189bb231163eadfe377447f6fc7d4d96c774961", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 73, "deletions": 86, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -185,10 +185,8 @@ impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n /// the projection cache key used to track these additional obligations.\n pub fn poly_project_and_unify_type<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &PolyProjectionObligation<'tcx>)\n-    -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n-              MismatchedProjectionTypes<'tcx>>\n-{\n+    obligation: &PolyProjectionObligation<'tcx>,\n+) -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>> {\n     debug!(\"poly_project_and_unify_type(obligation={:?})\",\n            obligation);\n \n@@ -212,10 +210,8 @@ pub fn poly_project_and_unify_type<'cx, 'tcx>(\n /// If successful, this may result in additional obligations.\n fn project_and_unify_type<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionObligation<'tcx>)\n-    -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n-              MismatchedProjectionTypes<'tcx>>\n-{\n+    obligation: &ProjectionObligation<'tcx>,\n+) -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>> {\n     debug!(\"project_and_unify_type(obligation={:?})\",\n            obligation);\n \n@@ -253,12 +249,14 @@ fn project_and_unify_type<'cx, 'tcx>(\n /// them with a fully resolved type where possible. The return value\n /// combines the normalized result and any additional obligations that\n /// were incurred as result.\n-pub fn normalize<'a, 'b, 'tcx, T>(selcx: &'a mut SelectionContext<'b, 'tcx>,\n-                                        param_env: ty::ParamEnv<'tcx>,\n-                                        cause: ObligationCause<'tcx>,\n-                                        value: &T)\n-                                        -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx>\n+pub fn normalize<'a, 'b, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    value: &T,\n+) -> Normalized<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n {\n     normalize_with_depth(selcx, param_env, cause, 0, value)\n }\n@@ -269,10 +267,10 @@ pub fn normalize_with_depth<'a, 'b, 'tcx, T>(\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n-    value: &T)\n-    -> Normalized<'tcx, T>\n-\n-    where T : TypeFoldable<'tcx>\n+    value: &T,\n+) -> Normalized<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n {\n     debug!(\"normalize_with_depth(depth={}, value={:?})\", depth, value);\n     let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth);\n@@ -296,12 +294,12 @@ struct AssocTypeNormalizer<'a, 'b: 'a, 'tcx: 'b> {\n }\n \n impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n-    fn new(selcx: &'a mut SelectionContext<'b, 'tcx>,\n-           param_env: ty::ParamEnv<'tcx>,\n-           cause: ObligationCause<'tcx>,\n-           depth: usize)\n-           -> AssocTypeNormalizer<'a, 'b, 'tcx>\n-    {\n+    fn new(\n+        selcx: &'a mut SelectionContext<'b, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        depth: usize,\n+    ) -> AssocTypeNormalizer<'a, 'b, 'tcx> {\n         AssocTypeNormalizer {\n             selcx,\n             param_env,\n@@ -462,9 +460,8 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n-    obligations: &mut Vec<PredicateObligation<'tcx>>)\n-    -> Ty<'tcx>\n-{\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> Ty<'tcx> {\n     opt_normalize_projection_type(selcx, param_env, projection_ty.clone(), cause.clone(), depth,\n                                   obligations)\n         .unwrap_or_else(move || {\n@@ -507,9 +504,8 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n-    obligations: &mut Vec<PredicateObligation<'tcx>>)\n-    -> Option<Ty<'tcx>>\n-{\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> Option<Ty<'tcx>> {\n     let infcx = selcx.infcx();\n \n     let projection_ty = infcx.resolve_vars_if_possible(&projection_ty);\n@@ -705,9 +701,10 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n /// If there are unresolved type variables, then we need to include\n /// any subobligations that bind them, at least until those type\n /// variables are fully resolved.\n-fn prune_cache_value_obligations<'a, 'tcx>(infcx: &'a InferCtxt<'a, 'tcx>,\n-                                                 result: &NormalizedTy<'tcx>)\n-                                                 -> NormalizedTy<'tcx> {\n+fn prune_cache_value_obligations<'a, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    result: &NormalizedTy<'tcx>,\n+) -> NormalizedTy<'tcx> {\n     if infcx.unresolved_type_vars(&result.value).is_none() {\n         return NormalizedTy { value: result.value, obligations: vec![] };\n     }\n@@ -768,9 +765,8 @@ fn get_paranoid_cache_value_obligation<'a, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: usize)\n-    -> PredicateObligation<'tcx>\n-{\n+    depth: usize,\n+) -> PredicateObligation<'tcx> {\n     let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n     Obligation {\n         cause,\n@@ -799,13 +795,13 @@ fn get_paranoid_cache_value_obligation<'a, 'tcx>(\n /// an error for this obligation, but we legitimately should not,\n /// because it contains `[type error]`. Yuck! (See issue #29857 for\n /// one case where this arose.)\n-fn normalize_to_error<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n-                                      param_env: ty::ParamEnv<'tcx>,\n-                                      projection_ty: ty::ProjectionTy<'tcx>,\n-                                      cause: ObligationCause<'tcx>,\n-                                      depth: usize)\n-                                      -> NormalizedTy<'tcx>\n-{\n+fn normalize_to_error<'a, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    projection_ty: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+) -> NormalizedTy<'tcx> {\n     let trait_ref = projection_ty.trait_ref(selcx.tcx()).to_poly_trait_ref();\n     let trait_obligation = Obligation { cause,\n                                         recursion_depth: depth,\n@@ -863,9 +859,8 @@ impl<'tcx> Progress<'tcx> {\n /// - `obligation` must be fully normalized\n fn project_type<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>)\n-    -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>>\n-{\n+    obligation: &ProjectionTyObligation<'tcx>,\n+) -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>> {\n     debug!(\"project(obligation={:?})\",\n            obligation);\n \n@@ -929,8 +924,8 @@ fn assemble_candidates_from_param_env<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-{\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+) {\n     debug!(\"assemble_candidates_from_param_env(..)\");\n     assemble_candidates_from_predicates(selcx,\n                                         obligation,\n@@ -954,8 +949,8 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-{\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+) {\n     debug!(\"assemble_candidates_from_trait_def(..)\");\n \n     let tcx = selcx.tcx();\n@@ -992,8 +987,9 @@ fn assemble_candidates_from_predicates<'cx, 'tcx, I>(\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n-    env_predicates: I)\n-    where I: IntoIterator<Item=ty::Predicate<'tcx>>\n+    env_predicates: I,\n+) where\n+    I: IntoIterator<Item = ty::Predicate<'tcx>>,\n {\n     debug!(\"assemble_candidates_from_predicates(obligation={:?})\",\n            obligation);\n@@ -1033,8 +1029,8 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-{\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+) {\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n     let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n@@ -1181,9 +1177,8 @@ fn confirm_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate: ProjectionTyCandidate<'tcx>)\n-    -> Progress<'tcx>\n-{\n+    candidate: ProjectionTyCandidate<'tcx>,\n+) -> Progress<'tcx> {\n     debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\",\n            candidate,\n            obligation);\n@@ -1204,9 +1199,8 @@ fn confirm_select_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    vtable: Selection<'tcx>)\n-    -> Progress<'tcx>\n-{\n+    vtable: Selection<'tcx>,\n+) -> Progress<'tcx> {\n     match vtable {\n         super::VtableImpl(data) =>\n             confirm_impl_candidate(selcx, obligation, data),\n@@ -1232,10 +1226,9 @@ fn confirm_select_candidate<'cx, 'tcx>(\n \n fn confirm_object_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>)\n-    -> Progress<'tcx>\n-{\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+) -> Progress<'tcx> {\n     let self_ty = obligation_trait_ref.self_ty();\n     let object_ty = selcx.infcx().shallow_resolve(self_ty);\n     debug!(\"confirm_object_candidate(object_ty={:?})\",\n@@ -1298,9 +1291,8 @@ fn confirm_object_candidate<'cx, 'tcx>(\n fn confirm_generator_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>)\n-    -> Progress<'tcx>\n-{\n+    vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n     let gen_sig = vtable.substs.poly_sig(vtable.generator_def_id, selcx.tcx());\n     let Normalized {\n         value: gen_sig,\n@@ -1351,9 +1343,8 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>)\n-    -> Progress<'tcx>\n-{\n+    fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n     let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized {\n@@ -1373,9 +1364,8 @@ fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n fn confirm_closure_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>)\n-    -> Progress<'tcx>\n-{\n+    vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n     let infcx = selcx.infcx();\n     let closure_sig_ty = vtable.substs.closure_sig_ty(vtable.closure_def_id, tcx);\n@@ -1406,9 +1396,8 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_sig: ty::PolyFnSig<'tcx>,\n-    flag: util::TupleArgumentsFlag)\n-    -> Progress<'tcx>\n-{\n+    flag: util::TupleArgumentsFlag,\n+) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n \n     debug!(\"confirm_callable_candidate({:?},{:?})\",\n@@ -1481,9 +1470,8 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n fn confirm_impl_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n-    -> Progress<'tcx>\n-{\n+    impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n     let VtableImplData { impl_def_id, substs, nested } = impl_vtable;\n \n     let tcx = selcx.tcx();\n@@ -1524,9 +1512,8 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n fn assoc_ty_def<'cx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'tcx>,\n     impl_def_id: DefId,\n-    assoc_ty_def_id: DefId)\n-    -> specialization_graph::NodeItem<ty::AssocItem>\n-{\n+    assoc_ty_def_id: DefId,\n+) -> specialization_graph::NodeItem<ty::AssocItem> {\n     let tcx = selcx.tcx();\n     let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n@@ -1609,10 +1596,10 @@ pub struct ProjectionCacheKey<'tcx> {\n }\n \n impl<'cx, 'tcx> ProjectionCacheKey<'tcx> {\n-    pub fn from_poly_projection_predicate(selcx: &mut SelectionContext<'cx, 'tcx>,\n-                                          predicate: &ty::PolyProjectionPredicate<'tcx>)\n-                                          -> Option<Self>\n-    {\n+    pub fn from_poly_projection_predicate(\n+        selcx: &mut SelectionContext<'cx, 'tcx>,\n+        predicate: &ty::PolyProjectionPredicate<'tcx>,\n+    ) -> Option<Self> {\n         let infcx = selcx.infcx();\n         // We don't do cross-snapshot caching of obligations with escaping regions,\n         // so there's no cache key to use"}, {"sha": "b298edfec594432d1a06b58699b58f0bf53a66a0", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -44,9 +44,7 @@ pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n /// which produces the resulting query region constraints.\n ///\n /// [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n-pub trait QueryTypeOp<'tcx>:\n-    fmt::Debug + Sized + TypeFoldable<'tcx> + Lift<'tcx>\n-{\n+pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + Lift<'tcx> {\n     type QueryResponse: TypeFoldable<'tcx> + Lift<'tcx>;\n \n     /// Give query the option for a simple fast path that never"}, {"sha": "3d47e94fb007c8c883103e39994ca355d2499637", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -69,12 +69,13 @@ pub struct OverlapError {\n /// through associated type projection. We deal with such cases by using\n /// *fulfillment* to relate the two impls, requiring that all projections are\n /// resolved.\n-pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        param_env: ty::ParamEnv<'tcx>,\n-                                        source_impl: DefId,\n-                                        source_substs: SubstsRef<'tcx>,\n-                                        target_node: specialization_graph::Node)\n-                                        -> SubstsRef<'tcx> {\n+pub fn translate_substs<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    source_impl: DefId,\n+    source_substs: SubstsRef<'tcx>,\n+    target_node: specialization_graph::Node,\n+) -> SubstsRef<'tcx> {\n     debug!(\"translate_substs({:?}, {:?}, {:?}, {:?})\",\n            param_env, source_impl, source_substs, target_node);\n     let source_trait_ref = infcx.tcx\n@@ -209,11 +210,12 @@ pub(super) fn specializes<'tcx>(\n /// generics of `target_impl`, including both those needed to unify with\n /// `source_trait_ref` and those whose identity is determined via a where\n /// clause in the impl.\n-fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                       param_env: ty::ParamEnv<'tcx>,\n-                                       source_trait_ref: ty::TraitRef<'tcx>,\n-                                       target_impl: DefId)\n-                                       -> Result<SubstsRef<'tcx>, ()> {\n+fn fulfill_implication<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    source_trait_ref: ty::TraitRef<'tcx>,\n+    target_impl: DefId,\n+) -> Result<SubstsRef<'tcx>, ()> {\n     debug!(\"fulfill_implication({:?}, trait_ref={:?} |- {:?} applies)\",\n            param_env, source_trait_ref, target_impl);\n "}, {"sha": "f736c5ef9b1c0fefb7f5c224332e1512870ac22e", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -383,12 +383,7 @@ impl<'tcx> Graph {\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    pub fn record_impl_from_cstore(\n-        &mut self,\n-        tcx: TyCtxt<'tcx>,\n-        parent: DefId,\n-        child: DefId,\n-    ) {\n+    pub fn record_impl_from_cstore(&mut self, tcx: TyCtxt<'tcx>, parent: DefId, child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\"When recording an impl from the crate store, information about its parent \\\n                   was already present.\");"}, {"sha": "b6a1ab9fe709a376eb29cff155d59ba2630eaaad", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -12,10 +12,7 @@ use crate::util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n-fn anonymize_predicate<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    pred: &ty::Predicate<'tcx>,\n-) -> ty::Predicate<'tcx> {\n+fn anonymize_predicate<'tcx>(tcx: TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n     match *pred {\n         ty::Predicate::Trait(ref data) =>\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data)),\n@@ -420,10 +417,7 @@ pub struct SupertraitDefIds<'tcx> {\n     visited: FxHashSet<DefId>,\n }\n \n-pub fn supertrait_def_ids<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_def_id: DefId,\n-) -> SupertraitDefIds<'tcx> {\n+pub fn supertrait_def_ids<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> SupertraitDefIds<'tcx> {\n     SupertraitDefIds {\n         tcx,\n         stack: vec![trait_def_id],\n@@ -489,13 +483,12 @@ impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<\n /// Instantiate all bound parameters of the impl with the given substs,\n /// returning the resulting trait ref and all obligations that arise.\n /// The obligations are closed under normalization.\n-pub fn impl_trait_ref_and_oblig<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n-                                                param_env: ty::ParamEnv<'tcx>,\n-                                                impl_def_id: DefId,\n-                                                impl_substs: SubstsRef<'tcx>,)\n-                                                -> (ty::TraitRef<'tcx>,\n-                                                    Vec<PredicateObligation<'tcx>>)\n-{\n+pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    impl_def_id: DefId,\n+    impl_substs: SubstsRef<'tcx>,\n+) -> (ty::TraitRef<'tcx>, Vec<PredicateObligation<'tcx>>) {\n     let impl_trait_ref =\n         selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n     let impl_trait_ref ="}, {"sha": "9ba99768215a692ea2729c4d0779430b21f55dde", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -104,11 +104,7 @@ pub struct OverloadedDeref<'tcx> {\n }\n \n impl<'tcx> OverloadedDeref<'tcx> {\n-    pub fn method_call(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        source: Ty<'tcx>,\n-    ) -> (DefId, SubstsRef<'tcx>) {\n+    pub fn method_call(&self, tcx: TyCtxt<'tcx>, source: Ty<'tcx>) -> (DefId, SubstsRef<'tcx>) {\n         let trait_def_id = match self.mutbl {\n             hir::MutImmutable => tcx.lang_items().deref_trait(),\n             hir::MutMutable => tcx.lang_items().deref_mut_trait()"}, {"sha": "e5d06532b3a169408589991ebfaa4bc9fa4acfc9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n     fn intern_ty(\n         local: &CtxtInterners<'tcx>,\n         global: &CtxtInterners<'tcx>,\n-        st: TyKind<'tcx>\n+        st: TyKind<'tcx>,\n     ) -> Ty<'tcx> {\n         let flags = super::flags::FlagComputation::for_sty(&st);\n \n@@ -857,7 +857,6 @@ BraceStructLiftImpl! {\n     }\n }\n \n-\n /// Canonicalized user type annotation.\n pub type CanonicalUserType<'tcx> = Canonical<'tcx, UserType<'tcx>>;\n \n@@ -1139,12 +1138,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.arena.alloc(Steal::new(mir))\n     }\n \n-    pub fn alloc_adt_def(self,\n-                         did: DefId,\n-                         kind: AdtKind,\n-                         variants: IndexVec<VariantIdx, ty::VariantDef>,\n-                         repr: ReprOptions)\n-                         -> &'tcx ty::AdtDef {\n+    pub fn alloc_adt_def(\n+        self,\n+        did: DefId,\n+        kind: AdtKind,\n+        variants: IndexVec<VariantIdx, ty::VariantDef>,\n+        repr: ReprOptions,\n+    ) -> &'tcx ty::AdtDef {\n         let def = ty::AdtDef::new(self, did, kind, variants, repr);\n         self.arena.alloc(def)\n     }\n@@ -1923,9 +1923,9 @@ pub mod tls {\n \n     /// Sets `context` as the new current ImplicitCtxt for the duration of the function `f`\n     #[inline]\n-    pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>,\n-                                                     f: F) -> R\n-        where F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R\n+    pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n+    where\n+        F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n     {\n         set_tlv(context as *const _ as usize, || {\n             f(&context)\n@@ -1999,7 +1999,8 @@ pub mod tls {\n     /// Allows access to the current ImplicitCtxt in a closure if one is available\n     #[inline]\n     pub fn with_context_opt<F, R>(f: F) -> R\n-        where F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R\n+    where\n+        F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n     {\n         let context = get_tlv();\n         if context == 0 {\n@@ -2017,7 +2018,8 @@ pub mod tls {\n     /// Panics if there is no ImplicitCtxt available\n     #[inline]\n     pub fn with_context<F, R>(f: F) -> R\n-        where F: for<'a, 'tcx> FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R\n+    where\n+        F: for<'a, 'tcx> FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n     {\n         with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n     }\n@@ -2254,14 +2256,14 @@ impl<'tcx> Borrow<GoalKind<'tcx>> for Interned<'tcx, GoalKind<'tcx>> {\n }\n \n impl<'tcx> Borrow<[ExistentialPredicate<'tcx>]>\n-    for Interned<'tcx, List<ExistentialPredicate<'tcx>>> {\n+    for Interned<'tcx, List<ExistentialPredicate<'tcx>>>\n+{\n     fn borrow<'a>(&'a self) -> &'a [ExistentialPredicate<'tcx>] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx> Borrow<[Predicate<'tcx>]>\n-    for Interned<'tcx, List<Predicate<'tcx>>> {\n+impl<'tcx> Borrow<[Predicate<'tcx>]> for Interned<'tcx, List<Predicate<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Predicate<'tcx>] {\n         &self.0[..]\n     }\n@@ -2273,15 +2275,13 @@ impl<'tcx> Borrow<Const<'tcx>> for Interned<'tcx, Const<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<[Clause<'tcx>]>\n-for Interned<'tcx, List<Clause<'tcx>>> {\n+impl<'tcx> Borrow<[Clause<'tcx>]> for Interned<'tcx, List<Clause<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Clause<'tcx>] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx> Borrow<[Goal<'tcx>]>\n-for Interned<'tcx, List<Goal<'tcx>>> {\n+impl<'tcx> Borrow<[Goal<'tcx>]> for Interned<'tcx, List<Goal<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Goal<'tcx>] {\n         &self.0[..]\n     }\n@@ -2942,9 +2942,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             .unwrap_or(false)\n     }\n \n-    pub fn object_lifetime_defaults(self, id: HirId)\n-        -> Option<&'tcx [ObjectLifetimeDefault]>\n-    {\n+    pub fn object_lifetime_defaults(self, id: HirId) -> Option<&'tcx [ObjectLifetimeDefault]> {\n         self.object_lifetime_defaults_map(id.owner)\n             .and_then(|map| map.get(&id.local_id).map(|v| &**v))\n     }"}, {"sha": "8b98a2916a76693b13c6de3042a714023f73c621", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -443,12 +443,7 @@ struct BoundVarReplacer<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> BoundVarReplacer<'a, 'tcx> {\n-    fn new<F, G, H>(\n-        tcx: TyCtxt<'tcx>,\n-        fld_r: &'a mut F,\n-        fld_t: &'a mut G,\n-        fld_c: &'a mut H,\n-    ) -> Self\n+    fn new<F, G, H>(tcx: TyCtxt<'tcx>, fld_r: &'a mut F, fld_t: &'a mut G, fld_c: &'a mut H) -> Self\n     where\n         F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n         G: FnMut(ty::BoundTy) -> Ty<'tcx>,"}, {"sha": "6cee2709b636da0309dabcbf4358d9b214bbfeda", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -2443,23 +2443,26 @@ impl_stable_hash_for!(struct crate::ty::layout::AbiAndPrefAlign {\n });\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for Align {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'tcx>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n         self.bytes().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for Size {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'tcx>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n         self.bytes().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx>\n-{\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {"}, {"sha": "c932586c078bde19d3aa955e8dddd35843085195", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -975,11 +975,7 @@ impl<'tcx> Generics {\n     }\n \n     /// Returns the `GenericParamDef` associated with this `ParamTy`.\n-    pub fn type_param(\n-        &'tcx self,\n-        param: &ParamTy,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> &'tcx GenericParamDef {\n+    pub fn type_param(&'tcx self, param: &ParamTy, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n@@ -993,11 +989,7 @@ impl<'tcx> Generics {\n     }\n \n     /// Returns the `ConstParameterDef` associated with this `ParamConst`.\n-    pub fn const_param(\n-        &'tcx self,\n-        param: &ParamConst,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> &GenericParamDef {\n+    pub fn const_param(&'tcx self, param: &ParamConst, tcx: TyCtxt<'tcx>) -> &GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n@@ -1772,7 +1764,8 @@ impl<'tcx, T> ParamEnvAnd<'tcx, T> {\n }\n \n impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for ParamEnvAnd<'tcx, T>\n-    where T: HashStable<StableHashingContext<'a>>\n+where\n+    T: HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -2363,11 +2356,7 @@ impl<'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn eval_explicit_discr(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        expr_did: DefId,\n-    ) -> Option<Discr<'tcx>> {\n+    pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n         let param_env = ParamEnv::empty();\n         let repr_type = self.repr.discr_type();\n         let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), expr_did);\n@@ -2714,7 +2703,7 @@ impl BorrowKind {\n #[derive(Debug, Clone)]\n pub enum Attributes<'tcx> {\n     Owned(Lrc<[ast::Attribute]>),\n-    Borrowed(&'tcx [ast::Attribute])\n+    Borrowed(&'tcx [ast::Attribute]),\n }\n \n impl<'tcx> ::std::ops::Deref for Attributes<'tcx> {\n@@ -3007,9 +2996,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n-    pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>)\n-                        -> &'tcx Body<'tcx>\n-    {\n+    pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n         match instance {\n             ty::InstanceDef::Item(did) => {\n                 self.optimized_mir(did)\n@@ -3300,10 +3287,7 @@ fn crate_hash<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> Svh {\n     tcx.hir().crate_hash\n }\n \n-fn instance_def_size_estimate<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    instance_def: InstanceDef<'tcx>,\n-) -> usize {\n+fn instance_def_size_estimate<'tcx>(tcx: TyCtxt<'tcx>, instance_def: InstanceDef<'tcx>) -> usize {\n     match instance_def {\n         InstanceDef::Item(..) |\n         InstanceDef::DropGlue(..) => {"}, {"sha": "092e7c6f3fffb6050dfacaa407836d2bef119660", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -326,9 +326,7 @@ impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx, P: Printer<'tcx>> Print<'tcx, P>\n-    for &'tcx ty::List<ty::ExistentialPredicate<'tcx>>\n-{\n+impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     type Output = P::DynExistential;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {"}, {"sha": "16fb334803926fd2359cf150187976179cdd4690", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -23,11 +23,7 @@ pub struct DefPathBasedNames<'tcx> {\n }\n \n impl DefPathBasedNames<'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        omit_disambiguators: bool,\n-        omit_local_crate_name: bool,\n-    ) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, omit_disambiguators: bool, omit_local_crate_name: bool) -> Self {\n         DefPathBasedNames { tcx, omit_disambiguators, omit_local_crate_name }\n     }\n "}, {"sha": "b79d7f06cd6aa85444f40000ba1cffd37791611f", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -167,15 +167,15 @@ impl RegionHighlightMode {\n \n /// Trait for printers that pretty-print using `fmt::Write` to the printer.\n pub trait PrettyPrinter<'tcx>:\n-    Printer<'tcx,\n+    Printer<\n+        'tcx,\n         Error = fmt::Error,\n         Path = Self,\n         Region = Self,\n         Type = Self,\n         DynExistential = Self,\n         Const = Self,\n-    > +\n-    fmt::Write\n+    > + fmt::Write\n {\n     /// Like `print_def_path` but for value paths.\n     fn print_value_path(\n@@ -186,21 +186,17 @@ pub trait PrettyPrinter<'tcx>:\n         self.print_def_path(def_id, substs)\n     }\n \n-    fn in_binder<T>(\n-        self,\n-        value: &ty::Binder<T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+    fn in_binder<T>(self, value: &ty::Binder<T>) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n     {\n         value.skip_binder().print(self)\n     }\n \n     /// Print comma-separated elements.\n-    fn comma_sep<T>(\n-        mut self,\n-        mut elems: impl Iterator<Item = T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, Self, Output = Self, Error = Self::Error>\n+    fn comma_sep<T>(mut self, mut elems: impl Iterator<Item = T>) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error>,\n     {\n         if let Some(first) = elems.next() {\n             self = first.print(self)?;\n@@ -1239,11 +1235,9 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         Ok(self)\n     }\n \n-    fn in_binder<T>(\n-        self,\n-        value: &ty::Binder<T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+    fn in_binder<T>(self, value: &ty::Binder<T>) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n     {\n         self.pretty_in_binder(value)\n     }\n@@ -1417,11 +1411,9 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n // HACK(eddyb) limited to `FmtPrinter` because of `binder_depth`,\n // `region_index` and `used_region_names`.\n impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n-    pub fn pretty_in_binder<T>(\n-        mut self,\n-        value: &ty::Binder<T>,\n-    ) -> Result<Self, fmt::Error>\n-        where T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>\n+    pub fn pretty_in_binder<T>(mut self, value: &ty::Binder<T>) -> Result<Self, fmt::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>,\n     {\n         fn name_by_region_index(index: usize) -> InternedString {\n             match index {\n@@ -1510,9 +1502,9 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n     }\n }\n \n-impl<'tcx, T, P: PrettyPrinter<'tcx>> Print<'tcx, P>\n-    for ty::Binder<T>\n-    where T: Print<'tcx, P, Output = P, Error = P::Error> + TypeFoldable<'tcx>\n+impl<'tcx, T, P: PrettyPrinter<'tcx>> Print<'tcx, P> for ty::Binder<T>\n+where\n+    T: Print<'tcx, P, Output = P, Error = P::Error> + TypeFoldable<'tcx>,\n {\n     type Output = P;\n     type Error = P::Error;\n@@ -1521,10 +1513,10 @@ impl<'tcx, T, P: PrettyPrinter<'tcx>> Print<'tcx, P>\n     }\n }\n \n-impl<'tcx, T, U, P: PrettyPrinter<'tcx>> Print<'tcx, P>\n-    for ty::OutlivesPredicate<T, U>\n-    where T: Print<'tcx, P, Output = P, Error = P::Error>,\n-          U: Print<'tcx, P, Output = P, Error = P::Error>,\n+impl<'tcx, T, U, P: PrettyPrinter<'tcx>> Print<'tcx, P> for ty::OutlivesPredicate<T, U>\n+where\n+    T: Print<'tcx, P, Output = P, Error = P::Error>,\n+    U: Print<'tcx, P, Output = P, Error = P::Error>,\n {\n     type Output = P;\n     type Error = P::Error;"}, {"sha": "dcc467a61b5416fbed4ba659c1e193be1dd9069c", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -100,11 +100,7 @@ impl<'tcx> QueryJob<'tcx> {\n     }\n \n     #[cfg(not(parallel_compiler))]\n-    pub(super) fn find_cycle_in_stack(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        span: Span,\n-    ) -> CycleError<'tcx> {\n+    pub(super) fn find_cycle_in_stack(&self, tcx: TyCtxt<'tcx>, span: Span) -> CycleError<'tcx> {\n         // Get the current executing query (waiter) and find the waitee amongst its parents\n         let mut current_job = tls::with_related_context(tcx, |icx| icx.query.clone());\n         let mut cycle = Vec::new();"}, {"sha": "6f83991a2daa2b331ca7932517f65c9096fd5ef6", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -156,11 +156,7 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn serialize<'tcx, E>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        encoder: &mut E,\n-    ) -> Result<(), E::Error>\n+    pub fn serialize<'tcx, E>(&self, tcx: TyCtxt<'tcx>, encoder: &mut E) -> Result<(), E::Error>\n     where\n         E: ty_codec::TyEncoder,\n     {"}, {"sha": "48e68167f824c5e3af0531ce582aae5f2fc8b933", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -104,11 +104,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    pub(super) fn try_get(\n-        tcx: TyCtxt<'tcx>,\n-        span: Span,\n-        key: &Q::Key,\n-    ) -> TryGetJob<'a, 'tcx, Q> {\n+    pub(super) fn try_get(tcx: TyCtxt<'tcx>, span: Span, key: &Q::Key) -> TryGetJob<'a, 'tcx, Q> {\n         let cache = Q::query_cache(tcx);\n         loop {\n             let mut lock = cache.borrow_mut();\n@@ -351,11 +347,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline(never)]\n-    pub(super) fn get_query<Q: QueryDescription<'tcx>>(\n-        self,\n-        span: Span,\n-        key: Q::Key)\n-    -> Q::Value {\n+    pub(super) fn get_query<Q: QueryDescription<'tcx>>(self, span: Span, key: Q::Key) -> Q::Value {\n         debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\",\n                Q::NAME.as_str(),\n                key,\n@@ -444,9 +436,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         key: Q::Key,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node_index: DepNodeIndex,\n-        dep_node: &DepNode\n-    ) -> Q::Value\n-    {\n+        dep_node: &DepNode,\n+    ) -> Q::Value {\n         // Note this function can be called concurrently from the same query\n         // We must ensure that this is handled correctly\n \n@@ -537,8 +528,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         key: Q::Key,\n         job: JobOwner<'_, 'tcx, Q>,\n-        dep_node: DepNode)\n-    -> (Q::Value, DepNodeIndex) {\n+        dep_node: DepNode,\n+    ) -> (Q::Value, DepNodeIndex) {\n         // If the following assertion triggers, it can have two reasons:\n         // 1. Something is wrong with DepNode creation, either here or\n         //    in DepGraph::try_mark_green()\n@@ -623,12 +614,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[allow(dead_code)]\n-    fn force_query<Q: QueryDescription<'tcx>>(\n-        self,\n-        key: Q::Key,\n-        span: Span,\n-        dep_node: DepNode\n-    ) {\n+    fn force_query<Q: QueryDescription<'tcx>>(self, key: Q::Key, span: Span, dep_node: DepNode) {\n         profq_msg!(\n             self,\n             ProfileQueriesMsg::QueryBegin(span.data(),"}, {"sha": "a4efb566e13e885ed91c0581579fe56b142c56b0", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -804,7 +804,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n     }\n }\n \n-impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n+impl<'tcx, T: TypeFoldable<'tcx>, U: TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n@@ -862,7 +862,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n     }\n }\n \n-impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         self.map_bound_ref(|ty| ty.fold_with(folder))\n     }"}, {"sha": "810a26d373648ee254230b3ba08434f86607b64f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -558,11 +558,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// This is the types of the fields of a generator which are not stored in a\n     /// variant.\n     #[inline]\n-    pub fn prefix_tys(\n-        self,\n-        def_id: DefId,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl Iterator<Item = Ty<'tcx>> {\n+    pub fn prefix_tys(self, def_id: DefId, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = Ty<'tcx>> {\n         self.upvar_tys(def_id, tcx)\n     }\n }\n@@ -2265,11 +2261,7 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn from_bits(\n-        tcx: TyCtxt<'tcx>,\n-        bits: u128,\n-        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> &'tcx Self {\n+    pub fn from_bits(tcx: TyCtxt<'tcx>, bits: u128, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> &'tcx Self {\n         let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).unwrap_or_else(|e| {\n             panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n@@ -2308,11 +2300,7 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn assert_bits(\n-        &self,\n-        tcx: TyCtxt<'_>,\n-        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Option<u128> {\n+    pub fn assert_bits(&self, tcx: TyCtxt<'_>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n         assert_eq!(self.ty, ty.value);\n         let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).ok()?.size;"}, {"sha": "79dcd327f52d4882af0ec38840ab37bb06855d1c", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -241,12 +241,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n         tcx.intern_substs(&substs)\n     }\n \n-    pub fn extend_to<F>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        mut mk_kind: F,\n-    ) -> SubstsRef<'tcx>\n+    pub fn extend_to<F>(&self, tcx: TyCtxt<'tcx>, def_id: DefId, mut mk_kind: F) -> SubstsRef<'tcx>\n     where\n         F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n     {\n@@ -418,21 +413,11 @@ pub trait Subst<'tcx>: Sized {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: &[Kind<'tcx>],\n-        span: Option<Span>,\n-    ) -> Self;\n+    fn subst_spanned(&self, tcx: TyCtxt<'tcx>, substs: &[Kind<'tcx>], span: Option<Span>) -> Self;\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n-    fn subst_spanned(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: &[Kind<'tcx>],\n-        span: Option<Span>,\n-    ) -> T {\n+    fn subst_spanned(&self, tcx: TyCtxt<'tcx>, substs: &[Kind<'tcx>], span: Option<Span>) -> T {\n         let mut folder = SubstFolder { tcx,\n                                        substs,\n                                        span,"}, {"sha": "a3b99f143d055ea7a9d729082d64cc1fc19fac6e", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -105,11 +105,7 @@ impl<'tcx> Discr<'tcx> {\n \n pub trait IntTypeExt {\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n-    fn disr_incr<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        val: Option<Discr<'tcx>>,\n-    ) -> Option<Discr<'tcx>>;\n+    fn disr_incr<'tcx>(&self, tcx: TyCtxt<'tcx>, val: Option<Discr<'tcx>>) -> Option<Discr<'tcx>>;\n     fn initial_discriminant<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Discr<'tcx>;\n }\n \n@@ -138,11 +134,7 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn disr_incr<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        val: Option<Discr<'tcx>>,\n-    ) -> Option<Discr<'tcx>> {\n+    fn disr_incr<'tcx>(&self, tcx: TyCtxt<'tcx>, val: Option<Discr<'tcx>>) -> Option<Discr<'tcx>> {\n         if let Some(val) = val {\n             assert_eq!(self.to_ty(tcx), val.ty);\n             let (new, oflo) = val.checked_add(tcx, 1);\n@@ -714,11 +706,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// over-approximation in generic contexts, where one can have\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n-    pub fn is_sized(\n-        &'tcx self,\n-        tcx_at: TyCtxtAt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n+    pub fn is_sized(&'tcx self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         tcx_at.is_sized_raw(param_env.and(self))\n     }\n \n@@ -979,10 +967,7 @@ fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n #[derive(Clone, HashStable)]\n pub struct NeedsDrop(pub bool);\n \n-fn needs_drop_raw<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-) -> NeedsDrop {\n+fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n     let (param_env, ty) = query.into_parts();\n \n     let needs_drop = |ty: Ty<'tcx>| -> bool {"}, {"sha": "6b2f00e5f703fd18b8ca57cf940b2e09d4ff087c", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -15,13 +15,13 @@ use crate::mir::interpret::ConstValue;\n /// inference variable, returns `None`, because we are not able to\n /// make any progress at all. This is to prevent \"livelock\" where we\n /// say \"$0 is WF if $0 is WF\".\n-pub fn obligations<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                   param_env: ty::ParamEnv<'tcx>,\n-                                   body_id: hir::HirId,\n-                                   ty: Ty<'tcx>,\n-                                   span: Span)\n-                                   -> Option<Vec<traits::PredicateObligation<'tcx>>>\n-{\n+pub fn obligations<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body_id: hir::HirId,\n+    ty: Ty<'tcx>,\n+    span: Span,\n+) -> Option<Vec<traits::PredicateObligation<'tcx>>> {\n     let mut wf = WfPredicates { infcx,\n                                 param_env,\n                                 body_id,\n@@ -41,25 +41,25 @@ pub fn obligations<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n /// well-formed.  For example, if there is a trait `Set` defined like\n /// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n /// if `Bar: Eq`.\n-pub fn trait_obligations<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                         param_env: ty::ParamEnv<'tcx>,\n-                                         body_id: hir::HirId,\n-                                         trait_ref: &ty::TraitRef<'tcx>,\n-                                         span: Span)\n-                                         -> Vec<traits::PredicateObligation<'tcx>>\n-{\n+pub fn trait_obligations<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body_id: hir::HirId,\n+    trait_ref: &ty::TraitRef<'tcx>,\n+    span: Span,\n+) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n     wf.compute_trait_ref(trait_ref, Elaborate::All);\n     wf.normalize()\n }\n \n-pub fn predicate_obligations<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                             param_env: ty::ParamEnv<'tcx>,\n-                                             body_id: hir::HirId,\n-                                             predicate: &ty::Predicate<'tcx>,\n-                                             span: Span)\n-                                             -> Vec<traits::PredicateObligation<'tcx>>\n-{\n+pub fn predicate_obligations<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body_id: hir::HirId,\n+    predicate: &ty::Predicate<'tcx>,\n+    span: Span,\n+) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n \n     // (*) ok to skip binders, because wf code is prepared for it"}, {"sha": "a0dd767a3a8ff7625c13616b7b375ff26a8b1e78", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -125,11 +125,7 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n     ) {\n         unsafe { allocator::codegen(tcx, mods, kind) }\n     }\n-    fn compile_codegen_unit<'a, 'tcx: 'a>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        cgu_name: InternedString,\n-    ) {\n+    fn compile_codegen_unit<'a, 'tcx: 'a>(&self, tcx: TyCtxt<'tcx>, cgu_name: InternedString) {\n         base::compile_codegen_unit(tcx, cgu_name);\n     }\n     fn target_machine_factory("}, {"sha": "8f0bb6ee1983730f9eabdb4d1c2cb0452a0455d0", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -210,12 +210,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n         }\n     }\n \n-    fn push_item_name(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        qualified: bool,\n-        output: &mut String,\n-    ) {\n+    fn push_item_name(tcx: TyCtxt<'tcx>, def_id: DefId, qualified: bool, output: &mut String) {\n         if qualified {\n             output.push_str(&tcx.crate_name(def_id.krate).as_str());\n             for path_element in tcx.def_path(def_id).data {"}, {"sha": "22b7e0a2fb0c929619b19a971a760802ac4538c4", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -367,11 +367,9 @@ impl PrettyPrinter<'tcx> for SymbolPrinter<'tcx> {\n     ) -> bool {\n         false\n     }\n-    fn comma_sep<T>(\n-        mut self,\n-        mut elems: impl Iterator<Item = T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, Self, Output = Self, Error = Self::Error>\n+    fn comma_sep<T>(mut self, mut elems: impl Iterator<Item = T>) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error>,\n     {\n         if let Some(first) = elems.next() {\n             self = first.print(self)?;"}, {"sha": "a43347a2197c3735d055bd260dca268aeddbe259", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -184,11 +184,7 @@ impl Visitor<'tcx> for IfThisChanged<'tcx> {\n     }\n }\n \n-fn check_paths<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    if_this_changed: &Sources,\n-    then_this_would_need: &Targets,\n-) {\n+fn check_paths<'tcx>(tcx: TyCtxt<'tcx>, if_this_changed: &Sources, then_this_would_need: &Targets) {\n     // Return early here so as not to construct the query, which is not cheap.\n     if if_this_changed.is_empty() {\n         for &(target_span, _, _, _) in then_this_would_need {"}, {"sha": "69cb696f4c580a3cb667dda3dd051591a840d3a5", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -811,7 +811,7 @@ pub fn create_global_ctxt(\n     resolutions: Resolutions,\n     outputs: OutputFilenames,\n     tx: mpsc::Sender<Box<dyn Any + Send>>,\n-    crate_name: &str\n+    crate_name: &str,\n ) -> BoxedGlobalCtxt {\n     let sess = compiler.session().clone();\n     let cstore = compiler.cstore.clone();"}, {"sha": "4bafe16b8e66d4130e38c3288db97b9763950c87", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -620,7 +620,7 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates.unwrap().decode((self, tcx))\n-    }\n+}\n \n     pub fn get_predicates_defined_on(\n         &self,\n@@ -701,19 +701,12 @@ impl<'a, 'tcx> CrateMetadata {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    pub fn get_impl_trait(\n-        &self,\n-        id: DefIndex,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<ty::TraitRef<'tcx>> {\n+    pub fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n         self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    pub fn get_lib_features(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n+    pub fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root\n@@ -883,11 +876,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn maybe_get_optimized_mir(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        id: DefIndex,\n-    ) -> Option<Body<'tcx>> {\n+    pub fn maybe_get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Option<Body<'tcx>> {\n         match self.is_proc_macro(id) {\n             true => None,\n             false => self.entry(id).mir.map(|mir| mir.decode((self, tcx))),"}, {"sha": "161a08c5773e7b2ae11be8db44ff943381f6f6a0", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -1511,12 +1511,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    fn check_activations(\n-        &mut self,\n-        location: Location,\n-        span: Span,\n-        flow_state: &Flows<'cx, 'tcx>,\n-    ) {\n+    fn check_activations(&mut self, location: Location, span: Span, flow_state: &Flows<'cx, 'tcx>) {\n         // Two-phase borrow support: For each activation that is newly\n         // generated at this statement, check if it interferes with\n         // another borrow.\n@@ -2034,11 +2029,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n     }\n \n-    fn is_local_ever_initialized(&self,\n-                                 local: Local,\n-                                 flow_state: &Flows<'cx, 'tcx>)\n-                                 -> Option<InitIndex>\n-    {\n+    fn is_local_ever_initialized(\n+        &self,\n+        local: Local,\n+        flow_state: &Flows<'cx, 'tcx>,\n+    ) -> Option<InitIndex> {\n         let mpi = self.move_data.rev_lookup.find_local(local);\n         let ii = &self.move_data.init_path_map[mpi];\n         for &index in ii {\n@@ -2050,11 +2045,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// Adds the place into the used mutable variables set\n-    fn add_used_mut<'d>(\n-        &mut self,\n-        root_place: RootPlace<'d, 'tcx>,\n-        flow_state: &Flows<'cx, 'tcx>,\n-    ) {\n+    fn add_used_mut<'d>(&mut self, root_place: RootPlace<'d, 'tcx>, flow_state: &Flows<'cx, 'tcx>) {\n         match root_place {\n             RootPlace {\n                 place: Place::Base(PlaceBase::Local(local)),"}, {"sha": "6ce925cc7d12a342e37af2cc8d723121b9e44a99", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -33,11 +33,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Search the upvars (if any) to find one that references fr. Return its index.\n-    crate fn get_upvar_index_for_region(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        fr: RegionVid,\n-    ) -> Option<usize> {\n+    crate fn get_upvar_index_for_region(&self, tcx: TyCtxt<'tcx>, fr: RegionVid) -> Option<usize> {\n         let upvar_index = self\n             .universal_regions\n             .defining_ty\n@@ -134,5 +130,4 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         (argument_name, argument_span)\n     }\n-\n }"}, {"sha": "c1d1185cf177ad7fa4461cad12d263ffdcf30b08", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -16,10 +16,7 @@ pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, 'tcx>, body: &mut Body<'tcx>) {\n \n /// Replaces all regions appearing in `value` with fresh inference\n /// variables.\n-pub fn renumber_regions<'tcx, T>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n-    value: &T,\n-) -> T\n+pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'_, 'tcx>, value: &T) -> T\n where\n     T: TypeFoldable<'tcx>,\n {"}, {"sha": "d86702773e3f5adf141ac1a96bb620780047f5df", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -150,9 +150,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx>\n-    for &'a mut ConstraintConversion<'b, 'tcx>\n-{\n+impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'b, 'tcx> {\n     fn push_sub_region_constraint(\n         &mut self,\n         _origin: SubregionOrigin<'tcx>,"}, {"sha": "b35bcc09a235b7872fb542e450849a5923fb3045", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -36,7 +36,6 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n     }\n }\n \n-\n pub(super) struct Prefixes<'cx, 'tcx: 'cx> {\n     body: &'cx Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n@@ -60,11 +59,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Returns an iterator over the prefixes of `place`\n     /// (inclusive) from longest to smallest, potentially\n     /// terminating the iteration early based on `kind`.\n-    pub(super) fn prefixes(\n-        &self,\n-        place: &'cx Place<'tcx>,\n-        kind: PrefixSet,\n-    ) -> Prefixes<'cx, 'tcx> {\n+    pub(super) fn prefixes(&self, place: &'cx Place<'tcx>, kind: PrefixSet) -> Prefixes<'cx, 'tcx> {\n         Prefixes {\n             next: Some(place),\n             kind,"}, {"sha": "50d9bbf4cc324c0e23d2a03c0b95ea76e7f82bb0", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -70,11 +70,7 @@ pub struct MaybeInitializedPlaces<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> MaybeInitializedPlaces<'a, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'a Body<'tcx>,\n-        mdpe: &'a MoveDataParamEnv<'tcx>,\n-    ) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n         MaybeInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n@@ -125,11 +121,7 @@ pub struct MaybeUninitializedPlaces<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> MaybeUninitializedPlaces<'a, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'a Body<'tcx>,\n-        mdpe: &'a MoveDataParamEnv<'tcx>,\n-    ) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n         MaybeUninitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n@@ -179,11 +171,7 @@ pub struct DefinitelyInitializedPlaces<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> DefinitelyInitializedPlaces<'a, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'a Body<'tcx>,\n-        mdpe: &'a MoveDataParamEnv<'tcx>,\n-    ) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n         DefinitelyInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n@@ -228,11 +216,7 @@ pub struct EverInitializedPlaces<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> EverInitializedPlaces<'a, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'a Body<'tcx>,\n-        mdpe: &'a MoveDataParamEnv<'tcx>,\n-    ) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n         EverInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n@@ -241,7 +225,6 @@ impl<'a, 'tcx> HasMoveData<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-\n impl<'a, 'tcx> MaybeInitializedPlaces<'a, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<'_, MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)"}, {"sha": "7740042c783fce12aac1ec9c6cee2e5b58c5c1c8", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -52,8 +52,7 @@ pub struct Cx<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Cx<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>,\n-               src_id: hir::HirId) -> Cx<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>, src_id: hir::HirId) -> Cx<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let src_def_id = tcx.hir().local_def_id_from_hir_id(src_id);\n         let tables = tcx.typeck_tables_of(src_def_id);"}, {"sha": "5ca3531c98bb1b91a9c581adc2abe4f8af548d11", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -174,11 +174,9 @@ impl PrettyPrinter<'tcx> for AbsolutePathPrinter<'tcx> {\n     ) -> bool {\n         false\n     }\n-    fn comma_sep<T>(\n-        mut self,\n-        mut elems: impl Iterator<Item = T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, Self, Output = Self, Error = Self::Error>\n+    fn comma_sep<T>(mut self, mut elems: impl Iterator<Item = T>) -> Result<Self, Self::Error>\n+    where\n+        T: Print<'tcx, Self, Output = Self, Error = Self::Error>,\n     {\n         if let Some(first) = elems.next() {\n             self = first.print(self)?;"}, {"sha": "e530c56ed6f3a5916bd98f1de9f4355a2697a1a0", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -315,10 +315,7 @@ pub fn collect_crate_mono_items<'tcx>(\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n-fn collect_roots<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mode: MonoItemCollectionMode,\n-) -> Vec<MonoItem<'tcx>> {\n+fn collect_roots<'tcx>(tcx: TyCtxt<'tcx>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'tcx>> {\n     debug!(\"Collecting roots\");\n     let mut roots = Vec::new();\n \n@@ -1188,11 +1185,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n }\n \n /// Scan the miri alloc in order to find function calls, closures, and drop-glue\n-fn collect_miri<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    alloc_id: AllocId,\n-    output: &mut Vec<MonoItem<'tcx>>,\n-) {\n+fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<MonoItem<'tcx>>) {\n     let alloc_kind = tcx.alloc_map.lock().get(alloc_id);\n     match alloc_kind {\n         Some(GlobalAlloc::Static(def_id)) => {"}, {"sha": "a821cb2cfdad275858cd64ea84cecac86d3112df", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -203,10 +203,7 @@ struct PostInliningPartitioning<'tcx> {\n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n-fn place_root_mono_items<'tcx, I>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_items: I,\n-) -> PreInliningPartitioning<'tcx>\n+fn place_root_mono_items<'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I) -> PreInliningPartitioning<'tcx>\n where\n     I: Iterator<Item = MonoItem<'tcx>>,\n {"}, {"sha": "f5a22ea09315f107ec1a10fcea3d0502f9655aaa", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -163,11 +163,7 @@ fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>, span: Span)\n         .collect()\n }\n \n-fn build_drop_shim<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    ty: Option<Ty<'tcx>>,\n-) -> Body<'tcx> {\n+fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>) -> Body<'tcx> {\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n     // Check if this is a generator, if so, return the drop glue for it"}, {"sha": "c08c33bc6ff8b078855cd0906215970939eb2f38", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -31,12 +31,7 @@ pub use self::AddCallGuards::*;\n  */\n \n impl MirPass for AddCallGuards {\n-    fn run_pass<'tcx>(\n-        &self,\n-        _tcx: TyCtxt<'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         self.add_call_guards(body);\n     }\n }"}, {"sha": "a111669f149821f856fe21a46621574a197f576d", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -46,11 +46,7 @@ impl MirPass for AddMovesForPackedDrops {\n     }\n }\n \n-pub fn add_moves_for_packed_drops<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &mut Body<'tcx>,\n-    def_id: DefId,\n-) {\n+pub fn add_moves_for_packed_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, def_id: DefId) {\n     let patch = add_moves_for_packed_drops_patch(tcx, body, def_id);\n     patch.apply(body);\n }"}, {"sha": "ee040bf65901ce5a570b6f6a2402ff22c4a59bc3", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -74,12 +74,7 @@ fn may_have_reference<'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> bool {\n }\n \n impl MirPass for AddRetag {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;\n         }"}, {"sha": "6ee14160bbd1b1e73dfd96e10d1a6db3f2337935", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -27,12 +27,7 @@ pub struct CleanupNonCodegenStatements;\n pub struct DeleteNonCodegenStatements;\n \n impl MirPass for CleanupNonCodegenStatements {\n-    fn run_pass<'tcx>(\n-        &self,\n-        _tcx: TyCtxt<'tcx>,\n-        _source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut delete = DeleteNonCodegenStatements;\n         delete.visit_body(body);\n     }"}, {"sha": "2ec5c192726b0e3d0cafb24478b02698ec2fb932", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -31,12 +31,7 @@ use crate::transform::{MirPass, MirSource};\n pub struct ConstProp;\n \n impl MirPass for ConstProp {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n             return;"}, {"sha": "c850b48e074ab4af211f4480c7864d190cf2faa5", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -30,12 +30,7 @@ use crate::util::def_use::DefUseAnalysis;\n pub struct CopyPropagation;\n \n impl MirPass for CopyPropagation {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        _source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {"}, {"sha": "1b42a0dffb8941f194255bbaa1f3493f86226678", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -6,12 +6,7 @@ use crate::util::expand_aggregate;\n pub struct Deaggregator;\n \n impl MirPass for Deaggregator {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        _source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {"}, {"sha": "243820ba7d0278cd4ce347e227999e55d886c873", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -18,12 +18,7 @@ impl MirPass for Marker {\n         Cow::Borrowed(self.0)\n     }\n \n-    fn run_pass<'tcx>(\n-        &self,\n-        _tcx: TyCtxt<'tcx>,\n-        _source: MirSource<'tcx>,\n-        _body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body: &mut Body<'tcx>) {\n     }\n }\n "}, {"sha": "9c7aedc12a27b7887e211be0258627d6ea4c4e16", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -1092,12 +1092,7 @@ where\n }\n \n impl MirPass for StateTransform {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let yield_ty = if let Some(yield_ty) = body.yield_ty {\n             yield_ty\n         } else {"}, {"sha": "1cbdc2a2de26ef918b43112cb4666fb3fd1da228", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -38,12 +38,7 @@ struct CallSite<'tcx> {\n }\n \n impl MirPass for Inline {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n             Inliner { tcx, source }.run_pass(body);\n         }"}, {"sha": "f0aa189804f7de338010f953b9011e7d736037a0", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -10,12 +10,7 @@ use crate::transform::{MirPass, MirSource};\n pub struct Lower128Bit;\n \n impl MirPass for Lower128Bit {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let debugging_override = tcx.sess.opts.debugging_opts.lower_128bit_ops;\n         let target_default = tcx.sess.host.options.i128_lowering;\n         if !debugging_override.unwrap_or(target_default) {"}, {"sha": "04dce326e69de1edc1354772331b48d19f7c5a54", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -141,12 +141,7 @@ pub trait MirPass {\n         default_name::<Self>()\n     }\n \n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    );\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>);\n }\n \n pub fn run_passes("}, {"sha": "7b3cdc835ebb1231307e6b974c93b73694ea986a", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -19,12 +19,7 @@ pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>)\n }\n \n impl MirPass for RemoveNoopLandingPads {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         remove_noop_landing_pads(tcx, body);\n     }\n }"}, {"sha": "ac15f52d9ec5b17a60b48f391d5c6ea61e12032c", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -57,12 +57,7 @@ impl MirPass for SimplifyCfg {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass<'tcx>(\n-        &self,\n-        _tcx: TyCtxt<'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n         simplify_cfg(body);\n     }"}, {"sha": "0c63a8d9c96b1ad2446fed71ec0178563c48f796", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -19,12 +19,7 @@ impl MirPass for SimplifyBranches {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {"}, {"sha": "90b52b76155db3497aed872ed889d5317748f5ba", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -37,12 +37,7 @@ use crate::util::patch::MirPatch;\n pub struct UniformArrayMoveOut;\n \n impl MirPass for UniformArrayMoveOut {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);\n         {\n             let mut visitor = UniformArrayMoveOutVisitor{body, patch: &mut patch, tcx};\n@@ -164,12 +159,7 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n pub struct RestoreSubsliceArrayMoveOut;\n \n impl MirPass for RestoreSubsliceArrayMoveOut {\n-    fn run_pass<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        _src: MirSource<'tcx>,\n-        body: &mut Body<'tcx>,\n-    ) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);\n         {\n             let mut visitor = RestoreDataCollector {"}, {"sha": "719029dbaac77bfdf339a2b161527f96e8ed03a6", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -21,10 +21,7 @@ pub use self::graphviz::{graphviz_safe_def_name, write_mir_graphviz};\n pub use self::graphviz::write_node_label as write_graphviz_node_label;\n \n /// If possible, suggest replacing `ref` with `ref mut`.\n-pub fn suggest_ref_mut<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    binding_span: Span,\n-) -> Option<(String)> {\n+pub fn suggest_ref_mut<'tcx>(tcx: TyCtxt<'tcx>, binding_span: Span) -> Option<(String)> {\n     let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();\n     if hi_src.starts_with(\"ref\")\n         && hi_src[\"ref\".len()..].starts_with(Pattern_White_Space)"}, {"sha": "fc46adb702c8da389c94ea704884a039ec4700ac", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -93,11 +93,7 @@ pub fn dump_mir<'tcx, F>(\n     );\n }\n \n-pub fn dump_enabled<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    pass_name: &str,\n-    source: MirSource<'tcx>,\n-) -> bool {\n+pub fn dump_enabled<'tcx>(tcx: TyCtxt<'tcx>, pass_name: &str, source: MirSource<'tcx>) -> bool {\n     let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n         None => return false,\n         Some(ref filters) => filters,\n@@ -370,11 +366,7 @@ where\n /// After we print the main statement, we sometimes dump extra\n /// information. There's often a lot of little things \"nuzzled up\" in\n /// a statement.\n-fn write_extra<'tcx, F>(\n-    tcx: TyCtxt<'tcx>,\n-    write: &mut dyn Write,\n-    mut visit_op: F,\n-) -> io::Result<()>\n+fn write_extra<'tcx, F>(tcx: TyCtxt<'tcx>, write: &mut dyn Write, mut visit_op: F) -> io::Result<()>\n where\n     F: FnMut(&mut ExtraComments<'tcx>),\n {"}, {"sha": "c2cb2f4d1745e9b6a2f01d96b7c17c99d2cff729", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -337,11 +337,7 @@ fn item_tables<'a, 'tcx>(\n     if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n }\n \n-fn min<'tcx>(\n-    vis1: ty::Visibility,\n-    vis2: ty::Visibility,\n-    tcx: TyCtxt<'tcx>,\n-) -> ty::Visibility {\n+fn min<'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'tcx>) -> ty::Visibility {\n     if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n }\n "}, {"sha": "2b678919ce41b0aba7cde4ae887a18c9000e7c3e", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -179,10 +179,7 @@ impl context::AggregateOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n impl context::ContextOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n     /// Returns `true` if this is a coinductive goal: basically proving that an auto trait\n     /// is implemented or proving that a trait reference is well-formed.\n-    fn is_coinductive(\n-        &self,\n-        goal: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>\n-    ) -> bool {\n+    fn is_coinductive(&self, goal: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>) -> bool {\n         use rustc::traits::{WellFormed, WhereClause};\n \n         let mut goal = goal.value.goal;\n@@ -441,12 +438,9 @@ impl context::UnificationOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n     fn u_canonicalize_goal(\n         &mut self,\n         value: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n-    ) -> (\n-        Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n-        UniverseMap,\n-    ) {\n+    ) -> (Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>, UniverseMap) {\n         (value.clone(), UniverseMap)\n-    }\n+}\n \n     fn invert_goal(\n         &mut self,\n@@ -652,7 +646,8 @@ impl<'tcx> Upcast<'tcx> for ExClause<ChalkArenas<'tcx>> {\n }\n \n impl<'tcx, T> Upcast<'tcx> for Canonical<'tcx, T>\n-    where T: Upcast<'tcx>\n+where\n+    T: Upcast<'tcx>,\n {\n     type Upcasted = Canonical<'tcx, T::Upcasted>;\n "}, {"sha": "8e4b9da6de268304f7704321f67e80ea390ddffd", "filename": "src/librustc_traits/chalk_context/program_clauses/primitive.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -15,10 +15,7 @@ use crate::lowering::Lower;\n use crate::generic_types;\n use std::iter;\n \n-crate fn wf_clause_for_raw_ptr<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mutbl: hir::Mutability,\n-) -> Clauses<'tcx> {\n+crate fn wf_clause_for_raw_ptr<'tcx>(tcx: TyCtxt<'tcx>, mutbl: hir::Mutability) -> Clauses<'tcx> {\n     let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n \n     let wf_clause = ProgramClause {"}, {"sha": "d66faa92336fe837b11c997bc8e8557d98dd3e18", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -15,7 +15,7 @@ crate fn unify<'me, 'tcx, T: Relate<'tcx>>(\n     environment: Environment<'tcx>,\n     variance: ty::Variance,\n     a: &T,\n-    b: &T\n+    b: &T,\n ) -> RelateResult<'tcx, UnificationResult<'tcx>> {\n     debug!(\"unify(\n         a = {:?},\n@@ -50,10 +50,7 @@ struct ChalkTypeRelatingDelegate<'me, 'tcx: 'me> {\n }\n \n impl ChalkTypeRelatingDelegate<'me, 'tcx> {\n-    fn new(\n-        infcx: &'me InferCtxt<'me, 'tcx>,\n-        environment: Environment<'tcx>,\n-    ) -> Self {\n+    fn new(infcx: &'me InferCtxt<'me, 'tcx>, environment: Environment<'tcx>) -> Self {\n         Self {\n             infcx,\n             environment,"}, {"sha": "7f9ebdc79c27608f5000b0ad33151ba18432e71b", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -39,7 +39,7 @@ fn implied_outlives_bounds<'tcx>(\n fn compute_implied_outlives_bounds<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>\n+    ty: Ty<'tcx>,\n ) -> Fallible<Vec<OutlivesBound<'tcx>>> {\n     let tcx = infcx.tcx;\n "}, {"sha": "9ffbbd384c6d59f2ebca88a5334ee586ae745d25", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -1027,8 +1027,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         expected: Ty<'tcx>,\n         def_bm: ty::BindingMode,\n         discrim_span: Option<Span>,\n-    ) -> Ty<'tcx>\n-    {\n+    ) -> Ty<'tcx> {\n         // Resolve the path and check the definition for errors.\n         let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n         {"}, {"sha": "dc4969d7ad2db1c285bffd65d62f6c9d89502a70", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -31,7 +31,7 @@ pub struct Autoderef<'a, 'tcx: 'a> {\n     include_raw_pointers: bool,\n     span: Span,\n     silence_errors: bool,\n-    reached_recursion_limit: bool\n+    reached_recursion_limit: bool,\n }\n \n impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n@@ -86,13 +86,13 @@ impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>,\n-               param_env: ty::ParamEnv<'tcx>,\n-               body_id: hir::HirId,\n-               span: Span,\n-               base_ty: Ty<'tcx>)\n-               -> Autoderef<'a, 'tcx>\n-    {\n+    pub fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: hir::HirId,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+    ) -> Autoderef<'a, 'tcx> {\n         Autoderef {\n             infcx,\n             body_id,\n@@ -172,13 +172,15 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>, needs: Needs)\n-                        -> Vec<Adjustment<'tcx>> {\n+    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>, needs: Needs) -> Vec<Adjustment<'tcx>> {\n         fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx, needs))\n     }\n \n-    pub fn adjust_steps_as_infer_ok(&self, fcx: &FnCtxt<'a, 'tcx>, needs: Needs)\n-                                    -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n+    pub fn adjust_steps_as_infer_ok(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        needs: Needs,\n+    ) -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n         let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty)\n             .chain(iter::once(self.cur_ty));\n@@ -239,11 +241,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n     }\n }\n \n-pub fn report_autoderef_recursion_limit_error<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    span: Span,\n-    ty: Ty<'tcx>,\n-) {\n+pub fn report_autoderef_recursion_limit_error<'tcx>(tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n     // We've reached the recursion limit, error gracefully.\n     let suggested_limit = *tcx.sess.recursion_limit.get() * 2;\n     let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\","}, {"sha": "53101499af1dc283d82d8735fc04e73b8d59d3e7", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -158,26 +158,28 @@ impl From<ErrorReported> for CastError {\n     }\n }\n \n-fn make_invalid_casting_error<'a, 'tcx>(sess: &'a Session,\n-                                              span: Span,\n-                                              expr_ty: Ty<'tcx>,\n-                                              cast_ty: Ty<'tcx>,\n-                                              fcx: &FnCtxt<'a, 'tcx>)\n-                                              -> DiagnosticBuilder<'a> {\n+fn make_invalid_casting_error<'a, 'tcx>(\n+    sess: &'a Session,\n+    span: Span,\n+    expr_ty: Ty<'tcx>,\n+    cast_ty: Ty<'tcx>,\n+    fcx: &FnCtxt<'a, 'tcx>,\n+) -> DiagnosticBuilder<'a> {\n     type_error_struct!(sess, span, expr_ty, E0606,\n                        \"casting `{}` as `{}` is invalid\",\n                        fcx.ty_to_string(expr_ty),\n                        fcx.ty_to_string(cast_ty))\n }\n \n impl<'a, 'tcx> CastCheck<'tcx> {\n-    pub fn new(fcx: &FnCtxt<'a, 'tcx>,\n-               expr: &'tcx hir::Expr,\n-               expr_ty: Ty<'tcx>,\n-               cast_ty: Ty<'tcx>,\n-               cast_span: Span,\n-               span: Span)\n-               -> Result<CastCheck<'tcx>, ErrorReported> {\n+    pub fn new(\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        expr: &'tcx hir::Expr,\n+        expr_ty: Ty<'tcx>,\n+        cast_ty: Ty<'tcx>,\n+        cast_span: Span,\n+        span: Span,\n+    ) -> Result<CastCheck<'tcx>, ErrorReported> {\n         let check = CastCheck {\n             expr,\n             expr_ty,\n@@ -531,11 +533,12 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn check_ptr_ptr_cast(&self,\n-                          fcx: &FnCtxt<'a, 'tcx>,\n-                          m_expr: ty::TypeAndMut<'tcx>,\n-                          m_cast: ty::TypeAndMut<'tcx>)\n-                          -> Result<CastKind, CastError> {\n+    fn check_ptr_ptr_cast(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        m_expr: ty::TypeAndMut<'tcx>,\n+        m_cast: ty::TypeAndMut<'tcx>,\n+    ) -> Result<CastKind, CastError> {\n         debug!(\"check_ptr_ptr_cast m_expr={:?} m_cast={:?}\", m_expr, m_cast);\n         // ptr-ptr cast. vtables must match.\n \n@@ -572,10 +575,11 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn check_fptr_ptr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'tcx>,\n-                           m_cast: ty::TypeAndMut<'tcx>)\n-                           -> Result<CastKind, CastError> {\n+    fn check_fptr_ptr_cast(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        m_cast: ty::TypeAndMut<'tcx>,\n+    ) -> Result<CastKind, CastError> {\n         // fptr-ptr cast. must be to thin ptr\n \n         match fcx.pointer_kind(m_cast.ty, self.span)? {\n@@ -585,10 +589,11 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn check_ptr_addr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'tcx>,\n-                           m_expr: ty::TypeAndMut<'tcx>)\n-                           -> Result<CastKind, CastError> {\n+    fn check_ptr_addr_cast(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        m_expr: ty::TypeAndMut<'tcx>,\n+    ) -> Result<CastKind, CastError> {\n         // ptr-addr cast. must be from thin ptr\n \n         match fcx.pointer_kind(m_expr.ty, self.span)? {\n@@ -598,11 +603,12 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn check_ref_cast(&self,\n-                      fcx: &FnCtxt<'a, 'tcx>,\n-                      m_expr: ty::TypeAndMut<'tcx>,\n-                      m_cast: ty::TypeAndMut<'tcx>)\n-                      -> Result<CastKind, CastError> {\n+    fn check_ref_cast(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        m_expr: ty::TypeAndMut<'tcx>,\n+        m_cast: ty::TypeAndMut<'tcx>,\n+    ) -> Result<CastKind, CastError> {\n         // array-ptr-cast.\n \n         if m_expr.mutbl == hir::MutImmutable && m_cast.mutbl == hir::MutImmutable {\n@@ -623,10 +629,11 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         Err(CastError::IllegalCast)\n     }\n \n-    fn check_addr_ptr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'tcx>,\n-                           m_cast: TypeAndMut<'tcx>)\n-                           -> Result<CastKind, CastError> {\n+    fn check_addr_ptr_cast(\n+        &self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        m_cast: TypeAndMut<'tcx>,\n+    ) -> Result<CastKind, CastError> {\n         // ptr-addr cast. pointer must be thin.\n         match fcx.pointer_kind(m_cast.ty, self.span)? {\n             None => Err(CastError::UnknownCastPtrKind),"}, {"sha": "a56196ccf82f54fac76de40b5b537f0d45f6cd5b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -121,9 +121,11 @@ fn success<'tcx>(adj: Vec<Adjustment<'tcx>>,\n }\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n-    fn new(fcx: &'f FnCtxt<'f, 'tcx>,\n-           cause: ObligationCause<'tcx>,\n-           allow_two_phase: AllowTwoPhase) -> Self {\n+    fn new(\n+        fcx: &'f FnCtxt<'f, 'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        allow_two_phase: AllowTwoPhase,\n+    ) -> Self {\n         Coerce {\n             fcx,\n             cause,\n@@ -1073,12 +1075,13 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     /// could coerce from. This will record `expression`, and later\n     /// calls to `coerce` may come back and add adjustments and things\n     /// if necessary.\n-    pub fn coerce<'a>(&mut self,\n-                      fcx: &FnCtxt<'a, 'tcx>,\n-                      cause: &ObligationCause<'tcx>,\n-                      expression: &'tcx hir::Expr,\n-                      expression_ty: Ty<'tcx>)\n-    {\n+    pub fn coerce<'a>(\n+        &mut self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        expression: &'tcx hir::Expr,\n+        expression_ty: Ty<'tcx>,\n+    ) {\n         self.coerce_inner(fcx,\n                           cause,\n                           Some(expression),\n@@ -1098,12 +1101,13 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     /// The `augment_error` gives you a chance to extend the error\n     /// message, in case any results (e.g., we use this to suggest\n     /// removing a `;`).\n-    pub fn coerce_forced_unit<'a>(&mut self,\n-                                  fcx: &FnCtxt<'a, 'tcx>,\n-                                  cause: &ObligationCause<'tcx>,\n-                                  augment_error: &mut dyn FnMut(&mut DiagnosticBuilder<'_>),\n-                                  label_unit_as_expected: bool)\n-    {\n+    pub fn coerce_forced_unit<'a>(\n+        &mut self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        augment_error: &mut dyn FnMut(&mut DiagnosticBuilder<'_>),\n+        label_unit_as_expected: bool,\n+    ) {\n         self.coerce_inner(fcx,\n                           cause,\n                           None,\n@@ -1115,14 +1119,15 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     /// The inner coercion \"engine\". If `expression` is `None`, this\n     /// is a forced-unit case, and hence `expression_ty` must be\n     /// `Nil`.\n-    fn coerce_inner<'a>(&mut self,\n-                        fcx: &FnCtxt<'a, 'tcx>,\n-                        cause: &ObligationCause<'tcx>,\n-                        expression: Option<&'tcx hir::Expr>,\n-                        mut expression_ty: Ty<'tcx>,\n-                        augment_error: Option<&mut dyn FnMut(&mut DiagnosticBuilder<'_>)>,\n-                        label_expression_as_expected: bool)\n-    {\n+    fn coerce_inner<'a>(\n+        &mut self,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        expression: Option<&'tcx hir::Expr>,\n+        mut expression_ty: Ty<'tcx>,\n+        augment_error: Option<&mut dyn FnMut(&mut DiagnosticBuilder<'_>)>,\n+        label_expression_as_expected: bool,\n+    ) {\n         // Incorporate whatever type inference information we have\n         // until now; in principle we might also want to process\n         // pending obligations, but doing so should only improve"}, {"sha": "088ac0e8ba6c8745920df176790d2c25ecc5449f", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -410,15 +410,16 @@ fn check_region_bounds_on_impl_method<'tcx>(\n     Ok(())\n }\n \n-fn extract_spans_for_error_reporting<'a, 'tcx>(infcx: &infer::InferCtxt<'a, 'tcx>,\n-                                                     param_env: ty::ParamEnv<'tcx>,\n-                                                     terr: &TypeError<'_>,\n-                                                     cause: &ObligationCause<'tcx>,\n-                                                     impl_m: &ty::AssocItem,\n-                                                     impl_sig: ty::FnSig<'tcx>,\n-                                                     trait_m: &ty::AssocItem,\n-                                                     trait_sig: ty::FnSig<'tcx>)\n-                                                     -> (Span, Option<Span>) {\n+fn extract_spans_for_error_reporting<'a, 'tcx>(\n+    infcx: &infer::InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    terr: &TypeError<'_>,\n+    cause: &ObligationCause<'tcx>,\n+    impl_m: &ty::AssocItem,\n+    impl_sig: ty::FnSig<'tcx>,\n+    trait_m: &ty::AssocItem,\n+    trait_sig: ty::FnSig<'tcx>,\n+) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n     let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n     let (impl_m_output, impl_m_iter) = match tcx.hir()"}, {"sha": "2003782e7adca7a9c67508a626636f381e51ccac", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -29,10 +29,7 @@ use syntax_pos::Span;\n ///    struct/enum definition for the nominal type itself (i.e.\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n-pub fn check_drop_impl<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    drop_impl_did: DefId,\n-) -> Result<(), ErrorReported> {\n+pub fn check_drop_impl<'tcx>(tcx: TyCtxt<'tcx>, drop_impl_did: DefId) -> Result<(), ErrorReported> {\n     let dtor_self_type = tcx.type_of(drop_impl_did);\n     let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.sty {"}, {"sha": "5f9aa5fbabe04628f4c36e0112973f2694eb4465", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -75,10 +75,12 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn resolve_interior<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n-                                        def_id: DefId,\n-                                        body_id: hir::BodyId,\n-                                        interior: Ty<'tcx>) {\n+pub fn resolve_interior<'a, 'tcx>(\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    def_id: DefId,\n+    body_id: hir::BodyId,\n+    interior: Ty<'tcx>,\n+) {\n     let body = fcx.tcx.hir().body(body_id);\n     let mut visitor = InteriorVisitor {\n         fcx,"}, {"sha": "5df0010b63eb224ee4c31db9814a2905fc66894b", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -58,11 +58,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n-           span: Span,\n-           self_expr: &'tcx hir::Expr,\n-           call_expr: &'tcx hir::Expr)\n-           -> ConfirmContext<'a, 'tcx> {\n+    fn new(\n+        fcx: &'a FnCtxt<'a, 'tcx>,\n+        span: Span,\n+        self_expr: &'tcx hir::Expr,\n+        call_expr: &'tcx hir::Expr,\n+    ) -> ConfirmContext<'a, 'tcx> {\n         ConfirmContext {\n             fcx,\n             span,\n@@ -263,10 +264,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     }\n \n     fn extract_existential_trait_ref<R, F>(&mut self, self_ty: Ty<'tcx>, mut closure: F) -> R\n-        where F: FnMut(&mut ConfirmContext<'a, 'tcx>,\n-                       Ty<'tcx>,\n-                       ty::PolyExistentialTraitRef<'tcx>)\n-                       -> R\n+    where\n+        F: FnMut(&mut ConfirmContext<'a, 'tcx>, Ty<'tcx>, ty::PolyExistentialTraitRef<'tcx>) -> R,\n     {\n         // If we specified that this is an object method, then the\n         // self-type ought to be something that can be dereferenced to"}, {"sha": "b492197870b7539b1aa1b500cb65e701ef2d968f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -174,13 +174,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// * `self_ty`:               the (unadjusted) type of the self expression (`foo`)\n     /// * `supplied_method_types`: the explicit method type parameters, if any (`T1..Tn`)\n     /// * `self_expr`:             the self expression (`foo`)\n-    pub fn lookup_method(&self,\n-                         self_ty: Ty<'tcx>,\n-                         segment: &hir::PathSegment,\n-                         span: Span,\n-                         call_expr: &'tcx hir::Expr,\n-                         self_expr: &'tcx hir::Expr)\n-                         -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n+    pub fn lookup_method(\n+        &self,\n+        self_ty: Ty<'tcx>,\n+        segment: &hir::PathSegment,\n+        span: Span,\n+        call_expr: &'tcx hir::Expr,\n+        self_expr: &'tcx hir::Expr,\n+    ) -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n         debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n                segment.ident,\n                self_ty,\n@@ -245,13 +246,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Ok(result.callee)\n     }\n \n-    fn lookup_probe(&self,\n-                    span: Span,\n-                    method_name: ast::Ident,\n-                    self_ty: Ty<'tcx>,\n-                    call_expr: &'tcx hir::Expr,\n-                    scope: ProbeScope)\n-                    -> probe::PickResult<'tcx> {\n+    fn lookup_probe(\n+        &self,\n+        span: Span,\n+        method_name: ast::Ident,\n+        self_ty: Ty<'tcx>,\n+        call_expr: &'tcx hir::Expr,\n+        scope: ProbeScope,\n+    ) -> probe::PickResult<'tcx> {\n         let mode = probe::Mode::MethodCall;\n         let self_ty = self.resolve_vars_if_possible(&self_ty);\n         self.probe_for_name(span, mode, method_name, IsSuggestion(false),"}, {"sha": "661883f2ac11d6916b2e7d1dfbe370bb6ada856a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -259,18 +259,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                       |probe_cx| probe_cx.pick())\n     }\n \n-    fn probe_op<OP,R>(&'a self,\n-                      span: Span,\n-                      mode: Mode,\n-                      method_name: Option<ast::Ident>,\n-                      return_type: Option<Ty<'tcx>>,\n-                      is_suggestion: IsSuggestion,\n-                      self_ty: Ty<'tcx>,\n-                      scope_expr_id: hir::HirId,\n-                      scope: ProbeScope,\n-                      op: OP)\n-                      -> Result<R, MethodError<'tcx>>\n-        where OP: FnOnce(ProbeContext<'a, 'tcx>) -> Result<R, MethodError<'tcx>>\n+    fn probe_op<OP, R>(\n+        &'a self,\n+        span: Span,\n+        mode: Mode,\n+        method_name: Option<ast::Ident>,\n+        return_type: Option<Ty<'tcx>>,\n+        is_suggestion: IsSuggestion,\n+        self_ty: Ty<'tcx>,\n+        scope_expr_id: hir::HirId,\n+        scope: ProbeScope,\n+        op: OP,\n+    ) -> Result<R, MethodError<'tcx>>\n+    where\n+        OP: FnOnce(ProbeContext<'a, 'tcx>) -> Result<R, MethodError<'tcx>>,\n     {\n         let mut orig_values = OriginalQueryValues::default();\n         let param_env_and_self_ty =\n@@ -463,17 +465,17 @@ fn method_autoderef_steps<'tcx>(\n     })\n }\n \n-\n impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n-           span: Span,\n-           mode: Mode,\n-           method_name: Option<ast::Ident>,\n-           return_type: Option<Ty<'tcx>>,\n-           orig_steps_var_values: OriginalQueryValues<'tcx>,\n-           steps: Lrc<Vec<CandidateStep<'tcx>>>,\n-           is_suggestion: IsSuggestion)\n-           -> ProbeContext<'a, 'tcx> {\n+    fn new(\n+        fcx: &'a FnCtxt<'a, 'tcx>,\n+        span: Span,\n+        mode: Mode,\n+        method_name: Option<ast::Ident>,\n+        return_type: Option<Ty<'tcx>>,\n+        orig_steps_var_values: OriginalQueryValues<'tcx>,\n+        steps: Lrc<Vec<CandidateStep<'tcx>>>,\n+        is_suggestion: IsSuggestion,\n+    ) -> ProbeContext<'a, 'tcx> {\n         ProbeContext {\n             fcx,\n             span,\n@@ -808,12 +810,12 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     // Do a search through a list of bounds, using a callback to actually\n     // create the candidates.\n-    fn elaborate_bounds<F>(&mut self,\n-                           bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-                           mut mk_cand: F)\n-        where F: for<'b> FnMut(&mut ProbeContext<'b, 'tcx>,\n-                               ty::PolyTraitRef<'tcx>,\n-                               ty::AssocItem)\n+    fn elaborate_bounds<F>(\n+        &mut self,\n+        bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+        mut mk_cand: F,\n+    ) where\n+        F: for<'b> FnMut(&mut ProbeContext<'b, 'tcx>, ty::PolyTraitRef<'tcx>, ty::AssocItem),\n     {\n         let tcx = self.tcx;\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n@@ -1045,9 +1047,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             .next()\n     }\n \n-    fn pick_by_value_method(&mut self, step: &CandidateStep<'tcx>, self_ty: Ty<'tcx>)\n-                            -> Option<PickResult<'tcx>>\n-    {\n+    fn pick_by_value_method(\n+        &mut self,\n+        step: &CandidateStep<'tcx>,\n+        self_ty: Ty<'tcx>,\n+    ) -> Option<PickResult<'tcx>> {\n         //! For each type `T` in the step list, this attempts to find a\n         //! method where the (transformed) self type is exactly `T`. We\n         //! do however do one transformation on the adjustment: if we\n@@ -1075,11 +1079,12 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn pick_autorefd_method(&mut self,\n-                            step: &CandidateStep<'tcx>,\n-                            self_ty: Ty<'tcx>,\n-                            mutbl: hir::Mutability)\n-                            -> Option<PickResult<'tcx>> {\n+    fn pick_autorefd_method(\n+        &mut self,\n+        step: &CandidateStep<'tcx>,\n+        self_ty: Ty<'tcx>,\n+        mutbl: hir::Mutability,\n+    ) -> Option<PickResult<'tcx>> {\n         let tcx = self.tcx;\n \n         // In general, during probing we erase regions. See"}, {"sha": "3a30e31f89e2a3eb527d650b96a64bbb84ac5f21", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 165, "deletions": 150, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -1010,8 +1010,14 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     }\n \n     // Don't descend into the bodies of nested closures\n-    fn visit_fn(&mut self, _: intravisit::FnKind<'tcx>, _: &'tcx hir::FnDecl,\n-                _: hir::BodyId, _: Span, _: hir::HirId) { }\n+    fn visit_fn(\n+        &mut self,\n+        _: intravisit::FnKind<'tcx>,\n+        _: &'tcx hir::FnDecl,\n+        _: hir::BodyId,\n+        _: Span,\n+        _: hir::HirId,\n+    ) { }\n }\n \n /// When `check_fn` is invoked on a generator (i.e., a body that\n@@ -1034,15 +1040,15 @@ struct GeneratorTypes<'tcx> {\n ///\n /// * ...\n /// * inherited: other fields inherited from the enclosing fn (if any)\n-fn check_fn<'a, 'tcx>(inherited: &'a Inherited<'a, 'tcx>,\n-                            param_env: ty::ParamEnv<'tcx>,\n-                            fn_sig: ty::FnSig<'tcx>,\n-                            decl: &'tcx hir::FnDecl,\n-                            fn_id: hir::HirId,\n-                            body: &'tcx hir::Body,\n-                            can_be_generator: Option<hir::GeneratorMovability>)\n-                            -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>)\n-{\n+fn check_fn<'a, 'tcx>(\n+    inherited: &'a Inherited<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    fn_sig: ty::FnSig<'tcx>,\n+    decl: &'tcx hir::FnDecl,\n+    fn_id: hir::HirId,\n+    body: &'tcx hir::Body,\n+    can_be_generator: Option<hir::GeneratorMovability>,\n+) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n     let mut fn_sig = fn_sig.clone();\n \n     debug!(\"check_fn(sig={:?}, fn_id={}, param_env={:?})\", fn_sig, fn_id, param_env);\n@@ -1755,11 +1761,7 @@ fn check_packed<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n     }\n }\n \n-fn check_packed_inner<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    stack: &mut Vec<DefId>,\n-) -> bool {\n+fn check_packed_inner<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, stack: &mut Vec<DefId>) -> bool {\n     let t = tcx.type_of(def_id);\n     if stack.contains(&def_id) {\n         debug!(\"check_packed_inner: {:?} is recursive\", t);\n@@ -1867,12 +1869,7 @@ fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n }\n \n #[allow(trivial_numeric_casts)]\n-pub fn check_enum<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    sp: Span,\n-    vs: &'tcx [hir::Variant],\n-    id: hir::HirId,\n-) {\n+pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], id: hir::HirId) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -1933,12 +1930,7 @@ pub fn check_enum<'tcx>(\n     check_transparent(tcx, sp, def_id);\n }\n \n-fn report_unexpected_variant_res<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    res: Res,\n-    span: Span,\n-    qpath: &QPath,\n-) {\n+fn report_unexpected_variant_res<'tcx>(tcx: TyCtxt<'tcx>, res: Res, span: Span, qpath: &QPath) {\n     span_err!(tcx.sess, span, E0533,\n               \"expected unit struct/variant or constant, found {} `{}`\",\n               res.descr(),\n@@ -2075,10 +2067,11 @@ enum TupleArgumentsFlag {\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn new(inh: &'a Inherited<'a, 'tcx>,\n-               param_env: ty::ParamEnv<'tcx>,\n-               body_id: hir::HirId)\n-               -> FnCtxt<'a, 'tcx> {\n+    pub fn new(\n+        inh: &'a Inherited<'a, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: hir::HirId,\n+    ) -> FnCtxt<'a, 'tcx> {\n         FnCtxt {\n             body_id,\n             param_env,\n@@ -2165,17 +2158,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    fn record_deferred_call_resolution(&self,\n-                                       closure_def_id: DefId,\n-                                       r: DeferredCallResolution<'tcx>) {\n+    fn record_deferred_call_resolution(\n+        &self,\n+        closure_def_id: DefId,\n+        r: DeferredCallResolution<'tcx>,\n+    ) {\n         let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n         deferred_call_resolutions.entry(closure_def_id).or_default().push(r);\n     }\n \n-    fn remove_deferred_call_resolutions(&self,\n-                                        closure_def_id: DefId)\n-                                        -> Vec<DeferredCallResolution<'tcx>>\n-    {\n+    fn remove_deferred_call_resolutions(\n+        &self,\n+        closure_def_id: DefId,\n+    ) -> Vec<DeferredCallResolution<'tcx>> {\n         let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n         deferred_call_resolutions.remove(&closure_def_id).unwrap_or(vec![])\n     }\n@@ -2664,14 +2659,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ret_ty.builtin_deref(true).unwrap()\n     }\n \n-    fn lookup_indexing(&self,\n-                       expr: &hir::Expr,\n-                       base_expr: &'tcx hir::Expr,\n-                       base_ty: Ty<'tcx>,\n-                       idx_ty: Ty<'tcx>,\n-                       needs: Needs)\n-                       -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n-    {\n+    fn lookup_indexing(\n+        &self,\n+        expr: &hir::Expr,\n+        base_expr: &'tcx hir::Expr,\n+        base_ty: Ty<'tcx>,\n+        idx_ty: Ty<'tcx>,\n+        needs: Needs,\n+    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n         // FIXME(#18741) -- this is almost but not quite the same as the\n         // autoderef that normal method probing does. They could likely be\n         // consolidated.\n@@ -2690,14 +2685,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// supports builtin indexing or overloaded indexing.\n     /// This loop implements one step in that search; the autoderef loop\n     /// is implemented by `lookup_indexing`.\n-    fn try_index_step(&self,\n-                      expr: &hir::Expr,\n-                      base_expr: &hir::Expr,\n-                      autoderef: &Autoderef<'a, 'tcx>,\n-                      needs: Needs,\n-                      index_ty: Ty<'tcx>)\n-                      -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n-    {\n+    fn try_index_step(\n+        &self,\n+        expr: &hir::Expr,\n+        base_expr: &hir::Expr,\n+        autoderef: &Autoderef<'a, 'tcx>,\n+        needs: Needs,\n+        index_ty: Ty<'tcx>,\n+    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n         let adjusted_ty = autoderef.unambiguous_final_ty(self);\n         debug!(\"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n                                index_ty={:?})\",\n@@ -2815,14 +2810,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         method\n     }\n \n-    fn check_method_argument_types(&self,\n-                                   sp: Span,\n-                                   expr_sp: Span,\n-                                   method: Result<MethodCallee<'tcx>, ()>,\n-                                   args_no_rcvr: &'tcx [hir::Expr],\n-                                   tuple_arguments: TupleArgumentsFlag,\n-                                   expected: Expectation<'tcx>)\n-                                   -> Ty<'tcx> {\n+    fn check_method_argument_types(\n+        &self,\n+        sp: Span,\n+        expr_sp: Span,\n+        method: Result<MethodCallee<'tcx>, ()>,\n+        args_no_rcvr: &'tcx [hir::Expr],\n+        tuple_arguments: TupleArgumentsFlag,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n         let has_error = match method {\n             Ok(method) => {\n                 method.substs.references_error() || method.sig.references_error()\n@@ -2878,10 +2874,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn obligations_for_self_ty<'b>(&'b self, self_ty: ty::TyVid)\n-        -> impl Iterator<Item=(ty::PolyTraitRef<'tcx>, traits::PredicateObligation<'tcx>)>\n-           + Captures<'tcx> + 'b\n-    {\n+    fn obligations_for_self_ty<'b>(\n+        &'b self,\n+        self_ty: ty::TyVid,\n+    ) -> impl Iterator<Item = (ty::PolyTraitRef<'tcx>, traits::PredicateObligation<'tcx>)>\n+                 + Captures<'tcx>\n+                 + 'b {\n         // FIXME: consider using `sub_root_var` here so we\n         // can see through subtyping.\n         let ty_var_root = self.root_var(self_ty);\n@@ -2924,15 +2922,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Generic function that factors out common logic from function calls,\n     /// method calls and overloaded operators.\n-    fn check_argument_types(&self,\n-                            sp: Span,\n-                            expr_sp: Span,\n-                            fn_inputs: &[Ty<'tcx>],\n-                            expected_arg_tys: &[Ty<'tcx>],\n-                            args: &'tcx [hir::Expr],\n-                            c_variadic: bool,\n-                            tuple_arguments: TupleArgumentsFlag,\n-                            def_span: Option<Span>) {\n+    fn check_argument_types(\n+        &self,\n+        sp: Span,\n+        expr_sp: Span,\n+        fn_inputs: &[Ty<'tcx>],\n+        expected_arg_tys: &[Ty<'tcx>],\n+        args: &'tcx [hir::Expr],\n+        c_variadic: bool,\n+        tuple_arguments: TupleArgumentsFlag,\n+        def_span: Option<Span>,\n+    ) {\n         let tcx = self.tcx;\n \n         // Grab the argument types, supplying fresh type variables\n@@ -3196,22 +3196,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_eq_type(&self,\n-                          expr: &'tcx hir::Expr,\n-                          expected: Ty<'tcx>) {\n+    fn check_expr_eq_type(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) {\n         let ty = self.check_expr_with_hint(expr, expected);\n         self.demand_eqtype(expr.span, expected, ty);\n     }\n \n-    pub fn check_expr_has_type_or_error(&self,\n-                                        expr: &'tcx hir::Expr,\n-                                        expected: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn check_expr_has_type_or_error(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Ty<'tcx>,\n+    ) -> Ty<'tcx> {\n         self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected))\n     }\n \n-    fn check_expr_meets_expectation_or_error(&self,\n-                                             expr: &'tcx hir::Expr,\n-                                             expected: Expectation<'tcx>) -> Ty<'tcx> {\n+    fn check_expr_meets_expectation_or_error(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n         let expected_ty = expected.to_option(&self).unwrap_or(self.tcx.types.bool);\n         let mut ty = self.check_expr_with_expectation(expr, expected);\n \n@@ -3244,23 +3246,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    fn check_expr_coercable_to_type(&self,\n-                                    expr: &'tcx hir::Expr,\n-                                    expected: Ty<'tcx>) -> Ty<'tcx> {\n+    fn check_expr_coercable_to_type(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) -> Ty<'tcx> {\n         let ty = self.check_expr_with_hint(expr, expected);\n         // checks don't need two phase\n         self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n     }\n \n-    fn check_expr_with_hint(&self,\n-                            expr: &'tcx hir::Expr,\n-                            expected: Ty<'tcx>) -> Ty<'tcx> {\n+    fn check_expr_with_hint(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, ExpectHasType(expected))\n     }\n \n-    fn check_expr_with_expectation(&self,\n-                                   expr: &'tcx hir::Expr,\n-                                   expected: Expectation<'tcx>) -> Ty<'tcx> {\n+    fn check_expr_with_expectation(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n         self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n     }\n \n@@ -3342,13 +3342,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     // Checks a method call.\n-    fn check_method_call(&self,\n-                         expr: &'tcx hir::Expr,\n-                         segment: &hir::PathSegment,\n-                         span: Span,\n-                         args: &'tcx [hir::Expr],\n-                         expected: Expectation<'tcx>,\n-                         needs: Needs) -> Ty<'tcx> {\n+    fn check_method_call(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        segment: &hir::PathSegment,\n+        span: Span,\n+        args: &'tcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+        needs: Needs,\n+    ) -> Ty<'tcx> {\n         let rcvr = &args[0];\n         let rcvr_t = self.check_expr_with_needs(&rcvr, needs);\n         // no need to check for bot/err -- callee does that\n@@ -3403,11 +3405,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     // Check field access expressions\n-    fn check_field(&self,\n-                   expr: &'tcx hir::Expr,\n-                   needs: Needs,\n-                   base: &'tcx hir::Expr,\n-                   field: ast::Ident) -> Ty<'tcx> {\n+    fn check_field(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        needs: Needs,\n+        base: &'tcx hir::Expr,\n+        field: ast::Ident,\n+    ) -> Ty<'tcx> {\n         let expr_t = self.check_expr_with_needs(base, needs);\n         let expr_t = self.structurally_resolved_type(base.span,\n                                                      expr_t);\n@@ -3675,14 +3679,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn check_expr_struct_fields(&self,\n-                                adt_ty: Ty<'tcx>,\n-                                expected: Expectation<'tcx>,\n-                                expr_id: hir::HirId,\n-                                span: Span,\n-                                variant: &'tcx ty::VariantDef,\n-                                ast_fields: &'tcx [hir::Field],\n-                                check_completeness: bool) -> bool {\n+    fn check_expr_struct_fields(\n+        &self,\n+        adt_ty: Ty<'tcx>,\n+        expected: Expectation<'tcx>,\n+        expr_id: hir::HirId,\n+        span: Span,\n+        variant: &'tcx ty::VariantDef,\n+        ast_fields: &'tcx [hir::Field],\n+        check_completeness: bool,\n+    ) -> bool {\n         let tcx = self.tcx;\n \n         let adt_ty_hint =\n@@ -3786,9 +3792,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         error_happened\n     }\n \n-    fn check_struct_fields_on_error(&self,\n-                                    fields: &'tcx [hir::Field],\n-                                    base_expr: &'tcx Option<P<hir::Expr>>) {\n+    fn check_struct_fields_on_error(\n+        &self,\n+        fields: &'tcx [hir::Field],\n+        base_expr: &'tcx Option<P<hir::Expr>>,\n+    ) {\n         for field in fields {\n             self.check_expr(&field.expr);\n         }\n@@ -3855,13 +3863,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_struct(&self,\n-                         expr: &hir::Expr,\n-                         expected: Expectation<'tcx>,\n-                         qpath: &QPath,\n-                         fields: &'tcx [hir::Field],\n-                         base_expr: &'tcx Option<P<hir::Expr>>) -> Ty<'tcx>\n-    {\n+    fn check_expr_struct(\n+        &self,\n+        expr: &hir::Expr,\n+        expected: Expectation<'tcx>,\n+        qpath: &QPath,\n+        fields: &'tcx [hir::Field],\n+        base_expr: &'tcx Option<P<hir::Expr>>,\n+    ) -> Ty<'tcx> {\n         // Find the relevant variant\n         let (variant, adt_ty) =\n             if let Some(variant_ty) = self.check_struct_path(qpath, expr.hir_id) {\n@@ -3925,10 +3934,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Note that inspecting a type's structure *directly* may expose the fact\n     /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n-    fn check_expr_with_expectation_and_needs(&self,\n-                                             expr: &'tcx hir::Expr,\n-                                             expected: Expectation<'tcx>,\n-                                             needs: Needs) -> Ty<'tcx> {\n+    fn check_expr_with_expectation_and_needs(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        needs: Needs,\n+    ) -> Ty<'tcx> {\n         debug!(\">> type-checking: expr={:?} expected={:?}\",\n                expr, expected);\n \n@@ -3976,7 +3987,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr,\n         expected: Expectation<'tcx>,\n-        needs: Needs\n+        needs: Needs,\n     ) -> Ty<'tcx> {\n         debug!(\n             \"check_expr_kind(expr={:?}, expected={:?}, needs={:?})\",\n@@ -4784,10 +4795,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n-    pub fn check_decl_initializer(&self,\n-                                  local: &'tcx hir::Local,\n-                                  init: &'tcx hir::Expr) -> Ty<'tcx>\n-    {\n+    pub fn check_decl_initializer(\n+        &self,\n+        local: &'tcx hir::Local,\n+        init: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n         // FIXME(tschottdorf): `contains_explicit_ref_binding()` must be removed\n         // for #42640 (default match binding modes).\n         //\n@@ -4870,7 +4882,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n     }\n \n-    pub fn check_block_no_value(&self, blk: &'tcx hir::Block)  {\n+    pub fn check_block_no_value(&self, blk: &'tcx hir::Block) {\n         let unit = self.tcx.mk_unit();\n         let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n \n@@ -4881,9 +4893,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_block_with_expected(&self,\n-                                 blk: &'tcx hir::Block,\n-                                 expected: Expectation<'tcx>) -> Ty<'tcx> {\n+    fn check_block_with_expected(\n+        &self,\n+        blk: &'tcx hir::Block,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n         let prev = {\n             let mut fcx_ps = self.ps.borrow_mut();\n             let unsafety_state = fcx_ps.recurse(blk);\n@@ -5155,11 +5169,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// This routine checks if the return expression in a block would make sense on its own as a\n     /// statement and the return type has been left as default or has been specified as `()`. If so,\n     /// it suggests adding a semicolon.\n-    fn suggest_missing_semicolon(&self,\n-                                 err: &mut DiagnosticBuilder<'tcx>,\n-                                 expression: &'tcx hir::Expr,\n-                                 expected: Ty<'tcx>,\n-                                 cause_span: Span) {\n+    fn suggest_missing_semicolon(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        expression: &'tcx hir::Expr,\n+        expected: Ty<'tcx>,\n+        cause_span: Span,\n+    ) {\n         if expected.is_unit() {\n             // `BlockTailExpression` only relevant if the tail expr would be\n             // useful on its own.\n@@ -5268,11 +5284,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn could_remove_semicolon(\n-        &self,\n-        blk: &'tcx hir::Block,\n-        expected_ty: Ty<'tcx>,\n-    ) -> Option<Span> {\n+    fn could_remove_semicolon(&self, blk: &'tcx hir::Block, expected_ty: Ty<'tcx>) -> Option<Span> {\n         // Be helpful when the user wrote `{... expr;}` and\n         // taking the `;` off is enough to fix the error.\n         let last_stmt = blk.stmts.last()?;\n@@ -5632,9 +5644,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn with_breakable_ctxt<F: FnOnce() -> R, R>(&self, id: hir::HirId,\n-                                                ctxt: BreakableCtxt<'tcx>, f: F)\n-                                                -> (BreakableCtxt<'tcx>, R) {\n+    fn with_breakable_ctxt<F: FnOnce() -> R, R>(\n+        &self,\n+        id: hir::HirId,\n+        ctxt: BreakableCtxt<'tcx>,\n+        f: F,\n+    ) -> (BreakableCtxt<'tcx>, R) {\n         let index;\n         {\n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();"}, {"sha": "93855a3b68a7fc553caba34f342fa069356b9dcd", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -13,12 +13,13 @@ use rustc::hir;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a `a <op>= b`\n-    pub fn check_binop_assign(&self,\n-                              expr: &'tcx hir::Expr,\n-                              op: hir::BinOp,\n-                              lhs_expr: &'tcx hir::Expr,\n-                              rhs_expr: &'tcx hir::Expr) -> Ty<'tcx>\n-    {\n+    pub fn check_binop_assign(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        op: hir::BinOp,\n+        lhs_expr: &'tcx hir::Expr,\n+        rhs_expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n         let (lhs_ty, rhs_ty, return_ty) =\n             self.check_overloaded_binop(expr, lhs_expr, rhs_expr, op, IsAssign::Yes);\n \n@@ -43,12 +44,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Checks a potentially overloaded binary operator.\n-    pub fn check_binop(&self,\n-                       expr: &'tcx hir::Expr,\n-                       op: hir::BinOp,\n-                       lhs_expr: &'tcx hir::Expr,\n-                       rhs_expr: &'tcx hir::Expr) -> Ty<'tcx>\n-    {\n+    pub fn check_binop(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        op: hir::BinOp,\n+        lhs_expr: &'tcx hir::Expr,\n+        rhs_expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n         debug!(\"check_binop(expr.hir_id={}, expr={:?}, op={:?}, lhs_expr={:?}, rhs_expr={:?})\",\n@@ -104,14 +106,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn enforce_builtin_binop_types(&self,\n-                                   lhs_expr: &'tcx hir::Expr,\n-                                   lhs_ty: Ty<'tcx>,\n-                                   rhs_expr: &'tcx hir::Expr,\n-                                   rhs_ty: Ty<'tcx>,\n-                                   op: hir::BinOp)\n-                                   -> Ty<'tcx>\n-    {\n+    fn enforce_builtin_binop_types(\n+        &self,\n+        lhs_expr: &'tcx hir::Expr,\n+        lhs_ty: Ty<'tcx>,\n+        rhs_expr: &'tcx hir::Expr,\n+        rhs_ty: Ty<'tcx>,\n+        op: hir::BinOp,\n+    ) -> Ty<'tcx> {\n         debug_assert!(is_builtin_binop(lhs_ty, rhs_ty, op));\n \n         let tcx = self.tcx;\n@@ -142,14 +144,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_overloaded_binop(&self,\n-                              expr: &'tcx hir::Expr,\n-                              lhs_expr: &'tcx hir::Expr,\n-                              rhs_expr: &'tcx hir::Expr,\n-                              op: hir::BinOp,\n-                              is_assign: IsAssign)\n-                              -> (Ty<'tcx>, Ty<'tcx>, Ty<'tcx>)\n-    {\n+    fn check_overloaded_binop(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        lhs_expr: &'tcx hir::Expr,\n+        rhs_expr: &'tcx hir::Expr,\n+        op: hir::BinOp,\n+        is_assign: IsAssign,\n+    ) -> (Ty<'tcx>, Ty<'tcx>, Ty<'tcx>) {\n         debug!(\"check_overloaded_binop(expr.hir_id={}, op={:?}, is_assign={:?})\",\n                expr.hir_id,\n                op,\n@@ -611,12 +613,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn check_user_unop(&self,\n-                           ex: &'tcx hir::Expr,\n-                           operand_ty: Ty<'tcx>,\n-                           op: hir::UnOp)\n-                           -> Ty<'tcx>\n-    {\n+    pub fn check_user_unop(\n+        &self,\n+        ex: &'tcx hir::Expr,\n+        operand_ty: Ty<'tcx>,\n+        op: hir::UnOp,\n+    ) -> Ty<'tcx> {\n         assert!(op.is_by_value());\n         match self.lookup_op_method(operand_ty, &[], Op::Unary(op, ex.span)) {\n             Ok(method) => {"}, {"sha": "77ac2b96160a65d94f82049a2433ea6a05cd8cca", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -227,18 +227,11 @@ fn check_associated_item<'tcx>(\n     })\n }\n \n-fn for_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    item: &hir::Item,\n-) -> CheckWfFcxBuilder<'tcx> {\n+fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item) -> CheckWfFcxBuilder<'tcx> {\n     for_id(tcx, item.hir_id, item.span)\n }\n \n-fn for_id<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    id: hir::HirId,\n-    span: Span,\n-) -> CheckWfFcxBuilder<'tcx> {\n+fn for_id<'tcx>(tcx: TyCtxt<'tcx>, id: hir::HirId, span: Span) -> CheckWfFcxBuilder<'tcx> {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n@@ -768,11 +761,12 @@ fn check_existential_types<'fcx, 'tcx>(\n     substituted_predicates\n }\n \n-fn check_method_receiver<'fcx, 'tcx>(fcx: &FnCtxt<'fcx, 'tcx>,\n-                                           method_sig: &hir::MethodSig,\n-                                           method: &ty::AssocItem,\n-                                           self_ty: Ty<'tcx>)\n-{\n+fn check_method_receiver<'fcx, 'tcx>(\n+    fcx: &FnCtxt<'fcx, 'tcx>,\n+    method_sig: &hir::MethodSig,\n+    method: &ty::AssocItem,\n+    self_ty: Ty<'tcx>,\n+) {\n     // Check that the method has a valid receiver type, given the type `Self`.\n     debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n            method, self_ty);\n@@ -1028,11 +1022,7 @@ fn reject_shadowing_parameters(tcx: TyCtxt<'_>, def_id: DefId) {\n \n /// Feature gates RFC 2056 -- trivial bounds, checking for global bounds that\n /// aren't true.\n-fn check_false_global_bounds<'a, 'tcx>(\n-    fcx: &FnCtxt<'a, 'tcx>,\n-    span: Span,\n-    id: hir::HirId)\n-{\n+fn check_false_global_bounds<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, span: Span, id: hir::HirId) {\n     let empty_env = ty::ParamEnv::empty();\n \n     let def_id = fcx.tcx.hir().local_def_id_from_hir_id(id);"}, {"sha": "4336e861ce216a50151adbad311431f90e367f45", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -40,11 +40,7 @@ fn check_impl<'tcx>(tcx: TyCtxt<'tcx>, hir_id: HirId) {\n     }\n }\n \n-fn enforce_trait_manually_implementable(\n-    tcx: TyCtxt<'_>,\n-    impl_def_id: DefId,\n-    trait_def_id: DefId,\n-) {\n+fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_def_id: DefId) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n     let span = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n@@ -96,11 +92,7 @@ fn enforce_trait_manually_implementable(\n \n /// We allow impls of marker traits to overlap, so they can't override impls\n /// as that could make it ambiguous which associated item to use.\n-fn enforce_empty_impls_for_marker_traits(\n-    tcx: TyCtxt<'_>,\n-    impl_def_id: DefId,\n-    trait_def_id: DefId,\n-) {\n+fn enforce_empty_impls_for_marker_traits(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_def_id: DefId) {\n     if !tcx.trait_def(trait_def_id).is_marker {\n         return;\n     }"}, {"sha": "d4b2c200297d2d28ffb208eb1af8e67199bfb9c2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -514,11 +514,7 @@ fn convert_variant_ctor<'tcx>(tcx: TyCtxt<'tcx>, ctor_id: hir::HirId) {\n     tcx.predicates_of(def_id);\n }\n \n-fn convert_enum_variant_types<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    variants: &[hir::Variant],\n-) {\n+fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants: &[hir::Variant]) {\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr.discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n@@ -1143,11 +1139,7 @@ fn type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n ///\n /// If you want to fail anyway, you can set the `fail` parameter to true, but in this case,\n /// you'd better just call [`type_of`] directly.\n-pub fn checked_type_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    fail: bool,\n-) -> Option<Ty<'tcx>> {\n+pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Option<Ty<'tcx>> {\n     use rustc::hir::*;\n \n     let hir_id = match tcx.hir().as_local_hir_id(def_id) {\n@@ -1842,10 +1834,7 @@ fn predicates_defined_on<'tcx>(\n /// Returns a list of all type predicates (explicit and implicit) for the definition with\n /// ID `def_id`. This includes all predicates returned by `predicates_defined_on`, plus\n /// `Self: Trait` predicates for traits.\n-fn predicates_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-) -> &'tcx ty::GenericPredicates<'tcx> {\n+fn predicates_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::GenericPredicates<'tcx> {\n     let mut result = tcx.predicates_defined_on(def_id);\n \n     if tcx.is_trait(def_id) {"}, {"sha": "b833d8555ee0a6b7bb825ea6572117c361424ad3", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -183,10 +183,7 @@ fn report_unused_parameter(tcx: TyCtxt<'_>, span: Span, kind: &str, name: &str)\n }\n \n /// Enforce that we do not have two items in an impl with the same name.\n-fn enforce_impl_items_are_distinct<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    impl_item_refs: &[hir::ImplItemRef],\n-) {\n+fn enforce_impl_items_are_distinct<'tcx>(tcx: TyCtxt<'tcx>, impl_item_refs: &[hir::ImplItemRef]) {\n     let mut seen_type_items = FxHashMap::default();\n     let mut seen_value_items = FxHashMap::default();\n     for impl_item_ref in impl_item_refs {"}, {"sha": "ea458842acce676a8708df3a332ea4bfb44368a1", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc39bbf2447844569e872468f9440d430b81a46/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=afc39bbf2447844569e872468f9440d430b81a46", "patch": "@@ -34,10 +34,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn crate_variances<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    crate_num: CrateNum,\n-) -> &'tcx CrateVariancesMap<'tcx> {\n+fn crate_variances<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx CrateVariancesMap<'tcx> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::default();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);"}]}