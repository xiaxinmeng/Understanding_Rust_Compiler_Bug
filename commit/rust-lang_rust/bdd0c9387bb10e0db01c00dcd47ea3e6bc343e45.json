{"sha": "bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZDBjOTM4N2JiMTBlMGRiMDFjMDBkY2Q0N2VhM2U2YmMzNDNlNDU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-02T22:36:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T01:30:06Z"}, "message": "get new decorator extensions working", "tree": {"sha": "1dbc43e5cd08037aa6cd11de8e1528b2a118b7f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dbc43e5cd08037aa6cd11de8e1528b2a118b7f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "html_url": "https://github.com/rust-lang/rust/commit/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3516f091bbf051f8f9d40ea0dda9ab8c4584e74", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3516f091bbf051f8f9d40ea0dda9ab8c4584e74", "html_url": "https://github.com/rust-lang/rust/commit/c3516f091bbf051f8f9d40ea0dda9ab8c4584e74"}], "stats": {"total": 449, "additions": 449, "deletions": 0}, "files": [{"sha": "0f4ad795b89ccc77084e6457e35f57381bf81c45", "filename": "src/comp/syntax/ext/auto_serialize.rs", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Fcomp%2Fsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Fcomp%2Fsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fauto_serialize.rs?ref=bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "patch": "@@ -0,0 +1,388 @@\n+/*\n+\n+The compiler code necessary to implement the #[auto_serialize]\n+extension.  The idea here is that type-defining items may be tagged\n+with #[auto_serialize], which will cause us to generate a little\n+companion module with the same name as the item.\n+\n+For example, a type like:\n+\n+    type node_id = uint;\n+\n+would generate a companion module like:\n+\n+    mod node_id {\n+        use std;\n+        import std::serialization::serializer;\n+        import std::serialization::deserializer;\n+        fn serialize<S: serializer>(s: S, v: node_id) {\n+             s.emit_uint(v);\n+        }\n+        fn deserializer<D: deserializer>(d: D) -> node_id {\n+             d.read_uint()\n+        }\n+    }\n+\n+Other interesting scenarios are whe the item has type parameters or\n+references other non-built-in types.  A type definition like:\n+\n+    type spanned<T> = {node: T, span: span};\n+\n+would yield a helper module like:\n+\n+    mod spanned {\n+        use std;\n+        import std::serialization::serializer;\n+        import std::serialization::deserializer;\n+        fn serialize<S: serializer,T>(s: S, t: fn(T), v: spanned<T>) {\n+             s.emit_rec(2u) {||\n+                 s.emit_rec_field(\"node\", 0u) {||\n+                     t(s.node);\n+                 };\n+                 s.emit_rec_field(\"span\", 1u) {||\n+                     span::serialize(s, s.span);\n+                 };\n+             }\n+        }\n+        fn deserializer<D: deserializer>(d: D, t: fn() -> T) -> node_id {\n+             d.read_rec(2u) {||\n+                 {node: d.read_rec_field(\"node\", 0u, t),\n+                  span: d.read_rec_field(\"span\", 1u) {||span::deserialize(d)}}\n+             }\n+        }\n+    }\n+\n+In general, the code to serialize an instance `v` of a non-built-in\n+type a::b::c<T0,...,Tn> looks like:\n+\n+    a::b::c::serialize(s, {|v| c_T0}, ..., {|v| c_Tn}, v)\n+\n+where `c_Ti` is the code to serialize an instance `v` of the type\n+`Ti`.\n+\n+Similarly, the code to deserialize an instance of a non-built-in type\n+`a::b::c<T0,...,Tn>` using the deserializer `d` looks like:\n+\n+    a::b::c::deserialize(d, {|| c_T0}, ..., {|| c_Tn})\n+\n+where `c_Ti` is the code to deserialize an instance of `Ti` using the\n+deserializer `d`.\n+\n+TODO--Hygiene. Search for \"__\" strings.\n+\n+*/\n+import base::*;\n+import driver::session::session;\n+import codemap::span;\n+import std::map;\n+\n+export expand_auto_serialize;\n+\n+enum ser_cx = {\n+    ext_cx: ext_ctxt,\n+    tps: map::map<str, fn@(@ast::expr) -> [@ast::stmt]>\n+};\n+\n+fn expand_auto_serialize(cx: ext_ctxt,\n+                         span: span,\n+                         mitem: ast::meta_item,\n+                         in_items: [@ast::item]) -> [@ast::item] {\n+    vec::flat_map(in_items) {|in_item|\n+        alt in_item.node {\n+          ast::item_ty(ty, tps) {\n+            [in_item, ty_module(cx, in_item.ident, ty, tps)]\n+          }\n+\n+          ast::item_enum(variants, tps) {\n+            [in_item, enum_module(cx, in_item.ident, variants, tps)]\n+          }\n+\n+          _ {\n+            cx.session().span_err(span, \"#[auto_serialize] can only be \\\n+                                         applied to type and enum \\\n+                                         definitions\");\n+            [in_item]\n+          }\n+        }\n+    }\n+}\n+\n+impl helpers for ser_cx {\n+    fn session() -> session { self.ext_cx.session() }\n+\n+    fn next_id() -> ast::node_id { self.session().next_node_id() }\n+\n+    fn path(span: span, strs: [str]) -> @ast::path {\n+        @{node: {global: false,\n+                 idents: strs + [\"serialize\"],\n+                 types: []},\n+          span: span}\n+    }\n+\n+    fn expr(span: span, node: ast::expr_) -> @ast::expr {\n+        @{id: self.next_id(), node: node, span: span}\n+    }\n+\n+    fn ty_path(span: span, strs: [str]) -> @ast::ty {\n+        @{node: ast::ty_path(self.path(span, strs), self.next_id()),\n+          span: span}\n+    }\n+\n+    fn var_ref(span: span, name: str) -> @ast::expr {\n+        self.expr(span, ast::expr_path(self.path(span, [name])))\n+    }\n+\n+    fn blk(span: span, stmts: [@ast::stmt]) -> ast::blk {\n+        {node: {view_items: [],\n+                stmts: stmts,\n+                expr: none,\n+                id: self.next_id(),\n+                rules: ast::default_blk},\n+         span: span}\n+    }\n+\n+    fn binder_pat(span: span, nm: str) -> @ast::pat {\n+        let path = @{node: {global: false,\n+                            idents: [nm],\n+                            types: []},\n+                     span: span};\n+        @{id: self.next_id(),\n+          node: ast::pat_ident(path, none),\n+          span: span}\n+    }\n+\n+    fn stmt(expr: @ast::expr) -> @ast::stmt {\n+        @{node: ast::stmt_semi(expr, self.next_id()),\n+          span: expr.span}\n+    }\n+\n+    fn alt_stmt(arms: [ast::arm], span: span, -v: @ast::expr) -> @ast::stmt {\n+        self.stmt(\n+            self.expr(\n+                span,\n+                ast::expr_alt(v, arms, ast::alt_exhaustive)))\n+    }\n+\n+    fn clone(v: @ast::expr) -> @ast::expr {\n+        let fld = fold::make_fold({\n+            new_id: {|_id| self.next_id()}\n+            with *fold::default_ast_fold()\n+        });\n+        fld.fold_expr(v)\n+    }\n+\n+    fn clone_ty_param(v: ast::ty_param) -> ast::ty_param {\n+        let fld = fold::make_fold({\n+            new_id: {|_id| self.next_id()}\n+            with *fold::default_ast_fold()\n+        });\n+        fold::fold_ty_param(v, fld)\n+    }\n+\n+    fn at(span: span, expr: @ast::expr) -> @ast::expr {\n+        fn repl_sp(old_span: span, repl_span: span, with_span: span) -> span {\n+            if old_span == repl_span {\n+                with_span\n+            } else {\n+                old_span\n+            }\n+        }\n+\n+        let fld = fold::make_fold({\n+            new_span: repl_sp(_, ast_util::dummy_sp(), span)\n+            with *fold::default_ast_fold()\n+        });\n+\n+        fld.fold_expr(expr)\n+    }\n+}\n+\n+fn serialize_path(cx: ser_cx, path: @ast::path, -s: @ast::expr, -v: @ast::expr)\n+    -> [@ast::stmt] {\n+    let ext_cx = cx.ext_cx;\n+\n+    // We want to take a path like a::b::c<...> and generate a call\n+    // like a::b::c::serialize(s, ...), as described above.\n+\n+    let callee =\n+        cx.expr(\n+            path.span,\n+            ast::expr_path(\n+                cx.path(path.span, path.node.idents + [\"serialize\"])));\n+\n+    let ty_args = vec::map(path.node.types) {|ty|\n+        let sv = serialize_ty(cx, ty, s, #ast(expr){\"__v\"});\n+        cx.at(ty.span, #ast(expr){\"{|__v| $(sv)}\"})\n+    };\n+\n+    [cx.stmt(\n+        cx.expr(\n+            path.span,\n+            ast::expr_call(callee, [s] + ty_args + [v], false)))]\n+}\n+\n+fn serialize_variant(cx: ser_cx,\n+                     tys: [@ast::ty],\n+                     span: span,\n+                     -s: @ast::expr,\n+                     pfn: fn([@ast::pat]) -> ast::pat_) -> ast::arm {\n+    let vnames = vec::init_fn(vec::len(tys)) {|i| #fmt[\"__v%u\", i]};\n+    let pats = vec::init_fn(vec::len(tys)) {|i|\n+        cx.binder_pat(tys[i].span, vnames[i])\n+    };\n+    let pat: @ast::pat = @{id: cx.next_id(), node: pfn(pats), span: span};\n+    let stmts = vec::init_fn(vec::len(tys)) {|i|\n+        let v = cx.var_ref(span, vnames[i]);\n+        serialize_ty(cx, tys[i], cx.clone(s), v)\n+    };\n+    {pats: [pat], guard: none, body: cx.blk(span, vec::concat(stmts))}\n+}\n+\n+fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n+    -> [@ast::stmt] {\n+    let ext_cx = cx.ext_cx;\n+\n+    alt ty.node {\n+      ast::ty_nil | ast::ty_bot {\n+        []\n+      }\n+\n+      ast::ty_box(mt) |\n+      ast::ty_uniq(mt) |\n+      ast::ty_ptr(mt) {\n+        serialize_ty(cx, mt.ty, s, #ast(expr){\"*$(v)\"})\n+      }\n+\n+      ast::ty_rec(flds) {\n+        vec::flat_map(flds) {|fld|\n+            let vf = cx.expr(\n+                fld.span,\n+                ast::expr_field(cx.clone(v), fld.node.ident, []));\n+            serialize_ty(cx, fld.node.mt.ty, cx.clone(s), vf)\n+        }\n+      }\n+\n+      ast::ty_fn(_, _) {\n+        cx.session().span_err(\n+            ty.span, #fmt[\"Cannot serialize function types\"]);\n+        []\n+      }\n+\n+      ast::ty_tup(tys) {\n+        // Generate code like\n+        //\n+        // alt v {\n+        //    (v1, v2, v3) {\n+        //       .. serialize v1, v2, v3 ..\n+        //    }\n+        // };\n+\n+        let arms = [\n+            serialize_variant(cx, tys, ty.span, s,\n+                              {|pats| ast::pat_tup(pats)})\n+        ];\n+        [cx.alt_stmt(arms, ty.span, v)]\n+      }\n+\n+      ast::ty_path(path, _) {\n+        if vec::len(path.node.idents) == 1u &&\n+            vec::is_empty(path.node.types) {\n+            let ident = path.node.idents[0];\n+\n+            alt cx.tps.find(ident) {\n+              some(f) { f(v) }\n+              none { serialize_path(cx, path, s, v) }\n+            }\n+        } else {\n+            serialize_path(cx, path, s, v)\n+        }\n+      }\n+\n+      ast::ty_constr(ty, _) {\n+        serialize_ty(cx, ty, s, v)\n+      }\n+\n+      ast::ty_mac(_) {\n+        cx.session().span_err(\n+            ty.span, #fmt[\"Cannot serialize macro types\"]);\n+        []\n+      }\n+\n+      ast::ty_infer {\n+        cx.session().span_err(\n+            ty.span, #fmt[\"Cannot serialize inferred types\"]);\n+        []\n+      }\n+\n+      ast::ty_vec(mt) {\n+        let ser_e =\n+            cx.expr(\n+                ty.span,\n+                expr_block(\n+                    cx.blk(\n+                        ty.span,\n+                        serialize_ty(\n+                            cx, mt.ty,\n+                            cx.clone(s),\n+                            cx.at(\n+                                ty.span,\n+                                #ast(expr){__e})))));\n+        [#ast(stmt){ $(s).emit_from_vec($(v), {|__e| $(ser_e) }) }]\n+      }\n+    }\n+}\n+\n+fn ty_module(ext_cx: ext_ctxt, name: str, -ty: @ast::ty, tps: [ast::ty_param])\n+    -> @ast::item {\n+\n+    let cx = ser_cx({ext_cx: ext_cx, tps: map::new_str_hash()});\n+\n+    let ser_inputs: [ast::arg] =\n+        [{mode: ast::expl(ast::by_ref),\n+          ty: cx.ty_path(ty.span, [\"__S\"]),\n+          ident: \"__s\",\n+          id: cx.next_id()},\n+         {mode: ast::expl(ast::by_ref),\n+          ty: ty,\n+          ident: \"__v\",\n+          id: cx.next_id()}] +\n+        vec::map(tps, {|tp|\n+            {mode: ast::expl(ast::by_ref),\n+             ty: cx.ty_path(ty.span, [tp.ident]),\n+             ident: \"__v\",\n+             id: cx.next_id()}});\n+\n+    let ser_bnds = @[ast::bound_iface(cx.ty_path(ty.span,\n+                                                 [\"__std\", \"serialization\",\n+                                                  \"serializer\"]))];\n+    let ser_tps: [ast::ty_param] =\n+        [{ident: \"__S\",\n+          id: cx.next_id(),\n+          bounds: ser_bnds}] +\n+        vec::map(tps) {|tp| cx.clone_ty_param(tp) };\n+\n+    let ser_output: @ast::ty = @{node: ast::ty_nil,\n+                                 span: ty.span};\n+\n+    let ser_blk = cx.blk(ty.span,\n+                         serialize_ty(cx, ty,\n+                                      #ast(expr){\"__s\"}, #ast(expr){\"__v\"}));\n+\n+    @{ident: \"serialize\",\n+      attrs: [],\n+      id: cx.next_id(),\n+      node: ast::item_fn({inputs: ser_inputs,\n+                          output: ser_output,\n+                          purity: ast::impure_fn,\n+                          cf: ast::return_val,\n+                          constraints: []},\n+                         ser_tps,\n+                         ser_blk),\n+      span: ty.span}\n+}\n+\n+fn enum_module(cx: ext_ctxt, name: str,\n+               variants: [ast::variant], tps: [ast::ty_param])\n+    -> @ast::item {\n+\n+}\n\\ No newline at end of file"}, {"sha": "663bc20001b7428a47e5b05ae8508ea1c53059eb", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "patch": "@@ -405,7 +405,15 @@ fn map<T, U>(v: [T], f: fn(T) -> U) -> [U] {\n     ret result;\n }\n \n+fn flat_map<T, U>(v: [T], f: fn(T) -> [U]) -> [U] {\n+    let result = [];\n+    for elem: T in v { result += f(elem); }\n+    ret result;\n+}\n+\n #[doc = \"\n+Function: map2\n+\n Apply a function to each pair of elements and return the results\n \"]\n fn map2<T: copy, U: copy, V>(v0: [const T], v1: [const U],"}, {"sha": "516159ee8f6d7fc309a5e38365dbe38e38c042c7", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "patch": "@@ -87,6 +87,7 @@ mod syntax {\n         mod concat_idents;\n         mod ident_to_str;\n         mod log_syntax;\n+        mod auto_serialize;\n     }\n     mod print {\n         mod pprust;"}, {"sha": "721f059ee35e3a91b492cdc26f909283807c3ae5", "filename": "src/rustc/syntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Frustc%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Frustc%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fbase.rs?ref=bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "patch": "@@ -11,10 +11,13 @@ type syntax_expander = {\n type macro_def = {ident: str, ext: syntax_extension};\n type macro_definer =\n     fn@(ext_ctxt, span, ast::mac_arg, ast::mac_body) -> macro_def;\n+type item_decorator =\n+    fn@(ext_ctxt, span, ast::meta_item, [@ast::item]) -> [@ast::item];\n \n enum syntax_extension {\n     normal(syntax_expander),\n     macro_defining(macro_definer),\n+    item_decorator(item_decorator),\n }\n \n // A temporary hard-coded map of methods for expanding syntax extension"}, {"sha": "8384f7a887329d13f3d28cce66a34d4da3ba98bb", "filename": "src/rustc/syntax/ext/expand.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Frustc%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Frustc%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fexpand.rs?ref=bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "patch": "@@ -1,13 +1,17 @@\n import driver::session;\n+import driver::session::session;\n \n import std::map::hashmap;\n \n+import front::attr;\n+\n import syntax::ast::{crate, expr_, expr_mac, mac_invoc};\n import syntax::fold::*;\n import syntax::ext::base::*;\n import syntax::ext::qquote::{qq_helper};\n import syntax::parse::parser::parse_expr_from_source_str;\n \n+\n import codemap::{span, expanded_from};\n \n fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n@@ -26,6 +30,11 @@ fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n                     cx.span_fatal(pth.span,\n                                   #fmt[\"macro undefined: '%s'\", extname])\n                   }\n+                  some(item_decorator(_)) {\n+                    cx.span_fatal(\n+                        pth.span,\n+                        #fmt[\"%s can only be used as a decorator\", extname]);\n+                  }\n                   some(normal({expander: exp, span: exp_sp})) {\n                     let expanded = exp(cx, pth.span, args, body);\n \n@@ -52,6 +61,44 @@ fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n         };\n }\n \n+fn expand_mod_items(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n+                    module: ast::_mod, fld: ast_fold,\n+                    orig: fn@(ast::_mod, ast_fold) -> ast::_mod)\n+    -> ast::_mod\n+{\n+    // Fold the contents first:\n+    let module = orig(module, fld);\n+\n+    // For each item, look through the attributes.  If any of them are\n+    // decorated with \"item decorators\", then use that function to transform\n+    // the item into a new set of items.\n+    let new_items = vec::flat_map(module.items) {|item|\n+        vec::foldr(item.attrs, [item]) {|attr, items|\n+            let mname = alt attr.node.value.node {\n+              ast::meta_word(n) { n }\n+              ast::meta_name_value(n, _) { n }\n+              ast::meta_list(n, _) { n }\n+            };\n+            alt exts.find(mname) {\n+              none { items }\n+\n+              some(normal(_)) | some(macro_defining(_)) {\n+                cx.span_err(\n+                    attr.span,\n+                    #fmt[\"%s cannot be used as a decorator\", mname]);\n+                items\n+              }\n+\n+              some(item_decorator(dec_fn)) {\n+                dec_fn(cx, attr.span, attr.node.value, items)\n+              }\n+            }\n+        }\n+    };\n+\n+    ret {items: new_items with module};\n+}\n+\n fn new_span(cx: ext_ctxt, sp: span) -> span {\n     /* this discards information in the case of macro-defining macros */\n     ret {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n@@ -78,6 +125,7 @@ fn expand_crate(sess: session::session, c: @crate) -> @crate {\n     let cx: ext_ctxt = mk_ctxt(sess);\n     let f_pre =\n         {fold_expr: bind expand_expr(exts, cx, _, _, _, afp.fold_expr),\n+         fold_mod: bind expand_mod_items(exts, cx, _, _, afp.fold_mod),\n          new_span: bind new_span(cx, _)\n             with *afp};\n     let f = make_fold(f_pre);"}, {"sha": "9e6ee76db9b18a0c0501e6c093f5738adf2a5d5a", "filename": "src/rustc/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Frustc%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45/src%2Frustc%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Ffold.rs?ref=bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "patch": "@@ -13,6 +13,7 @@ export noop_fold_mod;\n export noop_fold_ty;\n export noop_fold_block;\n export wrap;\n+export fold_ty_param;\n \n type ast_fold = @mutable a_f;\n "}]}