{"sha": "5b4316377b9897f064b213a52a7efe8622d48487", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNDMxNjM3N2I5ODk3ZjA2NGIyMTNhNTJhN2VmZTg2MjJkNDg0ODc=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-05T18:28:53Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-07T12:12:08Z"}, "message": "improving documentation", "tree": {"sha": "6abe2b962393a56a6e500a22fa24ca2e22fa200e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6abe2b962393a56a6e500a22fa24ca2e22fa200e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b4316377b9897f064b213a52a7efe8622d48487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b4316377b9897f064b213a52a7efe8622d48487", "html_url": "https://github.com/rust-lang/rust/commit/5b4316377b9897f064b213a52a7efe8622d48487", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b4316377b9897f064b213a52a7efe8622d48487/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43dfd894934cf7c9161e473495a4e24965239475", "url": "https://api.github.com/repos/rust-lang/rust/commits/43dfd894934cf7c9161e473495a4e24965239475", "html_url": "https://github.com/rust-lang/rust/commit/43dfd894934cf7c9161e473495a4e24965239475"}], "stats": {"total": 80, "additions": 64, "deletions": 16}, "files": [{"sha": "8b9bdb7cd5a5dd8875f06fdee011d8f499b0526b", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 64, "deletions": 16, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5b4316377b9897f064b213a52a7efe8622d48487/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b4316377b9897f064b213a52a7efe8622d48487/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=5b4316377b9897f064b213a52a7efe8622d48487", "patch": "@@ -2,7 +2,7 @@\n //! for match arms.\n //!\n //! It is modeled on the rustc module `librustc_mir_build::hair::pattern::_match`, which\n-//! contains very detailed documentation about the match checking algorithm.\n+//! contains very detailed documentation about the algorithms used here.\n use std::sync::Arc;\n \n use smallvec::{smallvec, SmallVec};\n@@ -15,6 +15,14 @@ use crate::{\n use hir_def::{adt::VariantData, EnumVariantId, VariantId};\n \n #[derive(Debug, Clone, Copy)]\n+/// Either a pattern from the source code being analyzed, represented as\n+/// as `PatId`, or a `Wild` pattern which is created as an intermediate\n+/// step in the match checking algorithm and thus is not backed by a\n+/// real `PatId`.\n+///\n+/// Note that it is totally valid for the `PatId` variant to contain\n+/// a `PatId` which resolves to a `Wild` pattern, if that wild pattern\n+/// exists in the source code being analyzed.\n enum PatIdOrWild {\n     PatId(PatId),\n     Wild,\n@@ -44,11 +52,22 @@ impl From<PatId> for PatIdOrWild {\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n pub struct MatchCheckNotImplemented;\n+\n+/// The return type of `is_useful` is either an indication of usefulness\n+/// of the match arm, or an error in the case the match statement\n+/// is made up of types for which exhaustiveness checking is currently\n+/// not completely implemented.\n+///\n+/// The `std::result::Result` type is used here rather than a custom enum\n+/// to allow the use of `?`.\n pub type MatchCheckResult<T> = Result<T, MatchCheckNotImplemented>;\n \n-type PatStackInner = SmallVec<[PatIdOrWild; 2]>;\n #[derive(Debug)]\n+/// A row in a Matrix.\n+///\n+/// This type is modeled from the struct of the same name in `rustc`.\n pub(crate) struct PatStack(PatStackInner);\n+type PatStackInner = SmallVec<[PatIdOrWild; 2]>;\n \n impl PatStack {\n     pub(crate) fn from_pattern(pat_id: PatId) -> PatStack {\n@@ -94,7 +113,9 @@ impl PatStack {\n         PatStack::from_vec(patterns)\n     }\n \n-    // Computes `D(self)`.\n+    /// Computes `D(self)`.\n+    ///\n+    /// See the module docs and the associated documentation in rustc for details.\n     fn specialize_wildcard(&self, cx: &MatchCheckCtx) -> Option<PatStack> {\n         if matches!(self.head().as_pat(cx), Pat::Wild) {\n             Some(self.to_tail())\n@@ -103,7 +124,9 @@ impl PatStack {\n         }\n     }\n \n-    // Computes `S(constructor, self)`.\n+    /// Computes `S(constructor, self)`.\n+    ///\n+    /// See the module docs and the associated documentation in rustc for details.\n     fn specialize_constructor(\n         &self,\n         cx: &MatchCheckCtx,\n@@ -146,6 +169,11 @@ impl PatStack {\n         Ok(result)\n     }\n \n+    /// A special case of `specialize_constructor` where the head of the pattern stack\n+    /// is a Wild pattern.\n+    ///\n+    /// Replaces the Wild pattern at the head of the pattern stack with N Wild patterns\n+    /// (N >= 0), where N is the arity of the given constructor.\n     fn expand_wildcard(\n         &self,\n         cx: &MatchCheckCtx,\n@@ -183,6 +211,9 @@ impl PatStack {\n }\n \n #[derive(Debug)]\n+/// A collection of PatStack.\n+///\n+/// This type is modeled from the struct of the same name in `rustc`.\n pub(crate) struct Matrix(Vec<PatStack>);\n \n impl Matrix {\n@@ -191,8 +222,8 @@ impl Matrix {\n     }\n \n     pub(crate) fn push(&mut self, cx: &MatchCheckCtx, row: PatStack) {\n-        // if the pattern is an or pattern it should be expanded\n         if let Some(Pat::Or(pat_ids)) = row.get_head().map(|pat_id| pat_id.as_pat(cx)) {\n+            // Or patterns are expanded here\n             for pat_id in pat_ids {\n                 self.0.push(PatStack::from_pattern(pat_id));\n             }\n@@ -209,12 +240,16 @@ impl Matrix {\n         self.0.iter().map(|p| p.head()).collect()\n     }\n \n-    // Computes `D(self)`.\n+    /// Computes `D(self)` for each contained PatStack.\n+    ///\n+    /// See the module docs and the associated documentation in rustc for details.\n     fn specialize_wildcard(&self, cx: &MatchCheckCtx) -> Self {\n         Self::collect(cx, self.0.iter().filter_map(|r| r.specialize_wildcard(cx)))\n     }\n \n-    // Computes `S(constructor, self)`.\n+    /// Computes `S(constructor, self)` for each contained PatStack.\n+    ///\n+    /// See the module docs and the associated documentation in rustc for details.\n     fn specialize_constructor(\n         &self,\n         cx: &MatchCheckCtx,\n@@ -243,6 +278,11 @@ impl Matrix {\n }\n \n #[derive(Clone, Debug, PartialEq)]\n+/// An indication of the usefulness of a given match arm, where\n+/// usefulness is defined as matching some patterns which were\n+/// not matched by an prior match arms.\n+///\n+/// We may eventually need an `Unknown` variant here.\n pub enum Usefulness {\n     Useful,\n     NotUseful,\n@@ -257,6 +297,11 @@ pub struct MatchCheckCtx<'a> {\n /// Given a set of patterns `matrix`, and pattern to consider `v`, determines\n /// whether `v` is useful. A pattern is useful if it covers cases which were\n /// not previously covered.\n+///\n+/// When calling this function externally (that is, not the recursive calls) it\n+/// expected that you have already type checked the match arms. All patterns in\n+/// matrix should be the same type as v, as well as they should all be the same\n+/// type as the match expression.\n pub(crate) fn is_useful(\n     cx: &MatchCheckCtx,\n     matrix: &Matrix,\n@@ -311,8 +356,9 @@ pub(crate) fn is_useful(\n         // We assume here that the first constructor is the \"correct\" type. Since we\n         // only care about the \"type\" of the constructor (i.e. if it is a bool we\n         // don't care about the value), this assumption should be valid as long as\n-        // the match statement is well formed. But potentially a better way to handle\n-        // this is to use the match expressions type.\n+        // the match statement is well formed. We currently uphold this invariant by\n+        // filtering match arms before calling `is_useful`, only passing in match arms\n+        // whose type matches the type of the match expression.\n         match &used_constructors.first() {\n             Some(constructor) if all_constructors_covered(&cx, constructor, &used_constructors) => {\n                 // If all constructors are covered, then we need to consider whether\n@@ -380,23 +426,25 @@ pub(crate) fn is_useful(\n }\n \n #[derive(Debug)]\n+/// Similar to TypeCtor, but includes additional information about the specific\n+/// value being instantiated. For example, TypeCtor::Bool doesn't contain the\n+/// boolean value.\n enum Constructor {\n     Bool(bool),\n     Tuple { arity: usize },\n     Enum(EnumVariantId),\n }\n \n+/// Returns the constructor for the given pattern. Should only return None\n+/// in the case of a Wild pattern.\n fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Option<Constructor>> {\n     let res = match pat.as_pat(cx) {\n         Pat::Wild => None,\n         Pat::Tuple(pats) => Some(Constructor::Tuple { arity: pats.len() }),\n-        Pat::Lit(lit_expr) => {\n-            // for now we only support bool literals\n-            match cx.body.exprs[lit_expr] {\n-                Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n-                _ => return Err(MatchCheckNotImplemented),\n-            }\n-        }\n+        Pat::Lit(lit_expr) => match cx.body.exprs[lit_expr] {\n+            Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n+            _ => return Err(MatchCheckNotImplemented),\n+        },\n         Pat::TupleStruct { .. } | Pat::Path(_) => {\n             let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n             let variant_id ="}]}