{"sha": "4a16b562a8c761bc1c5359cb86753c010148f83c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMTZiNTYyYThjNzYxYmMxYzUzNTljYjg2NzUzYzAxMDE0OGY4M2M=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-10-21T16:01:58Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-11-15T17:22:32Z"}, "message": "fix remaining bugs", "tree": {"sha": "ccf6f7dcbea04679bacff22f5cfab8fc32652725", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccf6f7dcbea04679bacff22f5cfab8fc32652725"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a16b562a8c761bc1c5359cb86753c010148f83c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a16b562a8c761bc1c5359cb86753c010148f83c", "html_url": "https://github.com/rust-lang/rust/commit/4a16b562a8c761bc1c5359cb86753c010148f83c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a16b562a8c761bc1c5359cb86753c010148f83c/comments", "author": null, "committer": null, "parents": [{"sha": "c998057770737a6419880b9177317f5fced75912", "url": "https://api.github.com/repos/rust-lang/rust/commits/c998057770737a6419880b9177317f5fced75912", "html_url": "https://github.com/rust-lang/rust/commit/c998057770737a6419880b9177317f5fced75912"}], "stats": {"total": 184, "additions": 125, "deletions": 59}, "files": [{"sha": "691bac0cef865f82c6cde00f92074961e1018226", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=4a16b562a8c761bc1c5359cb86753c010148f83c", "patch": "@@ -340,47 +340,53 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n            ty,\n            bound);\n \n-    if !ty.has_infer_types() && !ty.has_closure_types() {\n-        let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n-        let obligation =\n-            util::predicate_for_builtin_bound(infcx.tcx, cause, bound, 0, ty);\n-        let obligation = match obligation {\n-            Ok(o) => o,\n-            Err(..) => return false\n-        };\n-        let result = SelectionContext::new(infcx)\n-            .evaluate_obligation_conservatively(&obligation);\n-        debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} => {:?}\",\n-               ty, bound, result);\n-        return result;\n-    }\n-\n-    let mut fulfill_cx = FulfillmentContext::new(false);\n-\n-    // We can use a dummy node-id here because we won't pay any mind\n-    // to region obligations that arise (there shouldn't really be any\n-    // anyhow).\n     let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n+    let obligation =\n+        util::predicate_for_builtin_bound(infcx.tcx, cause, bound, 0, ty);\n+    let obligation = match obligation {\n+        Ok(o) => o,\n+        Err(..) => return false\n+    };\n+    let result = SelectionContext::new(infcx)\n+        .evaluate_obligation_conservatively(&obligation);\n+    debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} => {:?}\",\n+           ty, bound, result);\n+\n+    if result && (ty.has_infer_types() || ty.has_closure_types()) {\n+        // Because of inference \"guessing\", selection can sometimes claim\n+        // to succeed while the success requires a guess. To ensure\n+        // this function's result remains infallible, we must confirm\n+        // that guess. While imperfect, I believe this is sound.\n+\n+        let mut fulfill_cx = FulfillmentContext::new(false);\n+\n+        // We can use a dummy node-id here because we won't pay any mind\n+        // to region obligations that arise (there shouldn't really be any\n+        // anyhow).\n+        let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n \n-    fulfill_cx.register_builtin_bound(infcx, ty, bound, cause);\n-\n-    // Note: we only assume something is `Copy` if we can\n-    // *definitively* show that it implements `Copy`. Otherwise,\n-    // assume it is move; linear is always ok.\n-    match fulfill_cx.select_all_or_error(infcx) {\n-        Ok(()) => {\n-            debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} success\",\n-                   ty,\n-                   bound);\n-            true\n-        }\n-        Err(e) => {\n-            debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} errors={:?}\",\n-                   ty,\n-                   bound,\n-                   e);\n-            false\n+        fulfill_cx.register_builtin_bound(infcx, ty, bound, cause);\n+\n+        // Note: we only assume something is `Copy` if we can\n+        // *definitively* show that it implements `Copy`. Otherwise,\n+        // assume it is move; linear is always ok.\n+        match fulfill_cx.select_all_or_error(infcx) {\n+            Ok(()) => {\n+                debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} success\",\n+                       ty,\n+                       bound);\n+                true\n+            }\n+            Err(e) => {\n+                debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} errors={:?}\",\n+                       ty,\n+                       bound,\n+                       e);\n+                false\n+            }\n         }\n+    } else {\n+        result\n     }\n }\n "}, {"sha": "98ee94fe328e33549c3cfadf91c84d812d9b702f", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=4a16b562a8c761bc1c5359cb86753c010148f83c", "patch": "@@ -2851,18 +2851,37 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  -> Vec<PredicateObligation<'tcx>>\n     {\n         debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);\n+        let tcx = self.tcx();\n \n-        let predicates = self.tcx().lookup_predicates(def_id);\n-        let predicates = predicates.instantiate(self.tcx(), substs);\n-        let predicates = normalize_with_depth(self, cause.clone(), recursion_depth, &predicates);\n-        let predicates = self.infcx().plug_leaks(skol_map, snapshot, &predicates);\n-\n-        let mut obligations = predicates.obligations;\n-        obligations.append(\n-            &mut util::predicates_for_generics(cause,\n-                                               recursion_depth,\n-                                               &predicates.value));\n-        obligations\n+        // To allow for one-pass evaluation of the nested obligation,\n+        // each predicate must be preceded by the obligations required\n+        // to normalize it.\n+        // for example, if we have:\n+        //    impl<U: Iterator, V: Iterator<Item=U>> Foo for V where U::Item: Copy\n+        // the impl will have the following predicates:\n+        //    <V as Iterator>::Item = U,\n+        //    U: Iterator, U: Sized,\n+        //    V: Iterator, V: Sized,\n+        //    <U as Iterator>::Item: Copy\n+        // When we substitute, say, `V => IntoIter<u32>, U => $0`, the last\n+        // obligation will normalize to `<$0 as Iterator>::Item = $1` and\n+        // `$1: Copy`, so we must ensure the obligations are emitted in\n+        // that order.\n+        let predicates = tcx\n+            .lookup_predicates(def_id)\n+            .predicates.iter()\n+            .flat_map(|predicate| {\n+                let predicate =\n+                    normalize_with_depth(self, cause.clone(), recursion_depth,\n+                                         &predicate.subst(tcx, substs));\n+                predicate.obligations.into_iter().chain(\n+                    Some(Obligation {\n+                        cause: cause.clone(),\n+                        recursion_depth: recursion_depth,\n+                        predicate: predicate.value\n+                    }))\n+            }).collect();\n+        self.infcx().plug_leaks(skol_map, snapshot, &predicates)\n     }\n \n     #[allow(unused_comparisons)]"}, {"sha": "d14b0fa9e6602a397e3a715961b44370909aa0df", "filename": "src/test/compile-fail/cast-rfc0401.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs?ref=4a16b562a8c761bc1c5359cb86753c010148f83c", "patch": "@@ -37,6 +37,7 @@ fn main()\n     let f: f32 = 1.2;\n     let v = 0 as *const u8;\n     let fat_v : *const [u8] = unsafe { &*(0 as *const [u8; 1])};\n+    let fat_sv : *const [i8] = unsafe { &*(0 as *const [i8; 1])};\n     let foo: &Foo = &f;\n \n     let _ = v as &u8; //~ ERROR non-scalar\n@@ -94,7 +95,7 @@ fn main()\n     let _ = main as *mut str; //~ ERROR casting\n     let _ = &f as *mut f32; //~ ERROR casting\n     let _ = &f as *const f64; //~ ERROR casting\n-    let _ = fat_v as usize;\n+    let _ = fat_sv as usize;\n     //~^ ERROR casting\n     //~^^ HELP through a thin pointer first\n \n@@ -106,7 +107,7 @@ fn main()\n     let _ = main.f as *const u32; //~ ERROR attempted access of field\n \n     let cf: *const Foo = &0;\n-    let _ = cf as *const [u8];\n+    let _ = cf as *const [u16];\n     //~^ ERROR casting\n     //~^^ NOTE vtable kinds\n     let _ = cf as *const Bar;"}, {"sha": "28806b6e2ab8cbd39eceb141c533e71e0abd2b61", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=4a16b562a8c761bc1c5359cb86753c010148f83c", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//~^^^^^^^^^^ ERROR overflow\n //\n // We get an error message at the top of file (dummy span).\n // This is not helpful, but also kind of annoying to prevent,\n@@ -32,6 +31,7 @@ impl<T:Clone> ToOpt for Option<T> {\n }\n \n fn function<T:ToOpt + Clone>(counter: usize, t: T) {\n+//~^ ERROR reached the recursion limit during monomorphization\n     if counter > 0 {\n         function(counter - 1, t.to_option());\n         // FIXME(#4287) Error message should be here. It should be"}, {"sha": "b1d45a82276a8b3c39bae308870f96d2a8ba1449", "filename": "src/test/compile-fail/recursion.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion.rs?ref=4a16b562a8c761bc1c5359cb86753c010148f83c", "patch": "@@ -8,12 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//~^^^^^^^^^^ ERROR overflow\n-//\n-// We get an error message at the top of file (dummy span).\n-// This is not helpful, but also kind of annoying to prevent,\n-// so for now just live with it.\n-\n enum Nil {NilValue}\n struct Cons<T> {head:isize, tail:T}\n trait Dot {fn dot(&self, other:Self) -> isize;}\n@@ -26,7 +20,7 @@ impl<T:Dot> Dot for Cons<T> {\n   }\n }\n fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize {\n-  match n {    0 => {first.dot(second)}\n+  match n {    0 => {first.dot(second)} //~ ERROR overflow\n       // FIXME(#4287) Error message should be here. It should be\n       // a type error to instantiate `test` at a type other than T.\n     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}"}, {"sha": "71cd3c9441e104e5698d880c88cc51e2a3d77ec8", "filename": "src/test/run-pass/trait-copy-guessing.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Ftest%2Frun-pass%2Ftrait-copy-guessing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a16b562a8c761bc1c5359cb86753c010148f83c/src%2Ftest%2Frun-pass%2Ftrait-copy-guessing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-copy-guessing.rs?ref=4a16b562a8c761bc1c5359cb86753c010148f83c", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// \"guessing\" in trait selection can affect `copy_or_move`. Check that this\n+// is correctly handled. I am not sure what is the \"correct\" behaviour,\n+// but we should at least not ICE.\n+\n+use std::mem;\n+\n+struct U([u8; 1337]);\n+\n+struct S<'a,T:'a>(&'a T);\n+impl<'a, T> Clone for S<'a, T> { fn clone(&self) -> Self { S(self.0) } }\n+/// This impl triggers inference \"guessing\" - S<_>: Copy => _ = U\n+impl<'a> Copy for S<'a, Option<U>> {}\n+\n+fn assert_impls_fn<R,T: Fn()->R>(_: &T){}\n+\n+fn main() {\n+    let n = None;\n+    let e = S(&n);\n+    let f = || {\n+        // S being copy is critical for this to work\n+        drop(e);\n+        mem::size_of_val(e.0)\n+    };\n+    assert_impls_fn(&f);\n+    assert_eq!(f(), 1337+1);\n+\n+    assert_eq!((|| {\n+        // S being Copy is not critical here, but\n+        // we check it anyway.\n+        let n = None;\n+        let e = S(&n);\n+        let ret = mem::size_of_val(e.0);\n+        drop(e);\n+        ret\n+    })(), 1337+1);\n+}"}]}