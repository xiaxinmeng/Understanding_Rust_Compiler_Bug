{"sha": "ad7802f9d45b884dad58931c7a8bec91d196ad0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNzgwMmY5ZDQ1Yjg4NGRhZDU4OTMxYzdhOGJlYzkxZDE5NmFkMGU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-10T07:40:02Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-11T08:07:43Z"}, "message": "Micro-optimize the heck out of LEB128 reading and writing.\n\nThis commit makes the following writing improvements:\n- Removes the unnecessary `write_to_vec` function.\n- Reduces the number of conditions per loop from 2 to 1.\n- Avoids a mask and a shift on the final byte.\n\nAnd the following reading improvements:\n- Removes an unnecessary type annotation.\n- Fixes a dangerous unchecked slice access. Imagine a slice `[0x80]` --\n  the current code will read past the end of the slice some number of\n  bytes. The bounds check at the end will subsequently trigger, unless\n  something bad (like a crash) happens first. The cost of doing bounds\n  check in the loop body is negligible.\n- Avoids a mask on the final byte.\n\nAnd the following improvements for both reading and writing:\n- Changes `for` to `loop` for the loops, avoiding an unnecessary\n  condition on each iteration. This also removes the need for\n  `leb128_size`.\n\nAll of these changes give significant perf wins, up to 5%.", "tree": {"sha": "a75abe2791323a45fd0b243d4d7fdf0913eea2aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a75abe2791323a45fd0b243d4d7fdf0913eea2aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad7802f9d45b884dad58931c7a8bec91d196ad0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad7802f9d45b884dad58931c7a8bec91d196ad0e", "html_url": "https://github.com/rust-lang/rust/commit/ad7802f9d45b884dad58931c7a8bec91d196ad0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad7802f9d45b884dad58931c7a8bec91d196ad0e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "html_url": "https://github.com/rust-lang/rust/commit/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a"}], "stats": {"total": 64, "additions": 14, "deletions": 50}, "files": [{"sha": "1fe6a309e9650a90f39f8cf639aff03538268e28", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 14, "deletions": 50, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ad7802f9d45b884dad58931c7a8bec91d196ad0e/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7802f9d45b884dad58931c7a8bec91d196ad0e/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=ad7802f9d45b884dad58931c7a8bec91d196ad0e", "patch": "@@ -1,46 +1,14 @@\n-#[inline]\n-pub fn write_to_vec(vec: &mut Vec<u8>, byte: u8) {\n-    vec.push(byte);\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-const USIZE_LEB128_SIZE: usize = 5;\n-#[cfg(target_pointer_width = \"64\")]\n-const USIZE_LEB128_SIZE: usize = 10;\n-\n-macro_rules! leb128_size {\n-    (u16) => {\n-        3\n-    };\n-    (u32) => {\n-        5\n-    };\n-    (u64) => {\n-        10\n-    };\n-    (u128) => {\n-        19\n-    };\n-    (usize) => {\n-        USIZE_LEB128_SIZE\n-    };\n-}\n-\n macro_rules! impl_write_unsigned_leb128 {\n     ($fn_name:ident, $int_ty:ident) => {\n         #[inline]\n         pub fn $fn_name(out: &mut Vec<u8>, mut value: $int_ty) {\n-            for _ in 0..leb128_size!($int_ty) {\n-                let mut byte = (value & 0x7F) as u8;\n-                value >>= 7;\n-                if value != 0 {\n-                    byte |= 0x80;\n-                }\n-\n-                write_to_vec(out, byte);\n-\n-                if value == 0 {\n+            loop {\n+                if value < 0x80 {\n+                    out.push(value as u8);\n                     break;\n+                } else {\n+                    out.push(((value & 0x7f) | 0x80) as u8);\n+                    value >>= 7;\n                 }\n             }\n         }\n@@ -57,24 +25,20 @@ macro_rules! impl_read_unsigned_leb128 {\n     ($fn_name:ident, $int_ty:ident) => {\n         #[inline]\n         pub fn $fn_name(slice: &[u8]) -> ($int_ty, usize) {\n-            let mut result: $int_ty = 0;\n+            let mut result = 0;\n             let mut shift = 0;\n             let mut position = 0;\n-\n-            for _ in 0..leb128_size!($int_ty) {\n-                let byte = unsafe { *slice.get_unchecked(position) };\n+            loop {\n+                let byte = slice[position];\n                 position += 1;\n-                result |= ((byte & 0x7F) as $int_ty) << shift;\n                 if (byte & 0x80) == 0 {\n-                    break;\n+                    result |= (byte as $int_ty) << shift;\n+                    return (result, position);\n+                } else {\n+                    result |= ((byte & 0x7F) as $int_ty) << shift;\n                 }\n                 shift += 7;\n             }\n-\n-            // Do a single bounds check at the end instead of for every byte.\n-            assert!(position <= slice.len());\n-\n-            (result, position)\n         }\n     };\n }\n@@ -116,7 +80,7 @@ where\n \n #[inline]\n pub fn write_signed_leb128(out: &mut Vec<u8>, value: i128) {\n-    write_signed_leb128_to(value, |v| write_to_vec(out, v))\n+    write_signed_leb128_to(value, |v| out.push(v))\n }\n \n #[inline]"}]}