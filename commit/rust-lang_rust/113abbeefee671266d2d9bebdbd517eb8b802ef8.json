{"sha": "113abbeefee671266d2d9bebdbd517eb8b802ef8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExM2FiYmVlZmVlNjcxMjY2ZDJkOWJlYmRiZDUxN2ViOGI4MDJlZjg=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-22T09:15:19Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-24T11:34:00Z"}, "message": "SSR: Parse template as Rust code.\n\nThis is in preparation for a subsequent commit where we add special\nhandling for paths in the template, allowing them to be qualified\ndifferently in different contexts.", "tree": {"sha": "a7c44c0490b09f06034cb82966b8a61f681c4433", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7c44c0490b09f06034cb82966b8a61f681c4433"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/113abbeefee671266d2d9bebdbd517eb8b802ef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/113abbeefee671266d2d9bebdbd517eb8b802ef8", "html_url": "https://github.com/rust-lang/rust/commit/113abbeefee671266d2d9bebdbd517eb8b802ef8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/113abbeefee671266d2d9bebdbd517eb8b802ef8/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fce8b6ba32bebba36d588d07781e9e578845728", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fce8b6ba32bebba36d588d07781e9e578845728", "html_url": "https://github.com/rust-lang/rust/commit/1fce8b6ba32bebba36d588d07781e9e578845728"}], "stats": {"total": 194, "additions": 112, "deletions": 82}, "files": [{"sha": "b28913a650aef0c577b5c97a68ff3fe64ff40cc1", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/113abbeefee671266d2d9bebdbd517eb8b802ef8/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113abbeefee671266d2d9bebdbd517eb8b802ef8/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=113abbeefee671266d2d9bebdbd517eb8b802ef8", "patch": "@@ -15,7 +15,6 @@ pub use crate::errors::SsrError;\n pub use crate::matching::Match;\n use crate::matching::MatchFailureReason;\n use hir::Semantics;\n-use parsing::SsrTemplate;\n use ra_db::{FileId, FileRange};\n use ra_syntax::{ast, AstNode, SyntaxNode, TextRange};\n use ra_text_edit::TextEdit;\n@@ -26,7 +25,7 @@ pub struct SsrRule {\n     /// A structured pattern that we're searching for.\n     pattern: parsing::RawPattern,\n     /// What we'll replace it with.\n-    template: SsrTemplate,\n+    template: parsing::RawPattern,\n     parsed_rules: Vec<parsing::ParsedRule>,\n }\n \n@@ -72,7 +71,11 @@ impl<'db> MatchFinder<'db> {\n             None\n         } else {\n             use ra_db::SourceDatabaseExt;\n-            Some(replacing::matches_to_edit(&matches, &self.sema.db.file_text(file_id)))\n+            Some(replacing::matches_to_edit(\n+                &matches,\n+                &self.sema.db.file_text(file_id),\n+                &self.rules,\n+            ))\n         }\n     }\n \n@@ -111,9 +114,8 @@ impl<'db> MatchFinder<'db> {\n     }\n \n     fn add_parsed_rules(&mut self, parsed_rules: Vec<parsing::ParsedRule>) {\n-        // FIXME: This doesn't need to be a for loop, but does in a subsequent commit. Justify it\n-        // being a for-loop.\n-        for parsed_rule in parsed_rules {\n+        for mut parsed_rule in parsed_rules {\n+            parsed_rule.index = self.rules.len();\n             self.rules.push(parsed_rule);\n         }\n     }"}, {"sha": "486191635d6f6a2fff7785cb402eaa947fe249a2", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/113abbeefee671266d2d9bebdbd517eb8b802ef8/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113abbeefee671266d2d9bebdbd517eb8b802ef8/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=113abbeefee671266d2d9bebdbd517eb8b802ef8", "patch": "@@ -2,7 +2,7 @@\n //! process of matching, placeholder values are recorded.\n \n use crate::{\n-    parsing::{Constraint, NodeKind, ParsedRule, Placeholder, SsrTemplate},\n+    parsing::{Constraint, NodeKind, ParsedRule, Placeholder},\n     SsrMatches,\n };\n use hir::Semantics;\n@@ -48,9 +48,7 @@ pub struct Match {\n     pub(crate) matched_node: SyntaxNode,\n     pub(crate) placeholder_values: FxHashMap<Var, PlaceholderMatch>,\n     pub(crate) ignored_comments: Vec<ast::Comment>,\n-    // A copy of the template for the rule that produced this match. We store this on the match for\n-    // if/when we do replacement.\n-    pub(crate) template: Option<SsrTemplate>,\n+    pub(crate) rule_index: usize,\n }\n \n /// Represents a `$var` in an SSR query.\n@@ -131,7 +129,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n             matched_node: code.clone(),\n             placeholder_values: FxHashMap::default(),\n             ignored_comments: Vec::new(),\n-            template: rule.template.clone(),\n+            rule_index: rule.index,\n         };\n         // Second matching pass, where we record placeholder matches, ignored comments and maybe do\n         // any other more expensive checks that we didn't want to do on the first pass.\n@@ -591,7 +589,7 @@ mod tests {\n             \"1+2\"\n         );\n \n-        let edit = crate::replacing::matches_to_edit(&matches, input);\n+        let edit = crate::replacing::matches_to_edit(&matches, input, &match_finder.rules);\n         let mut after = input.to_string();\n         edit.apply(&mut after);\n         assert_eq!(after, \"fn foo() {} fn main() { bar(1+2); }\");"}, {"sha": "cf7fb517fa1d2fc8534a9f32a14a88251746c58c", "filename": "crates/ra_ssr/src/parsing.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/113abbeefee671266d2d9bebdbd517eb8b802ef8/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113abbeefee671266d2d9bebdbd517eb8b802ef8/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fparsing.rs?ref=113abbeefee671266d2d9bebdbd517eb8b802ef8", "patch": "@@ -15,12 +15,8 @@ use std::str::FromStr;\n pub(crate) struct ParsedRule {\n     pub(crate) placeholders_by_stand_in: FxHashMap<SmolStr, Placeholder>,\n     pub(crate) pattern: SyntaxNode,\n-    pub(crate) template: Option<SsrTemplate>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct SsrTemplate {\n-    pub(crate) tokens: Vec<PatternElement>,\n+    pub(crate) template: Option<SyntaxNode>,\n+    pub(crate) index: usize,\n }\n \n #[derive(Debug)]\n@@ -64,18 +60,23 @@ pub(crate) struct Token {\n impl ParsedRule {\n     fn new(\n         pattern: &RawPattern,\n-        template: Option<&SsrTemplate>,\n+        template: Option<&RawPattern>,\n     ) -> Result<Vec<ParsedRule>, SsrError> {\n         let raw_pattern = pattern.as_rust_code();\n+        let raw_template = template.map(|t| t.as_rust_code());\n+        let raw_template = raw_template.as_ref().map(|s| s.as_str());\n         let mut builder = RuleBuilder {\n             placeholders_by_stand_in: pattern.placeholders_by_stand_in(),\n             rules: Vec::new(),\n         };\n-        builder.try_add(ast::Expr::parse(&raw_pattern), template);\n-        builder.try_add(ast::TypeRef::parse(&raw_pattern), template);\n-        builder.try_add(ast::ModuleItem::parse(&raw_pattern), template);\n-        builder.try_add(ast::Path::parse(&raw_pattern), template);\n-        builder.try_add(ast::Pat::parse(&raw_pattern), template);\n+        builder.try_add(ast::Expr::parse(&raw_pattern), raw_template.map(ast::Expr::parse));\n+        builder.try_add(ast::TypeRef::parse(&raw_pattern), raw_template.map(ast::TypeRef::parse));\n+        builder.try_add(\n+            ast::ModuleItem::parse(&raw_pattern),\n+            raw_template.map(ast::ModuleItem::parse),\n+        );\n+        builder.try_add(ast::Path::parse(&raw_pattern), raw_template.map(ast::Path::parse));\n+        builder.try_add(ast::Pat::parse(&raw_pattern), raw_template.map(ast::Pat::parse));\n         builder.build()\n     }\n }\n@@ -86,20 +87,30 @@ struct RuleBuilder {\n }\n \n impl RuleBuilder {\n-    fn try_add<T: AstNode>(&mut self, pattern: Result<T, ()>, template: Option<&SsrTemplate>) {\n-        match pattern {\n-            Ok(pattern) => self.rules.push(ParsedRule {\n+    fn try_add<T: AstNode>(&mut self, pattern: Result<T, ()>, template: Option<Result<T, ()>>) {\n+        match (pattern, template) {\n+            (Ok(pattern), Some(Ok(template))) => self.rules.push(ParsedRule {\n+                placeholders_by_stand_in: self.placeholders_by_stand_in.clone(),\n+                pattern: pattern.syntax().clone(),\n+                template: Some(template.syntax().clone()),\n+                // For now we give the rule an index of 0. It's given a proper index when the rule\n+                // is added to the SsrMatcher. Using an Option<usize>, instead would be slightly\n+                // more correct, but we delete this field from ParsedRule in a subsequent commit.\n+                index: 0,\n+            }),\n+            (Ok(pattern), None) => self.rules.push(ParsedRule {\n                 placeholders_by_stand_in: self.placeholders_by_stand_in.clone(),\n                 pattern: pattern.syntax().clone(),\n-                template: template.cloned(),\n+                template: None,\n+                index: 0,\n             }),\n             _ => {}\n         }\n     }\n \n     fn build(self) -> Result<Vec<ParsedRule>, SsrError> {\n         if self.rules.is_empty() {\n-            bail!(\"Pattern is not a valid Rust expression, type, item, path or pattern\");\n+            bail!(\"Not a valid Rust expression, type, item, path or pattern\");\n         }\n         Ok(self.rules)\n     }\n@@ -179,21 +190,6 @@ impl FromStr for SsrPattern {\n     }\n }\n \n-impl FromStr for SsrTemplate {\n-    type Err = SsrError;\n-\n-    fn from_str(pattern_str: &str) -> Result<SsrTemplate, SsrError> {\n-        let tokens = parse_pattern(pattern_str)?;\n-        // Validate that the template is a valid fragment of Rust code. We reuse the validation\n-        // logic for search patterns since the only thing that differs is the error message.\n-        if SsrPattern::from_str(pattern_str).is_err() {\n-            bail!(\"Replacement is not a valid Rust expression, type, item, path or pattern\");\n-        }\n-        // Our actual template needs to preserve whitespace, so we can't reuse `tokens`.\n-        Ok(SsrTemplate { tokens })\n-    }\n-}\n-\n /// Returns `pattern_str`, parsed as a search or replace pattern. If `remove_whitespace` is true,\n /// then any whitespace tokens will be removed, which we do for the search pattern, but not for the\n /// replace pattern."}, {"sha": "f1c5bdf14eafeb30f31df5af8acf43eb58709a86", "filename": "crates/ra_ssr/src/replacing.rs", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/113abbeefee671266d2d9bebdbd517eb8b802ef8/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113abbeefee671266d2d9bebdbd517eb8b802ef8/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Freplacing.rs?ref=113abbeefee671266d2d9bebdbd517eb8b802ef8", "patch": "@@ -1,70 +1,104 @@\n //! Code for applying replacement templates for matches that have previously been found.\n \n use crate::matching::Var;\n-use crate::parsing::PatternElement;\n-use crate::{Match, SsrMatches};\n+use crate::{parsing::ParsedRule, Match, SsrMatches};\n use ra_syntax::ast::AstToken;\n-use ra_syntax::TextSize;\n+use ra_syntax::{SyntaxElement, SyntaxNode, SyntaxToken, TextSize};\n use ra_text_edit::TextEdit;\n \n /// Returns a text edit that will replace each match in `matches` with its corresponding replacement\n /// template. Placeholders in the template will have been substituted with whatever they matched to\n /// in the original code.\n-pub(crate) fn matches_to_edit(matches: &SsrMatches, file_src: &str) -> TextEdit {\n-    matches_to_edit_at_offset(matches, file_src, 0.into())\n+pub(crate) fn matches_to_edit(\n+    matches: &SsrMatches,\n+    file_src: &str,\n+    rules: &[ParsedRule],\n+) -> TextEdit {\n+    matches_to_edit_at_offset(matches, file_src, 0.into(), rules)\n }\n \n fn matches_to_edit_at_offset(\n     matches: &SsrMatches,\n     file_src: &str,\n     relative_start: TextSize,\n+    rules: &[ParsedRule],\n ) -> TextEdit {\n     let mut edit_builder = ra_text_edit::TextEditBuilder::default();\n     for m in &matches.matches {\n         edit_builder.replace(\n             m.range.range.checked_sub(relative_start).unwrap(),\n-            render_replace(m, file_src),\n+            render_replace(m, file_src, rules),\n         );\n     }\n     edit_builder.finish()\n }\n \n-fn render_replace(match_info: &Match, file_src: &str) -> String {\n+struct ReplacementRenderer<'a> {\n+    match_info: &'a Match,\n+    file_src: &'a str,\n+    rules: &'a [ParsedRule],\n+    rule: &'a ParsedRule,\n+}\n+\n+fn render_replace(match_info: &Match, file_src: &str, rules: &[ParsedRule]) -> String {\n     let mut out = String::new();\n-    let template = match_info\n+    let rule = &rules[match_info.rule_index];\n+    let template = rule\n         .template\n         .as_ref()\n         .expect(\"You called MatchFinder::edits after calling MatchFinder::add_search_pattern\");\n-    for r in &template.tokens {\n-        match r {\n-            PatternElement::Token(t) => out.push_str(t.text.as_str()),\n-            PatternElement::Placeholder(p) => {\n-                if let Some(placeholder_value) =\n-                    match_info.placeholder_values.get(&Var(p.ident.to_string()))\n-                {\n-                    let range = &placeholder_value.range.range;\n-                    let mut matched_text =\n-                        file_src[usize::from(range.start())..usize::from(range.end())].to_owned();\n-                    let edit = matches_to_edit_at_offset(\n-                        &placeholder_value.inner_matches,\n-                        file_src,\n-                        range.start(),\n-                    );\n-                    edit.apply(&mut matched_text);\n-                    out.push_str(&matched_text);\n-                } else {\n-                    // We validated that all placeholder references were valid before we\n-                    // started, so this shouldn't happen.\n-                    panic!(\n-                        \"Internal error: replacement referenced unknown placeholder {}\",\n-                        p.ident\n-                    );\n-                }\n-            }\n-        }\n-    }\n+    let renderer = ReplacementRenderer { match_info, file_src, rules, rule };\n+    renderer.render_node_children(&template, &mut out);\n     for comment in &match_info.ignored_comments {\n         out.push_str(&comment.syntax().to_string());\n     }\n     out\n }\n+\n+impl ReplacementRenderer<'_> {\n+    fn render_node_children(&self, node: &SyntaxNode, out: &mut String) {\n+        for node_or_token in node.children_with_tokens() {\n+            self.render_node_or_token(&node_or_token, out);\n+        }\n+    }\n+\n+    fn render_node_or_token(&self, node_or_token: &SyntaxElement, out: &mut String) {\n+        match node_or_token {\n+            SyntaxElement::Token(token) => {\n+                self.render_token(&token, out);\n+            }\n+            SyntaxElement::Node(child_node) => {\n+                self.render_node_children(&child_node, out);\n+            }\n+        }\n+    }\n+\n+    fn render_token(&self, token: &SyntaxToken, out: &mut String) {\n+        if let Some(placeholder) = self.rule.get_placeholder(&token) {\n+            if let Some(placeholder_value) =\n+                self.match_info.placeholder_values.get(&Var(placeholder.ident.to_string()))\n+            {\n+                let range = &placeholder_value.range.range;\n+                let mut matched_text =\n+                    self.file_src[usize::from(range.start())..usize::from(range.end())].to_owned();\n+                let edit = matches_to_edit_at_offset(\n+                    &placeholder_value.inner_matches,\n+                    self.file_src,\n+                    range.start(),\n+                    self.rules,\n+                );\n+                edit.apply(&mut matched_text);\n+                out.push_str(&matched_text);\n+            } else {\n+                // We validated that all placeholder references were valid before we\n+                // started, so this shouldn't happen.\n+                panic!(\n+                    \"Internal error: replacement referenced unknown placeholder {}\",\n+                    placeholder.ident\n+                );\n+            }\n+        } else {\n+            out.push_str(token.text().as_str());\n+        }\n+    }\n+}"}, {"sha": "1b03b7f4bb31a3efb687c4b01d112f6f1f83b0af", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/113abbeefee671266d2d9bebdbd517eb8b802ef8/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113abbeefee671266d2d9bebdbd517eb8b802ef8/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=113abbeefee671266d2d9bebdbd517eb8b802ef8", "patch": "@@ -37,15 +37,15 @@ fn parser_repeated_name() {\n fn parser_invalid_pattern() {\n     assert_eq!(\n         parse_error_text(\" ==>> ()\"),\n-        \"Parse error: Pattern is not a valid Rust expression, type, item, path or pattern\"\n+        \"Parse error: Not a valid Rust expression, type, item, path or pattern\"\n     );\n }\n \n #[test]\n fn parser_invalid_template() {\n     assert_eq!(\n         parse_error_text(\"() ==>> )\"),\n-        \"Parse error: Replacement is not a valid Rust expression, type, item, path or pattern\"\n+        \"Parse error: Not a valid Rust expression, type, item, path or pattern\"\n     );\n }\n "}]}