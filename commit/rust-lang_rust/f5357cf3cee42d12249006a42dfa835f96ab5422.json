{"sha": "f5357cf3cee42d12249006a42dfa835f96ab5422", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MzU3Y2YzY2VlNDJkMTIyNDkwMDZhNDJkZmE4MzVmOTZhYjU0MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-22T03:06:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-22T03:06:44Z"}, "message": "auto merge of #13016 : huonw/rust/new-opt-vec, r=cmr\n\nReplace syntax::opt_vec with syntax::owned_slice\r\n\r\nThe `owned_slice::OwnedSlice` is  `(*T, uint)` (i.e. a direct equivalent to DSTs `~[T]`).\r\n\r\nThis shaves two words off the old OptVec type; and also makes substituting in other implementations easy, by removing all the mutation methods. (And also everything that's very rarely/never used.)", "tree": {"sha": "ab8bd94140ba08a70796786a6e5c63529a545f34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab8bd94140ba08a70796786a6e5c63529a545f34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5357cf3cee42d12249006a42dfa835f96ab5422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5357cf3cee42d12249006a42dfa835f96ab5422", "html_url": "https://github.com/rust-lang/rust/commit/f5357cf3cee42d12249006a42dfa835f96ab5422", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5357cf3cee42d12249006a42dfa835f96ab5422/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbf8cdc43feea08111abc5a59dc49a7f479d3103", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbf8cdc43feea08111abc5a59dc49a7f479d3103", "html_url": "https://github.com/rust-lang/rust/commit/bbf8cdc43feea08111abc5a59dc49a7f479d3103"}, {"sha": "e33676b7936b12bb68f47857ab3f8ea9b757d0d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e33676b7936b12bb68f47857ab3f8ea9b757d0d5", "html_url": "https://github.com/rust-lang/rust/commit/e33676b7936b12bb68f47857ab3f8ea9b757d0d5"}], "stats": {"total": 820, "additions": 369, "deletions": 451}, "files": [{"sha": "9a0c06c0955174ef897fbc9a14d9057bf93ad46f", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -18,7 +18,7 @@ use syntax::codemap::DUMMY_SP;\n use syntax::codemap;\n use syntax::fold::Folder;\n use syntax::fold;\n-use syntax::opt_vec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::util::small_vector::SmallVector;\n@@ -156,12 +156,12 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"std\"),\n                     lifetimes: Vec::new(),\n-                    types: opt_vec::Empty,\n+                    types: OwnedSlice::empty(),\n                 },\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"prelude\"),\n                     lifetimes: Vec::new(),\n-                    types: opt_vec::Empty,\n+                    types: OwnedSlice::empty(),\n                 }),\n         };\n "}, {"sha": "be9e9ea0bf62372251a2d1ef9377379a39b97dc3", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -31,7 +31,7 @@ use syntax::ext::base::ExtCtxt;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::fold::Folder;\n use syntax::fold;\n-use syntax::opt_vec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::print::pprust;\n@@ -377,7 +377,7 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n         segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n             lifetimes: Vec::new(),\n-            types: opt_vec::Empty,\n+            types: OwnedSlice::empty(),\n         }).collect()\n     }\n }\n@@ -389,7 +389,7 @@ fn path_node_global(ids: Vec<ast::Ident> ) -> ast::Path {\n         segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n             lifetimes: Vec::new(),\n-            types: opt_vec::Empty,\n+            types: OwnedSlice::empty(),\n         }).collect()\n     }\n }"}, {"sha": "c8ab681869778f71e217dd3f0de0ca8056318886", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -24,7 +24,7 @@ use syntax::abi::AbiSet;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast::*;\n-use syntax::opt_vec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n \n // Compact string representation for ty::t values. API ty_str &\n@@ -192,13 +192,13 @@ fn parse_region_substs(st: &mut PState, conv: conv_did) -> ty::RegionSubsts {\n     match next(st) {\n         'e' => ty::ErasedRegions,\n         'n' => {\n-            let mut regions = opt_vec::Empty;\n+            let mut regions = vec!();\n             while peek(st) != '.' {\n                 let r = parse_region(st, |x,y| conv(x,y));\n                 regions.push(r);\n             }\n             assert_eq!(next(st), '.');\n-            ty::NonerasedRegions(regions)\n+            ty::NonerasedRegions(OwnedSlice::from_vec(regions))\n         }\n         _ => fail!(\"parse_bound_region: bad input\")\n     }"}, {"sha": "93a1ba309c28b7ef132c7083c96b42bfa368bfd7", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -26,8 +26,6 @@ use middle::typeck;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n-use syntax::opt_vec::OptVec;\n-use syntax::opt_vec;\n use util::ppaux::Repr;\n \n pub struct MoveData {\n@@ -316,15 +314,15 @@ impl MoveData {\n \n     fn existing_base_paths(&self,\n                            lp: @LoanPath)\n-                           -> OptVec<MovePathIndex> {\n-        let mut result = opt_vec::Empty;\n+                           -> Vec<MovePathIndex> {\n+        let mut result = vec!();\n         self.add_existing_base_paths(lp, &mut result);\n         result\n     }\n \n     fn add_existing_base_paths(&self,\n                                lp: @LoanPath,\n-                               result: &mut OptVec<MovePathIndex>) {\n+                               result: &mut Vec<MovePathIndex>) {\n         /*!\n          * Adds any existing move path indices for `lp` and any base\n          * paths of `lp` to `result`, but does not add new move paths"}, {"sha": "b84e923f77d98d0ae4dc78f3d716720f65a3885e", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -14,7 +14,6 @@ use middle::typeck;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::opt_vec;\n use util::nodemap::NodeMap;\n \n struct CFGBuilder<'a> {\n@@ -470,7 +469,7 @@ impl<'a> CFGBuilder<'a> {\n     fn add_contained_edge(&mut self,\n                           source: CFGIndex,\n                           target: CFGIndex) {\n-        let data = CFGEdgeData {exiting_scopes: opt_vec::Empty};\n+        let data = CFGEdgeData {exiting_scopes: vec!() };\n         self.graph.add_edge(source, target, data);\n     }\n \n@@ -479,9 +478,10 @@ impl<'a> CFGBuilder<'a> {\n                         from_index: CFGIndex,\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n-        let mut data = CFGEdgeData {exiting_scopes: opt_vec::Empty};\n+        let mut data = CFGEdgeData {exiting_scopes: vec!() };\n         let mut scope_id = from_expr.id;\n         while scope_id != to_loop.loop_id {\n+\n             data.exiting_scopes.push(scope_id);\n             scope_id = self.tcx.region_maps.encl_scope(scope_id);\n         }"}, {"sha": "9c2dcd74351e3100b08699939b57cfb360b1e91d", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -19,7 +19,6 @@ use middle::graph;\n use middle::ty;\n use middle::typeck;\n use syntax::ast;\n-use syntax::opt_vec::OptVec;\n use util::nodemap::NodeMap;\n \n mod construct;\n@@ -36,7 +35,7 @@ pub struct CFGNodeData {\n }\n \n pub struct CFGEdgeData {\n-    exiting_scopes: OptVec<ast::NodeId>\n+    exiting_scopes: Vec<ast::NodeId>\n }\n \n pub type CFGIndex = graph::NodeIndex;"}, {"sha": "9d8f35eb9806508e49cea0612d7dbc91653bf7de", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -19,7 +19,7 @@ use util::ppaux::UserString;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::opt_vec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::print::pprust::expr_to_str;\n use syntax::{visit,ast_util};\n use syntax::visit::Visitor;\n@@ -92,7 +92,7 @@ fn check_struct_safe_for_destructor(cx: &mut Context,\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n     if !struct_tpt.generics.has_type_params() {\n         let struct_ty = ty::mk_struct(cx.tcx, struct_did, ty::substs {\n-            regions: ty::NonerasedRegions(opt_vec::Empty),\n+            regions: ty::NonerasedRegions(OwnedSlice::empty()),\n             self_ty: None,\n             tps: Vec::new()\n         });"}, {"sha": "360d010ed6773f28419679bb233e952f2e079c52", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -28,7 +28,7 @@ use syntax::ast_util::{is_local, def_id_of_def, local_def};\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n-use syntax::opt_vec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -842,7 +842,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                                 let seg = ast::PathSegment {\n                                     identifier: pid.node.name,\n                                     lifetimes: Vec::new(),\n-                                    types: opt_vec::Empty,\n+                                    types: OwnedSlice::empty(),\n                                 };\n                                 let segs = vec!(seg);\n                                 let path = ast::Path {"}, {"sha": "47f5e05fb8a82980f7fb5b328b9dfd2c4a734433", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -27,7 +27,7 @@ use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::print::pprust::path_to_str;\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n-use syntax::opt_vec::OptVec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -3969,7 +3969,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_type_parameters(&mut self,\n-                                   type_parameters: &OptVec<TyParam>) {\n+                                   type_parameters: &OwnedSlice<TyParam>) {\n         for type_parameter in type_parameters.iter() {\n             for bound in type_parameter.bounds.iter() {\n                 self.resolve_type_parameter_bound(type_parameter.id, bound);"}, {"sha": "40a7bdff11f5e776d3699fd26d1f1ffcb97161d9", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -21,8 +21,7 @@ use driver::session::Session;\n use util::nodemap::NodeMap;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::opt_vec;\n-use syntax::opt_vec::OptVec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::print::pprust::{lifetime_to_str};\n@@ -413,22 +412,22 @@ pub fn early_bound_lifetimes<'a>(generics: &'a ast::Generics) -> Vec<ast::Lifeti\n         .collect()\n }\n \n-pub fn free_lifetimes(ty_params: &OptVec<ast::TyParam>) -> OptVec<ast::Name> {\n+pub fn free_lifetimes(ty_params: &OwnedSlice<ast::TyParam>) -> Vec<ast::Name> {\n     /*!\n      * Gathers up and returns the names of any lifetimes that appear\n      * free in `ty_params`. Of course, right now, all lifetimes appear\n      * free, since we don't currently have any binders in type parameter\n      * declarations; just being forwards compatible with future extensions.\n      */\n \n-    let mut collector = FreeLifetimeCollector { names: opt_vec::Empty };\n+    let mut collector = FreeLifetimeCollector { names: vec!() };\n     for ty_param in ty_params.iter() {\n         visit::walk_ty_param_bounds(&mut collector, &ty_param.bounds, ());\n     }\n     return collector.names;\n \n     struct FreeLifetimeCollector {\n-        names: OptVec<ast::Name>,\n+        names: Vec<ast::Name>,\n     }\n \n     impl Visitor<()> for FreeLifetimeCollector {"}, {"sha": "0dd5c2ee10ee8c64c3f9f0fbb0d630ecb67b6b14", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -17,7 +17,7 @@ use util::ppaux::Repr;\n \n use std::rc::Rc;\n use syntax::codemap::Span;\n-use syntax::opt_vec::OptVec;\n+use syntax::owned_slice::OwnedSlice;\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n@@ -145,10 +145,10 @@ impl<T:Subst> Subst for Rc<T> {\n     }\n }\n \n-impl<T:Subst> Subst for OptVec<T> {\n+impl<T:Subst> Subst for OwnedSlice<T> {\n     fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n-                     span: Option<Span>) -> OptVec<T> {\n+                     span: Option<Span>) -> OwnedSlice<T> {\n         self.map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }"}, {"sha": "75f236d5028d48418bea91ac7a6445ec4aa9dc19", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -24,8 +24,6 @@ use middle::trans::glue;\n use middle::trans::type_::Type;\n use middle::ty;\n use syntax::ast;\n-use syntax::opt_vec;\n-use syntax::opt_vec::OptVec;\n use util::ppaux::Repr;\n \n pub struct CleanupScope<'a> {\n@@ -37,9 +35,9 @@ pub struct CleanupScope<'a> {\n     kind: CleanupScopeKind<'a>,\n \n     // Cleanups to run upon scope exit.\n-    cleanups: OptVec<~Cleanup>,\n+    cleanups: Vec<~Cleanup>,\n \n-    cached_early_exits: OptVec<CachedEarlyExit>,\n+    cached_early_exits: Vec<CachedEarlyExit>,\n     cached_landing_pad: Option<BasicBlockRef>,\n }\n \n@@ -379,7 +377,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         assert!(orig_scopes_len > 0);\n \n         // Remove any scopes that do not have cleanups on failure:\n-        let mut popped_scopes = opt_vec::Empty;\n+        let mut popped_scopes = vec!();\n         while !self.top_scope(|s| s.needs_invoke()) {\n             debug!(\"top scope does not need invoke\");\n             popped_scopes.push(self.pop_scope());\n@@ -510,7 +508,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n \n         let orig_scopes_len = self.scopes_len();\n         let mut prev_llbb;\n-        let mut popped_scopes = opt_vec::Empty;\n+        let mut popped_scopes = vec!();\n \n         // First we pop off all the cleanup stacks that are\n         // traversed until the exit is reached, pushing them\n@@ -708,14 +706,14 @@ impl<'a> CleanupScope<'a> {\n     fn new(kind: CleanupScopeKind<'a>) -> CleanupScope<'a> {\n         CleanupScope {\n             kind: kind,\n-            cleanups: opt_vec::Empty,\n-            cached_early_exits: opt_vec::Empty,\n+            cleanups: vec!(),\n+            cached_early_exits: vec!(),\n             cached_landing_pad: None,\n         }\n     }\n \n     fn clear_cached_exits(&mut self) {\n-        self.cached_early_exits = opt_vec::Empty;\n+        self.cached_early_exits = vec!();\n         self.cached_landing_pad = None;\n     }\n "}, {"sha": "dce7e85742dec6fd86c9515ae679bceb5fee90d6", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -150,7 +150,8 @@ use std::ptr;\n use std::sync::atomics;\n use std::slice;\n use syntax::codemap::{Span, Pos};\n-use syntax::{abi, ast, codemap, ast_util, ast_map, opt_vec};\n+use syntax::{abi, ast, codemap, ast_util, ast_map};\n+use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::parse::token::special_idents;\n \n@@ -539,7 +540,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         return FunctionWithoutDebugInfo;\n     }\n \n-    let empty_generics = ast::Generics { lifetimes: Vec::new(), ty_params: opt_vec::Empty };\n+    let empty_generics = ast::Generics { lifetimes: Vec::new(), ty_params: OwnedSlice::empty() };\n \n     let fnitem = cx.tcx.map.get(fn_ast_id);\n "}, {"sha": "dad254e2dc7a6712cb47e6282366387997c7042a", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -20,7 +20,7 @@ use util::ppaux::Repr;\n use middle::trans::type_::Type;\n \n use syntax::ast;\n-use syntax::opt_vec;\n+use syntax::owned_slice::OwnedSlice;\n \n pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: ty::t) -> bool {\n     !type_is_immediate(ccx, arg_ty)\n@@ -324,7 +324,7 @@ pub fn llvm_type_name(cx: &CrateContext,\n         an_enum => { \"enum\" }\n     };\n     let tstr = ppaux::parameterized(cx.tcx(), ty::item_path_str(cx.tcx(), did),\n-                                    &ty::NonerasedRegions(opt_vec::Empty),\n+                                    &ty::NonerasedRegions(OwnedSlice::empty()),\n                                     tps, did, false);\n     if did.krate == 0 {\n         format!(\"{}.{}\", name, tstr)"}, {"sha": "61cadfea253253656ce8d4c22b977aafd4a5b381", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -51,8 +51,7 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::parse::token::InternedString;\n use syntax::{ast, ast_map};\n-use syntax::opt_vec::OptVec;\n-use syntax::opt_vec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::abi::AbiSet;\n use syntax;\n use collections::enum_set::{EnumSet, CLike};\n@@ -192,8 +191,8 @@ pub enum ast_ty_to_ty_cache_entry {\n #[deriving(Clone, Eq, Decodable, Encodable)]\n pub struct ItemVariances {\n     self_param: Option<Variance>,\n-    type_params: OptVec<Variance>,\n-    region_params: OptVec<Variance>\n+    type_params: OwnedSlice<Variance>,\n+    region_params: OwnedSlice<Variance>\n }\n \n #[deriving(Clone, Eq, Decodable, Encodable, Show)]\n@@ -646,7 +645,7 @@ pub enum BoundRegion {\n #[deriving(Clone, Eq, Hash)]\n pub enum RegionSubsts {\n     ErasedRegions,\n-    NonerasedRegions(OptVec<ty::Region>)\n+    NonerasedRegions(OwnedSlice<ty::Region>)\n }\n \n /**\n@@ -4658,7 +4657,7 @@ pub fn visitor_object_ty(tcx: &ctxt,\n         Err(s) => { return Err(s); }\n     };\n     let substs = substs {\n-        regions: ty::NonerasedRegions(opt_vec::Empty),\n+        regions: ty::NonerasedRegions(OwnedSlice::empty()),\n         self_ty: None,\n         tps: Vec::new()\n     };\n@@ -5072,11 +5071,10 @@ pub fn construct_parameter_environment(\n \n     // map bound 'a => free 'a\n     let region_params = {\n-        fn push_region_params(accum: OptVec<ty::Region>,\n+        fn push_region_params(mut accum: Vec<ty::Region>,\n                               free_id: ast::NodeId,\n                               region_params: &[RegionParameterDef])\n-                              -> OptVec<ty::Region> {\n-            let mut accum = accum;\n+                              -> Vec<ty::Region> {\n             for r in region_params.iter() {\n                 accum.push(\n                     ty::ReFree(ty::FreeRegion {\n@@ -5086,14 +5084,14 @@ pub fn construct_parameter_environment(\n             accum\n         }\n \n-        let t = push_region_params(opt_vec::Empty, free_id, item_region_params);\n+        let t = push_region_params(vec!(), free_id, item_region_params);\n         push_region_params(t, free_id, method_region_params)\n     };\n \n     let free_substs = substs {\n         self_ty: self_ty,\n         tps: type_params,\n-        regions: ty::NonerasedRegions(region_params)\n+        regions: ty::NonerasedRegions(OwnedSlice::from_vec(region_params))\n     };\n \n     //\n@@ -5131,7 +5129,7 @@ impl substs {\n         substs {\n             self_ty: None,\n             tps: Vec::new(),\n-            regions: NonerasedRegions(opt_vec::Empty)\n+            regions: NonerasedRegions(OwnedSlice::empty())\n         }\n     }\n }"}, {"sha": "d28ad74e49b03334eb28a61ca3739176c643ee0a", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -63,8 +63,7 @@ use util::ppaux::Repr;\n use syntax::abi::AbiSet;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n-use syntax::opt_vec::OptVec;\n-use syntax::opt_vec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::print::pprust::{lifetime_to_str, path_to_str};\n \n pub trait AstConv {\n@@ -229,7 +228,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n                             .collect();\n \n     let mut substs = substs {\n-        regions: ty::NonerasedRegions(opt_vec::from(regions)),\n+        regions: ty::NonerasedRegions(OwnedSlice::from_vec(regions)),\n         self_ty: self_ty,\n         tps: tps\n     };\n@@ -816,7 +815,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     }\n }\n \n-fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBound>>,\n+fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OwnedSlice<ast::TyParamBound>>,\n                        store: ty::TraitStore)\n                        -> ty::BuiltinBounds {\n     //! Converts a list of bounds from the AST into a `BuiltinBounds`"}, {"sha": "fc577f12f6a3027d9df996fcf639c12a2e7330bf", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -104,6 +104,7 @@ use syntax::ast::{MutMutable, MutImmutable};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax::owned_slice::OwnedSlice;\n \n #[deriving(Eq)]\n pub enum CheckTraitsFlag {\n@@ -1102,8 +1103,8 @@ impl<'a> LookupContext<'a> {\n \n         // Determine values for the early-bound lifetime parameters.\n         // FIXME -- permit users to manually specify lifetimes\n-        let mut all_regions = match candidate.rcvr_substs.regions {\n-            NonerasedRegions(ref v) => v.clone(),\n+        let mut all_regions: Vec<Region> = match candidate.rcvr_substs.regions {\n+            NonerasedRegions(ref v) => v.iter().map(|r| r.clone()).collect(),\n             ErasedRegions => tcx.sess.span_bug(self.span, \"ErasedRegions\")\n         };\n         let m_regions =\n@@ -1119,7 +1120,7 @@ impl<'a> LookupContext<'a> {\n         let all_substs = substs {\n             tps: vec::append(candidate.rcvr_substs.tps.clone(),\n                                 m_substs.as_slice()),\n-            regions: NonerasedRegions(all_regions),\n+            regions: NonerasedRegions(OwnedSlice::from_vec(all_regions)),\n             self_ty: candidate.rcvr_substs.self_ty,\n         };\n "}, {"sha": "ff98d5196ad45a272a891cc23b8801e231883980", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -129,8 +129,7 @@ use syntax::ast_util;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::codemap;\n-use syntax::opt_vec::OptVec;\n-use syntax::opt_vec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::visit;\n@@ -903,7 +902,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         impl_m.generics.type_param_defs().iter().enumerate().\n         map(|(i,t)| ty::mk_param(tcx, i + impl_tps, t.def_id)).\n         collect();\n-    let dummy_impl_regions: OptVec<ty::Region> =\n+    let dummy_impl_regions: OwnedSlice<ty::Region> =\n         impl_generics.region_param_defs().iter().\n         map(|l| ty::ReFree(ty::FreeRegion {\n                 scope_id: impl_m_body_id,\n@@ -2631,7 +2630,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                       }\n                                   };\n                               let regions =\n-                                  ty::NonerasedRegions(opt_vec::Empty);\n+                                  ty::NonerasedRegions(OwnedSlice::empty());\n                               let sty = ty::mk_struct(tcx,\n                                                       gc_struct_id,\n                                                       substs {\n@@ -3706,7 +3705,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n     let num_expected_regions = tpt.generics.region_param_defs().len();\n     let num_supplied_regions = pth.segments.last().unwrap().lifetimes.len();\n     let regions = if num_expected_regions == num_supplied_regions {\n-        opt_vec::from(pth.segments.last().unwrap().lifetimes.map(\n+        OwnedSlice::from_vec(pth.segments.last().unwrap().lifetimes.map(\n             |l| ast_region_to_region(fcx.tcx(), l)))\n     } else {\n         if num_supplied_regions != 0 {\n@@ -3971,7 +3970,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool\n \n pub fn check_bounds_are_used(ccx: &CrateCtxt,\n                              span: Span,\n-                             tps: &OptVec<ast::TyParam>,\n+                             tps: &OwnedSlice<ast::TyParam>,\n                              ty: ty::t) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={})\",\n            tps.len(), ppaux::ty_to_str(ccx.tcx, ty));\n@@ -4087,7 +4086,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                     Ok(did) => (1u, Vec::new(), ty::mk_struct(ccx.tcx, did, substs {\n                                                  self_ty: None,\n                                                  tps: Vec::new(),\n-                                                 regions: ty::NonerasedRegions(opt_vec::Empty)\n+                                                 regions: ty::NonerasedRegions(OwnedSlice::empty())\n                                                  }) ),\n                     Err(msg) => { tcx.sess.span_fatal(it.span, msg); }\n                 }"}, {"sha": "4eeae31d0a49cbb558eefb8d21829d0d6561f1a4", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -60,7 +60,7 @@ use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::print::pprust::{path_to_str};\n use syntax::visit;\n-use syntax::opt_vec::OptVec;\n+use syntax::owned_slice::OwnedSlice;\n \n struct CollectItemTypesVisitor<'a> {\n     ccx: &'a CrateCtxt<'a>\n@@ -987,14 +987,14 @@ pub fn ty_generics_for_fn_or_method(ccx: &CrateCtxt,\n \n pub fn ty_generics(ccx: &CrateCtxt,\n                    lifetimes: &Vec<ast::Lifetime>,\n-                   ty_params: &OptVec<ast::TyParam>,\n+                   ty_params: &OwnedSlice<ast::TyParam>,\n                    base_index: uint) -> ty::Generics {\n     return ty::Generics {\n         region_param_defs: Rc::new(lifetimes.iter().map(|l| {\n                 ty::RegionParameterDef { name: l.name,\n                                          def_id: local_def(l.id) }\n             }).collect()),\n-        type_param_defs: Rc::new(ty_params.mapi_to_vec(|offset, param| {\n+        type_param_defs: Rc::new(ty_params.iter().enumerate().map(|(offset, param)| {\n             let existing_def_opt = {\n                 let ty_param_defs = ccx.tcx.ty_param_defs.borrow();\n                 ty_param_defs.get().find(&param.id).map(|&def| def)\n@@ -1015,13 +1015,13 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                 ty_param_defs.get().insert(param.id, def);\n                 def\n             })\n-        }).move_iter().collect()),\n+        }).collect()),\n     };\n \n     fn compute_bounds(\n         ccx: &CrateCtxt,\n         param_ty: ty::param_ty,\n-        ast_bounds: &OptVec<ast::TyParamBound>) -> ty::ParamBounds\n+        ast_bounds: &OwnedSlice<ast::TyParamBound>) -> ty::ParamBounds\n     {\n         /*!\n          * Translate the AST's notion of ty param bounds (which are an\n@@ -1113,7 +1113,7 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n         ty_generics.type_param_defs().iter().enumerate().map(\n             |(i, t)| ty::mk_param(ccx.tcx, i, t.def_id)).collect();\n \n-    let regions: OptVec<ty::Region> =\n+    let regions: OwnedSlice<ty::Region> =\n         ty_generics.region_param_defs().iter().enumerate().map(\n             |(i, l)| ty::ReEarlyBound(l.def_id.node, i, l.name)).collect();\n "}, {"sha": "1516a7bec34071690e68ac11a164b17659990f8d", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -66,7 +66,7 @@ use std::result;\n \n use syntax::ast::{Onceness, Purity};\n use syntax::ast;\n-use syntax::opt_vec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::abi::AbiSet;\n \n pub trait Combine {\n@@ -160,7 +160,7 @@ pub trait Combine {\n \n                     assert_eq!(num_region_params, a_rs.len());\n                     assert_eq!(num_region_params, b_rs.len());\n-                    let mut rs = opt_vec::Empty;\n+                    let mut rs = vec!();\n                     for i in range(0, num_region_params) {\n                         let a_r = *a_rs.get(i);\n                         let b_r = *b_rs.get(i);\n@@ -176,7 +176,7 @@ pub trait Combine {\n                         };\n                         rs.push(if_ok!(r));\n                     }\n-                    Ok(ty::NonerasedRegions(rs))\n+                    Ok(ty::NonerasedRegions(OwnedSlice::from_vec(rs)))\n                 }\n             }\n         }"}, {"sha": "4cd9d46ff7ac8825195d60ed4dcc72733c0a1e8e", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -80,8 +80,6 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n use syntax::ast_util::name_to_dummy_lifetime;\n-use syntax::opt_vec;\n-use syntax::opt_vec::OptVec;\n use syntax::parse::token;\n use syntax::print::pprust;\n use util::ppaux::UserString;\n@@ -90,10 +88,10 @@ use util::ppaux::note_and_explain_region;\n \n pub trait ErrorReporting {\n     fn report_region_errors(&self,\n-                            errors: &OptVec<RegionResolutionError>);\n+                            errors: &Vec<RegionResolutionError>);\n \n-    fn process_errors(&self, errors: &OptVec<RegionResolutionError>)\n-                      -> OptVec<RegionResolutionError>;\n+    fn process_errors(&self, errors: &Vec<RegionResolutionError>)\n+                      -> Vec<RegionResolutionError>;\n \n     fn report_type_error(&self, trace: TypeTrace, terr: &ty::type_err);\n \n@@ -151,7 +149,7 @@ trait ErrorReportingHelpers {\n \n impl<'a> ErrorReporting for InferCtxt<'a> {\n     fn report_region_errors(&self,\n-                            errors: &OptVec<RegionResolutionError>) {\n+                            errors: &Vec<RegionResolutionError>) {\n         let p_errors = self.process_errors(errors);\n         let errors = if p_errors.is_empty() { errors } else { &p_errors };\n         for error in errors.iter() {\n@@ -195,12 +193,12 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n     // complete view of what lifetimes should be the same.\n     // If the return value is an empty vector, it means that processing\n     // failed (so the return value of this method should not be used)\n-    fn process_errors(&self, errors: &OptVec<RegionResolutionError>)\n-                      -> OptVec<RegionResolutionError> {\n+    fn process_errors(&self, errors: &Vec<RegionResolutionError>)\n+                      -> Vec<RegionResolutionError> {\n         let mut var_origins = Vec::new();\n         let mut trace_origins = Vec::new();\n         let mut same_regions = Vec::new();\n-        let mut processed_errors = opt_vec::Empty;\n+        let mut processed_errors = Vec::new();\n         for error in errors.iter() {\n             match *error {\n                 ConcreteFailure(origin, sub, sup) => {\n@@ -239,7 +237,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                 // declaration, we want to make sure that they are, in fact,\n                 // from the same scope\n                 if sr.scope_id != common_scope_id {\n-                    return opt_vec::Empty;\n+                    return vec!();\n                 }\n             }\n             let pe = ProcessedErrors(var_origins, trace_origins, same_regions);"}, {"sha": "b1a1a6e3bd15ad4e1337ef5b2d32f3778fa35e82", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -43,7 +43,7 @@ use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n-use syntax::opt_vec::OptVec;\n+use syntax::owned_slice::OwnedSlice;\n use util::common::indent;\n use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr};\n \n@@ -668,7 +668,7 @@ impl<'a> InferCtxt<'a> {\n     pub fn region_vars_for_defs(&self,\n                                 span: Span,\n                                 defs: &[ty::RegionParameterDef])\n-                                -> OptVec<ty::Region> {\n+                                -> OwnedSlice<ty::Region> {\n         defs.iter()\n             .map(|d| self.next_region_var(EarlyBoundRegion(span, d.name)))\n             .collect()"}, {"sha": "7c13c15ffec7d550054700dd1f3640c394beb187", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -29,8 +29,6 @@ use std::uint;\n use std::slice;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n-use syntax::opt_vec;\n-use syntax::opt_vec::OptVec;\n \n mod doc;\n \n@@ -561,9 +559,9 @@ impl<'a> RegionVarBindings<'a> {\n     constraints, assuming such values can be found; if they cannot,\n     errors are reported.\n     */\n-    pub fn resolve_regions(&self) -> OptVec<RegionResolutionError> {\n+    pub fn resolve_regions(&self) -> Vec<RegionResolutionError> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n-        let mut errors = opt_vec::Empty;\n+        let mut errors = vec!();\n         let v = self.infer_variable_values(&mut errors);\n         let mut values = self.values.borrow_mut();\n         *values.get() = Some(v);\n@@ -815,7 +813,7 @@ type RegionGraph = graph::Graph<(), Constraint>;\n \n impl<'a> RegionVarBindings<'a> {\n     fn infer_variable_values(&self,\n-                             errors: &mut OptVec<RegionResolutionError>)\n+                             errors: &mut Vec<RegionResolutionError>)\n                              -> Vec<VarValue> {\n         let mut var_data = self.construct_var_data();\n         self.expansion(var_data.as_mut_slice());\n@@ -1004,7 +1002,7 @@ impl<'a> RegionVarBindings<'a> {\n \n     fn collect_concrete_region_errors(\n         &self,\n-        errors: &mut OptVec<RegionResolutionError>)\n+        errors: &mut Vec<RegionResolutionError>)\n     {\n         let constraints = self.constraints.borrow();\n         for (constraint, _) in constraints.get().iter() {\n@@ -1033,7 +1031,7 @@ impl<'a> RegionVarBindings<'a> {\n     fn extract_values_and_collect_conflicts(\n         &self,\n         var_data: &[VarData],\n-        errors: &mut OptVec<RegionResolutionError>)\n+        errors: &mut Vec<RegionResolutionError>)\n         -> Vec<VarValue> {\n         debug!(\"extract_values_and_collect_conflicts()\");\n \n@@ -1157,7 +1155,7 @@ impl<'a> RegionVarBindings<'a> {\n         var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n-        errors: &mut OptVec<RegionResolutionError>)\n+        errors: &mut Vec<RegionResolutionError>)\n     {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n@@ -1206,7 +1204,7 @@ impl<'a> RegionVarBindings<'a> {\n         var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n-        errors: &mut OptVec<RegionResolutionError>)\n+        errors: &mut Vec<RegionResolutionError>)\n     {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection."}, {"sha": "cef047fae5df5e258eac95c49f7670485fe9f9dc", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -14,7 +14,7 @@ use middle::ty;\n use std::cell::Cell;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::opt_vec::OptVec;\n+use syntax::owned_slice::OwnedSlice;\n \n /// Defines strategies for handling regions that are omitted.  For\n /// example, if one writes the type `&Foo`, then the lifetime of\n@@ -74,7 +74,7 @@ impl RegionScope for BindingRscope {\n }\n \n pub fn bound_type_regions(defs: &[ty::RegionParameterDef])\n-                          -> OptVec<ty::Region> {\n+                          -> OwnedSlice<ty::Region> {\n     assert!(defs.iter().all(|def| def.def_id.krate == ast::LOCAL_CRATE));\n     defs.iter().enumerate().map(\n         |(i, def)| ty::ReEarlyBound(def.def_id.node, i, def.name)).collect()"}, {"sha": "8748c332170ad754f65f880ad17b9f0e82c68fab", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -199,7 +199,7 @@ use middle::ty;\n use std::fmt;\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::opt_vec;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n use syntax::visit::Visitor;\n use util::ppaux::Repr;\n@@ -286,8 +286,8 @@ fn determine_parameters_to_be_inferred<'a>(tcx: &'a ty::ctxt,\n         // cache and share the variance struct used for items with\n         // no type/region parameters\n         empty_variances: @ty::ItemVariances { self_param: None,\n-                                              type_params: opt_vec::Empty,\n-                                              region_params: opt_vec::Empty }\n+                                              type_params: OwnedSlice::empty(),\n+                                              region_params: OwnedSlice::empty() }\n     };\n \n     visit::walk_crate(&mut terms_cx, krate, ());\n@@ -904,32 +904,33 @@ impl<'a> SolveContext<'a> {\n         let num_inferred = self.terms_cx.num_inferred();\n         while index < num_inferred {\n             let item_id = inferred_infos.get(index).item_id;\n-            let mut item_variances = ty::ItemVariances {\n-                self_param: None,\n-                type_params: opt_vec::Empty,\n-                region_params: opt_vec::Empty\n-            };\n+            let mut self_param = None;\n+            let mut type_params = vec!();\n+            let mut region_params = vec!();\n+\n             while index < num_inferred &&\n                   inferred_infos.get(index).item_id == item_id {\n                 let info = inferred_infos.get(index);\n                 match info.kind {\n                     SelfParam => {\n-                        assert!(item_variances.self_param.is_none());\n-                        item_variances.self_param =\n-                            Some(*solutions.get(index));\n+                        assert!(self_param.is_none());\n+                        self_param = Some(*solutions.get(index));\n                     }\n                     TypeParam => {\n-                        item_variances.type_params\n-                                      .push(*solutions.get(index));\n+                        type_params.push(*solutions.get(index));\n                     }\n                     RegionParam => {\n-                        item_variances.region_params\n-                                      .push(*solutions.get(index));\n+                        region_params.push(*solutions.get(index));\n                     }\n                 }\n                 index += 1;\n             }\n \n+            let item_variances = ty::ItemVariances {\n+                self_param: self_param,\n+                type_params: OwnedSlice::from_vec(type_params),\n+                region_params: OwnedSlice::from_vec(region_params)\n+            };\n             debug!(\"item_id={} item_variances={}\",\n                     item_id,\n                     item_variances.repr(tcx));"}, {"sha": "b2568c60dc05a3750a11b6f541e0d6b3df3bf32d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -29,8 +29,7 @@ use syntax::codemap::{Span, Pos};\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n-use syntax::opt_vec;\n-use syntax::opt_vec::OptVec;\n+use syntax::owned_slice::OwnedSlice;\n \n /// Produces a string suitable for debugging output.\n pub trait Repr {\n@@ -606,12 +605,9 @@ impl<'a, T:Repr> Repr for &'a [T] {\n     }\n }\n \n-impl<T:Repr> Repr for OptVec<T> {\n+impl<T:Repr> Repr for OwnedSlice<T> {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n-        match *self {\n-            opt_vec::Empty => ~\"[]\",\n-            opt_vec::Vec(ref v) => repr_vec(tcx, v.as_slice())\n-        }\n+        repr_vec(tcx, self.as_slice())\n     }\n }\n "}, {"sha": "e8854215c009cd580910d3a9c7dfa9d00bde33f5", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -56,12 +56,9 @@ impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::opt_vec::OptVec<T> {\n+impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n     fn clean(&self) -> Vec<U> {\n-        match self {\n-            &syntax::opt_vec::Empty => Vec::new(),\n-            &syntax::opt_vec::Vec(ref v) => v.clean()\n-        }\n+        self.iter().map(|x| x.clean()).collect()\n     }\n }\n "}, {"sha": "34e4256e5381e84f3c710812e6d3bc82f6e5cad1", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -121,6 +121,19 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Create a `Vec<T>` directly from the raw constituents.\n+    ///\n+    /// This is highly unsafe:\n+    ///\n+    /// - if `ptr` is null, then `length` and `capacity` should be 0\n+    /// - `ptr` must point to an allocation of size `capacity`\n+    /// - there must be `length` valid instances of type `T` at the\n+    ///   beginning of that allocation\n+    /// - `ptr` must be allocated by the default `Vec` allocator\n+    pub unsafe fn from_raw_parts(length: uint, capacity: uint, ptr: *mut T) -> Vec<T> {\n+        Vec { len: length, cap: capacity, ptr: ptr }\n+    }\n+\n     /// Consumes the `Vec`, partitioning it based on a predcate.\n     ///\n     /// Partitions the `Vec` into two `Vec`s `(A,B)`, where all elements of `A`"}, {"sha": "41038705d4d7e36cbfce0b210887c9dbf58d0ebe", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -13,7 +13,7 @@\n use codemap::{Span, Spanned, DUMMY_SP};\n use abi::AbiSet;\n use ast_util;\n-use opt_vec::OptVec;\n+use owned_slice::OwnedSlice;\n use parse::token::{InternedString, special_idents, str_to_ident};\n use parse::token;\n \n@@ -143,7 +143,7 @@ pub struct PathSegment {\n     /// The lifetime parameters for this path segment.\n     lifetimes: Vec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n-    types: OptVec<P<Ty>>,\n+    types: OwnedSlice<P<Ty>>,\n }\n \n pub type CrateNum = u32;\n@@ -180,14 +180,14 @@ pub enum TyParamBound {\n pub struct TyParam {\n     ident: Ident,\n     id: NodeId,\n-    bounds: OptVec<TyParamBound>,\n+    bounds: OwnedSlice<TyParamBound>,\n     default: Option<P<Ty>>\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Generics {\n     lifetimes: Vec<Lifetime>,\n-    ty_params: OptVec<TyParam>,\n+    ty_params: OwnedSlice<TyParam>,\n }\n \n impl Generics {\n@@ -799,7 +799,7 @@ pub struct ClosureTy {\n     // implement issue #7264. None means \"fn()\", which means infer a default\n     // bound based on pointer sigil during typeck. Some(Empty) means \"fn:()\",\n     // which means use no bounds (e.g., not even Owned on a ~fn()).\n-    bounds: Option<OptVec<TyParamBound>>,\n+    bounds: Option<OwnedSlice<TyParamBound>>,\n }\n \n #[deriving(Eq, Encodable, Decodable, Hash)]\n@@ -823,7 +823,7 @@ pub enum Ty_ {\n     TyClosure(@ClosureTy),\n     TyBareFn(@BareFnTy),\n     TyTup(Vec<P<Ty>> ),\n-    TyPath(Path, Option<OptVec<TyParamBound>>, NodeId), // for #7264; see above\n+    TyPath(Path, Option<OwnedSlice<TyParamBound>>, NodeId), // for #7264; see above\n     TyTypeof(@Expr),\n     // TyInfer means the type should be inferred instead of it having been\n     // specified. This can appear anywhere in a type."}, {"sha": "9d841255aa935221724d108cb4a75f18745bc034", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -13,7 +13,7 @@ use ast;\n use ast_util;\n use codemap;\n use codemap::Span;\n-use opt_vec;\n+use owned_slice::OwnedSlice;\n use parse::token;\n use print::pprust;\n use visit::Visitor;\n@@ -196,7 +196,7 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n             ast::PathSegment {\n                 identifier: identifier,\n                 lifetimes: Vec::new(),\n-                types: opt_vec::Empty,\n+                types: OwnedSlice::empty(),\n             }\n         ),\n     }\n@@ -318,7 +318,7 @@ pub static as_prec: uint = 12u;\n \n pub fn empty_generics() -> Generics {\n     Generics {lifetimes: Vec::new(),\n-              ty_params: opt_vec::Empty}\n+              ty_params: OwnedSlice::empty()}\n }\n \n // ______________________________________________________________________\n@@ -709,12 +709,12 @@ pub fn get_inner_tys(ty: P<Ty>) -> Vec<P<Ty>> {\n mod test {\n     use ast::*;\n     use super::*;\n-    use opt_vec;\n+    use owned_slice::OwnedSlice;\n \n     fn ident_to_segment(id : &Ident) -> PathSegment {\n         PathSegment {identifier:id.clone(),\n                      lifetimes: Vec::new(),\n-                     types: opt_vec::Empty}\n+                     types: OwnedSlice::empty()}\n     }\n \n     #[test] fn idents_name_eq_test() {"}, {"sha": "1106dc61db7b8751f41558329a023207fc4f297c", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -16,8 +16,7 @@ use codemap::{Span, respan, DUMMY_SP};\n use ext::base::ExtCtxt;\n use ext::quote::rt::*;\n use fold::Folder;\n-use opt_vec;\n-use opt_vec::OptVec;\n+use owned_slice::OwnedSlice;\n use parse::token::special_idents;\n use parse::token;\n \n@@ -48,7 +47,7 @@ pub trait AstBuilder {\n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy;\n \n     fn ty(&self, span: Span, ty: ast::Ty_) -> P<ast::Ty>;\n-    fn ty_path(&self, ast::Path, Option<OptVec<ast::TyParamBound>>) -> P<ast::Ty>;\n+    fn ty_path(&self, ast::Path, Option<OwnedSlice<ast::TyParamBound>>) -> P<ast::Ty>;\n     fn ty_ident(&self, span: Span, idents: ast::Ident) -> P<ast::Ty>;\n \n     fn ty_rptr(&self, span: Span,\n@@ -61,14 +60,14 @@ pub trait AstBuilder {\n     fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n     fn ty_nil(&self) -> P<ast::Ty>;\n \n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n+    fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n+    fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n     fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField;\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n     fn typaram(&self,\n                id: ast::Ident,\n-               bounds: OptVec<ast::TyParamBound>,\n+               bounds: OwnedSlice<ast::TyParamBound>,\n                default: Option<P<ast::Ty>>) -> ast::TyParam;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n@@ -274,13 +273,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             ast::PathSegment {\n                 identifier: ident,\n                 lifetimes: Vec::new(),\n-                types: opt_vec::Empty,\n+                types: OwnedSlice::empty(),\n             }\n         }).collect();\n         segments.push(ast::PathSegment {\n             identifier: last_identifier,\n             lifetimes: lifetimes,\n-            types: opt_vec::from(types),\n+            types: OwnedSlice::from_vec(types),\n         });\n         ast::Path {\n             span: sp,\n@@ -304,7 +303,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn ty_path(&self, path: ast::Path, bounds: Option<OptVec<ast::TyParamBound>>)\n+    fn ty_path(&self, path: ast::Path, bounds: Option<OwnedSlice<ast::TyParamBound>>)\n               -> P<ast::Ty> {\n         self.ty(path.span,\n                 ast::TyPath(path, bounds, ast::DUMMY_NODE_ID))\n@@ -366,7 +365,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn typaram(&self,\n                id: ast::Ident,\n-               bounds: OptVec<ast::TyParamBound>,\n+               bounds: OwnedSlice<ast::TyParamBound>,\n                default: Option<P<ast::Ty>>) -> ast::TyParam {\n         ast::TyParam {\n             ident: id,\n@@ -379,20 +378,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     // these are strange, and probably shouldn't be used outside of\n     // pipes. Specifically, the global version possible generates\n     // incorrect code.\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> {\n-        opt_vec::take_vec(\n-            ty_params.map(|p| self.ty_ident(DUMMY_SP, p.ident)))\n+    fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> {\n+        ty_params.iter().map(|p| self.ty_ident(DUMMY_SP, p.ident)).collect()\n     }\n \n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> {\n-        opt_vec::take_vec(\n-            ty_params.map(|p| self.ty_path(\n-                self.path_global(DUMMY_SP, vec!(p.ident)), None)))\n+    fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> {\n+        ty_params.iter().map(|p| self.ty_path(\n+                self.path_global(DUMMY_SP, vec!(p.ident)), None)).collect()\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {\n         let new_params = generics.ty_params.map(|ty_param| {\n-            ast::TyParam { bounds: opt_vec::Empty, ..*ty_param }\n+            ast::TyParam { bounds: OwnedSlice::empty(), ..*ty_param }\n         });\n         Generics {\n             ty_params: new_params,"}, {"sha": "8441fa719ea7e7ecf6b8f9a9c48d815769c24f20", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -12,7 +12,7 @@ use ast;\n use codemap::Span;\n use ext::base::*;\n use ext::base;\n-use opt_vec;\n+use owned_slice::OwnedSlice;\n use parse::token;\n use parse::token::{str_to_ident};\n \n@@ -52,7 +52,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     ast::PathSegment {\n                         identifier: res,\n                         lifetimes: Vec::new(),\n-                        types: opt_vec::Empty,\n+                        types: OwnedSlice::empty(),\n                     }\n                 )\n             }"}, {"sha": "89a8b2cd336d5d82c8221f5c1e4f9ed0afee34b4", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -184,7 +184,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap;\n use codemap::Span;\n-use opt_vec;\n+use owned_slice::OwnedSlice;\n use parse::token::InternedString;\n \n use std::vec;\n@@ -360,27 +360,32 @@ impl<'a> TraitDef<'a> {\n                            methods: Vec<@ast::Method> ) -> @ast::Item {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n-        let mut trait_generics = self.generics.to_generics(cx, self.span,\n-                                                           type_ident, generics);\n+        let Generics { mut lifetimes, ty_params } =\n+            self.generics.to_generics(cx, self.span, type_ident, generics);\n+        let mut ty_params = ty_params.into_vec();\n+\n         // Copy the lifetimes\n-        for l in generics.lifetimes.iter() {\n-            trait_generics.lifetimes.push(*l)\n-        };\n+        lifetimes.extend(&mut generics.lifetimes.iter().map(|l| *l));\n+\n         // Create the type parameters.\n-        for ty_param in generics.ty_params.iter() {\n+        ty_params.extend(&mut generics.ty_params.iter().map(|ty_param| {\n             // I don't think this can be moved out of the loop, since\n             // a TyParamBound requires an ast id\n-            let mut bounds = opt_vec::from(\n+            let mut bounds =\n                 // extra restrictions on the generics parameters to the type being derived upon\n                 self.additional_bounds.map(|p| {\n                     cx.typarambound(p.to_path(cx, self.span,\n                                                   type_ident, generics))\n-                }));\n+                });\n             // require the current trait\n             bounds.push(cx.typarambound(trait_path.clone()));\n \n-            trait_generics.ty_params.push(cx.typaram(ty_param.ident, bounds, None));\n-        }\n+            cx.typaram(ty_param.ident, OwnedSlice::from_vec(bounds), None)\n+        }));\n+        let trait_generics = Generics {\n+            lifetimes: lifetimes,\n+            ty_params: OwnedSlice::from_vec(ty_params)\n+        };\n \n         // Create the reference to the trait.\n         let trait_ref = cx.trait_ref(trait_path);\n@@ -395,7 +400,7 @@ impl<'a> TraitDef<'a> {\n         // Create the type of `self`.\n         let self_type = cx.ty_path(\n             cx.path_all(self.span, false, vec!( type_ident ), self_lifetimes,\n-                        opt_vec::take_vec(self_ty_params)), None);\n+                        self_ty_params.into_vec()), None);\n \n         let attr = cx.attribute(\n             self.span,"}, {"sha": "bfdfba7ba782d6e5391ccb68d833f6ffa541253e", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -18,7 +18,7 @@ use ast::{P,Expr,Generics,Ident};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{Span,respan};\n-use opt_vec;\n+use owned_slice::OwnedSlice;\n \n /// The types of pointers\n pub enum PtrTy<'a> {\n@@ -116,11 +116,10 @@ fn mk_lifetime(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifet\n }\n \n fn mk_lifetimes(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Vec<ast::Lifetime> {\n-    let lifetimes = match *lt {\n-        Some(ref s) => opt_vec::with(cx.lifetime(span, cx.ident_of(*s).name)),\n-        None => opt_vec::Empty\n-    };\n-    opt_vec::take_vec(lifetimes)\n+    match *lt {\n+        Some(ref s) => vec!(cx.lifetime(span, cx.ident_of(*s).name)),\n+        None => vec!()\n+    }\n }\n \n impl<'a> Ty<'a> {\n@@ -173,7 +172,7 @@ impl<'a> Ty<'a> {\n                 let lifetimes = self_generics.lifetimes.clone();\n \n                 cx.path_all(span, false, vec!(self_ty), lifetimes,\n-                            opt_vec::take_vec(self_params))\n+                            self_params.into_vec())\n             }\n             Literal(ref p) => {\n                 p.to_path(cx, span, self_ty, self_generics)\n@@ -187,18 +186,18 @@ impl<'a> Ty<'a> {\n \n fn mk_ty_param(cx: &ExtCtxt, span: Span, name: &str, bounds: &[Path],\n                self_ident: Ident, self_generics: &Generics) -> ast::TyParam {\n-    let bounds = opt_vec::from(\n+    let bounds =\n         bounds.iter().map(|b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n             cx.typarambound(path)\n-        }).collect());\n+        }).collect();\n     cx.typaram(cx.ident_of(name), bounds, None)\n }\n \n fn mk_generics(lifetimes: Vec<ast::Lifetime> ,  ty_params: Vec<ast::TyParam> ) -> Generics {\n     Generics {\n         lifetimes: lifetimes,\n-        ty_params: opt_vec::from(ty_params)\n+        ty_params: OwnedSlice::from_vec(ty_params)\n     }\n }\n "}, {"sha": "0afde5be9a07605121056b9593b5fc4930d04901", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -13,7 +13,7 @@ use ast;\n use ast_util;\n use codemap::{respan, Span, Spanned};\n use parse::token;\n-use opt_vec::OptVec;\n+use owned_slice::OwnedSlice;\n use util::small_vector::SmallVector;\n \n // We may eventually want to be able to fold over type parameters, too.\n@@ -424,8 +424,8 @@ pub fn fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {\n     }\n }\n \n-pub fn fold_ty_params<T: Folder>(tps: &OptVec<TyParam>, fld: &mut T)\n-                                   -> OptVec<TyParam> {\n+pub fn fold_ty_params<T: Folder>(tps: &OwnedSlice<TyParam>, fld: &mut T)\n+                                   -> OwnedSlice<TyParam> {\n     tps.map(|tp| fold_ty_param(tp, fld))\n }\n \n@@ -493,8 +493,8 @@ fn fold_mt<T: Folder>(mt: &MutTy, folder: &mut T) -> MutTy {\n     }\n }\n \n-fn fold_opt_bounds<T: Folder>(b: &Option<OptVec<TyParamBound>>, folder: &mut T)\n-                              -> Option<OptVec<TyParamBound>> {\n+fn fold_opt_bounds<T: Folder>(b: &Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n+                              -> Option<OwnedSlice<TyParamBound>> {\n     b.as_ref().map(|bounds| {\n         bounds.map(|bound| {\n             fold_ty_param_bound(bound, folder)"}, {"sha": "70fb96e4c5f00e0bd6f80a33e4ea11a67e222378", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -49,7 +49,7 @@ pub mod syntax {\n     pub use parse;\n }\n \n-pub mod opt_vec;\n+pub mod owned_slice;\n pub mod attr;\n pub mod diagnostic;\n pub mod codemap;"}, {"sha": "aeb521468d2c52d8dc7de709c50dac77cc850684", "filename": "src/libsyntax/opt_vec.rs", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -1,217 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * Defines a type OptVec<T> that can be used in place of ~[T].\n- * OptVec avoids the need for allocation for empty vectors.\n- * OptVec implements the iterable interface as well as\n- * other useful things like `push()` and `len()`.\n- */\n-\n-use std::default::Default;\n-use std::slice;\n-\n-#[deriving(Clone, Encodable, Decodable, Hash)]\n-pub enum OptVec<T> {\n-    Empty,\n-    Vec(Vec<T> )\n-}\n-\n-pub fn with<T>(t: T) -> OptVec<T> {\n-    Vec(vec!(t))\n-}\n-\n-pub fn from<T>(t: Vec<T> ) -> OptVec<T> {\n-    if t.len() == 0 {\n-        Empty\n-    } else {\n-        Vec(t)\n-    }\n-}\n-\n-impl<T> OptVec<T> {\n-    pub fn push(&mut self, t: T) {\n-        match *self {\n-            Vec(ref mut v) => {\n-                v.push(t);\n-                return;\n-            }\n-            Empty => {\n-                *self = Vec(vec!(t));\n-            }\n-        }\n-    }\n-\n-    pub fn pop(&mut self) -> Option<T> {\n-        match *self {\n-            Vec(ref mut v) => v.pop(),\n-            Empty => None\n-        }\n-    }\n-\n-    pub fn last<'a>(&'a self) -> Option<&'a T> {\n-        match *self {\n-            Vec(ref v) => v.last(),\n-            Empty => None\n-        }\n-    }\n-\n-    pub fn mut_last<'a>(&'a mut self) -> Option<&'a mut T> {\n-        match *self {\n-            Vec(ref mut v) => v.mut_last(),\n-            Empty => None\n-        }\n-    }\n-\n-    pub fn map<U>(&self, op: |&T| -> U) -> OptVec<U> {\n-        match *self {\n-            Empty => Empty,\n-            Vec(ref v) => Vec(v.map(op))\n-        }\n-    }\n-\n-    pub fn map_move<U>(self, op: |T| -> U) -> OptVec<U> {\n-        match self {\n-            Empty => Empty,\n-            Vec(v) => Vec(v.move_iter().map(op).collect())\n-        }\n-    }\n-\n-    pub fn get<'a>(&'a self, i: uint) -> &'a T {\n-        match *self {\n-            Empty => fail!(\"invalid index {}\", i),\n-            Vec(ref v) => v.get(i)\n-        }\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-\n-    pub fn len(&self) -> uint {\n-        match *self {\n-            Empty => 0,\n-            Vec(ref v) => v.len()\n-        }\n-    }\n-\n-    pub fn swap_remove(&mut self, index: uint) {\n-        match *self {\n-            Empty => { fail!(\"index out of bounds\"); }\n-            Vec(ref mut v) => {\n-                assert!(index < v.len());\n-                v.swap_remove(index);\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn iter<'r>(&'r self) -> Items<'r, T> {\n-        match *self {\n-            Empty => Items{iter: None},\n-            Vec(ref v) => Items{iter: Some(v.iter())}\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn map_to_vec<B>(&self, op: |&T| -> B) -> Vec<B> {\n-        self.iter().map(op).collect()\n-    }\n-\n-    pub fn mapi_to_vec<B>(&self, op: |uint, &T| -> B) -> Vec<B> {\n-        let mut index = 0;\n-        self.map_to_vec(|a| {\n-            let i = index;\n-            index += 1;\n-            op(i, a)\n-        })\n-    }\n-}\n-\n-pub fn take_vec<T>(v: OptVec<T>) -> Vec<T> {\n-    match v {\n-        Empty => Vec::new(),\n-        Vec(v) => v\n-    }\n-}\n-\n-impl<T:Clone> OptVec<T> {\n-    pub fn prepend(&self, t: T) -> OptVec<T> {\n-        let mut v0 = vec!(t);\n-        match *self {\n-            Empty => {}\n-            Vec(ref v1) => { v0.push_all(v1.as_slice()); }\n-        }\n-        return Vec(v0);\n-    }\n-}\n-\n-impl<A:Eq> Eq for OptVec<A> {\n-    fn eq(&self, other: &OptVec<A>) -> bool {\n-        // Note: cannot use #[deriving(Eq)] here because\n-        // (Empty, Vec(~[])) ought to be equal.\n-        match (self, other) {\n-            (&Empty, &Empty) => true,\n-            (&Empty, &Vec(ref v)) => v.is_empty(),\n-            (&Vec(ref v), &Empty) => v.is_empty(),\n-            (&Vec(ref v1), &Vec(ref v2)) => *v1 == *v2\n-        }\n-    }\n-\n-    fn ne(&self, other: &OptVec<A>) -> bool {\n-        !self.eq(other)\n-    }\n-}\n-\n-impl<T> Default for OptVec<T> {\n-    fn default() -> OptVec<T> { Empty }\n-}\n-\n-pub struct Items<'a, T> {\n-    priv iter: Option<slice::Items<'a, T>>\n-}\n-\n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a T> {\n-        match self.iter {\n-            Some(ref mut x) => x.next(),\n-            None => None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        match self.iter {\n-            Some(ref x) => x.size_hint(),\n-            None => (0, Some(0))\n-        }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a T> {\n-        match self.iter {\n-            Some(ref mut x) => x.next_back(),\n-            None => None\n-        }\n-    }\n-}\n-\n-impl<A> FromIterator<A> for OptVec<A> {\n-    fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> OptVec<A> {\n-        let mut r = Empty;\n-        for x in *iterator {\n-            r.push(x);\n-        }\n-        r\n-    }\n-}"}, {"sha": "df38945f198538b808ef5462498e2122cdd93066", "filename": "src/libsyntax/owned_slice.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::default::Default;\n+use std::hash::Hash;\n+use std::{cast, mem, raw, ptr, slice};\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n+\n+/// A non-growable owned slice. This would preferably become `~[T]`\n+/// under DST.\n+#[unsafe_no_drop_flag] // data is set to null on destruction\n+pub struct OwnedSlice<T> {\n+    /// null iff len == 0\n+    priv data: *mut T,\n+    priv len: uint,\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for OwnedSlice<T> {\n+    fn drop(&mut self) {\n+        if self.data.is_null() { return }\n+\n+        // extract the vector\n+        let v = mem::replace(self, OwnedSlice::empty());\n+        // free via the Vec destructor\n+        v.into_vec();\n+    }\n+}\n+\n+impl<T> OwnedSlice<T> {\n+    pub fn empty() -> OwnedSlice<T> {\n+        OwnedSlice  { data: ptr::mut_null(), len: 0 }\n+    }\n+\n+    #[inline(never)]\n+    pub fn from_vec(mut v: Vec<T>) -> OwnedSlice<T> {\n+        let len = v.len();\n+\n+        if len == 0 {\n+            OwnedSlice::empty()\n+        } else {\n+            let p = v.as_mut_ptr();\n+            // we own the allocation now\n+            unsafe {cast::forget(v)}\n+\n+            OwnedSlice { data: p, len: len }\n+        }\n+    }\n+\n+    #[inline(never)]\n+    pub fn into_vec(self) -> Vec<T> {\n+        // null is ok, because len == 0 in that case, as required by Vec.\n+        unsafe {\n+            let ret = Vec::from_raw_parts(self.len, self.len, self.data);\n+            // the vector owns the allocation now\n+            cast::forget(self);\n+            ret\n+        }\n+    }\n+\n+    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+        static PTR_MARKER: u8 = 0;\n+        let ptr = if self.data.is_null() {\n+            // length zero, i.e. this will never be read as a T.\n+            &PTR_MARKER as *u8 as *T\n+        } else {\n+            self.data as *T\n+        };\n+\n+        let slice: &[T] = unsafe {cast::transmute(raw::Slice {\n+            data: ptr,\n+            len: self.len\n+        })};\n+\n+        slice\n+    }\n+\n+    pub fn get<'a>(&'a self, i: uint) -> &'a T {\n+        self.as_slice().get(i).expect(\"OwnedSlice: index out of bounds\")\n+    }\n+\n+    pub fn iter<'r>(&'r self) -> slice::Items<'r, T> {\n+        self.as_slice().iter()\n+    }\n+\n+    pub fn map<U>(&self, f: |&T| -> U) -> OwnedSlice<U> {\n+        self.iter().map(f).collect()\n+    }\n+}\n+\n+impl<T> Default for OwnedSlice<T> {\n+    fn default() -> OwnedSlice<T> {\n+        OwnedSlice::empty()\n+    }\n+}\n+\n+impl<T: Clone> Clone for OwnedSlice<T> {\n+    fn clone(&self) -> OwnedSlice<T> {\n+        OwnedSlice::from_vec(Vec::from_slice(self.as_slice()))\n+    }\n+}\n+\n+impl<S: Writer, T: Hash<S>> Hash<S> for OwnedSlice<T> {\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state)\n+    }\n+}\n+\n+impl<T: Eq> Eq for OwnedSlice<T> {\n+    fn eq(&self, other: &OwnedSlice<T>) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl<T> Container for OwnedSlice<T> {\n+    fn len(&self) -> uint { self.len }\n+}\n+\n+impl<T> FromIterator<T> for OwnedSlice<T> {\n+    fn from_iterator<I: Iterator<T>>(iter: &mut I) -> OwnedSlice<T> {\n+        OwnedSlice::from_vec(iter.collect())\n+    }\n+}\n+\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for OwnedSlice<T> {\n+    fn encode(&self, s: &mut S) {\n+       self.as_slice().encode(s)\n+    }\n+}\n+\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for OwnedSlice<T> {\n+    fn decode(d: &mut D) -> OwnedSlice<T> {\n+        OwnedSlice::from_vec(Decodable::decode(d))\n+    }\n+}"}, {"sha": "eb6b462fb94fc9761c60d20fa50e61a9855459c2", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -279,7 +279,7 @@ mod test {\n     use std::io::MemWriter;\n     use std::str;\n     use codemap::{Span, BytePos, Spanned};\n-    use opt_vec;\n+    use owned_slice::OwnedSlice;\n     use ast;\n     use abi;\n     use parse::parser::Parser;\n@@ -312,7 +312,7 @@ mod test {\n                             ast::PathSegment {\n                                 identifier: str_to_ident(\"a\"),\n                                 lifetimes: Vec::new(),\n-                                types: opt_vec::Empty,\n+                                types: OwnedSlice::empty(),\n                             }\n                         ),\n                     }),\n@@ -331,12 +331,12 @@ mod test {\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"a\"),\n                                     lifetimes: Vec::new(),\n-                                    types: opt_vec::Empty,\n+                                    types: OwnedSlice::empty(),\n                                 },\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n                                     lifetimes: Vec::new(),\n-                                    types: opt_vec::Empty,\n+                                    types: OwnedSlice::empty(),\n                                 }\n                             )\n                         }),\n@@ -545,7 +545,7 @@ mod test {\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"d\"),\n                                     lifetimes: Vec::new(),\n-                                    types: opt_vec::Empty,\n+                                    types: OwnedSlice::empty(),\n                                 }\n                             ),\n                         }),\n@@ -567,7 +567,7 @@ mod test {\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n                                     lifetimes: Vec::new(),\n-                                    types: opt_vec::Empty,\n+                                    types: OwnedSlice::empty(),\n                                 }\n                                ),\n                             }),\n@@ -595,7 +595,7 @@ mod test {\n                                         ast::PathSegment {\n                                             identifier: str_to_ident(\"b\"),\n                                             lifetimes: Vec::new(),\n-                                            types: opt_vec::Empty,\n+                                            types: OwnedSlice::empty(),\n                                         }\n                                     ),\n                                 },\n@@ -623,7 +623,7 @@ mod test {\n                                                 identifier:\n                                                     str_to_ident(\"int\"),\n                                                 lifetimes: Vec::new(),\n-                                                types: opt_vec::Empty,\n+                                                types: OwnedSlice::empty(),\n                                             }\n                                         ),\n                                         }, None, ast::DUMMY_NODE_ID),\n@@ -641,7 +641,7 @@ mod test {\n                                                         identifier:\n                                                             str_to_ident(\"b\"),\n                                                         lifetimes: Vec::new(),\n-                                                        types: opt_vec::Empty,\n+                                                        types: OwnedSlice::empty(),\n                                                     }\n                                                 ),\n                                             },\n@@ -661,7 +661,7 @@ mod test {\n                                     abi::AbiSet::Rust(),\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),\n-                                        ty_params: opt_vec::Empty,\n+                                        ty_params: OwnedSlice::empty(),\n                                     },\n                                     ast::P(ast::Block {\n                                         view_items: Vec::new(),\n@@ -680,7 +680,7 @@ mod test {\n                                                                 lifetimes:\n                                                                 Vec::new(),\n                                                                 types:\n-                                                                opt_vec::Empty\n+                                                                OwnedSlice::empty()\n                                                             }\n                                                         ),\n                                                       }),"}, {"sha": "c8492cc4113fcd52f89721532eba81cad04d918c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -75,8 +75,7 @@ use parse::token::{is_ident, is_ident_or_path, is_plain_ident};\n use parse::token::{keywords, special_idents, token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, ParseSess};\n-use opt_vec;\n-use opt_vec::OptVec;\n+use owned_slice::OwnedSlice;\n \n use std::cell::Cell;\n use collections::HashSet;\n@@ -117,13 +116,13 @@ pub enum PathParsingMode {\n /// for the definition of a path segment.)\n struct PathSegmentAndBoundSet {\n     segment: ast::PathSegment,\n-    bound_set: Option<OptVec<TyParamBound>>,\n+    bound_set: Option<OwnedSlice<TyParamBound>>,\n }\n \n /// A path paired with optional type bounds.\n pub struct PathAndBounds {\n     path: ast::Path,\n-    bounds: Option<OptVec<TyParamBound>>,\n+    bounds: Option<OwnedSlice<TyParamBound>>,\n }\n \n enum ItemOrViewItem {\n@@ -630,9 +629,9 @@ impl<'a> Parser<'a> {\n                                   &mut self,\n                                   sep: Option<token::Token>,\n                                   f: |&mut Parser| -> T)\n-                                  -> OptVec<T> {\n+                                  -> OwnedSlice<T> {\n         let mut first = true;\n-        let mut v = opt_vec::Empty;\n+        let mut v = Vec::new();\n         while self.token != token::GT\n             && self.token != token::BINOP(token::SHR) {\n             match sep {\n@@ -644,14 +643,14 @@ impl<'a> Parser<'a> {\n             }\n             v.push(f(self));\n         }\n-        return v;\n+        return OwnedSlice::from_vec(v);\n     }\n \n     pub fn parse_seq_to_gt<T>(\n                            &mut self,\n                            sep: Option<token::Token>,\n                            f: |&mut Parser| -> T)\n-                           -> OptVec<T> {\n+                           -> OwnedSlice<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n         return v;\n@@ -681,7 +680,7 @@ impl<'a> Parser<'a> {\n                                    f: |&mut Parser| -> T)\n                                    -> Vec<T> {\n         let mut first: bool = true;\n-        let mut v: Vec<T> = Vec::new();\n+        let mut v = vec!();\n         while self.token != *ket {\n             match sep.sep {\n               Some(ref t) => {\n@@ -1531,7 +1530,7 @@ impl<'a> Parser<'a> {\n                     segment: ast::PathSegment {\n                         identifier: identifier,\n                         lifetimes: Vec::new(),\n-                        types: opt_vec::Empty,\n+                        types: OwnedSlice::empty(),\n                     },\n                     bound_set: bound_set\n                 });\n@@ -1543,9 +1542,9 @@ impl<'a> Parser<'a> {\n                 if mode != NoTypesAllowed && self.eat(&token::LT) {\n                     let (lifetimes, types) =\n                         self.parse_generic_values_after_lt();\n-                    (true, lifetimes, opt_vec::from(types))\n+                    (true, lifetimes, OwnedSlice::from_vec(types))\n                 } else {\n-                    (false, Vec::new(), opt_vec::Empty)\n+                    (false, Vec::new(), OwnedSlice::empty())\n                 }\n             };\n \n@@ -3432,12 +3431,12 @@ impl<'a> Parser<'a> {\n     // Returns \"Some(Empty)\" if there's a colon but nothing after (e.g. \"T:\")\n     // Returns \"Some(stuff)\" otherwise (e.g. \"T:stuff\").\n     // NB: The None/Some distinction is important for issue #7264.\n-    fn parse_optional_ty_param_bounds(&mut self) -> Option<OptVec<TyParamBound>> {\n+    fn parse_optional_ty_param_bounds(&mut self) -> Option<OwnedSlice<TyParamBound>> {\n         if !self.eat(&token::COLON) {\n             return None;\n         }\n \n-        let mut result = opt_vec::Empty;\n+        let mut result = vec!();\n         loop {\n             match self.token {\n                 token::LIFETIME(lifetime) => {\n@@ -3462,7 +3461,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return Some(result);\n+        return Some(OwnedSlice::from_vec(result));\n     }\n \n     // matches typaram = IDENT optbounds ( EQ ty )?\n@@ -3515,7 +3514,7 @@ impl<'a> Parser<'a> {\n         let result = self.parse_seq_to_gt(\n             Some(token::COMMA),\n             |p| p.parse_ty(false));\n-        (lifetimes, opt_vec::take_vec(result))\n+        (lifetimes, result.into_vec())\n     }\n \n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n@@ -4882,7 +4881,7 @@ impl<'a> Parser<'a> {\n                     ast::PathSegment {\n                         identifier: identifier,\n                         lifetimes: Vec::new(),\n-                        types: opt_vec::Empty,\n+                        types: OwnedSlice::empty(),\n                     }\n                 }).collect()\n             };\n@@ -4917,7 +4916,7 @@ impl<'a> Parser<'a> {\n                             ast::PathSegment {\n                                 identifier: identifier,\n                                 lifetimes: Vec::new(),\n-                                types: opt_vec::Empty,\n+                                types: OwnedSlice::empty(),\n                             }\n                         }).collect()\n                     };\n@@ -4935,7 +4934,7 @@ impl<'a> Parser<'a> {\n                             ast::PathSegment {\n                                 identifier: identifier,\n                                 lifetimes: Vec::new(),\n-                                types: opt_vec::Empty,\n+                                types: OwnedSlice::empty(),\n                             }\n                         }).collect()\n                     };\n@@ -4957,7 +4956,7 @@ impl<'a> Parser<'a> {\n                 ast::PathSegment {\n                     identifier: identifier,\n                     lifetimes: Vec::new(),\n-                    types: opt_vec::Empty,\n+                    types: OwnedSlice::empty(),\n                 }\n             }).collect()\n         };"}, {"sha": "9cecd5f6c2b53e9db61671801488475bb5f0a308", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -12,8 +12,7 @@ use abi::AbiSet;\n use ast::{P, RegionTyParamBound, TraitTyParamBound, Required, Provided};\n use ast;\n use ast_util;\n-use opt_vec::OptVec;\n-use opt_vec;\n+use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n use codemap::{CodeMap, BytePos};\n use codemap;\n@@ -478,7 +477,7 @@ impl<'a> State<'a> {\n             ast::TyBareFn(f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n-                    ty_params: opt_vec::Empty\n+                    ty_params: OwnedSlice::empty()\n                 };\n                 try!(self.print_ty_fn(Some(f.abis), None, &None,\n                                    f.purity, ast::Many, f.decl, None, &None,\n@@ -487,7 +486,7 @@ impl<'a> State<'a> {\n             ast::TyClosure(f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n-                    ty_params: opt_vec::Empty\n+                    ty_params: OwnedSlice::empty()\n                 };\n                 try!(self.print_ty_fn(None, Some(f.sigil), &f.region,\n                                    f.purity, f.onceness, f.decl, None, &f.bounds,\n@@ -1518,7 +1517,7 @@ impl<'a> State<'a> {\n     fn print_path_(&mut self,\n                    path: &ast::Path,\n                    colons_before_params: bool,\n-                   opt_bounds: &Option<OptVec<ast::TyParamBound>>)\n+                   opt_bounds: &Option<OwnedSlice<ast::TyParamBound>>)\n         -> IoResult<()> {\n         try!(self.maybe_print_comment(path.span.lo));\n         if path.global {\n@@ -1564,7 +1563,7 @@ impl<'a> State<'a> {\n                     }\n                     try!(self.commasep(\n                         Inconsistent,\n-                        segment.types.map_to_vec(|&t| t).as_slice(),\n+                        segment.types.as_slice(),\n                         |s, ty| s.print_type_ref(ty)));\n                 }\n \n@@ -1580,7 +1579,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_bounded_path(&mut self, path: &ast::Path,\n-                          bounds: &Option<OptVec<ast::TyParamBound>>)\n+                          bounds: &Option<OwnedSlice<ast::TyParamBound>>)\n         -> IoResult<()> {\n         self.print_path_(path, false, bounds)\n     }\n@@ -1826,7 +1825,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(decl.output.span.lo)\n     }\n \n-    pub fn print_bounds(&mut self, bounds: &OptVec<ast::TyParamBound>,\n+    pub fn print_bounds(&mut self, bounds: &OwnedSlice<ast::TyParamBound>,\n                         print_colon_anyway: bool) -> IoResult<()> {\n         if !bounds.is_empty() {\n             try!(word(&mut self.s, \":\"));\n@@ -2028,7 +2027,7 @@ impl<'a> State<'a> {\n                        onceness: ast::Onceness,\n                        decl: &ast::FnDecl,\n                        id: Option<ast::Ident>,\n-                       opt_bounds: &Option<OptVec<ast::TyParamBound>>,\n+                       opt_bounds: &Option<OwnedSlice<ast::TyParamBound>>,\n                        generics: Option<&ast::Generics>,\n                        opt_explicit_self: Option<ast::ExplicitSelf_>)\n         -> IoResult<()> {"}, {"sha": "de3eb1b9b8d6d9ef6b28e742e1e65fe8936a02e3", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5357cf3cee42d12249006a42dfa835f96ab5422/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f5357cf3cee42d12249006a42dfa835f96ab5422", "patch": "@@ -13,8 +13,7 @@ use ast::*;\n use ast;\n use codemap::Span;\n use parse;\n-use opt_vec;\n-use opt_vec::OptVec;\n+use owned_slice::OwnedSlice;\n \n // Context-passing AST walker. Each overridden visit method has full control\n // over what happens with its node, it can do its own traversal of the node's\n@@ -56,7 +55,7 @@ pub fn generics_of_fn(fk: &FnKind) -> Generics {\n         FkFnBlock(..) => {\n             Generics {\n                 lifetimes: Vec::new(),\n-                ty_params: opt_vec::Empty,\n+                ty_params: OwnedSlice::empty(),\n             }\n         }\n     }\n@@ -457,7 +456,7 @@ pub fn walk_foreign_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n }\n \n pub fn walk_ty_param_bounds<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                     bounds: &OptVec<TyParamBound>,\n+                                                     bounds: &OwnedSlice<TyParamBound>,\n                                                      env: E) {\n     for bound in bounds.iter() {\n         match *bound {"}]}