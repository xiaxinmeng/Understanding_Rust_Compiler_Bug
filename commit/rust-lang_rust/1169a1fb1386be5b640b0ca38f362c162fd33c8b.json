{"sha": "1169a1fb1386be5b640b0ca38f362c162fd33c8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNjlhMWZiMTM4NmJlNWI2NDBiMGNhMzhmMzYyYzE2MmZkMzNjOGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-17T00:05:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-17T00:05:50Z"}, "message": "Auto merge of #42604 - stepancheg:timedwait, r=alexcrichton\n\nFix condvar.wait(distant future) return immediately on OSX\n\nFixes issue #37440: `pthread_cond_timedwait` on macOS Sierra seems\nto overflow `ts_sec` parameter and returns immediately. To work\naround this problem patch rounds timeout down to year 3000.\n\nPatch also fixes overflow when converting `u64` to `time_t`.", "tree": {"sha": "6c61125d6a99978348e77db3adccedc661ce7d3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c61125d6a99978348e77db3adccedc661ce7d3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1169a1fb1386be5b640b0ca38f362c162fd33c8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1169a1fb1386be5b640b0ca38f362c162fd33c8b", "html_url": "https://github.com/rust-lang/rust/commit/1169a1fb1386be5b640b0ca38f362c162fd33c8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1169a1fb1386be5b640b0ca38f362c162fd33c8b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cb803460b109235cf83bbfc4173e5b038ce3396", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cb803460b109235cf83bbfc4173e5b038ce3396", "html_url": "https://github.com/rust-lang/rust/commit/3cb803460b109235cf83bbfc4173e5b038ce3396"}, {"sha": "0c26b5998d269f58c513fc55ebfdf873be02cc99", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c26b5998d269f58c513fc55ebfdf873be02cc99", "html_url": "https://github.com/rust-lang/rust/commit/0c26b5998d269f58c513fc55ebfdf873be02cc99"}], "stats": {"total": 100, "additions": 81, "deletions": 19}, "files": [{"sha": "564021758176b6f2bec77d6a86da41137f32d79e", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1169a1fb1386be5b640b0ca38f362c162fd33c8b/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1169a1fb1386be5b640b0ca38f362c162fd33c8b/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=1169a1fb1386be5b640b0ca38f362c162fd33c8b", "patch": "@@ -480,9 +480,10 @@ impl Drop for Condvar {\n mod tests {\n     use sync::mpsc::channel;\n     use sync::{Condvar, Mutex, Arc};\n+    use sync::atomic::{AtomicBool, Ordering};\n     use thread;\n     use time::Duration;\n-    use u32;\n+    use u64;\n \n     #[test]\n     fn smoke() {\n@@ -547,23 +548,58 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn wait_timeout_ms() {\n+    fn wait_timeout_wait() {\n         let m = Arc::new(Mutex::new(()));\n-        let m2 = m.clone();\n         let c = Arc::new(Condvar::new());\n-        let c2 = c.clone();\n \n-        let g = m.lock().unwrap();\n-        let (g, _no_timeout) = c.wait_timeout(g, Duration::from_millis(1)).unwrap();\n-        // spurious wakeups mean this isn't necessarily true\n-        // assert!(!no_timeout);\n-        let _t = thread::spawn(move || {\n-            let _g = m2.lock().unwrap();\n-            c2.notify_one();\n-        });\n-        let (g, timeout_res) = c.wait_timeout(g, Duration::from_millis(u32::MAX as u64)).unwrap();\n-        assert!(!timeout_res.timed_out());\n-        drop(g);\n+        loop {\n+            let g = m.lock().unwrap();\n+            let (_g, no_timeout) = c.wait_timeout(g, Duration::from_millis(1)).unwrap();\n+            // spurious wakeups mean this isn't necessarily true\n+            // so execute test again, if not timeout\n+            if !no_timeout.timed_out() {\n+                continue;\n+            }\n+\n+            break;\n+        }\n+    }\n+\n+    #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    fn wait_timeout_wake() {\n+        let m = Arc::new(Mutex::new(()));\n+        let c = Arc::new(Condvar::new());\n+\n+        loop {\n+            let g = m.lock().unwrap();\n+\n+            let c2 = c.clone();\n+            let m2 = m.clone();\n+\n+            let notified = Arc::new(AtomicBool::new(false));\n+            let notified_copy = notified.clone();\n+\n+            let t = thread::spawn(move || {\n+                let _g = m2.lock().unwrap();\n+                thread::sleep(Duration::from_millis(1));\n+                notified_copy.store(true, Ordering::SeqCst);\n+                c2.notify_one();\n+            });\n+            let (g, timeout_res) = c.wait_timeout(g, Duration::from_millis(u64::MAX)).unwrap();\n+            assert!(!timeout_res.timed_out());\n+            // spurious wakeups mean this isn't necessarily true\n+            // so execute test again, if not notified\n+            if !notified.load(Ordering::SeqCst) {\n+                t.join().unwrap();\n+                continue;\n+            }\n+            drop(g);\n+\n+            t.join().unwrap();\n+\n+            break;\n+        }\n     }\n \n     #[test]"}, {"sha": "b9ea573b323d2ea8b63071ae76a69db31aa460e0", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1169a1fb1386be5b640b0ca38f362c162fd33c8b/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1169a1fb1386be5b640b0ca38f362c162fd33c8b/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=1169a1fb1386be5b640b0ca38f362c162fd33c8b", "patch": "@@ -23,6 +23,14 @@ const TIMESPEC_MAX: libc::timespec = libc::timespec {\n     tv_nsec: 1_000_000_000 - 1,\n };\n \n+fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n+    if value > <libc::time_t>::max_value() as u64 {\n+        <libc::time_t>::max_value()\n+    } else {\n+        value as libc::time_t\n+    }\n+}\n+\n impl Condvar {\n     pub const fn new() -> Condvar {\n         // Might be moved and address is changing it is better to avoid\n@@ -79,8 +87,7 @@ impl Condvar {\n \n         // Nanosecond calculations can't overflow because both values are below 1e9.\n         let nsec = dur.subsec_nanos() as libc::c_long + now.tv_nsec as libc::c_long;\n-        // FIXME: Casting u64 into time_t could truncate the value.\n-        let sec = (dur.as_secs() as libc::time_t)\n+        let sec = saturating_cast_to_time_t(dur.as_secs())\n             .checked_add((nsec / 1_000_000_000) as libc::time_t)\n             .and_then(|s| s.checked_add(now.tv_sec));\n         let nsec = nsec % 1_000_000_000;\n@@ -100,10 +107,29 @@ impl Condvar {\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n     #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\"))]\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n         use ptr;\n         use time::Instant;\n \n+        // 1000 years\n+        let max_dur = Duration::from_secs(1000 * 365 * 86400);\n+\n+        if dur > max_dur {\n+            // OSX implementation of `pthread_cond_timedwait` is buggy\n+            // with super long durations. When duration is greater than\n+            // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n+            // in macOS Sierra return error 316.\n+            //\n+            // This program demonstrates the issue:\n+            // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n+            //\n+            // To work around this issue, and possible bugs of other OSes, timeout\n+            // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n+            // because of spurious wakeups.\n+\n+            dur = max_dur;\n+        }\n+\n         // First, figure out what time it currently is, in both system and\n         // stable time.  pthread_cond_timedwait uses system time, but we want to\n         // report timeout based on stable time.\n@@ -116,7 +142,7 @@ impl Condvar {\n                    (sys_now.tv_usec * 1000) as libc::c_long;\n         let extra = (nsec / 1_000_000_000) as libc::time_t;\n         let nsec = nsec % 1_000_000_000;\n-        let seconds = dur.as_secs() as libc::time_t;\n+        let seconds = saturating_cast_to_time_t(dur.as_secs());\n \n         let timeout = sys_now.tv_sec.checked_add(extra).and_then(|s| {\n             s.checked_add(seconds)"}]}