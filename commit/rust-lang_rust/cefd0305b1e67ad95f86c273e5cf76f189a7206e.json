{"sha": "cefd0305b1e67ad95f86c273e5cf76f189a7206e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZmQwMzA1YjFlNjdhZDk1Zjg2YzI3M2U1Y2Y3NmYxODlhNzIwNmU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-15T12:07:20Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-03-17T08:46:56Z"}, "message": "Don't use `TypeckTables` in NiceRegionError\n\nRegions in TypeckTables will be erased, so are unusable for error\nreporting.", "tree": {"sha": "0754fe2f2ada1a7ce56dbdb786fb6a57257c5f02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0754fe2f2ada1a7ce56dbdb786fb6a57257c5f02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cefd0305b1e67ad95f86c273e5cf76f189a7206e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cefd0305b1e67ad95f86c273e5cf76f189a7206e", "html_url": "https://github.com/rust-lang/rust/commit/cefd0305b1e67ad95f86c273e5cf76f189a7206e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cefd0305b1e67ad95f86c273e5cf76f189a7206e/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a9ccc9ce7242afd866af3321c400c1a87c745a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a9ccc9ce7242afd866af3321c400c1a87c745a8", "html_url": "https://github.com/rust-lang/rust/commit/5a9ccc9ce7242afd866af3321c400c1a87c745a8"}], "stats": {"total": 111, "additions": 51, "deletions": 60}, "files": [{"sha": "50b324c72278e1fa83d9a67671962e900221a6e6", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cefd0305b1e67ad95f86c273e5cf76f189a7206e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefd0305b1e67ad95f86c273e5cf76f189a7206e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=cefd0305b1e67ad95f86c273e5cf76f189a7206e", "patch": "@@ -3,6 +3,8 @@\n \n use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::lexical_region_resolve::RegionResolutionError;\n+use crate::infer::SubregionOrigin;\n use rustc::util::common::ErrorReported;\n \n use rustc_errors::struct_span_err;\n@@ -47,6 +49,15 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     pub(super) fn try_report_anon_anon_conflict(&self) -> Option<ErrorReported> {\n         let (span, sub, sup) = self.regions()?;\n \n+        if let Some(RegionResolutionError::ConcreteFailure(\n+            SubregionOrigin::ReferenceOutlivesReferent(..),\n+            ..,\n+        )) = self.error\n+        {\n+            // This error doesn't make much sense in this case.\n+            return None;\n+        }\n+\n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n         let anon_reg_sup = self.tcx().is_suitable_region(sup)?;\n "}, {"sha": "2357ee689d59e700a5d2c034b6f1d4a828bcbca3", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cefd0305b1e67ad95f86c273e5cf76f189a7206e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefd0305b1e67ad95f86c273e5cf76f189a7206e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=cefd0305b1e67ad95f86c273e5cf76f189a7206e", "patch": "@@ -17,39 +17,28 @@ mod util;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-        if let Some(tables) = self.in_progress_tables {\n-            let tables = tables.borrow();\n-            NiceRegionError::new(self, error.clone(), Some(&tables)).try_report().is_some()\n-        } else {\n-            NiceRegionError::new(self, error.clone(), None).try_report().is_some()\n-        }\n+        NiceRegionError::new(self, error.clone()).try_report().is_some()\n     }\n }\n \n pub struct NiceRegionError<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     error: Option<RegionResolutionError<'tcx>>,\n     regions: Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)>,\n-    tables: Option<&'cx ty::TypeckTables<'tcx>>,\n }\n \n impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n-    pub fn new(\n-        infcx: &'cx InferCtxt<'cx, 'tcx>,\n-        error: RegionResolutionError<'tcx>,\n-        tables: Option<&'cx ty::TypeckTables<'tcx>>,\n-    ) -> Self {\n-        Self { infcx, error: Some(error), regions: None, tables }\n+    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>, error: RegionResolutionError<'tcx>) -> Self {\n+        Self { infcx, error: Some(error), regions: None }\n     }\n \n     pub fn new_from_span(\n         infcx: &'cx InferCtxt<'cx, 'tcx>,\n         span: Span,\n         sub: ty::Region<'tcx>,\n         sup: ty::Region<'tcx>,\n-        tables: Option<&'cx ty::TypeckTables<'tcx>>,\n     ) -> Self {\n-        Self { infcx, error: None, regions: Some((span, sub, sup)), tables }\n+        Self { infcx, error: None, regions: Some((span, sub, sup)) }\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {"}, {"sha": "de72c276595f769dc5b887a087e17615498b39d3", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cefd0305b1e67ad95f86c273e5cf76f189a7206e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefd0305b1e67ad95f86c273e5cf76f189a7206e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=cefd0305b1e67ad95f86c273e5cf76f189a7206e", "patch": "@@ -51,52 +51,44 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         };\n \n         let hir = &self.tcx().hir();\n-        if let Some(hir_id) = hir.as_local_hir_id(id) {\n-            if let Some(body_id) = hir.maybe_body_owned_by(hir_id) {\n-                let body = hir.body(body_id);\n-                let owner_id = hir.body_owner(body_id);\n-                let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n-                if let Some(tables) = self.tables {\n-                    body.params\n-                        .iter()\n-                        .enumerate()\n-                        .filter_map(|(index, param)| {\n-                            // May return None; sometimes the tables are not yet populated.\n-                            let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let param_ty_span = hir.span(ty_hir_id);\n-                            let ty = tables.node_type_opt(param.hir_id)?;\n-                            let mut found_anon_region = false;\n-                            let new_param_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n-                                if *r == *anon_region {\n-                                    found_anon_region = true;\n-                                    replace_region\n-                                } else {\n-                                    r\n-                                }\n-                            });\n-                            if found_anon_region {\n-                                let is_first = index == 0;\n-                                Some(AnonymousParamInfo {\n-                                    param,\n-                                    param_ty: new_param_ty,\n-                                    param_ty_span,\n-                                    bound_region,\n-                                    is_first,\n-                                })\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                        .next()\n+        let hir_id = hir.as_local_hir_id(id)?;\n+        let body_id = hir.maybe_body_owned_by(hir_id)?;\n+        let body = hir.body(body_id);\n+        let owner_id = hir.body_owner(body_id);\n+        let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n+        let poly_fn_sig = self.tcx().fn_sig(id);\n+        let fn_sig = self.tcx().liberate_late_bound_regions(id, &poly_fn_sig);\n+        body.params\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(index, param)| {\n+                // May return None; sometimes the tables are not yet populated.\n+                let ty = fn_sig.inputs()[index];\n+                let mut found_anon_region = false;\n+                let new_param_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n+                    if *r == *anon_region {\n+                        found_anon_region = true;\n+                        replace_region\n+                    } else {\n+                        r\n+                    }\n+                });\n+                if found_anon_region {\n+                    let ty_hir_id = fn_decl.inputs[index].hir_id;\n+                    let param_ty_span = hir.span(ty_hir_id);\n+                    let is_first = index == 0;\n+                    Some(AnonymousParamInfo {\n+                        param,\n+                        param_ty: new_param_ty,\n+                        param_ty_span,\n+                        bound_region,\n+                        is_first,\n+                    })\n                 } else {\n                     None\n                 }\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n+            })\n+            .next()\n     }\n \n     // Here, we check for the case where the anonymous region"}, {"sha": "494b6421fd5d49bcf9e9eae433e76813650b0b58", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cefd0305b1e67ad95f86c273e5cf76f189a7206e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefd0305b1e67ad95f86c273e5cf76f189a7206e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=cefd0305b1e67ad95f86c273e5cf76f189a7206e", "patch": "@@ -284,8 +284,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         debug!(\"report_region_error: category={:?} {:?}\", category, span);\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n-            let tables = self.infcx.tcx.typeck_tables_of(self.mir_def_id);\n-            let nice = NiceRegionError::new_from_span(self.infcx, span, o, f, Some(tables));\n+            let nice = NiceRegionError::new_from_span(self.infcx, span, o, f);\n             if let Some(diag) = nice.try_report_from_nll() {\n                 diag.buffer(&mut self.errors_buffer);\n                 return;"}]}