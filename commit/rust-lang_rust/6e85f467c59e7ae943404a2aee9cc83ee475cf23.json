{"sha": "6e85f467c59e7ae943404a2aee9cc83ee475cf23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlODVmNDY3YzU5ZTdhZTk0MzQwNGEyYWVlOWNjODNlZTQ3NWNmMjM=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-21T18:45:28Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-21T18:45:28Z"}, "message": "Initial implementation of or-pattern usefulness checking", "tree": {"sha": "50f7fda155477b593c16ed3b8976b690f2b3c154", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50f7fda155477b593c16ed3b8976b690f2b3c154"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e85f467c59e7ae943404a2aee9cc83ee475cf23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e85f467c59e7ae943404a2aee9cc83ee475cf23", "html_url": "https://github.com/rust-lang/rust/commit/6e85f467c59e7ae943404a2aee9cc83ee475cf23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e85f467c59e7ae943404a2aee9cc83ee475cf23/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "html_url": "https://github.com/rust-lang/rust/commit/f1b882b55805c342e46ee4ca3beeef1d1fa2044b"}], "stats": {"total": 105, "additions": 91, "deletions": 14}, "files": [{"sha": "7d3bbbc1ee4fac827cbdfc8ad27c24c155798016", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6e85f467c59e7ae943404a2aee9cc83ee475cf23/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e85f467c59e7ae943404a2aee9cc83ee475cf23/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=6e85f467c59e7ae943404a2aee9cc83ee475cf23", "patch": "@@ -399,6 +399,25 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         self.0.iter().map(|p| *p)\n     }\n \n+    // If the first pattern is an or-pattern, expand this pattern. Otherwise, return `None`.\n+    fn expand_or_pat(&self) -> Option<Vec<PatStack<'p, 'tcx>>> {\n+        if self.is_empty() {\n+            None\n+        } else if let PatKind::Or { pats } = &*self.head().kind {\n+            Some(\n+                pats.iter()\n+                    .map(|pat| {\n+                        let mut new_patstack = PatStack::from_pattern(pat);\n+                        new_patstack.0.extend_from_slice(&self.0[1..]);\n+                        new_patstack\n+                    })\n+                    .collect(),\n+            )\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// This computes `D(self)`. See top of the file for explanations.\n     fn specialize_wildcard(&self) -> Option<Self> {\n         if self.head().is_wildcard() { Some(self.to_tail()) } else { None }\n@@ -446,8 +465,13 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         Matrix(vec![])\n     }\n \n+    /// Pushes a new row to the matrix. If the row starts with an or-pattern, this expands it.\n     pub fn push(&mut self, row: PatStack<'p, 'tcx>) {\n-        self.0.push(row)\n+        if let Some(rows) = row.expand_or_pat() {\n+            self.0.extend(rows);\n+        } else {\n+            self.0.push(row);\n+        }\n     }\n \n     /// Iterate over the first component of each row\n@@ -471,12 +495,10 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         'a: 'q,\n         'p: 'q,\n     {\n-        Matrix(\n-            self.0\n-                .iter()\n-                .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n-                .collect(),\n-        )\n+        self.0\n+            .iter()\n+            .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n+            .collect()\n     }\n }\n \n@@ -528,7 +550,12 @@ impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n     where\n         T: IntoIterator<Item = PatStack<'p, 'tcx>>,\n     {\n-        Matrix(iter.into_iter().collect())\n+        let mut matrix = Matrix::empty();\n+        for x in iter {\n+            // Using `push` ensures we correctly expand or-patterns.\n+            matrix.push(x);\n+        }\n+        matrix\n     }\n }\n \n@@ -1601,6 +1628,15 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n+    // If the first pattern is an or-pattern, expand it.\n+    if let Some(vs) = v.expand_or_pat() {\n+        return vs\n+            .into_iter()\n+            .map(|v| is_useful(cx, matrix, &v, witness_preference, hir_id))\n+            .find(|result| result.is_useful())\n+            .unwrap_or(NotUseful);\n+    }\n+\n     let (ty, span) = matrix\n         .heads()\n         .map(|r| (r.ty, r.span))\n@@ -1802,9 +1838,7 @@ fn pat_constructor<'tcx>(\n                 if slice.is_some() { VarLen(prefix, suffix) } else { FixedLen(prefix + suffix) };\n             Some(Slice(Slice { array_len, kind }))\n         }\n-        PatKind::Or { .. } => {\n-            bug!(\"support for or-patterns has not been fully implemented yet.\");\n-        }\n+        PatKind::Or { .. } => bug!(), // Should have been expanded earlier on.\n     }\n }\n \n@@ -2410,9 +2444,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n             _ => span_bug!(pat.span, \"unexpected ctor {:?} for slice pat\", constructor),\n         },\n \n-        PatKind::Or { .. } => {\n-            bug!(\"support for or-patterns has not been fully implemented yet.\");\n-        }\n+        PatKind::Or { .. } => bug!(), // Should have been expanded earlier on.\n     };\n     debug!(\"specialize({:#?}, {:#?}) = {:#?}\", pat, ctor_wild_subpatterns, result);\n "}, {"sha": "e1b5dce852d5fd9a7d88bff8b6384170ad261dd9", "filename": "src/test/compile-fail/or-patterns.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6e85f467c59e7ae943404a2aee9cc83ee475cf23/src%2Ftest%2Fcompile-fail%2For-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e85f467c59e7ae943404a2aee9cc83ee475cf23/src%2Ftest%2Fcompile-fail%2For-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2For-patterns.rs?ref=6e85f467c59e7ae943404a2aee9cc83ee475cf23", "patch": "@@ -0,0 +1,45 @@\n+// should-ice\n+#![allow(incomplete_features)]\n+#![feature(or_patterns)]\n+#![deny(unreachable_patterns)]\n+\n+// The ice will get removed once or-patterns are correctly implemented\n+fn main() {\n+    // We wrap patterns in a tuple because top-level or-patterns are special-cased for now.\n+    match (0u8,) {\n+        (1 | 2,) => {}\n+        //~^ ERROR simplifyable pattern found\n+        // This above is the ICE error message\n+        _ => {}\n+    }\n+\n+    match (0u8,) {\n+        (1 | 2,) => {}\n+        (1,) => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+    match (0u8,) {\n+        (1 | 2,) => {}\n+        (2,) => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+    match (0u8,) {\n+        (1,) => {}\n+        (2,) => {}\n+        (1 | 2,) => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+    match (0u8,) {\n+        (1 | 1,) => {} // redundancy not detected for now\n+        _ => {}\n+    }\n+    match (0u8, 0u8) {\n+        (1 | 2, 3 | 4) => {}\n+        (1, 2) => {}\n+        (1, 3) => {} //~ ERROR unreachable pattern\n+        (1, 4) => {} //~ ERROR unreachable pattern\n+        (2, 4) => {} //~ ERROR unreachable pattern\n+        (2 | 1, 4) => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+}"}]}