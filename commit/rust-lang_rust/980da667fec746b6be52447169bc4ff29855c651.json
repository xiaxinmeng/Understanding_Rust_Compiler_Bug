{"sha": "980da667fec746b6be52447169bc4ff29855c651", "node_id": "C_kwDOAAsO6NoAKDk4MGRhNjY3ZmVjNzQ2YjZiZTUyNDQ3MTY5YmM0ZmYyOTg1NWM2NTE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-23T00:36:20Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-25T03:35:14Z"}, "message": "Add InferCtxt::register_hidden_type_in_new_solver", "tree": {"sha": "c534fab46ee007842b76d37432998f218b26bfb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c534fab46ee007842b76d37432998f218b26bfb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/980da667fec746b6be52447169bc4ff29855c651", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/980da667fec746b6be52447169bc4ff29855c651", "html_url": "https://github.com/rust-lang/rust/commit/980da667fec746b6be52447169bc4ff29855c651", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/980da667fec746b6be52447169bc4ff29855c651/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97c11ffb227c906465d339b36286e6fb99051e3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/97c11ffb227c906465d339b36286e6fb99051e3a", "html_url": "https://github.com/rust-lang/rust/commit/97c11ffb227c906465d339b36286e6fb99051e3a"}], "stats": {"total": 88, "additions": 47, "deletions": 41}, "files": [{"sha": "cf204cff6b3a74f0aeb48903a92de85eeab2b7d8", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/980da667fec746b6be52447169bc4ff29855c651/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980da667fec746b6be52447169bc4ff29855c651/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=980da667fec746b6be52447169bc4ff29855c651", "patch": "@@ -26,7 +26,6 @@ use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::*;\n-use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::{SubstsRef, UserSubsts};"}, {"sha": "9d5ec228d827bd74eaf5c770b94d69af88e0ce9d", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/980da667fec746b6be52447169bc4ff29855c651/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980da667fec746b6be52447169bc4ff29855c651/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=980da667fec746b6be52447169bc4ff29855c651", "patch": "@@ -557,6 +557,29 @@ impl<'tcx> InferCtxt<'tcx> {\n         Ok(InferOk { value: (), obligations })\n     }\n \n+    /// Registers an opaque's hidden type -- only should be used when the opaque\n+    /// can be defined. For something more fallible -- checks the anchors, tries\n+    /// to unify opaques in both dirs, etc. -- use `InferCtxt::handle_opaque_type`.\n+    pub fn register_hidden_type_in_new_solver(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n+    ) -> InferResult<'tcx, ()> {\n+        assert!(self.tcx.trait_solver_next());\n+        let origin = self\n+            .opaque_type_origin(opaque_type_key.def_id)\n+            .expect(\"should be called for defining usages only\");\n+        self.register_hidden_type(\n+            opaque_type_key,\n+            ObligationCause::dummy(),\n+            param_env,\n+            hidden_ty,\n+            origin,\n+            true,\n+        )\n+    }\n+\n     pub fn add_item_bounds_for_hidden_type(\n         &self,\n         OpaqueTypeKey { def_id, substs }: OpaqueTypeKey<'tcx>,"}, {"sha": "f91c672775301610c630480bf89eed604317cc69", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/980da667fec746b6be52447169bc4ff29855c651/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980da667fec746b6be52447169bc4ff29855c651/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=980da667fec746b6be52447169bc4ff29855c651", "patch": "@@ -1,4 +1,4 @@\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -192,13 +192,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n \n             for &(a, b) in &input.predefined_opaques_in_body.opaque_types {\n                 let InferOk { value: (), obligations } = infcx\n-                    .handle_opaque_type(\n-                        tcx.mk_opaque(a.def_id.to_def_id(), a.substs),\n-                        b,\n-                        true,\n-                        &ObligationCause::dummy(),\n-                        input.goal.param_env,\n-                    )\n+                    .register_hidden_type_in_new_solver(a, input.goal.param_env, b)\n                     .expect(\"expected opaque type instantiation to succeed\");\n                 // We're only registering opaques already defined by the caller,\n                 // so we're not responsible for proving that they satisfy their\n@@ -727,19 +721,18 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n-    pub(super) fn can_define_opaque_ty(&mut self, def_id: DefId) -> bool {\n-        let Some(def_id) = def_id.as_local() else { return false; };\n+    pub(super) fn can_define_opaque_ty(&mut self, def_id: LocalDefId) -> bool {\n         self.infcx.opaque_type_origin(def_id).is_some()\n     }\n \n     pub(super) fn register_opaque_ty(\n         &mut self,\n-        a: Ty<'tcx>,\n+        a: ty::OpaqueTypeKey<'tcx>,\n         b: Ty<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Result<(), NoSolution> {\n         let InferOk { value: (), obligations } =\n-            self.infcx.handle_opaque_type(a, b, true, &ObligationCause::dummy(), param_env)?;\n+            self.infcx.register_hidden_type_in_new_solver(a, param_env, b)?;\n         self.add_goals(obligations.into_iter().map(|obligation| obligation.into()));\n         Ok(())\n     }\n@@ -749,17 +742,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn unify_existing_opaque_tys(\n         &mut self,\n         param_env: ty::ParamEnv<'tcx>,\n-        key: ty::AliasTy<'tcx>,\n+        key: ty::OpaqueTypeKey<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> Vec<CanonicalResponse<'tcx>> {\n-        let Some(def_id) = key.def_id.as_local() else { return vec![]; };\n-\n         // FIXME: Super inefficient to be cloning this...\n         let opaques = self.infcx.clone_opaque_types_for_query_response();\n \n         let mut values = vec![];\n         for (candidate_key, candidate_ty) in opaques {\n-            if candidate_key.def_id != def_id {\n+            if candidate_key.def_id != key.def_id {\n                 continue;\n             }\n             values.extend(self.probe(|ecx| {"}, {"sha": "fdb209fbff871cfd7d42c4da75ee28da10ac481f", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/980da667fec746b6be52447169bc4ff29855c651/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980da667fec746b6be52447169bc4ff29855c651/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=980da667fec746b6be52447169bc4ff29855c651", "patch": "@@ -15,11 +15,11 @@ use rustc_index::IndexVec;\n use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n+use rustc_infer::infer::InferOk;\n use rustc_middle::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     ExternalConstraints, ExternalConstraintsData, MaybeCause, PredefinedOpaquesData, QueryInput,\n };\n-use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::{self, BoundVar, GenericArgKind, Ty};\n use rustc_span::DUMMY_SP;\n use std::iter;\n@@ -179,13 +179,12 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let Response { var_values, external_constraints, certainty } =\n             response.substitute(self.tcx(), &substitution);\n \n-        let mut nested_goals =\n-            self.unify_query_var_values(param_env, &original_values, var_values)?;\n+        let nested_goals = self.unify_query_var_values(param_env, &original_values, var_values)?;\n \n         let ExternalConstraintsData { region_constraints, opaque_types } =\n             external_constraints.deref();\n         self.register_region_constraints(region_constraints);\n-        nested_goals.extend(self.register_opaque_types(param_env, opaque_types)?);\n+        self.register_opaque_types(param_env, opaque_types)?;\n \n         Ok((certainty, nested_goals))\n     }\n@@ -310,24 +309,14 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         &mut self,\n         param_env: ty::ParamEnv<'tcx>,\n         opaque_types: &[(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)],\n-    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n-        let mut nested_goals = vec![];\n+    ) -> Result<(), NoSolution> {\n         for &(a, b) in opaque_types {\n-            nested_goals.extend(\n-                self.infcx\n-                    .handle_opaque_type(\n-                        self.tcx().mk_opaque(a.def_id.to_def_id(), a.substs),\n-                        b,\n-                        true,\n-                        &ObligationCause::dummy(),\n-                        param_env,\n-                    )?\n-                    .into_obligations()\n-                    .into_iter()\n-                    .map(Goal::from),\n-            );\n+            let InferOk { value: (), obligations } =\n+                self.infcx.register_hidden_type_in_new_solver(a, param_env, b)?;\n+            // It's sound to drop these obligations, since the normalizes-to goal\n+            // is responsible for proving these obligations.\n+            let _ = obligations;\n         }\n-\n-        Ok(nested_goals)\n+        Ok(())\n     }\n }"}, {"sha": "54557aeb9a2dda4a6593e70bd2fca7997cedf790", "filename": "compiler/rustc_trait_selection/src/solve/opaques.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/980da667fec746b6be52447169bc4ff29855c651/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980da667fec746b6be52447169bc4ff29855c651/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs?ref=980da667fec746b6be52447169bc4ff29855c651", "patch": "@@ -18,10 +18,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         match goal.param_env.reveal() {\n             Reveal::UserFacing => match self.solver_mode() {\n                 SolverMode::Normal => {\n+                    let Some(opaque_ty_def_id) = opaque_ty.def_id.as_local() else {\n+                        return Err(NoSolution);\n+                    };\n+                    let opaque_ty =\n+                        ty::OpaqueTypeKey { def_id: opaque_ty_def_id, substs: opaque_ty.substs };\n                     // FIXME: at some point we should call queries without defining\n                     // new opaque types but having the existing opaque type definitions.\n                     // This will require moving this below \"Prefer opaques registered already\".\n-                    if !self.can_define_opaque_ty(opaque_ty.def_id) {\n+                    if !self.can_define_opaque_ty(opaque_ty_def_id) {\n                         return Err(NoSolution);\n                     }\n                     // FIXME: This may have issues when the substs contain aliases...\n@@ -47,8 +52,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                         }\n                     }\n                     // Otherwise, define a new opaque type\n-                    let opaque_ty = tcx.mk_opaque(opaque_ty.def_id, opaque_ty.substs);\n-                    self.register_opaque_ty(expected, opaque_ty, goal.param_env)?;\n+                    self.register_opaque_ty(opaque_ty, expected, goal.param_env)?;\n                     self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 SolverMode::Coherence => {"}]}