{"sha": "681d97f19c118696765a70d64834aa9178c8af5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MWQ5N2YxOWMxMTg2OTY3NjVhNzBkNjQ4MzRhYTkxNzhjOGFmNWM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2017-05-30T12:37:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-30T12:37:19Z"}, "message": "Syntax highlight all rust code in librustc/traits/README.md\n\nAlso replace `...` with `/*...*/`", "tree": {"sha": "deeedfeee1bd5e09f7c5a3162ea286ded525e762", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deeedfeee1bd5e09f7c5a3162ea286ded525e762"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/681d97f19c118696765a70d64834aa9178c8af5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/681d97f19c118696765a70d64834aa9178c8af5c", "html_url": "https://github.com/rust-lang/rust/commit/681d97f19c118696765a70d64834aa9178c8af5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/681d97f19c118696765a70d64834aa9178c8af5c/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1fe1a8933c5d13da9fcde618c074c0d4e099b96", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1fe1a8933c5d13da9fcde618c074c0d4e099b96", "html_url": "https://github.com/rust-lang/rust/commit/e1fe1a8933c5d13da9fcde618c074c0d4e099b96"}], "stats": {"total": 50, "additions": 31, "deletions": 19}, "files": [{"sha": "fa7f5c08608bb6486aa3b0e9444c8eeca9b6a885", "filename": "src/librustc/traits/README.md", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/681d97f19c118696765a70d64834aa9178c8af5c/src%2Flibrustc%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/681d97f19c118696765a70d64834aa9178c8af5c/src%2Flibrustc%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2FREADME.md?ref=681d97f19c118696765a70d64834aa9178c8af5c", "patch": "@@ -8,11 +8,15 @@ things.\n Trait resolution is the process of pairing up an impl with each\n reference to a trait. So, for example, if there is a generic function like:\n \n-    fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { ... }\n+```rust\n+fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { /*...*/ }\n+```\n \n and then a call to that function:\n \n-    let v: Vec<isize> = clone_slice([1, 2, 3])\n+```rust\n+let v: Vec<isize> = clone_slice(&[1, 2, 3])\n+```\n \n it is the job of trait resolution to figure out (in which case)\n whether there exists an impl of `isize : Clone`\n@@ -21,12 +25,14 @@ Note that in some cases, like generic functions, we may not be able to\n find a specific impl, but we can figure out that the caller must\n provide an impl. To see what I mean, consider the body of `clone_slice`:\n \n-    fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n-        let mut v = Vec::new();\n-        for e in &x {\n-            v.push((*e).clone()); // (*)\n-        }\n+```rust\n+fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n+    let mut v = Vec::new();\n+    for e in &x {\n+        v.push((*e).clone()); // (*)\n     }\n+}\n+```\n \n The line marked `(*)` is only legal if `T` (the type of `*e`)\n implements the `Clone` trait. Naturally, since we don't know what `T`\n@@ -107,7 +113,7 @@ otherwise the result is considered ambiguous.\n This process is easier if we work through some examples. Consider\n the following trait:\n \n-```\n+```rust\n trait Convert<Target> {\n     fn convert(&self) -> Target;\n }\n@@ -119,8 +125,8 @@ wanted to permit conversion between `isize` and `usize`, we might\n implement `Convert` like so:\n \n ```rust\n-impl Convert<usize> for isize { ... } // isize -> usize\n-impl Convert<isize> for usize { ... } // usize -> isize\n+impl Convert<usize> for isize { /*...*/ } // isize -> usize\n+impl Convert<isize> for usize { /*...*/ } // usize -> isize\n ```\n \n Now imagine there is some code like the following:\n@@ -205,12 +211,14 @@ using the definition of *matching* given above.\n \n Consider this simple example:\n \n-     trait A1 { ... }\n-     trait A2 : A1 { ... }\n+```rust\n+trait A1 { /*...*/ }\n+trait A2 : A1 { /*...*/ }\n \n-     trait B { ... }\n+trait B { /*...*/ }\n \n-     fn foo<X:A2+B> { ... }\n+fn foo<X:A2+B> { /*...*/ }\n+```\n \n Clearly we can use methods offered by `A1`, `A2`, or `B` within the\n body of `foo`. In each case, that will incur an obligation like `X :\n@@ -247,10 +255,12 @@ to us, so we must run trait selection to figure everything out.\n \n Here is an example:\n \n-    trait Foo { ... }\n-    impl<U,T:Bar<U>> Foo for Vec<T> { ... }\n+```rust\n+trait Foo { /*...*/ }\n+impl<U,T:Bar<U>> Foo for Vec<T> { /*...*/ }\n \n-    impl Bar<usize> for isize { ... }\n+impl Bar<usize> for isize { /*...*/ }\n+```\n \n After one shallow round of selection for an obligation like `Vec<isize>\n : Foo`, we would know which impl we want, and we would know that\n@@ -343,7 +353,7 @@ Once the basic matching is done, we get to another interesting topic:\n how to deal with impl obligations. I'll work through a simple example\n here. Imagine we have the traits `Foo` and `Bar` and an associated impl:\n \n-```\n+```rust\n trait Foo<X> {\n     fn foo(&self, x: X) { }\n }\n@@ -401,7 +411,9 @@ Therefore, we search through impls and where clauses and so forth, and\n we come to the conclusion that the only possible impl is this one,\n with def-id 22:\n \n-    impl Foo<isize> for usize { ... } // Impl #22\n+```rust\n+impl Foo<isize> for usize { ... } // Impl #22\n+```\n \n We would then record in the cache `usize : Foo<%0> ==>\n ImplCandidate(22)`. Next we would confirm `ImplCandidate(22)`, which"}]}