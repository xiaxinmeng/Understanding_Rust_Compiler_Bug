{"sha": "8e15985827ebf0ebf084efeb3d17a8cd25e99242", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMTU5ODU4MjdlYmYwZWJmMDg0ZWZlYjNkMTdhOGNkMjVlOTkyNDI=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-02-04T15:10:59Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-02-06T18:13:46Z"}, "message": "Rewrite suggestion generation of needless_continue", "tree": {"sha": "18d8959ed9851707403cb0a503a5cfd6df49288b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18d8959ed9851707403cb0a503a5cfd6df49288b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e15985827ebf0ebf084efeb3d17a8cd25e99242", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl48V1oACgkQaTCGhp1Q\nZjdVoxAAiDWFvSlvMT6LpwKpClsRtTS53D92+iVS0wf4kNldq9+JumN/CEUUb/oI\nP4lVhe3yYtIU64nE8SDUpr1tUlpsDrCWGe547WBgd4cqUOCsJRADK9q+w3AC4xC+\nk1MpXNDvZrHrQj3fz21tp6KkNEls/6rEaLxqN4p1wRc64LAR+hTNqk1EG/r30ZWI\nbI9iEBoJXO7YLvz+eraYCixle6mqi+ZofXlMwbWEQzVuqg129w1KeWJiLhAM/hb8\nshJEB1lQDqw7kzeBu4dm025Oxcg/sL/x5yTvlu7i5us+xYnmDGEZJSlbxTynxCNt\nhUnspbhcs+TICjxBubu1GqTqAcYH793TH+BYRkfU4dlhWW/j89ofXscpUl5+dlVl\nzkJNXnQaXIq7xNt/w0kBqlwu+I73I/tf4L07m96LHAzOd0kBI6oCb4nKToE1KGHk\nRQohFNeJ0BB86/pHAxfY0ohS6mVd+hcYbI9LJsBlKApZF2D4HEmtp/tkahi5jxdP\nhsyMhmsrLiRp+Duy5eQZo2qg4lvC+dab7NNWtsO4tizqm6OsROm1FKWhqXY/EUl0\n1SbXdawBM+yX0VI/TDUuxUobDxc9qmAdnaXXVfKXK1m1BJt1Awj6oMfOJms49tVC\n8M4CuaXVfotpnrKCBI+eIn36Ww5X8fM0YOQQdamAKEkqTXuLylI=\n=og11\n-----END PGP SIGNATURE-----", "payload": "tree 18d8959ed9851707403cb0a503a5cfd6df49288b\nparent 10cd1662c145a52ca6fe5d5e86ee117652598bc2\nauthor flip1995 <hello@philkrones.com> 1580829059 +0100\ncommitter flip1995 <hello@philkrones.com> 1581012826 +0100\n\nRewrite suggestion generation of needless_continue\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e15985827ebf0ebf084efeb3d17a8cd25e99242", "html_url": "https://github.com/rust-lang/rust/commit/8e15985827ebf0ebf084efeb3d17a8cd25e99242", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e15985827ebf0ebf084efeb3d17a8cd25e99242/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10cd1662c145a52ca6fe5d5e86ee117652598bc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/10cd1662c145a52ca6fe5d5e86ee117652598bc2", "html_url": "https://github.com/rust-lang/rust/commit/10cd1662c145a52ca6fe5d5e86ee117652598bc2"}], "stats": {"total": 250, "additions": 84, "deletions": 166}, "files": [{"sha": "75cbfe13072e275170e30d15b0f2bc5dc4f00b09", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 84, "deletions": 79, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/8e15985827ebf0ebf084efeb3d17a8cd25e99242/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e15985827ebf0ebf084efeb3d17a8cd25e99242/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=8e15985827ebf0ebf084efeb3d17a8cd25e99242", "patch": "@@ -36,10 +36,10 @@\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{original_sp, DUMMY_SP};\n-use std::borrow::Cow;\n+use rustc_span::Span;\n use syntax::ast;\n \n-use crate::utils::{snippet, snippet_block, span_lint_and_help, trim_multiline};\n+use crate::utils::{indent_of, snippet, snippet_block, span_lint_and_help};\n \n declare_clippy_lint! {\n     /// **What it does:** The lint checks for `if`-statements appearing in loops\n@@ -273,90 +273,93 @@ struct LintData<'a> {\n     block_stmts: &'a [ast::Stmt],\n }\n \n-const MSG_REDUNDANT_ELSE_BLOCK: &str = \"This `else` block is redundant.\\n\";\n+const MSG_REDUNDANT_ELSE_BLOCK: &str = \"this `else` block is redundant\";\n \n-const MSG_ELSE_BLOCK_NOT_NEEDED: &str = \"There is no need for an explicit `else` block for this `if` \\\n-                                         expression\\n\";\n+const MSG_ELSE_BLOCK_NOT_NEEDED: &str = \"there is no need for an explicit `else` block for this `if` \\\n+                                         expression\";\n \n-const DROP_ELSE_BLOCK_AND_MERGE_MSG: &str = \"Consider dropping the `else` clause and merging the code that \\\n-                                             follows (in the loop) with the `if` block, like so:\\n\";\n+const DROP_ELSE_BLOCK_AND_MERGE_MSG: &str = \"consider dropping the `else` clause and merging the code that \\\n+                                             follows (in the loop) with the `if` block\";\n \n-const DROP_ELSE_BLOCK_MSG: &str = \"Consider dropping the `else` clause, and moving out the code in the `else` \\\n-                                   block, like so:\\n\";\n+const DROP_ELSE_BLOCK_MSG: &str = \"consider dropping the `else` clause\";\n \n fn emit_warning<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str, typ: LintType) {\n     // snip    is the whole *help* message that appears after the warning.\n     // message is the warning message.\n     // expr    is the expression which the lint warning message refers to.\n     let (snip, message, expr) = match typ {\n         LintType::ContinueInsideElseBlock => (\n-            suggestion_snippet_for_continue_inside_else(ctx, data, header),\n+            suggestion_snippet_for_continue_inside_else(ctx, data),\n             MSG_REDUNDANT_ELSE_BLOCK,\n             data.else_expr,\n         ),\n         LintType::ContinueInsideThenBlock => (\n-            suggestion_snippet_for_continue_inside_if(ctx, data, header),\n+            suggestion_snippet_for_continue_inside_if(ctx, data),\n             MSG_ELSE_BLOCK_NOT_NEEDED,\n             data.if_expr,\n         ),\n     };\n-    span_lint_and_help(ctx, NEEDLESS_CONTINUE, expr.span, message, &snip);\n+    span_lint_and_help(\n+        ctx,\n+        NEEDLESS_CONTINUE,\n+        expr.span,\n+        message,\n+        &format!(\"{}\\n{}\", header, snip),\n+    );\n }\n \n-fn suggestion_snippet_for_continue_inside_if<'a>(\n-    ctx: &EarlyContext<'_>,\n-    data: &'a LintData<'_>,\n-    header: &str,\n-) -> String {\n+fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n \n-    let if_code = format!(\"if {} {{\\n    continue;\\n}}\\n\", cond_code);\n-    /* ^^^^--- Four spaces of indentation. */\n+    let continue_code = snippet_block(ctx, data.if_block.span, \"..\", Some(data.if_expr.span));\n     // region B\n-    let else_code = snippet(ctx, data.else_expr.span, \"..\").into_owned();\n-    let else_code = erode_block(&else_code);\n-    let else_code = trim_multiline(Cow::from(else_code), false);\n+    let else_code = snippet_block(ctx, data.else_expr.span, \"..\", Some(data.if_expr.span));\n \n-    let mut ret = String::from(header);\n-    ret.push_str(&if_code);\n-    ret.push_str(&else_code);\n-    ret.push_str(\"\\n...\");\n-    ret\n+    let indent_if = indent_of(ctx, data.if_expr.span).unwrap_or(0);\n+    format!(\n+        \"{}if {} {} {}\",\n+        \" \".repeat(indent_if),\n+        cond_code,\n+        continue_code,\n+        else_code,\n+    )\n }\n \n-fn suggestion_snippet_for_continue_inside_else<'a>(\n-    ctx: &EarlyContext<'_>,\n-    data: &'a LintData<'_>,\n-    header: &str,\n-) -> String {\n+fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n-    let mut if_code = format!(\"if {} {{\\n\", cond_code);\n \n     // Region B\n-    let block_code = &snippet(ctx, data.if_block.span, \"..\").into_owned();\n-    let block_code = erode_block(block_code);\n-    let block_code = trim_multiline(Cow::from(block_code), false);\n-\n-    if_code.push_str(&block_code);\n+    let block_code = erode_from_back(&snippet_block(ctx, data.if_block.span, \"..\", Some(data.if_expr.span)));\n \n     // Region C\n     // These is the code in the loop block that follows the if/else construction\n     // we are complaining about. We want to pull all of this code into the\n     // `then` block of the `if` statement.\n+    let indent = span_of_first_expr_in_block(data.if_block)\n+        .and_then(|span| indent_of(ctx, span))\n+        .unwrap_or(0);\n     let to_annex = data.block_stmts[data.stmt_idx + 1..]\n         .iter()\n         .map(|stmt| original_sp(stmt.span, DUMMY_SP))\n-        .map(|span| snippet_block(ctx, span, \"..\").into_owned())\n+        .map(|span| {\n+            let snip = snippet_block(ctx, span, \"..\", None).into_owned();\n+            snip.lines()\n+                .map(|line| format!(\"{}{}\", \" \".repeat(indent), line))\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\")\n+        })\n         .collect::<Vec<_>>()\n         .join(\"\\n\");\n \n-    let mut ret = String::from(header);\n-\n-    ret.push_str(&if_code);\n-    ret.push_str(\"\\n// Merged code follows...\");\n-    ret.push_str(&to_annex);\n-    ret.push_str(\"\\n}\\n\");\n-    ret\n+    let indent_if = indent_of(ctx, data.if_expr.span).unwrap_or(0);\n+    format!(\n+        \"{indent_if}if {} {}\\n{indent}// merged code follows:\\n{}\\n{indent_if}}}\",\n+        cond_code,\n+        block_code,\n+        to_annex,\n+        indent = \" \".repeat(indent),\n+        indent_if = \" \".repeat(indent_if),\n+    )\n }\n \n fn check_and_warn<'a>(ctx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n@@ -406,7 +409,7 @@ fn check_and_warn<'a>(ctx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n /// NOTE: when there is no closing brace in `s`, `s` is _not_ preserved, i.e.,\n /// an empty string will be returned in that case.\n #[must_use]\n-pub fn erode_from_back(s: &str) -> String {\n+fn erode_from_back(s: &str) -> String {\n     let mut ret = String::from(s);\n     while ret.pop().map_or(false, |c| c != '}') {}\n     while let Some(c) = ret.pop() {\n@@ -418,38 +421,40 @@ pub fn erode_from_back(s: &str) -> String {\n     ret\n }\n \n-/// Eats at `s` from the front by first skipping all leading whitespace. Then,\n-/// any number of opening braces are eaten, followed by any number of newlines.\n-/// e.g.,  the string\n-///\n-/// ```ignore\n-///         {\n-///             something();\n-///             inside_a_block();\n-///         }\n-/// ```\n-///\n-/// is transformed to\n-///\n-/// ```ignore\n-///             something();\n-///             inside_a_block();\n-///         }\n-/// ```\n-#[must_use]\n-pub fn erode_from_front(s: &str) -> String {\n-    s.chars()\n-        .skip_while(|c| c.is_whitespace())\n-        .skip_while(|c| *c == '{')\n-        .skip_while(|c| *c == '\\n')\n-        .collect::<String>()\n+fn span_of_first_expr_in_block(block: &ast::Block) -> Option<Span> {\n+    block.stmts.iter().next().map(|stmt| stmt.span)\n }\n \n-/// If `s` contains the code for a block, delimited by braces, this function\n-/// tries to get the contents of the block. If there is no closing brace\n-/// present,\n-/// an empty string is returned.\n-#[must_use]\n-pub fn erode_block(s: &str) -> String {\n-    erode_from_back(&erode_from_front(s))\n+#[cfg(test)]\n+mod test {\n+    use super::erode_from_back;\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_erode_from_back() {\n+        let input = \"\\\n+{\n+    let x = 5;\n+    let y = format!(\\\"{}\\\", 42);\n+}\";\n+\n+        let expected = \"\\\n+{\n+    let x = 5;\n+    let y = format!(\\\"{}\\\", 42);\";\n+\n+        let got = erode_from_back(input);\n+        assert_eq!(expected, got);\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_erode_from_back_no_brace() {\n+        let input = \"\\\n+let x = 5;\n+let y = something();\n+\";\n+        let expected = \"\";\n+        let got = erode_from_back(input);\n+        assert_eq!(expected, got);\n+    }\n }"}, {"sha": "255653b4737d3453ec371d76c8c6482deea897e4", "filename": "tests/needless_continue_helpers.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/10cd1662c145a52ca6fe5d5e86ee117652598bc2/tests%2Fneedless_continue_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10cd1662c145a52ca6fe5d5e86ee117652598bc2/tests%2Fneedless_continue_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fneedless_continue_helpers.rs?ref=10cd1662c145a52ca6fe5d5e86ee117652598bc2", "patch": "@@ -1,87 +0,0 @@\n-// Tests for the various helper functions used by the needless_continue\n-// lint that don't belong in utils.\n-\n-use clippy_lints::needless_continue::{erode_block, erode_from_back, erode_from_front};\n-\n-#[test]\n-#[rustfmt::skip]\n-fn test_erode_from_back() {\n-    let input = \"\\\n-{\n-    let x = 5;\n-    let y = format!(\\\"{}\\\", 42);\n-}\";\n-\n-    let expected = \"\\\n-{\n-    let x = 5;\n-    let y = format!(\\\"{}\\\", 42);\";\n-\n-    let got = erode_from_back(input);\n-    assert_eq!(expected, got);\n-}\n-\n-#[test]\n-#[rustfmt::skip]\n-fn test_erode_from_back_no_brace() {\n-    let input = \"\\\n-let x = 5;\n-let y = something();\n-\";\n-    let expected = \"\";\n-    let got = erode_from_back(input);\n-    assert_eq!(expected, got);\n-}\n-\n-#[test]\n-#[rustfmt::skip]\n-fn test_erode_from_front() {\n-    let input = \"\n-        {\n-            something();\n-            inside_a_block();\n-        }\n-    \";\n-    let expected =\n-\"            something();\n-            inside_a_block();\n-        }\n-    \";\n-    let got = erode_from_front(input);\n-    println!(\"input: {}\\nexpected:\\n{}\\ngot:\\n{}\", input, expected, got);\n-    assert_eq!(expected, got);\n-}\n-\n-#[test]\n-#[rustfmt::skip]\n-fn test_erode_from_front_no_brace() {\n-    let input = \"\n-            something();\n-            inside_a_block();\n-    \";\n-    let expected =\n-\"something();\n-            inside_a_block();\n-    \";\n-    let got = erode_from_front(input);\n-    println!(\"input: {}\\nexpected:\\n{}\\ngot:\\n{}\", input, expected, got);\n-    assert_eq!(expected, got);\n-}\n-\n-#[test]\n-#[rustfmt::skip]\n-fn test_erode_block() {\n-\n-    let input = \"\n-        {\n-            something();\n-            inside_a_block();\n-        }\n-    \";\n-    let expected =\n-\"            something();\n-            inside_a_block();\";\n-    let got = erode_block(input);\n-    println!(\"input: {}\\nexpected:\\n{}\\ngot:\\n{}\", input, expected, got);\n-    assert_eq!(expected, got);\n-}"}]}