{"sha": "370fd8c1b7da4db2570059416a544633fae0eecb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3MGZkOGMxYjdkYTRkYjI1NzAwNTk0MTZhNTQ0NjMzZmFlMGVlY2I=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-03T17:58:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-03T17:58:33Z"}, "message": "Rollup merge of #68787 - amosonn:patch-1, r=nagisa\n\nOptimize core::ptr::align_offset (part 1)\n\nr? @nagisa\nSee #68616 for main discussion.", "tree": {"sha": "0887ac78fd154479017cb04d788f0c0822c845e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0887ac78fd154479017cb04d788f0c0822c845e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/370fd8c1b7da4db2570059416a544633fae0eecb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeOF9JCRBK7hj4Ov3rIwAAdHIIAC8ltzdYI+rJgJig4nBUnJZj\n7PBasID0WMO9/VCdJL2dMgPZ8olEFetEIme8jL8MwNfwdBZyUNVaaxv7syyqCLLU\nJDknzcXKJ/nvt5FVphDZ/Umn1YvwdttxvXUwjwDgX0hWSSjKLlfmB/8rjob/2EaJ\nl07nwJma86I1X8lDye4215QvJjuzPDOg35u/qV2yoGkl4C6LalI7UqTNIn99KcGj\ncvpzkdHQHvkzfpJR41tFxIW+MX3chkUqe1UhFp7uAGZtP8x51tIEou6Ih1k+xrmJ\nfHUMXJPifKcIJMGQ5AsJqknUR1VCjE99iyeD7Jqq52MujFv/BcNk0boQYVoJd9U=\n=WT5+\n-----END PGP SIGNATURE-----\n", "payload": "tree 0887ac78fd154479017cb04d788f0c0822c845e0\nparent 51c6c2557584bbf64c0c8e7650596eccf7c1e222\nparent 22b263ae1837ab6a64fe4bcdbfa07aa8883f57db\nauthor Dylan DPC <dylan.dpc@gmail.com> 1580752713 +0100\ncommitter GitHub <noreply@github.com> 1580752713 +0100\n\nRollup merge of #68787 - amosonn:patch-1, r=nagisa\n\nOptimize core::ptr::align_offset (part 1)\n\nr? @nagisa\nSee #68616 for main discussion.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/370fd8c1b7da4db2570059416a544633fae0eecb", "html_url": "https://github.com/rust-lang/rust/commit/370fd8c1b7da4db2570059416a544633fae0eecb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/370fd8c1b7da4db2570059416a544633fae0eecb/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51c6c2557584bbf64c0c8e7650596eccf7c1e222", "url": "https://api.github.com/repos/rust-lang/rust/commits/51c6c2557584bbf64c0c8e7650596eccf7c1e222", "html_url": "https://github.com/rust-lang/rust/commit/51c6c2557584bbf64c0c8e7650596eccf7c1e222"}, {"sha": "22b263ae1837ab6a64fe4bcdbfa07aa8883f57db", "url": "https://api.github.com/repos/rust-lang/rust/commits/22b263ae1837ab6a64fe4bcdbfa07aa8883f57db", "html_url": "https://github.com/rust-lang/rust/commit/22b263ae1837ab6a64fe4bcdbfa07aa8883f57db"}], "stats": {"total": 38, "additions": 22, "deletions": 16}, "files": [{"sha": "0ee50966f968c70cbfb876cada69aa2cf26bd6aa", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/370fd8c1b7da4db2570059416a544633fae0eecb/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/370fd8c1b7da4db2570059416a544633fae0eecb/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=370fd8c1b7da4db2570059416a544633fae0eecb", "patch": "@@ -1081,9 +1081,8 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n                 // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n                 // usize::max_value()` instead, because we take the result `mod n` at the end\n                 // anyway.\n-                inverse = inverse.wrapping_mul(2usize.wrapping_sub(x.wrapping_mul(inverse)))\n-                    & (going_mod - 1);\n-                if going_mod > m {\n+                inverse = inverse.wrapping_mul(2usize.wrapping_sub(x.wrapping_mul(inverse)));\n+                if going_mod >= m {\n                     return inverse & (m - 1);\n                 }\n                 going_mod = going_mod.wrapping_mul(going_mod);\n@@ -1115,26 +1114,33 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n     let gcd = 1usize << gcdpow;\n \n-    if p as usize & (gcd - 1) == 0 {\n+    if p as usize & (gcd.wrapping_sub(1)) == 0 {\n         // This branch solves for the following linear congruence equation:\n         //\n-        // $$ p + so \u2261 0 mod a $$\n+        // ` p + so = 0 mod a `\n         //\n-        // $p$ here is the pointer value, $s$ \u2013 stride of `T`, $o$ offset in `T`s, and $a$ \u2013 the\n+        // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n         // requested alignment.\n         //\n-        // g = gcd(a, s)\n-        // o = (a - (p mod a))/g * ((s/g)\u207b\u00b9 mod a)\n+        // With `g = gcd(a, s)`, and the above asserting that `p` is also divisible by `g`, we can\n+        // denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n         //\n-        // The first term is \u201cthe relative alignment of p to a\u201d, the second term is \u201chow does\n-        // incrementing p by s bytes change the relative alignment of p\u201d. Division by `g` is\n-        // necessary to make this equation well formed if $a$ and $s$ are not co-prime.\n+        // ` p' + s'o = 0 mod a' `\n+        // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n         //\n-        // Furthermore, the result produced by this solution is not \u201cminimal\u201d, so it is necessary\n-        // to take the result $o mod lcm(s, a)$. We can replace $lcm(s, a)$ with just a $a / g$.\n-        let j = a.wrapping_sub(pmoda) >> gcdpow;\n-        let k = smoda >> gcdpow;\n-        return intrinsics::unchecked_rem(j.wrapping_mul(mod_inv(k, a)), a >> gcdpow);\n+        // The first term is \"the relative alignment of `p` to `a`\" (divided by the `g`), the second\n+        // term is \"how does incrementing `p` by `s` bytes change the relative alignment of `p`\" (again\n+        // divided by `g`).\n+        // Division by `g` is necessary to make the inverse well formed if `a` and `s` are not\n+        // co-prime.\n+        //\n+        // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n+        // to take the result `o mod lcm(s, a)`. We can replace `lcm(s, a)` with just a `a'`.\n+        let a2 = a >> gcdpow;\n+        let a2minus1 = a2.wrapping_sub(1);\n+        let s2 = smoda >> gcdpow;\n+        let minusp2 = a2.wrapping_sub(pmoda >> gcdpow);\n+        return (minusp2.wrapping_mul(mod_inv(s2, a2))) & a2minus1;\n     }\n \n     // Cannot be aligned at all."}]}