{"sha": "3cca3c6acef10201c6ff419979620ed8132a3965", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjY2EzYzZhY2VmMTAyMDFjNmZmNDE5OTc5NjIwZWQ4MTMyYTM5NjU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-31T18:19:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-31T18:19:38Z"}, "message": "Rollup merge of #67744 - Centril:reduce-diversity, r=petrochenkov\n\nparser: reduce diversity in error handling mechanisms\n\nInstead of having e.g. `span_err`, `fatal`, etc., we prefer to move towards uniformly using `struct_span_err` thus making it harder to emit fatal and/or unstructured diagnostics.\n\nThis PR also de-fatalizes some diagnostics.\n\nr? @estebank", "tree": {"sha": "44cab948bf6c0ab0b991c99bf3894f60d3f7f539", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44cab948bf6c0ab0b991c99bf3894f60d3f7f539"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cca3c6acef10201c6ff419979620ed8132a3965", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeC5E6CRBK7hj4Ov3rIwAAdHIIAK54Ez0/stULTfQLRb/chHo2\nx6fij9wR3try+HtlqJ34dUImXaYppnn34EP52znFdTmxaF1HDKF2UpLKqw4Ci6hU\nM802geB7SUWC4H4wbew6M4jns099xnVemKdMx5hjHarHlIQMLAYcZ2tHeCvzk4Iv\nYItllFfPpooOPk3RtQqVU2/PxYcYjg+6vSQuNezcoddYURAuNtRdU+skEVIF3mBV\nqZAgr7Cj49c3KhpQr0eU78U90JfgYvao0XaIHIxfvPlu/owrmrQyxvxrFEKWcL75\nvpZ72vd4Gli0VHp/IvWgJoapnZCPb26HcfMCDb1CF8MHVRp9sEJrRwnSk1h1gSM=\n=IqDy\n-----END PGP SIGNATURE-----\n", "payload": "tree 44cab948bf6c0ab0b991c99bf3894f60d3f7f539\nparent 50fb8480dbe65b14b48502c937eea66c4b5a6c31\nparent 2e7806146c008742919124bf6ac9a37c3ece51bb\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1577816378 +0100\ncommitter GitHub <noreply@github.com> 1577816378 +0100\n\nRollup merge of #67744 - Centril:reduce-diversity, r=petrochenkov\n\nparser: reduce diversity in error handling mechanisms\n\nInstead of having e.g. `span_err`, `fatal`, etc., we prefer to move towards uniformly using `struct_span_err` thus making it harder to emit fatal and/or unstructured diagnostics.\n\nThis PR also de-fatalizes some diagnostics.\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cca3c6acef10201c6ff419979620ed8132a3965", "html_url": "https://github.com/rust-lang/rust/commit/3cca3c6acef10201c6ff419979620ed8132a3965", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cca3c6acef10201c6ff419979620ed8132a3965/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50fb8480dbe65b14b48502c937eea66c4b5a6c31", "url": "https://api.github.com/repos/rust-lang/rust/commits/50fb8480dbe65b14b48502c937eea66c4b5a6c31", "html_url": "https://github.com/rust-lang/rust/commit/50fb8480dbe65b14b48502c937eea66c4b5a6c31"}, {"sha": "2e7806146c008742919124bf6ac9a37c3ece51bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e7806146c008742919124bf6ac9a37c3ece51bb", "html_url": "https://github.com/rust-lang/rust/commit/2e7806146c008742919124bf6ac9a37c3ece51bb"}], "stats": {"total": 289, "additions": 147, "deletions": 142}, "files": [{"sha": "37374d707192772140b0c4ab3ac055f84f264863", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -890,12 +890,12 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n     Ok(match name {\n         sym::item => match p.parse_item()? {\n             Some(i) => token::NtItem(i),\n-            None => return Err(p.fatal(\"expected an item keyword\")),\n+            None => return Err(p.struct_span_err(p.token.span, \"expected an item keyword\")),\n         },\n         sym::block => token::NtBlock(p.parse_block()?),\n         sym::stmt => match p.parse_stmt()? {\n             Some(s) => token::NtStmt(s),\n-            None => return Err(p.fatal(\"expected a statement\")),\n+            None => return Err(p.struct_span_err(p.token.span, \"expected a statement\")),\n         },\n         sym::pat => token::NtPat(p.parse_pat(None)?),\n         sym::expr => token::NtExpr(p.parse_expr()?),\n@@ -909,7 +909,8 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n                 token::NtIdent(Ident::new(name, span), is_raw)\n             } else {\n                 let token_str = pprust::token_to_string(&p.token);\n-                return Err(p.fatal(&format!(\"expected ident, found {}\", &token_str)));\n+                let msg = &format!(\"expected ident, found {}\", &token_str);\n+                return Err(p.struct_span_err(p.token.span, msg));\n             }\n         }\n         sym::path => token::NtPath(p.parse_path(PathStyle::Type)?),\n@@ -920,7 +921,8 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n                 token::NtLifetime(p.expect_lifetime().ident)\n             } else {\n                 let token_str = pprust::token_to_string(&p.token);\n-                return Err(p.fatal(&format!(\"expected a lifetime, found `{}`\", &token_str)));\n+                let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n+                return Err(p.struct_span_err(p.token.span, msg));\n             }\n         }\n         // this is not supposed to happen, since it has been checked"}, {"sha": "26df4f1c090d65ccc347eef23fdb23d6501b9933", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -46,7 +46,8 @@ impl<'a> Parser<'a> {\n                 token::DocComment(s) => {\n                     let attr = self.mk_doc_comment(s);\n                     if attr.style != ast::AttrStyle::Outer {\n-                        let mut err = self.fatal(\"expected outer doc comment\");\n+                        let span = self.token.span;\n+                        let mut err = self.struct_span_err(span, \"expected outer doc comment\");\n                         err.note(\n                             \"inner doc comments like this (starting with \\\n                                   `//!` or `/*!`) can only appear before items\",\n@@ -133,7 +134,7 @@ impl<'a> Parser<'a> {\n                             \"previous outer attribute\"\n                         };\n \n-                        let mut diagnostic = self.diagnostic().struct_span_err(attr_sp, reason);\n+                        let mut diagnostic = self.struct_span_err(attr_sp, reason);\n \n                         if let Some(prev_attr_sp) = prev_attr_sp {\n                             diagnostic\n@@ -156,7 +157,8 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 let token_str = pprust::token_to_string(&self.token);\n-                return Err(self.fatal(&format!(\"expected `#`, found `{}`\", token_str)));\n+                let msg = &format!(\"expected `#`, found `{}`\", token_str);\n+                return Err(self.struct_span_err(self.token.span, msg));\n             }\n         };\n \n@@ -231,8 +233,7 @@ impl<'a> Parser<'a> {\n \n         if !lit.kind.is_unsuffixed() {\n             let msg = \"suffixed literals are not allowed in attributes\";\n-            self.diagnostic()\n-                .struct_span_err(lit.span, msg)\n+            self.struct_span_err(lit.span, msg)\n                 .help(\n                     \"instead of using a suffixed literal \\\n                                     (1u8, 1.0f32, etc.), use an unsuffixed version \\\n@@ -332,6 +333,6 @@ impl<'a> Parser<'a> {\n \n         let found = pprust::token_to_string(&self.token);\n         let msg = format!(\"expected unsuffixed literal or identifier, found `{}`\", found);\n-        Err(self.diagnostic().struct_span_err(self.token.span, &msg))\n+        Err(self.struct_span_err(self.token.span, &msg))\n     }\n }"}, {"sha": "05754357bc82210c0dde8e7deb9db4abf1bbd657", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -157,14 +157,6 @@ crate enum ConsumeClosingDelim {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n-        self.span_fatal(self.token.span, m)\n-    }\n-\n-    crate fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n-        self.sess.span_diagnostic.struct_span_fatal(sp, m)\n-    }\n-\n     pub(super) fn span_fatal_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -173,14 +165,6 @@ impl<'a> Parser<'a> {\n         err.span_err(sp, self.diagnostic())\n     }\n \n-    pub(super) fn bug(&self, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_bug(self.token.span, m)\n-    }\n-\n-    pub(super) fn span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) {\n-        self.sess.span_diagnostic.span_err(sp, m)\n-    }\n-\n     pub fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n         self.sess.span_diagnostic.struct_span_err(sp, m)\n     }\n@@ -298,7 +282,7 @@ impl<'a> Parser<'a> {\n             )\n         };\n         self.last_unexpected_token_span = Some(self.token.span);\n-        let mut err = self.fatal(&msg_exp);\n+        let mut err = self.struct_span_err(self.token.span, &msg_exp);\n         let sp = if self.token == token::Eof {\n             // This is EOF; don't want to point at the following char, but rather the last token.\n             self.prev_span\n@@ -502,18 +486,17 @@ impl<'a> Parser<'a> {\n             let span = lo.until(self.token.span);\n \n             let total_num_of_gt = number_of_gt + number_of_shr * 2;\n-            self.diagnostic()\n-                .struct_span_err(\n-                    span,\n-                    &format!(\"unmatched angle bracket{}\", pluralize!(total_num_of_gt)),\n-                )\n-                .span_suggestion(\n-                    span,\n-                    &format!(\"remove extra angle bracket{}\", pluralize!(total_num_of_gt)),\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.struct_span_err(\n+                span,\n+                &format!(\"unmatched angle bracket{}\", pluralize!(total_num_of_gt)),\n+            )\n+            .span_suggestion(\n+                span,\n+                &format!(\"remove extra angle bracket{}\", pluralize!(total_num_of_gt)),\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n         }\n     }\n \n@@ -762,8 +745,7 @@ impl<'a> Parser<'a> {\n         path.span = ty_span.to(self.prev_span);\n \n         let ty_str = self.span_to_snippet(ty_span).unwrap_or_else(|_| pprust::ty_to_string(&ty));\n-        self.diagnostic()\n-            .struct_span_err(path.span, \"missing angle brackets in associated item path\")\n+        self.struct_span_err(path.span, \"missing angle brackets in associated item path\")\n             .span_suggestion(\n                 // This is a best-effort recovery.\n                 path.span,\n@@ -1271,7 +1253,8 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn expected_semi_or_open_brace<T>(&mut self) -> PResult<'a, T> {\n         let token_str = super::token_descr(&self.token);\n-        let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\", token_str));\n+        let msg = &format!(\"expected `;` or `{{`, found {}\", token_str);\n+        let mut err = self.struct_span_err(self.token.span, msg);\n         err.span_label(self.token.span, \"expected `;` or `{`\");\n         Err(err)\n     }"}, {"sha": "ab7c156e3706d85fcb30c8badf7380b6720a07be", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -283,7 +283,7 @@ impl<'a> Parser<'a> {\n                     self.mk_expr(span, aopexpr, AttrVec::new())\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n-                    self.bug(\"AssocOp should have been handled by special case\")\n+                    self.span_bug(span, \"AssocOp should have been handled by special case\")\n                 }\n             };\n \n@@ -822,7 +822,11 @@ impl<'a> Parser<'a> {\n         } else {\n             // Field access `expr.f`\n             if let Some(args) = segment.args {\n-                self.span_err(args.span(), \"field expressions may not have generic arguments\");\n+                self.struct_span_err(\n+                    args.span(),\n+                    \"field expressions may not have generic arguments\",\n+                )\n+                .emit();\n             }\n \n             let span = lo.to(self.prev_span);\n@@ -1133,7 +1137,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n         self.parse_opt_lit().ok_or_else(|| {\n             let msg = format!(\"unexpected token: {}\", super::token_descr(&self.token));\n-            self.span_fatal(self.token.span, &msg)\n+            self.struct_span_err(self.token.span, &msg)\n         })\n     }\n \n@@ -1446,9 +1450,7 @@ impl<'a> Parser<'a> {\n         self.struct_span_err(sp, \"missing condition for `if` expression\")\n             .span_label(sp, \"expected if condition here\")\n             .emit();\n-        let expr = self.mk_expr_err(span);\n-        let stmt = self.mk_stmt(span, ast::StmtKind::Expr(expr));\n-        self.mk_block(vec![stmt], BlockCheckMode::Default, span)\n+        self.mk_block_err(span)\n     }\n \n     /// Parses the condition of a `if` or `while` expression.\n@@ -1915,8 +1917,7 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        self.diagnostic()\n-            .struct_span_err(self.token.span, \"expected `:`, found `=`\")\n+        self.struct_span_err(self.token.span, \"expected `:`, found `=`\")\n             .span_suggestion(\n                 field_name.span.shrink_to_hi().to(self.token.span),\n                 \"replace equals symbol with a colon\","}, {"sha": "e5a7361b12ab7bb4021996c79fef3ff039ec1fa8", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -306,8 +306,7 @@ impl<'a> Parser<'a> {\n                 // possible public struct definition where `struct` was forgotten\n                 let ident = self.parse_ident().unwrap();\n                 let msg = format!(\"add `struct` here to parse `{}` as a public struct\", ident);\n-                let mut err =\n-                    self.diagnostic().struct_span_err(sp, \"missing `struct` for struct definition\");\n+                let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n                 err.span_suggestion_short(\n                     sp,\n                     &msg,\n@@ -335,7 +334,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.diagnostic().struct_span_err(sp, &msg);\n+                let mut err = self.struct_span_err(sp, &msg);\n                 if !ambiguous {\n                     self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n                     let suggestion =\n@@ -375,7 +374,7 @@ impl<'a> Parser<'a> {\n                     (\"fn` or `struct\", \"function or struct\", true)\n                 };\n                 let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.diagnostic().struct_span_err(sp, &msg);\n+                let mut err = self.struct_span_err(sp, &msg);\n                 if !ambiguous {\n                     err.span_suggestion_short(\n                         sp,\n@@ -446,9 +445,7 @@ impl<'a> Parser<'a> {\n         // FAILURE TO PARSE ITEM\n         match visibility.node {\n             VisibilityKind::Inherited => {}\n-            _ => {\n-                return Err(self.span_fatal(self.prev_span, \"unmatched visibility `pub`\"));\n-            }\n+            _ => return Err(self.struct_span_err(self.prev_span, \"unmatched visibility `pub`\")),\n         }\n \n         if !attributes_allowed && !attrs.is_empty() {\n@@ -466,7 +463,7 @@ impl<'a> Parser<'a> {\n             _ => \"expected item after attributes\",\n         };\n \n-        let mut err = self.diagnostic().struct_span_err(self.prev_span, message);\n+        let mut err = self.struct_span_err(self.prev_span, message);\n         if attrs.last().unwrap().is_doc_comment() {\n             err.span_label(self.prev_span, \"this doc comment doesn't document anything\");\n         }\n@@ -536,7 +533,6 @@ impl<'a> Parser<'a> {\n         //        ^^ `sp` below will point to this\n         let sp = prev_span.between(self.prev_span);\n         let mut err = self\n-            .diagnostic()\n             .struct_span_err(sp, &format!(\"{} for {}-item declaration\", expected_kinds, item_type));\n         err.span_label(sp, expected_kinds);\n         err\n@@ -619,7 +615,7 @@ impl<'a> Parser<'a> {\n                     // This notably includes paths passed through `ty` macro fragments (#46438).\n                     TyKind::Path(None, path) => path,\n                     _ => {\n-                        self.span_err(ty_first.span, \"expected a trait, found type\");\n+                        self.struct_span_err(ty_first.span, \"expected a trait, found type\").emit();\n                         err_path(ty_first.span)\n                     }\n                 };\n@@ -1349,10 +1345,11 @@ impl<'a> Parser<'a> {\n             body\n         } else {\n             let token_str = super::token_descr(&self.token);\n-            let mut err = self.fatal(&format!(\n+            let msg = &format!(\n                 \"expected `where`, `{{`, `(`, or `;` after struct name, found {}\",\n                 token_str\n-            ));\n+            );\n+            let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n             return Err(err);\n         };\n@@ -1375,8 +1372,8 @@ impl<'a> Parser<'a> {\n             VariantData::Struct(fields, recovered)\n         } else {\n             let token_str = super::token_descr(&self.token);\n-            let mut err = self\n-                .fatal(&format!(\"expected `where` or `{{` after union name, found {}\", token_str));\n+            let msg = &format!(\"expected `where` or `{{` after union name, found {}\", token_str);\n+            let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected `where` or `{` after union name\");\n             return Err(err);\n         };\n@@ -1412,10 +1409,8 @@ impl<'a> Parser<'a> {\n             self.eat(&token::CloseDelim(token::Brace));\n         } else {\n             let token_str = super::token_descr(&self.token);\n-            let mut err = self.fatal(&format!(\n-                \"expected `where`, or `{{` after struct name, found {}\",\n-                token_str\n-            ));\n+            let msg = &format!(\"expected `where`, or `{{` after struct name, found {}\", token_str);\n+            let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected `where`, or `{` after struct name\");\n             return Err(err);\n         }\n@@ -1603,9 +1598,8 @@ impl<'a> Parser<'a> {\n             VisibilityKind::Inherited => {}\n             _ => {\n                 let mut err = if self.token.is_keyword(sym::macro_rules) {\n-                    let mut err = self\n-                        .diagnostic()\n-                        .struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n+                    let mut err =\n+                        self.struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n                     err.span_suggestion(\n                         sp,\n                         \"try exporting the macro\",\n@@ -1614,9 +1608,8 @@ impl<'a> Parser<'a> {\n                     );\n                     err\n                 } else {\n-                    let mut err = self\n-                        .diagnostic()\n-                        .struct_span_err(sp, \"can't qualify macro invocation with `pub`\");\n+                    let mut err =\n+                        self.struct_span_err(sp, \"can't qualify macro invocation with `pub`\");\n                     err.help(\"try adjusting the macro to put `pub` inside the invocation\");\n                     err\n                 };"}, {"sha": "ec6468f4f0a329c81e6b50a94e227124b3d0f58a", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -884,7 +884,8 @@ impl<'a> Parser<'a> {\n     pub fn bump(&mut self) {\n         if self.prev_token_kind == PrevTokenKind::Eof {\n             // Bumping after EOF is a bad sign, usually an infinite loop.\n-            self.bug(\"attempted to bump the parser past EOF (may be stuck in a loop)\");\n+            let msg = \"attempted to bump the parser past EOF (may be stuck in a loop)\";\n+            self.span_bug(self.token.span, msg);\n         }\n \n         self.prev_span = self.meta_var_span.take().unwrap_or(self.token.span);\n@@ -1056,8 +1057,7 @@ impl<'a> Parser<'a> {\n                     _ => unreachable!(),\n                 };\n                 let span = self.prev_span.to(self.token.span);\n-                self.diagnostic()\n-                    .struct_span_fatal(span, &format!(\"unknown macro variable `{}`\", name))\n+                self.struct_span_err(span, &format!(\"unknown macro variable `{}`\", name))\n                     .span_label(span, \"unknown macro variable\")\n                     .emit();\n                 self.bump();"}, {"sha": "84ffa6f7fcd8fddeffec44c835c8e4dc34e2eec3", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -81,7 +81,8 @@ impl<'a> Parser<'a> {\n         if !self.eat(term) {\n             let token_str = super::token_descr(&self.token);\n             if !self.maybe_consume_incorrect_semicolon(&items) {\n-                let mut err = self.fatal(&format!(\"expected item, found {}\", token_str));\n+                let msg = &format!(\"expected item, found {}\", token_str);\n+                let mut err = self.struct_span_err(self.token.span, msg);\n                 err.span_label(self.token.span, \"expected item\");\n                 return Err(err);\n             }\n@@ -129,7 +130,7 @@ impl<'a> Parser<'a> {\n             DirectoryOwnership::UnownedViaBlock => {\n                 let msg = \"Cannot declare a non-inline module inside a block \\\n                     unless it has a path attribute\";\n-                let mut err = self.diagnostic().struct_span_err(id_sp, msg);\n+                let mut err = self.struct_span_err(id_sp, msg);\n                 if paths.path_exists {\n                     let msg = format!(\n                         \"Maybe `use` the module `{}` instead of redeclaring it\",\n@@ -140,9 +141,8 @@ impl<'a> Parser<'a> {\n                 Err(err)\n             }\n             DirectoryOwnership::UnownedViaMod => {\n-                let mut err = self\n-                    .diagnostic()\n-                    .struct_span_err(id_sp, \"cannot declare a new module at this location\");\n+                let mut err =\n+                    self.struct_span_err(id_sp, \"cannot declare a new module at this location\");\n                 if !id_sp.is_dummy() {\n                     let src_path = self.sess.source_map().span_to_filename(id_sp);\n                     if let FileName::Real(src_path) = src_path {\n@@ -263,7 +263,7 @@ impl<'a> Parser<'a> {\n                 err.push_str(\" -> \");\n             }\n             err.push_str(&path.to_string_lossy());\n-            return Err(self.span_fatal(id_sp, &err[..]));\n+            return Err(self.struct_span_err(id_sp, &err[..]));\n         }\n         included_mod_stack.push(path.clone());\n         drop(included_mod_stack);"}, {"sha": "e608b86c76a29447201b8d63d5fc7ce75e3a0779", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -673,7 +673,7 @@ impl<'a> Parser<'a> {\n         let expected = expected.unwrap_or(\"pattern\");\n         let msg = format!(\"expected {}, found {}\", expected, super::token_descr(&self.token));\n \n-        let mut err = self.fatal(&msg);\n+        let mut err = self.struct_span_err(self.token.span, &msg);\n         err.span_label(self.token.span, format!(\"expected {}\", expected));\n \n         let sp = self.sess.source_map().start_point(self.token.span);\n@@ -699,8 +699,7 @@ impl<'a> Parser<'a> {\n         let range_span = lo.to(end.span);\n         let begin = self.mk_expr(range_span, ExprKind::Err, AttrVec::new());\n \n-        self.diagnostic()\n-            .struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n+        self.struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n             .span_suggestion(\n                 range_span,\n                 \"try using the minimum value for the type\",\n@@ -722,18 +721,17 @@ impl<'a> Parser<'a> {\n             // Parsing e.g. `X..`.\n             let range_span = begin.span.to(self.prev_span);\n \n-            self.diagnostic()\n-                .struct_span_err(\n-                    range_span,\n-                    &format!(\"`X{}` range patterns are not supported\", form),\n-                )\n-                .span_suggestion(\n-                    range_span,\n-                    \"try using the maximum value for the type\",\n-                    format!(\"{}{}MAX\", pprust::expr_to_string(&begin), form),\n-                    Applicability::HasPlaceholders,\n-                )\n-                .emit();\n+            self.struct_span_err(\n+                range_span,\n+                &format!(\"`X{}` range patterns are not supported\", form),\n+            )\n+            .span_suggestion(\n+                range_span,\n+                \"try using the maximum value for the type\",\n+                format!(\"{}{}MAX\", pprust::expr_to_string(&begin), form),\n+                Applicability::HasPlaceholders,\n+            )\n+            .emit();\n \n             Ok(self.mk_expr(range_span, ExprKind::Err, AttrVec::new()))\n         }\n@@ -798,7 +796,9 @@ impl<'a> Parser<'a> {\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to `parse_enum_variant()`.\n         if self.token == token::OpenDelim(token::Paren) {\n-            return Err(self.span_fatal(self.prev_span, \"expected identifier, found enum pattern\"));\n+            return Err(\n+                self.struct_span_err(self.prev_span, \"expected identifier, found enum pattern\")\n+            );\n         }\n \n         Ok(PatKind::Ident(binding_mode, ident, sub))\n@@ -807,12 +807,8 @@ impl<'a> Parser<'a> {\n     /// Parse a struct (\"record\") pattern (e.g. `Foo { ... }` or `Foo::Bar { ... }`).\n     fn parse_pat_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n         if qself.is_some() {\n-            let msg = \"unexpected `{` after qualified path\";\n-            let mut err = self.fatal(msg);\n-            err.span_label(self.token.span, msg);\n-            return Err(err);\n+            return self.error_qpath_before_pat(&path, \"{\");\n         }\n-\n         self.bump();\n         let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n             e.emit();\n@@ -826,15 +822,22 @@ impl<'a> Parser<'a> {\n     /// Parse tuple struct or tuple variant pattern (e.g. `Foo(...)` or `Foo::Bar(...)`).\n     fn parse_pat_tuple_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n         if qself.is_some() {\n-            let msg = \"unexpected `(` after qualified path\";\n-            let mut err = self.fatal(msg);\n-            err.span_label(self.token.span, msg);\n-            return Err(err);\n+            return self.error_qpath_before_pat(&path, \"(\");\n         }\n         let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat_with_or_inner())?;\n         Ok(PatKind::TupleStruct(path, fields))\n     }\n \n+    /// Error when there's a qualified path, e.g. `<Foo as Bar>::Baz`\n+    /// as the path of e.g., a tuple or record struct pattern.\n+    fn error_qpath_before_pat(&mut self, path: &Path, token: &str) -> PResult<'a, PatKind> {\n+        let msg = &format!(\"unexpected `{}` after qualified path\", token);\n+        let mut err = self.struct_span_err(self.token.span, msg);\n+        err.span_label(self.token.span, msg);\n+        err.span_label(path.span, \"the qualified path\");\n+        Err(err)\n+    }\n+\n     /// Parses the fields of a struct-like pattern.\n     fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<FieldPat>, bool)> {\n         let mut fields = Vec::new();\n@@ -877,7 +880,8 @@ impl<'a> Parser<'a> {\n                     break;\n                 }\n                 let token_str = super::token_descr(&self.token);\n-                let mut err = self.fatal(&format!(\"expected `}}`, found {}\", token_str));\n+                let msg = &format!(\"expected `}}`, found {}\", token_str);\n+                let mut err = self.struct_span_err(self.token.span, msg);\n \n                 err.span_label(self.token.span, \"expected `}`\");\n                 let mut comma_sp = None;"}, {"sha": "325ad56cd2a43ff896dddaf1459234135e7187b2", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -93,7 +93,7 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtPath, |path| {\n             if style == PathStyle::Mod && path.segments.iter().any(|segment| segment.args.is_some())\n             {\n-                self.diagnostic().span_err(path.span, \"unexpected generic arguments in path\");\n+                self.struct_span_err(path.span, \"unexpected generic arguments in path\").emit();\n             }\n             path\n         });\n@@ -325,24 +325,23 @@ impl<'a> Parser<'a> {\n \n                 // Make a span over ${unmatched angle bracket count} characters.\n                 let span = lo.with_hi(lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count));\n-                self.diagnostic()\n-                    .struct_span_err(\n-                        span,\n-                        &format!(\n-                            \"unmatched angle bracket{}\",\n-                            pluralize!(snapshot.unmatched_angle_bracket_count)\n-                        ),\n-                    )\n-                    .span_suggestion(\n-                        span,\n-                        &format!(\n-                            \"remove extra angle bracket{}\",\n-                            pluralize!(snapshot.unmatched_angle_bracket_count)\n-                        ),\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.struct_span_err(\n+                    span,\n+                    &format!(\n+                        \"unmatched angle bracket{}\",\n+                        pluralize!(snapshot.unmatched_angle_bracket_count)\n+                    ),\n+                )\n+                .span_suggestion(\n+                    span,\n+                    &format!(\n+                        \"remove extra angle bracket{}\",\n+                        pluralize!(snapshot.unmatched_angle_bracket_count)\n+                    ),\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n \n                 // Try again without unmatched angle bracket characters.\n                 self.parse_generic_args()\n@@ -407,9 +406,11 @@ impl<'a> Parser<'a> {\n                     if self.token.is_bool_lit() {\n                         self.parse_literal_maybe_minus()?\n                     } else {\n-                        return Err(\n-                            self.fatal(\"identifiers may currently not be used for const generics\")\n-                        );\n+                        let span = self.token.span;\n+                        let msg = \"identifiers may currently not be used for const generics\";\n+                        self.struct_span_err(span, msg).emit();\n+                        let block = self.mk_block_err(span);\n+                        self.mk_expr(span, ast::ExprKind::Block(block, None), ast::AttrVec::new())\n                     }\n                 } else {\n                     self.parse_literal_maybe_minus()?"}, {"sha": "bf092ed14e342e7e802fb827d39dafa80648b780", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -193,7 +193,8 @@ impl<'a> Parser<'a> {\n             if self.prev_token_kind == PrevTokenKind::DocComment {\n                 self.span_fatal_err(self.prev_span, Error::UselessDocComment).emit();\n             } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n-                self.span_err(self.token.span, \"expected statement after outer attribute\");\n+                self.struct_span_err(self.token.span, \"expected statement after outer attribute\")\n+                    .emit();\n             }\n         }\n     }\n@@ -324,7 +325,7 @@ impl<'a> Parser<'a> {\n     fn error_block_no_opening_brace<T>(&mut self) -> PResult<'a, T> {\n         let sp = self.token.span;\n         let tok = super::token_descr(&self.token);\n-        let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n+        let mut e = self.struct_span_err(sp, &format!(\"expected `{{`, found {}\", tok));\n         let do_not_suggest_help = self.token.is_keyword(kw::In) || self.token == token::Colon;\n \n         // Check to see if the user has written something like\n@@ -397,10 +398,7 @@ impl<'a> Parser<'a> {\n                     self.maybe_annotate_with_ascription(&mut err, false);\n                     err.emit();\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n-                    Some(self.mk_stmt(\n-                        self.token.span,\n-                        StmtKind::Expr(self.mk_expr_err(self.token.span)),\n-                    ))\n+                    Some(self.mk_stmt_err(self.token.span))\n                 }\n                 Ok(stmt) => stmt,\n             };\n@@ -478,4 +476,12 @@ impl<'a> Parser<'a> {\n     pub(super) fn mk_stmt(&self, span: Span, kind: StmtKind) -> Stmt {\n         Stmt { id: DUMMY_NODE_ID, kind, span }\n     }\n+\n+    fn mk_stmt_err(&self, span: Span) -> Stmt {\n+        self.mk_stmt(span, StmtKind::Expr(self.mk_expr_err(span)))\n+    }\n+\n+    pub(super) fn mk_block_err(&self, span: Span) -> P<Block> {\n+        self.mk_block(vec![self.mk_stmt_err(span)], BlockCheckMode::Default, span)\n+    }\n }"}, {"sha": "4f7bcf01e1b82ca8906f93defb2f05ae04bea2aa", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -175,7 +175,9 @@ impl<'a> Parser<'a> {\n                 {\n                     let path = match bounds.remove(0) {\n                         GenericBound::Trait(pt, ..) => pt.trait_ref.path,\n-                        GenericBound::Outlives(..) => self.bug(\"unexpected lifetime bound\"),\n+                        GenericBound::Outlives(..) => {\n+                            self.span_bug(ty.span, \"unexpected lifetime bound\")\n+                        }\n                     };\n                     self.parse_remaining_bounds(Vec::new(), path, lo, true)\n                 }"}, {"sha": "f6d2bee0e15600a300d1d8e4de5915ba78e7bfb3", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -112,3 +112,4 @@ fn main() {}\n #[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n //~^ ERROR expected statement after outer attribute\n #[cfg(FALSE)] fn e() { { fn foo() { #[attr] } } }\n+//~^ ERROR expected statement after outer attribute"}, {"sha": "0123006418a3a71545846f7bcc420649e7155a25", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -410,5 +410,11 @@ error: expected statement after outer attribute\n LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n    |                                            ^\n \n-error: aborting due to 56 previous errors\n+error: expected statement after outer attribute\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:114:45\n+   |\n+LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr] } } }\n+   |                                             ^\n+\n+error: aborting due to 57 previous errors\n "}, {"sha": "d6fdf353f07af3f9e5c790d31b61aabcfd3b9eac", "filename": "src/test/ui/parser/brace-after-qualified-path-in-match.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.stderr?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -2,7 +2,9 @@ error: unexpected `{` after qualified path\n   --> $DIR/brace-after-qualified-path-in-match.rs:3:27\n    |\n LL |         <T as Trait>::Type{key: value} => (),\n-   |                           ^ unexpected `{` after qualified path\n+   |         ------------------^ unexpected `{` after qualified path\n+   |         |\n+   |         the qualified path\n \n error: aborting due to previous error\n "}, {"sha": "af21f9195467ae0511287ecd646031ae0f95a982", "filename": "src/test/ui/parser/paren-after-qualified-path-in-match.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.stderr?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -2,7 +2,9 @@ error: unexpected `(` after qualified path\n   --> $DIR/paren-after-qualified-path-in-match.rs:3:27\n    |\n LL |         <T as Trait>::Type(2) => (),\n-   |                           ^ unexpected `(` after qualified path\n+   |         ------------------^ unexpected `(` after qualified path\n+   |         |\n+   |         the qualified path\n \n error: aborting due to previous error\n "}, {"sha": "1634fdde7d29504a048100fccebcb26b9244aa61", "filename": "src/test/ui/suggestions/vec-macro-in-pattern.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3cca3c6acef10201c6ff419979620ed8132a3965/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr?ref=3cca3c6acef10201c6ff419979620ed8132a3965", "patch": "@@ -5,11 +5,12 @@ LL |         Some(vec![_x]) => (),\n    |              ^^^^^^^^\n    |              |\n    |              unexpected `(` after qualified path\n+   |              the qualified path\n    |              in this macro invocation\n    |              help: use a slice pattern here instead: `[_x]`\n    |\n    = help: for more information, see https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error\n "}]}