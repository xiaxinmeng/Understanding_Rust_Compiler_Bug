{"sha": "5c3504799deb78d986f8267f753a87fb9e73a452", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMzUwNDc5OWRlYjc4ZDk4NmY4MjY3Zjc1M2E4N2ZiOWU3M2E0NTI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-03T04:41:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-28T01:46:51Z"}, "message": "librustc: Remove `&const` and `*const` from the language.\n\nThey are still present as part of the borrow check.", "tree": {"sha": "20e9de7215edf2c27d59251b15afbd3c1d2b7e77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20e9de7215edf2c27d59251b15afbd3c1d2b7e77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c3504799deb78d986f8267f753a87fb9e73a452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3504799deb78d986f8267f753a87fb9e73a452", "html_url": "https://github.com/rust-lang/rust/commit/5c3504799deb78d986f8267f753a87fb9e73a452", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c3504799deb78d986f8267f753a87fb9e73a452/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "html_url": "https://github.com/rust-lang/rust/commit/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d"}], "stats": {"total": 763, "additions": 306, "deletions": 457}, "files": [{"sha": "65d4f79c640249e01008fd71e39b37f75cbf9998", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -25,13 +25,13 @@ pub mod rustrt {\n \n     #[link_name = \"rustrt\"]\n     extern {\n-        pub fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n+        pub fn tdefl_compress_mem_to_heap(psrc_buf: *c_void,\n                                           src_buf_len: size_t,\n                                           pout_len: *mut size_t,\n                                           flags: c_int)\n                                           -> *c_void;\n \n-        pub fn tinfl_decompress_mem_to_heap(psrc_buf: *const c_void,\n+        pub fn tinfl_decompress_mem_to_heap(psrc_buf: *c_void,\n                                             src_buf_len: size_t,\n                                             pout_len: *mut size_t,\n                                             flags: c_int)"}, {"sha": "0536a5e0227318071dd38fbc2fb059ffa9b140ce", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -804,12 +804,9 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n     fn get_mutability(ch: u8) -> ast::mutability {\n         match ch as char {\n-            'i' => { ast::m_imm }\n-            'm' => { ast::m_mutbl }\n-            'c' => { ast::m_const }\n-            _ => {\n-                fail!(\"unknown mutability character: `%c`\", ch as char)\n-            }\n+            'i' => ast::m_imm,\n+            'm' => ast::m_mutbl,\n+            _ => fail!(\"unknown mutability character: `%c`\", ch as char),\n         }\n     }\n "}, {"sha": "6a2d1901aef3f36cda8006a93a7009c18e537548", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -635,15 +635,8 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::explic\n     fn encode_mutability(ebml_w: &writer::Encoder,\n                          m: ast::mutability) {\n         match m {\n-            m_imm => {\n-                ebml_w.writer.write(&[ 'i' as u8 ]);\n-            }\n-            m_mutbl => {\n-                ebml_w.writer.write(&[ 'm' as u8 ]);\n-            }\n-            m_const => {\n-                ebml_w.writer.write(&[ 'c' as u8 ]);\n-            }\n+            m_imm => ebml_w.writer.write(&[ 'i' as u8 ]),\n+            m_mutbl => ebml_w.writer.write(&[ 'm' as u8 ]),\n         }\n     }\n }"}, {"sha": "a03266649ab0a3ee0da8405ec389d5f9d6cb0219", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -417,7 +417,6 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n fn parse_mutability(st: &mut PState) -> ast::mutability {\n     match peek(st) {\n       'm' => { next(st); ast::m_mutbl }\n-      '?' => { next(st); ast::m_const }\n       _ => { ast::m_imm }\n     }\n }"}, {"sha": "d00928dd3db74232da80f73a8df73150f12d41ab", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -99,7 +99,6 @@ fn enc_mutability(w: @io::Writer, mt: ast::mutability) {\n     match mt {\n       m_imm => (),\n       m_mutbl => w.write_char('m'),\n-      m_const => w.write_char('?')\n     }\n }\n "}, {"sha": "ba5b9d9dca142c40321d81eaac4200e7c3cccf50", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -23,7 +23,7 @@ use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::moves;\n use middle::ty;\n-use syntax::ast::{m_mutbl, m_imm, m_const};\n+use syntax::ast::m_mutbl;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::span;\n@@ -220,9 +220,9 @@ impl<'self> CheckLoanCtxt<'self> {\n \n         // Restrictions that would cause the new loan to be illegal:\n         let illegal_if = match loan2.mutbl {\n-            m_mutbl => RESTR_ALIAS | RESTR_FREEZE | RESTR_CLAIM,\n-            m_imm =>   RESTR_ALIAS | RESTR_FREEZE,\n-            m_const => RESTR_ALIAS,\n+            MutableMutability   => RESTR_ALIAS | RESTR_FREEZE | RESTR_CLAIM,\n+            ImmutableMutability => RESTR_ALIAS | RESTR_FREEZE,\n+            ConstMutability     => RESTR_ALIAS,\n         };\n         debug!(\"illegal_if=%?\", illegal_if);\n \n@@ -231,7 +231,7 @@ impl<'self> CheckLoanCtxt<'self> {\n             if restr.loan_path != loan2.loan_path { loop; }\n \n             match (new_loan.mutbl, old_loan.mutbl) {\n-                (m_mutbl, m_mutbl) => {\n+                (MutableMutability, MutableMutability) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         fmt!(\"cannot borrow `%s` as mutable \\\n@@ -582,16 +582,18 @@ impl<'self> CheckLoanCtxt<'self> {\n                     // Otherwise stop iterating\n                     LpExtend(_, mc::McDeclared, _) |\n                     LpExtend(_, mc::McImmutable, _) |\n-                    LpExtend(_, mc::McReadOnly, _) |\n                     LpVar(_) => {\n                         return true;\n                     }\n                 }\n \n                 // Check for a non-const loan of `loan_path`\n                 let cont = do this.each_in_scope_loan(expr.id) |loan| {\n-                    if loan.loan_path == loan_path && loan.mutbl != m_const {\n-                        this.report_illegal_mutation(expr, full_loan_path, loan);\n+                    if loan.loan_path == loan_path &&\n+                            loan.mutbl != ConstMutability {\n+                        this.report_illegal_mutation(expr,\n+                                                     full_loan_path,\n+                                                     loan);\n                         false\n                     } else {\n                         true"}, {"sha": "e76d11c269b2b21461c489aae232ca14135a8b77", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -15,7 +15,7 @@\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use syntax::ast::{m_const, m_imm, m_mutbl};\n+use syntax::ast::{m_imm, m_mutbl};\n use syntax::ast;\n use syntax::codemap::span;\n use util::ppaux::{note_and_explain_region};\n@@ -26,7 +26,7 @@ pub fn guarantee_lifetime(bccx: @BorrowckCtxt,\n                           span: span,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n-                          loan_mutbl: ast::mutability) {\n+                          loan_mutbl: LoanMutability) {\n     debug!(\"guarantee_lifetime(cmt=%s, loan_region=%s)\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n@@ -54,7 +54,7 @@ struct GuaranteeLifetimeContext {\n \n     span: span,\n     loan_region: ty::Region,\n-    loan_mutbl: ast::mutability,\n+    loan_mutbl: LoanMutability,\n     cmt_original: mc::cmt\n }\n \n@@ -235,11 +235,11 @@ impl GuaranteeLifetimeContext {\n         // we need to dynamically mark it to prevent incompatible\n         // borrows from happening later.\n         let opt_dyna = match ptr_mutbl {\n-            m_imm | m_const => None,\n+            m_imm => None,\n             m_mutbl => {\n                 match self.loan_mutbl {\n-                    m_mutbl => Some(DynaMut),\n-                    m_imm | m_const => Some(DynaImm)\n+                    MutableMutability => Some(DynaMut),\n+                    ImmutableMutability | ConstMutability => Some(DynaImm)\n                 }\n             }\n         };"}, {"sha": "8c5da2f3d0f84fac59dd103c7498500be4cc0ec8", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -26,7 +26,6 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr};\n \n-use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n use syntax::ast_util::id_range;\n use syntax::codemap::span;\n@@ -237,7 +236,11 @@ fn gather_loans_in_expr(v: &mut GatherLoanVisitor,\n         // make sure that the thing we are pointing out stays valid\n         // for the lifetime `scope_r` of the resulting ptr:\n         let scope_r = ty_region(tcx, ex.span, ty::expr_ty(tcx, ex));\n-        this.guarantee_valid(ex.id, ex.span, base_cmt, mutbl, scope_r);\n+        this.guarantee_valid(ex.id,\n+                             ex.span,\n+                             base_cmt,\n+                             LoanMutability::from_ast_mutability(mutbl),\n+                             scope_r);\n         visit::walk_expr(v, ex, this);\n       }\n \n@@ -278,7 +281,11 @@ fn gather_loans_in_expr(v: &mut GatherLoanVisitor,\n           // adjustments).\n           let scope_r = ty::re_scope(ex.id);\n           let arg_cmt = this.bccx.cat_expr(arg);\n-          this.guarantee_valid(arg.id, arg.span, arg_cmt, m_imm, scope_r);\n+          this.guarantee_valid(arg.id,\n+                               arg.span,\n+                               arg_cmt,\n+                               ImmutableMutability,\n+                               scope_r);\n           visit::walk_expr(v, ex, this);\n       }\n \n@@ -357,26 +364,30 @@ impl GatherLoanCtxt {\n \n                 match *autoref {\n                     ty::AutoPtr(r, m) => {\n+                        let loan_mutability =\n+                            LoanMutability::from_ast_mutability(m);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt,\n-                                             m,\n+                                             loan_mutability,\n                                              r)\n                     }\n                     ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n                         let cmt_index = mcx.cat_index(expr, cmt, autoderefs+1);\n+                        let loan_mutability =\n+                            LoanMutability::from_ast_mutability(m);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_index,\n-                                             m,\n+                                             loan_mutability,\n                                              r)\n                     }\n                     ty::AutoBorrowFn(r) => {\n                         let cmt_deref = mcx.cat_deref_fn_or_obj(expr, cmt, 0);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_deref,\n-                                             m_imm,\n+                                             ImmutableMutability,\n                                              r)\n                     }\n                     ty::AutoBorrowObj(r, m) => {\n@@ -402,7 +413,7 @@ impl GatherLoanCtxt {\n                            borrow_id: ast::NodeId,\n                            borrow_span: span,\n                            cmt: mc::cmt,\n-                           req_mutbl: ast::mutability,\n+                           req_mutbl: LoanMutability,\n                            loan_region: ty::Region) {\n         debug!(\"guarantee_valid(borrow_id=%?, cmt=%s, \\\n                 req_mutbl=%?, loan_region=%?)\",\n@@ -473,7 +484,7 @@ impl GatherLoanCtxt {\n                 let kill_scope = self.compute_kill_scope(loan_scope, loan_path);\n                 debug!(\"kill_scope = %?\", kill_scope);\n \n-                if req_mutbl == m_mutbl {\n+                if req_mutbl == MutableMutability {\n                     self.mark_loan_path_as_mutated(loan_path);\n                 }\n \n@@ -516,7 +527,7 @@ impl GatherLoanCtxt {\n             //        index: all_loans.len(),\n             //        loan_path: loan_path,\n             //        cmt: cmt,\n-            //        mutbl: m_const,\n+            //        mutbl: ConstMutability,\n             //        gen_scope: borrow_id,\n             //        kill_scope: kill_scope,\n             //        span: borrow_span,\n@@ -527,29 +538,20 @@ impl GatherLoanCtxt {\n         fn check_mutability(bccx: @BorrowckCtxt,\n                             borrow_span: span,\n                             cmt: mc::cmt,\n-                            req_mutbl: ast::mutability) {\n+                            req_mutbl: LoanMutability) {\n             //! Implements the M-* rules in doc.rs.\n \n             match req_mutbl {\n-                m_const => {\n+                ConstMutability => {\n                     // Data of any mutability can be lent as const.\n                 }\n \n-                m_imm => {\n-                    match cmt.mutbl {\n-                        mc::McImmutable | mc::McDeclared | mc::McInherited => {\n-                            // both imm and mut data can be lent as imm;\n-                            // for mutable data, this is a freeze\n-                        }\n-                        mc::McReadOnly => {\n-                            bccx.report(BckError {span: borrow_span,\n-                                                  cmt: cmt,\n-                                                  code: err_mutbl(req_mutbl)});\n-                        }\n-                    }\n+                ImmutableMutability => {\n+                    // both imm and mut data can be lent as imm;\n+                    // for mutable data, this is a freeze\n                 }\n \n-                m_mutbl => {\n+                MutableMutability => {\n                     // Only mutable data can be lent as mutable.\n                     if !cmt.mutbl.is_mutable() {\n                         bccx.report(BckError {span: borrow_span,\n@@ -561,12 +563,14 @@ impl GatherLoanCtxt {\n         }\n     }\n \n-    pub fn restriction_set(&self, req_mutbl: ast::mutability)\n+    pub fn restriction_set(&self, req_mutbl: LoanMutability)\n                            -> RestrictionSet {\n         match req_mutbl {\n-            m_const => RESTR_EMPTY,\n-            m_imm   => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM,\n-            m_mutbl => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE\n+            ConstMutability => RESTR_EMPTY,\n+            ImmutableMutability => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM,\n+            MutableMutability => {\n+                RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE\n+            }\n         }\n     }\n \n@@ -582,8 +586,8 @@ impl GatherLoanCtxt {\n                 self.mark_loan_path_as_mutated(base);\n             }\n             LpExtend(_, mc::McDeclared, _) |\n-            LpExtend(_, mc::McImmutable, _) |\n-            LpExtend(_, mc::McReadOnly, _) => {\n+            LpExtend(_, mc::McImmutable, _) => {\n+                // Nothing to do.\n             }\n         }\n     }\n@@ -701,8 +705,13 @@ impl GatherLoanCtxt {\n                             }\n                         }\n                     };\n-                    self.guarantee_valid(pat.id, pat.span,\n-                                         cmt_discr, mutbl, scope_r);\n+                    let loan_mutability =\n+                        LoanMutability::from_ast_mutability(mutbl);\n+                    self.guarantee_valid(pat.id,\n+                                         pat.span,\n+                                         cmt_discr,\n+                                         loan_mutability,\n+                                         scope_r);\n                   }\n                   ast::bind_infer => {\n                       // No borrows here, but there may be moves\n@@ -725,6 +734,8 @@ impl GatherLoanCtxt {\n                       self.vec_slice_info(slice_pat, slice_ty);\n                   let mcx = self.bccx.mc_ctxt();\n                   let cmt_index = mcx.cat_index(slice_pat, cmt, 0);\n+                  let slice_loan_mutability =\n+                    LoanMutability::from_ast_mutability(slice_mutbl);\n \n                   // Note: We declare here that the borrow occurs upon\n                   // entering the `[...]` pattern. This implies that\n@@ -743,8 +754,11 @@ impl GatherLoanCtxt {\n                   // trans do the right thing, and it would only work\n                   // for `~` vectors. It seems simpler to just require\n                   // that people call `vec.pop()` or `vec.unshift()`.\n-                  self.guarantee_valid(pat.id, pat.span,\n-                                       cmt_index, slice_mutbl, slice_r);\n+                  self.guarantee_valid(pat.id,\n+                                       pat.span,\n+                                       cmt_index,\n+                                       slice_loan_mutability,\n+                                       slice_r);\n               }\n \n               _ => {}"}, {"sha": "26c2cff189c46b00923a7ff94d666170926768eb", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -15,7 +15,7 @@ use std::vec;\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use syntax::ast::{m_const, m_imm, m_mutbl};\n+use syntax::ast::{m_imm, m_mutbl};\n use syntax::codemap::span;\n \n pub enum RestrictionResult {\n@@ -121,13 +121,6 @@ impl RestrictionsContext {\n                 Safe\n             }\n \n-            mc::cat_deref(_, _, mc::region_ptr(m_const, _)) |\n-            mc::cat_deref(_, _, mc::gc_ptr(m_const)) => {\n-                // R-Deref-Freeze-Borrowed\n-                self.check_no_mutability_control(cmt, restrictions);\n-                Safe\n-            }\n-\n             mc::cat_deref(cmt_base, _, pk @ mc::gc_ptr(m_mutbl)) => {\n                 // R-Deref-Managed-Borrowed\n                 //"}, {"sha": "7113af3fbc2464a8f55c7f6526aea344fbfa3000", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -241,12 +241,39 @@ pub enum PartialTotal {\n ///////////////////////////////////////////////////////////////////////////\n // Loans and loan paths\n \n+#[deriving(Clone, Eq)]\n+pub enum LoanMutability {\n+    ImmutableMutability,\n+    ConstMutability,\n+    MutableMutability,\n+}\n+\n+impl LoanMutability {\n+    pub fn from_ast_mutability(ast_mutability: ast::mutability)\n+                               -> LoanMutability {\n+        match ast_mutability {\n+            ast::m_imm => ImmutableMutability,\n+            ast::m_mutbl => MutableMutability,\n+        }\n+    }\n+}\n+\n+impl ToStr for LoanMutability {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            ImmutableMutability => ~\"immutable\",\n+            ConstMutability => ~\"read-only\",\n+            MutableMutability => ~\"mutable\",\n+        }\n+    }\n+}\n+\n /// Record of a loan that was issued.\n pub struct Loan {\n     index: uint,\n     loan_path: @LoanPath,\n     cmt: mc::cmt,\n-    mutbl: ast::mutability,\n+    mutbl: LoanMutability,\n     restrictions: ~[Restriction],\n     gen_scope: ast::NodeId,\n     kill_scope: ast::NodeId,\n@@ -417,7 +444,7 @@ impl ToStr for DynaFreezeKind {\n // Errors that can occur\n #[deriving(Eq)]\n pub enum bckerr_code {\n-    err_mutbl(ast::mutability),\n+    err_mutbl(LoanMutability),\n     err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n     err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n     err_freeze_aliasable_const\n@@ -794,17 +821,14 @@ impl BorrowckCtxt {\n         mc.cmt_to_str(cmt)\n     }\n \n-    pub fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n-        let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n-                                               method_map: self.method_map};\n-        mc.mut_to_str(mutbl)\n+    pub fn mut_to_str(&self, mutbl: LoanMutability) -> ~str {\n+        mutbl.to_str()\n     }\n \n     pub fn mut_to_keyword(&self, mutbl: ast::mutability) -> &'static str {\n         match mutbl {\n             ast::m_imm => \"\",\n-            ast::m_const => \"const\",\n-            ast::m_mutbl => \"mut\"\n+            ast::m_mutbl => \"mut\",\n         }\n     }\n }"}, {"sha": "3f1e409e170cde03b53c3f31a1cae27bccb341d3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -52,7 +52,7 @@ use middle::typeck;\n use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n use util::common::indenter;\n \n-use syntax::ast::{m_imm, m_const, m_mutbl};\n+use syntax::ast::{m_imm, m_mutbl};\n use syntax::ast;\n use syntax::codemap::span;\n use syntax::print::pprust;\n@@ -113,7 +113,6 @@ pub enum ElementKind {\n #[deriving(Eq, IterBytes)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n-    McReadOnly,  // Read-only (`const`)\n     McDeclared,  // Directly declared as mutable.\n     McInherited  // Inherited from the fact that owner is mutable.\n }\n@@ -297,39 +296,36 @@ impl MutabilityCategory {\n     pub fn from_mutbl(m: ast::mutability) -> MutabilityCategory {\n         match m {\n             m_imm => McImmutable,\n-            m_const => McReadOnly,\n             m_mutbl => McDeclared\n         }\n     }\n \n     pub fn inherit(&self) -> MutabilityCategory {\n         match *self {\n             McImmutable => McImmutable,\n-            McReadOnly => McReadOnly,\n             McDeclared => McInherited,\n             McInherited => McInherited\n         }\n     }\n \n     pub fn is_mutable(&self) -> bool {\n         match *self {\n-            McImmutable | McReadOnly => false,\n+            McImmutable => false,\n             McDeclared | McInherited => true\n         }\n     }\n \n     pub fn is_immutable(&self) -> bool {\n         match *self {\n             McImmutable => true,\n-            McReadOnly | McDeclared | McInherited => false\n+            McDeclared | McInherited => false\n         }\n     }\n \n     pub fn to_user_str(&self) -> &'static str {\n         match *self {\n             McDeclared | McInherited => \"mutable\",\n             McImmutable => \"immutable\",\n-            McReadOnly => \"const\"\n         }\n     }\n }\n@@ -610,7 +606,6 @@ impl mem_categorization_ctxt {\n                                 -> MutabilityCategory {\n         match interior_m {\n             m_imm => base_m.inherit(),\n-            m_const => McReadOnly,\n             m_mutbl => McDeclared\n         }\n     }\n@@ -999,7 +994,6 @@ impl mem_categorization_ctxt {\n     pub fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n         match mutbl {\n           m_mutbl => ~\"mutable\",\n-          m_const => ~\"const\",\n           m_imm => ~\"immutable\"\n         }\n     }\n@@ -1164,7 +1158,6 @@ impl cmt_ {\n                 Some(AliasableManaged(m))\n             }\n \n-            cat_deref(_, _, region_ptr(m @ m_const, _)) |\n             cat_deref(_, _, region_ptr(m @ m_imm, _)) => {\n                 Some(AliasableBorrowed(m))\n             }"}, {"sha": "8c96df9b8f0e9c1a30fbaf8d4be96615f800318c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -272,8 +272,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Clone + 'static>(\n         match a_seq_ty.ty.node {\n             ast::ty_vec(ref mt) => {\n                 let mut mt = ast_mt_to_mt(this, rscope, mt);\n-                if a_seq_ty.mutbl == ast::m_mutbl ||\n-                        a_seq_ty.mutbl == ast::m_const {\n+                if a_seq_ty.mutbl == ast::m_mutbl {\n                     mt = ty::mt { ty: mt.ty, mutbl: a_seq_ty.mutbl };\n                 }\n                 return ty::mk_evec(tcx, mt, vst);"}, {"sha": "1f7cccbdc938b3a112288cdc6f7f255e29441ee1", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -102,7 +102,7 @@ use std::vec;\n use extra::list::Nil;\n use syntax::ast::{def_id, sty_value, sty_region, sty_box};\n use syntax::ast::{sty_uniq, sty_static, NodeId};\n-use syntax::ast::{m_const, m_mutbl, m_imm};\n+use syntax::ast::{m_mutbl, m_imm};\n use syntax::ast;\n use syntax::ast_map;\n \n@@ -700,7 +700,7 @@ impl<'self> LookupContext<'self> {\n             ty_evec(mt, vstore_fixed(_)) => {\n                 // First try to borrow to a slice\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVec, autoderefs, [m_const, m_imm, m_mutbl],\n+                    AutoBorrowVec, autoderefs, [m_imm, m_mutbl],\n                     |m,r| ty::mk_evec(tcx,\n                                       ty::mt {ty:mt.ty, mutbl:m},\n                                       vstore_slice(r)));\n@@ -709,7 +709,7 @@ impl<'self> LookupContext<'self> {\n \n                 // Then try to borrow to a slice *and* borrow a pointer.\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVecRef, autoderefs, [m_const, m_imm, m_mutbl],\n+                    AutoBorrowVecRef, autoderefs, [m_imm, m_mutbl],\n                     |m,r| {\n                         let slice_ty = ty::mk_evec(tcx,\n                                                    ty::mt {ty:mt.ty, mutbl:m},\n@@ -744,7 +744,7 @@ impl<'self> LookupContext<'self> {\n                 // Coerce ~/@/&Trait instances to &Trait.\n \n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowObj, autoderefs, [m_const, m_imm, m_mutbl],\n+                    AutoBorrowObj, autoderefs, [m_imm, m_mutbl],\n                     |trt_mut, reg| {\n                         ty::mk_trait(tcx, trt_did, trt_substs.clone(),\n                                      RegionTraitStore(reg), trt_mut, b)\n@@ -779,7 +779,7 @@ impl<'self> LookupContext<'self> {\n             ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_struct(*) | ty_tup(*) |\n             ty_estr(*) | ty_evec(*) | ty_trait(*) | ty_closure(*) => {\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoPtr, autoderefs, [m_const, m_imm, m_mutbl],\n+                    AutoPtr, autoderefs, [m_imm, m_mutbl],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n             }\n \n@@ -1270,18 +1270,10 @@ impl<'self> LookupContext<'self> {\n         }\n \n         fn mutability_matches(self_mutbl: ast::mutability,\n-                              candidate_mutbl: ast::mutability) -> bool {\n+                              candidate_mutbl: ast::mutability)\n+                              -> bool {\n             //! True if `self_mutbl <: candidate_mutbl`\n-\n-            match (self_mutbl, candidate_mutbl) {\n-                (_, m_const) => true,\n-                (m_mutbl, m_mutbl) => true,\n-                (m_imm, m_imm) => true,\n-                (m_mutbl, m_imm) => false,\n-                (m_imm, m_mutbl) => false,\n-                (m_const, m_imm) => false,\n-                (m_const, m_mutbl) => false,\n-            }\n+            self_mutbl == candidate_mutbl\n         }\n     }\n "}, {"sha": "86c0736090c937e1a36a88b5cf00fd2517c276c8", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -21,7 +21,7 @@ use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::isr_alist;\n-use syntax::ast::{Many, Once, extern_fn, impure_fn, m_const, m_imm, m_mutbl};\n+use syntax::ast::{Many, Once, extern_fn, impure_fn, m_imm, m_mutbl};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n use util::common::{indenter};\n@@ -52,16 +52,6 @@ impl Combine for Glb {\n         match (a.mutbl, b.mutbl) {\n           // If one side or both is mut, then the GLB must use\n           // the precise type from the mut side.\n-          (m_mutbl, m_const) => {\n-            Sub(**self).tys(a.ty, b.ty).chain(|_t| {\n-                Ok(ty::mt {ty: a.ty, mutbl: m_mutbl})\n-            })\n-          }\n-          (m_const, m_mutbl) => {\n-            Sub(**self).tys(b.ty, a.ty).chain(|_t| {\n-                Ok(ty::mt {ty: b.ty, mutbl: m_mutbl})\n-            })\n-          }\n           (m_mutbl, m_mutbl) => {\n             eq_tys(self, a.ty, b.ty).then(|| {\n                 Ok(ty::mt {ty: a.ty, mutbl: m_mutbl})\n@@ -70,22 +60,12 @@ impl Combine for Glb {\n \n           // If one side or both is immutable, we can use the GLB of\n           // both sides but mutbl must be `m_imm`.\n-          (m_imm, m_const) |\n-          (m_const, m_imm) |\n           (m_imm, m_imm) => {\n             self.tys(a.ty, b.ty).chain(|t| {\n                 Ok(ty::mt {ty: t, mutbl: m_imm})\n             })\n           }\n \n-          // If both sides are const, then we can use GLB of both\n-          // sides and mutbl of only `m_const`.\n-          (m_const, m_const) => {\n-            self.tys(a.ty, b.ty).chain(|t| {\n-                Ok(ty::mt {ty: t, mutbl: m_const})\n-            })\n-          }\n-\n           // There is no mutual subtype of these combinations.\n           (m_mutbl, m_imm) |\n           (m_imm, m_mutbl) => {"}, {"sha": "50bddaacc3fc98a95b47c83e15baeb0d42e777bb", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -24,7 +24,7 @@ use middle::typeck::isr_alist;\n use util::ppaux::mt_to_str;\n \n use extra::list;\n-use syntax::ast::{Many, Once, extern_fn, m_const, impure_fn};\n+use syntax::ast::{Many, Once, extern_fn, impure_fn};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n \n@@ -55,14 +55,13 @@ impl Combine for Lub {\n                mt_to_str(tcx, a),\n                mt_to_str(tcx, b));\n \n-        let m = if a.mutbl == b.mutbl {\n-            a.mutbl\n-        } else {\n-            m_const\n-        };\n+        if a.mutbl != b.mutbl {\n+            return Err(ty::terr_mutability)\n+        }\n \n+        let m = a.mutbl;\n         match m {\n-          m_imm | m_const => {\n+          m_imm => {\n             self.tys(a.ty, b.ty).chain(|t| Ok(ty::mt {ty: t, mutbl: m}) )\n           }\n \n@@ -71,11 +70,7 @@ impl Combine for Lub {\n                 eq_tys(self, a.ty, b.ty).then(|| {\n                     Ok(ty::mt {ty: a.ty, mutbl: m})\n                 })\n-            }).chain_err(|_e| {\n-                self.tys(a.ty, b.ty).chain(|t| {\n-                    Ok(ty::mt {ty: t, mutbl: m_const})\n-                })\n-            })\n+            }).chain_err(|e| Err(e))\n           }\n         }\n     }"}, {"sha": "a00f018ceab0fdf650e5c93c3525b29060cad261", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -26,7 +26,7 @@ use util::ppaux::bound_region_to_str;\n \n use extra::list::Nil;\n use extra::list;\n-use syntax::ast::{Onceness, m_const, purity};\n+use syntax::ast::{Onceness, purity};\n \n pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n \n@@ -67,7 +67,7 @@ impl Combine for Sub {\n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         debug!(\"mts(%s <: %s)\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n-        if a.mutbl != b.mutbl && b.mutbl != m_const {\n+        if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability);\n         }\n \n@@ -77,7 +77,7 @@ impl Combine for Sub {\n             // (i.e., invariant if mut):\n             eq_tys(self, a.ty, b.ty).then(|| Ok(*a))\n           }\n-          m_imm | m_const => {\n+          m_imm => {\n             // Otherwise we can be covariant:\n             self.tys(a.ty, b.ty).chain(|_t| Ok(*a) )\n           }"}, {"sha": "3549323cf085f91d3840633333ab7be3f33c3786", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -239,7 +239,6 @@ fn mutability_to_str(m: ast::mutability) -> ~str {\n     match m {\n         ast::m_mutbl => ~\"mut \",\n         ast::m_imm => ~\"\",\n-        ast::m_const => ~\"const \"\n     }\n }\n "}, {"sha": "a4e18d98f47ea6c90209ef76183942a09f700bca", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -10,6 +10,7 @@\n \n //! Unsafe casting functions\n \n+use ptr::RawPtr;\n use sys;\n use unstable::intrinsics;\n \n@@ -94,13 +95,13 @@ pub unsafe fn transmute_region<'a,'b,T>(ptr: &'a T) -> &'b T {\n \n /// Coerce an immutable reference to be mutable.\n #[inline]\n-pub unsafe fn transmute_mut_unsafe<T>(ptr: *const T) -> *mut T {\n+pub unsafe fn transmute_mut_unsafe<T,P:RawPtr<T>>(ptr: P) -> *mut T {\n     transmute(ptr)\n }\n \n /// Coerce an immutable reference to be mutable.\n #[inline]\n-pub unsafe fn transmute_immut_unsafe<T>(ptr: *const T) -> *T {\n+pub unsafe fn transmute_immut_unsafe<T,P:RawPtr<T>>(ptr: P) -> *T {\n     transmute(ptr)\n }\n "}, {"sha": "6b982ec75da126255f7bc8545bfad0920f969b8c", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -11,7 +11,7 @@\n #[doc(hidden)];\n \n use libc::c_void;\n-use ptr::{mut_null};\n+use ptr::null;\n use unstable::intrinsics::TyDesc;\n use unstable::raw;\n \n@@ -37,7 +37,7 @@ unsafe fn each_live_alloc(read_next_before: bool,\n     use rt::local_heap;\n \n     let mut box = local_heap::live_allocs();\n-    while box != mut_null() {\n+    while box != null() {\n         let next_before = (*box).next;\n         let uniq = (*box).ref_count == managed::RC_MANAGED_UNIQUE;\n "}, {"sha": "7aae9425302255fdfaadac1a28a1612cdaf88096", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -1521,7 +1521,7 @@ impl MemoryMap {\n         let r = unsafe {\n             libc::mmap(addr, len, prot, flags, fd, offset)\n         };\n-        if r == libc::MAP_FAILED {\n+        if r.equiv(&libc::MAP_FAILED) {\n             Err(match errno() as c_int {\n                 libc::EACCES => ErrFdNotAvail,\n                 libc::EBADF => ErrInvalidFd,"}, {"sha": "860b1f4b7683b704151fc8bb95578ee13c70d374", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 114, "deletions": 32, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -12,8 +12,11 @@\n \n use cast;\n use clone::Clone;\n+use cmp::Equiv;\n use iterator::{range, Iterator};\n use option::{Option, Some, None};\n+#[cfg(stage0)]\n+use sys;\n use unstable::intrinsics;\n use util::swap;\n \n@@ -24,18 +27,28 @@ use util::swap;\n \n /// Calculate the offset from a pointer\n #[inline]\n+#[cfg(stage0)]\n pub fn offset<T>(ptr: *T, count: int) -> *T {\n-    unsafe { intrinsics::offset(ptr, count) }\n+    (ptr as uint + (count as uint) * sys::size_of::<T>()) as *T\n }\n \n-/// Calculate the offset from a const pointer\n+/// Calculate the offset from a mut pointer\n #[inline]\n-pub fn const_offset<T>(ptr: *const T, count: int) -> *const T {\n-    unsafe { intrinsics::offset(ptr as *T, count) }\n+#[cfg(stage0)]\n+pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n+    (ptr as uint + (count as uint) * sys::size_of::<T>()) as *mut T\n+}\n+\n+/// Calculate the offset from a pointer\n+#[inline]\n+#[cfg(not(stage0))]\n+pub fn offset<T>(ptr: *T, count: int) -> *T {\n+    unsafe { intrinsics::offset(ptr, count) }\n }\n \n /// Calculate the offset from a mut pointer\n #[inline]\n+#[cfg(not(stage0))]\n pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     unsafe { intrinsics::offset(ptr as *T, count) as *mut T }\n }\n@@ -73,11 +86,11 @@ pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n \n /// Returns true if the pointer is equal to the null pointer.\n #[inline]\n-pub fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n+pub fn is_null<T,P:RawPtr<T>>(ptr: P) -> bool { ptr.is_null() }\n \n /// Returns true if the pointer is not equal to the null pointer.\n #[inline]\n-pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n+pub fn is_not_null<T,P:RawPtr<T>>(ptr: P) -> bool { ptr.is_not_null() }\n \n /**\n  * Copies data from one location to another.\n@@ -87,8 +100,10 @@ pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n  */\n #[inline]\n #[cfg(target_word_size = \"32\")]\n-pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    intrinsics::memmove32(dst, src as *T, count as u32);\n+pub unsafe fn copy_memory<T,P:RawPtr<T>>(dst: *mut T, src: P, count: uint) {\n+    intrinsics::memmove32(dst,\n+                          cast::transmute_immut_unsafe(src),\n+                          count as u32);\n }\n \n /**\n@@ -99,8 +114,10 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  */\n #[inline]\n #[cfg(target_word_size = \"64\")]\n-pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    intrinsics::memmove64(dst, src as *T, count as u64);\n+pub unsafe fn copy_memory<T,P:RawPtr<T>>(dst: *mut T, src: P, count: uint) {\n+    intrinsics::memmove64(dst,\n+                          cast::transmute_immut_unsafe(src),\n+                          count as u64);\n }\n \n /**\n@@ -111,8 +128,12 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  */\n #[inline]\n #[cfg(target_word_size = \"32\")]\n-pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    intrinsics::memcpy32(dst, src as *T, count as u32);\n+pub unsafe fn copy_nonoverlapping_memory<T,P:RawPtr<T>>(dst: *mut T,\n+                                                        src: P,\n+                                                        count: uint) {\n+    intrinsics::memcpy32(dst,\n+                         cast::transmute_immut_unsafe(src),\n+                         count as u32);\n }\n \n /**\n@@ -123,8 +144,12 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n  */\n #[inline]\n #[cfg(target_word_size = \"64\")]\n-pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    intrinsics::memcpy64(dst, src as *T, count as u64);\n+pub unsafe fn copy_nonoverlapping_memory<T,P:RawPtr<T>>(dst: *mut T,\n+                                                        src: P,\n+                                                        count: uint) {\n+    intrinsics::memcpy64(dst,\n+                         cast::transmute_immut_unsafe(src),\n+                         count as u64);\n }\n \n /**\n@@ -216,12 +241,6 @@ pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n     thing as *T\n }\n \n-/// Transform a const region pointer - &const T - to a const unsafe pointer - *const T.\n-#[inline]\n-pub fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n-    thing as *const T\n-}\n-\n /// Transform a mutable region pointer - &mut T - to a mutable unsafe pointer - *mut T.\n #[inline]\n pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n@@ -269,22 +288,32 @@ pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n \n #[allow(missing_doc)]\n pub trait RawPtr<T> {\n+    fn null() -> Self;\n     fn is_null(&self) -> bool;\n     fn is_not_null(&self) -> bool;\n+    fn to_uint(&self) -> uint;\n     unsafe fn to_option(&self) -> Option<&T>;\n     fn offset(&self, count: int) -> Self;\n     unsafe fn offset_inbounds(self, count: int) -> Self;\n }\n \n /// Extension methods for immutable pointers\n impl<T> RawPtr<T> for *T {\n+    /// Returns the null pointer.\n+    #[inline]\n+    fn null() -> *T { null() }\n+\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline]\n-    fn is_null(&self) -> bool { is_null(*self) }\n+    fn is_null(&self) -> bool { *self == RawPtr::null() }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline]\n-    fn is_not_null(&self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&self) -> bool { *self != RawPtr::null() }\n+\n+    /// Returns the address of this pointer.\n+    #[inline]\n+    fn to_uint(&self) -> uint { *self as uint }\n \n     ///\n     /// Returns `None` if the pointer is null, or else returns the value wrapped\n@@ -317,13 +346,21 @@ impl<T> RawPtr<T> for *T {\n \n /// Extension methods for mutable pointers\n impl<T> RawPtr<T> for *mut T {\n+    /// Returns the null pointer.\n+    #[inline]\n+    fn null() -> *mut T { mut_null() }\n+\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline]\n-    fn is_null(&self) -> bool { is_null(*self) }\n+    fn is_null(&self) -> bool { *self == RawPtr::null() }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline]\n-    fn is_not_null(&self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&self) -> bool { *self != RawPtr::null() }\n+\n+    /// Returns the address of this pointer.\n+    #[inline]\n+    fn to_uint(&self) -> uint { *self as uint }\n \n     ///\n     /// Returns `None` if the pointer is null, or else returns the value wrapped\n@@ -360,13 +397,38 @@ impl<T> RawPtr<T> for *mut T {\n \n // Equality for pointers\n #[cfg(not(test))]\n-impl<T> Eq for *const T {\n+impl<T> Eq for *T {\n+    #[inline]\n+    fn eq(&self, other: &*T) -> bool {\n+        (*self as uint) == (*other as uint)\n+    }\n+    #[inline]\n+    fn ne(&self, other: &*T) -> bool { !self.eq(other) }\n+}\n+\n+#[cfg(not(test))]\n+impl<T> Eq for *mut T {\n     #[inline]\n-    fn eq(&self, other: &*const T) -> bool {\n+    fn eq(&self, other: &*mut T) -> bool {\n         (*self as uint) == (*other as uint)\n     }\n     #[inline]\n-    fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n+}\n+\n+// Equivalence for pointers\n+#[cfg(not(test))]\n+impl<T> Equiv<*mut T> for *T {\n+    fn equiv(&self, other: &*mut T) -> bool {\n+        self.to_uint() == other.to_uint()\n+    }\n+}\n+\n+#[cfg(not(test))]\n+impl<T> Equiv<*T> for *mut T {\n+    fn equiv(&self, other: &*T) -> bool {\n+        self.to_uint() == other.to_uint()\n+    }\n }\n \n // Equality for extern \"C\" fn pointers\n@@ -412,21 +474,41 @@ mod externfnpointers {\n \n // Comparison for pointers\n #[cfg(not(test))]\n-impl<T> Ord for *const T {\n+impl<T> Ord for *T {\n+    #[inline]\n+    fn lt(&self, other: &*T) -> bool {\n+        (*self as uint) < (*other as uint)\n+    }\n+    #[inline]\n+    fn le(&self, other: &*T) -> bool {\n+        (*self as uint) <= (*other as uint)\n+    }\n+    #[inline]\n+    fn ge(&self, other: &*T) -> bool {\n+        (*self as uint) >= (*other as uint)\n+    }\n+    #[inline]\n+    fn gt(&self, other: &*T) -> bool {\n+        (*self as uint) > (*other as uint)\n+    }\n+}\n+\n+#[cfg(not(test))]\n+impl<T> Ord for *mut T {\n     #[inline]\n-    fn lt(&self, other: &*const T) -> bool {\n+    fn lt(&self, other: &*mut T) -> bool {\n         (*self as uint) < (*other as uint)\n     }\n     #[inline]\n-    fn le(&self, other: &*const T) -> bool {\n+    fn le(&self, other: &*mut T) -> bool {\n         (*self as uint) <= (*other as uint)\n     }\n     #[inline]\n-    fn ge(&self, other: &*const T) -> bool {\n+    fn ge(&self, other: &*mut T) -> bool {\n         (*self as uint) >= (*other as uint)\n     }\n     #[inline]\n-    fn gt(&self, other: &*const T) -> bool {\n+    fn gt(&self, other: &*mut T) -> bool {\n         (*self as uint) > (*other as uint)\n     }\n }"}, {"sha": "01269d0d386d9acad78487dbc39e58409fab4532", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -11,17 +11,18 @@\n use cell::Cell;\n use c_str::ToCStr;\n use cast::transmute;\n-use libc::{c_char, size_t, STDERR_FILENO};\n-use io;\n use io::{Writer, WriterUtil};\n+use io;\n+use libc::{c_char, c_void, size_t, STDERR_FILENO};\n use option::{Option, None, Some};\n-use uint;\n+use ptr::RawPtr;\n use rt::env;\n use rt::local::Local;\n use rt::task::Task;\n-use str;\n use str::{OwnedStr, StrSlice};\n+use str;\n use sys;\n+use uint;\n use unstable::raw;\n use vec::ImmutableVector;\n \n@@ -93,28 +94,28 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) {\n static ENABLE_DEBUG: bool = false;\n \n #[inline]\n-unsafe fn debug_borrow<T>(tag: &'static str,\n-                          p: *const T,\n-                          old_bits: uint,\n-                          new_bits: uint,\n-                          filename: *c_char,\n-                          line: size_t) {\n+unsafe fn debug_borrow<T,P:RawPtr<T>>(tag: &'static str,\n+                                      p: P,\n+                                      old_bits: uint,\n+                                      new_bits: uint,\n+                                      filename: *c_char,\n+                                      line: size_t) {\n     //! A useful debugging function that prints a pointer + tag + newline\n     //! without allocating memory.\n \n     if ENABLE_DEBUG && env::debug_borrow() {\n         debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n     }\n \n-    unsafe fn debug_borrow_slow<T>(tag: &'static str,\n-                                   p: *const T,\n-                                   old_bits: uint,\n-                                   new_bits: uint,\n-                                   filename: *c_char,\n-                                   line: size_t) {\n+    unsafe fn debug_borrow_slow<T,P:RawPtr<T>>(tag: &'static str,\n+                                               p: P,\n+                                               old_bits: uint,\n+                                               new_bits: uint,\n+                                               filename: *c_char,\n+                                               line: size_t) {\n         let dbg = STDERR_FILENO as io::fd_t;\n         dbg.write_str(tag);\n-        dbg.write_hex(p as uint);\n+        dbg.write_hex(p.to_uint());\n         dbg.write_str(\" \");\n         dbg.write_hex(old_bits);\n         dbg.write_str(\" \");"}, {"sha": "26a3b95abbee35eba74387371257b5447723e6d0", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -554,6 +554,7 @@ impl Scheduler {\n \n             let current_task: &mut Task = match sched.cleanup_job {\n                 Some(CleanupJob { task: ref task, _ }) => {\n+                    let task_ptr: *~Task = task;\n                     transmute_mut_region(*transmute_mut_unsafe(task))\n                 }\n                 None => {"}, {"sha": "01f57c231dadef53cdab7b5ae1e8b05a6ead16b5", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -343,7 +343,14 @@ impl<A:IterBytes> IterBytes for ~A {\n \n // NB: raw-pointer IterBytes does _not_ dereference\n // to the target; it just gives you the pointer-bytes.\n-impl<A> IterBytes for *const A {\n+impl<A> IterBytes for *A {\n+    #[inline]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+impl<A> IterBytes for *mut A {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)"}, {"sha": "5085f337d4bba216103ddf9f17c1505dca509123", "filename": "src/libstd/util.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -54,8 +54,10 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n         let t: *mut T = &mut tmp;\n \n         // Perform the swap, `&mut` pointers never alias\n-        ptr::copy_nonoverlapping_memory(t, x, 1);\n-        ptr::copy_nonoverlapping_memory(x, y, 1);\n+        let x_raw: *mut T = x;\n+        let y_raw: *mut T = y;\n+        ptr::copy_nonoverlapping_memory(t, x_raw, 1);\n+        ptr::copy_nonoverlapping_memory(x, y_raw, 1);\n         ptr::copy_nonoverlapping_memory(y, t, 1);\n \n         // y and t now point to the same thing, but we need to completely forget `tmp`"}, {"sha": "8cd1b09468d46c721755f9e5cabc95335351be25", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -1122,14 +1122,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      * foreign interop.\n      */\n     #[inline]\n-    fn as_imm_buf<U>(&self,\n-                     /* NB---this CANNOT be const, see below */\n-                     f: &fn(*T, uint) -> U) -> U {\n-        // NB---Do not change the type of s to `&const [T]`.  This is\n-        // unsound.  The reason is that we are going to create immutable pointers\n-        // into `s` and pass them to `f()`, but in fact they are potentially\n-        // pointing at *mutable memory*.  Use `as_mut_buf` instead!\n-\n+    fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U {\n         let s = self.repr();\n         f(s.data, s.len / sys::nonzero_size_of::<T>())\n     }"}, {"sha": "8ae9453cf1113c2cdc07ee7681a3ed023b707b84", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -298,7 +298,10 @@ pub enum pat_ {\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum mutability { m_mutbl, m_imm, m_const, }\n+pub enum mutability {\n+    m_mutbl,\n+    m_imm,\n+}\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum Sigil {"}, {"sha": "ab1bde3a3b9eb357c0089d832c353ff9121e43d9", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -53,7 +53,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteMode,\n     ObsoleteImplicitSelf,\n     ObsoleteLifetimeNotation,\n-    ObsoleteConstManagedPointer,\n     ObsoletePurity,\n     ObsoleteStaticMethod,\n     ObsoleteConstItem,\n@@ -65,6 +64,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteUnsafeExternFn,\n     ObsoletePrivVisibility,\n     ObsoleteTraitFuncVisibility,\n+    ObsoleteConstPointer,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -201,10 +201,6 @@ impl ParserObsoleteMethods for Parser {\n                 \"instead of `&foo/bar`, write `&'foo bar`; instead of \\\n                  `bar/&foo`, write `&bar<'foo>\"\n             ),\n-            ObsoleteConstManagedPointer => (\n-                \"const `@` pointer\",\n-                \"instead of `@const Foo`, write `@Foo`\"\n-            ),\n             ObsoletePurity => (\n                 \"pure function\",\n                 \"remove `pure`\"\n@@ -255,6 +251,11 @@ impl ParserObsoleteMethods for Parser {\n                 \"visibility not necessary\",\n                 \"trait functions inherit the visibility of the trait itself\"\n             ),\n+            ObsoleteConstPointer => (\n+                \"const pointer\",\n+                \"instead of `&const Foo` or `@const Foo`, write `&Foo` or \\\n+                 `@Foo`\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "fe5e98d6036615e4e8b65702d42f39a1de5cf70b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -38,7 +38,7 @@ use ast::{ident, impure_fn, inherited, item, item_, item_static};\n use ast::{item_enum, item_fn, item_foreign_mod, item_impl};\n use ast::{item_mac, item_mod, item_struct, item_trait, item_ty, lit, lit_};\n use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int};\n-use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, Local, m_const};\n+use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, Local};\n use ast::{m_imm, m_mutbl, mac_, mac_invoc_tt, matcher, match_nonterminal};\n use ast::{match_seq, match_tok, method, mt, mul, mutability};\n use ast::{named_field, neg, NodeId, noreturn, not, pat, pat_box, pat_enum};\n@@ -1153,9 +1153,6 @@ impl Parser {\n         if mt.mutbl != m_imm && sigil == OwnedSigil {\n             self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n         }\n-        if mt.mutbl == m_const && sigil == ManagedSigil {\n-            self.obsolete(*self.last_span, ObsoleteConstManagedPointer);\n-        }\n \n         ctor(mt)\n     }\n@@ -1568,7 +1565,8 @@ impl Parser {\n         if self.eat_keyword(keywords::Mut) {\n             m_mutbl\n         } else if self.eat_keyword(keywords::Const) {\n-            m_const\n+            self.obsolete(*self.last_span, ObsoleteConstPointer);\n+            m_imm\n         } else {\n             m_imm\n         }\n@@ -1727,7 +1725,7 @@ impl Parser {\n         } else if *self.token == token::LBRACKET {\n             self.bump();\n             let mutbl = self.parse_mutability();\n-            if mutbl == m_mutbl || mutbl == m_const {\n+            if mutbl == m_mutbl {\n                 self.obsolete(*self.last_span, ObsoleteMutVector);\n             }\n \n@@ -2182,10 +2180,6 @@ impl Parser {\n           token::AT => {\n             self.bump();\n             let m = self.parse_mutability();\n-            if m == m_const {\n-                self.obsolete(*self.last_span, ObsoleteConstManagedPointer);\n-            }\n-\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n             // HACK: turn @[...] into a @-evec"}, {"sha": "ee9b2f4760dbfe2306e853de227bb9d265f1d692", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -386,7 +386,6 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n         word(s.s, \"[\");\n         match mt.mutbl {\n           ast::m_mutbl => word_space(s, \"mut\"),\n-          ast::m_const => word_space(s, \"const\"),\n           ast::m_imm => ()\n         }\n         print_type(s, mt.ty);\n@@ -429,7 +428,6 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n         word(s.s, \"[\");\n         match mt.mutbl {\n             ast::m_mutbl => word_space(s, \"mut\"),\n-            ast::m_const => word_space(s, \"const\"),\n             ast::m_imm => ()\n         }\n         print_type(s, mt.ty);\n@@ -1882,7 +1880,6 @@ pub fn print_view_item(s: @ps, item: &ast::view_item) {\n pub fn print_mutability(s: @ps, mutbl: ast::mutability) {\n     match mutbl {\n       ast::m_mutbl => word_nbsp(s, \"mut\"),\n-      ast::m_const => word_nbsp(s, \"const\"),\n       ast::m_imm => {/* nothing */ }\n     }\n }"}, {"sha": "c51cf5b9538d9309a45cbcb2583e1dc2854f2071", "filename": "src/test/compile-fail/borrowck-alias-mut-base-ptr.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -1,15 +0,0 @@\n-// Test that attempt to alias `&mut` pointer while pointee is borrowed\n-// yields an error.\n-//\n-// Example from src/middle/borrowck/doc.rs\n-\n-use std::util::swap;\n-\n-fn foo(t0: &mut int) {\n-    let p: &int = &*t0; // Freezes `*t0`\n-    let q: &const &mut int = &const t0; //~ ERROR cannot borrow `t0`\n-    **q = 22; //~ ERROR cannot assign to an `&mut` in a `&const` pointer\n-}\n-\n-fn main() {\n-}\n\\ No newline at end of file"}, {"sha": "843b5436d842c7c89322641dc8c0c70a501df5ef", "filename": "src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -11,21 +11,11 @@ fn foo(t0: & &mut int) {\n     **t1 = 22; //~ ERROR cannot assign\n }\n \n-fn foo2(t0: &const &mut int) {\n-    // Note: reborrowing from an &const actually yields two errors, since it\n-    // is unsafe in two ways: we can't control the aliasing, and we can't\n-    // control the mutation.\n-    let t1 = t0;\n-    let p: &int = &**t0; //~ ERROR cannot borrow an `&mut` in a `&const` pointer\n-    //~^ ERROR unsafe borrow of aliasable, const value\n-    **t1 = 22; //~ ERROR cannot assign\n-}\n-\n fn foo3(t0: &mut &mut int) {\n     let t1 = &mut *t0;\n     let p: &int = &**t0; //~ ERROR cannot borrow\n     **t1 = 22;\n }\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "537e52120d9f1f2c02712f0037ec5aaf6dc55d65", "filename": "src/test/compile-fail/borrowck-call-method-from-mut-aliasable.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -14,29 +14,18 @@ struct Foo {\n \n impl Foo {\n     pub fn f(&self) {}\n-    pub fn g(&const self) {}\n     pub fn h(&mut self) {}\n }\n \n fn a(x: &mut Foo) {\n     x.f();\n-    x.g();\n     x.h();\n }\n \n fn b(x: &Foo) {\n     x.f();\n-    x.g();\n     x.h(); //~ ERROR cannot borrow\n }\n \n-fn c(x: &const Foo) {\n-    x.f(); //~ ERROR cannot borrow\n-    //~^ ERROR unsafe borrow\n-    x.g();\n-    x.h(); //~ ERROR cannot borrow\n-    //~^ ERROR unsafe borrow\n-}\n-\n fn main() {\n }"}, {"sha": "ea840a28b4e6ac97efd6fe7ebb3af8bbcbe691a9", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -32,14 +32,6 @@ fn pre_freeze() {\n     borrow_mut(v); //~ ERROR cannot borrow\n }\n \n-fn pre_const() {\n-    // In this instance, the freeze starts before the mut borrow.\n-\n-    let mut v = ~3;\n-    let _w = &const v;\n-    borrow_mut(v);\n-}\n-\n fn post_freeze() {\n     // In this instance, the const alias starts after the borrow.\n "}, {"sha": "8a4a2cdedb23095987208afbdf2383b9e9c1722f", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -29,16 +29,5 @@ fn has_mut_vec_but_tries_to_change_it() {\n     }\n }\n \n-fn takes_const_elt(_v: &const int, f: &fn()) {\n-    f();\n-}\n-\n-fn has_mut_vec_and_tries_to_change_it() {\n-    let mut v = ~[1, 2, 3];\n-    do takes_const_elt(&const v[0]) {\n-        v[1] = 4;\n-    }\n-}\n-\n fn main() {\n }"}, {"sha": "e77f5245d7d8bb14906e6343d1d918599c2e58e2", "filename": "src/test/compile-fail/borrowck-pat-by-value-binding.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn process<T>(_t: T) {}\n-\n-fn match_const_opt_by_mut_ref(v: &const Option<int>) {\n-    match *v {\n-      Some(ref mut i) => process(i), //~ ERROR cannot borrow\n-        //~^ ERROR unsafe borrow of aliasable, const value\n-      None => ()\n-    }\n-}\n-\n-fn match_const_opt_by_const_ref(v: &const Option<int>) {\n-    match *v {\n-      Some(ref const i) => process(i),\n-        //~^ ERROR unsafe borrow of aliasable, const value\n-      None => ()\n-    }\n-}\n-\n-fn match_const_opt_by_imm_ref(v: &const Option<int>) {\n-    match *v {\n-      Some(ref i) => process(i), //~ ERROR cannot borrow\n-        //~^ ERROR unsafe borrow of aliasable, const value\n-      None => ()\n-    }\n-}\n-\n-fn match_const_opt_by_value(v: &const Option<int>) {\n-    match *v {\n-      Some(i) => process(i),\n-      None => ()\n-    }\n-}\n-\n-fn main() {\n-}"}, {"sha": "c87428cd300a7ab47bdcb7ca2dc4cac3d0397660", "filename": "src/test/compile-fail/borrowck-uniq-via-lend.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -35,12 +35,6 @@ fn aliased_imm() {\n     borrow(v);\n }\n \n-fn aliased_const() {\n-    let mut v = ~3;\n-    let _w = &const v;\n-    borrow(v);\n-}\n-\n fn aliased_mut() {\n     let mut v = ~3;\n     let _w = &mut v;"}, {"sha": "e42c6b658e4f7b87b5307935c361bc1702e3f940", "filename": "src/test/compile-fail/fn-variance-3.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -23,13 +23,10 @@ fn main() {\n \n     // @int <: X\n     //\n-    // This constraint forces X to be\n-    // @const int.\n-    r(@3);\n+    // Here the type check fails because @const is gone and there is no\n+    // supertype.\n+    r(@3);  //~ ERROR mismatched types\n \n-    // Here the type check succeeds but the\n-    // mutability check will fail, because the\n-    // type of r has been inferred to be\n-    // fn(@const int) -> @const int\n-    *r(@mut 3) = 4; //~ ERROR cannot assign to const dereference of @ pointer\n+    // Here the type check succeeds.\n+    *r(@mut 3) = 4;\n }"}, {"sha": "b60a54a44bbfdf853fe8874151597b6688813439", "filename": "src/test/compile-fail/issue-3969.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Bike {\n-    name: ~str,\n-}\n-\n-trait BikeMethods {\n-    fn woops(&const self) -> ~str;\n-}\n-\n-impl BikeMethods for Bike {\n-    fn woops() -> ~str { ~\"foo\" }\n-    //~^ ERROR has a `&const self` declaration in the trait, but not in the impl\n-}\n-\n-pub fn main() {\n-}"}, {"sha": "4460da72e205993ac9e03025a6a9e126502079a0", "filename": "src/test/compile-fail/mutable-huh-ptr-assign.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs?ref=58d6eb50483c44ecc72db6d77b71ad5d5a7aca4d", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern mod extra;\n-\n-fn main() {\n-    unsafe fn f(v: *const int) {\n-        *v = 1 //~ ERROR cannot assign\n-    }\n-\n-    unsafe {\n-        let mut a = 0;\n-        let v = &mut a;\n-        f(v);\n-    }\n-}"}, {"sha": "351daf461d2fea5bfbaf26ca1cbb923c7bb501d6", "filename": "src/test/compile-fail/resolve-inconsistent-binding-mode.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -26,13 +26,6 @@ fn matcher2(x: opts) {\n     }\n }\n \n-fn matcher3(x: opts) {\n-    match x {\n-      a(ref mut i) | b(ref const i) => {} //~ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n-      c(_) => {}\n-    }\n-}\n-\n fn matcher4(x: opts) {\n     match x {\n       a(ref mut i) | b(ref i) => {} //~ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1"}, {"sha": "d35341516f2a73d5b3ab86420cdd5e65587e2d9e", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -13,17 +13,14 @@\n \n trait MyIter {\n     fn test_imm(&self);\n-    fn test_const(&const self);\n }\n \n impl<'self> MyIter for &'self [int] {\n     fn test_imm(&self) { assert_eq!(self[0], 1) }\n-    fn test_const(&const self) { assert_eq!(self[0], 1) }\n }\n \n impl<'self> MyIter for &'self str {\n     fn test_imm(&self) { assert_eq!(*self, \"test\") }\n-    fn test_const(&const self) { assert_eq!(self[0], 't' as u8) }\n }\n \n pub fn main() {\n@@ -40,15 +37,6 @@ pub fn main() {\n \n     // XXX: Other types of mutable vecs don't currently exist\n \n-    ([1]).test_const();\n-    (~[1]).test_const();\n-    (@[1]).test_const();\n-    (&[1]).test_const();\n-    (\"test\").test_const();\n-    (~\"test\").test_const();\n-    (@\"test\").test_const();\n-    (&\"test\").test_const();\n-\n     // NB: We don't do this double autoreffing for &mut self because that would\n     // allow creating a mutable pointer to a temporary, which would be a source\n     // of confusion"}, {"sha": "fc643ec594089a4cc62f9eca2343f6e4afc6ee01", "filename": "src/test/run-pass/autoderef-and-borrow-method-receiver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -13,7 +13,7 @@ struct Foo {\n }\n \n impl Foo {\n-    pub fn f(&const self) {}\n+    pub fn f(&self) {}\n }\n \n fn g(x: &mut Foo) {"}, {"sha": "6c00bea28b6e3b6e5ab6d1d02acee0c71b0b9d8c", "filename": "src/test/run-pass/borrowck-pat-enum.rs", "status": "renamed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -24,32 +24,9 @@ fn match_ref_unused(v: Option<int>) {\n     }\n }\n \n-fn match_const_reg(v: &const Option<int>) -> int {\n-    match *v {\n-      Some(ref i) => {*i} //~ ERROR cannot borrow\n-        //~^ ERROR unsafe borrow\n-      None => {0}\n-    }\n-}\n-\n fn impure(_i: int) {\n }\n \n-fn match_const_reg_unused(v: &const Option<int>) {\n-    match *v {\n-      Some(_) => {impure(0)} // OK because nothing is captured\n-      None => {}\n-    }\n-}\n-\n-fn match_const_reg_impure(v: &const Option<int>) {\n-    match *v {\n-      Some(ref i) => {impure(*i)} //~ ERROR cannot borrow\n-        //~^ ERROR unsafe borrow\n-      None => {}\n-    }\n-}\n-\n fn match_imm_reg(v: &Option<int>) {\n     match *v {\n       Some(ref i) => {impure(*i)} // OK because immutable", "previous_filename": "src/test/compile-fail/borrowck-pat-enum.rs"}, {"sha": "44f3a8f518a15c44273230efbb3f8c8de49bb770", "filename": "src/test/run-pass/borrowck-uniq-via-ref.rs", "status": "renamed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-uniq-via-ref.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -25,7 +25,6 @@ struct Innermost {\n }\n \n fn borrow(_v: &int) {}\n-fn borrow_const(_v: &const int) {}\n \n fn box_mut(v: &mut ~int) {\n     borrow(*v); // OK: &mut -> &imm\n@@ -51,17 +50,5 @@ fn box_imm_recs(v: &Outer) {\n     borrow(v.f.g.h); // OK\n }\n \n-fn box_const(v: &const ~int) {\n-    borrow_const(*v); //~ ERROR unsafe borrow\n-}\n-\n-fn box_const_rec(v: &const Rec) {\n-    borrow_const(v.f); //~ ERROR unsafe borrow\n-}\n-\n-fn box_const_recs(v: &const Outer) {\n-    borrow_const(v.f.g.h); //~ ERROR unsafe borrow\n-}\n-\n fn main() {\n }", "previous_filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs"}, {"sha": "03dd33b08e2350fe167a8421038f78678ebab177", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -49,8 +49,8 @@ impl<T> cat<T> {\n }\n \n impl<T> Container for cat<T> {\n-    fn len(&const self) -> uint { self.meows as uint }\n-    fn is_empty(&const self) -> bool { self.meows == 0 }\n+    fn len(&self) -> uint { self.meows as uint }\n+    fn is_empty(&self) -> bool { self.meows == 0 }\n }\n \n impl<T> Mutable for cat<T> {"}, {"sha": "52fa1399363cdf4de434167400dce4ee8bbb49c3", "filename": "src/test/run-pass/coerce-reborrow-imm-ptr-rcvr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -3,14 +3,14 @@ struct SpeechMaker {\n }\n \n impl SpeechMaker {\n-    pub fn how_many(&const self) -> uint { self.speeches }\n+    pub fn how_many(&self) -> uint { self.speeches }\n }\n \n-fn foo(speaker: &const SpeechMaker) -> uint {\n+fn foo(speaker: &SpeechMaker) -> uint {\n     speaker.how_many() + 33\n }\n \n pub fn main() {\n     let lincoln = SpeechMaker {speeches: 22};\n-    assert_eq!(foo(&const lincoln), 55);\n+    assert_eq!(foo(&lincoln), 55);\n }"}, {"sha": "84ee54cfdde6d548203c8ba43e7b09f61f17ad27", "filename": "src/test/run-pass/const-vec-syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fconst-vec-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3504799deb78d986f8267f753a87fb9e73a452/src%2Ftest%2Frun-pass%2Fconst-vec-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-syntax.rs?ref=5c3504799deb78d986f8267f753a87fb9e73a452", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(_: &const [int]) {}\n+fn f(_: &[int]) {}\n \n pub fn main() {\n     let v = [ 1, 2, 3 ];"}]}