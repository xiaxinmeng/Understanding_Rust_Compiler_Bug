{"sha": "d052d28d70b31fac942765da137f794835e6536e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNTJkMjhkNzBiMzFmYWM5NDI3NjVkYTEzN2Y3OTQ4MzVlNjUzNmU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-11-29T09:05:31Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-12-13T21:33:03Z"}, "message": "Improve interaction between macros 2.0 and `macro_rules!`.", "tree": {"sha": "b339c73c8f824f39bab9aa06dc785964f46e917d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b339c73c8f824f39bab9aa06dc785964f46e917d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d052d28d70b31fac942765da137f794835e6536e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d052d28d70b31fac942765da137f794835e6536e", "html_url": "https://github.com/rust-lang/rust/commit/d052d28d70b31fac942765da137f794835e6536e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d052d28d70b31fac942765da137f794835e6536e/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dfbc88a626625be01e112da11ec367e2fc71bb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dfbc88a626625be01e112da11ec367e2fc71bb3", "html_url": "https://github.com/rust-lang/rust/commit/3dfbc88a626625be01e112da11ec367e2fc71bb3"}], "stats": {"total": 135, "additions": 126, "deletions": 9}, "files": [{"sha": "22f788e34ecff143f74cf7e8a46f75c95931559c", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d052d28d70b31fac942765da137f794835e6536e/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d052d28d70b31fac942765da137f794835e6536e/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=d052d28d70b31fac942765da137f794835e6536e", "patch": "@@ -95,7 +95,7 @@ impl FromStr for TokenStream {\n             // notify the expansion info that it is unhygienic\n             let mark = Mark::fresh(mark);\n             mark.set_expn_info(expn_info);\n-            let span = call_site.with_ctxt(call_site.ctxt().apply_mark(mark));\n+            let span = call_site.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n             let stream = parse::parse_stream_from_source_str(name, src, sess, Some(span));\n             Ok(__internal::token_stream_wrap(stream))\n         })"}, {"sha": "21b5bb6a97180d3fadf5d91f5f006db3e754326d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d052d28d70b31fac942765da137f794835e6536e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d052d28d70b31fac942765da137f794835e6536e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d052d28d70b31fac942765da137f794835e6536e", "patch": "@@ -156,7 +156,7 @@ impl<'a> Resolver<'a> {\n \n                     // Disallow `use $crate;`\n                     if source.name == keywords::DollarCrate.name() && path.segments.len() == 1 {\n-                        let crate_root = self.resolve_crate_root(source.ctxt);\n+                        let crate_root = self.resolve_crate_root(source.ctxt, true);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(_, name) => name,\n                             ModuleKind::Block(..) => unreachable!(),"}, {"sha": "2a97df920926093dac4d3bddb67b68ea576e9b25", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d052d28d70b31fac942765da137f794835e6536e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d052d28d70b31fac942765da137f794835e6536e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d052d28d70b31fac942765da137f794835e6536e", "patch": "@@ -42,7 +42,7 @@ use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n use syntax::codemap::{dummy_spanned, respan};\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::{Mark, MarkKind, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n@@ -1775,8 +1775,17 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn resolve_crate_root(&mut self, mut ctxt: SyntaxContext) -> Module<'a> {\n-        let module = match ctxt.adjust(Mark::root()) {\n+    fn resolve_crate_root(&mut self, mut ctxt: SyntaxContext, legacy: bool) -> Module<'a> {\n+        let mark = if legacy {\n+            // When resolving `$crate` from a `macro_rules!` invoked in a `macro`,\n+            // we don't want to pretend that the `macro_rules!` definition is in the `macro`\n+            // as described in `SyntaxContext::apply_mark`, so we ignore prepended modern marks.\n+            ctxt.marks().into_iter().find(|&mark| mark.kind() != MarkKind::Modern)\n+        } else {\n+            ctxt = ctxt.modern();\n+            ctxt.adjust(Mark::root())\n+        };\n+        let module = match mark {\n             Some(def) => self.macro_def_scope(def),\n             None => return self.graph_root,\n         };\n@@ -2961,11 +2970,11 @@ impl<'a> Resolver<'a> {\n                    (i == 1 && name == keywords::Crate.name() &&\n                               path[0].node.name == keywords::CrateRoot.name()) {\n                     // `::a::b` or `::crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident.node.ctxt.modern()));\n+                    module = Some(self.resolve_crate_root(ident.node.ctxt, false));\n                     continue\n                 } else if i == 0 && name == keywords::DollarCrate.name() {\n                     // `$crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident.node.ctxt));\n+                    module = Some(self.resolve_crate_root(ident.node.ctxt, true));\n                     continue\n                 } else if i == 1 && self.session.features.borrow().extern_absolute_paths &&\n                                     path[0].node.name == keywords::CrateRoot.name() &&"}, {"sha": "fe6bbf45d9fd05f97b405519b1503f8fe5d9f263", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d052d28d70b31fac942765da137f794835e6536e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d052d28d70b31fac942765da137f794835e6536e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=d052d28d70b31fac942765da137f794835e6536e", "patch": "@@ -140,7 +140,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 let ident = path.segments[0].identifier;\n                 if ident.name == keywords::DollarCrate.name() {\n                     path.segments[0].identifier.name = keywords::CrateRoot.name();\n-                    let module = self.0.resolve_crate_root(ident.ctxt);\n+                    let module = self.0.resolve_crate_root(ident.ctxt, true);\n                     if !module.is_local() {\n                         let span = path.segments[0].span;\n                         path.segments.insert(1, match module.kind {"}, {"sha": "4fd801707853de8f1080dc1a384dc87c0d5a59f2", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d052d28d70b31fac942765da137f794835e6536e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d052d28d70b31fac942765da137f794835e6536e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=d052d28d70b31fac942765da137f794835e6536e", "patch": "@@ -620,7 +620,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                          \"crate root imports need to be explicitly named: \\\n                                           `use crate as name;`\".to_string()));\n                         } else {\n-                            Some(self.resolve_crate_root(source.ctxt.modern()))\n+                            Some(self.resolve_crate_root(source.ctxt.modern(), false))\n                         }\n                     } else if extern_absolute_paths &&\n                               !token::Ident(source).is_path_segment_keyword() {"}, {"sha": "23c29e6c6dd7b800a13882feab0d5647b946f3cb", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d052d28d70b31fac942765da137f794835e6536e/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d052d28d70b31fac942765da137f794835e6536e/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=d052d28d70b31fac942765da137f794835e6536e", "patch": "@@ -181,6 +181,33 @@ impl SyntaxContext {\n \n     /// Extend a syntax context with a given mark\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n+        if mark.kind() == MarkKind::Modern {\n+            return self.apply_mark_internal(mark);\n+        }\n+\n+        let call_site_ctxt =\n+            mark.expn_info().map_or(SyntaxContext::empty(), |info| info.call_site.ctxt()).modern();\n+        if call_site_ctxt == SyntaxContext::empty() {\n+            return self.apply_mark_internal(mark);\n+        }\n+\n+        // Otherwise, `mark` is a macros 1.0 definition and the call site is in a\n+        // macros 2.0 expansion, i.e. a macros 1.0 invocation is in a macros 2.0 definition.\n+        //\n+        // In this case, the tokens from the macros 1.0 definition inherit the hygiene\n+        // at their invocation. That is, we pretend that the macros 1.0 definition\n+        // was defined at its invocation (i.e. inside the macros 2.0 definition)\n+        // so that the macros 2.0 definition remains hygienic.\n+        //\n+        // See the example at `test/run-pass/hygiene/legacy_interaction.rs`.\n+        let mut ctxt = call_site_ctxt;\n+        for mark in self.marks() {\n+            ctxt = ctxt.apply_mark_internal(mark);\n+        }\n+        ctxt.apply_mark_internal(mark)\n+    }\n+\n+    fn apply_mark_internal(self, mark: Mark) -> SyntaxContext {\n         HygieneData::with(|data| {\n             let syntax_contexts = &mut data.syntax_contexts;\n             let mut modern = syntax_contexts[self.0 as usize].modern;\n@@ -215,6 +242,18 @@ impl SyntaxContext {\n         })\n     }\n \n+    pub fn marks(mut self) -> Vec<Mark> {\n+        HygieneData::with(|data| {\n+            let mut marks = Vec::new();\n+            while self != SyntaxContext::empty() {\n+                marks.push(data.syntax_contexts[self.0 as usize].outer_mark);\n+                self = data.syntax_contexts[self.0 as usize].prev_ctxt;\n+            }\n+            marks.reverse();\n+            marks\n+        })\n+    }\n+\n     /// Adjust this context for resolution in a scope created by the given expansion.\n     /// For example, consider the following three resolutions of `f`:\n     /// ```rust"}, {"sha": "c614ee4d57501b3eb31b6165f74420962c22e463", "filename": "src/test/run-pass/hygiene/auxiliary/legacy_interaction.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d052d28d70b31fac942765da137f794835e6536e/src%2Ftest%2Frun-pass%2Fhygiene%2Fauxiliary%2Flegacy_interaction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d052d28d70b31fac942765da137f794835e6536e/src%2Ftest%2Frun-pass%2Fhygiene%2Fauxiliary%2Flegacy_interaction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Fauxiliary%2Flegacy_interaction.rs?ref=d052d28d70b31fac942765da137f794835e6536e", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#[macro_export]\n+macro_rules! m {\n+    () => {\n+        fn f() {} // (2)\n+        g(); // (1)\n+    }\n+}"}, {"sha": "683a15b99aebea3116acb55803ee22c192ff0b8d", "filename": "src/test/run-pass/hygiene/legacy_interaction.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d052d28d70b31fac942765da137f794835e6536e/src%2Ftest%2Frun-pass%2Fhygiene%2Flegacy_interaction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d052d28d70b31fac942765da137f794835e6536e/src%2Ftest%2Frun-pass%2Fhygiene%2Flegacy_interaction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Flegacy_interaction.rs?ref=d052d28d70b31fac942765da137f794835e6536e", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+// aux-build:legacy_interaction.rs\n+\n+#![feature(decl_macro)]\n+#[allow(unused)]\n+\n+extern crate legacy_interaction;\n+// ^ defines\n+// ```rust\n+//  macro_rules! m {\n+//     () => {\n+//         fn f() // (1)\n+//         g() // (2)\n+//     }\n+// }\n+// ```rust\n+\n+mod def_site {\n+    // Unless this macro opts out of hygiene, it should resolve the same wherever it is invoked.\n+    pub macro m2() {\n+        ::legacy_interaction::m!();\n+        f(); // This should resolve to (1)\n+        fn g() {} // We want (2) resolve to this, not to (4)\n+    }\n+}\n+\n+mod use_site {\n+    fn test() {\n+        fn f() -> bool { true } // (3)\n+        fn g() -> bool { true } // (4)\n+\n+        ::def_site::m2!();\n+\n+        let _: bool = f(); // This should resolve to (3)\n+        let _: bool = g(); // This should resolve to (4)\n+    }\n+}\n+\n+fn main() {}"}]}