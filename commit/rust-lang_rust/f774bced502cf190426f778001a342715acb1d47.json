{"sha": "f774bced502cf190426f778001a342715acb1d47", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NzRiY2VkNTAyY2YxOTA0MjZmNzc4MDAxYTM0MjcxNWFjYjFkNDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-12T19:40:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-12T19:40:49Z"}, "message": "Auto merge of #43724 - lukaramu:std-ops-docs, r=QuietMisdreavus\n\nImprove std::ops docs\n\nFixes #29365. (This fixes all but one point from @steveklabnik's list, but that point was referring to examples of implementing range traits, but there are no range traits in std::ops.)\n\nThe main changes are quite a bit of copyediting, adding more \"real\" examples for some of the traits, incorporating some guidance from the API docs, more linking (cross-docs and to the book & reference), cleaning up examples, moving things around, and so on. Refer to the commit messages for more details.\n\nNote: I decided to link to the second edition of the book since I think it's more appropriate now for the sections I linked, if this is not okay, please say so!", "tree": {"sha": "00edb67e2b56034d186a73b95852a8c1798c42ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00edb67e2b56034d186a73b95852a8c1798c42ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f774bced502cf190426f778001a342715acb1d47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f774bced502cf190426f778001a342715acb1d47", "html_url": "https://github.com/rust-lang/rust/commit/f774bced502cf190426f778001a342715acb1d47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f774bced502cf190426f778001a342715acb1d47/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0269acbb10bc7a5b083a5daf095ff391e21ee4e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0269acbb10bc7a5b083a5daf095ff391e21ee4e9", "html_url": "https://github.com/rust-lang/rust/commit/0269acbb10bc7a5b083a5daf095ff391e21ee4e9"}, {"sha": "6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "html_url": "https://github.com/rust-lang/rust/commit/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1"}], "stats": {"total": 1144, "additions": 615, "deletions": 529}, "files": [{"sha": "62007caedd3fc425f6c50f05f7fb9a71dce18f01", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 120, "deletions": 182, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=f774bced502cf190426f778001a342715acb1d47", "patch": "@@ -10,15 +10,20 @@\n \n /// The addition operator `+`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory. For\n+/// example, [`std::time::SystemTime`] implements `Add<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime + Duration`.\n+///\n+/// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n+///\n /// # Examples\n ///\n-/// This example creates a `Point` struct that implements the `Add` trait, and\n-/// then demonstrates adding two `Point`s.\n+/// ## `Add`able points\n ///\n /// ```\n /// use std::ops::Add;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -35,31 +40,25 @@\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n-///                Point { x: 3, y: 3 });\n-/// }\n+/// assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///            Point { x: 3, y: 3 });\n /// ```\n ///\n+/// ## Implementing `Add` with generics\n+///\n /// Here is an example of the same `Point` struct implementing the `Add` trait\n /// using generics.\n ///\n /// ```\n /// use std::ops::Add;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point<T> {\n ///     x: T,\n ///     y: T,\n /// }\n ///\n-/// // Notice that the implementation uses the `Output` associated type\n+/// // Notice that the implementation uses the associated type `Output`.\n /// impl<T: Add<Output=T>> Add for Point<T> {\n ///     type Output = Point<T>;\n ///\n@@ -71,32 +70,18 @@\n ///     }\n /// }\n ///\n-/// impl<T: PartialEq> PartialEq for Point<T> {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n-///                Point { x: 3, y: 3 });\n-/// }\n+/// assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///            Point { x: 3, y: 3 });\n /// ```\n-///\n-/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n-/// [std::time::SystemTime] implements `Add<Duration>`, which permits\n-/// operations of the form `SystemTime = SystemTime + Duration`.\n-///\n-/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n #[lang = \"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} + {RHS}`\"]\n pub trait Add<RHS=Self> {\n-    /// The resulting type after applying the `+` operator\n+    /// The resulting type after applying the `+` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `+` operator\n+    /// Performs the `+` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn add(self, rhs: RHS) -> Self::Output;\n }\n@@ -120,15 +105,20 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The subtraction operator `-`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory. For\n+/// example, [`std::time::SystemTime`] implements `Sub<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime - Duration`.\n+///\n+/// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n+///\n /// # Examples\n ///\n-/// This example creates a `Point` struct that implements the `Sub` trait, and\n-/// then demonstrates subtracting two `Point`s.\n+/// ## `Sub`tractable points\n ///\n /// ```\n /// use std::ops::Sub;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -145,31 +135,25 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n-///                Point { x: 1, y: 0 });\n-/// }\n+/// assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n+///            Point { x: 1, y: 0 });\n /// ```\n ///\n+/// ## Implementing `Sub` with generics\n+///\n /// Here is an example of the same `Point` struct implementing the `Sub` trait\n /// using generics.\n ///\n /// ```\n /// use std::ops::Sub;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point<T> {\n ///     x: T,\n ///     y: T,\n /// }\n ///\n-/// // Notice that the implementation uses the `Output` associated type\n+/// // Notice that the implementation uses the associated type `Output`.\n /// impl<T: Sub<Output=T>> Sub for Point<T> {\n ///     type Output = Point<T>;\n ///\n@@ -181,32 +165,18 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl<T: PartialEq> PartialEq for Point<T> {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 2, y: 3 } - Point { x: 1, y: 0 },\n-///                Point { x: 1, y: 3 });\n-/// }\n+/// assert_eq!(Point { x: 2, y: 3 } - Point { x: 1, y: 0 },\n+///            Point { x: 1, y: 3 });\n /// ```\n-///\n-/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n-/// [std::time::SystemTime] implements `Sub<Duration>`, which permits\n-/// operations of the form `SystemTime = SystemTime - Duration`.\n-///\n-/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n #[lang = \"sub\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} - {RHS}`\"]\n pub trait Sub<RHS=Self> {\n-    /// The resulting type after applying the `-` operator\n+    /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `-` operator\n+    /// Performs the `-` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sub(self, rhs: RHS) -> Self::Output;\n }\n@@ -230,17 +200,19 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The multiplication operator `*`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// Implementing a `Mul`tipliable rational number struct:\n+/// ## `Mul`tipliable rational numbers\n ///\n /// ```\n /// use std::ops::Mul;\n ///\n-/// // The uniqueness of rational numbers in lowest terms is a consequence of\n-/// // the fundamental theorem of arithmetic.\n-/// #[derive(Eq)]\n-/// #[derive(PartialEq, Debug)]\n+/// // By the fundamental theorem of arithmetic, rational numbers in lowest\n+/// // terms are unique. So, by keeping `Rational`s in reduced form, we can\n+/// // derive `Eq` and `PartialEq`.\n+/// #[derive(Debug, Eq, PartialEq)]\n /// struct Rational {\n ///     nominator: usize,\n ///     denominator: usize,\n@@ -291,45 +263,37 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///            Rational::new(1, 2));\n /// ```\n ///\n-/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n-/// implementation which enables multiplication of vectors by scalars, as is\n-/// done in linear algebra.\n+/// ## Multiplying vectors by scalars as in linear algebra\n ///\n /// ```\n /// use std::ops::Mul;\n ///\n-/// struct Scalar {value: usize};\n+/// struct Scalar { value: usize }\n ///\n-/// #[derive(Debug)]\n-/// struct Vector {value: Vec<usize>};\n+/// #[derive(Debug, PartialEq)]\n+/// struct Vector { value: Vec<usize> }\n ///\n-/// impl Mul<Vector> for Scalar {\n+/// impl Mul<Scalar> for Vector {\n ///     type Output = Vector;\n ///\n-///     fn mul(self, rhs: Vector) -> Vector {\n-///         Vector {value: rhs.value.iter().map(|v| self.value * v).collect()}\n+///     fn mul(self, rhs: Scalar) -> Vector {\n+///         Vector { value: self.value.iter().map(|v| v * rhs.value).collect() }\n ///     }\n /// }\n ///\n-/// impl PartialEq<Vector> for Vector {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.value == other.value\n-///     }\n-/// }\n-///\n-/// let scalar = Scalar{value: 3};\n-/// let vector = Vector{value: vec![2, 4, 6]};\n-/// assert_eq!(scalar * vector, Vector{value: vec![6, 12, 18]});\n+/// let vector = Vector { value: vec![2, 4, 6] };\n+/// let scalar = Scalar { value: 3 };\n+/// assert_eq!(vector * scalar, Vector { value: vec![6, 12, 18] });\n /// ```\n #[lang = \"mul\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} * {RHS}`\"]\n pub trait Mul<RHS=Self> {\n-    /// The resulting type after applying the `*` operator\n+    /// The resulting type after applying the `*` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `*` operator\n+    /// Performs the `*` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n@@ -353,17 +317,19 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The division operator `/`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// Implementing a `Div`idable rational number struct:\n+/// ## `Div`idable rational numbers\n ///\n /// ```\n /// use std::ops::Div;\n ///\n-/// // The uniqueness of rational numbers in lowest terms is a consequence of\n-/// // the fundamental theorem of arithmetic.\n-/// #[derive(Eq)]\n-/// #[derive(PartialEq, Debug)]\n+/// // By the fundamental theorem of arithmetic, rational numbers in lowest\n+/// // terms are unique. So, by keeping `Rational`s in reduced form, we can\n+/// // derive `Eq` and `PartialEq`.\n+/// #[derive(Debug, Eq, PartialEq)]\n /// struct Rational {\n ///     nominator: usize,\n ///     denominator: usize,\n@@ -413,52 +379,42 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     x\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n-///     assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n-///                Rational::new(2, 3));\n-/// }\n+/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n+/// assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n+///            Rational::new(2, 3));\n /// ```\n ///\n-/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n-/// implementation which enables division of vectors by scalars, as is done in\n-/// linear algebra.\n+/// ## Dividing vectors by scalars as in linear algebra\n ///\n /// ```\n /// use std::ops::Div;\n ///\n-/// struct Scalar {value: f32};\n+/// struct Scalar { value: f32 }\n ///\n-/// #[derive(Debug)]\n-/// struct Vector {value: Vec<f32>};\n+/// #[derive(Debug, PartialEq)]\n+/// struct Vector { value: Vec<f32> }\n ///\n /// impl Div<Scalar> for Vector {\n ///     type Output = Vector;\n ///\n ///     fn div(self, rhs: Scalar) -> Vector {\n-///         Vector {value: self.value.iter().map(|v| v / rhs.value).collect()}\n-///     }\n-/// }\n-///\n-/// impl PartialEq<Vector> for Vector {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.value == other.value\n+///         Vector { value: self.value.iter().map(|v| v / rhs.value).collect() }\n ///     }\n /// }\n ///\n-/// let scalar = Scalar{value: 2f32};\n-/// let vector = Vector{value: vec![2f32, 4f32, 6f32]};\n-/// assert_eq!(vector / scalar, Vector{value: vec![1f32, 2f32, 3f32]});\n+/// let scalar = Scalar { value: 2f32 };\n+/// let vector = Vector { value: vec![2f32, 4f32, 6f32] };\n+/// assert_eq!(vector / scalar, Vector { value: vec![1f32, 2f32, 3f32] });\n /// ```\n #[lang = \"div\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} / {RHS}`\"]\n pub trait Div<RHS=Self> {\n-    /// The resulting type after applying the `/` operator\n+    /// The resulting type after applying the `/` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `/` operator\n+    /// Performs the `/` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n@@ -499,6 +455,8 @@ div_impl_float! { f32 f64 }\n \n /// The remainder operator `%`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n /// This example implements `Rem` on a `SplitSlice` object. After `Rem` is\n@@ -526,19 +484,19 @@ div_impl_float! { f32 f64 }\n /// }\n ///\n /// // If we were to divide &[0, 1, 2, 3, 4, 5, 6, 7] into slices of size 3,\n-/// // the remainder would be &[6, 7]\n+/// // the remainder would be &[6, 7].\n /// assert_eq!(SplitSlice { slice: &[0, 1, 2, 3, 4, 5, 6, 7] } % 3,\n ///            SplitSlice { slice: &[6, 7] });\n /// ```\n #[lang = \"rem\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} % {RHS}`\"]\n pub trait Rem<RHS=Self> {\n-    /// The resulting type after applying the `%` operator\n+    /// The resulting type after applying the `%` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output = Self;\n \n-    /// The method for the `%` operator\n+    /// Performs the `%` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rem(self, rhs: RHS) -> Self::Output;\n }\n@@ -607,21 +565,21 @@ rem_impl_float! { f32 f64 }\n ///     }\n /// }\n ///\n-/// // a negative positive is a negative\n+/// // A negative positive is a negative.\n /// assert_eq!(-Sign::Positive, Sign::Negative);\n-/// // a double negative is a positive\n+/// // A double negative is a positive.\n /// assert_eq!(-Sign::Negative, Sign::Positive);\n-/// // zero is its own negation\n+/// // Zero is its own negation.\n /// assert_eq!(-Sign::Zero, Sign::Zero);\n /// ```\n #[lang = \"neg\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Neg {\n-    /// The resulting type after applying the `-` operator\n+    /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the unary `-` operator\n+    /// Performs the unary `-` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn neg(self) -> Self::Output;\n }\n@@ -668,7 +626,7 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n /// use std::ops::AddAssign;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -683,12 +641,6 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n /// let mut point = Point { x: 1, y: 0 };\n /// point += Point { x: 2, y: 3 };\n /// assert_eq!(point, Point { x: 3, y: 3 });\n@@ -697,7 +649,7 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} += {Rhs}`\"]\n pub trait AddAssign<Rhs=Self> {\n-    /// The method for the `+=` operator\n+    /// Performs the `+=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn add_assign(&mut self, rhs: Rhs);\n }\n@@ -725,7 +677,7 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n /// use std::ops::SubAssign;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -740,12 +692,6 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n /// let mut point = Point { x: 3, y: 3 };\n /// point -= Point { x: 2, y: 3 };\n /// assert_eq!(point, Point {x: 1, y: 0});\n@@ -754,7 +700,7 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} -= {Rhs}`\"]\n pub trait SubAssign<Rhs=Self> {\n-    /// The method for the `-=` operator\n+    /// Performs the `-=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn sub_assign(&mut self, rhs: Rhs);\n }\n@@ -776,31 +722,27 @@ sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `MulAssign`. When `Foo *= Foo` happens, it ends up\n-/// calling `mul_assign`, and therefore, `main` prints `Multiplying!`.\n-///\n /// ```\n /// use std::ops::MulAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Frequency { hertz: f64 }\n ///\n-/// impl MulAssign for Foo {\n-///     fn mul_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Multiplying!\");\n+/// impl MulAssign<f64> for Frequency {\n+///     fn mul_assign(&mut self, rhs: f64) {\n+///         self.hertz *= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo *= Foo;\n-/// }\n+/// let mut frequency = Frequency { hertz: 50.0 };\n+/// frequency *= 4.0;\n+/// assert_eq!(Frequency { hertz: 200.0 }, frequency);\n /// ```\n #[lang = \"mul_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} *= {Rhs}`\"]\n pub trait MulAssign<Rhs=Self> {\n-    /// The method for the `*=` operator\n+    /// Performs the `*=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn mul_assign(&mut self, rhs: Rhs);\n }\n@@ -822,31 +764,27 @@ mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `DivAssign`. When `Foo /= Foo` happens, it ends up\n-/// calling `div_assign`, and therefore, `main` prints `Dividing!`.\n-///\n /// ```\n /// use std::ops::DivAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Frequency { hertz: f64 }\n ///\n-/// impl DivAssign for Foo {\n-///     fn div_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Dividing!\");\n+/// impl DivAssign<f64> for Frequency {\n+///     fn div_assign(&mut self, rhs: f64) {\n+///         self.hertz /= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo /= Foo;\n-/// }\n+/// let mut frequency = Frequency { hertz: 200.0 };\n+/// frequency /= 4.0;\n+/// assert_eq!(Frequency { hertz: 50.0 }, frequency);\n /// ```\n #[lang = \"div_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} /= {Rhs}`\"]\n pub trait DivAssign<Rhs=Self> {\n-    /// The method for the `/=` operator\n+    /// Performs the `/=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn div_assign(&mut self, rhs: Rhs);\n }\n@@ -867,31 +805,31 @@ div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `RemAssign`. When `Foo %= Foo` happens, it ends up\n-/// calling `rem_assign`, and therefore, `main` prints `Remainder-ing!`.\n-///\n /// ```\n /// use std::ops::RemAssign;\n ///\n-/// struct Foo;\n+/// struct CookieJar { cookies: u32 }\n ///\n-/// impl RemAssign for Foo {\n-///     fn rem_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Remainder-ing!\");\n+/// impl RemAssign<u32> for CookieJar {\n+///     fn rem_assign(&mut self, piles: u32) {\n+///         self.cookies %= piles;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo %= Foo;\n-/// }\n+/// let mut jar = CookieJar { cookies: 31 };\n+/// let piles = 4;\n+///\n+/// println!(\"Splitting up {} cookies into {} even piles!\", jar.cookies, piles);\n+///\n+/// jar %= piles;\n+///\n+/// println!(\"{} cookies remain in the cookie jar!\", jar.cookies);\n /// ```\n #[lang = \"rem_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} %= {Rhs}`\"]\n pub trait RemAssign<Rhs=Self> {\n-    /// The method for the `%=` operator\n+    /// Performs the `%=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn rem_assign(&mut self, rhs: Rhs);\n }"}, {"sha": "0bc5e554cb347d7cf2c3e76a94f21b685bf4a5a3", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 128, "deletions": 150, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=f774bced502cf190426f778001a342715acb1d47", "patch": "@@ -41,11 +41,11 @@\n #[lang = \"not\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Not {\n-    /// The resulting type after applying the `!` operator\n+    /// The resulting type after applying the `!` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the unary `!` operator\n+    /// Performs the unary `!` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn not(self) -> Self::Output;\n }\n@@ -68,9 +68,11 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n /// The bitwise AND operator `&`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// In this example, the `&` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitAnd` for a wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitAnd;\n@@ -87,16 +89,13 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n-///     assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n-///     assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n-/// }\n+/// assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n+/// assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n+/// assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitAnd` trait is implemented for a `BooleanVector`\n-/// struct.\n+/// An implementation of `BitAnd` for a wrapper around `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitAnd;\n@@ -114,22 +113,20 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, false, false, false]);\n-///     assert_eq!(bv1 & bv2, expected);\n-/// }\n+/// let bv1 = BooleanVector(vec![true, true, false, false]);\n+/// let bv2 = BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![true, false, false, false]);\n+/// assert_eq!(bv1 & bv2, expected);\n /// ```\n #[lang = \"bitand\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} & {RHS}`\"]\n pub trait BitAnd<RHS=Self> {\n-    /// The resulting type after applying the `&` operator\n+    /// The resulting type after applying the `&` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `&` operator\n+    /// Performs the `&` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitand(self, rhs: RHS) -> Self::Output;\n }\n@@ -152,9 +149,11 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n /// The bitwise OR operator `|`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// In this example, the `|` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitOr` for a wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitOr;\n@@ -171,16 +170,13 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n-///     assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n-/// }\n+/// assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n+/// assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitOr` trait is implemented for a `BooleanVector`\n-/// struct.\n+/// An implementation of `BitOr` for a wrapper around `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitOr;\n@@ -198,22 +194,20 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, true, true, false]);\n-///     assert_eq!(bv1 | bv2, expected);\n-/// }\n+/// let bv1 = BooleanVector(vec![true, true, false, false]);\n+/// let bv2 = BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![true, true, true, false]);\n+/// assert_eq!(bv1 | bv2, expected);\n /// ```\n #[lang = \"bitor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} | {RHS}`\"]\n pub trait BitOr<RHS=Self> {\n-    /// The resulting type after applying the `|` operator\n+    /// The resulting type after applying the `|` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `|` operator\n+    /// Performs the `|` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitor(self, rhs: RHS) -> Self::Output;\n }\n@@ -236,9 +230,11 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n /// The bitwise XOR operator `^`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// In this example, the `^` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitXor` that lifts `^` to a wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitXor;\n@@ -255,16 +251,13 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n-///     assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n-///     assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n-/// }\n+/// assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n+/// assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n+/// assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitXor` trait is implemented for a `BooleanVector`\n-/// struct.\n+/// An implementation of `BitXor` trait for a wrapper around `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitXor;\n@@ -285,22 +278,20 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![false, true, true, false]);\n-///     assert_eq!(bv1 ^ bv2, expected);\n-/// }\n+/// let bv1 = BooleanVector(vec![true, true, false, false]);\n+/// let bv2 = BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![false, true, true, false]);\n+/// assert_eq!(bv1 ^ bv2, expected);\n /// ```\n #[lang = \"bitxor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} ^ {RHS}`\"]\n pub trait BitXor<RHS=Self> {\n-    /// The resulting type after applying the `^` operator\n+    /// The resulting type after applying the `^` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `^` operator\n+    /// Performs the `^` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n@@ -326,7 +317,7 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// # Examples\n ///\n /// An implementation of `Shl` that lifts the `<<` operation on integers to a\n-/// `Scalar` struct.\n+/// wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::Shl;\n@@ -342,9 +333,8 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///         Scalar(lhs << rhs)\n ///     }\n /// }\n-/// fn main() {\n-///     assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n-/// }\n+///\n+/// assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n /// ```\n ///\n /// An implementation of `Shl` that spins a vector leftward by a given amount.\n@@ -361,7 +351,7 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     type Output = Self;\n ///\n ///     fn shl(self, rhs: usize) -> SpinVector<T> {\n-///         // rotate the vector by `rhs` places\n+///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(rhs);\n ///         let mut spun_vector: Vec<T> = vec![];\n ///         spun_vector.extend_from_slice(b);\n@@ -370,20 +360,18 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n-///                SpinVector { vec: vec![2, 3, 4, 0, 1] });\n-/// }\n+/// assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n+///            SpinVector { vec: vec![2, 3, 4, 0, 1] });\n /// ```\n #[lang = \"shl\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} << {RHS}`\"]\n pub trait Shl<RHS> {\n-    /// The resulting type after applying the `<<` operator\n+    /// The resulting type after applying the `<<` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `<<` operator\n+    /// Performs the `<<` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shl(self, rhs: RHS) -> Self::Output;\n }\n@@ -430,7 +418,7 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n /// # Examples\n ///\n /// An implementation of `Shr` that lifts the `>>` operation on integers to a\n-/// `Scalar` struct.\n+/// wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::Shr;\n@@ -446,9 +434,8 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///         Scalar(lhs >> rhs)\n ///     }\n /// }\n-/// fn main() {\n-///     assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n-/// }\n+///\n+/// assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n /// ```\n ///\n /// An implementation of `Shr` that spins a vector rightward by a given amount.\n@@ -465,7 +452,7 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///     type Output = Self;\n ///\n ///     fn shr(self, rhs: usize) -> SpinVector<T> {\n-///         // rotate the vector by `rhs` places\n+///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n ///         let mut spun_vector: Vec<T> = vec![];\n ///         spun_vector.extend_from_slice(b);\n@@ -474,20 +461,18 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n-///                SpinVector { vec: vec![3, 4, 0, 1, 2] });\n-/// }\n+/// assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n+///            SpinVector { vec: vec![3, 4, 0, 1, 2] });\n /// ```\n #[lang = \"shr\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} >> {RHS}`\"]\n pub trait Shr<RHS> {\n-    /// The resulting type after applying the `>>` operator\n+    /// The resulting type after applying the `>>` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `>>` operator\n+    /// Performs the `>>` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shr(self, rhs: RHS) -> Self::Output;\n }\n@@ -533,7 +518,8 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///\n /// # Examples\n ///\n-/// In this example, the `&=` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitAndAssign` that lifts the `&=` operator to a\n+/// wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitAndAssign;\n@@ -548,27 +534,25 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let mut scalar = Scalar(true);\n-///     scalar &= Scalar(true);\n-///     assert_eq!(scalar, Scalar(true));\n+/// let mut scalar = Scalar(true);\n+/// scalar &= Scalar(true);\n+/// assert_eq!(scalar, Scalar(true));\n ///\n-///     let mut scalar = Scalar(true);\n-///     scalar &= Scalar(false);\n-///     assert_eq!(scalar, Scalar(false));\n+/// let mut scalar = Scalar(true);\n+/// scalar &= Scalar(false);\n+/// assert_eq!(scalar, Scalar(false));\n ///\n-///     let mut scalar = Scalar(false);\n-///     scalar &= Scalar(true);\n-///     assert_eq!(scalar, Scalar(false));\n+/// let mut scalar = Scalar(false);\n+/// scalar &= Scalar(true);\n+/// assert_eq!(scalar, Scalar(false));\n ///\n-///     let mut scalar = Scalar(false);\n-///     scalar &= Scalar(false);\n-///     assert_eq!(scalar, Scalar(false));\n-/// }\n+/// let mut scalar = Scalar(false);\n+/// scalar &= Scalar(false);\n+/// assert_eq!(scalar, Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitAndAssign` trait is implemented for a\n-/// `BooleanVector` struct.\n+/// Here, the `BitAndAssign` trait is implemented for a wrapper around\n+/// `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitAndAssign;\n@@ -577,7 +561,7 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n /// struct BooleanVector(Vec<bool>);\n ///\n /// impl BitAndAssign for BooleanVector {\n-///     // rhs is the \"right-hand side\" of the expression `a &= b`\n+///     // `rhs` is the \"right-hand side\" of the expression `a &= b`.\n ///     fn bitand_assign(&mut self, rhs: Self) {\n ///         assert_eq!(self.0.len(), rhs.0.len());\n ///         *self = BooleanVector(self.0\n@@ -588,18 +572,16 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let mut bv = BooleanVector(vec![true, true, false, false]);\n-///     bv &= BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, false, false, false]);\n-///     assert_eq!(bv, expected);\n-/// }\n+/// let mut bv = BooleanVector(vec![true, true, false, false]);\n+/// bv &= BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![true, false, false, false]);\n+/// assert_eq!(bv, expected);\n /// ```\n #[lang = \"bitand_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} &= {Rhs}`\"]\n pub trait BitAndAssign<Rhs=Self> {\n-    /// The method for the `&=` operator\n+    /// Performs the `&=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitand_assign(&mut self, rhs: Rhs);\n }\n@@ -620,31 +602,31 @@ bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `BitOrAssign`. When `Foo |= Foo` happens, it ends up\n-/// calling `bitor_assign`, and therefore, `main` prints `Bitwise Or-ing!`.\n-///\n /// ```\n /// use std::ops::BitOrAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct PersonalPreferences {\n+///     likes_cats: bool,\n+///     likes_dogs: bool,\n+/// }\n ///\n-/// impl BitOrAssign for Foo {\n-///     fn bitor_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Bitwise Or-ing!\");\n+/// impl BitOrAssign for PersonalPreferences {\n+///     fn bitor_assign(&mut self, rhs: Self) {\n+///         self.likes_cats |= rhs.likes_cats;\n+///         self.likes_dogs |= rhs.likes_dogs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo |= Foo;\n-/// }\n+/// let mut prefs = PersonalPreferences { likes_cats: true, likes_dogs: false };\n+/// prefs |= PersonalPreferences { likes_cats: false, likes_dogs: true };\n+/// assert_eq!(prefs, PersonalPreferences { likes_cats: true, likes_dogs: true });\n /// ```\n #[lang = \"bitor_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} |= {Rhs}`\"]\n pub trait BitOrAssign<Rhs=Self> {\n-    /// The method for the `|=` operator\n+    /// Performs the `|=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitor_assign(&mut self, rhs: Rhs);\n }\n@@ -665,31 +647,31 @@ bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `BitXorAssign`. When `Foo ^= Foo` happens, it ends up\n-/// calling `bitxor_assign`, and therefore, `main` prints `Bitwise Xor-ing!`.\n-///\n /// ```\n /// use std::ops::BitXorAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Personality {\n+///     has_soul: bool,\n+///     likes_knitting: bool,\n+/// }\n ///\n-/// impl BitXorAssign for Foo {\n-///     fn bitxor_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Bitwise Xor-ing!\");\n+/// impl BitXorAssign for Personality {\n+///     fn bitxor_assign(&mut self, rhs: Self) {\n+///         self.has_soul ^= rhs.has_soul;\n+///         self.likes_knitting ^= rhs.likes_knitting;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo ^= Foo;\n-/// }\n+/// let mut personality = Personality { has_soul: false, likes_knitting: true };\n+/// personality ^= Personality { has_soul: true, likes_knitting: true };\n+/// assert_eq!(personality, Personality { has_soul: true, likes_knitting: false});\n /// ```\n #[lang = \"bitxor_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} ^= {Rhs}`\"]\n pub trait BitXorAssign<Rhs=Self> {\n-    /// The method for the `^=` operator\n+    /// Performs the `^=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitxor_assign(&mut self, rhs: Rhs);\n }\n@@ -710,31 +692,29 @@ bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `ShlAssign`. When `Foo <<= Foo` happens, it ends up\n-/// calling `shl_assign`, and therefore, `main` prints `Shifting left!`.\n+/// An implementation of `ShlAssign` for a wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::ShlAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(usize);\n ///\n-/// impl ShlAssign<Foo> for Foo {\n-///     fn shl_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Shifting left!\");\n+/// impl ShlAssign<usize> for Scalar {\n+///     fn shl_assign(&mut self, rhs: usize) {\n+///         self.0 <<= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo <<= Foo;\n-/// }\n+/// let mut scalar = Scalar(4);\n+/// scalar <<= 2;\n+/// assert_eq!(scalar, Scalar(16));\n /// ```\n #[lang = \"shl_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} <<= {Rhs}`\"]\n pub trait ShlAssign<Rhs> {\n-    /// The method for the `<<=` operator\n+    /// Performs the `<<=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shl_assign(&mut self, rhs: Rhs);\n }\n@@ -776,31 +756,29 @@ shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `ShrAssign`. When `Foo >>= Foo` happens, it ends up\n-/// calling `shr_assign`, and therefore, `main` prints `Shifting right!`.\n+/// An implementation of `ShrAssign` for a wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::ShrAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(usize);\n ///\n-/// impl ShrAssign<Foo> for Foo {\n-///     fn shr_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Shifting right!\");\n+/// impl ShrAssign<usize> for Scalar {\n+///     fn shr_assign(&mut self, rhs: usize) {\n+///         self.0 >>= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo >>= Foo;\n-/// }\n+/// let mut scalar = Scalar(16);\n+/// scalar >>= 2;\n+/// assert_eq!(scalar, Scalar(4));\n /// ```\n #[lang = \"shr_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} >>= {Rhs}`\"]\n pub trait ShrAssign<Rhs=Self> {\n-    /// The method for the `>>=` operator\n+    /// Performs the `>>=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shr_assign(&mut self, rhs: Rhs);\n }"}, {"sha": "a2e7c44cb249fd08f6f36942133c0ecb469d8168", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 78, "deletions": 24, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=f774bced502cf190426f778001a342715acb1d47", "patch": "@@ -8,16 +8,44 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// The `Deref` trait is used to specify the functionality of dereferencing\n-/// operations, like `*v`.\n+/// Used for immutable dereferencing operations, like `*v`.\n ///\n-/// `Deref` also enables ['`Deref` coercions'][coercions].\n+/// In addition to being used for explicit dereferencing operations with the\n+/// (unary) `*` operator in immutable contexts, `Deref` is also used implicitly\n+/// by the compiler in many circumstances. This mechanism is called\n+/// ['`Deref` coercion'][more]. In mutable contexts, [`DerefMut`] is used.\n ///\n-/// [coercions]: ../../book/first-edition/deref-coercions.html\n+/// Implementing `Deref` for smart pointers makes accessing the data behind them\n+/// convenient, which is why they implement `Deref`. On the other hand, the\n+/// rules regarding `Deref` and [`DerefMut`] were designed specifically to\n+/// accomodate smart pointers. Because of this, **`Deref` should only be\n+/// implemented for smart pointers** to avoid confusion.\n+///\n+/// For similar reasons, **this trait should never fail**. Failure during\n+/// dereferencing can be extremely confusing when `Deref` is invoked implicitly.\n+///\n+/// # More on `Deref` coercion\n+///\n+/// If `T` implements `Deref<Target = U>`, and `x` is a value of type `T`, then:\n+/// * In immutable contexts, `*x` on non-pointer types is equivalent to\n+///   `*Deref::deref(&x)`.\n+/// * Values of type `&T` are coerced to values of type `&U`\n+/// * `T` implicitly implements all the (immutable) methods of the type `U`.\n+///\n+/// For more details, visit [the chapter in *The Rust Programming Language*]\n+/// [book] as well as the reference sections on [the dereference operator]\n+/// [ref-deref-op], [the `Deref` trait][ref-deref-trait], and [type coercions].\n+///\n+/// [book]: ../../book/second-edition/ch15-02-deref.html\n+/// [`DerefMut`]: trait.DerefMut.html\n+/// [more]: #more-on-deref-coercion\n+/// [ref-deref-op]: ../../reference/expressions.html#the-dereference-operator\n+/// [ref-deref-trait]: ../../reference/the-deref-trait.html\n+/// [type coercions]: ../../reference/type-coercions.html\n ///\n /// # Examples\n ///\n-/// A struct with a single field which is accessible via dereferencing the\n+/// A struct with a single field which is accessible by dereferencing the\n /// struct.\n ///\n /// ```\n@@ -35,19 +63,17 @@\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let x = DerefExample { value: 'a' };\n-///     assert_eq!('a', *x);\n-/// }\n+/// let x = DerefExample { value: 'a' };\n+/// assert_eq!('a', *x);\n /// ```\n #[lang = \"deref\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Deref {\n-    /// The resulting type after dereferencing\n+    /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Target: ?Sized;\n \n-    /// The method called to dereference a value\n+    /// Dereferences the value.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref(&self) -> &Self::Target;\n }\n@@ -66,16 +92,46 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n     fn deref(&self) -> &T { *self }\n }\n \n-/// The `DerefMut` trait is used to specify the functionality of dereferencing\n-/// mutably like `*v = 1;`\n-///\n-/// `DerefMut` also enables ['`Deref` coercions'][coercions].\n-///\n-/// [coercions]: ../../book/first-edition/deref-coercions.html\n+/// Used for mutable dereferencing operations, like in `*v = 1;`.\n+///\n+/// In addition to being used for explicit dereferencing operations with the\n+/// (unary) `*` operator in mutable contexts, `DerefMut` is also used implicitly\n+/// by the compiler in many circumstances. This mechanism is called\n+/// ['`Deref` coercion'][more]. In immutable contexts, [`Deref`] is used.\n+///\n+/// Implementing `DerefMut` for smart pointers makes mutating the data behind\n+/// them convenient, which is why they implement `DerefMut`. On the other hand,\n+/// the rules regarding [`Deref`] and `DerefMut` were designed specifically to\n+/// accomodate smart pointers. Because of this, **`DerefMut` should only be\n+/// implemented for smart pointers** to avoid confusion.\n+///\n+/// For similar reasons, **this trait should never fail**. Failure during\n+/// dereferencing can be extremely confusing when `DerefMut` is invoked\n+/// implicitly.\n+///\n+/// # More on `Deref` coercion\n+///\n+/// If `T` implements `DerefMut<Target = U>`, and `x` is a value of type `T`,\n+/// then:\n+/// * In mutable contexts, `*x` on non-pointer types is equivalent to\n+///   `*Deref::deref(&x)`.\n+/// * Values of type `&mut T` are coerced to values of type `&mut U`\n+/// * `T` implicitly implements all the (mutable) methods of the type `U`.\n+///\n+/// For more details, visit [the chapter in *The Rust Programming Language*]\n+/// [book] as well as the reference sections on [the dereference operator]\n+/// [ref-deref-op], [the `Deref` trait][ref-deref-trait], and [type coercions].\n+///\n+/// [book]: ../../book/second-edition/ch15-02-deref.html\n+/// [`Deref`]: trait.Deref.html\n+/// [more]: #more-on-deref-coercion\n+/// [ref-deref-op]: ../../reference/expressions.html#the-dereference-operator\n+/// [ref-deref-trait]: ../../reference/the-deref-trait.html\n+/// [type coercions]: ../../reference/type-coercions.html\n ///\n /// # Examples\n ///\n-/// A struct with a single field which is modifiable via dereferencing the\n+/// A struct with a single field which is modifiable by dereferencing the\n /// struct.\n ///\n /// ```\n@@ -99,16 +155,14 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let mut x = DerefMutExample { value: 'a' };\n-///     *x = 'b';\n-///     assert_eq!('b', *x);\n-/// }\n+/// let mut x = DerefMutExample { value: 'a' };\n+/// *x = 'b';\n+/// assert_eq!('b', *x);\n /// ```\n #[lang = \"deref_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DerefMut: Deref {\n-    /// The method called to mutably dereference a value\n+    /// Mutably dereferences the value.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref_mut(&mut self) -> &mut Self::Target;\n }"}, {"sha": "70ab7b2f3b7ec28aca515533266593be41af72ba", "filename": "src/libcore/ops/drop.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fdrop.rs?ref=f774bced502cf190426f778001a342715acb1d47", "patch": "@@ -8,20 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// The `Drop` trait is used to run some code when a value goes out of scope.\n+/// Used to run some code when a value goes out of scope.\n /// This is sometimes called a 'destructor'.\n ///\n-/// When a value goes out of scope, if it implements this trait, it will have\n-/// its `drop` method called. Then any fields the value contains will also\n+/// When a value goes out of scope, it will have its `drop` method called if\n+/// its type implements `Drop`. Then, any fields the value contains will also\n /// be dropped recursively.\n ///\n-/// Because of the recursive dropping, you do not need to implement this trait\n+/// Because of this recursive dropping, you do not need to implement this trait\n /// unless your type needs its own destructor logic.\n ///\n+/// Refer to [the chapter on `Drop` in *The Rust Programming Language*][book]\n+/// for some more elaboration.\n+///\n+/// [book]: ../../book/second-edition/ch15-03-drop.html\n+///\n /// # Examples\n ///\n-/// A trivial implementation of `Drop`. The `drop` method is called when `_x`\n-/// goes out of scope, and therefore `main` prints `Dropping!`.\n+/// ## Implementing `Drop`\n+///\n+/// The `drop` method is called when `_x` goes out of scope, and therefore\n+/// `main` prints `Dropping!`.\n ///\n /// ```\n /// struct HasDrop;\n@@ -37,9 +44,11 @@\n /// }\n /// ```\n ///\n-/// Showing the recursive nature of `Drop`. When `outer` goes out of scope, the\n-/// `drop` method will be called first for `Outer`, then for `Inner`. Therefore\n-/// `main` prints `Dropping Outer!` and then `Dropping Inner!`.\n+/// ## Dropping is done recursively\n+///\n+/// When `outer` goes out of scope, the `drop` method will be called first for\n+/// `Outer`, then for `Inner`. Therefore, `main` prints `Dropping Outer!` and\n+/// then `Dropping Inner!`.\n ///\n /// ```\n /// struct Inner;\n@@ -62,12 +71,20 @@\n /// }\n /// ```\n ///\n-/// Because variables are dropped in the reverse order they are declared,\n-/// `main` will print `Declared second!` and then `Declared first!`.\n+/// ## Variables are dropped in reverse order of declaration\n+///\n+/// `_first` is declared first and `_second` is declared second, so `main` will\n+/// print `Declared second!` and then `Declared first!`.\n ///\n /// ```\n /// struct PrintOnDrop(&'static str);\n ///\n+/// impl Drop for PrintOnDrop {\n+///     fn drop(&mut self) {\n+///         println!(\"{}\", self.0);\n+///     }\n+/// }\n+///\n /// fn main() {\n ///     let _first = PrintOnDrop(\"Declared first!\");\n ///     let _second = PrintOnDrop(\"Declared second!\");\n@@ -76,24 +93,25 @@\n #[lang = \"drop\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Drop {\n-    /// A method called when the value goes out of scope.\n+    /// Executes the destructor for this type.\n+    ///\n+    /// This method is called implilcitly when the value goes out of scope,\n+    /// and cannot be called explicitly (this is compiler error [E0040]).\n+    /// However, the [`std::mem::drop`] function in the prelude can be\n+    /// used to call the argument's `Drop` implementation.\n     ///\n     /// When this method has been called, `self` has not yet been deallocated.\n-    /// If it were, `self` would be a dangling reference.\n+    /// That only happens after the method is over.\n+    /// If this wasn't the case, `self` would be a dangling reference.\n     ///\n-    /// After this function is over, the memory of `self` will be deallocated.\n+    /// # Panics\n     ///\n-    /// This function cannot be called explicitly. This is compiler error\n-    /// [E0040]. However, the [`std::mem::drop`] function in the prelude can be\n-    /// used to call the argument's `Drop` implementation.\n+    /// Given that a [`panic!`] will call `drop` as it unwinds, any [`panic!`]\n+    /// in a `drop` implementation will likely abort.\n     ///\n     /// [E0040]: ../../error-index.html#E0040\n+    /// [`panic!`]: ../macro.panic.html\n     /// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n-    ///\n-    /// # Panics\n-    ///\n-    /// Given that a `panic!` will call `drop()` as it unwinds, any `panic!` in\n-    /// a `drop()` implementation will likely abort.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn drop(&mut self);\n }"}, {"sha": "d10fcb86b2411723df17dd205a9375ea8c47b6b6", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=f774bced502cf190426f778001a342715acb1d47", "patch": "@@ -8,26 +8,51 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// A version of the call operator that takes an immutable receiver.\n+/// The version of the call operator that takes an immutable receiver.\n ///\n-/// # Examples\n+/// Instances of `Fn` can be called repeatedly without mutating state.\n+///\n+/// *This trait (`Fn`) is not to be confused with [function pointers][]\n+/// (`fn`).*\n+///\n+/// `Fn` is implemented automatically by closures which only take immutable\n+/// references to captured variables or don't capture anything at all, as well\n+/// as (safe) [function pointers][] (with some caveats, see their documentation\n+/// for more details). Additionally, for any type `F` that implements `Fn`, `&F`\n+/// implements `Fn`, too.\n+///\n+/// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n+/// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\n+/// is expected.\n ///\n-/// Closures automatically implement this trait, which allows them to be\n-/// invoked. Note, however, that `Fn` takes an immutable reference to any\n-/// captured variables. To take a mutable capture, implement [`FnMut`], and to\n-/// consume the capture, implement [`FnOnce`].\n+/// Use `Fn` as a bound when you want to accept a parameter of function-like\n+/// type and need to call it repeatedly and without mutating state (e.g. when\n+/// calling it concurrently). If you do not need such strict requirements, use\n+/// [`FnMut`] or [`FnOnce`] as bounds.\n ///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/second-edition/ch13-01-closures.html\n /// [`FnMut`]: trait.FnMut.html\n /// [`FnOnce`]: trait.FnOnce.html\n+/// [function pointers]: ../../std/primitive.fn.html\n+/// [nomicon]: ../../nomicon/hrtb.html\n+///\n+/// # Examples\n+///\n+/// ## Calling a closure\n ///\n /// ```\n /// let square = |x| x * x;\n /// assert_eq!(square(5), 25);\n /// ```\n ///\n-/// Closures can also be passed to higher-level functions through a `Fn`\n-/// parameter (or a `FnMut` or `FnOnce` parameter, which are supertraits of\n-/// `Fn`).\n+/// ## Using a `Fn` parameter\n ///\n /// ```\n /// fn call_with_one<F>(func: F) -> usize\n@@ -43,17 +68,46 @@\n #[rustc_paren_sugar]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait Fn<Args> : FnMut<Args> {\n-    /// This is called when the call operator is used.\n+    /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n }\n \n-/// A version of the call operator that takes a mutable receiver.\n+/// The version of the call operator that takes a mutable receiver.\n+///\n+/// Instances of `FnMut` can be called repeatedly and may mutate state.\n+///\n+/// `FnMut` is implemented automatically by closures which take mutable\n+/// references to captured variables, as well as all types that implement\n+/// [`Fn`], e.g. (safe) [function pointers][] (since `FnMut` is a supertrait of\n+/// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n+/// implements `FnMut`, too.\n+///\n+/// Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\n+/// used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n+/// `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n+///\n+/// Use `FnMut` as a bound when you want to accept a parameter of function-like\n+/// type and need to call it repeatedly, while allowing it to mutate state.\n+/// If you don't want the parameter to mutate state, use [`Fn`] as a\n+/// bound; if you don't need to call it repeatedly, use [`FnOnce`].\n+///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/second-edition/ch13-01-closures.html\n+/// [`Fn`]: trait.Fn.html\n+/// [`FnOnce`]: trait.FnOnce.html\n+/// [function pointers]: ../../std/primitive.fn.html\n+/// [nomicon]: ../../nomicon/hrtb.html\n ///\n /// # Examples\n ///\n-/// Closures that mutably capture variables automatically implement this trait,\n-/// which allows them to be invoked.\n+/// ## Calling a mutably capturing closure\n ///\n /// ```\n /// let mut x = 5;\n@@ -64,8 +118,7 @@ pub trait Fn<Args> : FnMut<Args> {\n /// assert_eq!(x, 25);\n /// ```\n ///\n-/// Closures can also be passed to higher-level functions through a `FnMut`\n-/// parameter (or a `FnOnce` parameter, which is a supertrait of `FnMut`).\n+/// ## Using a `FnMut` parameter\n ///\n /// ```\n /// fn do_twice<F>(mut func: F)\n@@ -88,39 +141,66 @@ pub trait Fn<Args> : FnMut<Args> {\n #[rustc_paren_sugar]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait FnMut<Args> : FnOnce<Args> {\n-    /// This is called when the call operator is used.\n+    /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n-/// A version of the call operator that takes a by-value receiver.\n+/// The version of the call operator that takes a by-value receiver.\n+///\n+/// Instances of `FnOnce` can be called, but might not be callable multiple\n+/// times. Because of this, if the only thing known about a type is that it\n+/// implements `FnOnce`, it can only be called once.\n+///\n+/// `FnOnce` is implemented automatically by closure that might consume captured\n+/// variables, as well as all types that implement [`FnMut`], e.g. (safe)\n+/// [function pointers][] (since `FnOnce` is a supertrait of [`FnMut`]).\n+///\n+/// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n+/// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n+///\n+/// Use `FnOnce` as a bound when you want to accept a parameter of function-like\n+/// type and only need to call it once. If you need to call the parameter\n+/// repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\n+/// state, use [`Fn`].\n+///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/second-edition/ch13-01-closures.html\n+/// [`Fn`]: trait.Fn.html\n+/// [`FnMut`]: trait.FnMut.html\n+/// [function pointers]: ../../std/primitive.fn.html\n+/// [nomicon]: ../../nomicon/hrtb.html\n ///\n /// # Examples\n ///\n-/// By-value closures automatically implement this trait, which allows them to\n-/// be invoked.\n+/// ## Calling a by-value closure\n ///\n /// ```\n /// let x = 5;\n /// let square_x = move || x * x;\n /// assert_eq!(square_x(), 25);\n /// ```\n ///\n-/// By-value Closures can also be passed to higher-level functions through a\n-/// `FnOnce` parameter.\n+/// ## Using a `FnOnce` parameter\n ///\n /// ```\n /// fn consume_with_relish<F>(func: F)\n ///     where F: FnOnce() -> String\n /// {\n ///     // `func` consumes its captured variables, so it cannot be run more\n-///     // than once\n+///     // than once.\n ///     println!(\"Consumed: {}\", func());\n ///\n ///     println!(\"Delicious!\");\n ///\n ///     // Attempting to invoke `func()` again will throw a `use of moved\n-///     // value` error for `func`\n+///     // value` error for `func`.\n /// }\n ///\n /// let x = String::from(\"x\");\n@@ -138,7 +218,7 @@ pub trait FnOnce<Args> {\n     #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n     type Output;\n \n-    /// This is called when the call operator is used.\n+    /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }"}, {"sha": "d65c0aba5048103fe80c67056102347f876ee742", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=f774bced502cf190426f778001a342715acb1d47", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// The `Index` trait is used to specify the functionality of indexing operations\n-/// like `container[index]` when used in an immutable context.\n+/// Used for indexing operations (`container[index]`) in immutable contexts.\n ///\n /// `container[index]` is actually syntactic sugar for `*container.index(index)`,\n /// but only when used as an immutable value. If a mutable value is requested,\n /// [`IndexMut`] is used instead. This allows nice things such as\n-/// `let value = v[index]` if `value` implements [`Copy`].\n+/// `let value = v[index]` if the type of `value` implements [`Copy`].\n ///\n /// [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n /// [`Copy`]: ../../std/marker/trait.Copy.html\n@@ -64,25 +63,23 @@\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Index<Idx: ?Sized> {\n-    /// The returned type after indexing\n+    /// The returned type after indexing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output: ?Sized;\n \n-    /// The method for the indexing (`container[index]`) operation\n+    /// Performs the indexing (`container[index]`) operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index(&self, index: Idx) -> &Self::Output;\n }\n \n-/// The `IndexMut` trait is used to specify the functionality of indexing\n-/// operations like `container[index]` when used in a mutable context.\n+/// Used for indexing operations (`container[index]`) in mutable contexts.\n ///\n /// `container[index]` is actually syntactic sugar for\n /// `*container.index_mut(index)`, but only when used as a mutable value. If\n /// an immutable value is requested, the [`Index`] trait is used instead. This\n-/// allows nice things such as `v[index] = value` if `value` implements [`Copy`].\n+/// allows nice things such as `v[index] = value`.\n ///\n /// [`Index`]: ../../std/ops/trait.Index.html\n-/// [`Copy`]: ../../std/marker/trait.Copy.html\n ///\n /// # Examples\n ///\n@@ -106,7 +103,7 @@ pub trait Index<Idx: ?Sized> {\n ///\n /// struct Balance {\n ///     pub left: Weight,\n-///     pub right:Weight,\n+///     pub right: Weight,\n /// }\n ///\n /// impl Index<Side> for Balance {\n@@ -131,28 +128,26 @@ pub trait Index<Idx: ?Sized> {\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let mut balance = Balance {\n-///         right: Weight::Kilogram(2.5),\n-///         left: Weight::Pound(1.5),\n-///     };\n-///\n-///     // In this case balance[Side::Right] is sugar for\n-///     // *balance.index(Side::Right), since we are only reading\n-///     // balance[Side::Right], not writing it.\n-///     assert_eq!(balance[Side::Right],Weight::Kilogram(2.5));\n-///\n-///     // However in this case balance[Side::Left] is sugar for\n-///     // *balance.index_mut(Side::Left), since we are writing\n-///     // balance[Side::Left].\n-///     balance[Side::Left] = Weight::Kilogram(3.0);\n-/// }\n+/// let mut balance = Balance {\n+///     right: Weight::Kilogram(2.5),\n+///     left: Weight::Pound(1.5),\n+/// };\n+///\n+/// // In this case, `balance[Side::Right]` is sugar for\n+/// // `*balance.index(Side::Right)`, since we are only *reading*\n+/// // `balance[Side::Right]`, not writing it.\n+/// assert_eq!(balance[Side::Right], Weight::Kilogram(2.5));\n+///\n+/// // However, in this case `balance[Side::Left]` is sugar for\n+/// // `*balance.index_mut(Side::Left)`, since we are writing\n+/// // `balance[Side::Left]`.\n+/// balance[Side::Left] = Weight::Kilogram(3.0);\n /// ```\n #[lang = \"index_mut\"]\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n-    /// The method for the mutable indexing (`container[index]`) operation\n+    /// Performs the mutable indexing (`container[index]`) operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n }"}, {"sha": "b5e6912b10d6e2948b0852ce17dde722d0052279", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=f774bced502cf190426f778001a342715acb1d47", "patch": "@@ -21,6 +21,12 @@\n //! custom operators are required, you should look toward macros or compiler\n //! plugins to extend Rust's syntax.\n //!\n+//! Implementations of operator traits should be unsurprising in their\n+//! respective contexts, keeping in mind their usual meanings and\n+//! [operator precedence]. For example, when implementing [`Mul`], the operation\n+//! should have some resemblance to multiplication (and share expected\n+//! properties like associativity).\n+//!\n //! Note that the `&&` and `||` operators short-circuit, i.e. they only\n //! evaluate their second operand if it contributes to the result. Since this\n //! behavior is not enforceable by traits, `&&` and `||` are not supported as\n@@ -46,7 +52,7 @@\n //! ```rust\n //! use std::ops::{Add, Sub};\n //!\n-//! #[derive(Debug)]\n+//! #[derive(Debug, PartialEq)]\n //! struct Point {\n //!     x: i32,\n //!     y: i32,\n@@ -67,10 +73,9 @@\n //!         Point {x: self.x - other.x, y: self.y - other.y}\n //!     }\n //! }\n-//! fn main() {\n-//!     println!(\"{:?}\", Point {x: 1, y: 0} + Point {x: 2, y: 3});\n-//!     println!(\"{:?}\", Point {x: 1, y: 0} - Point {x: 2, y: 3});\n-//! }\n+//!\n+//! assert_eq!(Point {x: 3, y: 3}, Point {x: 1, y: 0} + Point {x: 2, y: 3});\n+//! assert_eq!(Point {x: -1, y: -3}, Point {x: 1, y: 0} - Point {x: 2, y: 3});\n //! ```\n //!\n //! See the documentation for each trait for an example implementation.\n@@ -143,7 +148,9 @@\n //! [`FnOnce`]: trait.FnOnce.html\n //! [`Add`]: trait.Add.html\n //! [`Sub`]: trait.Sub.html\n+//! [`Mul`]: trait.Mul.html\n //! [`clone`]: ../clone/trait.Clone.html#tymethod.clone\n+//! [operator precedence]: ../../reference/expressions.html#operator-precedence\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "463a50491a866e16a884973474a7622bd479dda6", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 111, "deletions": 95, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f774bced502cf190426f778001a342715acb1d47/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=f774bced502cf190426f778001a342715acb1d47", "patch": "@@ -10,10 +10,10 @@\n \n use fmt;\n \n-/// An unbounded range. Use `..` (two dots) for its shorthand.\n+/// An unbounded range (`..`).\n ///\n-/// Its primary use case is slicing index. It cannot serve as an iterator\n-/// because it doesn't have a starting point.\n+/// `RangeFull` is primarily used as a [slicing index], its shorthand is `..`.\n+/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n ///\n@@ -23,16 +23,16 @@ use fmt;\n /// assert_eq!((..), std::ops::RangeFull);\n /// ```\n ///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n-/// `for` loop directly. This won't compile:\n+/// It does not have an [`IntoIterator`] implementation, so you can't use it in\n+/// a `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n /// for i in .. {\n ///    // ...\n /// }\n /// ```\n ///\n-/// Used as a slicing index, `RangeFull` produces the full array as a slice.\n+/// Used as a [slicing index], `RangeFull` produces the full array as a slice.\n ///\n /// ```\n /// let arr = [0, 1, 2, 3];\n@@ -41,6 +41,10 @@ use fmt;\n /// assert_eq!(arr[1.. ], [  1,2,3]);\n /// assert_eq!(arr[1..3], [  1,2  ]);\n /// ```\n+///\n+/// [`IntoIterator`]: ../iter/trait.Iterator.html\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n+/// [slicing index]: ../slice/trait.SliceIndex.html\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFull;\n@@ -52,24 +56,23 @@ impl fmt::Debug for RangeFull {\n     }\n }\n \n-/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.\n-/// Use `start..end` (two dots) for its shorthand.\n+/// A (half-open) range bounded inclusively below and exclusively above\n+/// (`start..end`).\n ///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// The `Range` `start..end` contains all values with `x >= start` and\n+/// `x < end`.\n ///\n /// # Examples\n ///\n /// ```\n-/// fn main() {\n-///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n-///     assert_eq!(3+4+5, (3..6).sum());\n-///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ .. ], [0,1,2,3]);\n-///     assert_eq!(arr[ ..3], [0,1,2  ]);\n-///     assert_eq!(arr[1.. ], [  1,2,3]);\n-///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n-/// }\n+/// assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n+/// assert_eq!(3 + 4 + 5, (3..6).sum());\n+///\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);\n+/// assert_eq!(arr[1.. ], [  1,2,3]);\n+/// assert_eq!(arr[1..3], [  1,2  ]);  // Range\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -91,49 +94,49 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> Range<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!( ! (3..5).contains(2));\n-    ///     assert!(   (3..5).contains(3));\n-    ///     assert!(   (3..5).contains(4));\n-    ///     assert!( ! (3..5).contains(5));\n     ///\n-    ///     assert!( ! (3..3).contains(3));\n-    ///     assert!( ! (3..2).contains(3));\n-    /// }\n+    /// assert!(!(3..5).contains(2));\n+    /// assert!( (3..5).contains(3));\n+    /// assert!( (3..5).contains(4));\n+    /// assert!(!(3..5).contains(5));\n+    ///\n+    /// assert!(!(3..3).contains(3));\n+    /// assert!(!(3..2).contains(3));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (self.start <= item) && (item < self.end)\n     }\n }\n \n-/// A range which is only bounded below: { x | start <= x }.\n-/// Use `start..` for its shorthand.\n+/// A range only bounded inclusively below (`start..`).\n ///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// The `RangeFrom` `start..` contains all values with `x >= start`.\n ///\n-/// Note: Currently, no overflow checking is done for the iterator\n+/// *Note*: Currently, no overflow checking is done for the [`Iterator`]\n /// implementation; if you use an integer range and the integer overflows, it\n-/// might panic in debug mode or create an endless loop in release mode. This\n-/// overflow behavior might change in the future.\n+/// might panic in debug mode or create an endless loop in release mode. **This\n+/// overflow behavior might change in the future.**\n ///\n /// # Examples\n ///\n /// ```\n-/// fn main() {\n-///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n-///     assert_eq!(2+3+4, (2..).take(3).sum());\n-///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ .. ], [0,1,2,3]);\n-///     assert_eq!(arr[ ..3], [0,1,2  ]);\n-///     assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n-///     assert_eq!(arr[1..3], [  1,2  ]);\n-/// }\n+/// assert_eq!((2..), std::ops::RangeFrom { start: 2 });\n+/// assert_eq!(2 + 3 + 4, (2..).take(3).sum());\n+///\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);\n+/// assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n+/// assert_eq!(arr[1..3], [  1,2  ]);\n /// ```\n+///\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n@@ -151,46 +154,47 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!( ! (3..).contains(2));\n-    ///     assert!(   (3..).contains(3));\n-    ///     assert!(   (3..).contains(1_000_000_000));\n-    /// }\n+    ///\n+    /// assert!(!(3..).contains(2));\n+    /// assert!( (3..).contains(3));\n+    /// assert!( (3..).contains(1_000_000_000));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (self.start <= item)\n     }\n }\n \n-/// A range which is only bounded above: { x | x < end }.\n-/// Use `..end` (two dots) for its shorthand.\n-///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// A range only bounded exclusively above (`..end`).\n ///\n-/// It cannot serve as an iterator because it doesn't have a starting point.\n+/// The `RangeTo` `..end` contains all values with `x < end`.\n+/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n ///\n-/// The `..{integer}` syntax is a `RangeTo`:\n+/// The `..end` syntax is a `RangeTo`:\n ///\n /// ```\n-/// assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n+/// assert_eq!((..5), std::ops::RangeTo { end: 5 });\n /// ```\n ///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n-/// `for` loop directly. This won't compile:\n+/// It does not have an [`IntoIterator`] implementation, so you can't use it in\n+/// a `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n+/// // error[E0277]: the trait bound `std::ops::RangeTo<{integer}>:\n+/// // std::iter::Iterator` is not satisfied\n /// for i in ..5 {\n ///     // ...\n /// }\n /// ```\n ///\n-/// When used as a slicing index, `RangeTo` produces a slice of all array\n+/// When used as a [slicing index], `RangeTo` produces a slice of all array\n /// elements before the index indicated by `end`.\n ///\n /// ```\n@@ -200,6 +204,10 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n /// assert_eq!(arr[1.. ], [  1,2,3]);\n /// assert_eq!(arr[1..3], [  1,2  ]);\n /// ```\n+///\n+/// [`IntoIterator`]: ../iter/trait.Iterator.html\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n+/// [slicing index]: ../slice/trait.SliceIndex.html\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n@@ -217,38 +225,38 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!(   (..5).contains(-1_000_000_000));\n-    ///     assert!(   (..5).contains(4));\n-    ///     assert!( ! (..5).contains(5));\n-    /// }\n+    ///\n+    /// assert!( (..5).contains(-1_000_000_000));\n+    /// assert!( (..5).contains(4));\n+    /// assert!(!(..5).contains(5));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (item < self.end)\n     }\n }\n \n-/// An inclusive range which is bounded at both ends: { x | start <= x <= end }.\n-/// Use `start...end` (three dots) for its shorthand.\n+/// An range bounded inclusively below and above (`start...end`).\n ///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// The `RangeInclusive` `start...end` contains all values with `x >= start`\n+/// and `x <= end`.\n ///\n /// # Examples\n ///\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n-/// fn main() {\n-///     assert_eq!((3...5), std::ops::RangeInclusive{ start: 3, end: 5 });\n-///     assert_eq!(3+4+5, (3...5).sum());\n ///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ ...2], [0,1,2  ]);\n-///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n-/// }\n+/// assert_eq!((3...5), std::ops::RangeInclusive { start: 3, end: 5 });\n+/// assert_eq!(3 + 4 + 5, (3...5).sum());\n+///\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ ...2], [0,1,2  ]);\n+/// assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n@@ -274,61 +282,68 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n-    /// fn main() {\n-    ///     assert!( ! (3...5).contains(2));\n-    ///     assert!(   (3...5).contains(3));\n-    ///     assert!(   (3...5).contains(4));\n-    ///     assert!(   (3...5).contains(5));\n-    ///     assert!( ! (3...5).contains(6));\n     ///\n-    ///     assert!(   (3...3).contains(3));\n-    ///     assert!( ! (3...2).contains(3));\n-    /// }\n+    /// assert!(!(3...5).contains(2));\n+    /// assert!( (3...5).contains(3));\n+    /// assert!( (3...5).contains(4));\n+    /// assert!( (3...5).contains(5));\n+    /// assert!(!(3...5).contains(6));\n+    ///\n+    /// assert!( (3...3).contains(3));\n+    /// assert!(!(3...2).contains(3));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         self.start <= item && item <= self.end\n     }\n }\n \n-/// An inclusive range which is only bounded above: { x | x <= end }.\n-/// Use `...end` (three dots) for its shorthand.\n+/// A range only bounded inclusively above (`...end`).\n ///\n-/// See the [`contains`](#method.contains) method for its characterization.\n-///\n-/// It cannot serve as an iterator because it doesn't have a starting point.\n+/// The `RangeToInclusive` `...end` contains all values with `x <= end`.\n+/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n ///\n-/// The `...{integer}` syntax is a `RangeToInclusive`:\n+/// The `...end` syntax is a `RangeToInclusive`:\n ///\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n /// assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n /// ```\n ///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// It does not have an [`IntoIterator`] implementation, so you can't use it in a\n /// `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n /// #![feature(inclusive_range_syntax)]\n+///\n+/// // error[E0277]: the trait bound `std::ops::RangeToInclusive<{integer}>:\n+/// // std::iter::Iterator` is not satisfied\n /// for i in ...5 {\n ///     // ...\n /// }\n /// ```\n ///\n-/// When used as a slicing index, `RangeToInclusive` produces a slice of all\n+/// When used as a [slicing index], `RangeToInclusive` produces a slice of all\n /// array elements up to and including the index indicated by `end`.\n ///\n /// ```\n /// #![feature(inclusive_range_syntax)]\n+///\n /// let arr = [0, 1, 2, 3];\n /// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n /// assert_eq!(arr[1...2], [  1,2  ]);\n /// ```\n+///\n+/// [`IntoIterator`]: ../iter/trait.Iterator.html\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n+/// [slicing index]: ../slice/trait.SliceIndex.html\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub struct RangeToInclusive<Idx> {\n@@ -348,15 +363,16 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n-    /// fn main() {\n-    ///     assert!(   (...5).contains(-1_000_000_000));\n-    ///     assert!(   (...5).contains(5));\n-    ///     assert!( ! (...5).contains(6));\n-    /// }\n+    ///\n+    /// assert!( (...5).contains(-1_000_000_000));\n+    /// assert!( (...5).contains(5));\n+    /// assert!(!(...5).contains(6));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (item <= self.end)"}]}