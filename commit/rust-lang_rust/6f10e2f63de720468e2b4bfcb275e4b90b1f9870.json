{"sha": "6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMTBlMmY2M2RlNzIwNDY4ZTJiNGJmY2IyNzVlNGI5MGIxZjk4NzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-14T10:40:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-14T10:40:09Z"}, "message": "Auto merge of #39921 - cramertj:add-catch-to-ast, r=nikomatsakis\n\nAdd catch {} to AST\n\nPart of #39849. Builds on #39864.", "tree": {"sha": "11f51d7f07c5a74ab22e20b7f3556c4c0191fe66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11f51d7f07c5a74ab22e20b7f3556c4c0191fe66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "html_url": "https://github.com/rust-lang/rust/commit/6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa53235cc4364fe085ccba720237d19b669c2f8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa53235cc4364fe085ccba720237d19b669c2f8b", "html_url": "https://github.com/rust-lang/rust/commit/fa53235cc4364fe085ccba720237d19b669c2f8b"}, {"sha": "b1aa99352a69e328094e096bbbd1741b68c0667f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1aa99352a69e328094e096bbbd1741b68c0667f", "html_url": "https://github.com/rust-lang/rust/commit/b1aa99352a69e328094e096bbbd1741b68c0667f"}], "stats": {"total": 164, "additions": 159, "deletions": 5}, "files": [{"sha": "d92eaee6f0c8ec9e72902fa48a3b5c54aac5b969", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -84,6 +84,7 @@ pub struct LoweringContext<'a> {\n     trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n     trait_default_impl: BTreeMap<DefId, NodeId>,\n \n+    catch_scopes: Vec<NodeId>,\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n \n@@ -123,6 +124,7 @@ pub fn lower_crate(sess: &Session,\n         trait_impls: BTreeMap::new(),\n         trait_default_impl: BTreeMap::new(),\n         exported_macros: Vec::new(),\n+        catch_scopes: Vec::new(),\n         loop_scopes: Vec::new(),\n         is_in_loop_condition: false,\n         type_def_lifetime_params: DefIdMap(),\n@@ -261,6 +263,21 @@ impl<'a> LoweringContext<'a> {\n         span\n     }\n \n+    fn with_catch_scope<T, F>(&mut self, catch_id: NodeId, f: F) -> T\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let len = self.catch_scopes.len();\n+        self.catch_scopes.push(catch_id);\n+\n+        let result = f(self);\n+        assert_eq!(len + 1, self.catch_scopes.len(),\n+            \"catch scopes should be added and removed in stack order\");\n+\n+        self.catch_scopes.pop().unwrap();\n+\n+        result\n+    }\n+\n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n@@ -295,15 +312,17 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n-    fn with_new_loop_scopes<T, F>(&mut self, f: F) -> T\n+    fn with_new_scopes<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = false;\n \n+        let catch_scopes = mem::replace(&mut self.catch_scopes, Vec::new());\n         let loop_scopes = mem::replace(&mut self.loop_scopes, Vec::new());\n         let result = f(self);\n-        mem::replace(&mut self.loop_scopes, loop_scopes);\n+        self.catch_scopes = catch_scopes;\n+        self.loop_scopes = loop_scopes;\n \n         self.is_in_loop_condition = was_in_loop_condition;\n \n@@ -1065,7 +1084,7 @@ impl<'a> LoweringContext<'a> {\n                                self.record_body(value, None))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n-                self.with_new_loop_scopes(|this| {\n+                self.with_new_scopes(|this| {\n                     let body = this.lower_block(body);\n                     let body = this.expr_block(body, ThinVec::new());\n                     let body_id = this.record_body(body, Some(decl));\n@@ -1665,13 +1684,17 @@ impl<'a> LoweringContext<'a> {\n                                       this.lower_opt_sp_ident(opt_ident),\n                                       hir::LoopSource::Loop))\n                 }\n+                ExprKind::Catch(ref body) => {\n+                    // FIXME(cramertj): Add catch to HIR\n+                    self.with_catch_scope(e.id, |this| hir::ExprBlock(this.lower_block(body)))\n+                }\n                 ExprKind::Match(ref expr, ref arms) => {\n                     hir::ExprMatch(P(self.lower_expr(expr)),\n                                    arms.iter().map(|x| self.lower_arm(x)).collect(),\n                                    hir::MatchSource::Normal)\n                 }\n                 ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n-                    self.with_new_loop_scopes(|this| {\n+                    self.with_new_scopes(|this| {\n                         this.with_parent_def(e.id, |this| {\n                             let expr = this.lower_expr(body);\n                             hir::ExprClosure(this.lower_capture_clause(capture_clause),\n@@ -2069,6 +2092,12 @@ impl<'a> LoweringContext<'a> {\n                     //     Err(err) => #[allow(unreachable_code)]\n                     //                 return Carrier::from_error(From::from(err)),\n                     // }\n+\n+                    // FIXME(cramertj): implement breaking to catch\n+                    if !self.catch_scopes.is_empty() {\n+                        bug!(\"`?` in catch scopes is unimplemented\")\n+                    }\n+\n                     let unstable_span = self.allow_internal_unstable(\"?\", e.span);\n \n                     // Carrier::translate(<expr>)"}, {"sha": "a456fa512254c788050c584b0e8c67ebe9b4056d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -935,6 +935,8 @@ pub enum ExprKind {\n     Closure(CaptureBy, P<FnDecl>, P<Expr>, Span),\n     /// A block (`{ ... }`)\n     Block(P<Block>),\n+    /// A catch block (`catch { ... }`)\n+    Catch(P<Block>),\n \n     /// An assignment (`a = foo()`)\n     Assign(P<Expr>, P<Expr>),"}, {"sha": "15913d56d162f0cba362d22881b496c066a6fcd0", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -339,6 +339,9 @@ declare_features! (\n \n     // `extern \"x86-interrupt\" fn()`\n     (active, abi_x86_interrupt, \"1.17.0\", Some(40180)),\n+\n+    // Allows the `catch {...}` expression\n+    (active, catch_expr, \"1.17.0\", Some(31436)),\n );\n \n declare_features! (\n@@ -1287,6 +1290,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     }\n                 }\n             }\n+            ast::ExprKind::Catch(_) => {\n+                gate_feature_post!(&self, catch_expr, e.span, \"`catch` expression is experimental\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "9f11d0173d6d5168c6602b8d85dc58f5642325f0", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -1269,6 +1269,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 };\n             }\n             ExprKind::Try(ex) => ExprKind::Try(folder.fold_expr(ex)),\n+            ExprKind::Catch(body) => ExprKind::Catch(folder.fold_block(body)),\n         },\n         id: folder.new_id(id),\n         span: folder.new_span(span),"}, {"sha": "8f66c1a2b8cf630eada9a2627ac6360b1d2dd72b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -2280,6 +2280,12 @@ impl<'a> Parser<'a> {\n                         BlockCheckMode::Unsafe(ast::UserProvided),\n                         attrs);\n                 }\n+                if self.is_catch_expr() {\n+                    assert!(self.eat_keyword(keywords::Do));\n+                    assert!(self.eat_keyword(keywords::Catch));\n+                    let lo = self.prev_span.lo;\n+                    return self.parse_catch_expr(lo, attrs);\n+                }\n                 if self.eat_keyword(keywords::Return) {\n                     if self.token.can_begin_expr() {\n                         let e = self.parse_expr()?;\n@@ -3099,6 +3105,16 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(span_lo, hi, ExprKind::Loop(body, opt_ident), attrs))\n     }\n \n+    /// Parse a `do catch {...}` expression (`do catch` token already eaten)\n+    pub fn parse_catch_expr(&mut self, span_lo: BytePos, mut attrs: ThinVec<Attribute>)\n+        -> PResult<'a, P<Expr>>\n+    {\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        let hi = body.span.hi;\n+        Ok(self.mk_expr(span_lo, hi, ExprKind::Catch(body), attrs))\n+    }\n+\n     // `match` token already eaten\n     fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_span;\n@@ -3706,6 +3722,15 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    fn is_catch_expr(&mut self) -> bool {\n+        self.token.is_keyword(keywords::Do) &&\n+        self.look_ahead(1, |t| t.is_keyword(keywords::Catch)) &&\n+        self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n+\n+        // prevent `while catch {} {}`, `if catch {} {} else {}`, etc.\n+        !self.restrictions.contains(Restrictions::RESTRICTION_NO_STRUCT_LITERAL)\n+    }\n+\n     fn is_union_item(&self) -> bool {\n         self.token.is_keyword(keywords::Union) &&\n         self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword())\n@@ -4882,6 +4907,7 @@ impl<'a> Parser<'a> {\n     /// Parse struct Foo { ... }\n     fn parse_item_struct(&mut self) -> PResult<'a, ItemInfo> {\n         let class_name = self.parse_ident()?;\n+\n         let mut generics = self.parse_generics()?;\n \n         // There is a special case worth noting here, as reported in issue #17904.\n@@ -4931,6 +4957,7 @@ impl<'a> Parser<'a> {\n     /// Parse union Foo { ... }\n     fn parse_item_union(&mut self) -> PResult<'a, ItemInfo> {\n         let class_name = self.parse_ident()?;\n+\n         let mut generics = self.parse_generics()?;\n \n         let vdata = if self.token.is_keyword(keywords::Where) {"}, {"sha": "25601f2420e8a7d680d4f21c2861200f3e55ce3e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -86,6 +86,7 @@ fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n     !ident_token.is_any_keyword() ||\n     ident_token.is_path_segment_keyword() ||\n     [\n+        keywords::Do.name(),\n         keywords::Box.name(),\n         keywords::Break.name(),\n         keywords::Continue.name(),"}, {"sha": "83753f398a3765cd7e3df0424a89cf97c7fae479", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -2279,6 +2279,11 @@ impl<'a> State<'a> {\n                 self.print_expr(e)?;\n                 word(&mut self.s, \"?\")?\n             }\n+            ast::ExprKind::Catch(ref blk) => {\n+                self.head(\"do catch\")?;\n+                space(&mut self.s)?;\n+                self.print_block_with_attrs(&blk, attrs)?\n+            }\n         }\n         self.ann.post(self, NodeExpr(expr))?;\n         self.end()"}, {"sha": "6642c60d256b3c4e40e0cc437ddb60993544e1f6", "filename": "src/libsyntax/symbol.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -221,9 +221,10 @@ declare_keywords! {\n     (53, Default,        \"default\")\n     (54, StaticLifetime, \"'static\")\n     (55, Union,          \"union\")\n+    (56, Catch,          \"catch\")\n \n     // A virtual keyword that resolves to the crate root when used in a lexical scope.\n-    (56, CrateRoot, \"{{root}}\")\n+    (57, CrateRoot, \"{{root}}\")\n }\n \n // If an interner exists in TLS, return it. Otherwise, prepare a fresh one."}, {"sha": "a5333f3bb6a6e46c1f3af1c8e1d30194c194d897", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -779,6 +779,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::Try(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n+        ExprKind::Catch(ref body) => {\n+            visitor.visit_block(body)\n+        }\n     }\n \n     visitor.visit_expr_post(expression)"}, {"sha": "9f9968e81242a135b45d941ea092791472cbbc55", "filename": "src/test/compile-fail/catch-in-match.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Ftest%2Fcompile-fail%2Fcatch-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Ftest%2Fcompile-fail%2Fcatch-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcatch-in-match.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(catch_expr)]\n+\n+fn main() {\n+    match do catch { false } { _ => {} } //~ ERROR expected expression, found reserved keyword `do`\n+}"}, {"sha": "cb8613ee60b424cf77c181a571d60bed18bece7e", "filename": "src/test/compile-fail/catch-in-while.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Ftest%2Fcompile-fail%2Fcatch-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Ftest%2Fcompile-fail%2Fcatch-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcatch-in-while.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(catch_expr)]\n+\n+fn main() {\n+    while do catch { false } {} //~ ERROR expected expression, found reserved keyword `do`\n+}"}, {"sha": "5568a5cf0aac267e8bfe79374206c997ccee4df1", "filename": "src/test/compile-fail/feature-gate-catch_expr.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Ftest%2Fcompile-fail%2Ffeature-gate-catch_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Ftest%2Fcompile-fail%2Ffeature-gate-catch_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-catch_expr.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    let catch_result = do catch { //~ ERROR `catch` expression is experimental\n+        let x = 5;\n+        x\n+    };\n+    assert_eq!(catch_result, 5);\n+}"}, {"sha": "a9b28a534a3483edd4b69a98f00bcfd0f309f6dc", "filename": "src/test/run-pass/catch-expr.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Ftest%2Frun-pass%2Fcatch-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f10e2f63de720468e2b4bfcb275e4b90b1f9870/src%2Ftest%2Frun-pass%2Fcatch-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcatch-expr.rs?ref=6f10e2f63de720468e2b4bfcb275e4b90b1f9870", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(catch_expr)]\n+\n+struct catch {}\n+\n+pub fn main() {\n+    let catch_result = do catch {\n+        let x = 5;\n+        x\n+    };\n+    assert_eq!(catch_result, 5);\n+\n+    let mut catch = true;\n+    while catch { catch = false; }\n+    assert_eq!(catch, false);\n+\n+    catch = if catch { false } else { true };\n+    assert_eq!(catch, true);\n+\n+    match catch {\n+        _ => {}\n+    };\n+}"}]}