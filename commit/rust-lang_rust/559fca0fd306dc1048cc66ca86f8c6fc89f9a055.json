{"sha": "559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1OWZjYTBmZDMwNmRjMTA0OGNjNjZjYTg2ZjhjNmZjODlmOWEwNTU=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-09T21:00:20Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-12T18:28:42Z"}, "message": "Autoderef in librustc", "tree": {"sha": "b93ad08074d6a20e19f83c35ad3c19892be13251", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b93ad08074d6a20e19f83c35ad3c19892be13251"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "html_url": "https://github.com/rust-lang/rust/commit/559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62bada40dec16bb47e2ea0a0d54f74389309512a", "url": "https://api.github.com/repos/rust-lang/rust/commits/62bada40dec16bb47e2ea0a0d54f74389309512a", "html_url": "https://github.com/rust-lang/rust/commit/62bada40dec16bb47e2ea0a0d54f74389309512a"}], "stats": {"total": 524, "additions": 262, "deletions": 262}, "files": [{"sha": "752b625f529c084ce3aa077a32bc92b5e1f693a8", "filename": "src/librustc/front/map/blocks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -217,9 +217,9 @@ impl<'a> FnLikeNode<'a> {\n                     item_fn(ItemFnParts {\n                         id: i.id,\n                         name: i.name,\n-                        decl: &**decl,\n+                        decl: &decl,\n                         unsafety: unsafety,\n-                        body: &**block,\n+                        body: &block,\n                         generics: generics,\n                         abi: abi,\n                         vis: i.vis,\n@@ -246,7 +246,7 @@ impl<'a> FnLikeNode<'a> {\n             }\n             map::NodeExpr(e) => match e.node {\n                 ast::ExprClosure(_, ref decl, ref block) =>\n-                    closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n+                    closure(ClosureParts::new(&decl, &block, e.id, e.span)),\n                 _ => panic!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => panic!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "310e341749381e9e7eb4485a274c61067548b245", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -795,7 +795,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n             loop {\n                 match map.find(id) {\n                     None => return None,\n-                    Some(NodeItem(item)) if item_is_mod(&*item) =>\n+                    Some(NodeItem(item)) if item_is_mod(&item) =>\n                         return Some((id, item.name)),\n                     _ => {}\n                 }\n@@ -967,16 +967,16 @@ pub trait NodePrinter {\n impl<'a> NodePrinter for pprust::State<'a> {\n     fn print_node(&mut self, node: &Node) -> io::Result<()> {\n         match *node {\n-            NodeItem(a)        => self.print_item(&*a),\n-            NodeForeignItem(a) => self.print_foreign_item(&*a),\n+            NodeItem(a)        => self.print_item(&a),\n+            NodeForeignItem(a) => self.print_foreign_item(&a),\n             NodeTraitItem(a)   => self.print_trait_item(a),\n             NodeImplItem(a)    => self.print_impl_item(a),\n-            NodeVariant(a)     => self.print_variant(&*a),\n-            NodeExpr(a)        => self.print_expr(&*a),\n-            NodeStmt(a)        => self.print_stmt(&*a),\n-            NodePat(a)         => self.print_pat(&*a),\n-            NodeBlock(a)       => self.print_block(&*a),\n-            NodeLifetime(a)    => self.print_lifetime(&*a),\n+            NodeVariant(a)     => self.print_variant(&a),\n+            NodeExpr(a)        => self.print_expr(&a),\n+            NodeStmt(a)        => self.print_stmt(&a),\n+            NodePat(a)         => self.print_pat(&a),\n+            NodeBlock(a)       => self.print_block(&a),\n+            NodeLifetime(a)    => self.print_lifetime(&a),\n             NodeTyParam(_)     => panic!(\"cannot print TyParam\"),\n             // these cases do not carry enough information in the\n             // ast_map to reconstruct their full structure for pretty\n@@ -1055,26 +1055,26 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                     map.path_to_string(id), id_str)\n         }\n         Some(NodeExpr(ref expr)) => {\n-            format!(\"expr {}{}\", pprust::expr_to_string(&**expr), id_str)\n+            format!(\"expr {}{}\", pprust::expr_to_string(&expr), id_str)\n         }\n         Some(NodeStmt(ref stmt)) => {\n-            format!(\"stmt {}{}\", pprust::stmt_to_string(&**stmt), id_str)\n+            format!(\"stmt {}{}\", pprust::stmt_to_string(&stmt), id_str)\n         }\n         Some(NodeLocal(ref pat)) => {\n-            format!(\"local {}{}\", pprust::pat_to_string(&**pat), id_str)\n+            format!(\"local {}{}\", pprust::pat_to_string(&pat), id_str)\n         }\n         Some(NodePat(ref pat)) => {\n-            format!(\"pat {}{}\", pprust::pat_to_string(&**pat), id_str)\n+            format!(\"pat {}{}\", pprust::pat_to_string(&pat), id_str)\n         }\n         Some(NodeBlock(ref block)) => {\n-            format!(\"block {}{}\", pprust::block_to_string(&**block), id_str)\n+            format!(\"block {}{}\", pprust::block_to_string(&block), id_str)\n         }\n         Some(NodeStructCtor(_)) => {\n             format!(\"struct_ctor {}{}\", map.path_to_string(id), id_str)\n         }\n         Some(NodeLifetime(ref l)) => {\n             format!(\"lifetime {}{}\",\n-                    pprust::lifetime_to_string(&**l), id_str)\n+                    pprust::lifetime_to_string(&l), id_str)\n         }\n         Some(NodeTyParam(ref ty_param)) => {\n             format!(\"typaram {:?}{}\", ty_param, id_str)"}, {"sha": "6142f14db3ecce16a6bba1ad05ea33738b91b60d", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -73,12 +73,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n             hir::StmtDecl(ref decl, id) => {\n-                let exit = self.decl(&**decl, pred);\n+                let exit = self.decl(&decl, pred);\n                 self.add_ast_node(id, &[exit])\n             }\n \n             hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) => {\n-                let exit = self.expr(&**expr, pred);\n+                let exit = self.expr(&expr, pred);\n                 self.add_ast_node(id, &[exit])\n             }\n         }\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match decl.node {\n             hir::DeclLocal(ref local) => {\n                 let init_exit = self.opt_expr(&local.init, pred);\n-                self.pat(&*local.pat, init_exit)\n+                self.pat(&local.pat, init_exit)\n             }\n \n             hir::DeclItem(_) => {\n@@ -111,7 +111,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::PatBox(ref subpat) |\n             hir::PatRegion(ref subpat, _) |\n             hir::PatIdent(_, _, Some(ref subpat)) => {\n-                let subpat_exit = self.pat(&**subpat, pred);\n+                let subpat_exit = self.pat(&subpat, pred);\n                 self.add_ast_node(pat.id, &[subpat_exit])\n             }\n \n@@ -140,13 +140,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                                           pats: I,\n                                           pred: CFGIndex) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n-        pats.fold(pred, |pred, pat| self.pat(&**pat, pred))\n+        pats.fold(pred, |pred, pat| self.pat(&pat, pred))\n     }\n \n     fn expr(&mut self, expr: &hir::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n             hir::ExprBlock(ref blk) => {\n-                let blk_exit = self.block(&**blk, pred);\n+                let blk_exit = self.block(&blk, pred);\n                 self.add_ast_node(expr.id, &[blk_exit])\n             }\n \n@@ -165,8 +165,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 3   v 4\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(&**cond, pred);                // 1\n-                let then_exit = self.block(&**then, cond_exit);          // 2\n+                let cond_exit = self.expr(&cond, pred);                // 1\n+                let then_exit = self.block(&then, cond_exit);          // 2\n                 self.add_ast_node(expr.id, &[cond_exit, then_exit])      // 3,4\n             }\n \n@@ -185,9 +185,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 4   v 5\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(&**cond, pred);                // 1\n-                let then_exit = self.block(&**then, cond_exit);          // 2\n-                let else_exit = self.expr(&**otherwise, cond_exit);      // 3\n+                let cond_exit = self.expr(&cond, pred);                // 1\n+                let then_exit = self.block(&then, cond_exit);          // 2\n+                let else_exit = self.expr(&otherwise, cond_exit);      // 3\n                 self.add_ast_node(expr.id, &[then_exit, else_exit])      // 4, 5\n             }\n \n@@ -211,14 +211,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n                 // Is the condition considered part of the loop?\n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let cond_exit = self.expr(&**cond, loopback);             // 2\n+                let cond_exit = self.expr(&cond, loopback);             // 2\n                 let expr_exit = self.add_ast_node(expr.id, &[cond_exit]); // 3\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n                     break_index: expr_exit\n                 });\n-                let body_exit = self.block(&**body, cond_exit);          // 4\n+                let body_exit = self.block(&body, cond_exit);          // 4\n                 self.add_contained_edge(body_exit, loopback);            // 5\n                 self.loop_scopes.pop();\n                 expr_exit\n@@ -246,7 +246,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     continue_index: loopback,\n                     break_index: expr_exit,\n                 });\n-                let body_exit = self.block(&**body, loopback);           // 3\n+                let body_exit = self.block(&body, loopback);           // 3\n                 self.add_contained_edge(body_exit, loopback);            // 4\n                 self.loop_scopes.pop();\n                 expr_exit\n@@ -271,8 +271,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 3  v 4\n                 //   [..exit..]\n                 //\n-                let l_exit = self.expr(&**l, pred);                      // 1\n-                let r_exit = self.expr(&**r, l_exit);                    // 2\n+                let l_exit = self.expr(&l, pred);                      // 1\n+                let r_exit = self.expr(&r, l_exit);                    // 2\n                 self.add_ast_node(expr.id, &[l_exit, r_exit])            // 3,4\n             }\n \n@@ -304,16 +304,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprCall(ref func, ref args) => {\n-                self.call(expr, pred, &**func, args.iter().map(|e| &**e))\n+                self.call(expr, pred, &func, args.iter().map(|e| &**e))\n             }\n \n             hir::ExprMethodCall(_, _, ref args) => {\n-                self.call(expr, pred, &*args[0], args[1..].iter().map(|e| &**e))\n+                self.call(expr, pred, &args[0], args[1..].iter().map(|e| &**e))\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n             hir::ExprBinary(_, ref l, ref r) if self.tcx.is_method_call(expr.id) => {\n-                self.call(expr, pred, &**l, Some(&**r).into_iter())\n+                self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n             hir::ExprRange(ref start, ref end) => {\n@@ -323,7 +323,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n-                self.call(expr, pred, &**e, None::<hir::Expr>.iter())\n+                self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n \n             hir::ExprTup(ref exprs) => {\n@@ -413,7 +413,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 opt_expr: &Option<P<hir::Expr>>,\n                 pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `opt_expr` evaluated, if Some\n-        opt_expr.iter().fold(pred, |p, e| self.expr(&**e, p))\n+        opt_expr.iter().fold(pred, |p, e| self.expr(&e, p))\n     }\n \n     fn straightline<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n@@ -461,18 +461,18 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             for pat in &arm.pats {\n                 // Visit the pattern, coming from the discriminant exit\n-                let mut pat_exit = self.pat(&**pat, discr_exit);\n+                let mut pat_exit = self.pat(&pat, discr_exit);\n \n                 // If there is a guard expression, handle it here\n                 if let Some(ref guard) = arm.guard {\n                     // Add a dummy node for the previous guard\n                     // expression to target\n                     let guard_start = self.add_dummy_node(&[pat_exit]);\n                     // Visit the guard expression\n-                    let guard_exit = self.expr(&**guard, guard_start);\n+                    let guard_exit = self.expr(&guard, guard_start);\n \n                     let this_has_bindings = pat_util::pat_contains_bindings_or_wild(\n-                        &self.tcx.def_map.borrow(), &**pat);\n+                        &self.tcx.def_map.borrow(), &pat);\n \n                     // If both this pattern and the previous pattern\n                     // were free of bindings, they must consist only"}, {"sha": "a32f5b8797d3e83237503f95a5da897e9df9b2cb", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -72,7 +72,7 @@ impl<'a> fmt::Debug for Matrix<'a> {\n         let &Matrix(ref m) = self;\n         let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n             row.iter()\n-               .map(|&pat| pat_to_string(&*pat))\n+               .map(|&pat| pat_to_string(&pat))\n                .collect::<Vec<String>>()\n         }).collect();\n \n@@ -175,7 +175,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 // Second, if there is a guard on each arm, make sure it isn't\n                 // assigning or borrowing anything mutably.\n                 match arm.guard {\n-                    Some(ref guard) => check_for_mutation_in_guard(cx, &**guard),\n+                    Some(ref guard) => check_for_mutation_in_guard(cx, &guard),\n                     None => {}\n                 }\n             }\n@@ -196,14 +196,14 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 .iter()\n                 .flat_map(|&(ref pats, _)| pats) {\n                 // Third, check legality of move bindings.\n-                check_legality_of_bindings_in_at_patterns(cx, &**pat);\n+                check_legality_of_bindings_in_at_patterns(cx, &pat);\n \n                 // Fourth, check if there are any references to NaN that we should warn about.\n-                check_for_static_nan(cx, &**pat);\n+                check_for_static_nan(cx, &pat);\n \n                 // Fifth, check if for any of the patterns that match an enumerated type\n                 // are bindings with the same name as one of the variants of said type.\n-                check_for_bindings_named_the_same_as_variants(cx, &**pat);\n+                check_for_bindings_named_the_same_as_variants(cx, &pat);\n             }\n \n             // Fourth, check for unreachable arms.\n@@ -275,7 +275,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n     front_util::walk_pat(pat, |p| {\n         if let hir::PatLit(ref expr) = p.node {\n-            match eval_const_expr_partial(cx.tcx, &**expr, ExprTypeChecked, None) {\n+            match eval_const_expr_partial(cx.tcx, &expr, ExprTypeChecked, None) {\n                 Ok(ConstVal::Float(f)) if f.is_nan() => {\n                     span_warn!(cx.tcx.sess, p.span, E0003,\n                                \"unmatchable NaN in pattern, \\\n@@ -360,7 +360,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n \n fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n     match p.node {\n-        hir::PatIdent(_, _, Some(ref s)) => raw_pat(&**s),\n+        hir::PatIdent(_, _, Some(ref s)) => raw_pat(&s),\n         _ => p\n     }\n }\n@@ -679,7 +679,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n     let left_ty = if real_pat.id == DUMMY_NODE_ID {\n         cx.tcx.mk_nil()\n     } else {\n-        let left_ty = cx.tcx.pat_ty(&*real_pat);\n+        let left_ty = cx.tcx.pat_ty(&real_pat);\n \n         match real_pat.node {\n             hir::PatIdent(hir::BindByRef(..), _, _) => {\n@@ -798,9 +798,9 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                 _ => vec!(Single)\n             },\n         hir::PatLit(ref expr) =>\n-            vec!(ConstantValue(eval_const_expr(cx.tcx, &**expr))),\n+            vec!(ConstantValue(eval_const_expr(cx.tcx, &expr))),\n         hir::PatRange(ref lo, ref hi) =>\n-            vec!(ConstantRange(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi))),\n+            vec!(ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))),\n         hir::PatVec(ref before, ref slice, ref after) =>\n             match left_ty.sty {\n                 ty::TyArray(_, _) => vec!(Single),\n@@ -941,7 +941,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             Some(vec![&**inner]),\n \n         hir::PatLit(ref expr) => {\n-            let expr_value = eval_const_expr(cx.tcx, &**expr);\n+            let expr_value = eval_const_expr(cx.tcx, &expr);\n             match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n@@ -953,8 +953,8 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         hir::PatRange(ref from, ref to) => {\n-            let from_value = eval_const_expr(cx.tcx, &**from);\n-            let to_value = eval_const_expr(cx.tcx, &**to);\n+            let from_value = eval_const_expr(cx.tcx, &from);\n+            let to_value = eval_const_expr(cx.tcx, &to);\n             match range_covered_by_constructor(constructor, &from_value, &to_value) {\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n@@ -1012,7 +1012,7 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &hir::Local) {\n \n     // Check legality of move bindings and `@` patterns.\n     check_legality_of_move_bindings(cx, false, slice::ref_slice(&loc.pat));\n-    check_legality_of_bindings_in_at_patterns(cx, &*loc.pat);\n+    check_legality_of_bindings_in_at_patterns(cx, &loc.pat);\n }\n \n fn check_fn(cx: &mut MatchCheckCtxt,\n@@ -1031,7 +1031,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n     for input in &decl.inputs {\n         check_irrefutable(cx, &input.pat, true);\n         check_legality_of_move_bindings(cx, false, slice::ref_slice(&input.pat));\n-        check_legality_of_bindings_in_at_patterns(cx, &*input.pat);\n+        check_legality_of_bindings_in_at_patterns(cx, &input.pat);\n     }\n }\n \n@@ -1058,7 +1058,7 @@ fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A>\n     match is_useful(cx, &pats, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             assert_eq!(pats.len(), 1);\n-            Some(refutable(&*pats[0]))\n+            Some(refutable(&pats[0]))\n         },\n         NotUseful => None,\n         Useful => unreachable!()\n@@ -1073,7 +1073,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n     for pat in pats {\n-        pat_bindings(def_map, &**pat, |bm, _, span, _path| {\n+        pat_bindings(def_map, &pat, |bm, _, span, _path| {\n             match bm {\n                 hir::BindByRef(_) => {\n                     by_ref_span = Some(span);\n@@ -1088,7 +1088,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n-        if sub.map_or(false, |p| pat_contains_bindings(&def_map.borrow(), &*p)) {\n+        if sub.map_or(false, |p| pat_contains_bindings(&def_map.borrow(), &p)) {\n             span_err!(cx.tcx.sess, p.span, E0007, \"cannot bind by-move with sub-bindings\");\n         } else if has_guard {\n             span_err!(cx.tcx.sess, p.span, E0008, \"cannot bind by-move into a pattern guard\");\n@@ -1101,8 +1101,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     };\n \n     for pat in pats {\n-        front_util::walk_pat(&**pat, |p| {\n-            if pat_is_binding(&def_map.borrow(), &*p) {\n+        front_util::walk_pat(&pat, |p| {\n+            if pat_is_binding(&def_map.borrow(), &p) {\n                 match p.node {\n                     hir::PatIdent(hir::BindByValue(_), _, ref sub) => {\n                         let pat_ty = tcx.node_id_to_type(p.id);"}, {"sha": "f9922f725c615f47cd0064375cb0c36f0137367c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -94,7 +94,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 hir::ItemConst(_, ref const_expr) => {\n-                    Some(&*const_expr)\n+                    Some(&const_expr)\n                 }\n                 _ => None\n             },\n@@ -129,7 +129,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n             },\n             Some(ast_map::NodeImplItem(ii)) => match ii.node {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n-                    Some(&*expr)\n+                    Some(&expr)\n                 }\n                 _ => None\n             },\n@@ -325,7 +325,7 @@ impl ConstVal {\n pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n     let pat = match expr.node {\n         hir::ExprTup(ref exprs) =>\n-            hir::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect()),\n+            hir::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect()),\n \n         hir::ExprCall(ref callee, ref args) => {\n             let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n@@ -342,7 +342,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n                 }),\n                 _ => unreachable!()\n             };\n-            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n+            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n             hir::PatEnum(path, Some(pats))\n         }\n \n@@ -351,15 +351,15 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n                 span: codemap::DUMMY_SP,\n                 node: hir::FieldPat {\n                     name: field.name.node,\n-                    pat: const_expr_to_pat(tcx, &*field.expr, span),\n+                    pat: const_expr_to_pat(tcx, &field.expr, span),\n                     is_shorthand: false,\n                 },\n             }).collect();\n             hir::PatStruct(path.clone(), field_pats, false)\n         }\n \n         hir::ExprVec(ref exprs) => {\n-            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n+            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n             hir::PatVec(pats, None, hir::HirVec::new())\n         }\n \n@@ -850,7 +850,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let result = match e.node {\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n-        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint, fn_args)) {\n+        match try!(eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)) {\n           Float(f) => Float(-f),\n           Int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n           Uint(i) => {\n@@ -860,7 +860,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint, fn_args)) {\n+        match try!(eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)) {\n           Int(i) => Int(!i),\n           Uint(i) => const_uint_not(i, expr_uint_type),\n           Bool(b) => Bool(!b),\n@@ -872,8 +872,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             hir::BiShl | hir::BiShr => ty_hint.checked_or(tcx.types.usize),\n             _ => ty_hint\n         };\n-        match (try!(eval_const_expr_partial(tcx, &**a, ty_hint, fn_args)),\n-               try!(eval_const_expr_partial(tcx, &**b, b_ty, fn_args))) {\n+        match (try!(eval_const_expr_partial(tcx, &a, ty_hint, fn_args)),\n+               try!(eval_const_expr_partial(tcx, &b, b_ty, fn_args))) {\n           (Float(a), Float(b)) => {\n             match op.node {\n               hir::BiAdd => Float(a + b),\n@@ -964,7 +964,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n       }\n       hir::ExprCast(ref base, ref target_ty) => {\n-        let ety = ety.or_else(|| ast_ty_to_prim_ty(tcx, &**target_ty))\n+        let ety = ety.or_else(|| ast_ty_to_prim_ty(tcx, &target_ty))\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n@@ -982,7 +982,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         };\n \n-        let val = try!(eval_const_expr_partial(tcx, &**base, base_hint, fn_args));\n+        let val = try!(eval_const_expr_partial(tcx, &base, base_hint, fn_args));\n         match cast_const(tcx, val, ety) {\n             Ok(val) => val,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n@@ -1116,16 +1116,16 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               assert!(old.is_none());\n           }\n           debug!(\"const call({:?})\", call_args);\n-          try!(eval_const_expr_partial(tcx, &**result, ty_hint, Some(&call_args)))\n+          try!(eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args)))\n       },\n-      hir::ExprLit(ref lit) => lit_to_const(tcx.sess, e.span, &**lit, ety),\n+      hir::ExprLit(ref lit) => lit_to_const(tcx.sess, e.span, &lit, ety),\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ty_hint, fn_args)),\n+            Some(ref expr) => try!(eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)),\n             None => unreachable!(),\n         }\n       }\n-      hir::ExprType(ref e, _) => try!(eval_const_expr_partial(tcx, &**e, ty_hint, fn_args)),\n+      hir::ExprType(ref e, _) => try!(eval_const_expr_partial(tcx, &e, ty_hint, fn_args)),\n       hir::ExprTup(_) => Tuple(e.id),\n       hir::ExprStruct(..) => Struct(e.id),\n       hir::ExprIndex(ref arr, ref idx) => {\n@@ -1144,15 +1144,15 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         match arr {\n             Array(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n             Array(v, _) => if let hir::ExprVec(ref v) = tcx.map.expect_expr(v).node {\n-                try!(eval_const_expr_partial(tcx, &*v[idx as usize], ty_hint, fn_args))\n+                try!(eval_const_expr_partial(tcx, &v[idx as usize], ty_hint, fn_args))\n             } else {\n                 unreachable!()\n             },\n \n             Repeat(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n             Repeat(elem, _) => try!(eval_const_expr_partial(\n                 tcx,\n-                &*tcx.map.expect_expr(elem),\n+                &tcx.map.expect_expr(elem),\n                 ty_hint,\n                 fn_args,\n             )),\n@@ -1172,7 +1172,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           let len_hint = ty_hint.checked_or(tcx.types.usize);\n           Repeat(\n               e.id,\n-              match try!(eval_const_expr_partial(tcx, &**n, len_hint, fn_args)) {\n+              match try!(eval_const_expr_partial(tcx, &n, len_hint, fn_args)) {\n                   Int(i) if i >= 0 => i as u64,\n                   Int(_) => signal!(e, RepeatCountNotNatural),\n                   Uint(i) => i,\n@@ -1207,7 +1207,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 // if the idents are compared run-pass/issue-19244 fails\n                 if let Some(f) = fields.iter().find(|f| f.name.node\n                                                      == field_name.node) {\n-                    return eval_const_expr_partial(tcx, &*f.expr, base_hint, fn_args)\n+                    return eval_const_expr_partial(tcx, &f.expr, base_hint, fn_args)\n                 } else {\n                     signal!(e, MissingStructField);\n                 }"}, {"sha": "5de192ca4ebfb0019abcc6856e4f483adb4dbbc9", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -254,8 +254,8 @@ impl InlinedItem {\n         where V: Visitor<'ast>\n     {\n         match *self {\n-            InlinedItem::Item(ref i) => visitor.visit_item(&**i),\n-            InlinedItem::Foreign(ref i) => visitor.visit_foreign_item(&**i),\n+            InlinedItem::Item(ref i) => visitor.visit_item(&i),\n+            InlinedItem::Foreign(ref i) => visitor.visit_foreign_item(&i),\n             InlinedItem::TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n             InlinedItem::ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n         }"}, {"sha": "ae2252b6df6ca88e33a304c6486fb1d12b6cf2dc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -183,17 +183,17 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                                 .contains(&attr::ReprExtern)\n                         });\n \n-                        intravisit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &item);\n                     }\n                     hir::ItemEnum(..) => {\n                         self.inherited_pub_visibility = item.vis == hir::Public;\n-                        intravisit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &item);\n                     }\n                     hir::ItemFn(..)\n                     | hir::ItemTy(..)\n                     | hir::ItemStatic(..)\n                     | hir::ItemConst(..) => {\n-                        intravisit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &item);\n                     }\n                     _ => ()\n                 }\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 intravisit::walk_impl_item(self, impl_item);\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n-                intravisit::walk_foreign_item(self, &*foreign_item);\n+                intravisit::walk_foreign_item(self, &foreign_item);\n             }\n             _ => ()\n         }\n@@ -237,10 +237,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.lookup_and_handle_method(expr.id);\n             }\n             hir::ExprField(ref lhs, ref name) => {\n-                self.handle_field_access(&**lhs, name.node);\n+                self.handle_field_access(&lhs, name.node);\n             }\n             hir::ExprTupField(ref lhs, idx) => {\n-                self.handle_tup_field_access(&**lhs, idx.node);\n+                self.handle_tup_field_access(&lhs, idx.node);\n             }\n             _ => ()\n         }\n@@ -257,7 +257,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             // necessary for the pattern to match. Those construction sites\n             // can't be reached unless the variant is constructed elsewhere.\n             let len = self.ignore_variant_stack.len();\n-            self.ignore_variant_stack.extend_from_slice(&*variants);\n+            self.ignore_variant_stack.extend_from_slice(&variants);\n             intravisit::walk_arm(self, arm);\n             self.ignore_variant_stack.truncate(len);\n         } else {"}, {"sha": "5bdb553a2fea98708d3eb5bf50eeda3a955206ae", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -303,7 +303,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 ty::ReScope(fn_body_scope), // Args live only as long as the fn body.\n                 arg_ty);\n \n-            self.walk_irrefutable_pat(arg_cmt, &*arg.pat);\n+            self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n         }\n     }\n \n@@ -324,7 +324,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n     fn consume_exprs(&mut self, exprs: &[P<hir::Expr>]) {\n         for expr in exprs {\n-            self.consume_expr(&**expr);\n+            self.consume_expr(&expr);\n         }\n     }\n \n@@ -372,40 +372,40 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             hir::ExprPath(..) => { }\n \n             hir::ExprType(ref subexpr, _) => {\n-                self.walk_expr(&**subexpr)\n+                self.walk_expr(&subexpr)\n             }\n \n             hir::ExprUnary(hir::UnDeref, ref base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, &**base, Vec::new(), PassArgs::ByRef) {\n-                    self.select_from_expr(&**base);\n+                if !self.walk_overloaded_operator(expr, &base, Vec::new(), PassArgs::ByRef) {\n+                    self.select_from_expr(&base);\n                 }\n             }\n \n             hir::ExprField(ref base, _) => {         // base.f\n-                self.select_from_expr(&**base);\n+                self.select_from_expr(&base);\n             }\n \n             hir::ExprTupField(ref base, _) => {         // base.<n>\n-                self.select_from_expr(&**base);\n+                self.select_from_expr(&base);\n             }\n \n             hir::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n                 if !self.walk_overloaded_operator(expr,\n-                                                  &**lhs,\n-                                                  vec![&**rhs],\n+                                                  &lhs,\n+                                                  vec![&rhs],\n                                                   PassArgs::ByValue) {\n-                    self.select_from_expr(&**lhs);\n-                    self.consume_expr(&**rhs);\n+                    self.select_from_expr(&lhs);\n+                    self.consume_expr(&rhs);\n                 }\n             }\n \n             hir::ExprRange(ref start, ref end) => {\n-                start.as_ref().map(|e| self.consume_expr(&**e));\n-                end.as_ref().map(|e| self.consume_expr(&**e));\n+                start.as_ref().map(|e| self.consume_expr(&e));\n+                end.as_ref().map(|e| self.consume_expr(&e));\n             }\n \n             hir::ExprCall(ref callee, ref args) => {    // callee(args)\n-                self.walk_callee(expr, &**callee);\n+                self.walk_callee(expr, &callee);\n                 self.consume_exprs(args);\n             }\n \n@@ -422,16 +422,16 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             }\n \n             hir::ExprIf(ref cond_expr, ref then_blk, ref opt_else_expr) => {\n-                self.consume_expr(&**cond_expr);\n-                self.walk_block(&**then_blk);\n+                self.consume_expr(&cond_expr);\n+                self.walk_block(&then_blk);\n                 if let Some(ref else_expr) = *opt_else_expr {\n-                    self.consume_expr(&**else_expr);\n+                    self.consume_expr(&else_expr);\n                 }\n             }\n \n             hir::ExprMatch(ref discr, ref arms, _) => {\n-                let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));\n-                self.borrow_expr(&**discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n+                let discr_cmt = return_if_err!(self.mc.cat_expr(&discr));\n+                self.borrow_expr(&discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n@@ -451,20 +451,20 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 let expr_ty = return_if_err!(self.typer.node_ty(expr.id));\n                 if let ty::TyRef(&r, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n-                    self.borrow_expr(&**base, r, bk, AddrOf);\n+                    self.borrow_expr(&base, r, bk, AddrOf);\n                 }\n             }\n \n             hir::ExprInlineAsm(ref ia) => {\n                 for &(_, ref input) in &ia.inputs {\n-                    self.consume_expr(&**input);\n+                    self.consume_expr(&input);\n                 }\n \n                 for output in &ia.outputs {\n                     if output.is_indirect {\n-                        self.consume_expr(&*output.expr);\n+                        self.consume_expr(&output.expr);\n                     } else {\n-                        self.mutate_expr(expr, &*output.expr,\n+                        self.mutate_expr(expr, &output.expr,\n                                          if output.is_rw {\n                                              MutateMode::WriteAndRead\n                                          } else {\n@@ -479,12 +479,12 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             hir::ExprLit(..) => {}\n \n             hir::ExprLoop(ref blk, _) => {\n-                self.walk_block(&**blk);\n+                self.walk_block(&blk);\n             }\n \n             hir::ExprWhile(ref cond_expr, ref blk, _) => {\n-                self.consume_expr(&**cond_expr);\n-                self.walk_block(&**blk);\n+                self.consume_expr(&cond_expr);\n+                self.walk_block(&blk);\n             }\n \n             hir::ExprUnary(op, ref lhs) => {\n@@ -494,8 +494,8 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                     PassArgs::ByRef\n                 };\n \n-                if !self.walk_overloaded_operator(expr, &**lhs, Vec::new(), pass_args) {\n-                    self.consume_expr(&**lhs);\n+                if !self.walk_overloaded_operator(expr, &lhs, Vec::new(), pass_args) {\n+                    self.consume_expr(&lhs);\n                 }\n             }\n \n@@ -506,52 +506,52 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                     PassArgs::ByRef\n                 };\n \n-                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], pass_args) {\n-                    self.consume_expr(&**lhs);\n-                    self.consume_expr(&**rhs);\n+                if !self.walk_overloaded_operator(expr, &lhs, vec![&rhs], pass_args) {\n+                    self.consume_expr(&lhs);\n+                    self.consume_expr(&rhs);\n                 }\n             }\n \n             hir::ExprBlock(ref blk) => {\n-                self.walk_block(&**blk);\n+                self.walk_block(&blk);\n             }\n \n             hir::ExprRet(ref opt_expr) => {\n                 if let Some(ref expr) = *opt_expr {\n-                    self.consume_expr(&**expr);\n+                    self.consume_expr(&expr);\n                 }\n             }\n \n             hir::ExprAssign(ref lhs, ref rhs) => {\n-                self.mutate_expr(expr, &**lhs, MutateMode::JustWrite);\n-                self.consume_expr(&**rhs);\n+                self.mutate_expr(expr, &lhs, MutateMode::JustWrite);\n+                self.consume_expr(&rhs);\n             }\n \n             hir::ExprCast(ref base, _) => {\n-                self.consume_expr(&**base);\n+                self.consume_expr(&base);\n             }\n \n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 // NB All our assignment operations take the RHS by value\n                 assert!(::rustc_front::util::is_by_value_binop(op.node));\n \n                 if !self.walk_overloaded_operator(expr, lhs, vec![rhs], PassArgs::ByValue) {\n-                    self.mutate_expr(expr, &**lhs, MutateMode::WriteAndRead);\n-                    self.consume_expr(&**rhs);\n+                    self.mutate_expr(expr, &lhs, MutateMode::WriteAndRead);\n+                    self.consume_expr(&rhs);\n                 }\n             }\n \n             hir::ExprRepeat(ref base, ref count) => {\n-                self.consume_expr(&**base);\n-                self.consume_expr(&**count);\n+                self.consume_expr(&base);\n+                self.consume_expr(&count);\n             }\n \n             hir::ExprClosure(..) => {\n                 self.walk_captures(expr)\n             }\n \n             hir::ExprBox(ref base) => {\n-                self.consume_expr(&**base);\n+                self.consume_expr(&base);\n             }\n         }\n     }\n@@ -602,7 +602,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             hir::StmtDecl(ref decl, _) => {\n                 match decl.node {\n                     hir::DeclLocal(ref local) => {\n-                        self.walk_local(&**local);\n+                        self.walk_local(&local);\n                     }\n \n                     hir::DeclItem(_) => {\n@@ -614,7 +614,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n             hir::StmtExpr(ref expr, _) |\n             hir::StmtSemi(ref expr, _) => {\n-                self.consume_expr(&**expr);\n+                self.consume_expr(&expr);\n             }\n         }\n     }\n@@ -623,7 +623,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&self.typer.tcx.def_map, &*local.pat,\n+                pat_util::pat_bindings(&self.typer.tcx.def_map, &local.pat,\n                                        |_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n@@ -634,9 +634,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 // initializers are considered\n                 // \"assigns\", which is handled by\n                 // `walk_pat`:\n-                self.walk_expr(&**expr);\n-                let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n-                self.walk_irrefutable_pat(init_cmt, &*local.pat);\n+                self.walk_expr(&expr);\n+                let init_cmt = return_if_err!(self.mc.cat_expr(&expr));\n+                self.walk_irrefutable_pat(init_cmt, &local.pat);\n             }\n         }\n     }\n@@ -651,7 +651,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         }\n \n         if let Some(ref tail_expr) = blk.expr {\n-            self.consume_expr(&**tail_expr);\n+            self.consume_expr(&tail_expr);\n         }\n     }\n \n@@ -661,15 +661,15 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         opt_with: &Option<P<hir::Expr>>) {\n         // Consume the expressions supplying values for each field.\n         for field in fields {\n-            self.consume_expr(&*field.expr);\n+            self.consume_expr(&field.expr);\n         }\n \n         let with_expr = match *opt_with {\n             Some(ref w) => &**w,\n             None => { return; }\n         };\n \n-        let with_cmt = return_if_err!(self.mc.cat_expr(&*with_expr));\n+        let with_cmt = return_if_err!(self.mc.cat_expr(&with_expr));\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n@@ -906,21 +906,21 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) -> TrackMatchMode {\n         let mut mode = Unknown;\n         for pat in &arm.pats {\n-            self.determine_pat_move_mode(discr_cmt.clone(), &**pat, &mut mode);\n+            self.determine_pat_move_mode(discr_cmt.clone(), &pat, &mut mode);\n         }\n         mode\n     }\n \n     fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm, mode: MatchMode) {\n         for pat in &arm.pats {\n-            self.walk_pat(discr_cmt.clone(), &**pat, mode);\n+            self.walk_pat(discr_cmt.clone(), &pat, mode);\n         }\n \n         if let Some(ref guard) = arm.guard {\n-            self.consume_expr(&**guard);\n+            self.consume_expr(&guard);\n         }\n \n-        self.consume_expr(&*arm.body);\n+        self.consume_expr(&arm.body);\n     }\n \n     /// Walks a pat that occurs in isolation (i.e. top-level of fn\n@@ -1029,7 +1029,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         // matched.\n \n                         let (slice_cmt, slice_mutbl, slice_r) =\n-                            return_if_err!(mc.cat_slice_pattern(cmt_pat, &**slice_pat));\n+                            return_if_err!(mc.cat_slice_pattern(cmt_pat, &slice_pat));\n \n                         // Note: We declare here that the borrow\n                         // occurs upon entering the `[...]`"}, {"sha": "8c578bcd3d2aec38d38c2c4e7d6e582326a2eaa3", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -145,7 +145,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n                         _ => \"expression\",\n                     },\n                     Some(ast_map::NodeStmt(_)) => \"statement\",\n-                    Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n+                    Some(ast_map::NodeItem(it)) => item_scope_tag(&it),\n                     Some(_) | None => {\n                         err.span_note(span, &unknown_scope());\n                         return;\n@@ -190,7 +190,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n                         (format!(\"{} {}\", prefix, msg), opt_span)\n                     }\n                     Some(ast_map::NodeItem(it)) => {\n-                        let tag = item_scope_tag(&*it);\n+                        let tag = item_scope_tag(&it);\n                         let (msg, opt_span) = explain_span(self, tag, it.span);\n                         (format!(\"{} {}\", prefix, msg), opt_span)\n                     }\n@@ -1333,7 +1333,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                        -> hir::HirVec<hir::Arg> {\n         let mut new_inputs = Vec::new();\n         for arg in inputs {\n-            let new_ty = self.rebuild_arg_ty_or_output(&*arg.ty, lifetime,\n+            let new_ty = self.rebuild_arg_ty_or_output(&arg.ty, lifetime,\n                                                        anon_nums, region_names);\n             let possibly_new_arg = hir::Arg {\n                 ty: new_ty,\n@@ -1351,7 +1351,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                       region_names: &HashSet<ast::Name>) -> hir::FunctionRetTy {\n         match *ty {\n             hir::Return(ref ret_ty) => hir::Return(\n-                self.rebuild_arg_ty_or_output(&**ret_ty, lifetime, anon_nums, region_names)\n+                self.rebuild_arg_ty_or_output(&ret_ty, lifetime, anon_nums, region_names)\n             ),\n             hir::DefaultReturn(span) => hir::DefaultReturn(span),\n             hir::NoReturn(span) => hir::NoReturn(span)\n@@ -1390,7 +1390,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         };\n                         new_ty = self.rebuild_ty(new_ty, P(to));\n                     }\n-                    ty_queue.push(&*mut_ty.ty);\n+                    ty_queue.push(&mut_ty.ty);\n                 }\n                 hir::TyPath(ref maybe_qself, ref path) => {\n                     let a_def = match self.tcx.def_map.borrow().get(&cur_ty.id) {\n@@ -1455,11 +1455,11 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 }\n \n                 hir::TyPtr(ref mut_ty) => {\n-                    ty_queue.push(&*mut_ty.ty);\n+                    ty_queue.push(&mut_ty.ty);\n                 }\n                 hir::TyVec(ref ty) |\n                 hir::TyFixedLengthVec(ref ty, _) => {\n-                    ty_queue.push(&**ty);\n+                    ty_queue.push(&ty);\n                 }\n                 hir::TyTup(ref tys) => ty_queue.extend(tys.iter().map(|ty| &**ty)),\n                 _ => {}\n@@ -1554,13 +1554,13 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     }\n                 }\n                 let new_types = data.types.iter().map(|t| {\n-                    self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n+                    self.rebuild_arg_ty_or_output(&t, lifetime, anon_nums, region_names)\n                 }).collect();\n                 let new_bindings = data.bindings.iter().map(|b| {\n                     hir::TypeBinding {\n                         id: b.id,\n                         name: b.name,\n-                        ty: self.rebuild_arg_ty_or_output(&*b.ty,\n+                        ty: self.rebuild_arg_ty_or_output(&b.ty,\n                                                           lifetime,\n                                                           anon_nums,\n                                                           region_names),"}, {"sha": "dafa65c5bdca86663f39a664e1fb963ad92f4644", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -76,7 +76,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n \n     let output_path = {\n         let output_template = match requested_output {\n-            Ok(ref s) if &**s == \"help\" => {\n+            Ok(ref s) if s == \"help\" => {\n                 static PRINTED_YET: AtomicBool = AtomicBool::new(false);\n                 if !PRINTED_YET.load(Ordering::SeqCst) {\n                     print_help_message();"}, {"sha": "a487ddbc2b1c258aa5a3489e158f256a774c1ca2", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -382,7 +382,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     for arg in &decl.inputs {\n         pat_util::pat_bindings(&ir.tcx.def_map,\n-                               &*arg.pat,\n+                               &arg.pat,\n                                |_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n             let name = path1.node;\n@@ -416,7 +416,7 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n-    pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path1| {\n+    pat_util::pat_bindings(&ir.tcx.def_map, &local.pat, |_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node;\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -430,7 +430,7 @@ fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n     for pat in &arm.pats {\n-        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n+        pat_util::pat_bindings(&ir.tcx.def_map, &pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = path1.node;\n@@ -876,11 +876,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                               -> LiveNode {\n         match stmt.node {\n             hir::StmtDecl(ref decl, _) => {\n-                self.propagate_through_decl(&**decl, succ)\n+                self.propagate_through_decl(&decl, succ)\n             }\n \n             hir::StmtExpr(ref expr, _) | hir::StmtSemi(ref expr, _) => {\n-                self.propagate_through_expr(&**expr, succ)\n+                self.propagate_through_expr(&expr, succ)\n             }\n         }\n     }\n@@ -889,7 +889,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                               -> LiveNode {\n         match decl.node {\n             hir::DeclLocal(ref local) => {\n-                self.propagate_through_local(&**local, succ)\n+                self.propagate_through_local(&local, succ)\n             }\n             hir::DeclItem(_) => succ,\n         }\n@@ -912,13 +912,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // once at the func header but otherwise equivalent.\n \n         let succ = self.propagate_through_opt_expr(local.init.as_ref().map(|e| &**e), succ);\n-        self.define_bindings_in_pat(&*local.pat, succ)\n+        self.define_bindings_in_pat(&local.pat, succ)\n     }\n \n     fn propagate_through_exprs(&mut self, exprs: &[P<Expr>], succ: LiveNode)\n                                -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| {\n-            self.propagate_through_expr(&**expr, succ)\n+            self.propagate_through_expr(&expr, succ)\n         })\n     }\n \n@@ -941,11 +941,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprField(ref e, _) => {\n-              self.propagate_through_expr(&**e, succ)\n+              self.propagate_through_expr(&e, succ)\n           }\n \n           hir::ExprTupField(ref e, _) => {\n-              self.propagate_through_expr(&**e, succ)\n+              self.propagate_through_expr(&e, succ)\n           }\n \n           hir::ExprClosure(_, _, ref blk) => {\n@@ -991,21 +991,21 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             //   (  succ  )\n             //\n             let else_ln = self.propagate_through_opt_expr(els.as_ref().map(|e| &**e), succ);\n-            let then_ln = self.propagate_through_block(&**then, succ);\n+            let then_ln = self.propagate_through_block(&then, succ);\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, else_ln);\n             self.merge_from_succ(ln, then_ln, false);\n-            self.propagate_through_expr(&**cond, ln)\n+            self.propagate_through_expr(&cond, ln)\n           }\n \n           hir::ExprWhile(ref cond, ref blk, _) => {\n-            self.propagate_through_loop(expr, WhileLoop(&**cond), &**blk, succ)\n+            self.propagate_through_loop(expr, WhileLoop(&cond), &blk, succ)\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n           hir::ExprLoop(ref blk, _) => {\n-            self.propagate_through_loop(expr, LoopLoop, &**blk, succ)\n+            self.propagate_through_loop(expr, LoopLoop, &blk, succ)\n           }\n \n           hir::ExprMatch(ref e, ref arms, _) => {\n@@ -1028,7 +1028,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             let mut first_merge = true;\n             for arm in arms {\n                 let body_succ =\n-                    self.propagate_through_expr(&*arm.body, succ);\n+                    self.propagate_through_expr(&arm.body, succ);\n                 let guard_succ =\n                     self.propagate_through_opt_expr(arm.guard.as_ref().map(|e| &**e), body_succ);\n                 // only consider the first pattern; any later patterns must have\n@@ -1040,7 +1040,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n             };\n-            self.propagate_through_expr(&**e, ln)\n+            self.propagate_through_expr(&e, ln)\n           }\n \n           hir::ExprRet(ref o_e) => {\n@@ -1080,17 +1080,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprAssign(ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n-            let succ = self.write_lvalue(&**l, succ, ACC_WRITE);\n-            let succ = self.propagate_through_lvalue_components(&**l, succ);\n-            self.propagate_through_expr(&**r, succ)\n+            let succ = self.write_lvalue(&l, succ, ACC_WRITE);\n+            let succ = self.propagate_through_lvalue_components(&l, succ);\n+            self.propagate_through_expr(&r, succ)\n           }\n \n           hir::ExprAssignOp(_, ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n-            let succ = self.write_lvalue(&**l, succ, ACC_WRITE|ACC_READ);\n-            let succ = self.propagate_through_expr(&**r, succ);\n-            self.propagate_through_lvalue_components(&**l, succ)\n+            let succ = self.write_lvalue(&l, succ, ACC_WRITE|ACC_READ);\n+            let succ = self.propagate_through_expr(&r, succ);\n+            self.propagate_through_lvalue_components(&l, succ)\n           }\n \n           // Uninteresting cases: just propagate in rev exec order\n@@ -1100,27 +1100,27 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprRepeat(ref element, ref count) => {\n-            let succ = self.propagate_through_expr(&**count, succ);\n-            self.propagate_through_expr(&**element, succ)\n+            let succ = self.propagate_through_expr(&count, succ);\n+            self.propagate_through_expr(&element, succ)\n           }\n \n           hir::ExprStruct(_, ref fields, ref with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n-                self.propagate_through_expr(&*field.expr, succ)\n+                self.propagate_through_expr(&field.expr, succ)\n             })\n           }\n \n           hir::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n-                self.ir.tcx.expr_ty_adjusted(&**f).fn_ret().diverges();\n+                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().diverges();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n                 succ\n             };\n             let succ = self.propagate_through_exprs(&args[..], succ);\n-            self.propagate_through_expr(&**f, succ)\n+            self.propagate_through_expr(&f, succ)\n           }\n \n           hir::ExprMethodCall(_, _, ref args) => {\n@@ -1139,32 +1139,32 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprBinary(op, ref l, ref r) if ::rustc_front::util::lazy_binop(op.node) => {\n-            let r_succ = self.propagate_through_expr(&**r, succ);\n+            let r_succ = self.propagate_through_expr(&r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, succ);\n             self.merge_from_succ(ln, r_succ, false);\n \n-            self.propagate_through_expr(&**l, ln)\n+            self.propagate_through_expr(&l, ln)\n           }\n \n           hir::ExprIndex(ref l, ref r) |\n           hir::ExprBinary(_, ref l, ref r) => {\n-            let r_succ = self.propagate_through_expr(&**r, succ);\n-            self.propagate_through_expr(&**l, r_succ)\n+            let r_succ = self.propagate_through_expr(&r, succ);\n+            self.propagate_through_expr(&l, r_succ)\n           }\n \n           hir::ExprRange(ref e1, ref e2) => {\n-            let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n-            e1.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ))\n+            let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&e, succ));\n+            e1.as_ref().map_or(succ, |e| self.propagate_through_expr(&e, succ))\n           }\n \n           hir::ExprBox(ref e) |\n           hir::ExprAddrOf(_, ref e) |\n           hir::ExprCast(ref e, _) |\n           hir::ExprType(ref e, _) |\n           hir::ExprUnary(_, ref e) => {\n-            self.propagate_through_expr(&**e, succ)\n+            self.propagate_through_expr(&e, succ)\n           }\n \n           hir::ExprInlineAsm(ref ia) => {\n@@ -1174,17 +1174,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     // see comment on lvalues\n                     // in propagate_through_lvalue_components()\n                     if out.is_indirect {\n-                        self.propagate_through_expr(&*out.expr, succ)\n+                        self.propagate_through_expr(&out.expr, succ)\n                     } else {\n                         let acc = if out.is_rw { ACC_WRITE|ACC_READ } else { ACC_WRITE };\n-                        let succ = self.write_lvalue(&*out.expr, succ, acc);\n-                        self.propagate_through_lvalue_components(&*out.expr, succ)\n+                        let succ = self.write_lvalue(&out.expr, succ, acc);\n+                        self.propagate_through_lvalue_components(&out.expr, succ)\n                     }\n                 }\n             );\n             // Inputs are executed first. Propagate last because of rev order\n             ia.inputs.iter().rev().fold(succ, |succ, &(_, ref expr)| {\n-                self.propagate_through_expr(&**expr, succ)\n+                self.propagate_through_expr(&expr, succ)\n             })\n           }\n \n@@ -1193,7 +1193,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprBlock(ref blk) => {\n-            self.propagate_through_block(&**blk, succ)\n+            self.propagate_through_block(&blk, succ)\n           }\n         }\n     }\n@@ -1253,8 +1253,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         match expr.node {\n             hir::ExprPath(..) => succ,\n-            hir::ExprField(ref e, _) => self.propagate_through_expr(&**e, succ),\n-            hir::ExprTupField(ref e, _) => self.propagate_through_expr(&**e, succ),\n+            hir::ExprField(ref e, _) => self.propagate_through_expr(&e, succ),\n+            hir::ExprTupField(ref e, _) => self.propagate_through_expr(&e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -1336,7 +1336,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let cond_ln = match kind {\n             LoopLoop => ln,\n-            WhileLoop(ref cond) => self.propagate_through_expr(&**cond, ln),\n+            WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n         };\n         let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n             this.propagate_through_block(body, cond_ln)\n@@ -1349,7 +1349,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             let new_cond_ln = match kind {\n                 LoopLoop => ln,\n                 WhileLoop(ref cond) => {\n-                    self.propagate_through_expr(&**cond, ln)\n+                    self.propagate_through_expr(&cond, ln)\n                 }\n             };\n             assert!(cond_ln == new_cond_ln);\n@@ -1384,10 +1384,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n fn check_local(this: &mut Liveness, local: &hir::Local) {\n     match local.init {\n         Some(_) => {\n-            this.warn_about_unused_or_dead_vars_in_pat(&*local.pat);\n+            this.warn_about_unused_or_dead_vars_in_pat(&local.pat);\n         },\n         None => {\n-            this.pat_bindings(&*local.pat, |this, ln, var, sp, id| {\n+            this.pat_bindings(&local.pat, |this, ln, var, sp, id| {\n                 this.warn_about_unused(sp, id, ln, var);\n             })\n         }\n@@ -1409,28 +1409,28 @@ fn check_arm(this: &mut Liveness, arm: &hir::Arm) {\n fn check_expr(this: &mut Liveness, expr: &Expr) {\n     match expr.node {\n       hir::ExprAssign(ref l, _) => {\n-        this.check_lvalue(&**l);\n+        this.check_lvalue(&l);\n \n         intravisit::walk_expr(this, expr);\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n-        this.check_lvalue(&**l);\n+        this.check_lvalue(&l);\n \n         intravisit::walk_expr(this, expr);\n       }\n \n       hir::ExprInlineAsm(ref ia) => {\n         for &(_, ref input) in &ia.inputs {\n-          this.visit_expr(&**input);\n+          this.visit_expr(&input);\n         }\n \n         // Output operands must be lvalues\n         for out in &ia.outputs {\n           if !out.is_indirect {\n-            this.check_lvalue(&*out.expr);\n+            this.check_lvalue(&out.expr);\n           }\n-          this.visit_expr(&*out.expr);\n+          this.visit_expr(&out.expr);\n         }\n \n         intravisit::walk_expr(this, expr);\n@@ -1496,7 +1496,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         None if !body.stmts.is_empty() =>\n                             match body.stmts.first().unwrap().node {\n                                 hir::StmtSemi(ref e, _) => {\n-                                    self.ir.tcx.expr_ty(&**e) == t_ret\n+                                    self.ir.tcx.expr_ty(&e) == t_ret\n                                 },\n                                 _ => false\n                             },\n@@ -1565,7 +1565,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn warn_about_unused_args(&self, decl: &hir::FnDecl, entry_ln: LiveNode) {\n         for arg in &decl.inputs {\n             pat_util::pat_bindings(&self.ir.tcx.def_map,\n-                                   &*arg.pat,\n+                                   &arg.pat,\n                                    |_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self."}, {"sha": "71af07c21cf500738d5e6127260b3f3a192ecb82", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -463,12 +463,12 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         let expr_ty = try!(self.expr_ty(expr));\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n-            let base_cmt = try!(self.cat_expr(&**e_base));\n+            let base_cmt = try!(self.cat_expr(&e_base));\n             self.cat_deref(expr, base_cmt, 0, None)\n           }\n \n           hir::ExprField(ref base, f_name) => {\n-            let base_cmt = try!(self.cat_expr(&**base));\n+            let base_cmt = try!(self.cat_expr(&base));\n             debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                    expr.id,\n                    expr,\n@@ -477,7 +477,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           }\n \n           hir::ExprTupField(ref base, idx) => {\n-            let base_cmt = try!(self.cat_expr(&**base));\n+            let base_cmt = try!(self.cat_expr(&base));\n             Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n           }\n \n@@ -508,7 +508,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                     self.cat_deref_common(expr, base_cmt, 1, elem_ty, Some(context), true)\n                 }\n                 None => {\n-                    self.cat_index(expr, try!(self.cat_expr(&**base)), context)\n+                    self.cat_index(expr, try!(self.cat_expr(&base)), context)\n                 }\n             }\n           }\n@@ -519,7 +519,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           }\n \n           hir::ExprType(ref e, _) => {\n-            self.cat_expr(&**e)\n+            self.cat_expr(&e)\n           }\n \n           hir::ExprAddrOf(..) | hir::ExprCall(..) |\n@@ -584,7 +584,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                           None => {\n                               self.tcx().sess.span_bug(\n                                   span,\n-                                  &*format!(\"No closure kind for {:?}\", closure_id));\n+                                  &format!(\"No closure kind for {:?}\", closure_id));\n                           }\n                       }\n                   }\n@@ -1234,29 +1234,29 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 Some(Def::Variant(..)) => {\n                     // variant(x, y, z)\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n+                        let subpat_ty = try!(self.pat_ty(&subpat)); // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        try!(self.cat_pattern_(subcmt, &**subpat, op));\n+                        try!(self.cat_pattern_(subcmt, &subpat, op));\n                     }\n                 }\n                 Some(Def::Struct(..)) => {\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n+                        let subpat_ty = try!(self.pat_ty(&subpat)); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        try!(self.cat_pattern_(cmt_field, &**subpat, op));\n+                        try!(self.cat_pattern_(cmt_field, &subpat, op));\n                     }\n                 }\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {\n                     for subpat in subpats {\n-                        try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n+                        try!(self.cat_pattern_(cmt.clone(), &subpat, op));\n                     }\n                 }\n                 _ => {\n@@ -1272,7 +1272,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           }\n \n           hir::PatIdent(_, _, Some(ref subpat)) => {\n-              try!(self.cat_pattern_(cmt, &**subpat, op));\n+              try!(self.cat_pattern_(cmt, &subpat, op));\n           }\n \n           hir::PatIdent(_, _, None) => {\n@@ -1282,21 +1282,21 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           hir::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats {\n-                let field_ty = try!(self.pat_ty(&*fp.node.pat)); // see (*2)\n+                let field_ty = try!(self.pat_ty(&fp.node.pat)); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.name, field_ty);\n-                try!(self.cat_pattern_(cmt_field, &*fp.node.pat, op));\n+                try!(self.cat_pattern_(cmt_field, &fp.node.pat, op));\n             }\n           }\n \n           hir::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n+                let subpat_ty = try!(self.pat_ty(&subpat)); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                try!(self.cat_pattern_(subcmt, &**subpat, op));\n+                try!(self.cat_pattern_(subcmt, &subpat, op));\n             }\n           }\n \n@@ -1305,23 +1305,23 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             // PatRegion since that information is already contained\n             // in the type.\n             let subcmt = try!(self.cat_deref(pat, cmt, 0, None));\n-              try!(self.cat_pattern_(subcmt, &**subpat, op));\n+              try!(self.cat_pattern_(subcmt, &subpat, op));\n           }\n \n           hir::PatVec(ref before, ref slice, ref after) => {\n               let context = InteriorOffsetKind::Pattern;\n               let vec_cmt = try!(self.deref_vec(pat, cmt, context));\n               let elt_cmt = try!(self.cat_index(pat, vec_cmt, context));\n               for before_pat in before {\n-                  try!(self.cat_pattern_(elt_cmt.clone(), &**before_pat, op));\n+                  try!(self.cat_pattern_(elt_cmt.clone(), &before_pat, op));\n               }\n               if let Some(ref slice_pat) = *slice {\n-                  let slice_ty = try!(self.pat_ty(&**slice_pat));\n+                  let slice_ty = try!(self.pat_ty(&slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  try!(self.cat_pattern_(slice_cmt, &**slice_pat, op));\n+                  try!(self.cat_pattern_(slice_cmt, &slice_pat, op));\n               }\n               for after_pat in after {\n-                  try!(self.cat_pattern_(elt_cmt.clone(), &**after_pat, op));\n+                  try!(self.cat_pattern_(elt_cmt.clone(), &after_pat, op));\n               }\n           }\n "}, {"sha": "614d9be147bd874d27ad4628a87fba03a361eda6", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -65,7 +65,7 @@ fn method_might_be_inlined(tcx: &ty::ctxt, sig: &hir::MethodSig,\n     if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_src) {\n         match tcx.map.find(impl_node_id) {\n             Some(ast_map::NodeItem(item)) =>\n-                item_might_be_inlined(&*item),\n+                item_might_be_inlined(&item),\n             Some(..) | None =>\n                 tcx.sess.span_bug(impl_item.span, \"impl did is not an item\")\n         }\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match self.tcx.map.find(node_id) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(..) => item_might_be_inlined(&*item),\n+                    hir::ItemFn(..) => item_might_be_inlined(&item),\n                     _ => false,\n                 }\n             }\n@@ -255,16 +255,16 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n                     hir::ItemFn(_, _, _, _, _, ref search_block) => {\n-                        if item_might_be_inlined(&*item) {\n-                            intravisit::walk_block(self, &**search_block)\n+                        if item_might_be_inlined(&item) {\n+                            intravisit::walk_block(self, &search_block)\n                         }\n                     }\n \n                     // Reachable constants will be inlined into other crates\n                     // unconditionally, so we need to make sure that their\n                     // contents are also reachable.\n                     hir::ItemConst(_, ref init) => {\n-                        self.visit_expr(&**init);\n+                        self.visit_expr(&init);\n                     }\n \n                     // These are normal, nothing reachable about these\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         // Keep going, nothing to get exported\n                     }\n                     hir::ConstTraitItem(_, Some(ref expr)) => {\n-                        self.visit_expr(&*expr);\n+                        self.visit_expr(&expr);\n                     }\n                     hir::MethodTraitItem(_, Some(ref body)) => {\n                         intravisit::walk_block(self, body);\n@@ -296,7 +296,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             ast_map::NodeImplItem(impl_item) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(_, ref expr) => {\n-                        self.visit_expr(&*expr);\n+                        self.visit_expr(&expr);\n                     }\n                     hir::ImplItemKind::Method(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);"}, {"sha": "81d2f37bfd99e2158414f71b970773467f2d13d9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -933,13 +933,13 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n \n     match local.init {\n         Some(ref expr) => {\n-            record_rvalue_scope_if_borrow_expr(visitor, &**expr, blk_scope);\n+            record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);\n \n             let is_borrow =\n-                if let Some(ref ty) = local.ty { is_borrowed_ty(&**ty) } else { false };\n+                if let Some(ref ty) = local.ty { is_borrowed_ty(&ty) } else { false };\n \n-            if is_binding_pat(&*local.pat) || is_borrow {\n-                record_rvalue_scope(visitor, &**expr, blk_scope);\n+            if is_binding_pat(&local.pat) || is_borrow {\n+                record_rvalue_scope(visitor, &expr, blk_scope);\n             }\n         }\n \n@@ -961,22 +961,22 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n             hir::PatIdent(hir::BindByRef(_), _, _) => true,\n \n             hir::PatStruct(_, ref field_pats, _) => {\n-                field_pats.iter().any(|fp| is_binding_pat(&*fp.node.pat))\n+                field_pats.iter().any(|fp| is_binding_pat(&fp.node.pat))\n             }\n \n             hir::PatVec(ref pats1, ref pats2, ref pats3) => {\n-                pats1.iter().any(|p| is_binding_pat(&**p)) ||\n-                pats2.iter().any(|p| is_binding_pat(&**p)) ||\n-                pats3.iter().any(|p| is_binding_pat(&**p))\n+                pats1.iter().any(|p| is_binding_pat(&p)) ||\n+                pats2.iter().any(|p| is_binding_pat(&p)) ||\n+                pats3.iter().any(|p| is_binding_pat(&p))\n             }\n \n             hir::PatEnum(_, Some(ref subpats)) |\n             hir::PatTup(ref subpats) => {\n-                subpats.iter().any(|p| is_binding_pat(&**p))\n+                subpats.iter().any(|p| is_binding_pat(&p))\n             }\n \n             hir::PatBox(ref subpat) => {\n-                is_binding_pat(&**subpat)\n+                is_binding_pat(&subpat)\n             }\n \n             _ => false,\n@@ -1006,30 +1006,30 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n                                           blk_id: CodeExtent) {\n         match expr.node {\n             hir::ExprAddrOf(_, ref subexpr) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n-                record_rvalue_scope(visitor, &**subexpr, blk_id);\n+                record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n+                record_rvalue_scope(visitor, &subexpr, blk_id);\n             }\n             hir::ExprStruct(_, ref fields, _) => {\n                 for field in fields {\n                     record_rvalue_scope_if_borrow_expr(\n-                        visitor, &*field.expr, blk_id);\n+                        visitor, &field.expr, blk_id);\n                 }\n             }\n             hir::ExprVec(ref subexprs) |\n             hir::ExprTup(ref subexprs) => {\n                 for subexpr in subexprs {\n                     record_rvalue_scope_if_borrow_expr(\n-                        visitor, &**subexpr, blk_id);\n+                        visitor, &subexpr, blk_id);\n                 }\n             }\n             hir::ExprCast(ref subexpr, _) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id)\n+                record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n             }\n             hir::ExprBlock(ref block) => {\n                 match block.expr {\n                     Some(ref subexpr) => {\n                         record_rvalue_scope_if_borrow_expr(\n-                            visitor, &**subexpr, blk_id);\n+                            visitor, &subexpr, blk_id);\n                     }\n                     None => { }\n                 }\n@@ -1072,7 +1072,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n                 hir::ExprField(ref subexpr, _) |\n                 hir::ExprTupField(ref subexpr, _) |\n                 hir::ExprIndex(ref subexpr, _) => {\n-                    expr = &**subexpr;\n+                    expr = &subexpr;\n                 }\n                 _ => {\n                     return;"}, {"sha": "f29e14f67d73fa7b3407ecd70d2e08b53be9dd80", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n             match ty_param.default {\n-                Some(ref ty) => self.visit_ty(&**ty),\n+                Some(ref ty) => self.visit_ty(&ty),\n                 None => {}\n             }\n         }\n@@ -271,13 +271,13 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                         let result = self.with(LateScope(bound_lifetimes, self.scope),\n                                                |old_scope, this| {\n                             this.check_lifetime_defs(old_scope, bound_lifetimes);\n-                            this.visit_ty(&**bounded_ty);\n+                            this.visit_ty(&bounded_ty);\n                             walk_list!(this, visit_ty_param_bound, bounds);\n                         });\n                         self.trait_ref_hack = false;\n                         result\n                     } else {\n-                        self.visit_ty(&**bounded_ty);\n+                        self.visit_ty(&bounded_ty);\n                         walk_list!(self, visit_ty_param_bound, bounds);\n                     }\n                 }\n@@ -295,7 +295,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                                                                          ref ty,\n                                                                          .. }) => {\n                     self.visit_path(path, id);\n-                    self.visit_ty(&**ty);\n+                    self.visit_ty(&ty);\n                 }\n             }\n         }\n@@ -810,7 +810,7 @@ fn early_bound_lifetime_names(generics: &hir::Generics) -> Vec<ast::Name> {\n                 &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ref bounds,\n                                                                               ref bounded_ty,\n                                                                               ..}) => {\n-                    collector.visit_ty(&**bounded_ty);\n+                    collector.visit_ty(&bounded_ty);\n                     walk_list!(&mut collector, visit_ty_param_bound, bounds);\n                 }\n                 &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,"}, {"sha": "fac53ec140dbcad62fdedcf5a2746e52d8e4d390", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -770,7 +770,7 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                        err,\n                                        &parent_predicate,\n                                        cause_span,\n-                                       &*data.parent_code);\n+                                       &data.parent_code);\n         }\n         ObligationCauseCode::ImplDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n@@ -784,7 +784,7 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                        err,\n                                        &parent_predicate,\n                                        cause_span,\n-                                       &*data.parent_code);\n+                                       &data.parent_code);\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n             err.fileline_note("}, {"sha": "7ffdc3bdef27ad0fe491e07cec809ebf82e2262f", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -116,7 +116,7 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .filter_map(|item| {\n             match *item {\n                 ty::MethodTraitItem(ref m) => {\n-                    object_safety_violation_for_method(tcx, trait_def_id, &**m)\n+                    object_safety_violation_for_method(tcx, trait_def_id, &m)\n                         .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n                 }\n                 _ => None,"}, {"sha": "888a623b24a83d1960d14ffb14264d396faa09ef", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559fca0fd306dc1048cc66ca86f8c6fc89f9a055/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "patch": "@@ -196,7 +196,7 @@ pub fn block_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr) -\n         p: p,\n         flag: false,\n     };\n-    intravisit::walk_block(&mut v, &*b);\n+    intravisit::walk_block(&mut v, &b);\n     return v.flag;\n }\n "}]}