{"sha": "1bcb0ec28cd169e1e80efffc824287287d374147", "node_id": "C_kwDOAAsO6NoAKDFiY2IwZWMyOGNkMTY5ZTFlODBlZmZmYzgyNDI4NzI4N2QzNzQxNDc", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-04-06T07:36:36Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-04-13T07:12:39Z"}, "message": "`assume` value ranges in `transmute`\n\nFixes #109958", "tree": {"sha": "65dba0186b06611c9ab96675a5f6d0183cc85a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65dba0186b06611c9ab96675a5f6d0183cc85a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bcb0ec28cd169e1e80efffc824287287d374147", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bcb0ec28cd169e1e80efffc824287287d374147", "html_url": "https://github.com/rust-lang/rust/commit/1bcb0ec28cd169e1e80efffc824287287d374147", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bcb0ec28cd169e1e80efffc824287287d374147/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8fc8192471063c7b72fb2f95f61a9427ab84b86", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8fc8192471063c7b72fb2f95f61a9427ab84b86", "html_url": "https://github.com/rust-lang/rust/commit/d8fc8192471063c7b72fb2f95f61a9427ab84b86"}], "stats": {"total": 269, "additions": 253, "deletions": 16}, "files": [{"sha": "e05d03d150fe370c17b5b317169262779432273e", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 58, "deletions": 5, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1bcb0ec28cd169e1e80efffc824287287d374147/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bcb0ec28cd169e1e80efffc824287287d374147/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=1bcb0ec28cd169e1e80efffc824287287d374147", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::mir::Operand;\n use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n+use rustc_session::config::OptLevel;\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_target::abi::{self, FIRST_VARIANT};\n \n@@ -231,10 +232,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         (ScalarOrZst::Scalar(in_scalar), ScalarOrZst::Scalar(out_scalar))\n                             if in_scalar.size(self.cx) == out_scalar.size(self.cx) =>\n                         {\n+                            let operand_bty = bx.backend_type(operand.layout);\n                             let cast_bty = bx.backend_type(cast);\n-                            Some(OperandValue::Immediate(\n-                                self.transmute_immediate(bx, imm, in_scalar, out_scalar, cast_bty),\n-                            ))\n+                            Some(OperandValue::Immediate(self.transmute_immediate(\n+                                bx,\n+                                imm,\n+                                in_scalar,\n+                                operand_bty,\n+                                out_scalar,\n+                                cast_bty,\n+                            )))\n                         }\n                         _ => None,\n                     }\n@@ -250,11 +257,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     && in_a.size(self.cx) == out_a.size(self.cx)\n                     && in_b.size(self.cx) == out_b.size(self.cx)\n                 {\n+                    let in_a_ibty = bx.scalar_pair_element_backend_type(operand.layout, 0, false);\n+                    let in_b_ibty = bx.scalar_pair_element_backend_type(operand.layout, 1, false);\n                     let out_a_ibty = bx.scalar_pair_element_backend_type(cast, 0, false);\n                     let out_b_ibty = bx.scalar_pair_element_backend_type(cast, 1, false);\n                     Some(OperandValue::Pair(\n-                        self.transmute_immediate(bx, imm_a, in_a, out_a, out_a_ibty),\n-                        self.transmute_immediate(bx, imm_b, in_b, out_b, out_b_ibty),\n+                        self.transmute_immediate(bx, imm_a, in_a, in_a_ibty, out_a, out_a_ibty),\n+                        self.transmute_immediate(bx, imm_b, in_b, in_b_ibty, out_b, out_b_ibty),\n                     ))\n                 } else {\n                     None\n@@ -273,13 +282,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &mut Bx,\n         mut imm: Bx::Value,\n         from_scalar: abi::Scalar,\n+        from_backend_ty: Bx::Type,\n         to_scalar: abi::Scalar,\n         to_backend_ty: Bx::Type,\n     ) -> Bx::Value {\n         debug_assert_eq!(from_scalar.size(self.cx), to_scalar.size(self.cx));\n \n         use abi::Primitive::*;\n         imm = bx.from_immediate(imm);\n+        self.assume_scalar_range(bx, imm, from_scalar, from_backend_ty);\n         imm = match (from_scalar.primitive(), to_scalar.primitive()) {\n             (Int(..) | F32 | F64, Int(..) | F32 | F64) => bx.bitcast(imm, to_backend_ty),\n             (Pointer(..), Pointer(..)) => bx.pointercast(imm, to_backend_ty),\n@@ -294,10 +305,52 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx.bitcast(int_imm, to_backend_ty)\n             }\n         };\n+        self.assume_scalar_range(bx, imm, to_scalar, to_backend_ty);\n         imm = bx.to_immediate_scalar(imm, to_scalar);\n         imm\n     }\n \n+    fn assume_scalar_range(\n+        &self,\n+        bx: &mut Bx,\n+        imm: Bx::Value,\n+        scalar: abi::Scalar,\n+        backend_ty: Bx::Type,\n+    ) {\n+        if matches!(self.cx.sess().opts.optimize, OptLevel::No | OptLevel::Less)\n+            || !matches!(scalar.primitive(), abi::Primitive::Int(..))\n+            || scalar.is_always_valid(self.cx)\n+        {\n+            return;\n+        }\n+\n+        let abi::WrappingRange { start, end } = scalar.valid_range(self.cx);\n+\n+        if start <= end {\n+            if start > 0 {\n+                let low = bx.const_uint_big(backend_ty, start);\n+                let cmp = bx.icmp(IntPredicate::IntUGE, imm, low);\n+                bx.assume(cmp);\n+            }\n+\n+            let type_max = scalar.size(self.cx).unsigned_int_max();\n+            if end < type_max {\n+                let high = bx.const_uint_big(backend_ty, end);\n+                let cmp = bx.icmp(IntPredicate::IntULE, imm, high);\n+                bx.assume(cmp);\n+            }\n+        } else {\n+            let low = bx.const_uint_big(backend_ty, start);\n+            let cmp_low = bx.icmp(IntPredicate::IntUGE, imm, low);\n+\n+            let high = bx.const_uint_big(backend_ty, end);\n+            let cmp_high = bx.icmp(IntPredicate::IntULE, imm, high);\n+\n+            let or = bx.or(cmp_low, cmp_high);\n+            bx.assume(or);\n+        }\n+    }\n+\n     pub fn codegen_rvalue_unsized(\n         &mut self,\n         bx: &mut Bx,"}, {"sha": "69e9b1d12062ea8f1d9178039331d82fb7ff58b6", "filename": "tests/codegen/intrinsics/transmute-niched.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/1bcb0ec28cd169e1e80efffc824287287d374147/tests%2Fcodegen%2Fintrinsics%2Ftransmute-niched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bcb0ec28cd169e1e80efffc824287287d374147/tests%2Fcodegen%2Fintrinsics%2Ftransmute-niched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute-niched.rs?ref=1bcb0ec28cd169e1e80efffc824287287d374147", "patch": "@@ -0,0 +1,184 @@\n+// revisions: OPT DBG\n+// [OPT] compile-flags: -C opt-level=3 -C no-prepopulate-passes\n+// [DBG] compile-flags: -C opt-level=0 -C no-prepopulate-passes\n+// only-64bit (so I don't need to worry about usize)\n+// min-llvm-version: 15.0 # this test assumes `ptr`s\n+\n+#![crate_type = \"lib\"]\n+\n+use std::mem::transmute;\n+use std::num::NonZeroU32;\n+\n+#[repr(u8)]\n+pub enum SmallEnum {\n+    A = 10,\n+    B = 11,\n+    C = 12,\n+}\n+\n+// CHECK-LABEL: @check_to_enum(\n+#[no_mangle]\n+pub unsafe fn check_to_enum(x: i8) -> SmallEnum {\n+    // OPT: %0 = icmp uge i8 %x, 10\n+    // OPT: call void @llvm.assume(i1 %0)\n+    // OPT: %1 = icmp ule i8 %x, 12\n+    // OPT: call void @llvm.assume(i1 %1)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i8 %x\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_enum(\n+#[no_mangle]\n+pub unsafe fn check_from_enum(x: SmallEnum) -> i8 {\n+    // OPT: %0 = icmp uge i8 %x, 10\n+    // OPT: call void @llvm.assume(i1 %0)\n+    // OPT: %1 = icmp ule i8 %x, 12\n+    // OPT: call void @llvm.assume(i1 %1)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i8 %x\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_to_ordering(\n+#[no_mangle]\n+pub unsafe fn check_to_ordering(x: u8) -> std::cmp::Ordering {\n+    // OPT: %0 = icmp uge i8 %x, -1\n+    // OPT: %1 = icmp ule i8 %x, 1\n+    // OPT: %2 = or i1 %0, %1\n+    // OPT: call void @llvm.assume(i1 %2)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i8 %x\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_ordering(\n+#[no_mangle]\n+pub unsafe fn check_from_ordering(x: std::cmp::Ordering) -> u8 {\n+    // OPT: %0 = icmp uge i8 %x, -1\n+    // OPT: %1 = icmp ule i8 %x, 1\n+    // OPT: %2 = or i1 %0, %1\n+    // OPT: call void @llvm.assume(i1 %2)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i8 %x\n+\n+    transmute(x)\n+}\n+\n+#[repr(i32)]\n+pub enum Minus100ToPlus100 {\n+    A = -100,\n+    B = -90,\n+    C = -80,\n+    D = -70,\n+    E = -60,\n+    F = -50,\n+    G = -40,\n+    H = -30,\n+    I = -20,\n+    J = -10,\n+    K = 0,\n+    L = 10,\n+    M = 20,\n+    N = 30,\n+    O = 40,\n+    P = 50,\n+    Q = 60,\n+    R = 70,\n+    S = 80,\n+    T = 90,\n+    U = 100,\n+}\n+\n+// CHECK-LABEL: @check_enum_from_char(\n+#[no_mangle]\n+pub unsafe fn check_enum_from_char(x: char) -> Minus100ToPlus100 {\n+    // OPT: %0 = icmp ule i32 %x, 1114111\n+    // OPT: call void @llvm.assume(i1 %0)\n+    // OPT: %1 = icmp uge i32 %x, -100\n+    // OPT: %2 = icmp ule i32 %x, 100\n+    // OPT: %3 = or i1 %1, %2\n+    // OPT: call void @llvm.assume(i1 %3)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i32 %x\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_enum_to_char(\n+#[no_mangle]\n+pub unsafe fn check_enum_to_char(x: Minus100ToPlus100) -> char {\n+    // OPT: %0 = icmp uge i32 %x, -100\n+    // OPT: %1 = icmp ule i32 %x, 100\n+    // OPT: %2 = or i1 %0, %1\n+    // OPT: call void @llvm.assume(i1 %2)\n+    // OPT: %3 = icmp ule i32 %x, 1114111\n+    // OPT: call void @llvm.assume(i1 %3)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i32 %x\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_swap_pair(\n+#[no_mangle]\n+pub unsafe fn check_swap_pair(x: (char, NonZeroU32)) -> (NonZeroU32, char) {\n+    // OPT: %0 = icmp ule i32 %x.0, 1114111\n+    // OPT: call void @llvm.assume(i1 %0)\n+    // OPT: %1 = icmp uge i32 %x.0, 1\n+    // OPT: call void @llvm.assume(i1 %1)\n+    // OPT: %2 = icmp uge i32 %x.1, 1\n+    // OPT: call void @llvm.assume(i1 %2)\n+    // OPT: %3 = icmp ule i32 %x.1, 1114111\n+    // OPT: call void @llvm.assume(i1 %3)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: %[[P1:.+]] = insertvalue { i32, i32 } poison, i32 %x.0, 0\n+    // CHECK: %[[P2:.+]] = insertvalue { i32, i32 } %[[P1]], i32 %x.1, 1\n+    // CHECK: ret { i32, i32 } %[[P2]]\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_bool_from_ordering(\n+#[no_mangle]\n+pub unsafe fn check_bool_from_ordering(x: std::cmp::Ordering) -> bool {\n+    // OPT: %0 = icmp uge i8 %x, -1\n+    // OPT: %1 = icmp ule i8 %x, 1\n+    // OPT: %2 = or i1 %0, %1\n+    // OPT: call void @llvm.assume(i1 %2)\n+    // OPT: %3 = icmp ule i8 %x, 1\n+    // OPT: call void @llvm.assume(i1 %3)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: %[[R:.+]] = trunc i8 %x to i1\n+    // CHECK: ret i1 %[[R]]\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_bool_to_ordering(\n+#[no_mangle]\n+pub unsafe fn check_bool_to_ordering(x: bool) -> std::cmp::Ordering {\n+    // CHECK: %0 = zext i1 %x to i8\n+    // OPT: %1 = icmp ule i8 %0, 1\n+    // OPT: call void @llvm.assume(i1 %1)\n+    // OPT: %2 = icmp uge i8 %0, -1\n+    // OPT: %3 = icmp ule i8 %0, 1\n+    // OPT: %4 = or i1 %2, %3\n+    // OPT: call void @llvm.assume(i1 %4)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i8 %0\n+\n+    transmute(x)\n+}"}, {"sha": "51c000b82ea8ae89b4afa447ad70cfc4ed904ccc", "filename": "tests/codegen/intrinsics/transmute.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bcb0ec28cd169e1e80efffc824287287d374147/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bcb0ec28cd169e1e80efffc824287287d374147/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs?ref=1bcb0ec28cd169e1e80efffc824287287d374147", "patch": "@@ -169,17 +169,17 @@ pub unsafe fn check_aggregate_from_bool(x: bool) -> Aggregate8 {\n #[no_mangle]\n pub unsafe fn check_byte_to_bool(x: u8) -> bool {\n     // CHECK-NOT: alloca\n-    // CHECK: %0 = trunc i8 %x to i1\n-    // CHECK: ret i1 %0\n+    // CHECK: %[[R:.+]] = trunc i8 %x to i1\n+    // CHECK: ret i1 %[[R]]\n     transmute(x)\n }\n \n // CHECK-LABEL: @check_byte_from_bool(\n #[no_mangle]\n pub unsafe fn check_byte_from_bool(x: bool) -> u8 {\n     // CHECK-NOT: alloca\n-    // CHECK: %0 = zext i1 %x to i8\n-    // CHECK: ret i8 %0\n+    // CHECK: %[[R:.+]] = zext i1 %x to i8\n+    // CHECK: ret i8 %[[R:.+]]\n     transmute(x)\n }\n "}, {"sha": "a0894a505c7c6330c2a5dda3f953635fa6de9237", "filename": "tests/codegen/transmute-scalar.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1bcb0ec28cd169e1e80efffc824287287d374147/tests%2Fcodegen%2Ftransmute-scalar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bcb0ec28cd169e1e80efffc824287287d374147/tests%2Fcodegen%2Ftransmute-scalar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ftransmute-scalar.rs?ref=1bcb0ec28cd169e1e80efffc824287287d374147", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -O -C no-prepopulate-passes\n+// compile-flags: -C opt-level=0 -C no-prepopulate-passes\n // min-llvm-version: 15.0 # this test assumes `ptr`s and thus no `pointercast`s\n \n #![crate_type = \"lib\"]\n@@ -10,46 +10,46 @@\n // However, `bitcast`s and `ptrtoint`s and `inttoptr`s are still worth doing when\n // that allows us to avoid the `alloca`s entirely; see `rvalue_creates_operand`.\n \n-// CHECK-LABEL: define{{.*}}i32 @f32_to_bits(float noundef %x)\n+// CHECK-LABEL: define{{.*}}i32 @f32_to_bits(float %x)\n // CHECK: %0 = bitcast float %x to i32\n // CHECK-NEXT: ret i32 %0\n #[no_mangle]\n pub fn f32_to_bits(x: f32) -> u32 {\n     unsafe { std::mem::transmute(x) }\n }\n \n-// CHECK-LABEL: define{{.*}}i8 @bool_to_byte(i1 noundef zeroext %b)\n+// CHECK-LABEL: define{{.*}}i8 @bool_to_byte(i1 zeroext %b)\n // CHECK: %0 = zext i1 %b to i8\n // CHECK-NEXT: ret i8 %0\n #[no_mangle]\n pub fn bool_to_byte(b: bool) -> u8 {\n     unsafe { std::mem::transmute(b) }\n }\n \n-// CHECK-LABEL: define{{.*}}noundef zeroext i1 @byte_to_bool(i8 noundef %byte)\n+// CHECK-LABEL: define{{.*}}zeroext i1 @byte_to_bool(i8 %byte)\n // CHECK: %0 = trunc i8 %byte to i1\n // CHECK-NEXT: ret i1 %0\n #[no_mangle]\n pub unsafe fn byte_to_bool(byte: u8) -> bool {\n     std::mem::transmute(byte)\n }\n \n-// CHECK-LABEL: define{{.*}}ptr @ptr_to_ptr(ptr noundef %p)\n+// CHECK-LABEL: define{{.*}}ptr @ptr_to_ptr(ptr %p)\n // CHECK: ret ptr %p\n #[no_mangle]\n pub fn ptr_to_ptr(p: *mut u16) -> *mut u8 {\n     unsafe { std::mem::transmute(p) }\n }\n \n-// CHECK: define{{.*}}[[USIZE:i[0-9]+]] @ptr_to_int(ptr noundef %p)\n+// CHECK: define{{.*}}[[USIZE:i[0-9]+]] @ptr_to_int(ptr %p)\n // CHECK: %0 = ptrtoint ptr %p to [[USIZE]]\n // CHECK-NEXT: ret [[USIZE]] %0\n #[no_mangle]\n pub fn ptr_to_int(p: *mut u16) -> usize {\n     unsafe { std::mem::transmute(p) }\n }\n \n-// CHECK: define{{.*}}ptr @int_to_ptr([[USIZE]] noundef %i)\n+// CHECK: define{{.*}}ptr @int_to_ptr([[USIZE]] %i)\n // CHECK: %0 = inttoptr [[USIZE]] %i to ptr\n // CHECK-NEXT: ret ptr %0\n #[no_mangle]"}]}