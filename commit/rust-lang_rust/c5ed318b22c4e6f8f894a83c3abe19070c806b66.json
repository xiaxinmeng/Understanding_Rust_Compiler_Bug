{"sha": "c5ed318b22c4e6f8f894a83c3abe19070c806b66", "node_id": "C_kwDOAAsO6NoAKGM1ZWQzMThiMjJjNGU2ZjhmODk0YTgzYzNhYmUxOTA3MGM4MDZiNjY", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2022-06-15T09:55:05Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2022-06-15T15:47:04Z"}, "message": "implement (unused) matching solver", "tree": {"sha": "4c7ebc272dfcabbd897606975cdda79c4a815d32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c7ebc272dfcabbd897606975cdda79c4a815d32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5ed318b22c4e6f8f894a83c3abe19070c806b66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5ed318b22c4e6f8f894a83c3abe19070c806b66", "html_url": "https://github.com/rust-lang/rust/commit/c5ed318b22c4e6f8f894a83c3abe19070c806b66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5ed318b22c4e6f8f894a83c3abe19070c806b66/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d203c13db23fe0f0d39b448e6926beaad9b550a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d203c13db23fe0f0d39b448e6926beaad9b550a4", "html_url": "https://github.com/rust-lang/rust/commit/d203c13db23fe0f0d39b448e6926beaad9b550a4"}], "stats": {"total": 353, "additions": 329, "deletions": 24}, "files": [{"sha": "3a919e954a424d350e4ef59cbea47cb34ba61177", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=c5ed318b22c4e6f8f894a83c3abe19070c806b66", "patch": "@@ -299,7 +299,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n \n     // Solve the region constraints.\n     let (closure_region_requirements, nll_errors) =\n-        regioncx.solve(infcx, &body, polonius_output.clone());\n+        regioncx.solve(infcx, param_env, &body, polonius_output.clone());\n \n     if !nll_errors.is_empty() {\n         // Suppress unhelpful extra errors in `infer_opaque_types`."}, {"sha": "d553a60faef0d9a22876110232458249ae5951e7", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 80, "deletions": 21, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=c5ed318b22c4e6f8f894a83c3abe19070c806b66", "patch": "@@ -10,14 +10,16 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::CRATE_HIR_ID;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n-use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n+use rustc_infer::infer::outlives::test_type_match;\n+use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n     Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n     ConstraintCategory, Local, Location, ReturnConstraint,\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n+use rustc_middle::ty::Region;\n use rustc_middle::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n \n@@ -46,6 +48,7 @@ pub mod values;\n \n pub struct RegionInferenceContext<'tcx> {\n     pub var_infos: VarInfos,\n+\n     /// Contains the definition for every region variable. Region\n     /// variables are identified by their index (`RegionVid`). The\n     /// definition contains information about where the region came\n@@ -559,6 +562,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(super) fn solve(\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         polonius_output: Option<Rc<PoloniusOutput>>,\n     ) -> (Option<ClosureRegionRequirements<'tcx>>, RegionErrors<'tcx>) {\n@@ -574,7 +578,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // eagerly.\n         let mut outlives_requirements = infcx.tcx.is_typeck_child(mir_def_id).then(Vec::new);\n \n-        self.check_type_tests(infcx, body, outlives_requirements.as_mut(), &mut errors_buffer);\n+        self.check_type_tests(\n+            infcx,\n+            param_env,\n+            body,\n+            outlives_requirements.as_mut(),\n+            &mut errors_buffer,\n+        );\n \n         // In Polonius mode, the errors about missing universal region relations are in the output\n         // and need to be emitted or propagated. Otherwise, we need to check whether the\n@@ -823,6 +833,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_type_tests(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n@@ -839,7 +850,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             let generic_ty = type_test.generic_kind.to_ty(tcx);\n             if self.eval_verify_bound(\n-                tcx,\n+                infcx,\n+                param_env,\n                 body,\n                 generic_ty,\n                 type_test.lower_bound,\n@@ -851,6 +863,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let Some(propagated_outlives_requirements) = &mut propagated_outlives_requirements {\n                 if self.try_promote_type_test(\n                     infcx,\n+                    param_env,\n                     body,\n                     type_test,\n                     propagated_outlives_requirements,\n@@ -907,6 +920,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn try_promote_type_test(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         type_test: &TypeTest<'tcx>,\n         propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'tcx>>,\n@@ -938,7 +952,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // where `ur` is a local bound -- we are sometimes in a\n             // position to prove things that our caller cannot.  See\n             // #53570 for an example.\n-            if self.eval_verify_bound(tcx, body, generic_ty, ur, &type_test.verify_bound) {\n+            if self.eval_verify_bound(\n+                infcx,\n+                param_env,\n+                body,\n+                generic_ty,\n+                ur,\n+                &type_test.verify_bound,\n+            ) {\n                 continue;\n             }\n \n@@ -1161,7 +1182,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `point`.\n     fn eval_verify_bound(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n@@ -1170,14 +1192,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"eval_verify_bound(lower_bound={:?}, verify_bound={:?})\", lower_bound, verify_bound);\n \n         match verify_bound {\n-            VerifyBound::IfEq(test_ty, verify_bound1) => self.eval_if_eq(\n-                tcx,\n-                body,\n-                generic_ty,\n-                lower_bound,\n-                *test_ty,\n-                &VerifyBound::OutlivedBy(*verify_bound1),\n-            ),\n+            VerifyBound::IfEq(test_ty, verify_bound1) => {\n+                self.eval_if_eq(infcx, generic_ty, lower_bound, *test_ty, *verify_bound1)\n+            }\n+\n+            VerifyBound::IfEqBound(verify_if_eq_b) => {\n+                self.eval_if_eq_bound(infcx, param_env, generic_ty, lower_bound, *verify_if_eq_b)\n+            }\n \n             VerifyBound::IsEmpty => {\n                 let lower_bound_scc = self.constraint_sccs.scc(lower_bound);\n@@ -1190,33 +1211,71 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             VerifyBound::AnyBound(verify_bounds) => verify_bounds.iter().any(|verify_bound| {\n-                self.eval_verify_bound(tcx, body, generic_ty, lower_bound, verify_bound)\n+                self.eval_verify_bound(\n+                    infcx,\n+                    param_env,\n+                    body,\n+                    generic_ty,\n+                    lower_bound,\n+                    verify_bound,\n+                )\n             }),\n \n             VerifyBound::AllBounds(verify_bounds) => verify_bounds.iter().all(|verify_bound| {\n-                self.eval_verify_bound(tcx, body, generic_ty, lower_bound, verify_bound)\n+                self.eval_verify_bound(\n+                    infcx,\n+                    param_env,\n+                    body,\n+                    generic_ty,\n+                    lower_bound,\n+                    verify_bound,\n+                )\n             }),\n         }\n     }\n \n     fn eval_if_eq(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n-        body: &Body<'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n         test_ty: Ty<'tcx>,\n-        verify_bound: &VerifyBound<'tcx>,\n+        verify_bound: Region<'tcx>,\n     ) -> bool {\n-        let generic_ty_normalized = self.normalize_to_scc_representatives(tcx, generic_ty);\n-        let test_ty_normalized = self.normalize_to_scc_representatives(tcx, test_ty);\n+        let generic_ty_normalized = self.normalize_to_scc_representatives(infcx.tcx, generic_ty);\n+        let test_ty_normalized = self.normalize_to_scc_representatives(infcx.tcx, test_ty);\n         if generic_ty_normalized == test_ty_normalized {\n-            self.eval_verify_bound(tcx, body, generic_ty, lower_bound, verify_bound)\n+            let verify_bound_vid = self.to_region_vid(verify_bound);\n+            self.eval_outlives(verify_bound_vid, lower_bound)\n         } else {\n             false\n         }\n     }\n \n+    fn eval_if_eq_bound(\n+        &self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        generic_ty: Ty<'tcx>,\n+        lower_bound: RegionVid,\n+        verify_if_eq_b: ty::Binder<'tcx, VerifyIfEq<'tcx>>,\n+    ) -> bool {\n+        let generic_ty = self.normalize_to_scc_representatives(infcx.tcx, generic_ty);\n+        let verify_if_eq_b = self.normalize_to_scc_representatives(infcx.tcx, verify_if_eq_b);\n+        match test_type_match::extract_verify_if_eq_bound(\n+            infcx.tcx,\n+            param_env,\n+            &verify_if_eq_b,\n+            generic_ty,\n+        ) {\n+            Some(r) => {\n+                let r_vid = self.to_region_vid(r);\n+                self.eval_outlives(r_vid, lower_bound)\n+            }\n+            None => false,\n+        }\n+    }\n+\n     /// This is a conservative normalization procedure. It takes every\n     /// free region in `value` and replaces it with the\n     /// \"representative\" of its SCC (see `scc_representatives` field)."}, {"sha": "1cc5f3d53c9df5a488c8d687ad5f348eebdbf6ec", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=c5ed318b22c4e6f8f894a83c3abe19070c806b66", "patch": "@@ -22,19 +22,22 @@ use rustc_middle::ty::{Region, RegionVid};\n use rustc_span::Span;\n use std::fmt;\n \n+use super::outlives::test_type_match;\n+\n /// This function performs lexical region resolution given a complete\n /// set of constraints and variable origins. It performs a fixed-point\n /// iteration to find region values which satisfy all constraints,\n /// assuming such values can be found. It returns the final values of\n /// all the variables as well as a set of errors that must be reported.\n #[instrument(level = \"debug\", skip(region_rels, var_infos, data))]\n pub(crate) fn resolve<'tcx>(\n+    param_env: ty::ParamEnv<'tcx>,\n     region_rels: &RegionRelations<'_, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n ) -> (LexicalRegionResolutions<'tcx>, Vec<RegionResolutionError<'tcx>>) {\n     let mut errors = vec![];\n-    let mut resolver = LexicalResolver { region_rels, var_infos, data };\n+    let mut resolver = LexicalResolver { param_env, region_rels, var_infos, data };\n     let values = resolver.infer_variable_values(&mut errors);\n     (values, errors)\n }\n@@ -100,6 +103,7 @@ struct RegionAndOrigin<'tcx> {\n type RegionGraph<'tcx> = Graph<(), Constraint<'tcx>>;\n \n struct LexicalResolver<'cx, 'tcx> {\n+    param_env: ty::ParamEnv<'tcx>,\n     region_rels: &'cx RegionRelations<'cx, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n@@ -823,6 +827,21 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     && self.bound_is_met(&VerifyBound::OutlivedBy(*r), var_values, generic_ty, min)\n             }\n \n+            VerifyBound::IfEqBound(verify_if_eq_b) => {\n+                match test_type_match::extract_verify_if_eq_bound(\n+                    self.tcx(),\n+                    self.param_env,\n+                    verify_if_eq_b,\n+                    generic_ty,\n+                ) {\n+                    Some(r) => {\n+                        self.bound_is_met(&VerifyBound::OutlivedBy(r), var_values, generic_ty, min)\n+                    }\n+\n+                    None => false,\n+                }\n+            }\n+\n             VerifyBound::OutlivedBy(r) => {\n                 self.sub_concrete_regions(min, var_values.normalize(self.tcx(), *r))\n             }"}, {"sha": "6f88b83a473213d86857bcb6dac01c57653a88e3", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=c5ed318b22c4e6f8f894a83c3abe19070c806b66", "patch": "@@ -1290,7 +1290,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             &RegionRelations::new(self.tcx, region_context, outlives_env.free_region_map());\n \n         let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(region_rels, var_infos, data);\n+            lexical_region_resolve::resolve(outlives_env.param_env, region_rels, var_infos, data);\n \n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());"}, {"sha": "2a085288fb7c069c8d58d8a776b9e758d0b4078c", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=c5ed318b22c4e6f8f894a83c3abe19070c806b66", "patch": "@@ -3,6 +3,7 @@\n pub mod components;\n pub mod env;\n pub mod obligations;\n+pub mod test_type_match;\n pub mod verify;\n \n use rustc_middle::traits::query::OutlivesBound;"}, {"sha": "99d6aabf0d6a0ded0d78c2bdd963026014e92c2b", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=c5ed318b22c4e6f8f894a83c3abe19070c806b66", "patch": "@@ -0,0 +1,179 @@\n+use std::collections::hash_map::Entry;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_middle::ty::{\n+    self,\n+    error::TypeError,\n+    relate::{self, Relate, RelateResult, TypeRelation},\n+    Ty, TyCtxt,\n+};\n+\n+use crate::infer::region_constraints::VerifyIfEq;\n+\n+/// Given a \"verify-if-eq\" type test like:\n+///\n+///     exists<'a...> {\n+///         verify_if_eq(some_type, bound_region)\n+///     }\n+///\n+/// and the type `test_ty` that the type test is being tested against,\n+/// returns:\n+///\n+/// * `None` if `some_type` cannot be made equal to `test_ty`,\n+///   no matter the values of the variables in `exists`.\n+/// * `Some(r)` with a suitable bound (typically the value of `bound_region`, modulo\n+///   any bound existential variables, which will be substituted) for the\n+///   type under test.\n+///\n+/// NB: This function uses a simplistic, syntactic version of type equality.\n+/// In other words, it may spuriously return `None` even if the type-under-test\n+/// is in fact equal to `some_type`. In practice, though, this is used on types\n+/// that are either projections like `T::Item` or `T` and it works fine, but it\n+/// could have trouble when complex types with higher-ranked binders and the\n+/// like are used. This is a particular challenge since this function is invoked\n+/// very late in inference and hence cannot make use of the normal inference\n+/// machinery.\n+pub fn extract_verify_if_eq_bound<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    verify_if_eq_b: &ty::Binder<'tcx, VerifyIfEq<'tcx>>,\n+    test_ty: Ty<'tcx>,\n+) -> Option<ty::Region<'tcx>> {\n+    assert!(!verify_if_eq_b.has_escaping_bound_vars());\n+    let mut m = Match::new(tcx, param_env);\n+    let verify_if_eq = verify_if_eq_b.skip_binder();\n+    m.relate(verify_if_eq.ty, test_ty).ok()?;\n+\n+    if let ty::RegionKind::ReLateBound(depth, br) = verify_if_eq.bound.kind() {\n+        assert!(depth == ty::INNERMOST);\n+        match m.map.get(&br) {\n+            Some(&r) => Some(r),\n+            None => {\n+                // If there is no mapping, then this region is unconstrained.\n+                // In that case, we escalate to `'static`.\n+                Some(tcx.lifetimes.re_static)\n+            }\n+        }\n+    } else {\n+        // The region does not contain any inference variables.\n+        Some(verify_if_eq.bound)\n+    }\n+}\n+\n+struct Match<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    pattern_depth: ty::DebruijnIndex,\n+    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n+}\n+\n+impl<'tcx> Match<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Match<'tcx> {\n+        Match { tcx, param_env, pattern_depth: ty::INNERMOST, map: FxHashMap::default() }\n+    }\n+}\n+\n+impl<'tcx> Match<'tcx> {\n+    /// Creates the \"Error\" variant that signals \"no match\".\n+    fn no_match<T>(&self) -> RelateResult<'tcx, T> {\n+        Err(TypeError::Mismatch)\n+    }\n+\n+    /// Binds the pattern variable `br` to `value`; returns an `Err` if the pattern\n+    /// is already bound to a different value.\n+    fn bind(\n+        &mut self,\n+        br: ty::BoundRegion,\n+        value: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        match self.map.entry(br) {\n+            Entry::Occupied(entry) => {\n+                if *entry.get() == value {\n+                    Ok(value)\n+                } else {\n+                    self.no_match()\n+                }\n+            }\n+            Entry::Vacant(entry) => {\n+                entry.insert(value);\n+                Ok(value)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n+    fn tag(&self) -> &'static str {\n+        \"Match\"\n+    }\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    } // irrelevant\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _: ty::Variance,\n+        _: ty::VarianceDiagInfo<'tcx>,\n+        a: T,\n+        b: T,\n+    ) -> RelateResult<'tcx, T> {\n+        self.relate(a, b)\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn regions(\n+        &mut self,\n+        pattern: ty::Region<'tcx>,\n+        value: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        if let ty::RegionKind::ReLateBound(depth, br) = pattern.kind() && depth == self.pattern_depth {\n+            self.bind(br, pattern)\n+        } else if pattern == value {\n+            Ok(pattern)\n+        } else {\n+            self.no_match()\n+        }\n+    }\n+\n+    fn tys(&mut self, pattern: Ty<'tcx>, value: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        if pattern == value {\n+            return Ok(pattern);\n+        } else {\n+            relate::super_relate_tys(self, pattern, value)\n+        }\n+    }\n+\n+    fn consts(\n+        &mut self,\n+        pattern: ty::Const<'tcx>,\n+        value: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n+        debug!(\"{}.consts({:?}, {:?})\", self.tag(), pattern, value);\n+        if pattern == value {\n+            return Ok(pattern);\n+        } else {\n+            relate::super_relate_consts(self, pattern, value)\n+        }\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        pattern: ty::Binder<'tcx, T>,\n+        value: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        self.pattern_depth.shift_in(1);\n+        let result = Ok(pattern.rebind(self.relate(pattern.skip_binder(), value.skip_binder())?));\n+        self.pattern_depth.shift_out(1);\n+        result\n+    }\n+}"}, {"sha": "e0ccbb2c0f919148202d32f4bea01bfaffa7a4b0", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ed318b22c4e6f8f894a83c3abe19070c806b66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=c5ed318b22c4e6f8f894a83c3abe19070c806b66", "patch": "@@ -226,6 +226,8 @@ pub enum VerifyBound<'tcx> {\n     /// (after inference), and `'a: min`, then `G: min`.\n     IfEq(Ty<'tcx>, Region<'tcx>),\n \n+    IfEqBound(ty::Binder<'tcx, VerifyIfEq<'tcx>>),\n+\n     /// Given a region `R`, expands to the function:\n     ///\n     /// ```ignore (pseudo-rust)\n@@ -267,6 +269,49 @@ pub enum VerifyBound<'tcx> {\n     AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n+/// Given a kind K and a bound B, expands to a function like the\n+/// following, where `G` is the generic for which this verify\n+/// bound was created:\n+///\n+/// ```ignore (pseudo-rust)\n+/// fn(min) -> bool {\n+///     if G == K {\n+///         B(min)\n+///     } else {\n+///         false\n+///     }\n+/// }\n+/// ```\n+///\n+/// In other words, if the generic `G` that we are checking is\n+/// equal to `K`, then check the associated verify bound\n+/// (otherwise, false).\n+///\n+/// This is used when we have something in the environment that\n+/// may or may not be relevant, depending on the region inference\n+/// results. For example, we may have `where <T as\n+/// Trait<'a>>::Item: 'b` in our where-clauses. If we are\n+/// generating the verify-bound for `<T as Trait<'0>>::Item`, then\n+/// this where-clause is only relevant if `'0` winds up inferred\n+/// to `'a`.\n+///\n+/// So we would compile to a verify-bound like\n+///\n+/// ```ignore (illustrative)\n+/// IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n+/// ```\n+///\n+/// meaning, if the subject G is equal to `<T as Trait<'a>>::Item`\n+/// (after inference), and `'a: min`, then `G: min`.\n+#[derive(Debug, Copy, Clone, TypeFoldable)]\n+pub struct VerifyIfEq<'tcx> {\n+    /// Type which must match the generic `G`\n+    pub ty: Ty<'tcx>,\n+\n+    /// Bound that applies if `ty` is equal.\n+    pub bound: Region<'tcx>,\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub(crate) struct TwoRegions<'tcx> {\n     a: Region<'tcx>,\n@@ -761,6 +806,7 @@ impl<'tcx> VerifyBound<'tcx> {\n     pub fn must_hold(&self) -> bool {\n         match self {\n             VerifyBound::IfEq(..) => false,\n+            VerifyBound::IfEqBound(..) => false,\n             VerifyBound::OutlivedBy(re) => re.is_static(),\n             VerifyBound::IsEmpty => false,\n             VerifyBound::AnyBound(bs) => bs.iter().any(|b| b.must_hold()),\n@@ -771,6 +817,7 @@ impl<'tcx> VerifyBound<'tcx> {\n     pub fn cannot_hold(&self) -> bool {\n         match self {\n             VerifyBound::IfEq(_, _) => false,\n+            VerifyBound::IfEqBound(..) => false,\n             VerifyBound::IsEmpty => false,\n             VerifyBound::OutlivedBy(_) => false,\n             VerifyBound::AnyBound(bs) => bs.iter().all(|b| b.cannot_hold()),"}]}