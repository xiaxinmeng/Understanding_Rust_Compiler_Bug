{"sha": "7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZjgyNWJiNjA3YzRlOTM0YzkyYmQwYjczZWNiYzRjMjRmMzI4NmI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-08T02:42:22Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-08T02:42:27Z"}, "message": "Revert \"remove alias analysis and replace with borrowck\"\n\n18s perf regression compiling rustc with opts\n\nThis reverts commit 7f6ee0ce0df8af4c21b065cb49b95079ae643f77.", "tree": {"sha": "c5800f031f1959f2d91c61b890547a3b37f3a0af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5800f031f1959f2d91c61b890547a3b37f3a0af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "html_url": "https://github.com/rust-lang/rust/commit/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c058f1d9927874fd5bfe40d5e6698880a07c36bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c058f1d9927874fd5bfe40d5e6698880a07c36bb", "html_url": "https://github.com/rust-lang/rust/commit/c058f1d9927874fd5bfe40d5e6698880a07c36bb"}], "stats": {"total": 1165, "additions": 1134, "deletions": 31}, "files": [{"sha": "c7b94c8e1550e591c2c750555c2a812c8f0af959", "filename": "doc/tutorial.md", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1382,7 +1382,83 @@ gets access to them.\n \n ## Safe references\n \n-*This system has recently changed.  An explanantion is forthcoming.*\n+There is one catch with this approach: sometimes the compiler can\n+*not* statically guarantee that the argument value at the caller side\n+will survive to the end of the call. Another argument might indirectly\n+refer to it and be used to overwrite it, or a closure might assign a\n+new value to it.\n+\n+Fortunately, Rust tasks are single-threaded worlds, which share no\n+data with other tasks, and most data is immutable. This allows most\n+argument-passing situations to be proved safe without further\n+difficulty.\n+\n+Take the following program:\n+\n+~~~~\n+# fn get_really_big_record() -> int { 1 }\n+# fn myfunc(a: int) {}\n+fn main() {\n+    let x = get_really_big_record();\n+    myfunc(x);\n+}\n+~~~~\n+\n+Here we know for sure that no one else has access to the `x` variable\n+in `main`, so we're good. But the call could also look like this:\n+\n+~~~~\n+# fn myfunc(a: int, b: fn()) {}\n+# fn get_another_record() -> int { 1 }\n+# let mut x = 1;\n+myfunc(x, {|| x = get_another_record(); });\n+~~~~\n+\n+Now, if `myfunc` first calls its second argument and then accesses its\n+first argument, it will see a different value from the one that was\n+passed to it.\n+\n+In such a case, the compiler will insert an implicit copy of `x`,\n+*except* if `x` contains something mutable, in which case a copy would\n+result in code that behaves differently. If copying `x` might be\n+expensive (for example, if it holds a vector), the compiler will emit\n+a warning.\n+\n+There are even more tricky cases, in which the Rust compiler is forced\n+to pessimistically assume a value will get mutated, even though it is\n+not sure.\n+\n+~~~~\n+fn for_each(v: [mut @int], iter: fn(@int)) {\n+   for v.each {|elt| iter(elt); }\n+}\n+~~~~\n+\n+For all this function knows, calling `iter` (which is a closure that\n+might have access to the vector that's passed as `v`) could cause the\n+elements in the vector to be mutated, with the effect that it can not\n+guarantee that the boxes will live for the duration of the call. So it\n+has to copy them. In this case, this will happen implicitly (bumping a\n+reference count is considered cheap enough to not warn about it).\n+\n+## The copy operator\n+\n+If the `for_each` function given above were to take a vector of\n+`{mut a: int}` instead of `@int`, it would not be able to\n+implicitly copy, since if the `iter` function changes a copy of a\n+mutable record, the changes won't be visible in the record itself. If\n+we *do* want to allow copies there, we have to explicitly allow it\n+with the `copy` operator:\n+\n+~~~~\n+type mutrec = {mut x: int};\n+fn for_each(v: [mut mutrec], iter: fn(mutrec)) {\n+   for v.each {|elt| iter(copy elt); }\n+}\n+~~~~\n+\n+Adding a `copy` operator is also the way to muffle warnings about\n+implicit copies.\n \n ## Other uses of safe references\n "}, {"sha": "672a950f42b1fe6a6c73d1b6161475e67cca24bb", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -204,6 +204,9 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let (root_map, mutbl_map) = time(\n         time_passes, \"borrow checking\",\n         bind middle::borrowck::check_crate(ty_cx, method_map, crate));\n+    let (copy_map, _ref_map) =\n+        time(time_passes, \"alias checking\",\n+             bind middle::alias::check_crate(ty_cx, crate));\n     time(time_passes, \"kind checking\",\n          bind kind::check_crate(ty_cx, method_map, last_use_map, crate));\n     time(time_passes, \"lint checking\",\n@@ -213,7 +216,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let outputs = option::get(outputs);\n \n     let maps = {mutbl_map: mutbl_map, root_map: root_map,\n-                last_use_map: last_use_map,\n+                copy_map: copy_map, last_use_map: last_use_map,\n                 impl_map: impl_map, method_map: method_map,\n                 vtable_map: vtable_map};\n \n@@ -445,6 +448,14 @@ fn build_session_options(match: getopts::match,\n     let sysroot_opt = getopts::opt_maybe_str(match, \"sysroot\");\n     let target_opt = getopts::opt_maybe_str(match, \"target\");\n     let save_temps = getopts::opt_present(match, \"save-temps\");\n+    let borrowck = alt getopts::opt_maybe_str(match, \"borrowck\") {\n+      none { 0u }\n+      some(\"warn\") { 1u }\n+      some(\"err\") { 2u }\n+      some(_) {\n+        early_error(demitter, \"borrowck may be warn or err\")\n+      }\n+    };\n     alt output_type {\n       // unless we're emitting huamn-readable assembly, omit comments.\n       link::output_type_llvm_assembly | link::output_type_assembly {}\n@@ -493,7 +504,8 @@ fn build_session_options(match: getopts::match,\n           test: test,\n           parse_only: parse_only,\n           no_trans: no_trans,\n-          debugging_opts: debugging_opts};\n+          debugging_opts: debugging_opts,\n+          borrowck: borrowck};\n     ret sopts;\n }\n \n@@ -570,7 +582,8 @@ fn opts() -> [getopts::opt] {\n          optmulti(\"Z\"),\n \n          optmulti(\"cfg\"), optflag(\"test\"),\n-         optflag(\"lib\"), optflag(\"bin\"), optflag(\"static\"), optflag(\"gc\")];\n+         optflag(\"lib\"), optflag(\"bin\"), optflag(\"static\"), optflag(\"gc\"),\n+         optopt(\"borrowck\")];\n }\n \n type output_filenames = @{out_filename: str, obj_filename:str};"}, {"sha": "97e2d0ec4db730d7b589363da1dcf38d68f5eb57", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -66,6 +66,9 @@ type options =\n      no_trans: bool,\n \n      debugging_opts: uint,\n+\n+     // temporary hack: 0=off,1=warn,2=err --> if 2, alias is disabled\n+     borrowck: uint,\n     };\n \n type crate_metadata = {name: str, data: [u8]};\n@@ -178,7 +181,8 @@ fn basic_options() -> @options {\n         test: false,\n         parse_only: false,\n         no_trans: false,\n-        debugging_opts: 0u\n+        debugging_opts: 0u,\n+        borrowck: 0u,\n     }\n }\n "}, {"sha": "a754d4c11a2685feb79a32337fc5b854d96e8351", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -116,6 +116,7 @@ enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_param_bounds,\n     tag_table_inferred_modes,\n     tag_table_mutbl,\n+    tag_table_copy,\n     tag_table_last_use,\n     tag_table_spill,\n     tag_table_method_map,"}, {"sha": "1fb17d4f3855e3c393f4e622ce2ed642fd5bfe11", "filename": "src/rustc/middle/alias.rs", "status": "added", "additions": 847, "deletions": 0, "changes": 847, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -0,0 +1,847 @@\n+import syntax::{ast, ast_util, ast_map};\n+import ast_util::path_to_ident;\n+import ast::{ident, fn_ident, node_id};\n+import syntax::codemap::span;\n+import syntax::visit;\n+import visit::vt;\n+import std::list;\n+import std::map::hashmap;\n+import core::unreachable;\n+import option::is_none;\n+import list::list;\n+import driver::session::session;\n+import pat_util::*;\n+import util::ppaux::ty_to_str;\n+\n+// This is not an alias-analyser (though it would merit from becoming one, or\n+// getting input from one, to be more precise). It is a pass that checks\n+// whether aliases are used in a safe way.\n+\n+enum copied { not_allowed, copied, not_copied, }\n+enum invalid_reason { overwritten, val_taken, }\n+type invalid = {reason: invalid_reason,\n+                node_id: node_id,\n+                sp: span, path: @ast::path};\n+\n+enum unsafe_ty { contains(ty::t), mutbl_contains(ty::t), }\n+\n+type binding = @{node_id: node_id,\n+                 span: span,\n+                 root_var: option<node_id>,\n+                 local_id: uint,\n+                 unsafe_tys: [unsafe_ty],\n+                 mut copied: copied};\n+\n+// FIXME it may be worthwhile to use a linked list of bindings instead\n+type scope = {bs: [binding],\n+              invalid: @mut @list<@invalid>};\n+\n+fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option<node_id>,\n+              unsafe_tys: [unsafe_ty]) -> binding {\n+    alt root_var {\n+      some(r_id) { cx.ref_map.insert(id, r_id); }\n+      _ {}\n+    }\n+    ret @{node_id: id, span: span, root_var: root_var,\n+          local_id: local_id_of_node(cx, id),\n+          unsafe_tys: unsafe_tys,\n+          mut copied: not_copied};\n+}\n+\n+enum local_info { local(uint), }\n+\n+type copy_map = std::map::hashmap<node_id, ()>;\n+type ref_map = std::map::hashmap<node_id, node_id>;\n+\n+type ctx = {tcx: ty::ctxt,\n+            copy_map: copy_map,\n+            ref_map: ref_map,\n+            mut silent: bool};\n+\n+fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> (copy_map, ref_map) {\n+    // Stores information about function arguments that's otherwise not easily\n+    // available.\n+    let cx = @{tcx: tcx,\n+               copy_map: std::map::int_hash(),\n+               ref_map: std::map::int_hash(),\n+               mut silent: false};\n+    let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n+              visit_expr: bind visit_expr(cx, _, _, _),\n+              visit_block: bind visit_block(cx, _, _, _)\n+              with *visit::default_visitor::<scope>()};\n+    let sc = {bs: [], invalid: @mut @list::nil};\n+    visit::visit_crate(*crate, sc, visit::mk_vt(v));\n+    tcx.sess.abort_if_errors();\n+    ret (cx.copy_map, cx.ref_map);\n+}\n+\n+fn visit_fn(cx: @ctx, _fk: visit::fn_kind, decl: ast::fn_decl,\n+            body: ast::blk, _sp: span,\n+            id: ast::node_id, sc: scope, v: vt<scope>) {\n+    visit::visit_fn_decl(decl, sc, v);\n+    let fty = ty::node_id_to_type(cx.tcx, id);\n+\n+    // Blocks need to obey any restrictions from the enclosing scope, and may\n+    // be called multiple times.\n+    let proto = ty::ty_fn_proto(fty);\n+    alt proto {\n+      ast::proto_block | ast::proto_any {\n+        check_loop(*cx, sc) {|| v.visit_block(body, sc, v);}\n+      }\n+      ast::proto_box | ast::proto_uniq | ast::proto_bare {\n+        let sc = {bs: [], invalid: @mut @list::nil};\n+        v.visit_block(body, sc, v);\n+      }\n+    }\n+}\n+\n+fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n+    let mut handled = true;\n+    alt ex.node {\n+      ast::expr_call(f, args, _) {\n+        check_call(cx, sc, f, args, v);\n+        visit_expr(cx, f, sc, v);\n+      }\n+      ast::expr_alt(input, arms, _) { check_alt(*cx, input, arms, sc, v); }\n+      ast::expr_path(pt) {\n+        check_var(*cx, ex, pt, ex.id, false, sc);\n+        handled = false;\n+      }\n+      ast::expr_swap(lhs, rhs) {\n+        check_lval(cx, lhs, sc, v);\n+        check_lval(cx, rhs, sc, v);\n+        handled = false;\n+      }\n+      ast::expr_move(dest, src) {\n+        visit_expr(cx, src, sc, v);\n+        check_lval(cx, dest, sc, v);\n+        check_lval(cx, src, sc, v);\n+      }\n+      ast::expr_assign(dest, src) | ast::expr_assign_op(_, dest, src) {\n+        visit_expr(cx, src, sc, v);\n+        check_lval(cx, dest, sc, v);\n+      }\n+      ast::expr_if(c, then, els) { check_if(c, then, els, sc, v); }\n+      ast::expr_while(_, _) {\n+        check_loop(*cx, sc) {|| visit::visit_expr(ex, sc, v); }\n+      }\n+      _ { handled = false; }\n+    }\n+    if !handled { visit::visit_expr(ex, sc, v); }\n+}\n+\n+fn visit_block(cx: @ctx, b: ast::blk, sc: scope, v: vt<scope>) {\n+    let sc = sc;\n+    for b.node.stmts.each {|stmt|\n+        alt stmt.node {\n+          ast::stmt_decl(@{node: ast::decl_item(it), _}, _) {\n+            v.visit_item(it, sc, v);\n+          }\n+          ast::stmt_decl(@{node: ast::decl_local(locs), _}, _) {\n+            for locs.each {|loc|\n+                alt loc.node.init {\n+                  some(init) {\n+                    if init.op == ast::init_move {\n+                        check_lval(cx, init.expr, sc, v);\n+                    } else {\n+                        visit_expr(cx, init.expr, sc, v);\n+                    }\n+                  }\n+                  none { }\n+                }\n+            }\n+          }\n+          ast::stmt_expr(ex, _) | ast::stmt_semi(ex, _) {\n+            v.visit_expr(ex, sc, v);\n+          }\n+        }\n+    }\n+    visit::visit_expr_opt(b.node.expr, sc, v);\n+}\n+\n+fn cant_copy(cx: ctx, b: binding) -> bool {\n+\n+    if cx.tcx.sess.opts.borrowck == 2u {\n+        // borrowck is enabled. disable alias analysis.\n+        ret false;\n+    }\n+\n+    alt b.copied {\n+      not_allowed { ret true; }\n+      copied { ret false; }\n+      not_copied {}\n+    }\n+    let ty = ty::node_id_to_type(cx.tcx, b.node_id);\n+    if ty::type_allows_implicit_copy(cx.tcx, ty) {\n+        b.copied = copied;\n+        cx.copy_map.insert(b.node_id, ());\n+        if copy_is_expensive(cx.tcx, ty) {\n+            cx.tcx.sess.span_warn(b.span,\n+                                  \"inserting an implicit copy for type \" +\n+                                  util::ppaux::ty_to_str(cx.tcx, ty));\n+        }\n+        ret false;\n+    } else { ret true; }\n+}\n+\n+// FIXME this is a really awful hack\n+fn local_id_for_args(cx: ctx, args: [@ast::expr]) -> uint {\n+    for vec::each(args) {|arg|\n+        alt arg.node {\n+          ast::expr_fn_block(decl, _, _) | ast::expr_fn(_, decl, _, _) |\n+          ast::expr_loop_body(@{node: ast::expr_fn_block(decl, _, _), _}) {\n+            if decl.inputs.len() > 0u {\n+                ret local_id_of_node(cx, decl.inputs[0].id);\n+            }\n+          }\n+          _ {}\n+        }\n+    }\n+    0xFFFFFFFFu\n+}\n+\n+fn check_call(cx: @ctx, sc: scope, f: @ast::expr, args: [@ast::expr],\n+              v: vt<scope>) {\n+    let fty = ty::expr_ty(cx.tcx, f);\n+    let arg_ts = ty::ty_fn_args(fty);\n+    let mut mut_roots: [{arg: @ast::expr, node: node_id}] = [];\n+    let mut bindings = [];\n+    let mut blocks = [], loc_id = local_id_for_args(*cx, args);\n+    vec::iter2(args, arg_ts) {|arg, arg_t|\n+        let root = expr_root(*cx, arg, false);\n+        alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n+          ast::by_mutbl_ref {\n+            alt path_def(*cx, arg) {\n+              some(def) {\n+                let dnum = ast_util::def_id_of_def(def).node;\n+                mut_roots += [{arg: arg, node: dnum}];\n+              }\n+              _ { }\n+            }\n+          }\n+          ast::by_ref | ast::by_val | ast::by_move | ast::by_copy {}\n+        }\n+        alt arg.node {\n+          ast::expr_fn_block(*) { blocks += [arg]; }\n+          ast::expr_loop_body(b) { blocks += [b]; }\n+          _ {\n+            let root_var = path_def_id(*cx, root.ex);\n+            let arg_copied = alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n+              ast::by_move | ast::by_copy { copied }\n+              ast::by_mutbl_ref { not_allowed }\n+              ast::by_ref | ast::by_val { not_copied }\n+            };\n+            visit_expr(cx, arg, sc, v);\n+            bindings += [@{node_id: arg.id,\n+                           span: arg.span,\n+                           root_var: root_var,\n+                           local_id: loc_id,\n+                           unsafe_tys: unsafe_set(root.mutbl),\n+                           mut copied: arg_copied}];\n+          }\n+        }\n+    }\n+    let f_may_close = alt f.node {\n+      ast::expr_path(_) { def_is_local_or_self(cx.tcx.def_map.get(f.id)) }\n+      _ { true }\n+    };\n+    if f_may_close {\n+        let mut i = 0u;\n+        for bindings.each {|b|\n+            let mut unsfe = vec::len(b.unsafe_tys) > 0u;\n+            alt b.root_var {\n+              some(rid) {\n+                for sc.bs.each {|o|\n+                    if o.node_id == rid && vec::len(o.unsafe_tys) > 0u {\n+                        unsfe = true; break;\n+                    }\n+                }\n+              }\n+              _ {}\n+            }\n+            if unsfe && cant_copy(*cx, b) {\n+                err(*cx, f.span, #fmt[\"function may alias with argument \\\n+                                      %u, which is not immutably rooted\", i]);\n+            }\n+            i += 1u;\n+        }\n+    }\n+    let mut j = 0u;\n+    for bindings.each {|b|\n+        for b.unsafe_tys.each {|unsafe_ty|\n+            vec::iteri(arg_ts) {|i, arg_t|\n+                let mut_alias =\n+                    (ast::by_mutbl_ref == ty::arg_mode(cx.tcx, arg_t));\n+                alt args[i].node {\n+                  ast::expr_fn_block(*) | ast::expr_loop_body(_) {}\n+                  _ {\n+                    if i != j && ty_can_unsafely_include(\n+                        *cx, unsafe_ty, arg_t.ty, mut_alias) &&\n+                       cant_copy(*cx, b) {\n+                        err(*cx, args[i].span,\n+                            #fmt[\"argument %u may alias with argument %u, \\\n+                                  which is not immutably rooted\", i, j]);\n+                    }\n+                  }\n+                }\n+            }\n+        }\n+        j += 1u;\n+    }\n+\n+    // Ensure we're not passing a root by mut alias.\n+    for mut_roots.each {|mroot|\n+        for bindings.each {|b|\n+            if b.node_id != mroot.arg.id {\n+                alt b.root_var {\n+                  some(root) {\n+                    if mroot.node == root && cant_copy(*cx, b) {\n+                        err(*cx, mroot.arg.span,\n+                            \"passing a mut reference to a \\\n+                             variable that roots another reference\");\n+                        break;\n+                    }\n+                  }\n+                  none { }\n+                }\n+            }\n+        }\n+    }\n+    // Check the bodies of block arguments against the current scope\n+    if blocks.len() > 0u {\n+        let inner_sc = {bs: bindings + sc.bs, invalid: sc.invalid};\n+        for blocks.each {|blk|\n+            alt check blk.node {\n+              ast::expr_fn_block(_, body, _) {\n+                v.visit_block(body, inner_sc, v);\n+              }\n+            }\n+        }\n+        for bindings.each {|binding|\n+            test_scope(*cx, sc, binding, none);\n+        }\n+    }\n+}\n+\n+#[warn(no_non_implicitly_copyable_typarams)]\n+fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n+             v: vt<scope>) {\n+    v.visit_expr(input, sc, v);\n+    let orig_invalid = *sc.invalid;\n+    let mut all_invalid = orig_invalid;\n+    let root = expr_root(cx, input, true);\n+    for arms.each {|a|\n+        let mut new_bs = sc.bs;\n+        let root_var = path_def_id(cx, root.ex);\n+        let pat_id_map = pat_util::pat_id_map(cx.tcx.def_map, a.pats[0]);\n+        type info = {\n+            id: node_id,\n+            mut unsafe_tys: [unsafe_ty],\n+            span: span};\n+        let mut binding_info: [info] = [];\n+        for a.pats.each {|pat|\n+            for pattern_roots(cx.tcx, root.mutbl, pat).each {|proot|\n+                let canon_id = pat_id_map.get(proot.name);\n+                alt vec::find(binding_info, {|x| x.id == canon_id}) {\n+                  some(s) { s.unsafe_tys += unsafe_set(proot.mutbl); }\n+                  none {\n+                      binding_info += [\n+                          {id: canon_id,\n+                           mut unsafe_tys: unsafe_set(proot.mutbl),\n+                           span: proot.span}];\n+                  }\n+                }\n+            }\n+        }\n+        for binding_info.each {|info|\n+            new_bs += [mk_binding(cx, info.id, info.span, root_var,\n+                                  copy info.unsafe_tys)];\n+        };\n+        *sc.invalid = orig_invalid;\n+        visit::visit_arm(a, {bs: new_bs with sc}, v);\n+        all_invalid = join_invalid(all_invalid, *sc.invalid);\n+    };\n+    *sc.invalid = all_invalid;\n+}\n+\n+fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n+             sc: scope, v: vt<scope>) {\n+    let root = expr_root(cx, seq, false);\n+\n+    // If this is a mut vector, don't allow it to be touched.\n+    let seq_t = ty::expr_ty(cx.tcx, seq);\n+    let mut cur_mutbl = root.mutbl;\n+    alt ty::get(seq_t).struct {\n+      ty::ty_vec(mt) {\n+        if mt.mutbl != ast::m_imm {\n+            cur_mutbl = some(contains(seq_t));\n+        }\n+      }\n+      _ {}\n+    }\n+    let root_var = path_def_id(cx, root.ex);\n+    let mut new_bs = sc.bs;\n+    for pattern_roots(cx.tcx, cur_mutbl, local.node.pat).each {|proot|\n+        new_bs += [mk_binding(cx, proot.id, proot.span, root_var,\n+                              unsafe_set(proot.mutbl))];\n+    }\n+    visit::visit_block(blk, {bs: new_bs with sc}, v);\n+}\n+\n+fn check_var(cx: ctx, ex: @ast::expr, p: @ast::path, id: ast::node_id,\n+             assign: bool, sc: scope) {\n+    let def = cx.tcx.def_map.get(id);\n+    if !def_is_local_or_self(def) { ret; }\n+    let my_defnum = ast_util::def_id_of_def(def).node;\n+    let my_local_id = local_id_of_node(cx, my_defnum);\n+    let var_t = ty::expr_ty(cx.tcx, ex);\n+    for sc.bs.each {|b|\n+        // excludes variables introduced since the alias was made\n+        if my_local_id < b.local_id {\n+            for b.unsafe_tys.each {|unsafe_ty|\n+                if ty_can_unsafely_include(cx, unsafe_ty, var_t, assign) {\n+                    let inv = @{reason: val_taken, node_id: b.node_id,\n+                                sp: ex.span, path: p};\n+                    *sc.invalid = @list::cons(inv, *sc.invalid);\n+                }\n+            }\n+        } else if b.node_id == my_defnum {\n+            test_scope(cx, sc, b, some(p));\n+        }\n+    }\n+}\n+\n+fn check_lval(cx: @ctx, dest: @ast::expr, sc: scope, v: vt<scope>) {\n+    alt dest.node {\n+      ast::expr_path(p) {\n+        let def = cx.tcx.def_map.get(dest.id);\n+        let dnum = ast_util::def_id_of_def(def).node;\n+        for sc.bs.each {|b|\n+            if b.root_var == some(dnum) {\n+                let inv = @{reason: overwritten, node_id: b.node_id,\n+                            sp: dest.span, path: p};\n+                *sc.invalid = @list::cons(inv, *sc.invalid);\n+            }\n+        }\n+      }\n+      _ { visit_expr(cx, dest, sc, v); }\n+    }\n+}\n+\n+fn check_if(c: @ast::expr, then: ast::blk, els: option<@ast::expr>,\n+            sc: scope, v: vt<scope>) {\n+    v.visit_expr(c, sc, v);\n+    let orig_invalid = *sc.invalid;\n+    v.visit_block(then, sc, v);\n+    let then_invalid = *sc.invalid;\n+    *sc.invalid = orig_invalid;\n+    visit::visit_expr_opt(els, sc, v);\n+    *sc.invalid = join_invalid(*sc.invalid, then_invalid);\n+}\n+\n+fn check_loop(cx: ctx, sc: scope, checker: fn()) {\n+    let orig_invalid = filter_invalid(*sc.invalid, sc.bs);\n+    checker();\n+    let new_invalid = filter_invalid(*sc.invalid, sc.bs);\n+    // Have to check contents of loop again if it invalidated an alias\n+    if list::len(orig_invalid) < list::len(new_invalid) {\n+        let old_silent = cx.silent;\n+        cx.silent = true;\n+        checker();\n+        cx.silent = old_silent;\n+    }\n+    *sc.invalid = new_invalid;\n+}\n+\n+fn test_scope(cx: ctx, sc: scope, b: binding, p: option<@ast::path>) {\n+    let mut prob = find_invalid(b.node_id, *sc.invalid);\n+    alt b.root_var {\n+      some(dn) {\n+        for sc.bs.each {|other|\n+            if !is_none(prob) { break; }\n+            if other.node_id == dn {\n+                prob = find_invalid(other.node_id, *sc.invalid);\n+            }\n+        }\n+      }\n+      _ {}\n+    }\n+    if !is_none(prob) && cant_copy(cx, b) {\n+        let i = option::get(prob);\n+        let msg = alt i.reason {\n+          overwritten { \"overwriting \" + ast_util::path_name(i.path) }\n+          val_taken { \"taking the value of \" + ast_util::path_name(i.path) }\n+        };\n+        let refname = alt p {\n+          some(pt) { \"reference \" + ast_util::path_name(pt) +\n+                        \", which is still used\" }\n+          none { \"an argument\" }\n+        };\n+        err(cx, i.sp, msg + \" will invalidate \" + refname);\n+    }\n+}\n+\n+fn path_def(cx: ctx, ex: @ast::expr) -> option<ast::def> {\n+    ret alt ex.node {\n+          ast::expr_path(_) { some(cx.tcx.def_map.get(ex.id)) }\n+          _ { none }\n+        }\n+}\n+\n+fn path_def_id(cx: ctx, ex: @ast::expr) -> option<ast::node_id> {\n+    alt ex.node {\n+      ast::expr_path(_) {\n+        ret some(ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id)).node);\n+      }\n+      _ { ret none; }\n+    }\n+}\n+\n+fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n+                           mutbl: bool) -> bool {\n+    fn get_mutbl(cur: bool, mt: ty::mt) -> bool {\n+        ret cur || mt.mutbl != ast::m_imm;\n+    }\n+    fn helper(tcx: ty::ctxt, needle: unsafe_ty, haystack: ty::t, mutbl: bool)\n+        -> bool {\n+        if alt needle {\n+          contains(ty) { ty == haystack }\n+          mutbl_contains(ty) { mutbl && ty == haystack }\n+        } { ret true; }\n+        alt ty::get(haystack).struct {\n+          ty::ty_enum(_, ts) {\n+            for ts.tps.each {|t|\n+                if helper(tcx, needle, t, mutbl) { ret true; }\n+            }\n+            ret false;\n+          }\n+          ty::ty_box(mt) | ty::ty_ptr(mt) | ty::ty_uniq(mt) {\n+            ret helper(tcx, needle, mt.ty, get_mutbl(mutbl, mt));\n+          }\n+          ty::ty_rec(fields) {\n+            for fields.each {|f|\n+                if helper(tcx, needle, f.mt.ty, get_mutbl(mutbl, f.mt)) {\n+                    ret true;\n+                }\n+            }\n+            ret false;\n+          }\n+          ty::ty_tup(ts) {\n+            for ts.each {|t| if helper(tcx, needle, t, mutbl) { ret true; } }\n+            ret false;\n+          }\n+          ty::ty_fn({proto: ast::proto_bare, _}) { ret false; }\n+          // These may contain anything.\n+          ty::ty_fn(_) | ty::ty_iface(_, _) { ret true; }\n+          // A type param may include everything, but can only be\n+          // treated as opaque downstream, and is thus safe unless we\n+          // saw mut fields, in which case the whole thing can be\n+          // overwritten.\n+          ty::ty_param(_, _) { ret mutbl; }\n+          _ { ret false; }\n+        }\n+    }\n+    ret helper(cx.tcx, needle, haystack, mutbl);\n+}\n+\n+fn def_is_local_or_self(d: ast::def) -> bool {\n+    alt d {\n+      ast::def_local(_, _) | ast::def_arg(_, _) | ast::def_binding(_) |\n+      ast::def_upvar(_, _, _) | ast::def_self(_) { true }\n+      _ { false }\n+    }\n+}\n+\n+fn local_id_of_node(cx: ctx, id: node_id) -> uint {\n+    alt cx.tcx.items.find(id) {\n+      some(ast_map::node_arg(_, id)) | some(ast_map::node_local(id)) { id }\n+      _ { 0u }\n+    }\n+}\n+\n+// Heuristic, somewhat random way to decide whether to warn when inserting an\n+// implicit copy.\n+fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n+    fn score_ty(tcx: ty::ctxt, ty: ty::t) -> uint {\n+        ret alt ty::get(ty).struct {\n+          ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) |\n+          ty::ty_uint(_) | ty::ty_float(_) | ty::ty_type |\n+          ty::ty_ptr(_) { 1u }\n+          ty::ty_box(_) | ty::ty_iface(_, _) { 3u }\n+          ty::ty_constr(t, _) | ty::ty_res(_, t, _) { score_ty(tcx, t) }\n+          ty::ty_fn(_) { 4u }\n+          ty::ty_str | ty::ty_vec(_) | ty::ty_param(_, _) { 50u }\n+          ty::ty_uniq(mt) { 1u + score_ty(tcx, mt.ty) }\n+          ty::ty_enum(_, substs) {\n+            substs.tps.foldl(0u) { |sum, t| sum + score_ty(tcx, t) }\n+          }\n+          ty::ty_tup(ts) {\n+            ts.foldl(0u) { |sum, t| sum + score_ty(tcx, t) }\n+          }\n+          ty::ty_rec(fs) {\n+            let mut sum = 0u;\n+            for fs.each {|f| sum += score_ty(tcx, f.mt.ty); }\n+            sum\n+          }\n+          _ {\n+            tcx.sess.warn(#fmt(\"score_ty: unexpected type %s\",\n+               ty_to_str(tcx, ty)));\n+            1u // ???\n+          }\n+        };\n+    }\n+    ret score_ty(tcx, ty) > 8u;\n+}\n+\n+type pattern_root = {id: node_id,\n+                     name: ident,\n+                     mutbl: option<unsafe_ty>,\n+                     span: span};\n+\n+fn pattern_roots(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat)\n+    -> [pattern_root] {\n+    fn walk(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat,\n+            &set: [pattern_root]) {\n+        alt pat.node {\n+          ast::pat_ident(nm, sub)\n+          if !pat_util::pat_is_variant(tcx.def_map, pat) {\n+            set += [{id: pat.id, name: path_to_ident(nm), mutbl: mutbl,\n+                        span: pat.span}];\n+            option::iter(sub) {|p| walk(tcx, mutbl, p, set); };\n+          }\n+          ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) |\n+          ast::pat_ident(_, _) | ast::pat_enum(_, none) {}\n+          ast::pat_enum(_, some(ps)) | ast::pat_tup(ps) {\n+            for ps.each {|p| walk(tcx, mutbl, p, set); }\n+          }\n+          ast::pat_rec(fs, _) {\n+            let ty = ty::node_id_to_type(tcx, pat.id);\n+            for fs.each {|f|\n+                let m = ty::get_field(ty, f.ident).mt.mutbl != ast::m_imm,\n+                    c = if m { some(contains(ty)) } else { mutbl };\n+                walk(tcx, c, f.pat, set);\n+            }\n+          }\n+          ast::pat_box(p) {\n+            let ty = ty::node_id_to_type(tcx, pat.id);\n+            let m = alt ty::get(ty).struct {\n+              ty::ty_box(mt) { mt.mutbl != ast::m_imm }\n+              _ { tcx.sess.span_bug(pat.span, \"box pat has non-box type\"); }\n+            },\n+                c = if m  {some(contains(ty)) } else { mutbl };\n+            walk(tcx, c, p, set);\n+          }\n+          ast::pat_uniq(p) {\n+            let ty = ty::node_id_to_type(tcx, pat.id);\n+            let m = alt ty::get(ty).struct {\n+              ty::ty_uniq(mt) { mt.mutbl != ast::m_imm }\n+              _ { tcx.sess.span_bug(pat.span, \"uniq pat has non-uniq type\"); }\n+            },\n+                c = if m { some(contains(ty)) } else { mutbl };\n+            walk(tcx, c, p, set);\n+          }\n+        }\n+    }\n+    let mut set = [];\n+    walk(tcx, mutbl, pat, set);\n+    ret set;\n+}\n+\n+enum deref_t { unbox(bool), field, index, }\n+\n+type deref = @{mutbl: bool, kind: deref_t, outer_t: ty::t};\n+\n+fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool)\n+    -> {ex: @ast::expr, mutbl: option<unsafe_ty>} {\n+\n+    fn maybe_auto_unbox(tcx: ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n+        let mut ds = [], t = t;\n+        loop {\n+            alt ty::get(t).struct {\n+              ty::ty_box(mt) | ty::ty_uniq(mt) | ty::ty_rptr(_, mt) {\n+                ds += [@{mutbl: mt.mutbl == ast::m_mutbl,\n+                         kind: unbox(false),\n+                         outer_t: t}];\n+                t = mt.ty;\n+              }\n+              ty::ty_res(_, inner, substs) {\n+                ds += [@{mutbl: false, kind: unbox(false), outer_t: t}];\n+                t = ty::subst(tcx, substs, inner);\n+              }\n+              ty::ty_enum(did, substs) {\n+                let variants = ty::enum_variants(tcx, did);\n+                if vec::len(*variants) != 1u ||\n+                    vec::len(variants[0].args) != 1u {\n+                    break;\n+                }\n+                ds += [@{mutbl: false, kind: unbox(false), outer_t: t}];\n+                t = ty::subst(tcx, substs, variants[0].args[0]);\n+              }\n+              _ { break; }\n+            }\n+        }\n+        ret {t: t, ds: ds};\n+    }\n+\n+    fn expr_root_(tcx: ty::ctxt, ctor_self: option<node_id>,\n+                  ex: @ast::expr, autoderef: bool) -> {ex: @ast::expr,\n+                                                       ds: @[deref]} {\n+        let mut ds: [deref] = [], ex = ex;\n+        loop {\n+            alt copy ex.node {\n+              ast::expr_field(base, ident, _) {\n+                let auto_unbox =\n+                    maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n+                let mut is_mutbl = false;\n+                alt ty::get(auto_unbox.t).struct {\n+                  ty::ty_rec(fields) {\n+                    for fields.each {|fld|\n+                        if str::eq(ident, fld.ident) {\n+                            is_mutbl = fld.mt.mutbl == ast::m_mutbl;\n+                            break;\n+                        }\n+                    }\n+                  }\n+                  ty::ty_class(did, _) {\n+                    util::common::log_expr(*base);\n+                    let in_self = alt ctor_self {\n+                      some(selfid) {\n+                        alt tcx.def_map.find(base.id) {\n+                          some(ast::def_self(slfid)) { slfid == selfid }\n+                          _ { false }\n+                        }\n+                      }\n+                      none { false }\n+                    };\n+                    for ty::lookup_class_fields(tcx, did).each {|fld|\n+                        if str::eq(ident, fld.ident) {\n+                            is_mutbl = fld.mutability == ast::class_mutable\n+                                || in_self; // all fields can be mutated\n+                            // in the ctor\n+                            break;\n+                        }\n+                    }\n+                  }\n+                  _ {}\n+                }\n+                ds += [@{mutbl:is_mutbl, kind:field, outer_t:auto_unbox.t}];\n+                ds += auto_unbox.ds;\n+                ex = base;\n+              }\n+              ast::expr_index(base, _) {\n+                let auto_unbox =\n+                    maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n+                alt ty::get(auto_unbox.t).struct {\n+                  ty::ty_evec(mt, _) |\n+                  ty::ty_vec(mt) {\n+                    ds +=\n+                        [@{mutbl: mt.mutbl == ast::m_mutbl,\n+                           kind: index,\n+                           outer_t: auto_unbox.t}];\n+                  }\n+                  ty::ty_estr(_) |\n+                  ty::ty_str {\n+                    ds += [@{mutbl:false, kind:index, outer_t:auto_unbox.t}];\n+                  }\n+                  _ { break; }\n+                }\n+                ds += auto_unbox.ds;\n+                ex = base;\n+              }\n+              ast::expr_unary(op, base) {\n+                if op == ast::deref {\n+                    let base_t = ty::expr_ty(tcx, base);\n+                    let mut is_mutbl = false, ptr = false;\n+                    alt ty::get(base_t).struct {\n+                      ty::ty_box(mt) { is_mutbl = mt.mutbl==ast::m_mutbl; }\n+                      ty::ty_uniq(mt) { is_mutbl = mt.mutbl==ast::m_mutbl; }\n+                      ty::ty_res(_, _, _) { }\n+                      ty::ty_enum(_, _) { }\n+                      ty::ty_ptr(mt) | ty::ty_rptr(_, mt) {\n+                        is_mutbl = mt.mutbl==ast::m_mutbl;\n+                        ptr = true;\n+                      }\n+                      _ {\n+                        tcx.sess.span_bug(\n+                            base.span,\n+                            \"ill-typed base expression in deref\"); }\n+                    }\n+                    ds += [@{mutbl: is_mutbl, kind: unbox(ptr && is_mutbl),\n+                             outer_t: base_t}];\n+                    ex = base;\n+                } else { break; }\n+              }\n+              _ { break; }\n+            }\n+        }\n+        if autoderef {\n+            let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, ex));\n+            ds += auto_unbox.ds;\n+        }\n+        ret {ex: ex, ds: @ds};\n+    }\n+\n+    let base_root = expr_root_(cx.tcx, none, ex, autoderef);\n+    let mut unsafe_ty = none;\n+    for vec::each(*base_root.ds) {|d|\n+        if d.mutbl { unsafe_ty = some(contains(d.outer_t)); break; }\n+    }\n+    ret {ex: base_root.ex, mutbl: unsafe_ty};\n+}\n+\n+fn unsafe_set(from: option<unsafe_ty>) -> [unsafe_ty] {\n+    alt from { some(t) { [t] } _ { [] } }\n+}\n+\n+fn find_invalid(id: node_id, lst: @list<@invalid>) -> option<@invalid> {\n+    let mut cur = lst;\n+    loop {\n+        alt *cur {\n+          list::nil { ret none; }\n+          list::cons(head, tail) {\n+            if head.node_id == id { ret some(head); }\n+            cur = tail;\n+          }\n+        }\n+    };\n+}\n+\n+fn join_invalid(a: @list<@invalid>, b: @list<@invalid>) -> @list<@invalid> {\n+    let mut result = a;\n+    list::iter(b) {|elt|\n+        let mut found = false;\n+        list::iter(a) {|e| if e == elt { found = true; } }\n+        if !found { result = @list::cons(elt, result); }\n+    }\n+    result\n+}\n+\n+fn filter_invalid(src: @list<@invalid>, bs: [binding]) -> @list<@invalid> {\n+    let mut out = @list::nil, cur = src;\n+    loop {\n+        alt *cur {\n+          list::cons(head, tail) {\n+            let p = vec::position(bs, {|b| b.node_id == head.node_id});\n+            if !is_none(p) { out = @list::cons(head, out); }\n+            cur = tail;\n+          }\n+          list::nil {\n+            ret out;\n+          }\n+        }\n+    }\n+}\n+\n+fn err(cx: ctx, sp: span, err: str) {\n+    if !cx.silent || !cx.tcx.sess.has_errors() {\n+        cx.tcx.sess.span_err(sp, err);\n+    }\n+}\n+\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "bcf6c799739f78c4aeab4cd4560740b5f1bba3eb", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -52,6 +52,7 @@ export decode_inlined_item;\n type maps = {\n     mutbl_map: middle::borrowck::mutbl_map,\n     root_map: middle::borrowck::root_map,\n+    copy_map: middle::alias::copy_map,\n     last_use_map: middle::liveness::last_use_map,\n     impl_map: middle::resolve::impl_map,\n     method_map: middle::typeck::method_map,\n@@ -830,6 +831,12 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n+    option::iter(maps.copy_map.find(id)) {|_m|\n+        ebml_w.tag(c::tag_table_copy) {||\n+            ebml_w.id(id);\n+        }\n+    }\n+\n     option::iter(maps.last_use_map.find(id)) {|m|\n         ebml_w.tag(c::tag_table_last_use) {||\n             ebml_w.id(id);\n@@ -936,6 +943,8 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n \n         if tag == (c::tag_table_mutbl as uint) {\n             dcx.maps.mutbl_map.insert(id, ());\n+        } else if tag == (c::tag_table_copy as uint) {\n+            dcx.maps.copy_map.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val];\n             let val_dsr = ebml::ebml_deserializer(val_doc);"}, {"sha": "d106c2b23d86edf36767ecf40923f5a68a5c4068", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -171,12 +171,28 @@ export check_crate, root_map, mutbl_map;\n fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n                crate: @ast::crate) -> (root_map, mutbl_map) {\n+\n+    // big hack to keep this off except when I want it on\n+    let msg_level = if tcx.sess.opts.borrowck != 0u {\n+        tcx.sess.opts.borrowck\n+    } else {\n+        os::getenv(\"RUST_BORROWCK\").map_default(0u) { |v|\n+            option::get(uint::from_str(v))\n+        }\n+    };\n+\n     let bccx = @{tcx: tcx,\n                  method_map: method_map,\n+                 msg_level: msg_level,\n                  root_map: root_map(),\n                  mutbl_map: int_hash()};\n \n-    let req_maps = gather_loans::gather_loans(bccx, crate);\n+    let req_maps = if msg_level > 0u {\n+        gather_loans::gather_loans(bccx, crate)\n+    } else {\n+        {req_loan_map: int_hash(),\n+         pure_map: int_hash()}\n+    };\n     check_loans::check_loans(bccx, req_maps, crate);\n     ret (bccx.root_map, bccx.mutbl_map);\n }\n@@ -186,6 +202,7 @@ fn check_crate(tcx: ty::ctxt,\n \n type borrowck_ctxt = @{tcx: ty::ctxt,\n                        method_map: typeck::method_map,\n+                       msg_level: uint,\n                        root_map: root_map,\n                        mutbl_map: mutbl_map};\n \n@@ -346,7 +363,11 @@ impl error_methods for borrowck_ctxt {\n     }\n \n     fn span_err(s: span, m: str) {\n-        self.tcx.sess.span_err(s, m);\n+        if self.msg_level == 1u {\n+            self.tcx.sess.span_warn(s, m);\n+        } else {\n+            self.tcx.sess.span_err(s, m);\n+        }\n     }\n \n     fn span_note(s: span, m: str) {"}, {"sha": "f31f3a209bcd1b54745dc7500041dab50b3cf33a", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -614,7 +614,25 @@ fn make_phi_bindings(bcx: block, map: [exit_node],\n             bcx.fcx.lllocals.insert(node_id, local_mem(local));\n         } else { success = false; }\n     };\n-    if !success {\n+    if success {\n+        // Copy references that the alias analysis considered unsafe\n+        for ids.each_value {|node_id|\n+            if bcx.ccx().maps.copy_map.contains_key(node_id) {\n+                let local = alt bcx.fcx.lllocals.find(node_id) {\n+                  some(local_mem(x)) { x }\n+                  _ { bcx.tcx().sess.bug(\"someone \\\n+                        forgot to document an invariant in \\\n+                        make_phi_bindings\"); }\n+                };\n+                let e_ty = node_id_type(bcx, node_id);\n+                let alloc = alloc_ty(bcx, e_ty);\n+                bcx = copy_val(bcx, INIT, alloc,\n+                               load_if_immediate(bcx, local, e_ty), e_ty);\n+                add_clean(bcx, alloc, e_ty);\n+                bcx.fcx.lllocals.insert(node_id, local_mem(alloc));\n+            }\n+        };\n+    } else {\n         Unreachable(bcx);\n     }\n     ret success;\n@@ -701,7 +719,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n     alt pat.node {\n       ast::pat_ident(_,inner) {\n         if pat_is_variant(bcx.tcx().def_map, pat) { ret bcx; }\n-        if make_copy {\n+        if make_copy || ccx.maps.copy_map.contains_key(pat.id) {\n             let ty = node_id_type(bcx, pat.id);\n             let llty = type_of::type_of(ccx, ty);\n             let alloc = alloca(bcx, llty);"}, {"sha": "34845ceb45ab58c6379e980e0b1ddec051c5b906", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -2888,11 +2888,22 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n         // to have type lldestty (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty);\n     } else if arg_mode == ast::by_ref || arg_mode == ast::by_val {\n+        let mut copied = false;\n         let imm = ty::type_is_immediate(arg.ty);\n         #debug[\"   arg.ty=%s, imm=%b, arg_mode=%?, lv.kind=%?\",\n                ty_to_str(bcx.tcx(), arg.ty), imm, arg_mode, lv.kind];\n         if arg_mode == ast::by_ref && lv.kind != owned && imm {\n             val = do_spill_noroot(bcx, val);\n+            copied = true;\n+        }\n+        if ccx.maps.copy_map.contains_key(e.id) && lv.kind != temporary {\n+            if !copied {\n+                let alloc = alloc_ty(bcx, arg.ty);\n+                bcx = copy_val(bcx, INIT, alloc,\n+                               load_if_immediate(bcx, val, arg.ty), arg.ty);\n+                val = alloc;\n+            } else { bcx = take_ty(bcx, val, arg.ty); }\n+            add_clean(bcx, val, arg.ty);\n         }\n         if arg_mode == ast::by_val && (lv.kind == owned || !imm) {\n             val = Load(bcx, val);"}, {"sha": "cf929353ab4ea45c344ba2f55a6ace30a68199cb", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -19,13 +19,11 @@ enum reflector = {\n impl methods for reflector {\n \n     fn c_uint(u: uint) -> ValueRef {\n-        let bcx = self.bcx;\n-        C_uint(bcx.ccx(), u)\n+        C_uint(self.bcx.ccx(), u)\n     }\n \n     fn visit(ty_name: str, args: [ValueRef]) {\n-        let bcx = self.bcx;\n-        let tcx = bcx.tcx();\n+        let tcx = self.bcx.tcx();\n         let mth_idx = option::get(ty::method_idx(\"visit_\" + ty_name,\n                                                  *self.visitor_methods));\n         let mth_ty = ty::mk_fn(tcx, self.visitor_methods[mth_idx].fty);"}, {"sha": "7cdaeb9273be061135cd8bc4ce7954950600f5df", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -78,6 +78,7 @@ mod middle {\n         mod loan;\n         mod preserve;\n     }\n+    mod alias;\n     mod liveness;\n     mod block_use;\n     mod kind;"}, {"sha": "c418c855237357276de164065af552e78aace65d", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n type point = { x: int, y: int };\n \n fn a() {"}, {"sha": "c8830957c763533e55c8c838bab0c9484fa350c9", "filename": "src/test/compile-fail/borrowck-assign-comp.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n type point = { x: int, y: int };\n \n fn a() {"}, {"sha": "aa2358121e28abcc72a827c724d7280fa4a131b8", "filename": "src/test/compile-fail/borrowck-lend-args.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn borrow(_v: &int) {}\n \n fn borrow_from_arg_imm_ref(&&v: ~int) {"}, {"sha": "def99033e5ef902fcb72e2df920690ea6dd3c467", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n // Note: the borrowck analysis is currently flow-insensitive.\n // Therefore, some of these errors are marked as spurious and could be\n // corrected by a simple change to the analysis.  The others are"}, {"sha": "d9f3bd0567680beeb88f603d9011dfd1ac623ea6", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn borrow(v: &int, f: fn(x: &int)) {\n     f(v);\n }"}, {"sha": "6c26aafd425e3bce0313bfaf2778debaafc35886", "filename": "src/test/compile-fail/borrowck-loan-blocks-move.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn take(-_v: ~int) {\n }\n "}, {"sha": "d7538f168abd268bb8fab15495df3289d587641a", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn borrow(v: &int, f: fn(x: &int)) {\n     f(v);\n }"}, {"sha": "7f45a50cbf40356a98de66c44461e3bf8cf1b8f5", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n type point = { x: int, y: int };\n \n impl foo for point {"}, {"sha": "1fba825d5aba207610ae63e2f89de9e9c4ea55fc", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n type point = { x: int, y: int };\n \n impl foo for point {"}, {"sha": "c3d0a62f05e4d64d3d1dfd9e5660711ddea4c2a5", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n // Here we check that it is allowed to lend out an element of a\n // (locally rooted) mutable, unique vector, and that we then prevent\n // modifications to the contents."}, {"sha": "803f30f8e33a7e4cd48d59a5dfbeb1c4e99ce125", "filename": "src/test/compile-fail/borrowck-mut-vec-as-imm-slice-bad.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn want_slice(v: [int]/&) -> int {\n     let mut sum = 0;\n     for vec::each(v) { |i| sum += i; }"}, {"sha": "a546ef867e1874235e16d37afe9af57322553564", "filename": "src/test/compile-fail/borrowck-no-cycle-in-exchange-heap.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c058f1d9927874fd5bfe40d5e6698880a07c36bb/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c058f1d9927874fd5bfe40d5e6698880a07c36bb/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs?ref=c058f1d9927874fd5bfe40d5e6698880a07c36bb", "patch": "@@ -1,13 +0,0 @@\n-enum cycle {\n-    node({mut a: ~cycle}),\n-    empty\n-}\n-fn main() {\n-    let x = ~node({mut a: ~empty});\n-    // Create a cycle!\n-    alt check *x { //! NOTE loan of immutable local variable granted here\n-      node(y) {\n-        y.a <- x; //! ERROR moving out of immutable local variable prohibited due to outstanding loan\n-      }\n-    };\n-}\n\\ No newline at end of file"}, {"sha": "32135b5ad8f68d41b049165efeb4a56329aea485", "filename": "src/test/compile-fail/borrowck-pat-enum-in-box.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn match_imm_box(v: &const @option<int>) -> int {\n     alt *v {\n       @some(i) {i}"}, {"sha": "753b51b0251c75d827fb13e1af74363ea3fbf3ce", "filename": "src/test/compile-fail/borrowck-pat-enum.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn match_ref(&&v: option<int>) -> int {\n     alt v {\n       some(i) {"}, {"sha": "5018d4835ae4c132a94f777322061953802e9b08", "filename": "src/test/compile-fail/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n // xfail-pretty -- comments are infaithfully preserved\n \n fn main() {"}, {"sha": "bf28af2db4d0bfd99327df253445d6db84e7859f", "filename": "src/test/compile-fail/borrowck-pat-reassign-sometimes-binding.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n // xfail-pretty -- comments are infaithfully preserved\n \n fn main() {"}, {"sha": "9e83fd4be355d7f65e870f622f4d77a99b2fd79e", "filename": "src/test/compile-fail/borrowck-pure-scope-in-call.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n pure fn pure_borrow(_x: &int, _y: ()) {}\n \n fn test1(x: @mut ~int) {"}, {"sha": "cefe3ba05538bcf3b0aa9ff28956eeb51ba23b58", "filename": "src/test/compile-fail/borrowck-unchecked-with-borrow.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn impure(_i: int) {}\n \n // check that unchecked alone does not override borrowck:"}, {"sha": "4433dba0c19a369b83687212cbc907acdd6cd58c", "filename": "src/test/compile-fail/borrowck-uniq-via-box.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn borrow(_v: &int) {}\n \n fn box_mut(v: @mut ~int) {"}, {"sha": "787285e7bf5ac262d13314c25f7542b6feadff2a", "filename": "src/test/compile-fail/borrowck-uniq-via-lend.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn borrow(_v: &int) {}\n \n fn local() {"}, {"sha": "b0fae6622d002532dcbfac3bebb4b04a29d59336", "filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n fn borrow(_v: &int) {}\n \n fn box_mut(v: &mut ~int) {"}, {"sha": "40d25a375668094e1bc95d18b6cad4054c716943", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -8,6 +8,8 @@ fn f<T>(&o: option<T>) {\n fn main() {\n     f::<int>(option::none);\n     //!^ ERROR taking mut reference to static item\n-    //!^^ ERROR illegal borrow unless pure: creating mutable alias to aliasable, immutable memory\n-    //!^^^ NOTE impure due to access to impure function\n+\n+    // Additional errors reported by borrowck:\n+    //^^ ERROR illegal borrow unless pure: creating mutable alias to aliasable, immutable memory\n+    //^^^ NOTE impure due to access to impure function\n }\n\\ No newline at end of file"}, {"sha": "ac20aeec931fbb3b1301baea4e8f6984c3768330", "filename": "src/test/compile-fail/unsafe-alias-2.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -0,0 +1,8 @@\n+// error-pattern:invalidate reference x\n+\n+fn whoknows(x: @mut {mut x: int}) { x.x = 10; }\n+\n+fn main() {\n+    let box = @mut {mut x: 1};\n+    alt *box { x { whoknows(box); log(error, x); } }\n+}"}, {"sha": "0b13c5b5305a15621e9cacd11e41a129a154a62e", "filename": "src/test/compile-fail/unsafe-alias.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -0,0 +1,10 @@\n+// error-pattern:may alias with argument\n+\n+fn foo(x: {mut x: int}, f: fn@()) { log(debug, x); }\n+\n+fn whoknows(x: @mut {mut x: int}) { *x = {mut x: 10}; }\n+\n+fn main() {\n+    let box = @mut {mut x: 1};\n+    foo(*box, bind whoknows(box));\n+}"}, {"sha": "498508d89807d1d8b26364813756dc8f54434f8d", "filename": "src/test/compile-fail/unsafe-alt.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -0,0 +1,8 @@\n+// error-pattern:invalidate reference i\n+\n+enum foo { left({mut x: int}), right(bool) }\n+\n+fn main() {\n+    let mut x = left({mut x: 10});\n+    alt x { left(i) { x = right(false); copy x; log(debug, i); } _ { } }\n+}"}, {"sha": "1767eb3983cdfb34dcdf216f68a03ff7fe0fac74", "filename": "src/test/compile-fail/unsafe-mutable-alias.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -0,0 +1,8 @@\n+// error-pattern:mut reference to a variable that roots another reference\n+\n+fn f(a: {mut x: int}, &b: {mut x: int}) -> int {\n+    b.x += 1;\n+    ret a.x + b.x;\n+}\n+\n+fn main() { let i = {mut x: 4}; log(debug, f(i, i)); }"}, {"sha": "bffa76efa302a121f49e5c26064f11c9c96a0c68", "filename": "src/test/run-pass/alt-implicit-copy-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let x = ~{mut a: ~10, b: ~20};\n     alt x {\n-      ~{a, b} { assert *a == 10; (*x).a = ~30; assert *a == 30; }\n+      ~{a, b} { assert *a == 10; (*x).a = ~30; assert *a == 10; }\n     }\n }"}, {"sha": "43de34e87a83e98622e06fbf9cc46b03ad70466b", "filename": "src/test/run-pass/alt-implicit-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let x = @{mut a: @10, b: @20};\n     alt x {\n-      @{a, b} { assert *a == 10; (*x).a = @30; assert *a == 30; }\n+      @{a, b} { assert *a == 10; (*x).a = @30; assert *a == 10; }\n     }\n }"}, {"sha": "e6e4c36db35db07c66b12388e03a33ca99fde53c", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn want_slice(v: [int]/&) -> int {\n     let mut sum = 0;\n     for vec::each(v) { |i| sum += i; }"}, {"sha": "e5dd8a1756c28ff8775d376cf47447ad87412bd6", "filename": "src/test/run-pass/borrowck-pat-reassign-no-binding.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,6 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n fn main() {\n     let mut x = none;\n     alt x {"}, {"sha": "5241848131de4f88ca8189a9a8c60c5606587c0a", "filename": "src/test/run-pass/borrowck-preserve-box-in-arm-not-taken.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast   (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n // exec-env:RUST_POISON_ON_FREE=1\n \n fn main() {"}, {"sha": "044db44595d13bcfe9eaf47d86b5d0185516d0c0", "filename": "src/test/run-pass/borrowck-preserve-box-in-discr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n // exec-env:RUST_POISON_ON_FREE=1\n \n fn main() {"}, {"sha": "06260dbe5d2a9e7af32fc1cc4fb9d5331ce53414", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n // exec-env:RUST_POISON_ON_FREE=1\n \n fn borrow(x: &int, f: fn(x: &int)) {"}, {"sha": "718507d1efca78af13e190dd668b818eeddc38ae", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n // exec-env:RUST_POISON_ON_FREE=1\n \n fn main() {"}, {"sha": "3bec4fb083a07e5b36f59de1216fa6bc26231a54", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n // exec-env:RUST_POISON_ON_FREE=1\n \n fn borrow(x: &int, f: fn(x: &int)) {"}, {"sha": "ed6e0b19e01db365a0d74b8c6c27a382f20804f3", "filename": "src/test/run-pass/borrowck-preserve-box-sometimes-needed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast   (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n // exec-env:RUST_POISON_ON_FREE=1\n \n fn switcher(x: option<@int>) {"}, {"sha": "ebc1c1ab70dc63def3317e7d310175ccbff6f1c8", "filename": "src/test/run-pass/borrowck-preserve-box.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n // exec-env:RUST_POISON_ON_FREE=1\n \n fn borrow(x: &int, f: fn(x: &int)) {"}, {"sha": "d1098a04d01b566823f76c02e1352cc7cc6dfa73", "filename": "src/test/run-pass/borrowck-preserve-cond-box.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n // exec-env:RUST_POISON_ON_FREE=1\n \n fn testfn(cond: bool) {"}, {"sha": "c50afeeaa90a2319c52ff6f4f1af8c116e645b4b", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -1,3 +1,5 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n // exec-env:RUST_POISON_ON_FREE=1\n \n fn borrow(x: &int, f: fn(x: &int)) {"}, {"sha": "7cd373756f7db37357be680389803ec48207b22c", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "patch": "@@ -91,7 +91,7 @@ fn main() {\n     intrinsic::visit_ty::<i16>(vv);\n     intrinsic::visit_ty::<[int]>(vv);\n \n-    for (copy v.types).each {|s|\n+    for v.types.each {|s|\n         io::println(#fmt(\"type: %s\", s));\n     }\n     assert v.types == [\"bool\", \"int\", \"i8\", \"i16\","}]}