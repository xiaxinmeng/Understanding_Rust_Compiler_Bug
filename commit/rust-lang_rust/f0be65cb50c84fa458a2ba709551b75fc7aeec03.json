{"sha": "f0be65cb50c84fa458a2ba709551b75fc7aeec03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYmU2NWNiNTBjODRmYTQ1OGEyYmE3MDk1NTFiNzVmYzdhZWVjMDM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-25T12:04:37Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-25T12:04:37Z"}, "message": "Fix span information returned by parser::parse_seq\n\nIts hi pos used to be the end of the token after the sequence. It now\nproperly reports the end of the closing token.", "tree": {"sha": "49b9513f175bc6a6fdeb8bee70c5ff836ea0893a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49b9513f175bc6a6fdeb8bee70c5ff836ea0893a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0be65cb50c84fa458a2ba709551b75fc7aeec03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0be65cb50c84fa458a2ba709551b75fc7aeec03", "html_url": "https://github.com/rust-lang/rust/commit/f0be65cb50c84fa458a2ba709551b75fc7aeec03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0be65cb50c84fa458a2ba709551b75fc7aeec03/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "beab6ba8aa46e9c7cdf568c202eb2d7d8db148ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/beab6ba8aa46e9c7cdf568c202eb2d7d8db148ea", "html_url": "https://github.com/rust-lang/rust/commit/beab6ba8aa46e9c7cdf568c202eb2d7d8db148ea"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "7109c57f286d97426bb939276f747a1357976da4", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f0be65cb50c84fa458a2ba709551b75fc7aeec03/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0be65cb50c84fa458a2ba709551b75fc7aeec03/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=f0be65cb50c84fa458a2ba709551b75fc7aeec03", "patch": "@@ -425,7 +425,7 @@ fn parse_ty_postfix(ast::ty_ orig_t, &parser p) -> @ast::ty {\n         if (mut == ast::imm && p.peek() != token::RBRACKET) {\n             // This is explicit type parameter instantiation.\n             auto seq = parse_seq_to_end(token::RBRACKET,\n-                                             some(token::COMMA), parse_ty, p);\n+                                        some(token::COMMA), parse_ty, p);\n \n             alt (orig_t) {\n                 case (ast::ty_path(?pth, ?ann)) {\n@@ -597,7 +597,14 @@ fn parse_arg(&parser p) -> ast::arg {\n }\n \n fn parse_seq_to_end[T](token::token ket, option::t[token::token] sep,\n-                            fn(&parser)->T  f, &parser p) -> T[] {\n+                       fn(&parser)->T  f, &parser p) -> T[] {\n+    auto val = parse_seq_to_before_end(ket, sep, f, p);\n+    p.bump();\n+    ret val;\n+}\n+\n+fn parse_seq_to_before_end[T](token::token ket, option::t[token::token] sep,\n+                              fn(&parser)->T  f, &parser p) -> T[] {\n     let bool first = true;\n     let T[] v = ~[];\n     while (p.peek() != ket) {\n@@ -609,7 +616,6 @@ fn parse_seq_to_end[T](token::token ket, option::t[token::token] sep,\n         }\n         v += ~[f(p)];\n     }\n-    expect(p, ket);\n     ret v;\n }\n \n@@ -619,8 +625,9 @@ fn parse_seq[T](token::token bra, token::token ket,\n                      fn(&parser)->T  f, &parser p) -> spanned[T[]] {\n     auto lo = p.get_lo_pos();\n     expect(p, bra);\n-    auto result = parse_seq_to_end[T](ket, sep, f, p);\n+    auto result = parse_seq_to_before_end[T](ket, sep, f, p);\n     auto hi = p.get_hi_pos();\n+    p.bump();\n     ret spanned(lo, hi, result);\n }\n \n@@ -702,7 +709,7 @@ fn parse_path_and_ty_param_substs(&parser p) -> ast::path {\n     if (p.peek() == token::LBRACKET) {\n         auto seq = parse_seq(token::LBRACKET, token::RBRACKET,\n                              some(token::COMMA), parse_ty, p);\n-        auto hi = p.get_hi_pos();\n+        auto hi = seq.span.hi;\n         path = spanned(lo, hi, rec(global=path.node.global,\n                                    idents=path.node.idents,\n                                    types=seq.node));\n@@ -785,17 +792,15 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             auto e = parse_expr(p);\n             ret rec(mut=m, expr=e);\n         }\n-        auto es =\n-            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                           parse_elt, p);\n+        auto es = parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                            parse_elt, p);\n         hi = es.span.hi;\n         ex = ast::expr_tup(es.node);\n     } else if (p.peek() == token::LBRACKET) {\n         p.bump();\n         auto mut = parse_mutability(p);\n-        auto es =\n-            parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n-                                  parse_expr, p);\n+        auto es = parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n+                                   parse_expr, p);\n         ex = ast::expr_vec(es, mut, ast::sk_rc);\n     } else if (p.peek() == token::POUND_LT) {\n         p.bump();\n@@ -814,12 +819,10 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         p.bump();\n         alt (p.peek()) {\n             case (token::LBRACKET) { // unique array (temporary)\n-\n                 p.bump();\n                 auto mut = parse_mutability(p);\n-                auto es =\n-                    parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n-                                          parse_expr, p);\n+                auto es = parse_seq_to_end\n+                    (token::RBRACKET, some(token::COMMA), parse_expr, p);\n                 ex = ast::expr_vec(es, mut, ast::sk_unique);\n             }\n             case (token::LIT_STR(?s)) {\n@@ -894,9 +897,8 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n                 case (_) { ret some(parse_expr(p)); }\n             }\n         }\n-        auto es =\n-            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                           parse_expr_opt, p);\n+        auto es = parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                            parse_expr_opt, p);\n         hi = es.span.hi;\n         ex = ast::expr_bind(e, es.node);\n     } else if (p.peek() == token::POUND) {\n@@ -995,9 +997,8 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         // The rest is a call expression.\n \n         let @ast::expr f = parse_self_method(p);\n-        auto es =\n-            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                           parse_expr, p);\n+        auto es = parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                            parse_expr, p);\n         hi = es.span.hi;\n         ex = ast::expr_call(f, es.node);\n     } else if (p.peek() == token::MOD_SEP ||\n@@ -1026,8 +1027,8 @@ fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n     if (ivec::len(pth.node.idents) == 0u) {\n         p.fatal(\"expected a syntax expander name\");\n     }\n-    auto es = parse_seq(token::LPAREN, token::RPAREN,\n-                             some(token::COMMA), parse_expr, p);\n+    auto es = parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                        parse_expr, p);\n     auto hi = es.span.hi;\n     ret mk_mac_expr(p, lo, hi, ast::mac_invoc(pth, es.node, none));\n }\n@@ -1053,9 +1054,8 @@ fn parse_dot_or_call_expr_with(&parser p, @ast::expr e) -> @ast::expr {\n                 } else {\n                     // Call expr.\n \n-                    auto es =\n-                        parse_seq(token::LPAREN, token::RPAREN,\n-                                       some(token::COMMA), parse_expr, p);\n+                    auto es = parse_seq(token::LPAREN, token::RPAREN,\n+                                        some(token::COMMA), parse_expr, p);\n                     hi = es.span.hi;\n                     e = mk_expr(p, lo, hi, ast::expr_call(e, es.node));\n                 }\n@@ -1370,9 +1370,8 @@ fn parse_spawn_expr(&parser p) -> @ast::expr {\n     // FIXME: why no full expr?\n \n     auto fn_expr = parse_bottom_expr(p);\n-    auto es =\n-        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                       parse_expr, p);\n+    auto es = parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                        parse_expr, p);\n     auto hi = es.span.hi;\n     ret mk_expr(p, lo, hi, ast::expr_spawn\n                 (ast::dom_implicit, option::none, fn_expr, es.node));\n@@ -1507,8 +1506,7 @@ fn parse_pat(&parser p) -> @ast::pat {\n                 alt (p.peek()) {\n                     case (token::LPAREN) {\n                         auto f = parse_pat;\n-                        auto a =\n-                            parse_seq(token::LPAREN, token::RPAREN,\n+                        auto a = parse_seq(token::LPAREN, token::RPAREN,\n                                            some(token::COMMA), f, p);\n                         args = a.node;\n                         hi = a.span.hi;\n@@ -1763,9 +1761,8 @@ fn parse_ty_param(&parser p) -> ast::ty_param { ret parse_ident(p); }\n fn parse_ty_params(&parser p) -> ast::ty_param[] {\n     let ast::ty_param[] ty_params = ~[];\n     if (p.peek() == token::LBRACKET) {\n-        ty_params =\n-            parse_seq(token::LBRACKET, token::RBRACKET,\n-                           some(token::COMMA), parse_ty_param, p).node;\n+        ty_params = parse_seq(token::LBRACKET, token::RBRACKET,\n+                              some(token::COMMA), parse_ty_param, p).node;\n     }\n     ret ty_params;\n }\n@@ -2116,6 +2113,7 @@ fn parse_item_tag(&parser p, &ast::attribute[] attrs) -> @ast::item {\n                 auto vlo = p.get_lo_pos();\n                 p.bump();\n                 let ast::variant_arg[] args = ~[];\n+                auto vhi = p.get_hi_pos();\n                 alt (p.peek()) {\n                     case (token::LPAREN) {\n                         auto arg_tys =\n@@ -2124,10 +2122,10 @@ fn parse_item_tag(&parser p, &ast::attribute[] attrs) -> @ast::item {\n                         for (@ast::ty ty in arg_tys.node) {\n                             args += ~[rec(ty=ty, id=p.get_id())];\n                         }\n+                        vhi = arg_tys.span.hi;\n                     }\n                     case (_) {/* empty */ }\n                 }\n-                auto vhi = p.get_hi_pos();\n                 expect(p, token::SEMI);\n                 p.get_id();\n                 auto vr ="}]}