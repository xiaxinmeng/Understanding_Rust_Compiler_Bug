{"sha": "62ab9d70f4ba1f35f0fc6d851318ac0966001229", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYWI5ZDcwZjRiYTFmMzVmMGZjNmQ4NTEzMThhYzA5NjYwMDEyMjk=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-09-08T00:12:16Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-09-08T00:19:11Z"}, "message": "tutorial: swap order of \"Traits\" and \"Modules and Crates\" sections.\n\nThis puts \"Traits\" next to \"Generics\", as requested by issue #3397.\nCloses #3397.", "tree": {"sha": "1c08f14bd24d2be09d1951127917d25786b371a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c08f14bd24d2be09d1951127917d25786b371a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62ab9d70f4ba1f35f0fc6d851318ac0966001229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62ab9d70f4ba1f35f0fc6d851318ac0966001229", "html_url": "https://github.com/rust-lang/rust/commit/62ab9d70f4ba1f35f0fc6d851318ac0966001229", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62ab9d70f4ba1f35f0fc6d851318ac0966001229/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53ce42dc4f4fceaf6881a3026f3dbc8fd81ae626", "url": "https://api.github.com/repos/rust-lang/rust/commits/53ce42dc4f4fceaf6881a3026f3dbc8fd81ae626", "html_url": "https://github.com/rust-lang/rust/commit/53ce42dc4f4fceaf6881a3026f3dbc8fd81ae626"}], "stats": {"total": 394, "additions": 197, "deletions": 197}, "files": [{"sha": "8234a8f751807a65e415825a5bd8e288cf86a4ac", "filename": "doc/tutorial.md", "status": "modified", "additions": 197, "deletions": 197, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/62ab9d70f4ba1f35f0fc6d851318ac0966001229/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/62ab9d70f4ba1f35f0fc6d851318ac0966001229/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=62ab9d70f4ba1f35f0fc6d851318ac0966001229", "patch": "@@ -1605,6 +1605,203 @@ resource type. Rust has several kinds that can be used as type bounds:\n > kinds will actually be traits that the compiler has special\n > knowledge about.\n \n+# Traits\n+\n+Traits are Rust's take on value polymorphism\u2014the thing that\n+object-oriented languages tend to solve with methods and inheritance.\n+For example, writing a function that can operate on multiple types of\n+collections.\n+\n+> ***Note:*** This feature is very new, and will need a few extensions to be\n+> applicable to more advanced use cases.\n+\n+## Declaration\n+\n+A trait consists of a set of methods. A method is a function that\n+can be applied to a `self` value and a number of arguments, using the\n+dot notation: `self.foo(arg1, arg2)`.\n+\n+For example, we could declare the trait `to_str` for things that\n+can be converted to a string, with a single method of the same name:\n+\n+~~~~\n+trait to_str {\n+    fn to_str() -> ~str;\n+}\n+~~~~\n+\n+## Implementation\n+\n+To actually implement a trait for a given type, the `impl` form\n+is used. This defines implementations of `to_str` for the `int` and\n+`~str` types.\n+\n+~~~~\n+# trait to_str { fn to_str() -> ~str; }\n+impl int: to_str {\n+    fn to_str() -> ~str { int::to_str(self, 10u) }\n+}\n+impl ~str: to_str {\n+    fn to_str() -> ~str { self }\n+}\n+~~~~\n+\n+Given these, we may call `1.to_str()` to get `~\"1\"`, or\n+`(~\"foo\").to_str()` to get `~\"foo\"` again. This is basically a form of\n+static overloading\u2014when the Rust compiler sees the `to_str` method\n+call, it looks for an implementation that matches the type with a\n+method that matches the name, and simply calls that.\n+\n+## Bounded type parameters\n+\n+The useful thing about value polymorphism is that it does not have to\n+be static. If object-oriented languages only let you call a method on\n+an object when they knew exactly which sub-type it had, that would not\n+get you very far. To be able to call methods on types that aren't\n+known at compile time, it is possible to specify 'bounds' for type\n+parameters.\n+\n+~~~~\n+# trait to_str { fn to_str() -> ~str; }\n+fn comma_sep<T: to_str>(elts: ~[T]) -> ~str {\n+    let mut result = ~\"\", first = true;\n+    for elts.each |elt| {\n+        if first { first = false; }\n+        else { result += ~\", \"; }\n+        result += elt.to_str();\n+    }\n+    return result;\n+}\n+~~~~\n+\n+The syntax for this is similar to the syntax for specifying that a\n+parameter type has to be copyable (which is, in principle, another\n+kind of bound). By declaring `T` as conforming to the `to_str`\n+trait, it becomes possible to call methods from that trait on\n+values of that type inside the function. It will also cause a\n+compile-time error when anyone tries to call `comma_sep` on an array\n+whose element type does not have a `to_str` implementation in scope.\n+\n+## Polymorphic traits\n+\n+Traits may contain type parameters. A trait for\n+generalized sequence types is:\n+\n+~~~~\n+trait seq<T> {\n+    fn len() -> uint;\n+    fn iter(fn(T));\n+}\n+impl<T> ~[T]: seq<T> {\n+    fn len() -> uint { vec::len(self) }\n+    fn iter(b: fn(T)) {\n+        for self.each |elt| { b(elt); }\n+    }\n+}\n+~~~~\n+\n+The implementation has to explicitly declare the type\n+parameter that it binds, `T`, before using it to specify its trait type. Rust requires this declaration because the `impl` could also, for example, specify an implementation of `seq<int>`. The trait type -- appearing after the colon in the `impl` -- *refers* to a type, rather than defining one.\n+\n+The type parameters bound by a trait are in scope in each of the\n+method declarations. So, re-declaring the type parameter\n+`T` as an explicit type parameter for `len` -- in either the trait or\n+the impl -- would be a compile-time error.\n+\n+## The `self` type in traits\n+\n+In a trait, `self` is a special type that you can think of as a\n+type parameter. An implementation of the trait for any given type\n+`T` replaces the `self` type parameter with `T`. The following\n+trait describes types that support an equality operation:\n+\n+~~~~\n+trait eq {\n+  fn equals(&&other: self) -> bool;\n+}\n+\n+impl int: eq {\n+  fn equals(&&other: int) -> bool { other == self }\n+}\n+~~~~\n+\n+Notice that `equals` takes an `int` argument, rather than a `self` argument, in\n+an implementation for type `int`.\n+\n+## Casting to a trait type\n+\n+The above allows us to define functions that polymorphically act on\n+values of *an* unknown type that conforms to a given trait.\n+However, consider this function:\n+\n+~~~~\n+# type circle = int; type rectangle = int;\n+# trait drawable { fn draw(); }\n+# impl int: drawable { fn draw() {} }\n+# fn new_circle() -> int { 1 }\n+fn draw_all<T: drawable>(shapes: ~[T]) {\n+    for shapes.each |shape| { shape.draw(); }\n+}\n+# let c: circle = new_circle();\n+# draw_all(~[c]);\n+~~~~\n+\n+You can call that on an array of circles, or an array of squares\n+(assuming those have suitable `drawable` traits defined), but not\n+on an array containing both circles and squares.\n+\n+When this is needed, a trait name can be used as a type, causing\n+the function to be written simply like this:\n+\n+~~~~\n+# trait drawable { fn draw(); }\n+fn draw_all(shapes: ~[drawable]) {\n+    for shapes.each |shape| { shape.draw(); }\n+}\n+~~~~\n+\n+There is no type parameter anymore (since there isn't a single type\n+that we're calling the function on). Instead, the `drawable` type is\n+used to refer to a type that is a reference-counted box containing a\n+value for which a `drawable` implementation exists, combined with\n+information on where to find the methods for this implementation. This\n+is very similar to the 'vtables' used in most object-oriented\n+languages.\n+\n+To construct such a value, you use the `as` operator to cast a value\n+to a trait type:\n+\n+~~~~\n+# type circle = int; type rectangle = int;\n+# trait drawable { fn draw(); }\n+# impl int: drawable { fn draw() {} }\n+# fn new_circle() -> int { 1 }\n+# fn new_rectangle() -> int { 2 }\n+# fn draw_all(shapes: ~[drawable]) {}\n+let c: circle = new_circle();\n+let r: rectangle = new_rectangle();\n+draw_all(~[c as drawable, r as drawable]);\n+~~~~\n+\n+This will store the value into a box, along with information about the\n+implementation (which is looked up in the scope of the cast). The\n+`drawable` type simply refers to such boxes, and calling methods on it\n+always works, no matter what implementations are in scope.\n+\n+Note that the allocation of a box is somewhat more expensive than\n+simply using a type parameter and passing in the value as-is, and much\n+more expensive than statically resolved method calls.\n+\n+## Trait-less implementations\n+\n+If you only intend to use an implementation for static overloading,\n+and there is no trait available that it conforms to, you are free\n+to leave off the type after the colon.  However, this is only possible when you\n+are defining an implementation in the same module as the receiver\n+type, and the receiver type is a named type (i.e., an enum or a\n+class); [single-variant enums](#single_variant_enum) are a common\n+choice.\n+\n # Modules and crates\n \n The Rust namespace is divided into modules. Each source file starts\n@@ -1872,203 +2069,6 @@ This makes it possible to rebind a variable without actually mutating\n it, which is mostly useful for destructuring (which can rebind, but\n not assign).\n \n-# Traits\n-\n-Traits are Rust's take on value polymorphism\u2014the thing that\n-object-oriented languages tend to solve with methods and inheritance.\n-For example, writing a function that can operate on multiple types of\n-collections.\n-\n-> ***Note:*** This feature is very new, and will need a few extensions to be\n-> applicable to more advanced use cases.\n-\n-## Declaration\n-\n-A trait consists of a set of methods. A method is a function that\n-can be applied to a `self` value and a number of arguments, using the\n-dot notation: `self.foo(arg1, arg2)`.\n-\n-For example, we could declare the trait `to_str` for things that\n-can be converted to a string, with a single method of the same name:\n-\n-~~~~\n-trait to_str {\n-    fn to_str() -> ~str;\n-}\n-~~~~\n-\n-## Implementation\n-\n-To actually implement a trait for a given type, the `impl` form\n-is used. This defines implementations of `to_str` for the `int` and\n-`~str` types.\n-\n-~~~~\n-# trait to_str { fn to_str() -> ~str; }\n-impl int: to_str {\n-    fn to_str() -> ~str { int::to_str(self, 10u) }\n-}\n-impl ~str: to_str {\n-    fn to_str() -> ~str { self }\n-}\n-~~~~\n-\n-Given these, we may call `1.to_str()` to get `~\"1\"`, or\n-`(~\"foo\").to_str()` to get `~\"foo\"` again. This is basically a form of\n-static overloading\u2014when the Rust compiler sees the `to_str` method\n-call, it looks for an implementation that matches the type with a\n-method that matches the name, and simply calls that.\n-\n-## Bounded type parameters\n-\n-The useful thing about value polymorphism is that it does not have to\n-be static. If object-oriented languages only let you call a method on\n-an object when they knew exactly which sub-type it had, that would not\n-get you very far. To be able to call methods on types that aren't\n-known at compile time, it is possible to specify 'bounds' for type\n-parameters.\n-\n-~~~~\n-# trait to_str { fn to_str() -> ~str; }\n-fn comma_sep<T: to_str>(elts: ~[T]) -> ~str {\n-    let mut result = ~\"\", first = true;\n-    for elts.each |elt| {\n-        if first { first = false; }\n-        else { result += ~\", \"; }\n-        result += elt.to_str();\n-    }\n-    return result;\n-}\n-~~~~\n-\n-The syntax for this is similar to the syntax for specifying that a\n-parameter type has to be copyable (which is, in principle, another\n-kind of bound). By declaring `T` as conforming to the `to_str`\n-trait, it becomes possible to call methods from that trait on\n-values of that type inside the function. It will also cause a\n-compile-time error when anyone tries to call `comma_sep` on an array\n-whose element type does not have a `to_str` implementation in scope.\n-\n-## Polymorphic traits\n-\n-Traits may contain type parameters. A trait for\n-generalized sequence types is:\n-\n-~~~~\n-trait seq<T> {\n-    fn len() -> uint;\n-    fn iter(fn(T));\n-}\n-impl<T> ~[T]: seq<T> {\n-    fn len() -> uint { vec::len(self) }\n-    fn iter(b: fn(T)) {\n-        for self.each |elt| { b(elt); }\n-    }\n-}\n-~~~~\n-\n-The implementation has to explicitly declare the type\n-parameter that it binds, `T`, before using it to specify its trait type. Rust requires this declaration because the `impl` could also, for example, specify an implementation of `seq<int>`. The trait type -- appearing after the colon in the `impl` -- *refers* to a type, rather than defining one.\n-\n-The type parameters bound by a trait are in scope in each of the\n-method declarations. So, re-declaring the type parameter\n-`T` as an explicit type parameter for `len` -- in either the trait or\n-the impl -- would be a compile-time error.\n-\n-## The `self` type in traits\n-\n-In a trait, `self` is a special type that you can think of as a\n-type parameter. An implementation of the trait for any given type\n-`T` replaces the `self` type parameter with `T`. The following\n-trait describes types that support an equality operation:\n-\n-~~~~\n-trait eq {\n-  fn equals(&&other: self) -> bool;\n-}\n-\n-impl int: eq {\n-  fn equals(&&other: int) -> bool { other == self }\n-}\n-~~~~\n-\n-Notice that `equals` takes an `int` argument, rather than a `self` argument, in\n-an implementation for type `int`.\n-\n-## Casting to a trait type\n-\n-The above allows us to define functions that polymorphically act on\n-values of *an* unknown type that conforms to a given trait.\n-However, consider this function:\n-\n-~~~~\n-# type circle = int; type rectangle = int;\n-# trait drawable { fn draw(); }\n-# impl int: drawable { fn draw() {} }\n-# fn new_circle() -> int { 1 }\n-fn draw_all<T: drawable>(shapes: ~[T]) {\n-    for shapes.each |shape| { shape.draw(); }\n-}\n-# let c: circle = new_circle();\n-# draw_all(~[c]);\n-~~~~\n-\n-You can call that on an array of circles, or an array of squares\n-(assuming those have suitable `drawable` traits defined), but not\n-on an array containing both circles and squares.\n-\n-When this is needed, a trait name can be used as a type, causing\n-the function to be written simply like this:\n-\n-~~~~\n-# trait drawable { fn draw(); }\n-fn draw_all(shapes: ~[drawable]) {\n-    for shapes.each |shape| { shape.draw(); }\n-}\n-~~~~\n-\n-There is no type parameter anymore (since there isn't a single type\n-that we're calling the function on). Instead, the `drawable` type is\n-used to refer to a type that is a reference-counted box containing a\n-value for which a `drawable` implementation exists, combined with\n-information on where to find the methods for this implementation. This\n-is very similar to the 'vtables' used in most object-oriented\n-languages.\n-\n-To construct such a value, you use the `as` operator to cast a value\n-to a trait type:\n-\n-~~~~\n-# type circle = int; type rectangle = int;\n-# trait drawable { fn draw(); }\n-# impl int: drawable { fn draw() {} }\n-# fn new_circle() -> int { 1 }\n-# fn new_rectangle() -> int { 2 }\n-# fn draw_all(shapes: ~[drawable]) {}\n-let c: circle = new_circle();\n-let r: rectangle = new_rectangle();\n-draw_all(~[c as drawable, r as drawable]);\n-~~~~\n-\n-This will store the value into a box, along with information about the\n-implementation (which is looked up in the scope of the cast). The\n-`drawable` type simply refers to such boxes, and calling methods on it\n-always works, no matter what implementations are in scope.\n-\n-Note that the allocation of a box is somewhat more expensive than\n-simply using a type parameter and passing in the value as-is, and much\n-more expensive than statically resolved method calls.\n-\n-## Trait-less implementations\n-\n-If you only intend to use an implementation for static overloading,\n-and there is no trait available that it conforms to, you are free\n-to leave off the type after the colon.  However, this is only possible when you\n-are defining an implementation in the same module as the receiver\n-type, and the receiver type is a named type (i.e., an enum or a\n-class); [single-variant enums](#single_variant_enum) are a common\n-choice.\n-\n # Tasks\n \n Rust supports a system of lightweight tasks, similar to what is found"}]}