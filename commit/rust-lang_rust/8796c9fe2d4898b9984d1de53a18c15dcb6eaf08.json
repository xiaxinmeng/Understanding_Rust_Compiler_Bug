{"sha": "8796c9fe2d4898b9984d1de53a18c15dcb6eaf08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3OTZjOWZlMmQ0ODk4Yjk5ODRkMWRlNTNhMThjMTVkY2I2ZWFmMDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-18T16:03:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-18T16:03:55Z"}, "message": "auto merge of #5935 : bjz/rust/master, r=thestinger", "tree": {"sha": "9c982d942e9c04b4db38976c30cc83df20c16228", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c982d942e9c04b4db38976c30cc83df20c16228"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08", "html_url": "https://github.com/rust-lang/rust/commit/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4f35a7326e4ea2af9b6000080819208a7f6d722", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f35a7326e4ea2af9b6000080819208a7f6d722", "html_url": "https://github.com/rust-lang/rust/commit/e4f35a7326e4ea2af9b6000080819208a7f6d722"}, {"sha": "a7f6ec854223772bd5c445d6cd2a17a045009f72", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f6ec854223772bd5c445d6cd2a17a045009f72", "html_url": "https://github.com/rust-lang/rust/commit/a7f6ec854223772bd5c445d6cd2a17a045009f72"}], "stats": {"total": 622, "additions": 367, "deletions": 255}, "files": [{"sha": "404f1a82de5d009ad635e7b07a362daf45292eb1", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=8796c9fe2d4898b9984d1de53a18c15dcb6eaf08", "patch": "@@ -288,26 +288,32 @@ impl num::One for f32 {\n \n #[cfg(notest)]\n impl ops::Add<f32,f32> for f32 {\n+    #[inline(always)]\n     fn add(&self, other: &f32) -> f32 { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<f32,f32> for f32 {\n+    #[inline(always)]\n     fn sub(&self, other: &f32) -> f32 { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<f32,f32> for f32 {\n+    #[inline(always)]\n     fn mul(&self, other: &f32) -> f32 { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<f32,f32> for f32 {\n+    #[inline(always)]\n     fn div(&self, other: &f32) -> f32 { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<f32,f32> for f32 {\n+    #[inline(always)]\n     fn modulo(&self, other: &f32) -> f32 { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<f32> for f32 {\n+    #[inline(always)]\n     fn neg(&self) -> f32 { -*self }\n }\n "}, {"sha": "b4eaa0e7fdc605f41c2765a40febaa8bf10be382", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=8796c9fe2d4898b9984d1de53a18c15dcb6eaf08", "patch": "@@ -310,26 +310,32 @@ impl num::One for f64 {\n \n #[cfg(notest)]\n impl ops::Add<f64,f64> for f64 {\n+    #[inline(always)]\n     fn add(&self, other: &f64) -> f64 { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<f64,f64> for f64 {\n+    #[inline(always)]\n     fn sub(&self, other: &f64) -> f64 { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<f64,f64> for f64 {\n+    #[inline(always)]\n     fn mul(&self, other: &f64) -> f64 { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<f64,f64> for f64 {\n+    #[inline(always)]\n     fn div(&self, other: &f64) -> f64 { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<f64,f64> for f64 {\n+    #[inline(always)]\n     fn modulo(&self, other: &f64) -> f64 { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<f64> for f64 {\n+    #[inline(always)]\n     fn neg(&self) -> f64 { -*self }\n }\n "}, {"sha": "38111210c73c13622e7adb7f36b6ea87f7b97d7f", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 108, "deletions": 96, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=8796c9fe2d4898b9984d1de53a18c15dcb6eaf08", "patch": "@@ -387,15 +387,21 @@ pub fn tan(x: float) -> float {\n \n #[cfg(notest)]\n impl Eq for float {\n+    #[inline(always)]\n     fn eq(&self, other: &float) -> bool { (*self) == (*other) }\n+    #[inline(always)]\n     fn ne(&self, other: &float) -> bool { (*self) != (*other) }\n }\n \n #[cfg(notest)]\n impl Ord for float {\n+    #[inline(always)]\n     fn lt(&self, other: &float) -> bool { (*self) < (*other) }\n+    #[inline(always)]\n     fn le(&self, other: &float) -> bool { (*self) <= (*other) }\n+    #[inline(always)]\n     fn ge(&self, other: &float) -> bool { (*self) >= (*other) }\n+    #[inline(always)]\n     fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n }\n \n@@ -444,26 +450,32 @@ impl num::Round for float {\n \n #[cfg(notest)]\n impl ops::Add<float,float> for float {\n+    #[inline(always)]\n     fn add(&self, other: &float) -> float { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<float,float> for float {\n+    #[inline(always)]\n     fn sub(&self, other: &float) -> float { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<float,float> for float {\n+    #[inline(always)]\n     fn mul(&self, other: &float) -> float { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<float,float> for float {\n+    #[inline(always)]\n     fn div(&self, other: &float) -> float { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<float,float> for float {\n+    #[inline(always)]\n     fn modulo(&self, other: &float) -> float { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<float> for float {\n+    #[inline(always)]\n     fn neg(&self) -> float { -*self }\n }\n \n@@ -474,29 +486,29 @@ mod tests {\n     #[test]\n     pub fn test_to_str_exact_do_decimal() {\n         let s = to_str_exact(5.0, 4u);\n-        assert!(s == ~\"5.0000\");\n+        assert_eq!(s, ~\"5.0000\");\n     }\n \n     #[test]\n     pub fn test_from_str() {\n-        assert!(from_str(~\"3\") == Some(3.));\n-        assert!(from_str(~\"3.14\") == Some(3.14));\n-        assert!(from_str(~\"+3.14\") == Some(3.14));\n-        assert!(from_str(~\"-3.14\") == Some(-3.14));\n-        assert!(from_str(~\"2.5E10\") == Some(25000000000.));\n-        assert!(from_str(~\"2.5e10\") == Some(25000000000.));\n-        assert!(from_str(~\"25000000000.E-10\") == Some(2.5));\n-        assert!(from_str(~\".\") == Some(0.));\n-        assert!(from_str(~\".e1\") == Some(0.));\n-        assert!(from_str(~\".e-1\") == Some(0.));\n-        assert!(from_str(~\"5.\") == Some(5.));\n-        assert!(from_str(~\".5\") == Some(0.5));\n-        assert!(from_str(~\"0.5\") == Some(0.5));\n-        assert!(from_str(~\"-.5\") == Some(-0.5));\n-        assert!(from_str(~\"-5\") == Some(-5.));\n-        assert!(from_str(~\"inf\") == Some(infinity));\n-        assert!(from_str(~\"+inf\") == Some(infinity));\n-        assert!(from_str(~\"-inf\") == Some(neg_infinity));\n+        assert_eq!(from_str(~\"3\"), Some(3.));\n+        assert_eq!(from_str(~\"3.14\"), Some(3.14));\n+        assert_eq!(from_str(~\"+3.14\"), Some(3.14));\n+        assert_eq!(from_str(~\"-3.14\"), Some(-3.14));\n+        assert_eq!(from_str(~\"2.5E10\"), Some(25000000000.));\n+        assert_eq!(from_str(~\"2.5e10\"), Some(25000000000.));\n+        assert_eq!(from_str(~\"25000000000.E-10\"), Some(2.5));\n+        assert_eq!(from_str(~\".\"), Some(0.));\n+        assert_eq!(from_str(~\".e1\"), Some(0.));\n+        assert_eq!(from_str(~\".e-1\"), Some(0.));\n+        assert_eq!(from_str(~\"5.\"), Some(5.));\n+        assert_eq!(from_str(~\".5\"), Some(0.5));\n+        assert_eq!(from_str(~\"0.5\"), Some(0.5));\n+        assert_eq!(from_str(~\"-.5\"), Some(-0.5));\n+        assert_eq!(from_str(~\"-5\"), Some(-5.));\n+        assert_eq!(from_str(~\"inf\"), Some(infinity));\n+        assert_eq!(from_str(~\"+inf\"), Some(infinity));\n+        assert_eq!(from_str(~\"-inf\"), Some(neg_infinity));\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str(~\"NaN\") {\n             Some(f) => assert!(is_NaN(f)),\n@@ -526,24 +538,24 @@ mod tests {\n \n     #[test]\n     pub fn test_from_str_hex() {\n-        assert!(from_str_hex(~\"a4\") == Some(164.));\n-        assert!(from_str_hex(~\"a4.fe\") == Some(164.9921875));\n-        assert!(from_str_hex(~\"-a4.fe\") == Some(-164.9921875));\n-        assert!(from_str_hex(~\"+a4.fe\") == Some(164.9921875));\n-        assert!(from_str_hex(~\"ff0P4\") == Some(0xff00 as float));\n-        assert!(from_str_hex(~\"ff0p4\") == Some(0xff00 as float));\n-        assert!(from_str_hex(~\"ff0p-4\") == Some(0xff as float));\n-        assert!(from_str_hex(~\".\") == Some(0.));\n-        assert!(from_str_hex(~\".p1\") == Some(0.));\n-        assert!(from_str_hex(~\".p-1\") == Some(0.));\n-        assert!(from_str_hex(~\"f.\") == Some(15.));\n-        assert!(from_str_hex(~\".f\") == Some(0.9375));\n-        assert!(from_str_hex(~\"0.f\") == Some(0.9375));\n-        assert!(from_str_hex(~\"-.f\") == Some(-0.9375));\n-        assert!(from_str_hex(~\"-f\") == Some(-15.));\n-        assert!(from_str_hex(~\"inf\") == Some(infinity));\n-        assert!(from_str_hex(~\"+inf\") == Some(infinity));\n-        assert!(from_str_hex(~\"-inf\") == Some(neg_infinity));\n+        assert_eq!(from_str_hex(~\"a4\"), Some(164.));\n+        assert_eq!(from_str_hex(~\"a4.fe\"), Some(164.9921875));\n+        assert_eq!(from_str_hex(~\"-a4.fe\"), Some(-164.9921875));\n+        assert_eq!(from_str_hex(~\"+a4.fe\"), Some(164.9921875));\n+        assert_eq!(from_str_hex(~\"ff0P4\"), Some(0xff00 as float));\n+        assert_eq!(from_str_hex(~\"ff0p4\"), Some(0xff00 as float));\n+        assert_eq!(from_str_hex(~\"ff0p-4\"), Some(0xff as float));\n+        assert_eq!(from_str_hex(~\".\"), Some(0.));\n+        assert_eq!(from_str_hex(~\".p1\"), Some(0.));\n+        assert_eq!(from_str_hex(~\".p-1\"), Some(0.));\n+        assert_eq!(from_str_hex(~\"f.\"), Some(15.));\n+        assert_eq!(from_str_hex(~\".f\"), Some(0.9375));\n+        assert_eq!(from_str_hex(~\"0.f\"), Some(0.9375));\n+        assert_eq!(from_str_hex(~\"-.f\"), Some(-0.9375));\n+        assert_eq!(from_str_hex(~\"-f\"), Some(-15.));\n+        assert_eq!(from_str_hex(~\"inf\"), Some(infinity));\n+        assert_eq!(from_str_hex(~\"+inf\"), Some(infinity));\n+        assert_eq!(from_str_hex(~\"-inf\"), Some(neg_infinity));\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str_hex(~\"NaN\") {\n             Some(f) => assert!(is_NaN(f)),\n@@ -558,11 +570,11 @@ mod tests {\n             Some(v) if is_zero(v) => assert!(is_positive(v)),\n             _ => fail!()\n         }\n-        assert!(from_str_hex(~\"e\") == Some(14.));\n-        assert!(from_str_hex(~\"E\") == Some(14.));\n-        assert!(from_str_hex(~\"E1\") == Some(225.));\n-        assert!(from_str_hex(~\"1e1e1\") == Some(123361.));\n-        assert!(from_str_hex(~\"1e1.1\") == Some(481.0625));\n+        assert_eq!(from_str_hex(~\"e\"), Some(14.));\n+        assert_eq!(from_str_hex(~\"E\"), Some(14.));\n+        assert_eq!(from_str_hex(~\"E1\"), Some(225.));\n+        assert_eq!(from_str_hex(~\"1e1e1\"), Some(123361.));\n+        assert_eq!(from_str_hex(~\"1e1.1\"), Some(481.0625));\n \n         assert!(from_str_hex(~\"\").is_none());\n         assert!(from_str_hex(~\"x\").is_none());\n@@ -578,92 +590,92 @@ mod tests {\n \n     #[test]\n     pub fn test_to_str_hex() {\n-        assert!(to_str_hex(164.) == ~\"a4\");\n-        assert!(to_str_hex(164.9921875) == ~\"a4.fe\");\n-        assert!(to_str_hex(-164.9921875) == ~\"-a4.fe\");\n-        assert!(to_str_hex(0xff00 as float) == ~\"ff00\");\n-        assert!(to_str_hex(-(0xff00 as float)) == ~\"-ff00\");\n-        assert!(to_str_hex(0.) == ~\"0\");\n-        assert!(to_str_hex(15.) == ~\"f\");\n-        assert!(to_str_hex(-15.) == ~\"-f\");\n-        assert!(to_str_hex(0.9375) == ~\"0.f\");\n-        assert!(to_str_hex(-0.9375) == ~\"-0.f\");\n-        assert!(to_str_hex(infinity) == ~\"inf\");\n-        assert!(to_str_hex(neg_infinity) == ~\"-inf\");\n-        assert!(to_str_hex(NaN) == ~\"NaN\");\n-        assert!(to_str_hex(0.) == ~\"0\");\n-        assert!(to_str_hex(-0.) == ~\"-0\");\n+        assert_eq!(to_str_hex(164.), ~\"a4\");\n+        assert_eq!(to_str_hex(164.9921875), ~\"a4.fe\");\n+        assert_eq!(to_str_hex(-164.9921875), ~\"-a4.fe\");\n+        assert_eq!(to_str_hex(0xff00 as float), ~\"ff00\");\n+        assert_eq!(to_str_hex(-(0xff00 as float)), ~\"-ff00\");\n+        assert_eq!(to_str_hex(0.), ~\"0\");\n+        assert_eq!(to_str_hex(15.), ~\"f\");\n+        assert_eq!(to_str_hex(-15.), ~\"-f\");\n+        assert_eq!(to_str_hex(0.9375), ~\"0.f\");\n+        assert_eq!(to_str_hex(-0.9375), ~\"-0.f\");\n+        assert_eq!(to_str_hex(infinity), ~\"inf\");\n+        assert_eq!(to_str_hex(neg_infinity), ~\"-inf\");\n+        assert_eq!(to_str_hex(NaN), ~\"NaN\");\n+        assert_eq!(to_str_hex(0.), ~\"0\");\n+        assert_eq!(to_str_hex(-0.), ~\"-0\");\n     }\n \n     #[test]\n     pub fn test_to_str_radix() {\n-        assert!(to_str_radix(36., 36u) == ~\"10\");\n-        assert!(to_str_radix(8.125, 2u) == ~\"1000.001\");\n+        assert_eq!(to_str_radix(36., 36u), ~\"10\");\n+        assert_eq!(to_str_radix(8.125, 2u), ~\"1000.001\");\n     }\n \n     #[test]\n     pub fn test_from_str_radix() {\n-        assert!(from_str_radix(~\"10\", 36u) == Some(36.));\n-        assert!(from_str_radix(~\"1000.001\", 2u) == Some(8.125));\n+        assert_eq!(from_str_radix(~\"10\", 36u), Some(36.));\n+        assert_eq!(from_str_radix(~\"1000.001\", 2u), Some(8.125));\n     }\n \n     #[test]\n     pub fn test_positive() {\n-        assert!((is_positive(infinity)));\n-        assert!((is_positive(1.)));\n-        assert!((is_positive(0.)));\n-        assert!((!is_positive(-1.)));\n-        assert!((!is_positive(neg_infinity)));\n-        assert!((!is_positive(1./neg_infinity)));\n-        assert!((!is_positive(NaN)));\n+        assert!(is_positive(infinity));\n+        assert!(is_positive(1.));\n+        assert!(is_positive(0.));\n+        assert!(!is_positive(-1.));\n+        assert!(!is_positive(neg_infinity));\n+        assert!(!is_positive(1./neg_infinity));\n+        assert!(!is_positive(NaN));\n     }\n \n     #[test]\n     pub fn test_negative() {\n-        assert!((!is_negative(infinity)));\n-        assert!((!is_negative(1.)));\n-        assert!((!is_negative(0.)));\n-        assert!((is_negative(-1.)));\n-        assert!((is_negative(neg_infinity)));\n-        assert!((is_negative(1./neg_infinity)));\n-        assert!((!is_negative(NaN)));\n+        assert!(!is_negative(infinity));\n+        assert!(!is_negative(1.));\n+        assert!(!is_negative(0.));\n+        assert!(is_negative(-1.));\n+        assert!(is_negative(neg_infinity));\n+        assert!(is_negative(1./neg_infinity));\n+        assert!(!is_negative(NaN));\n     }\n \n     #[test]\n     pub fn test_nonpositive() {\n-        assert!((!is_nonpositive(infinity)));\n-        assert!((!is_nonpositive(1.)));\n-        assert!((!is_nonpositive(0.)));\n-        assert!((is_nonpositive(-1.)));\n-        assert!((is_nonpositive(neg_infinity)));\n-        assert!((is_nonpositive(1./neg_infinity)));\n-        assert!((!is_nonpositive(NaN)));\n+        assert!(!is_nonpositive(infinity));\n+        assert!(!is_nonpositive(1.));\n+        assert!(!is_nonpositive(0.));\n+        assert!(is_nonpositive(-1.));\n+        assert!(is_nonpositive(neg_infinity));\n+        assert!(is_nonpositive(1./neg_infinity));\n+        assert!(!is_nonpositive(NaN));\n     }\n \n     #[test]\n     pub fn test_nonnegative() {\n-        assert!((is_nonnegative(infinity)));\n-        assert!((is_nonnegative(1.)));\n-        assert!((is_nonnegative(0.)));\n-        assert!((!is_nonnegative(-1.)));\n-        assert!((!is_nonnegative(neg_infinity)));\n-        assert!((!is_nonnegative(1./neg_infinity)));\n-        assert!((!is_nonnegative(NaN)));\n+        assert!(is_nonnegative(infinity));\n+        assert!(is_nonnegative(1.));\n+        assert!(is_nonnegative(0.));\n+        assert!(!is_nonnegative(-1.));\n+        assert!(!is_nonnegative(neg_infinity));\n+        assert!(!is_nonnegative(1./neg_infinity));\n+        assert!(!is_nonnegative(NaN));\n     }\n \n     #[test]\n     pub fn test_to_str_inf() {\n-        assert!(to_str_digits(infinity, 10u) == ~\"inf\");\n-        assert!(to_str_digits(-infinity, 10u) == ~\"-inf\");\n+        assert_eq!(to_str_digits(infinity, 10u), ~\"inf\");\n+        assert_eq!(to_str_digits(-infinity, 10u), ~\"-inf\");\n     }\n \n     #[test]\n     pub fn test_round() {\n-        assert!(round(5.8) == 6.0);\n-        assert!(round(5.2) == 5.0);\n-        assert!(round(3.0) == 3.0);\n-        assert!(round(2.5) == 3.0);\n-        assert!(round(-3.5) == -4.0);\n+        assert_eq!(round(5.8), 6.0);\n+        assert_eq!(round(5.2), 5.0);\n+        assert_eq!(round(3.0), 3.0);\n+        assert_eq!(round(2.5), 3.0);\n+        assert_eq!(round(-3.5), -4.0);\n     }\n }\n "}, {"sha": "8fd61fb6187e4a2ff6d943d9e05a13cbdffb7366", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 104, "deletions": 62, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=8796c9fe2d4898b9984d1de53a18c15dcb6eaf08", "patch": "@@ -177,29 +177,66 @@ impl num::One for T {\n \n #[cfg(notest)]\n impl ops::Add<T,T> for T {\n+    #[inline(always)]\n     fn add(&self, other: &T) -> T { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<T,T> for T {\n+    #[inline(always)]\n     fn sub(&self, other: &T) -> T { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<T,T> for T {\n+    #[inline(always)]\n     fn mul(&self, other: &T) -> T { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<T,T> for T {\n+    #[inline(always)]\n     fn div(&self, other: &T) -> T { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<T,T> for T {\n+    #[inline(always)]\n     fn modulo(&self, other: &T) -> T { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<T> for T {\n+    #[inline(always)]\n     fn neg(&self) -> T { -*self }\n }\n \n+#[cfg(notest)]\n+impl ops::BitOr<T,T> for T {\n+    #[inline(always)]\n+    fn bitor(&self, other: &T) -> T { *self | *other }\n+}\n+#[cfg(notest)]\n+impl ops::BitAnd<T,T> for T {\n+    #[inline(always)]\n+    fn bitand(&self, other: &T) -> T { *self & *other }\n+}\n+#[cfg(notest)]\n+impl ops::BitXor<T,T> for T {\n+    #[inline(always)]\n+    fn bitxor(&self, other: &T) -> T { *self ^ *other }\n+}\n+#[cfg(notest)]\n+impl ops::Shl<T,T> for T {\n+    #[inline(always)]\n+    fn shl(&self, other: &T) -> T { *self << *other }\n+}\n+#[cfg(notest)]\n+impl ops::Shr<T,T> for T {\n+    #[inline(always)]\n+    fn shr(&self, other: &T) -> T { *self >> *other }\n+}\n+#[cfg(notest)]\n+impl ops::Not<T> for T {\n+    #[inline(always)]\n+    fn not(&self) -> T { !*self }\n+}\n+\n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n@@ -283,19 +320,29 @@ mod tests {\n     use super::inst::T;\n     use prelude::*;\n \n+    #[test]\n+    fn test_bitwise_ops() {\n+        assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));\n+        assert_eq!(0b1000 as T, (0b1100 as T).bitand(&(0b1010 as T)));\n+        assert_eq!(0b0110 as T, (0b1100 as T).bitxor(&(0b1010 as T)));\n+        assert_eq!(0b1110 as T, (0b0111 as T).shl(&(1 as T)));\n+        assert_eq!(0b0111 as T, (0b1110 as T).shr(&(1 as T)));\n+        assert_eq!(-(0b11 as T) - (1 as T), (0b11 as T).not());\n+    }\n+\n     #[test]\n     fn test_from_str() {\n-        assert!(from_str(~\"0\") == Some(0 as T));\n-        assert!(from_str(~\"3\") == Some(3 as T));\n-        assert!(from_str(~\"10\") == Some(10 as T));\n-        assert!(i32::from_str(~\"123456789\") == Some(123456789 as i32));\n-        assert!(from_str(~\"00100\") == Some(100 as T));\n-\n-        assert!(from_str(~\"-1\") == Some(-1 as T));\n-        assert!(from_str(~\"-3\") == Some(-3 as T));\n-        assert!(from_str(~\"-10\") == Some(-10 as T));\n-        assert!(i32::from_str(~\"-123456789\") == Some(-123456789 as i32));\n-        assert!(from_str(~\"-00100\") == Some(-100 as T));\n+        assert_eq!(from_str(~\"0\"), Some(0 as T));\n+        assert_eq!(from_str(~\"3\"), Some(3 as T));\n+        assert_eq!(from_str(~\"10\"), Some(10 as T));\n+        assert_eq!(i32::from_str(~\"123456789\"), Some(123456789 as i32));\n+        assert_eq!(from_str(~\"00100\"), Some(100 as T));\n+\n+        assert_eq!(from_str(~\"-1\"), Some(-1 as T));\n+        assert_eq!(from_str(~\"-3\"), Some(-3 as T));\n+        assert_eq!(from_str(~\"-10\"), Some(-10 as T));\n+        assert_eq!(i32::from_str(~\"-123456789\"), Some(-123456789 as i32));\n+        assert_eq!(from_str(~\"-00100\"), Some(-100 as T));\n \n         assert!(from_str(~\" \").is_none());\n         assert!(from_str(~\"x\").is_none());\n@@ -304,103 +351,98 @@ mod tests {\n     #[test]\n     fn test_parse_bytes() {\n         use str::to_bytes;\n-        assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T));\n-        assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T));\n-        assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T));\n-        assert!(i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32));\n-        assert!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n-                Some(65535 as i32));\n-        assert!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) ==\n-                Some(65535 as i32));\n-        assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T));\n-        assert!(parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T));\n-\n-        assert!(parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T));\n-        assert!(parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T));\n-        assert!(parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T));\n-        assert!(i32::parse_bytes(to_bytes(~\"-123\"), 16u) ==\n-                Some(-291 as i32));\n-        assert!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) ==\n-                Some(-65535 as i32));\n-        assert!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) ==\n-                Some(-65535 as i32));\n-        assert!(parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T));\n-        assert!(parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T));\n+        assert_eq!(parse_bytes(to_bytes(~\"123\"), 10u), Some(123 as T));\n+        assert_eq!(parse_bytes(to_bytes(~\"1001\"), 2u), Some(9 as T));\n+        assert_eq!(parse_bytes(to_bytes(~\"123\"), 8u), Some(83 as T));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"123\"), 16u), Some(291 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u), Some(65535 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u), Some(65535 as i32));\n+        assert_eq!(parse_bytes(to_bytes(~\"z\"), 36u), Some(35 as T));\n+        assert_eq!(parse_bytes(to_bytes(~\"Z\"), 36u), Some(35 as T));\n+\n+        assert_eq!(parse_bytes(to_bytes(~\"-123\"), 10u), Some(-123 as T));\n+        assert_eq!(parse_bytes(to_bytes(~\"-1001\"), 2u), Some(-9 as T));\n+        assert_eq!(parse_bytes(to_bytes(~\"-123\"), 8u), Some(-83 as T));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"-123\"), 16u), Some(-291 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u), Some(-65535 as i32));\n+        assert_eq!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u), Some(-65535 as i32));\n+        assert_eq!(parse_bytes(to_bytes(~\"-z\"), 36u), Some(-35 as T));\n+        assert_eq!(parse_bytes(to_bytes(~\"-Z\"), 36u), Some(-35 as T));\n \n         assert!(parse_bytes(to_bytes(~\"Z\"), 35u).is_none());\n         assert!(parse_bytes(to_bytes(~\"-9\"), 2u).is_none());\n     }\n \n     #[test]\n     fn test_to_str() {\n-        assert!((to_str_radix(0 as T, 10u) == ~\"0\"));\n-        assert!((to_str_radix(1 as T, 10u) == ~\"1\"));\n-        assert!((to_str_radix(-1 as T, 10u) == ~\"-1\"));\n-        assert!((to_str_radix(127 as T, 16u) == ~\"7f\"));\n-        assert!((to_str_radix(100 as T, 10u) == ~\"100\"));\n+        assert_eq!(to_str_radix(0 as T, 10u), ~\"0\");\n+        assert_eq!(to_str_radix(1 as T, 10u), ~\"1\");\n+        assert_eq!(to_str_radix(-1 as T, 10u), ~\"-1\");\n+        assert_eq!(to_str_radix(127 as T, 16u), ~\"7f\");\n+        assert_eq!(to_str_radix(100 as T, 10u), ~\"100\");\n \n     }\n \n     #[test]\n     fn test_int_to_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert!((i8::to_str(i8_val) == ~\"127\"));\n+        assert_eq!(i8::to_str(i8_val), ~\"127\");\n \n         i8_val += 1 as i8;\n-        assert!((i8::to_str(i8_val) == ~\"-128\"));\n+        assert_eq!(i8::to_str(i8_val), ~\"-128\");\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert!((i16::to_str(i16_val) == ~\"32767\"));\n+        assert_eq!(i16::to_str(i16_val), ~\"32767\");\n \n         i16_val += 1 as i16;\n-        assert!((i16::to_str(i16_val) == ~\"-32768\"));\n+        assert_eq!(i16::to_str(i16_val), ~\"-32768\");\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert!((i32::to_str(i32_val) == ~\"2147483647\"));\n+        assert_eq!(i32::to_str(i32_val), ~\"2147483647\");\n \n         i32_val += 1 as i32;\n-        assert!((i32::to_str(i32_val) == ~\"-2147483648\"));\n+        assert_eq!(i32::to_str(i32_val), ~\"-2147483648\");\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert!((i64::to_str(i64_val) == ~\"9223372036854775807\"));\n+        assert_eq!(i64::to_str(i64_val), ~\"9223372036854775807\");\n \n         i64_val += 1 as i64;\n-        assert!((i64::to_str(i64_val) == ~\"-9223372036854775808\"));\n+        assert_eq!(i64::to_str(i64_val), ~\"-9223372036854775808\");\n     }\n \n     #[test]\n     fn test_int_from_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert!((i8::from_str(~\"127\") == Some(i8_val)));\n-        assert!((i8::from_str(~\"128\").is_none()));\n+        assert_eq!(i8::from_str(~\"127\"), Some(i8_val));\n+        assert!(i8::from_str(~\"128\").is_none());\n \n         i8_val += 1 as i8;\n-        assert!((i8::from_str(~\"-128\") == Some(i8_val)));\n-        assert!((i8::from_str(~\"-129\").is_none()));\n+        assert_eq!(i8::from_str(~\"-128\"), Some(i8_val));\n+        assert!(i8::from_str(~\"-129\").is_none());\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert!((i16::from_str(~\"32767\") == Some(i16_val)));\n-        assert!((i16::from_str(~\"32768\").is_none()));\n+        assert_eq!(i16::from_str(~\"32767\"), Some(i16_val));\n+        assert!(i16::from_str(~\"32768\").is_none());\n \n         i16_val += 1 as i16;\n-        assert!((i16::from_str(~\"-32768\") == Some(i16_val)));\n-        assert!((i16::from_str(~\"-32769\").is_none()));\n+        assert_eq!(i16::from_str(~\"-32768\"), Some(i16_val));\n+        assert!(i16::from_str(~\"-32769\").is_none());\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert!((i32::from_str(~\"2147483647\") == Some(i32_val)));\n-        assert!((i32::from_str(~\"2147483648\").is_none()));\n+        assert_eq!(i32::from_str(~\"2147483647\"), Some(i32_val));\n+        assert!(i32::from_str(~\"2147483648\").is_none());\n \n         i32_val += 1 as i32;\n-        assert!((i32::from_str(~\"-2147483648\") == Some(i32_val)));\n-        assert!((i32::from_str(~\"-2147483649\").is_none()));\n+        assert_eq!(i32::from_str(~\"-2147483648\"), Some(i32_val));\n+        assert!(i32::from_str(~\"-2147483649\").is_none());\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert!((i64::from_str(~\"9223372036854775807\") == Some(i64_val)));\n-        assert!((i64::from_str(~\"9223372036854775808\").is_none()));\n+        assert_eq!(i64::from_str(~\"9223372036854775807\"), Some(i64_val));\n+        assert!(i64::from_str(~\"9223372036854775808\").is_none());\n \n         i64_val += 1 as i64;\n-        assert!((i64::from_str(~\"-9223372036854775808\") == Some(i64_val)));\n-        assert!((i64::from_str(~\"-9223372036854775809\").is_none()));\n+        assert_eq!(i64::from_str(~\"-9223372036854775808\"), Some(i64_val));\n+        assert!(i64::from_str(~\"-9223372036854775809\").is_none());\n     }\n \n     #[test]"}, {"sha": "5834214475219497d9432ad38dd19b7f16cf5965", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=8796c9fe2d4898b9984d1de53a18c15dcb6eaf08", "patch": "@@ -77,7 +77,7 @@ pub enum RoundMode {\n  *\n  * ~~~\n  * let twenty: f32 = num::cast(0x14);\n- * assert!(twenty == 20f32);\n+ * assert_eq!(twenty, 20f32);\n  * ~~~\n  */\n #[inline(always)]\n@@ -196,17 +196,17 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n \n #[cfg(test)]\n fn test_num<T:Num + NumCast>(ten: T, two: T) {\n-    assert!(ten.add(&two)    == cast(12));\n-    assert!(ten.sub(&two)    == cast(8));\n-    assert!(ten.mul(&two)    == cast(20));\n-    assert!(ten.div(&two)    == cast(5));\n-    assert!(ten.modulo(&two) == cast(0));\n-\n-    assert!(ten.add(&two)    == ten + two);\n-    assert!(ten.sub(&two)    == ten - two);\n-    assert!(ten.mul(&two)    == ten * two);\n-    assert!(ten.div(&two)    == ten / two);\n-    assert!(ten.modulo(&two) == ten % two);\n+    assert_eq!(ten.add(&two),    cast(12));\n+    assert_eq!(ten.sub(&two),    cast(8));\n+    assert_eq!(ten.mul(&two),    cast(20));\n+    assert_eq!(ten.div(&two),    cast(5));\n+    assert_eq!(ten.modulo(&two), cast(0));\n+\n+    assert_eq!(ten.add(&two),    ten + two);\n+    assert_eq!(ten.sub(&two),    ten - two);\n+    assert_eq!(ten.mul(&two),    ten * two);\n+    assert_eq!(ten.div(&two),    ten / two);\n+    assert_eq!(ten.modulo(&two), ten % two);\n }\n \n #[test] fn test_u8_num()    { test_num(10u8,  2u8)  }\n@@ -227,47 +227,47 @@ macro_rules! test_cast_20(\n     ($_20:expr) => ({\n         let _20 = $_20;\n \n-        assert!(20u   == _20.to_uint());\n-        assert!(20u8  == _20.to_u8());\n-        assert!(20u16 == _20.to_u16());\n-        assert!(20u32 == _20.to_u32());\n-        assert!(20u64 == _20.to_u64());\n-        assert!(20i   == _20.to_int());\n-        assert!(20i8  == _20.to_i8());\n-        assert!(20i16 == _20.to_i16());\n-        assert!(20i32 == _20.to_i32());\n-        assert!(20i64 == _20.to_i64());\n-        assert!(20f   == _20.to_float());\n-        assert!(20f32 == _20.to_f32());\n-        assert!(20f64 == _20.to_f64());\n-\n-        assert!(_20 == NumCast::from(20u));\n-        assert!(_20 == NumCast::from(20u8));\n-        assert!(_20 == NumCast::from(20u16));\n-        assert!(_20 == NumCast::from(20u32));\n-        assert!(_20 == NumCast::from(20u64));\n-        assert!(_20 == NumCast::from(20i));\n-        assert!(_20 == NumCast::from(20i8));\n-        assert!(_20 == NumCast::from(20i16));\n-        assert!(_20 == NumCast::from(20i32));\n-        assert!(_20 == NumCast::from(20i64));\n-        assert!(_20 == NumCast::from(20f));\n-        assert!(_20 == NumCast::from(20f32));\n-        assert!(_20 == NumCast::from(20f64));\n-\n-        assert!(_20 == cast(20u));\n-        assert!(_20 == cast(20u8));\n-        assert!(_20 == cast(20u16));\n-        assert!(_20 == cast(20u32));\n-        assert!(_20 == cast(20u64));\n-        assert!(_20 == cast(20i));\n-        assert!(_20 == cast(20i8));\n-        assert!(_20 == cast(20i16));\n-        assert!(_20 == cast(20i32));\n-        assert!(_20 == cast(20i64));\n-        assert!(_20 == cast(20f));\n-        assert!(_20 == cast(20f32));\n-        assert!(_20 == cast(20f64));\n+        assert_eq!(20u,   _20.to_uint());\n+        assert_eq!(20u8,  _20.to_u8());\n+        assert_eq!(20u16, _20.to_u16());\n+        assert_eq!(20u32, _20.to_u32());\n+        assert_eq!(20u64, _20.to_u64());\n+        assert_eq!(20i,   _20.to_int());\n+        assert_eq!(20i8,  _20.to_i8());\n+        assert_eq!(20i16, _20.to_i16());\n+        assert_eq!(20i32, _20.to_i32());\n+        assert_eq!(20i64, _20.to_i64());\n+        assert_eq!(20f,   _20.to_float());\n+        assert_eq!(20f32, _20.to_f32());\n+        assert_eq!(20f64, _20.to_f64());\n+\n+        assert_eq!(_20, NumCast::from(20u));\n+        assert_eq!(_20, NumCast::from(20u8));\n+        assert_eq!(_20, NumCast::from(20u16));\n+        assert_eq!(_20, NumCast::from(20u32));\n+        assert_eq!(_20, NumCast::from(20u64));\n+        assert_eq!(_20, NumCast::from(20i));\n+        assert_eq!(_20, NumCast::from(20i8));\n+        assert_eq!(_20, NumCast::from(20i16));\n+        assert_eq!(_20, NumCast::from(20i32));\n+        assert_eq!(_20, NumCast::from(20i64));\n+        assert_eq!(_20, NumCast::from(20f));\n+        assert_eq!(_20, NumCast::from(20f32));\n+        assert_eq!(_20, NumCast::from(20f64));\n+\n+        assert_eq!(_20, cast(20u));\n+        assert_eq!(_20, cast(20u8));\n+        assert_eq!(_20, cast(20u16));\n+        assert_eq!(_20, cast(20u32));\n+        assert_eq!(_20, cast(20u64));\n+        assert_eq!(_20, cast(20i));\n+        assert_eq!(_20, cast(20i8));\n+        assert_eq!(_20, cast(20i16));\n+        assert_eq!(_20, cast(20i32));\n+        assert_eq!(_20, cast(20i64));\n+        assert_eq!(_20, cast(20f));\n+        assert_eq!(_20, cast(20f32));\n+        assert_eq!(_20, cast(20f64));\n     })\n )\n "}, {"sha": "0109c915c60148a0e2224d3f2b9627a439a5a50c", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 90, "deletions": 44, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8796c9fe2d4898b9984d1de53a18c15dcb6eaf08/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=8796c9fe2d4898b9984d1de53a18c15dcb6eaf08", "patch": "@@ -142,29 +142,66 @@ impl num::One for T {\n \n #[cfg(notest)]\n impl ops::Add<T,T> for T {\n+    #[inline(always)]\n     fn add(&self, other: &T) -> T { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<T,T> for T {\n+    #[inline(always)]\n     fn sub(&self, other: &T) -> T { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<T,T> for T {\n+    #[inline(always)]\n     fn mul(&self, other: &T) -> T { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<T,T> for T {\n+    #[inline(always)]\n     fn div(&self, other: &T) -> T { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<T,T> for T {\n+    #[inline(always)]\n     fn modulo(&self, other: &T) -> T { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<T> for T {\n+    #[inline(always)]\n     fn neg(&self) -> T { -*self }\n }\n \n+#[cfg(notest)]\n+impl ops::BitOr<T,T> for T {\n+    #[inline(always)]\n+    fn bitor(&self, other: &T) -> T { *self | *other }\n+}\n+#[cfg(notest)]\n+impl ops::BitAnd<T,T> for T {\n+    #[inline(always)]\n+    fn bitand(&self, other: &T) -> T { *self & *other }\n+}\n+#[cfg(notest)]\n+impl ops::BitXor<T,T> for T {\n+    #[inline(always)]\n+    fn bitxor(&self, other: &T) -> T { *self ^ *other }\n+}\n+#[cfg(notest)]\n+impl ops::Shl<T,T> for T {\n+    #[inline(always)]\n+    fn shl(&self, other: &T) -> T { *self << *other }\n+}\n+#[cfg(notest)]\n+impl ops::Shr<T,T> for T {\n+    #[inline(always)]\n+    fn shr(&self, other: &T) -> T { *self >> *other }\n+}\n+#[cfg(notest)]\n+impl ops::Not<T> for T {\n+    #[inline(always)]\n+    fn not(&self) -> T { !*self }\n+}\n+\n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n@@ -247,24 +284,35 @@ mod tests {\n     use super::*;\n     use super::inst::T;\n     use prelude::*;\n+\n+    #[test]\n+    fn test_bitwise_ops() {\n+        assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));\n+        assert_eq!(0b1000 as T, (0b1100 as T).bitand(&(0b1010 as T)));\n+        assert_eq!(0b0110 as T, (0b1100 as T).bitxor(&(0b1010 as T)));\n+        assert_eq!(0b1110 as T, (0b0111 as T).shl(&(1 as T)));\n+        assert_eq!(0b0111 as T, (0b1110 as T).shr(&(1 as T)));\n+        assert_eq!(max_value - (0b1011 as T), (0b1011 as T).not());\n+    }\n+\n     #[test]\n     pub fn test_to_str() {\n-        assert!(to_str_radix(0 as T, 10u) == ~\"0\");\n-        assert!(to_str_radix(1 as T, 10u) == ~\"1\");\n-        assert!(to_str_radix(2 as T, 10u) == ~\"2\");\n-        assert!(to_str_radix(11 as T, 10u) == ~\"11\");\n-        assert!(to_str_radix(11 as T, 16u) == ~\"b\");\n-        assert!(to_str_radix(255 as T, 16u) == ~\"ff\");\n-        assert!(to_str_radix(0xff as T, 10u) == ~\"255\");\n+        assert_eq!(to_str_radix(0 as T, 10u), ~\"0\");\n+        assert_eq!(to_str_radix(1 as T, 10u), ~\"1\");\n+        assert_eq!(to_str_radix(2 as T, 10u), ~\"2\");\n+        assert_eq!(to_str_radix(11 as T, 10u), ~\"11\");\n+        assert_eq!(to_str_radix(11 as T, 16u), ~\"b\");\n+        assert_eq!(to_str_radix(255 as T, 16u), ~\"ff\");\n+        assert_eq!(to_str_radix(0xff as T, 10u), ~\"255\");\n     }\n \n     #[test]\n     pub fn test_from_str() {\n-        assert!(from_str(~\"0\") == Some(0u as T));\n-        assert!(from_str(~\"3\") == Some(3u as T));\n-        assert!(from_str(~\"10\") == Some(10u as T));\n-        assert!(u32::from_str(~\"123456789\") == Some(123456789 as u32));\n-        assert!(from_str(~\"00100\") == Some(100u as T));\n+        assert_eq!(from_str(~\"0\"), Some(0u as T));\n+        assert_eq!(from_str(~\"3\"), Some(3u as T));\n+        assert_eq!(from_str(~\"10\"), Some(10u as T));\n+        assert_eq!(u32::from_str(~\"123456789\"), Some(123456789 as u32));\n+        assert_eq!(from_str(~\"00100\"), Some(100u as T));\n \n         assert!(from_str(~\"\").is_none());\n         assert!(from_str(~\" \").is_none());\n@@ -274,14 +322,12 @@ mod tests {\n     #[test]\n     pub fn test_parse_bytes() {\n         use str::to_bytes;\n-        assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T));\n-        assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T));\n-        assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T));\n-        assert!(u16::parse_bytes(to_bytes(~\"123\"), 16u) ==\n-                Some(291u as u16));\n-        assert!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n-                Some(65535u as u16));\n-        assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T));\n+        assert_eq!(parse_bytes(to_bytes(~\"123\"), 10u), Some(123u as T));\n+        assert_eq!(parse_bytes(to_bytes(~\"1001\"), 2u), Some(9u as T));\n+        assert_eq!(parse_bytes(to_bytes(~\"123\"), 8u), Some(83u as T));\n+        assert_eq!(u16::parse_bytes(to_bytes(~\"123\"), 16u), Some(291u as u16));\n+        assert_eq!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u), Some(65535u as u16));\n+        assert_eq!(parse_bytes(to_bytes(~\"z\"), 36u), Some(35u as T));\n \n         assert!(parse_bytes(to_bytes(~\"Z\"), 10u).is_none());\n         assert!(parse_bytes(to_bytes(~\"_\"), 2u).is_none());\n@@ -290,63 +336,63 @@ mod tests {\n     #[test]\n     fn test_uint_to_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n-        assert!((u8::to_str(u8_val) == ~\"255\"));\n+        assert_eq!(u8::to_str(u8_val), ~\"255\");\n \n         u8_val += 1 as u8;\n-        assert!((u8::to_str(u8_val) == ~\"0\"));\n+        assert_eq!(u8::to_str(u8_val), ~\"0\");\n \n         let mut u16_val: u16 = 65_535_u16;\n-        assert!((u16::to_str(u16_val) == ~\"65535\"));\n+        assert_eq!(u16::to_str(u16_val), ~\"65535\");\n \n         u16_val += 1 as u16;\n-        assert!((u16::to_str(u16_val) == ~\"0\"));\n+        assert_eq!(u16::to_str(u16_val), ~\"0\");\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert!((u32::to_str(u32_val) == ~\"4294967295\"));\n+        assert_eq!(u32::to_str(u32_val), ~\"4294967295\");\n \n         u32_val += 1 as u32;\n-        assert!((u32::to_str(u32_val) == ~\"0\"));\n+        assert_eq!(u32::to_str(u32_val), ~\"0\");\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert!((u64::to_str(u64_val) == ~\"18446744073709551615\"));\n+        assert_eq!(u64::to_str(u64_val), ~\"18446744073709551615\");\n \n         u64_val += 1 as u64;\n-        assert!((u64::to_str(u64_val) == ~\"0\"));\n+        assert_eq!(u64::to_str(u64_val), ~\"0\");\n     }\n \n     #[test]\n     fn test_uint_from_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n-        assert!((u8::from_str(~\"255\") == Some(u8_val)));\n-        assert!((u8::from_str(~\"256\").is_none()));\n+        assert_eq!(u8::from_str(~\"255\"), Some(u8_val));\n+        assert!(u8::from_str(~\"256\").is_none());\n \n         u8_val += 1 as u8;\n-        assert!((u8::from_str(~\"0\") == Some(u8_val)));\n-        assert!((u8::from_str(~\"-1\").is_none()));\n+        assert_eq!(u8::from_str(~\"0\"), Some(u8_val));\n+        assert!(u8::from_str(~\"-1\").is_none());\n \n         let mut u16_val: u16 = 65_535_u16;\n-        assert!((u16::from_str(~\"65535\") == Some(u16_val)));\n-        assert!((u16::from_str(~\"65536\").is_none()));\n+        assert_eq!(u16::from_str(~\"65535\"), Some(u16_val));\n+        assert!(u16::from_str(~\"65536\").is_none());\n \n         u16_val += 1 as u16;\n-        assert!((u16::from_str(~\"0\") == Some(u16_val)));\n-        assert!((u16::from_str(~\"-1\").is_none()));\n+        assert_eq!(u16::from_str(~\"0\"), Some(u16_val));\n+        assert!(u16::from_str(~\"-1\").is_none());\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert!((u32::from_str(~\"4294967295\") == Some(u32_val)));\n-        assert!((u32::from_str(~\"4294967296\").is_none()));\n+        assert_eq!(u32::from_str(~\"4294967295\"), Some(u32_val));\n+        assert!(u32::from_str(~\"4294967296\").is_none());\n \n         u32_val += 1 as u32;\n-        assert!((u32::from_str(~\"0\") == Some(u32_val)));\n-        assert!((u32::from_str(~\"-1\").is_none()));\n+        assert_eq!(u32::from_str(~\"0\"), Some(u32_val));\n+        assert!(u32::from_str(~\"-1\").is_none());\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert!((u64::from_str(~\"18446744073709551615\") == Some(u64_val)));\n-        assert!((u64::from_str(~\"18446744073709551616\").is_none()));\n+        assert_eq!(u64::from_str(~\"18446744073709551615\"), Some(u64_val));\n+        assert!(u64::from_str(~\"18446744073709551616\").is_none());\n \n         u64_val += 1 as u64;\n-        assert!((u64::from_str(~\"0\") == Some(u64_val)));\n-        assert!((u64::from_str(~\"-1\").is_none()));\n+        assert_eq!(u64::from_str(~\"0\"), Some(u64_val));\n+        assert!(u64::from_str(~\"-1\").is_none());\n     }\n \n     #[test]"}]}