{"sha": "5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "node_id": "C_kwDOAAsO6NoAKDVkMmNkMTg3NjVhYmI2ODFjYWNjMmE1N2FlYmRlMTNmYTFkYzMyYzE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-22T10:40:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-22T10:40:23Z"}, "message": "Merge #11780\n\n11780: feat: Add type mismatch diagnostic r=flodiebold a=flodiebold\n\nThis adds a proper diagnostic for type mismatches, turning \"Add reference here\", \"Missing Ok or Some\" and \"Remove this semicolon\" into quickfixes for this single diagnostic.\r\nThe diagnostic is marked as experimental when it does not have one of these quickfixes, so it can be turned off with `rust-analyzer.diagnostics.enableExperimental` (or specifically with `rust-analyzer.diagnostics.disabled` of course, the ID is `type-mismatch`).\r\nThere will still be some false positives, but I think there shouldn't be too many especially when the Chalk fix lands, and it's still experimental anyway :slightly_smiling_face: \r\nThis also fixes type checking for `rustc_legacy_const_generics` just to avoid some errors in tests.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "df82ab0c7753485d6e53e322ce0f3929b168c7ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df82ab0c7753485d6e53e322ce0f3929b168c7ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiOaeXCRBK7hj4Ov3rIwAAIfYIAAJj1/WbQW+PXiHykBsg5Pk7\nMOfIklEZ4HXKKPsJeuUQhT3/HXN1n2iwRpnb9CARMfOHM6mg1Ii3R9RMpeIOTIdZ\nlL9FhRfvjZWdPaeErPt3osyTsqSzsHx4YDQbCkEEMnZqls+6PWJJhP5KZTMpSu+a\npPltPCs2/mRNYgbWVc1UeOx3Bd5oA/Thg6rdaufXVbPl5gADuO9MJGBneufF8joc\nV7BQSGT0KBKvR6qZu0K54tcdWVb/d294KRqEZyIdaKpf70YuR6hWFfw8YbPZHNDW\n5pAKg1zCsdVpJ9Kq9Q35ZNtJY82e2mnQ1oXfLn2QfpRTm2prFZOyP4GMGC4ztzE=\n=M8Fu\n-----END PGP SIGNATURE-----\n", "payload": "tree df82ab0c7753485d6e53e322ce0f3929b168c7ca\nparent 754d8687f4952e0dca50eca95aded4cf58a07fdf\nparent 3bdb68d80f583032e2d4da4ba34bdacc588b8095\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647945623 +0000\ncommitter GitHub <noreply@github.com> 1647945623 +0000\n\nMerge #11780\n\n11780: feat: Add type mismatch diagnostic r=flodiebold a=flodiebold\n\nThis adds a proper diagnostic for type mismatches, turning \"Add reference here\", \"Missing Ok or Some\" and \"Remove this semicolon\" into quickfixes for this single diagnostic.\r\nThe diagnostic is marked as experimental when it does not have one of these quickfixes, so it can be turned off with `rust-analyzer.diagnostics.enableExperimental` (or specifically with `rust-analyzer.diagnostics.disabled` of course, the ID is `type-mismatch`).\r\nThere will still be some false positives, but I think there shouldn't be too many especially when the Chalk fix lands, and it's still experimental anyway :slightly_smiling_face: \r\nThis also fixes type checking for `rustc_legacy_const_generics` just to avoid some errors in tests.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "html_url": "https://github.com/rust-lang/rust/commit/5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "754d8687f4952e0dca50eca95aded4cf58a07fdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/754d8687f4952e0dca50eca95aded4cf58a07fdf", "html_url": "https://github.com/rust-lang/rust/commit/754d8687f4952e0dca50eca95aded4cf58a07fdf"}, {"sha": "3bdb68d80f583032e2d4da4ba34bdacc588b8095", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bdb68d80f583032e2d4da4ba34bdacc588b8095", "html_url": "https://github.com/rust-lang/rust/commit/3bdb68d80f583032e2d4da4ba34bdacc588b8095"}], "stats": {"total": 1460, "additions": 772, "deletions": 688}, "files": [{"sha": "bc43fb15ee45744199f3df7aefae90927cf90d35", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -5,7 +5,7 @@\n //! be expressed in terms of hir types themselves.\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n-use hir_def::{path::ModPath, type_ref::Mutability};\n+use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n@@ -28,7 +28,6 @@ macro_rules! diagnostics {\n }\n \n diagnostics![\n-    AddReferenceHere,\n     BreakOutsideOfLoop,\n     InactiveCode,\n     IncorrectCase,\n@@ -38,11 +37,10 @@ diagnostics![\n     MismatchedArgCount,\n     MissingFields,\n     MissingMatchArms,\n-    MissingOkOrSomeInTailExpr,\n     MissingUnsafe,\n     NoSuchField,\n-    RemoveThisSemicolon,\n     ReplaceFilterMapNextWithFindMap,\n+    TypeMismatch,\n     UnimplementedBuiltinMacro,\n     UnresolvedExternCrate,\n     UnresolvedImport,\n@@ -147,29 +145,18 @@ pub struct MismatchedArgCount {\n     pub found: usize,\n }\n \n-#[derive(Debug)]\n-pub struct RemoveThisSemicolon {\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n-}\n-\n-#[derive(Debug)]\n-pub struct MissingOkOrSomeInTailExpr {\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n-    // `Some` or `Ok` depending on whether the return type is Result or Option\n-    pub required: String,\n-    pub expected: Type,\n-}\n-\n #[derive(Debug)]\n pub struct MissingMatchArms {\n     pub file: HirFileId,\n     pub match_expr: AstPtr<ast::Expr>,\n }\n \n #[derive(Debug)]\n-pub struct AddReferenceHere {\n+pub struct TypeMismatch {\n+    // FIXME: add mismatches in patterns as well\n     pub expr: InFile<AstPtr<ast::Expr>>,\n-    pub mutability: Mutability,\n+    pub expected: Type,\n+    pub actual: Type,\n }\n \n pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "f4e58d88ed888b773eb5b2393f88f1bcd67c722e", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 79, "deletions": 34, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -58,7 +58,6 @@ use hir_ty::{\n     consteval::{\n         eval_const, unknown_const_as_generic, ComputedExpr, ConstEvalCtx, ConstEvalError, ConstExt,\n     },\n-    could_unify,\n     diagnostics::BodyValidationDiagnostic,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n@@ -85,12 +84,11 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AddReferenceHere, AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase,\n-        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n-        MissingMatchArms, MissingOkOrSomeInTailExpr, MissingUnsafe, NoSuchField,\n-        RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap, UnimplementedBuiltinMacro,\n-        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n-        UnresolvedProcMacro,\n+        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n+        MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n+        MissingUnsafe, NoSuchField, ReplaceFilterMapNextWithFindMap, TypeMismatch,\n+        UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n+        UnresolvedModule, UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo},\n@@ -1005,6 +1003,24 @@ impl Adt {\n         Type::from_def(db, id.module(db.upcast()).krate(), id)\n     }\n \n+    /// Turns this ADT into a type with the given type parameters. This isn't\n+    /// the greatest API, FIXME find a better one.\n+    pub fn ty_with_args(self, db: &dyn HirDatabase, args: &[Type]) -> Type {\n+        let id = AdtId::from(self);\n+        let mut it = args.iter().map(|t| t.ty.clone());\n+        let ty = TyBuilder::def_ty(db, id.into())\n+            .fill(|x| {\n+                let r = it.next().unwrap_or_else(|| TyKind::Error.intern(Interner));\n+                match x {\n+                    ParamKind::Type => GenericArgData::Ty(r).intern(Interner),\n+                    ParamKind::Const(ty) => unknown_const_as_generic(ty.clone()),\n+                }\n+            })\n+            .build();\n+        let krate = id.module(db.upcast()).krate();\n+        Type::new(db, krate, id, ty)\n+    }\n+\n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n         match self {\n             Adt::Struct(s) => s.module(db),\n@@ -1020,6 +1036,14 @@ impl Adt {\n             Adt::Enum(e) => e.name(db),\n         }\n     }\n+\n+    pub fn as_enum(&self) -> Option<Enum> {\n+        if let Self::Enum(v) = self {\n+            Some(*v)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n impl HasVisibility for Adt {\n@@ -1163,6 +1187,30 @@ impl DefWithBody {\n                 }\n             }\n         }\n+        for (expr, mismatch) in infer.expr_type_mismatches() {\n+            let expr = match source_map.expr_syntax(expr) {\n+                Ok(expr) => expr,\n+                Err(SyntheticSyntax) => continue,\n+            };\n+            acc.push(\n+                TypeMismatch {\n+                    expr,\n+                    expected: Type::new(\n+                        db,\n+                        krate,\n+                        DefWithBodyId::from(self),\n+                        mismatch.expected.clone(),\n+                    ),\n+                    actual: Type::new(\n+                        db,\n+                        krate,\n+                        DefWithBodyId::from(self),\n+                        mismatch.actual.clone(),\n+                    ),\n+                }\n+                .into(),\n+            );\n+        }\n \n         for expr in hir_ty::diagnostics::missing_unsafe(db, self.into()) {\n             match source_map.expr_syntax(expr) {\n@@ -1259,25 +1307,6 @@ impl DefWithBody {\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n-                BodyValidationDiagnostic::RemoveThisSemicolon { expr } => {\n-                    match source_map.expr_syntax(expr) {\n-                        Ok(expr) => acc.push(RemoveThisSemicolon { expr }.into()),\n-                        Err(SyntheticSyntax) => (),\n-                    }\n-                }\n-                BodyValidationDiagnostic::MissingOkOrSomeInTailExpr { expr, required } => {\n-                    match source_map.expr_syntax(expr) {\n-                        Ok(expr) => acc.push(\n-                            MissingOkOrSomeInTailExpr {\n-                                expr,\n-                                required,\n-                                expected: self.body_type(db),\n-                            }\n-                            .into(),\n-                        ),\n-                        Err(SyntheticSyntax) => (),\n-                    }\n-                }\n                 BodyValidationDiagnostic::MissingMatchArms { match_expr } => {\n                     match source_map.expr_syntax(match_expr) {\n                         Ok(source_ptr) => {\n@@ -1299,12 +1328,6 @@ impl DefWithBody {\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n-                BodyValidationDiagnostic::AddReferenceHere { arg_expr, mutability } => {\n-                    match source_map.expr_syntax(arg_expr) {\n-                        Ok(expr) => acc.push(AddReferenceHere { expr, mutability }.into()),\n-                        Err(SyntheticSyntax) => (),\n-                    }\n-                }\n             }\n         }\n \n@@ -2618,6 +2641,17 @@ impl Type {\n         Type { krate, env: environment, ty }\n     }\n \n+    pub fn reference(inner: &Type, m: Mutability) -> Type {\n+        inner.derived(\n+            TyKind::Ref(\n+                if m.is_mut() { hir_ty::Mutability::Mut } else { hir_ty::Mutability::Not },\n+                hir_ty::static_lifetime(),\n+                inner.ty.clone(),\n+            )\n+            .intern(Interner),\n+        )\n+    }\n+\n     fn new(db: &dyn HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n         let resolver = lexical_env.resolver(db.upcast());\n         let environment = resolver\n@@ -2659,6 +2693,12 @@ impl Type {\n         matches!(self.ty.kind(Interner), TyKind::Ref(..))\n     }\n \n+    pub fn as_reference(&self) -> Option<(Type, Mutability)> {\n+        let (ty, _lt, m) = self.ty.as_reference()?;\n+        let m = Mutability::from_mutable(matches!(m, hir_ty::Mutability::Mut));\n+        Some((self.derived(ty.clone()), m))\n+    }\n+\n     pub fn is_slice(&self) -> bool {\n         matches!(self.ty.kind(Interner), TyKind::Slice(..))\n     }\n@@ -2900,7 +2940,7 @@ impl Type {\n         self.autoderef_(db).map(move |ty| self.derived(ty))\n     }\n \n-    pub fn autoderef_<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Ty> + 'a {\n+    fn autoderef_<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Ty> + 'a {\n         // There should be no inference vars in types passed here\n         let canonical = hir_ty::replace_errors_with_variables(&self.ty);\n         let environment = self.env.clone();\n@@ -3238,7 +3278,12 @@ impl Type {\n \n     pub fn could_unify_with(&self, db: &dyn HirDatabase, other: &Type) -> bool {\n         let tys = hir_ty::replace_errors_with_variables(&(self.ty.clone(), other.ty.clone()));\n-        could_unify(db, self.env.clone(), &tys)\n+        hir_ty::could_unify(db, self.env.clone(), &tys)\n+    }\n+\n+    pub fn could_coerce_to(&self, db: &dyn HirDatabase, to: &Type) -> bool {\n+        let tys = hir_ty::replace_errors_with_variables(&(self.ty.clone(), to.ty.clone()));\n+        hir_ty::could_coerce(db, self.env.clone(), &tys)\n     }\n }\n "}, {"sha": "8e9336a0cc49f1926c4f0b90a7f9d95c27ceca11", "filename": "crates/hir_def/src/type_ref.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -38,6 +38,22 @@ impl Mutability {\n             Mutability::Mut => \"mut \",\n         }\n     }\n+\n+    /// Returns `true` if the mutability is [`Mut`].\n+    ///\n+    /// [`Mut`]: Mutability::Mut\n+    #[must_use]\n+    pub fn is_mut(&self) -> bool {\n+        matches!(self, Self::Mut)\n+    }\n+\n+    /// Returns `true` if the mutability is [`Shared`].\n+    ///\n+    /// [`Shared`]: Mutability::Shared\n+    #[must_use]\n+    pub fn is_shared(&self) -> bool {\n+        matches!(self, Self::Shared)\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]"}, {"sha": "71eb7e3995799e8073fc2f23c1ba32eec2d4ad49", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 2, "deletions": 127, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -4,10 +4,7 @@\n \n use std::sync::Arc;\n \n-use hir_def::{\n-    expr::Statement, path::path, resolver::HasResolver, type_ref::Mutability, AssocItemId,\n-    DefWithBodyId, HasModule,\n-};\n+use hir_def::{path::path, resolver::HasResolver, AssocItemId, DefWithBodyId, HasModule};\n use hir_expand::name;\n use itertools::Either;\n use rustc_hash::FxHashSet;\n@@ -20,7 +17,7 @@ use crate::{\n         deconstruct_pat::DeconstructedPat,\n         usefulness::{compute_match_usefulness, MatchCheckCtx},\n     },\n-    AdtId, InferenceResult, Interner, Ty, TyExt, TyKind,\n+    InferenceResult, Interner, TyExt,\n };\n \n pub(crate) use hir_def::{\n@@ -43,20 +40,9 @@ pub enum BodyValidationDiagnostic {\n         expected: usize,\n         found: usize,\n     },\n-    RemoveThisSemicolon {\n-        expr: ExprId,\n-    },\n-    MissingOkOrSomeInTailExpr {\n-        expr: ExprId,\n-        required: String,\n-    },\n     MissingMatchArms {\n         match_expr: ExprId,\n     },\n-    AddReferenceHere {\n-        arg_expr: ExprId,\n-        mutability: Mutability,\n-    },\n }\n \n impl BodyValidationDiagnostic {\n@@ -116,30 +102,6 @@ impl ExprValidator {\n                 });\n             }\n         }\n-        let body_expr = &body[body.body_expr];\n-        if let Expr::Block { statements, tail, .. } = body_expr {\n-            if let Some(t) = tail {\n-                self.validate_results_in_tail_expr(body.body_expr, *t, db);\n-            } else if let Some(Statement::Expr { expr: id, .. }) = statements.last() {\n-                self.validate_missing_tail_expr(body.body_expr, *id);\n-            }\n-        }\n-\n-        let infer = &self.infer;\n-        let diagnostics = &mut self.diagnostics;\n-\n-        infer\n-            .expr_type_mismatches()\n-            .filter_map(|(expr, mismatch)| {\n-                let (expr_without_ref, mutability) =\n-                    check_missing_refs(infer, expr, &mismatch.expected)?;\n-\n-                Some((expr_without_ref, mutability))\n-            })\n-            .for_each(|(arg_expr, mutability)| {\n-                diagnostics\n-                    .push(BodyValidationDiagnostic::AddReferenceHere { arg_expr, mutability });\n-            });\n     }\n \n     fn validate_call(\n@@ -330,66 +292,6 @@ impl ExprValidator {\n         }\n         pattern\n     }\n-\n-    fn validate_results_in_tail_expr(&mut self, body_id: ExprId, id: ExprId, db: &dyn HirDatabase) {\n-        // the mismatch will be on the whole block currently\n-        let mismatch = match self.infer.type_mismatch_for_expr(body_id) {\n-            Some(m) => m,\n-            None => return,\n-        };\n-\n-        let core_result_path = path![core::result::Result];\n-        let core_option_path = path![core::option::Option];\n-\n-        let resolver = self.owner.resolver(db.upcast());\n-        let core_result_enum = match resolver.resolve_known_enum(db.upcast(), &core_result_path) {\n-            Some(it) => it,\n-            _ => return,\n-        };\n-        let core_option_enum = match resolver.resolve_known_enum(db.upcast(), &core_option_path) {\n-            Some(it) => it,\n-            _ => return,\n-        };\n-\n-        let (params, required) = match mismatch.expected.kind(Interner) {\n-            TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), parameters)\n-                if *enum_id == core_result_enum =>\n-            {\n-                (parameters, \"Ok\".to_string())\n-            }\n-            TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), parameters)\n-                if *enum_id == core_option_enum =>\n-            {\n-                (parameters, \"Some\".to_string())\n-            }\n-            _ => return,\n-        };\n-\n-        if params.len(Interner) > 0 && params.at(Interner, 0).ty(Interner) == Some(&mismatch.actual)\n-        {\n-            self.diagnostics\n-                .push(BodyValidationDiagnostic::MissingOkOrSomeInTailExpr { expr: id, required });\n-        }\n-    }\n-\n-    fn validate_missing_tail_expr(&mut self, body_id: ExprId, possible_tail_id: ExprId) {\n-        let mismatch = match self.infer.type_mismatch_for_expr(body_id) {\n-            Some(m) => m,\n-            None => return,\n-        };\n-\n-        let possible_tail_ty = match self.infer.type_of_expr.get(possible_tail_id) {\n-            Some(ty) => ty,\n-            None => return,\n-        };\n-\n-        if !mismatch.actual.is_unit() || mismatch.expected != *possible_tail_ty {\n-            return;\n-        }\n-\n-        self.diagnostics\n-            .push(BodyValidationDiagnostic::RemoveThisSemicolon { expr: possible_tail_id });\n-    }\n }\n \n struct FilterMapNextChecker {\n@@ -523,30 +425,3 @@ fn types_of_subpatterns_do_match(pat: PatId, body: &Body, infer: &InferenceResul\n     walk(pat, body, infer, &mut has_type_mismatches);\n     !has_type_mismatches\n }\n-\n-fn check_missing_refs(\n-    infer: &InferenceResult,\n-    arg: ExprId,\n-    param: &Ty,\n-) -> Option<(ExprId, Mutability)> {\n-    let arg_ty = infer.type_of_expr.get(arg)?;\n-\n-    let reference_one = arg_ty.as_reference();\n-    let reference_two = param.as_reference();\n-\n-    match (reference_one, reference_two) {\n-        (None, Some((referenced_ty, _, mutability))) if referenced_ty == arg_ty => {\n-            Some((arg, Mutability::from_mutable(matches!(mutability, chalk_ir::Mutability::Mut))))\n-        }\n-        (None, Some((referenced_ty, _, mutability))) => match referenced_ty.kind(Interner) {\n-            TyKind::Slice(subst) if matches!(arg_ty.kind(Interner), TyKind::Array(arr_subst, _) if arr_subst == subst) => {\n-                Some((\n-                    arg,\n-                    Mutability::from_mutable(matches!(mutability, chalk_ir::Mutability::Mut)),\n-                ))\n-            }\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n-}"}, {"sha": "c91cdec18341a7c3bd584d8dcd53366642b5829d", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -44,6 +44,8 @@ use crate::{\n //\n // https://github.com/rust-lang/rust/issues/57411\n #[allow(unreachable_pub)]\n+pub use coerce::could_coerce;\n+#[allow(unreachable_pub)]\n pub use unify::could_unify;\n \n pub(crate) mod unify;"}, {"sha": "f54440bf5b372e00b8422ae4069a47d0de2f7c5f", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 78, "deletions": 22, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -5,23 +5,26 @@\n //! See <https://doc.rust-lang.org/nomicon/coercions.html> and\n //! `librustc_typeck/check/coercion.rs`.\n \n-use std::iter;\n+use std::{iter, sync::Arc};\n \n-use chalk_ir::{cast::Cast, Goal, Mutability, TyVariableKind};\n+use chalk_ir::{cast::Cast, BoundVar, Goal, Mutability, TyVariableKind};\n use hir_def::{expr::ExprId, lang_item::LangItemTarget};\n use stdx::always;\n use syntax::SmolStr;\n \n use crate::{\n     autoderef::{Autoderef, AutoderefKind},\n+    db::HirDatabase,\n     infer::{\n-        Adjust, Adjustment, AutoBorrow, InferOk, InferResult, InferenceContext, OverloadedDeref,\n-        PointerCast, TypeError, TypeMismatch,\n+        Adjust, Adjustment, AutoBorrow, InferOk, InferenceContext, OverloadedDeref, PointerCast,\n+        TypeError, TypeMismatch,\n     },\n     static_lifetime, Canonical, DomainGoal, FnPointer, FnSig, Guidance, InEnvironment, Interner,\n-    Solution, Substitution, Ty, TyBuilder, TyExt, TyKind,\n+    Solution, Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind,\n };\n \n+use super::unify::InferenceTable;\n+\n pub(crate) type CoerceResult = Result<InferOk<(Vec<Adjustment>, Ty)>, TypeError>;\n \n /// Do not require any adjustments, i.e. coerce `x -> x`.\n@@ -84,8 +87,8 @@ impl CoerceMany {\n         };\n         if let Some(sig) = sig {\n             let target_ty = TyKind::Function(sig.to_fn_ptr()).intern(Interner);\n-            let result1 = ctx.coerce_inner(self.expected_ty.clone(), &target_ty);\n-            let result2 = ctx.coerce_inner(expr_ty.clone(), &target_ty);\n+            let result1 = ctx.table.coerce_inner(self.expected_ty.clone(), &target_ty);\n+            let result2 = ctx.table.coerce_inner(expr_ty.clone(), &target_ty);\n             if let (Ok(result1), Ok(result2)) = (result1, result2) {\n                 ctx.table.register_infer_ok(result1);\n                 ctx.table.register_infer_ok(result2);\n@@ -118,6 +121,45 @@ impl CoerceMany {\n     }\n }\n \n+pub fn could_coerce(\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    tys: &Canonical<(Ty, Ty)>,\n+) -> bool {\n+    coerce(db, env, tys).is_ok()\n+}\n+\n+pub(crate) fn coerce(\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    tys: &Canonical<(Ty, Ty)>,\n+) -> Result<(Vec<Adjustment>, Ty), TypeError> {\n+    let mut table = InferenceTable::new(db, env);\n+    let vars = table.fresh_subst(tys.binders.as_slice(Interner));\n+    let ty1_with_vars = vars.apply(tys.value.0.clone(), Interner);\n+    let ty2_with_vars = vars.apply(tys.value.1.clone(), Interner);\n+    let (adjustments, ty) = table.coerce(&ty1_with_vars, &ty2_with_vars)?;\n+    // default any type vars that weren't unified back to their original bound vars\n+    // (kind of hacky)\n+    let find_var = |iv| {\n+        vars.iter(Interner).position(|v| match v.interned() {\n+            chalk_ir::GenericArgData::Ty(ty) => ty.inference_var(Interner),\n+            chalk_ir::GenericArgData::Lifetime(lt) => lt.inference_var(Interner),\n+            chalk_ir::GenericArgData::Const(c) => c.inference_var(Interner),\n+        } == Some(iv))\n+    };\n+    let fallback = |iv, kind, default, binder| match kind {\n+        chalk_ir::VariableKind::Ty(_ty_kind) => find_var(iv)\n+            .map_or(default, |i| BoundVar::new(binder, i).to_ty(Interner).cast(Interner)),\n+        chalk_ir::VariableKind::Lifetime => find_var(iv)\n+            .map_or(default, |i| BoundVar::new(binder, i).to_lifetime(Interner).cast(Interner)),\n+        chalk_ir::VariableKind::Const(ty) => find_var(iv)\n+            .map_or(default, |i| BoundVar::new(binder, i).to_const(Interner, ty).cast(Interner)),\n+    };\n+    // FIXME also map the types in the adjustments\n+    Ok((adjustments, table.resolve_with_fallback(ty, &fallback)))\n+}\n+\n impl<'a> InferenceContext<'a> {\n     /// Unify two types, but may coerce the first one to the second one\n     /// using \"implicit coercion rules\" if needed.\n@@ -126,16 +168,31 @@ impl<'a> InferenceContext<'a> {\n         expr: Option<ExprId>,\n         from_ty: &Ty,\n         to_ty: &Ty,\n-    ) -> InferResult<Ty> {\n+    ) -> Result<Ty, TypeError> {\n+        let from_ty = self.resolve_ty_shallow(from_ty);\n+        let to_ty = self.resolve_ty_shallow(to_ty);\n+        let (adjustments, ty) = self.table.coerce(&from_ty, &to_ty)?;\n+        if let Some(expr) = expr {\n+            self.write_expr_adj(expr, adjustments);\n+        }\n+        Ok(ty)\n+    }\n+}\n+\n+impl<'a> InferenceTable<'a> {\n+    /// Unify two types, but may coerce the first one to the second one\n+    /// using \"implicit coercion rules\" if needed.\n+    pub(crate) fn coerce(\n+        &mut self,\n+        from_ty: &Ty,\n+        to_ty: &Ty,\n+    ) -> Result<(Vec<Adjustment>, Ty), TypeError> {\n         let from_ty = self.resolve_ty_shallow(from_ty);\n         let to_ty = self.resolve_ty_shallow(to_ty);\n         match self.coerce_inner(from_ty, &to_ty) {\n             Ok(InferOk { value: (adjustments, ty), goals }) => {\n-                if let Some(expr) = expr {\n-                    self.write_expr_adj(expr, adjustments);\n-                }\n-                self.table.register_infer_ok(InferOk { value: (), goals });\n-                Ok(InferOk { value: ty, goals: Vec::new() })\n+                self.register_infer_ok(InferOk { value: (), goals });\n+                Ok((adjustments, ty))\n             }\n             Err(e) => {\n                 // FIXME deal with error\n@@ -154,7 +211,7 @@ impl<'a> InferenceContext<'a> {\n             //\n             // here, we would coerce from `!` to `?T`.\n             if let TyKind::InferenceVar(tv, TyVariableKind::General) = to_ty.kind(Interner) {\n-                self.table.set_diverging(*tv, true);\n+                self.set_diverging(*tv, true);\n             }\n             return success(simple(Adjust::NeverToAny)(to_ty.clone()), to_ty.clone(), vec![]);\n         }\n@@ -203,8 +260,7 @@ impl<'a> InferenceContext<'a> {\n     where\n         F: FnOnce(Ty) -> Vec<Adjustment>,\n     {\n-        self.table\n-            .try_unify(t1, t2)\n+        self.try_unify(t1, t2)\n             .and_then(|InferOk { goals, .. }| success(f(t1.clone()), t1.clone(), goals))\n     }\n \n@@ -259,9 +315,9 @@ impl<'a> InferenceContext<'a> {\n         // details of coercion errors though, so I think it's useful to leave\n         // the structure like it is.\n \n-        let snapshot = self.table.snapshot();\n+        let snapshot = self.snapshot();\n \n-        let mut autoderef = Autoderef::new(&mut self.table, from_ty.clone());\n+        let mut autoderef = Autoderef::new(self, from_ty.clone());\n         let mut first_error = None;\n         let mut found = None;\n \n@@ -317,7 +373,7 @@ impl<'a> InferenceContext<'a> {\n         let InferOk { value: ty, goals } = match found {\n             Some(d) => d,\n             None => {\n-                self.table.rollback_to(snapshot);\n+                self.rollback_to(snapshot);\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n                 return Err(err);\n             }\n@@ -513,7 +569,7 @@ impl<'a> InferenceContext<'a> {\n         let coerce_from =\n             reborrow.as_ref().map_or_else(|| from_ty.clone(), |(_, adj)| adj.target.clone());\n \n-        let krate = self.resolver.krate().unwrap();\n+        let krate = self.trait_env.krate;\n         let coerce_unsized_trait =\n             match self.db.lang_item(krate, SmolStr::new_inline(\"coerce_unsized\")) {\n                 Some(LangItemTarget::TraitId(trait_)) => trait_,\n@@ -546,7 +602,7 @@ impl<'a> InferenceContext<'a> {\n         match solution {\n             Solution::Unique(v) => {\n                 canonicalized.apply_solution(\n-                    &mut self.table,\n+                    self,\n                     Canonical {\n                         binders: v.binders,\n                         // FIXME handle constraints\n@@ -556,7 +612,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Solution::Ambig(Guidance::Definite(subst)) => {\n                 // FIXME need to record an obligation here\n-                canonicalized.apply_solution(&mut self.table, subst)\n+                canonicalized.apply_solution(self, subst)\n             }\n             // FIXME actually we maybe should also accept unknown guidance here\n             _ => return Err(TypeError),"}, {"sha": "43cff92f233adb49cc061ccfb437aded9bd598b2", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 69, "deletions": 7, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -28,7 +28,7 @@ use crate::{\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n-    mapping::from_chalk,\n+    mapping::{from_chalk, ToChalk},\n     method_resolution,\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n@@ -67,7 +67,7 @@ impl<'a> InferenceContext<'a> {\n         let ty = self.infer_expr_inner(expr, expected);\n         if let Some(target) = expected.only_has_type(&mut self.table) {\n             match self.coerce(Some(expr), &ty, &target) {\n-                Ok(res) => res.value,\n+                Ok(res) => res,\n                 Err(_) => {\n                     self.result\n                         .type_mismatches\n@@ -279,21 +279,24 @@ impl<'a> InferenceContext<'a> {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let mut derefs = Autoderef::new(&mut self.table, callee_ty.clone());\n                 let mut res = None;\n+                let mut derefed_callee = callee_ty.clone();\n                 // manual loop to be able to access `derefs.table`\n                 while let Some((callee_deref_ty, _)) = derefs.next() {\n                     res = derefs.table.callable_sig(&callee_deref_ty, args.len());\n                     if res.is_some() {\n+                        derefed_callee = callee_deref_ty;\n                         break;\n                     }\n                 }\n-                let (param_tys, ret_ty): (Vec<Ty>, Ty) = match res {\n+                let (param_tys, ret_ty) = match res {\n                     Some(res) => {\n                         let adjustments = auto_deref_adjust_steps(&derefs);\n                         self.write_expr_adj(*callee, adjustments);\n                         res\n                     }\n                     None => (Vec::new(), self.err_ty()),\n                 };\n+                let indices_to_skip = self.check_legacy_const_generics(derefed_callee, args);\n                 self.register_obligations_for_call(&callee_ty);\n \n                 let expected_inputs = self.expected_inputs_for_expected_output(\n@@ -302,7 +305,7 @@ impl<'a> InferenceContext<'a> {\n                     param_tys.clone(),\n                 );\n \n-                self.check_call_arguments(args, &expected_inputs, &param_tys);\n+                self.check_call_arguments(args, &expected_inputs, &param_tys, &indices_to_skip);\n                 self.normalize_associated_types_in(ret_ty)\n             }\n             Expr::MethodCall { receiver, args, method_name, generic_args } => self\n@@ -952,7 +955,7 @@ impl<'a> InferenceContext<'a> {\n         let expected_inputs =\n             self.expected_inputs_for_expected_output(expected, ret_ty.clone(), param_tys.clone());\n \n-        self.check_call_arguments(args, &expected_inputs, &param_tys);\n+        self.check_call_arguments(args, &expected_inputs, &param_tys, &[]);\n         self.normalize_associated_types_in(ret_ty)\n     }\n \n@@ -983,24 +986,40 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    fn check_call_arguments(&mut self, args: &[ExprId], expected_inputs: &[Ty], param_tys: &[Ty]) {\n+    fn check_call_arguments(\n+        &mut self,\n+        args: &[ExprId],\n+        expected_inputs: &[Ty],\n+        param_tys: &[Ty],\n+        skip_indices: &[u32],\n+    ) {\n         // Quoting https://github.com/rust-lang/rust/blob/6ef275e6c3cb1384ec78128eceeb4963ff788dca/src/librustc_typeck/check/mod.rs#L3325 --\n         // We do this in a pretty awful way: first we type-check any arguments\n         // that are not closures, then we type-check the closures. This is so\n         // that we have more information about the types of arguments when we\n         // type-check the functions. This isn't really the right way to do this.\n         for &check_closures in &[false, true] {\n+            let mut skip_indices = skip_indices.into_iter().copied().fuse().peekable();\n             let param_iter = param_tys.iter().cloned().chain(repeat(self.err_ty()));\n             let expected_iter = expected_inputs\n                 .iter()\n                 .cloned()\n                 .chain(param_iter.clone().skip(expected_inputs.len()));\n-            for ((&arg, param_ty), expected_ty) in args.iter().zip(param_iter).zip(expected_iter) {\n+            for (idx, ((&arg, param_ty), expected_ty)) in\n+                args.iter().zip(param_iter).zip(expected_iter).enumerate()\n+            {\n                 let is_closure = matches!(&self.body[arg], Expr::Lambda { .. });\n                 if is_closure != check_closures {\n                     continue;\n                 }\n \n+                while skip_indices.peek().map_or(false, |i| *i < idx as u32) {\n+                    skip_indices.next();\n+                }\n+                if skip_indices.peek().copied() == Some(idx as u32) {\n+                    continue;\n+                }\n+\n                 // the difference between param_ty and expected here is that\n                 // expected is the parameter when the expected *return* type is\n                 // taken into account. So in `let _: &[i32] = identity(&[1, 2])`\n@@ -1140,6 +1159,49 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n+    /// Returns the argument indices to skip.\n+    fn check_legacy_const_generics(&mut self, callee: Ty, args: &[ExprId]) -> Vec<u32> {\n+        let (func, subst) = match callee.kind(Interner) {\n+            TyKind::FnDef(fn_id, subst) => {\n+                let callable = CallableDefId::from_chalk(self.db, *fn_id);\n+                let func = match callable {\n+                    CallableDefId::FunctionId(f) => f,\n+                    _ => return Vec::new(),\n+                };\n+                (func, subst)\n+            }\n+            _ => return Vec::new(),\n+        };\n+\n+        let data = self.db.function_data(func);\n+        if data.legacy_const_generics_indices.is_empty() {\n+            return Vec::new();\n+        }\n+\n+        // only use legacy const generics if the param count matches with them\n+        if data.params.len() + data.legacy_const_generics_indices.len() != args.len() {\n+            return Vec::new();\n+        }\n+\n+        // check legacy const parameters\n+        for (subst_idx, arg_idx) in data.legacy_const_generics_indices.iter().copied().enumerate() {\n+            let arg = match subst.at(Interner, subst_idx).constant(Interner) {\n+                Some(c) => c,\n+                None => continue, // not a const parameter?\n+            };\n+            if arg_idx >= args.len() as u32 {\n+                continue;\n+            }\n+            let _ty = arg.data(Interner).ty.clone();\n+            let expected = Expectation::none(); // FIXME use actual const ty, when that is lowered correctly\n+            self.infer_expr(args[arg_idx as usize], &expected);\n+            // FIXME: evaluate and unify with the const\n+        }\n+        let mut indices = data.legacy_const_generics_indices.clone();\n+        indices.sort();\n+        indices\n+    }\n+\n     fn builtin_binary_op_return_ty(&mut self, op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Option<Ty> {\n         let lhs_ty = self.resolve_ty_shallow(&lhs_ty);\n         let rhs_ty = self.resolve_ty_shallow(&rhs_ty);"}, {"sha": "84ca1660afb139f9325f8c7447c34279d94a864a", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -3,8 +3,8 @@\n use std::{fmt, mem, sync::Arc};\n \n use chalk_ir::{\n-    cast::Cast, fold::Fold, interner::HasInterner, zip::Zip, FloatTy, IntTy, NoSolution,\n-    TyVariableKind, UniverseIndex,\n+    cast::Cast, fold::Fold, interner::HasInterner, zip::Zip, CanonicalVarKind, FloatTy, IntTy,\n+    NoSolution, TyVariableKind, UniverseIndex,\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n@@ -299,11 +299,23 @@ impl<'a> InferenceTable<'a> {\n         self.resolve_with_fallback_inner(&mut Vec::new(), t, &fallback)\n     }\n \n+    pub(crate) fn fresh_subst(&mut self, binders: &[CanonicalVarKind<Interner>]) -> Substitution {\n+        Substitution::from_iter(\n+            Interner,\n+            binders.iter().map(|kind| {\n+                let param_infer_var =\n+                    kind.map_ref(|&ui| self.var_unification_table.new_variable(ui));\n+                param_infer_var.to_generic_arg(Interner)\n+            }),\n+        )\n+    }\n+\n     pub(crate) fn instantiate_canonical<T>(&mut self, canonical: Canonical<T>) -> T::Result\n     where\n         T: HasInterner<Interner = Interner> + Fold<Interner> + std::fmt::Debug,\n     {\n-        self.var_unification_table.instantiate_canonical(Interner, canonical)\n+        let subst = self.fresh_subst(canonical.binders.as_slice(Interner));\n+        subst.apply(canonical.value, Interner)\n     }\n \n     fn resolve_with_fallback_inner<T>("}, {"sha": "945b4b0e4a6aee603dc2e31df944367eea775438", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -51,7 +51,7 @@ pub use autoderef::autoderef;\n pub use builder::{ParamKind, TyBuilder};\n pub use chalk_ext::*;\n pub use infer::{\n-    could_unify, Adjust, Adjustment, AutoBorrow, InferenceDiagnostic, InferenceResult,\n+    could_coerce, could_unify, Adjust, Adjustment, AutoBorrow, InferenceDiagnostic, InferenceResult,\n };\n pub use interner::Interner;\n pub use lower::{"}, {"sha": "de27c294f61937375fd69f66f725f6490bac9131", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -1,6 +1,6 @@\n use expect_test::expect;\n \n-use super::{check_infer, check_types};\n+use super::{check_infer, check_no_mismatches, check_types};\n \n #[test]\n fn infer_box() {\n@@ -2624,3 +2624,21 @@ pub mod prelude {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn legacy_const_generics() {\n+    check_no_mismatches(\n+        r#\"\n+#[rustc_legacy_const_generics(1, 3)]\n+fn mixed<const N1: &'static str, const N2: bool>(\n+    a: u8,\n+    b: i8,\n+) {}\n+\n+fn f() {\n+    mixed(0, \"\", -1, true);\n+    mixed::<\"\", true>(0, -1);\n+}\n+    \"#,\n+    );\n+}"}, {"sha": "db24fd6cce368e3e89d0fd03ecb32cf7421a79a9", "filename": "crates/ide_diagnostics/src/handlers/add_reference_here.rs", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/754d8687f4952e0dca50eca95aded4cf58a07fdf/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fadd_reference_here.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754d8687f4952e0dca50eca95aded4cf58a07fdf/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fadd_reference_here.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fadd_reference_here.rs?ref=754d8687f4952e0dca50eca95aded4cf58a07fdf", "patch": "@@ -1,163 +0,0 @@\n-use hir::db::AstDatabase;\n-use ide_db::source_change::SourceChange;\n-use syntax::AstNode;\n-use text_edit::TextEdit;\n-\n-use crate::{fix, Assist, Diagnostic, DiagnosticsContext};\n-\n-// Diagnostic: add-reference-here\n-//\n-// This diagnostic is triggered when there's a missing referencing of expression.\n-pub(crate) fn add_reference_here(\n-    ctx: &DiagnosticsContext<'_>,\n-    d: &hir::AddReferenceHere,\n-) -> Diagnostic {\n-    Diagnostic::new(\n-        \"add-reference-here\",\n-        \"add reference here\",\n-        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n-    )\n-    .with_fixes(fixes(ctx, d))\n-}\n-\n-fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::AddReferenceHere) -> Option<Vec<Assist>> {\n-    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let arg_expr = d.expr.value.to_node(&root);\n-\n-    let arg_with_ref = format!(\"&{}{}\", d.mutability.as_keyword_for_ref(), arg_expr.syntax());\n-\n-    let arg_range = arg_expr.syntax().text_range();\n-    let edit = TextEdit::replace(arg_range, arg_with_ref);\n-    let source_change =\n-        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n-\n-    Some(vec![fix(\"add_reference_here\", \"Add reference here\", source_change, arg_range)])\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::{check_diagnostics, check_fix};\n-\n-    #[test]\n-    fn missing_reference() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    test(123);\n-       //^^^ \ud83d\udca1 error: add reference here\n-}\n-fn test(arg: &i32) {}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_add_reference_to_int() {\n-        check_fix(\n-            r#\"\n-fn main() {\n-    test(123$0);\n-}\n-fn test(arg: &i32) {}\n-            \"#,\n-            r#\"\n-fn main() {\n-    test(&123);\n-}\n-fn test(arg: &i32) {}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_add_mutable_reference_to_int() {\n-        check_fix(\n-            r#\"\n-fn main() {\n-    test($0123);\n-}\n-fn test(arg: &mut i32) {}\n-            \"#,\n-            r#\"\n-fn main() {\n-    test(&mut 123);\n-}\n-fn test(arg: &mut i32) {}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_add_reference_to_array() {\n-        check_fix(\n-            r#\"\n-fn main() {\n-    test($0[1, 2, 3]);\n-}\n-fn test(arg: &[i32]) {}\n-            \"#,\n-            r#\"\n-fn main() {\n-    test(&[1, 2, 3]);\n-}\n-fn test(arg: &[i32]) {}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_add_reference_to_method_call() {\n-        check_fix(\n-            r#\"\n-fn main() {\n-    Test.call_by_ref($0123);\n-}\n-struct Test;\n-impl Test {\n-    fn call_by_ref(&self, arg: &i32) {}\n-}\n-            \"#,\n-            r#\"\n-fn main() {\n-    Test.call_by_ref(&123);\n-}\n-struct Test;\n-impl Test {\n-    fn call_by_ref(&self, arg: &i32) {}\n-}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_add_reference_to_let_stmt() {\n-        check_fix(\n-            r#\"\n-fn main() {\n-    let test: &i32 = $0123;\n-}\n-            \"#,\n-            r#\"\n-fn main() {\n-    let test: &i32 = &123;\n-}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_add_mutable_reference_to_let_stmt() {\n-        check_fix(\n-            r#\"\n-fn main() {\n-    let test: &mut i32 = $0123;\n-}\n-            \"#,\n-            r#\"\n-fn main() {\n-    let test: &mut i32 = &mut 123;\n-}\n-            \"#,\n-        );\n-    }\n-}"}, {"sha": "2b7105362503859dc9a5177290dadb6112863f8d", "filename": "crates/ide_diagnostics/src/handlers/field_shorthand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ffield_shorthand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ffield_shorthand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ffield_shorthand.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -108,13 +108,13 @@ mod tests {\n         check_diagnostics(\n             r#\"\n struct A { a: &'static str }\n-fn main() { A { a: \"hello\" } }\n+fn main() { A { a: \"hello\" }; }\n \"#,\n         );\n         check_diagnostics(\n             r#\"\n struct A(usize);\n-fn main() { A { 0: 0 } }\n+fn main() { A { 0: 0 }; }\n \"#,\n         );\n \n@@ -123,14 +123,14 @@ fn main() { A { 0: 0 } }\n struct A { a: &'static str }\n fn main() {\n     let a = \"haha\";\n-    A { a$0: a }\n+    A { a$0: a };\n }\n \"#,\n             r#\"\n struct A { a: &'static str }\n fn main() {\n     let a = \"haha\";\n-    A { a }\n+    A { a };\n }\n \"#,\n         );\n@@ -141,15 +141,15 @@ struct A { a: &'static str, b: &'static str }\n fn main() {\n     let a = \"haha\";\n     let b = \"bb\";\n-    A { a$0: a, b }\n+    A { a$0: a, b };\n }\n \"#,\n             r#\"\n struct A { a: &'static str, b: &'static str }\n fn main() {\n     let a = \"haha\";\n     let b = \"bb\";\n-    A { a, b }\n+    A { a, b };\n }\n \"#,\n         );"}, {"sha": "fe6a8683c110df2624b5c3b2595dedb6735a1342", "filename": "crates/ide_diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -278,6 +278,7 @@ fn main() {\n     match (true, false) {\n         (true, false, true) => (),\n         (true) => (),\n+      // ^^^^  error: expected (bool, bool), found bool\n     }\n     match (true, false) { (true,) => {} }\n     match (0) { () => () }"}, {"sha": "d5635ba8baf355d93a85f0767873c7cf4235d4f3", "filename": "crates/ide_diagnostics/src/handlers/missing_ok_or_some_in_tail_expr.rs", "status": "removed", "additions": 0, "deletions": 223, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/754d8687f4952e0dca50eca95aded4cf58a07fdf/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754d8687f4952e0dca50eca95aded4cf58a07fdf/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs?ref=754d8687f4952e0dca50eca95aded4cf58a07fdf", "patch": "@@ -1,223 +0,0 @@\n-use hir::{db::AstDatabase, TypeInfo};\n-use ide_db::{\n-    assists::Assist, source_change::SourceChange, syntax_helpers::node_ext::for_each_tail_expr,\n-};\n-use syntax::AstNode;\n-use text_edit::TextEdit;\n-\n-use crate::{fix, Diagnostic, DiagnosticsContext};\n-\n-// Diagnostic: missing-ok-or-some-in-tail-expr\n-//\n-// This diagnostic is triggered if a block that should return `Result` returns a value not wrapped in `Ok`,\n-// or if a block that should return `Option` returns a value not wrapped in `Some`.\n-//\n-// Example:\n-//\n-// ```rust\n-// fn foo() -> Result<u8, ()> {\n-//     10\n-// }\n-// ```\n-pub(crate) fn missing_ok_or_some_in_tail_expr(\n-    ctx: &DiagnosticsContext<'_>,\n-    d: &hir::MissingOkOrSomeInTailExpr,\n-) -> Diagnostic {\n-    Diagnostic::new(\n-        \"missing-ok-or-some-in-tail-expr\",\n-        format!(\"wrap return expression in {}\", d.required),\n-        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n-    )\n-    .with_fixes(fixes(ctx, d))\n-}\n-\n-fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingOkOrSomeInTailExpr) -> Option<Vec<Assist>> {\n-    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let tail_expr = d.expr.value.to_node(&root);\n-    let tail_expr_range = tail_expr.syntax().text_range();\n-    let mut builder = TextEdit::builder();\n-    for_each_tail_expr(&tail_expr, &mut |expr| {\n-        if ctx.sema.type_of_expr(expr).map(TypeInfo::original).as_ref() != Some(&d.expected) {\n-            builder.insert(expr.syntax().text_range().start(), format!(\"{}(\", d.required));\n-            builder.insert(expr.syntax().text_range().end(), \")\".to_string());\n-        }\n-    });\n-    let source_change =\n-        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), builder.finish());\n-    let name = if d.required == \"Ok\" { \"Wrap with Ok\" } else { \"Wrap with Some\" };\n-    Some(vec![fix(\"wrap_tail_expr\", name, source_change, tail_expr_range)])\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::{check_diagnostics, check_fix};\n-\n-    #[test]\n-    fn test_wrap_return_type_option() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-fn div(x: i32, y: i32) -> Option<i32> {\n-    if y == 0 {\n-        return None;\n-    }\n-    x / y$0\n-}\n-\"#,\n-            r#\"\n-fn div(x: i32, y: i32) -> Option<i32> {\n-    if y == 0 {\n-        return None;\n-    }\n-    Some(x / y)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_option_tails() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-fn div(x: i32, y: i32) -> Option<i32> {\n-    if y == 0 {\n-        0\n-    } else if true {\n-        100\n-    } else {\n-        None\n-    }$0\n-}\n-\"#,\n-            r#\"\n-fn div(x: i32, y: i32) -> Option<i32> {\n-    if y == 0 {\n-        Some(0)\n-    } else if true {\n-        Some(100)\n-    } else {\n-        None\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-fn div(x: i32, y: i32) -> Result<i32, ()> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    x / y$0\n-}\n-\"#,\n-            r#\"\n-fn div(x: i32, y: i32) -> Result<i32, ()> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    Ok(x / y)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_handles_generic_functions() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-fn div<T>(x: T) -> Result<T, i32> {\n-    if x == 0 {\n-        return Err(7);\n-    }\n-    $0x\n-}\n-\"#,\n-            r#\"\n-fn div<T>(x: T) -> Result<T, i32> {\n-    if x == 0 {\n-        return Err(7);\n-    }\n-    Ok(x)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_handles_type_aliases() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-type MyResult<T> = Result<T, ()>;\n-\n-fn div(x: i32, y: i32) -> MyResult<i32> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    x $0/ y\n-}\n-\"#,\n-            r#\"\n-type MyResult<T> = Result<T, ()>;\n-\n-fn div(x: i32, y: i32) -> MyResult<i32> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    Ok(x / y)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_in_const_and_static() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-static A: Option<()> = {($0)};\n-            \"#,\n-            r#\"\n-static A: Option<()> = {Some(())};\n-            \"#,\n-        );\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-const _: Option<()> = {($0)};\n-            \"#,\n-            r#\"\n-const _: Option<()> = {Some(())};\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n-        check_diagnostics(\n-            r#\"\n-//- minicore: option, result\n-fn foo() -> Result<(), i32> { 0 }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_not_applicable_when_return_type_is_not_result_or_option() {\n-        check_diagnostics(\n-            r#\"\n-//- minicore: option, result\n-enum SomeOtherEnum { Ok(i32), Err(String) }\n-\n-fn foo() -> SomeOtherEnum { 0 }\n-\"#,\n-        );\n-    }\n-}"}, {"sha": "141fbc42fa56b5a78cf069dfbb2b86816287f37d", "filename": "crates/ide_diagnostics/src/handlers/remove_this_semicolon.rs", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/754d8687f4952e0dca50eca95aded4cf58a07fdf/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fremove_this_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754d8687f4952e0dca50eca95aded4cf58a07fdf/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fremove_this_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fremove_this_semicolon.rs?ref=754d8687f4952e0dca50eca95aded4cf58a07fdf", "patch": "@@ -1,76 +0,0 @@\n-use ide_db::{\n-    base_db::{FileLoader, FileRange},\n-    source_change::SourceChange,\n-};\n-use syntax::{TextRange, TextSize};\n-use text_edit::TextEdit;\n-\n-use crate::{fix, Assist, Diagnostic, DiagnosticsContext};\n-\n-// Diagnostic: remove-this-semicolon\n-//\n-// This diagnostic is triggered when there's an erroneous `;` at the end of the block.\n-pub(crate) fn remove_this_semicolon(\n-    ctx: &DiagnosticsContext<'_>,\n-    d: &hir::RemoveThisSemicolon,\n-) -> Diagnostic {\n-    Diagnostic::new(\n-        \"remove-this-semicolon\",\n-        \"remove this semicolon\",\n-        semicolon_range(ctx, d).unwrap_or_else(|it| it).range,\n-    )\n-    .with_fixes(fixes(ctx, d))\n-}\n-\n-fn semicolon_range(\n-    ctx: &DiagnosticsContext<'_>,\n-    d: &hir::RemoveThisSemicolon,\n-) -> Result<FileRange, FileRange> {\n-    let expr_range = ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into()));\n-    let file_text = ctx.sema.db.file_text(expr_range.file_id);\n-    let range_end: usize = expr_range.range.end().into();\n-    // FIXME: This doesn't handle whitespace and comments, but handling those in\n-    // the presence of macros might prove tricky...\n-    if file_text[range_end..].starts_with(';') {\n-        Ok(FileRange {\n-            file_id: expr_range.file_id,\n-            range: TextRange::at(expr_range.range.end(), TextSize::of(';')),\n-        })\n-    } else {\n-        Err(expr_range)\n-    }\n-}\n-\n-fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::RemoveThisSemicolon) -> Option<Vec<Assist>> {\n-    let semicolon_range = semicolon_range(ctx, d).ok()?;\n-\n-    let edit = TextEdit::delete(semicolon_range.range);\n-    let source_change = SourceChange::from_text_edit(semicolon_range.file_id, edit);\n-\n-    Some(vec![fix(\n-        \"remove_semicolon\",\n-        \"Remove this semicolon\",\n-        source_change,\n-        semicolon_range.range,\n-    )])\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::{check_diagnostics, check_fix};\n-\n-    #[test]\n-    fn missing_semicolon() {\n-        check_diagnostics(\n-            r#\"\n-fn test() -> i32 { 123; }\n-                    //^ \ud83d\udca1 error: remove this semicolon\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn remove_semicolon() {\n-        check_fix(r#\"fn f() -> i32 { 92$0; }\"#, r#\"fn f() -> i32 { 92 }\"#);\n-    }\n-}"}, {"sha": "040dcbd1d958cdb9128be2bdd1579825e444127b", "filename": "crates/ide_diagnostics/src/handlers/type_mismatch.rs", "status": "added", "additions": 476, "deletions": 0, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -0,0 +1,476 @@\n+use hir::{db::AstDatabase, HirDisplay, Type, TypeInfo};\n+use ide_db::{\n+    famous_defs::FamousDefs, source_change::SourceChange,\n+    syntax_helpers::node_ext::for_each_tail_expr,\n+};\n+use syntax::{\n+    ast::{BlockExpr, ExprStmt},\n+    AstNode,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::{fix, Assist, Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: type-mismatch\n+//\n+// This diagnostic is triggered when the type of an expression does not match\n+// the expected type.\n+pub(crate) fn type_mismatch(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Diagnostic {\n+    let mut diag = Diagnostic::new(\n+        \"type-mismatch\",\n+        format!(\n+            \"expected {}, found {}\",\n+            d.expected.display(ctx.sema.db),\n+            d.actual.display(ctx.sema.db)\n+        ),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d));\n+    if diag.fixes.is_none() {\n+        diag.experimental = true;\n+    }\n+    diag\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Option<Vec<Assist>> {\n+    let mut fixes = Vec::new();\n+\n+    add_reference(ctx, d, &mut fixes);\n+    add_missing_ok_or_some(ctx, d, &mut fixes);\n+    remove_semicolon(ctx, d, &mut fixes);\n+\n+    if fixes.is_empty() {\n+        None\n+    } else {\n+        Some(fixes)\n+    }\n+}\n+\n+fn add_reference(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::TypeMismatch,\n+    acc: &mut Vec<Assist>,\n+) -> Option<()> {\n+    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n+    let expr_node = d.expr.value.to_node(&root);\n+\n+    let range = ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range;\n+\n+    let (_, mutability) = d.expected.as_reference()?;\n+    let actual_with_ref = Type::reference(&d.actual, mutability);\n+    if !actual_with_ref.could_coerce_to(ctx.sema.db, &d.expected) {\n+        return None;\n+    }\n+\n+    let ampersands = format!(\"&{}\", mutability.as_keyword_for_ref());\n+\n+    let edit = TextEdit::insert(expr_node.syntax().text_range().start(), ampersands);\n+    let source_change =\n+        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+    acc.push(fix(\"add_reference_here\", \"Add reference here\", source_change, range));\n+    Some(())\n+}\n+\n+fn add_missing_ok_or_some(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::TypeMismatch,\n+    acc: &mut Vec<Assist>,\n+) -> Option<()> {\n+    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n+    let tail_expr = d.expr.value.to_node(&root);\n+    let tail_expr_range = tail_expr.syntax().text_range();\n+    let scope = ctx.sema.scope(tail_expr.syntax());\n+\n+    let expected_adt = d.expected.as_adt()?;\n+    let expected_enum = expected_adt.as_enum()?;\n+\n+    let famous_defs = FamousDefs(&ctx.sema, scope.krate());\n+    let core_result = famous_defs.core_result_Result();\n+    let core_option = famous_defs.core_option_Option();\n+\n+    if Some(expected_enum) != core_result && Some(expected_enum) != core_option {\n+        return None;\n+    }\n+\n+    let variant_name = if Some(expected_enum) == core_result { \"Ok\" } else { \"Some\" };\n+\n+    let wrapped_actual_ty = expected_adt.ty_with_args(ctx.sema.db, &[d.actual.clone()]);\n+\n+    if !d.expected.could_unify_with(ctx.sema.db, &wrapped_actual_ty) {\n+        return None;\n+    }\n+\n+    let mut builder = TextEdit::builder();\n+    for_each_tail_expr(&tail_expr, &mut |expr| {\n+        if ctx.sema.type_of_expr(expr).map(TypeInfo::adjusted).as_ref() != Some(&d.expected) {\n+            builder.insert(expr.syntax().text_range().start(), format!(\"{}(\", variant_name));\n+            builder.insert(expr.syntax().text_range().end(), \")\".to_string());\n+        }\n+    });\n+    let source_change =\n+        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), builder.finish());\n+    let name = format!(\"Wrap in {}\", variant_name);\n+    acc.push(fix(\"wrap_tail_expr\", &name, source_change, tail_expr_range));\n+    Some(())\n+}\n+\n+fn remove_semicolon(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::TypeMismatch,\n+    acc: &mut Vec<Assist>,\n+) -> Option<()> {\n+    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n+    let expr = d.expr.value.to_node(&root);\n+    if !d.actual.is_unit() {\n+        return None;\n+    }\n+    let block = BlockExpr::cast(expr.syntax().clone())?;\n+    let expr_before_semi =\n+        block.statements().last().and_then(|s| ExprStmt::cast(s.syntax().clone()))?;\n+    let type_before_semi = ctx.sema.type_of_expr(&expr_before_semi.expr()?)?.original();\n+    if !type_before_semi.could_coerce_to(ctx.sema.db, &d.expected) {\n+        return None;\n+    }\n+    let semicolon_range = expr_before_semi.semicolon_token()?.text_range();\n+\n+    let edit = TextEdit::delete(semicolon_range);\n+    let source_change =\n+        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+\n+    acc.push(fix(\"remove_semicolon\", \"Remove this semicolon\", source_change, semicolon_range));\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_diagnostics, check_fix, check_no_fix};\n+\n+    #[test]\n+    fn missing_reference() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    test(123);\n+       //^^^ \ud83d\udca1 error: expected &i32, found i32\n+}\n+fn test(arg: &i32) {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_reference_to_int() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    test(123$0);\n+}\n+fn test(arg: &i32) {}\n+            \"#,\n+            r#\"\n+fn main() {\n+    test(&123);\n+}\n+fn test(arg: &i32) {}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_mutable_reference_to_int() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    test($0123);\n+}\n+fn test(arg: &mut i32) {}\n+            \"#,\n+            r#\"\n+fn main() {\n+    test(&mut 123);\n+}\n+fn test(arg: &mut i32) {}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_reference_to_array() {\n+        check_fix(\n+            r#\"\n+//- minicore: coerce_unsized\n+fn main() {\n+    test($0[1, 2, 3]);\n+}\n+fn test(arg: &[i32]) {}\n+            \"#,\n+            r#\"\n+fn main() {\n+    test(&[1, 2, 3]);\n+}\n+fn test(arg: &[i32]) {}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_reference_with_autoderef() {\n+        check_fix(\n+            r#\"\n+//- minicore: coerce_unsized, deref\n+struct Foo;\n+struct Bar;\n+impl core::ops::Deref for Foo {\n+    type Target = Bar;\n+}\n+\n+fn main() {\n+    test($0Foo);\n+}\n+fn test(arg: &Bar) {}\n+            \"#,\n+            r#\"\n+struct Foo;\n+struct Bar;\n+impl core::ops::Deref for Foo {\n+    type Target = Bar;\n+}\n+\n+fn main() {\n+    test(&Foo);\n+}\n+fn test(arg: &Bar) {}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_reference_to_method_call() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    Test.call_by_ref($0123);\n+}\n+struct Test;\n+impl Test {\n+    fn call_by_ref(&self, arg: &i32) {}\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    Test.call_by_ref(&123);\n+}\n+struct Test;\n+impl Test {\n+    fn call_by_ref(&self, arg: &i32) {}\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_reference_to_let_stmt() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    let test: &i32 = $0123;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let test: &i32 = &123;\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_mutable_reference_to_let_stmt() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    let test: &mut i32 = $0123;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let test: &mut i32 = &mut 123;\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_option() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+fn div(x: i32, y: i32) -> Option<i32> {\n+    if y == 0 {\n+        return None;\n+    }\n+    x / y$0\n+}\n+\"#,\n+            r#\"\n+fn div(x: i32, y: i32) -> Option<i32> {\n+    if y == 0 {\n+        return None;\n+    }\n+    Some(x / y)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_option_tails() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+fn div(x: i32, y: i32) -> Option<i32> {\n+    if y == 0 {\n+        0\n+    } else if true {\n+        100\n+    } else {\n+        None\n+    }$0\n+}\n+\"#,\n+            r#\"\n+fn div(x: i32, y: i32) -> Option<i32> {\n+    if y == 0 {\n+        Some(0)\n+    } else if true {\n+        Some(100)\n+    } else {\n+        None\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+fn div(x: i32, y: i32) -> Result<i32, ()> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    x / y$0\n+}\n+\"#,\n+            r#\"\n+fn div(x: i32, y: i32) -> Result<i32, ()> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    Ok(x / y)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_handles_generic_functions() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+fn div<T>(x: T) -> Result<T, i32> {\n+    if x == 0 {\n+        return Err(7);\n+    }\n+    $0x\n+}\n+\"#,\n+            r#\"\n+fn div<T>(x: T) -> Result<T, i32> {\n+    if x == 0 {\n+        return Err(7);\n+    }\n+    Ok(x)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_handles_type_aliases() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+type MyResult<T> = Result<T, ()>;\n+\n+fn div(x: i32, y: i32) -> MyResult<i32> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    x $0/ y\n+}\n+\"#,\n+            r#\"\n+type MyResult<T> = Result<T, ()>;\n+\n+fn div(x: i32, y: i32) -> MyResult<i32> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    Ok(x / y)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_in_const_and_static() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+static A: Option<()> = {($0)};\n+            \"#,\n+            r#\"\n+static A: Option<()> = {Some(())};\n+            \"#,\n+        );\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+const _: Option<()> = {($0)};\n+            \"#,\n+            r#\"\n+const _: Option<()> = {Some(())};\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n+        check_no_fix(\n+            r#\"\n+//- minicore: option, result\n+fn foo() -> Result<(), i32> { 0$0 }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_not_applicable_when_return_type_is_not_result_or_option() {\n+        check_no_fix(\n+            r#\"\n+//- minicore: option, result\n+enum SomeOtherEnum { Ok(i32), Err(String) }\n+\n+fn foo() -> SomeOtherEnum { 0$0 }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_semicolon() {\n+        check_fix(r#\"fn f() -> i32 { 92$0; }\"#, r#\"fn f() -> i32 { 92 }\"#);\n+    }\n+}"}, {"sha": "13ac0a245021317515a68d177bd5b45ee1a1c532", "filename": "crates/ide_diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fide_diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2cd18765abb681cacc2a57aebde13fa1dc32c1/crates%2Fide_diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Flib.rs?ref=5d2cd18765abb681cacc2a57aebde13fa1dc32c1", "patch": "@@ -24,7 +24,6 @@\n //! don't yet have a great pattern for how to do them properly.\n \n mod handlers {\n-    pub(crate) mod add_reference_here;\n     pub(crate) mod break_outside_of_loop;\n     pub(crate) mod inactive_code;\n     pub(crate) mod incorrect_case;\n@@ -34,11 +33,10 @@ mod handlers {\n     pub(crate) mod mismatched_arg_count;\n     pub(crate) mod missing_fields;\n     pub(crate) mod missing_match_arms;\n-    pub(crate) mod missing_ok_or_some_in_tail_expr;\n     pub(crate) mod missing_unsafe;\n     pub(crate) mod no_such_field;\n-    pub(crate) mod remove_this_semicolon;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n+    pub(crate) mod type_mismatch;\n     pub(crate) mod unimplemented_builtin_macro;\n     pub(crate) mod unresolved_extern_crate;\n     pub(crate) mod unresolved_import;\n@@ -191,19 +189,17 @@ pub fn diagnostics(\n     for diag in diags {\n         #[rustfmt::skip]\n         let d = match diag {\n-            AnyDiagnostic::AddReferenceHere(d) => handlers::add_reference_here::add_reference_here(&ctx, &d),\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => handlers::missing_fields::missing_fields(&ctx, &d),\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n-            AnyDiagnostic::MissingOkOrSomeInTailExpr(d) => handlers::missing_ok_or_some_in_tail_expr::missing_ok_or_some_in_tail_expr(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n-            AnyDiagnostic::RemoveThisSemicolon(d) => handlers::remove_this_semicolon::remove_this_semicolon(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n+            AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),\n             AnyDiagnostic::UnimplementedBuiltinMacro(d) => handlers::unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n             AnyDiagnostic::UnresolvedExternCrate(d) => handlers::unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n             AnyDiagnostic::UnresolvedImport(d) => handlers::unresolved_import::unresolved_import(&ctx, &d),"}]}