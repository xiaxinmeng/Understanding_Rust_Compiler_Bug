{"sha": "67776ba3dab24a3e281931da437d30ccfc3b04c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3Nzc2YmEzZGFiMjRhM2UyODE5MzFkYTQzN2QzMGNjZmMzYjA0YzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-03T01:06:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-03T01:06:38Z"}, "message": "auto merge of #15325 : pcwalton/rust/trait-impl-bound-mismatch, r=pnkfelix\n\nwith the corresponding trait parameter bounds.\r\n\r\nThis is a version of the patch in PR #12611 by Florian Hahn, modified to\r\naddress Niko's feedback.\r\n\r\nIt does not address the issue of duplicate type parameter bounds, nor\r\ndoes it address the issue of implementation-defined methods that contain\r\n*fewer* bounds than the trait, because Niko's review indicates that this\r\nshould not be necessary (and indeed I believe it is not). A test has\r\nbeen added to ensure that this works.\r\n\r\nThis will break code like:\r\n\r\n    trait Foo {\r\n        fn bar<T:Baz>();\r\n    }\r\n\r\n    impl Foo for Boo {\r\n        fn bar<T:Baz + Quux>() { ... }\r\n        //             ^~~~ ERROR\r\n    }\r\n\r\nThis will be rejected because the implementation requires *more* bounds\r\nthan the trait. It can be fixed by either adding the missing bound to\r\nthe trait:\r\n\r\n    trait Foo {\r\n        fn bar<T:Baz + Quux>();\r\n        //             ^~~~\r\n    }\r\n\r\n    impl Foo for Boo {\r\n        fn bar<T:Baz + Quux>() { ... }  // OK\r\n    }\r\n\r\nOr by removing the bound from the impl:\r\n\r\n    trait Foo {\r\n        fn bar<T:Baz>();\r\n    }\r\n\r\n    impl Foo for Boo {\r\n        fn bar<T:Baz>() { ... }  // OK\r\n        //       ^ remove Quux\r\n    }\r\n\r\nThis patch imports the relevant tests from #2687, as well as the test\r\ncase in #5886, which is fixed as well by this patch.\r\n\r\nCloses #2687.\r\nCloses #5886.\r\n\r\n[breaking-change]\r\n\r\nr? @pnkfelix", "tree": {"sha": "ff463fd21bdea1f9c6f3b0e2d81962c73afc90b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff463fd21bdea1f9c6f3b0e2d81962c73afc90b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67776ba3dab24a3e281931da437d30ccfc3b04c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67776ba3dab24a3e281931da437d30ccfc3b04c1", "html_url": "https://github.com/rust-lang/rust/commit/67776ba3dab24a3e281931da437d30ccfc3b04c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67776ba3dab24a3e281931da437d30ccfc3b04c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8ae065182d19a098aa397fddcb4f4f4eccc0b32", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ae065182d19a098aa397fddcb4f4f4eccc0b32", "html_url": "https://github.com/rust-lang/rust/commit/c8ae065182d19a098aa397fddcb4f4f4eccc0b32"}, {"sha": "e56dbad9f7c3691bcb12edfaeda5cb3b660496de", "url": "https://api.github.com/repos/rust-lang/rust/commits/e56dbad9f7c3691bcb12edfaeda5cb3b660496de", "html_url": "https://github.com/rust-lang/rust/commit/e56dbad9f7c3691bcb12edfaeda5cb3b660496de"}], "stats": {"total": 243, "additions": 200, "deletions": 43}, "files": [{"sha": "f5e34e9307764944b73ff9457acb678b2970fa36", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 64, "deletions": 43, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/67776ba3dab24a3e281931da437d30ccfc3b04c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67776ba3dab24a3e281931da437d30ccfc3b04c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=67776ba3dab24a3e281931da437d30ccfc3b04c1", "patch": "@@ -920,49 +920,6 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     let it = trait_m.generics.types.get_vec(subst::FnSpace).iter()\n         .zip(impl_m.generics.types.get_vec(subst::FnSpace).iter());\n \n-    for (i, (trait_param_def, impl_param_def)) in it.enumerate() {\n-        // Check that the impl does not require any builtin-bounds\n-        // that the trait does not guarantee:\n-        let extra_bounds =\n-            impl_param_def.bounds.builtin_bounds -\n-            trait_param_def.bounds.builtin_bounds;\n-        if !extra_bounds.is_empty() {\n-           tcx.sess.span_err(\n-               impl_m_span,\n-               format!(\"in method `{}`, \\\n-                       type parameter {} requires `{}`, \\\n-                       which is not required by \\\n-                       the corresponding type parameter \\\n-                       in the trait declaration\",\n-                       token::get_ident(trait_m.ident),\n-                       i,\n-                       extra_bounds.user_string(tcx)).as_slice());\n-           return;\n-        }\n-\n-        // FIXME(#2687)---we should be checking that the bounds of the\n-        // trait imply the bounds of the subtype, but it appears we\n-        // are...not checking this.\n-        if impl_param_def.bounds.trait_bounds.len() !=\n-            trait_param_def.bounds.trait_bounds.len()\n-        {\n-            let found = impl_param_def.bounds.trait_bounds.len();\n-            let expected =  trait_param_def.bounds.trait_bounds.len();\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"in method `{}`, type parameter {} has {} trait \\\n-                         bound{}, but the corresponding type parameter in \\\n-                         the trait declaration has {} trait bound{}\",\n-                        token::get_ident(trait_m.ident),\n-                        i,\n-                        found,\n-                        if found == 1 {\"\"} else {\"s\"},\n-                        expected,\n-                        if expected == 1 {\"\"} else {\"s\"}).as_slice());\n-            return;\n-        }\n-    }\n-\n     // This code is best explained by example. Consider a trait:\n     //\n     //     trait Trait<T> {\n@@ -1037,6 +994,70 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n+    // Check bounds.\n+    for (i, (trait_param_def, impl_param_def)) in it.enumerate() {\n+        // Check that the impl does not require any builtin-bounds\n+        // that the trait does not guarantee:\n+        let extra_bounds =\n+            impl_param_def.bounds.builtin_bounds -\n+            trait_param_def.bounds.builtin_bounds;\n+        if !extra_bounds.is_empty() {\n+           tcx.sess.span_err(\n+               impl_m_span,\n+               format!(\"in method `{}`, \\\n+                       type parameter {} requires `{}`, \\\n+                       which is not required by \\\n+                       the corresponding type parameter \\\n+                       in the trait declaration\",\n+                       token::get_ident(trait_m.ident),\n+                       i,\n+                       extra_bounds.user_string(tcx)).as_slice());\n+           return;\n+        }\n+\n+        // Check that the trait bounds of the trait imply the bounds of its\n+        // implementation.\n+        //\n+        // FIXME(pcwalton): We could be laxer here regarding sub- and super-\n+        // traits, but I doubt that'll be wanted often, so meh.\n+        for impl_trait_bound in impl_param_def.bounds.trait_bounds.iter() {\n+            let impl_trait_bound =\n+                impl_trait_bound.subst(tcx, &impl_to_skol_substs);\n+\n+            let mut ok = false;\n+            for trait_bound in trait_param_def.bounds.trait_bounds.iter() {\n+                let trait_bound =\n+                    trait_bound.subst(tcx, &trait_to_skol_substs);\n+                let infcx = infer::new_infer_ctxt(tcx);\n+                match infer::mk_sub_trait_refs(&infcx,\n+                                               true,\n+                                               infer::Misc(impl_m_span),\n+                                               trait_bound,\n+                                               impl_trait_bound.clone()) {\n+                    Ok(_) => {\n+                        ok = true;\n+                        break\n+                    }\n+                    Err(_) => continue,\n+                }\n+            }\n+\n+            if !ok {\n+                tcx.sess.span_err(impl_m_span,\n+                                  format!(\"in method `{}`, type parameter {} \\\n+                                           requires bound `{}`, which is not \\\n+                                           required by the corresponding \\\n+                                           type parameter in the trait \\\n+                                           declaration\",\n+                                          token::get_ident(trait_m.ident),\n+                                          i,\n+                                          ppaux::trait_ref_to_str(\n+                                              tcx,\n+                                              &*impl_trait_bound)).as_slice())\n+            }\n+        }\n+    }\n+\n     // Check the impl method type IM is a subtype of the trait method\n     // type TM. To see why this makes sense, think of a vtable. The\n     // expected type of the function pointers in the vtable is the"}, {"sha": "eec116855c98662c6f3466aab5c17ecfd6809d05", "filename": "src/test/compile-fail/trait-bounds-impl-comparison-1.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/67776ba3dab24a3e281931da437d30ccfc3b04c1/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67776ba3dab24a3e281931da437d30ccfc3b04c1/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs?ref=67776ba3dab24a3e281931da437d30ccfc3b04c1", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Make sure rustc checks the type parameter bounds in implementations of traits,\n+// see #2687\n+\n+trait A {}\n+\n+trait B: A {}\n+\n+trait C: A {}\n+\n+trait Foo {\n+    fn test_error1_fn<T: Eq>(&self);\n+    fn test_error2_fn<T: Eq + Ord>(&self);\n+    fn test_error3_fn<T: Eq + Ord>(&self);\n+    fn test3_fn<T: Eq + Ord>(&self);\n+    fn test4_fn<T: Eq + Ord>(&self);\n+    fn test_error5_fn<T: A>(&self);\n+    fn test6_fn<T: A + Eq>(&self);\n+    fn test_error7_fn<T: A>(&self);\n+    fn test_error8_fn<T: B>(&self);\n+}\n+\n+impl Foo for int {\n+    // invalid bound for T, was defined as Eq in trait\n+    fn test_error1_fn<T: Ord>(&self) {}\n+    //~^ ERROR in method `test_error1_fn`, type parameter 0 requires bound `core::cmp::Ord`\n+\n+    // invalid bound for T, was defined as Eq + Ord in trait\n+    fn test_error2_fn<T: Eq + B>(&self) {}\n+    //~^ ERROR in method `test_error2_fn`, type parameter 0 requires bound `B`\n+\n+    // invalid bound for T, was defined as Eq + Ord in trait\n+    fn test_error3_fn<T: B + Eq>(&self) {}\n+    //~^ ERROR in method `test_error3_fn`, type parameter 0 requires bound `B`\n+\n+    // multiple bounds, same order as in trait\n+    fn test3_fn<T: Ord + Eq>(&self) {}\n+\n+    // multiple bounds, different order as in trait\n+    fn test4_fn<T: Eq + Ord>(&self) {}\n+\n+    // parameters in impls must be equal or more general than in the defining trait\n+    fn test_error5_fn<T: B>(&self) {}\n+    //~^ ERROR in method `test_error5_fn`, type parameter 0 requires bound `B`\n+\n+    // bound `std::cmp::Eq` not enforced by this implementation, but this is OK\n+    fn test6_fn<T: A>(&self) {}\n+\n+    fn test_error7_fn<T: A + Eq>(&self) {}\n+    //~^ ERROR in method `test_error7_fn`, type parameter 0 requires bound `core::cmp::Eq`\n+\n+    fn test_error8_fn<T: C>(&self) {}\n+    //~^ ERROR in method `test_error8_fn`, type parameter 0 requires bound `C`\n+}\n+\n+\n+trait Getter<T> { }\n+\n+trait Trait {\n+    fn method<G:Getter<int>>();\n+}\n+\n+impl Trait for uint {\n+    fn method<G: Getter<uint>>() {}\n+    //~^ ERROR in method `method`, type parameter 0 requires bound `Getter<uint>`\n+}\n+\n+fn main() {}\n+"}, {"sha": "a970a86408e90ad379aaeb31d8505037dc87691d", "filename": "src/test/compile-fail/trait-bounds-impl-comparison-2.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/67776ba3dab24a3e281931da437d30ccfc3b04c1/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67776ba3dab24a3e281931da437d30ccfc3b04c1/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs?ref=67776ba3dab24a3e281931da437d30ccfc3b04c1", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #5886: a complex instance of issue #2687.\n+\n+trait Iterator<A> {\n+    fn next(&mut self) -> Option<A>;\n+}\n+\n+trait IteratorUtil<A> {\n+    fn zip<B, U: Iterator<U>>(self, other: U) -> ZipIterator<Self, U>;\n+}\n+\n+impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n+    fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<T, U> {\n+    //~^ ERROR in method `zip`, type parameter 1 requires bound `Iterator<B>`\n+        ZipIterator{a: self, b: other}\n+    }\n+}\n+\n+struct ZipIterator<T, U> {\n+    a: T, b: U\n+}\n+\n+fn main() {}\n+"}, {"sha": "55ad22dd0bfdf3e5f2ae061d117e88060da29fb7", "filename": "src/test/run-pass/trait-bounds-impl-comparison-duplicates.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/67776ba3dab24a3e281931da437d30ccfc3b04c1/src%2Ftest%2Frun-pass%2Ftrait-bounds-impl-comparison-duplicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67776ba3dab24a3e281931da437d30ccfc3b04c1/src%2Ftest%2Frun-pass%2Ftrait-bounds-impl-comparison-duplicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-impl-comparison-duplicates.rs?ref=67776ba3dab24a3e281931da437d30ccfc3b04c1", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that type parameter bounds on an implementation need not match the\n+// trait exactly, as long as the implementation doesn't demand *more* bounds\n+// than the trait.\n+\n+trait A {\n+    fn foo<T: Eq + Ord>(&self);\n+}\n+\n+impl A for int {\n+    fn foo<T: Ord + Ord>(&self) {}\n+}\n+\n+fn main() {}\n+\n+"}]}