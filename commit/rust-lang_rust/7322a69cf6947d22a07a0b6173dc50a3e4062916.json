{"sha": "7322a69cf6947d22a07a0b6173dc50a3e4062916", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMjJhNjljZjY5NDdkMjJhMDdhMGI2MTczZGM1MGEzZTQwNjI5MTY=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-10-28T16:58:16Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-10-28T16:58:16Z"}, "message": "refactor(hir_ty): do not override DisplayTarget in hir_fmt\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "7426455f28a70ced3d61a83e18d74e09144c0073", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7426455f28a70ced3d61a83e18d74e09144c0073"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7322a69cf6947d22a07a0b6173dc50a3e4062916", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7322a69cf6947d22a07a0b6173dc50a3e4062916", "html_url": "https://github.com/rust-lang/rust/commit/7322a69cf6947d22a07a0b6173dc50a3e4062916", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7322a69cf6947d22a07a0b6173dc50a3e4062916/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e34183218ceb840c3b20a707ed79e57bdf9f90b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e34183218ceb840c3b20a707ed79e57bdf9f90b7", "html_url": "https://github.com/rust-lang/rust/commit/e34183218ceb840c3b20a707ed79e57bdf9f90b7"}], "stats": {"total": 113, "additions": 68, "deletions": 45}, "files": [{"sha": "14e8c06332b18ae29db75f5dd411f6c18a039f80", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 68, "deletions": 45, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/7322a69cf6947d22a07a0b6173dc50a3e4062916/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7322a69cf6947d22a07a0b6173dc50a3e4062916/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=7322a69cf6947d22a07a0b6173dc50a3e4062916", "patch": "@@ -25,6 +25,20 @@ pub struct HirFormatter<'a> {\n pub trait HirDisplay {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError>;\n \n+    /// Returns a `Display`able type that is human-readable.\n+    fn into_displayable<'a>(\n+        &'a self,\n+        db: &'a dyn HirDatabase,\n+        max_size: Option<usize>,\n+        omit_verbose_types: bool,\n+        display_target: DisplayTarget,\n+    ) -> HirDisplayWrapper<'a, Self>\n+    where\n+        Self: Sized,\n+    {\n+        HirDisplayWrapper { db, t: self, max_size, omit_verbose_types, display_target }\n+    }\n+\n     /// Returns a `Display`able type that is human-readable.\n     /// Use this for showing types to the user (e.g. diagnostics)\n     fn display<'a>(&'a self, db: &'a dyn HirDatabase) -> HirDisplayWrapper<'a, Self>\n@@ -140,7 +154,7 @@ impl<'a> HirFormatter<'a> {\n }\n \n #[derive(Clone, Copy)]\n-enum DisplayTarget {\n+pub enum DisplayTarget {\n     /// Display types for inlays, doc popups, autocompletion, etc...\n     /// Showing `{unknown}` or not qualifying paths is fine here.\n     /// There's no reason for this to fail.\n@@ -232,32 +246,32 @@ impl HirDisplay for ApplicationTy {\n             TypeCtor::Str => write!(f, \"str\")?,\n             TypeCtor::Slice => {\n                 let t = self.parameters.as_single();\n-                write!(f, \"[{}]\", t.display(f.db))?;\n+                write!(f, \"[\")?;\n+                t.hir_fmt(f)?;\n+                write!(f, \"]\")?;\n             }\n             TypeCtor::Array => {\n                 let t = self.parameters.as_single();\n-                write!(f, \"[{}; _]\", t.display(f.db))?;\n+                write!(f, \"[\")?;\n+                t.hir_fmt(f)?;\n+                write!(f, \"; _]\")?;\n             }\n             TypeCtor::RawPtr(m) => {\n                 let t = self.parameters.as_single();\n-                let ty_display = t.display(f.db);\n \n                 write!(f, \"*{}\", m.as_keyword_for_ptr())?;\n                 if matches!(t, Ty::Dyn(predicates) if predicates.len() > 1) {\n                     write!(f, \"(\")?;\n-                    write!(f, \"{}\", ty_display)?;\n+                    t.hir_fmt(f)?;\n                     write!(f, \")\")?;\n                 } else {\n-                    write!(f, \"{}\", ty_display)?;\n+                    t.hir_fmt(f)?;\n                 }\n             }\n             TypeCtor::Ref(m) => {\n                 let t = self.parameters.as_single();\n-                let ty_display = if f.omit_verbose_types() {\n-                    t.display_truncated(f.db, f.max_size)\n-                } else {\n-                    t.display(f.db)\n-                };\n+                let ty_display =\n+                    t.into_displayable(f.db, f.max_size, f.omit_verbose_types, f.display_target);\n \n                 write!(f, \"&{}\", m.as_keyword_for_ref())?;\n                 if matches!(t, Ty::Dyn(predicates) if predicates.len() > 1) {\n@@ -272,7 +286,9 @@ impl HirDisplay for ApplicationTy {\n             TypeCtor::Tuple { .. } => {\n                 let ts = &self.parameters;\n                 if ts.len() == 1 {\n-                    write!(f, \"({},)\", ts[0].display(f.db))?;\n+                    write!(f, \"(\")?;\n+                    ts[0].hir_fmt(f)?;\n+                    write!(f, \",)\")?;\n                 } else {\n                     write!(f, \"(\")?;\n                     f.write_joined(&*ts.0, \", \")?;\n@@ -293,11 +309,12 @@ impl HirDisplay for ApplicationTy {\n                 write!(f, \")\")?;\n                 let ret = sig.ret();\n                 if *ret != Ty::unit() {\n-                    let ret_display = if f.omit_verbose_types() {\n-                        ret.display_truncated(f.db, f.max_size)\n-                    } else {\n-                        ret.display(f.db)\n-                    };\n+                    let ret_display = ret.into_displayable(\n+                        f.db,\n+                        f.max_size,\n+                        f.omit_verbose_types,\n+                        f.display_target,\n+                    );\n                     write!(f, \" -> {}\", ret_display)?;\n                 }\n             }\n@@ -329,15 +346,13 @@ impl HirDisplay for ApplicationTy {\n                 write!(f, \")\")?;\n                 let ret = sig.ret();\n                 if *ret != Ty::unit() {\n-                    let ret_display = if f.omit_verbose_types() {\n-                        ret.display_truncated(f.db, f.max_size)\n-                    } else {\n-                        if f.display_target.is_test() {\n-                            ret.display_test(f.db)\n-                        } else {\n-                            ret.display(f.db)\n-                        }\n-                    };\n+                    let ret_display = ret.into_displayable(\n+                        f.db,\n+                        f.max_size,\n+                        f.omit_verbose_types,\n+                        f.display_target,\n+                    );\n+\n                     write!(f, \" -> {}\", ret_display)?;\n                 }\n             }\n@@ -473,15 +488,12 @@ impl HirDisplay for ApplicationTy {\n                         write!(f, \"|\")?;\n                     };\n \n-                    let ret_display = if f.omit_verbose_types() {\n-                        sig.ret().display_truncated(f.db, f.max_size)\n-                    } else {\n-                        if f.display_target.is_test() {\n-                            sig.ret().display_test(f.db)\n-                        } else {\n-                            sig.ret().display(f.db)\n-                        }\n-                    };\n+                    let ret_display = sig.ret().into_displayable(\n+                        f.db,\n+                        f.max_size,\n+                        f.omit_verbose_types,\n+                        f.display_target,\n+                    );\n                     write!(f, \" -> {}\", ret_display)?;\n                 } else {\n                     write!(f, \"{{closure}}\")?;\n@@ -499,7 +511,13 @@ impl HirDisplay for ProjectionTy {\n         }\n \n         let trait_ = f.db.trait_data(self.trait_(f.db));\n-        write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_.name)?;\n+        let first_parameter = self.parameters[0].into_displayable(\n+            f.db,\n+            f.max_size,\n+            f.omit_verbose_types,\n+            f.display_target,\n+        );\n+        write!(f, \"<{} as {}\", first_parameter, trait_.name)?;\n         if self.parameters.len() > 1 {\n             write!(f, \"<\")?;\n             f.write_joined(&self.parameters[1..], \", \")?;\n@@ -678,10 +696,10 @@ impl HirDisplay for GenericPredicate {\n                 projection_pred.projection_ty.trait_ref(f.db).hir_fmt_ext(f, true)?;\n                 write!(\n                     f,\n-                    \">::{} = {}\",\n+                    \">::{} = \",\n                     f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name,\n-                    projection_pred.ty.display(f.db)\n                 )?;\n+                projection_pred.ty.hir_fmt(f)?;\n             }\n             GenericPredicate::Error => write!(f, \"{{error}}\")?,\n         }\n@@ -692,13 +710,18 @@ impl HirDisplay for GenericPredicate {\n impl HirDisplay for Obligation {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         match self {\n-            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n-            Obligation::Projection(proj) => write!(\n-                f,\n-                \"Normalize({} => {})\",\n-                proj.projection_ty.display(f.db),\n-                proj.ty.display(f.db)\n-            ),\n+            Obligation::Trait(tr) => {\n+                write!(f, \"Implements(\")?;\n+                tr.hir_fmt(f)?;\n+                write!(f, \")\")\n+            }\n+            Obligation::Projection(proj) => {\n+                write!(f, \"Normalize(\")?;\n+                proj.projection_ty.hir_fmt(f)?;\n+                write!(f, \" => \")?;\n+                proj.ty.hir_fmt(f)?;\n+                write!(f, \")\")\n+            }\n         }\n     }\n }"}]}