{"sha": "85e1d4749e5ba14ff89073f5812974ec8fdbffd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZTFkNDc0OWU1YmExNGZmODkwNzNmNTgxMjk3NGVjOGZkYmZmZDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T18:04:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-15T15:27:51Z"}, "message": "propagate type tests from closure to closure creators\n\nCurrently, we only propagate type tests that exclude all regions from\nthe type.", "tree": {"sha": "5442f2b3f0f5dc1e885c09bfdb50bdfcc95cf2c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5442f2b3f0f5dc1e885c09bfdb50bdfcc95cf2c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85e1d4749e5ba14ff89073f5812974ec8fdbffd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85e1d4749e5ba14ff89073f5812974ec8fdbffd4", "html_url": "https://github.com/rust-lang/rust/commit/85e1d4749e5ba14ff89073f5812974ec8fdbffd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "url": "https://api.github.com/repos/rust-lang/rust/commits/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de", "html_url": "https://github.com/rust-lang/rust/commit/5804637a81a8e5216fbbf2e3e7c0a7bdca9c99de"}], "stats": {"total": 612, "additions": 581, "deletions": 31}, "files": [{"sha": "244abb407982fc0abcf3b9139783f13e6b9c9b99", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 136, "deletions": 21, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=85e1d4749e5ba14ff89073f5812974ec8fdbffd4", "patch": "@@ -12,15 +12,18 @@ use super::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::infer::NLLRegionVariableOrigin;\n+use rustc::infer::RegionObligation;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::SubregionOrigin;\n use rustc::infer::region_constraints::{GenericKind, VarOrigins};\n use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n                  Location, Mir};\n-use rustc::ty::{self, RegionVid};\n+use rustc::traits::ObligationCause;\n+use rustc::ty::{self, RegionVid, TypeFoldable};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt;\n use std::rc::Rc;\n+use syntax::ast;\n use syntax_pos::Span;\n \n mod annotation;\n@@ -361,7 +364,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             None\n         };\n \n-        self.check_type_tests(infcx, mir);\n+        self.check_type_tests(infcx, mir, outlives_requirements.as_mut());\n \n         self.check_universal_regions(infcx, outlives_requirements.as_mut());\n \n@@ -439,21 +442,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// therefore add `end('a)` into the region for `'b` -- but we\n     /// have no evidence that `'b` outlives `'a`, so we want to report\n     /// an error.\n-    fn check_type_tests(&self, infcx: &InferCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) {\n+    fn check_type_tests<'gcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+    ) {\n         let tcx = infcx.tcx;\n \n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n-            if self.eval_region_test(\n-                mir,\n-                type_test.point,\n-                type_test.lower_bound,\n-                &type_test.test,\n-            ) {\n+            if self.eval_region_test(mir, type_test.point, type_test.lower_bound, &type_test.test) {\n                 continue;\n             }\n \n+            if let Some(propagated_outlives_requirements) = &mut propagated_outlives_requirements {\n+                if self.try_promote_type_test(infcx, type_test, propagated_outlives_requirements) {\n+                    continue;\n+                }\n+            }\n+\n             // Oh the humanity. Obviously we will do better than this error eventually.\n             tcx.sess.span_err(\n                 type_test.span,\n@@ -462,6 +471,103 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n+    fn try_promote_type_test<'gcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        type_test: &TypeTest<'tcx>,\n+        propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'gcx>>,\n+    ) -> bool {\n+        let tcx = infcx.tcx;\n+        let gcx = tcx.global_tcx();\n+\n+        let TypeTest {\n+            generic_kind,\n+            lower_bound,\n+            point: _,\n+            span,\n+            test: _,\n+        } = type_test;\n+\n+        // TODO. For now, just fail to promote anything with a\n+        // region. This is obviously too strict: we will for example\n+        // fail to promote `<T as Foo<'static>>::Bar` to our\n+        // caller. But it is always sound not to promote, that just\n+        // means more errors, and ignoring regions is a convenient\n+        // starting point. This is because we would want to promote to\n+        // a type that references the region-vids of the closure, for\n+        // which we have no global representation just now.\n+        let generic_ty = generic_kind.to_ty(tcx);\n+        if generic_ty.has_free_regions() {\n+            return false;\n+        }\n+        let generic_ty = gcx.lift(&generic_ty).unwrap();\n+\n+        // Find some bounding subject-region R+ that is a super-region\n+        // of the existing subject-region R. This should be a non-local, universal\n+        // region, which ensures it can be encoded in a `ClosureOutlivesRequirement`.\n+        let lower_bound_plus = self.promoted_type_test_bound(*lower_bound);\n+        assert!(self.universal_regions.is_universal_region(lower_bound_plus));\n+        assert!(!self.universal_regions\n+            .is_local_free_region(lower_bound_plus));\n+\n+        propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n+            subject: ClosureOutlivesSubject::Ty(generic_ty),\n+            outlived_free_region: lower_bound_plus,\n+            blame_span: *span,\n+        });\n+        true\n+    }\n+\n+    /// Here, `lower_bound` (henceforth, `'r`) represents the bound from\n+    /// some type-test `T: 'r`. We are a closure and have found that\n+    /// `T: 'r` is not locally satisfiable, so we want to propagate\n+    /// this constraint to our creator. It is sound for us to do so\n+    /// with some `'r+` known to our creator, where `'r+: 'r`.\n+    ///\n+    /// The tricky bit here: this region `'r` may contain (a) any\n+    /// number of points in the CFG and (b) any number of `end('x)`\n+    /// elements of universally quantified regions. To communicate with\n+    /// our creator, however, we have to pick exactly one universally\n+    /// quantified region -- in other words, exactly one `end('x)`\n+    /// element -- that they understand and which will be `'r+`.\n+    ///\n+    /// We do this as follows:\n+    ///\n+    /// - Ignore the CFG points in `'r`. All universally quantified regions\n+    ///   include the CFG anyhow.\n+    /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n+    ///   a result `'y`.\n+    /// - Finally, we take the non-local upper bound of `'y`.\n+    fn promoted_type_test_bound(&self, lower_bound: RegionVid) -> RegionVid {\n+        let inferred_values = self.inferred_values.as_ref().unwrap();\n+\n+        debug!(\n+            \"promoted_type_test_bound(lower_bound={:?}={})\",\n+            lower_bound,\n+            inferred_values.region_value_str(lower_bound)\n+        );\n+\n+        // Find the smallest universal region that contains all other\n+        // universal regions within `region`.\n+        let mut lub = self.universal_regions.fr_fn_body;\n+        for ur in inferred_values.universal_regions_outlived_by(lower_bound) {\n+            lub = self.universal_regions.postdom_upper_bound(lub, ur);\n+        }\n+\n+        debug!(\"promoted_type_test_bound: lub={:?}\", lub);\n+\n+        // Grow further to get smallest universal region known to\n+        // creator.\n+        let non_local_lub = self.universal_regions.non_local_upper_bound(lub);\n+\n+        debug!(\n+            \"promoted_type_test_bound: non_local_lub={:?}\",\n+            non_local_lub\n+        );\n+\n+        non_local_lub\n+    }\n+\n     /// Test if `test` is true when applied to `lower_bound` at\n     /// `point`, and returns true or false.\n     fn eval_region_test(\n@@ -487,13 +593,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .iter()\n                 .any(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n \n-            RegionTest::Any(tests) => tests.iter().any(|test| {\n-                self.eval_region_test(mir, point, lower_bound, test)\n-            }),\n+            RegionTest::Any(tests) => tests\n+                .iter()\n+                .any(|test| self.eval_region_test(mir, point, lower_bound, test)),\n \n-            RegionTest::All(tests) => tests.iter().all(|test| {\n-                self.eval_region_test(mir, point, lower_bound, test)\n-            }),\n+            RegionTest::All(tests) => tests\n+                .iter()\n+                .all(|test| self.eval_region_test(mir, point, lower_bound, test)),\n         }\n     }\n \n@@ -772,17 +878,18 @@ impl fmt::Debug for Constraint {\n     }\n }\n \n-pub trait ClosureRegionRequirementsExt {\n+pub trait ClosureRegionRequirementsExt<'gcx> {\n     fn apply_requirements<'tcx>(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        body_id: ast::NodeId,\n         location: Location,\n         closure_def_id: DefId,\n         closure_substs: ty::ClosureSubsts<'tcx>,\n     );\n }\n \n-impl<'gcx> ClosureRegionRequirementsExt for ClosureRegionRequirements<'gcx> {\n+impl<'gcx> ClosureRegionRequirementsExt<'gcx> for ClosureRegionRequirements<'gcx> {\n     /// Given an instance T of the closure type, this method\n     /// instantiates the \"extra\" requirements that we computed for the\n     /// closure into the inference context. This has the effect of\n@@ -797,7 +904,8 @@ impl<'gcx> ClosureRegionRequirementsExt for ClosureRegionRequirements<'gcx> {\n     /// requirements.\n     fn apply_requirements<'tcx>(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        body_id: ast::NodeId,\n         location: Location,\n         closure_def_id: DefId,\n         closure_substs: ty::ClosureSubsts<'tcx>,\n@@ -843,8 +951,15 @@ impl<'gcx> ClosureRegionRequirementsExt for ClosureRegionRequirements<'gcx> {\n                     infcx.sub_regions(origin, outlived_region, region);\n                 }\n \n-                ClosureOutlivesSubject::Ty(_ty) => {\n-                    bug!(\"TODO not yet implemented -- closure outlives subject of a type\");\n+                ClosureOutlivesSubject::Ty(ty) => {\n+                    infcx.register_region_obligation(\n+                        body_id,\n+                        RegionObligation {\n+                            sup_type: ty,\n+                            sub_region: outlived_region,\n+                            cause: ObligationCause::misc(outlives_requirement.blame_span, body_id),\n+                        },\n+                    );\n                 }\n             }\n         }"}, {"sha": "5c3cdbe2207ba2127e0f7855d3b22748e218e243", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=85e1d4749e5ba14ff89073f5812974ec8fdbffd4", "patch": "@@ -1409,6 +1409,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 if let Some(closure_region_requirements) = tcx.mir_borrowck(*def_id) {\n                     closure_region_requirements.apply_requirements(\n                         self.infcx,\n+                        self.body_id,\n                         location,\n                         *def_id,\n                         *substs,"}, {"sha": "d3e75626e63cf99e0ee828098dd4baf253b2adf7", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=85e1d4749e5ba14ff89073f5812974ec8fdbffd4", "patch": "@@ -267,6 +267,20 @@ impl<'tcx> UniversalRegions<'tcx> {\n         self.num_universals\n     }\n \n+    /// Given two universal regions, returns the postdominating\n+    /// upper-bound (effectively the least upper bound).\n+    ///\n+    /// (See `TransitiveRelation::postdom_upper_bound` for details on\n+    /// the postdominating upper bound in general.)\n+    pub fn postdom_upper_bound(&self, fr1: RegionVid, fr2: RegionVid) -> RegionVid {\n+        assert!(self.is_universal_region(fr1));\n+        assert!(self.is_universal_region(fr2));\n+        *self.relations\n+            .inverse_outlives\n+            .postdom_upper_bound(&fr1, &fr2)\n+            .unwrap_or(&self.fr_static)\n+    }\n+\n     /// Finds an \"upper bound\" for `fr` that is not local. In other\n     /// words, returns the smallest (*) known region `fr1` that (a)\n     /// outlives `fr` and (b) is not local. This cannot fail, because\n@@ -431,7 +445,10 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         // - `'r: 'fn_body` for every (other) universally quantified\n         //   region `'r`, all of which are provided by our caller\n         for fr in (FIRST_GLOBAL_INDEX..num_universals).map(RegionVid::new) {\n-            debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n+            debug!(\n+                \"build: relating free region {:?} to itself and to 'static\",\n+                fr\n+            );\n             self.relations.relate_universal_regions(fr, fr);\n             self.relations.relate_universal_regions(fr_static, fr);\n             self.relations.relate_universal_regions(fr, fr_fn_body);\n@@ -442,15 +459,21 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         // we should not have created any more variables\n         assert_eq!(self.infcx.num_region_vars(), num_universals);\n \n-        debug!(\"build: global regions = {}..{}\",\n-               FIRST_GLOBAL_INDEX,\n-               first_extern_index);\n-        debug!(\"build: extern regions = {}..{}\",\n-               first_extern_index,\n-               first_local_index);\n-        debug!(\"build: local regions  = {}..{}\",\n-               first_local_index,\n-               num_universals);\n+        debug!(\n+            \"build: global regions = {}..{}\",\n+            FIRST_GLOBAL_INDEX,\n+            first_extern_index\n+        );\n+        debug!(\n+            \"build: extern regions = {}..{}\",\n+            first_extern_index,\n+            first_local_index\n+        );\n+        debug!(\n+            \"build: local regions  = {}..{}\",\n+            first_local_index,\n+            num_universals\n+        );\n \n         UniversalRegions {\n             indices,"}, {"sha": "6b23c82c77131c4cbbbe3f1465240f3d9d67ed89", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs?ref=85e1d4749e5ba14ff89073f5812974ec8fdbffd4", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::fmt::Debug;\n+\n+fn with_signature<'a, T, F>(x: Box<T>, op: F) -> Box<dyn Debug + 'a>\n+    where F: FnOnce(Box<T>) -> Box<dyn Debug + 'a>\n+{\n+    op(x)\n+}\n+\n+#[rustc_regions]\n+fn no_region<'a, T>(x: Box<T>) -> Box<dyn Debug + 'a>\n+where\n+    T: Debug,\n+{\n+    // Here, the closure winds up being required to prove that `T:\n+    // 'a`.  In principle, it could know that, except that it is\n+    // type-checked in a fully generic way, and hence it winds up with\n+    // a propagated requirement that `T: '_#2`, where `'_#2` appears\n+    // in the return type. The caller makes the mapping from `'_#2` to\n+    // `'a` (and subsequently reports an error).\n+\n+    with_signature(x, |y| y)\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+}\n+\n+fn correct_region<'a, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'a + Debug,\n+{\n+    x\n+}\n+\n+fn wrong_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'b + Debug,\n+{\n+    x\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+}\n+\n+fn outlives_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'b + Debug,\n+    'b: 'a,\n+{\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "721896a93ffcbf9ac2acfb3a21eb6ee15e4266d1", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr?ref=85e1d4749e5ba14ff89073f5812974ec8fdbffd4", "patch": "@@ -0,0 +1,58 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:37:27\n+   |\n+37 |     with_signature(x, |y| y)\n+   |                           ^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:53:5\n+   |\n+53 |     x\n+   |     ^\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:37:23\n+   |\n+37 |     with_signature(x, |y| y)\n+   |                       ^^^^^\n+   |\n+   = note: defining type: DefId(0/1:14 ~ ty_param_closure_outlives_from_return_type[317d]::no_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<std::fmt::Debug + '_#2r>\n+           ]\n+   = note: number of external vids: 3\n+   = note: where T: '_#2r\n+\n+error: failed type test: TypeTest { generic_kind: T/#1, lower_bound: '_#4r, point: bb0[5], span: $DIR/ty-param-closure-outlives-from-return-type.rs:37:23: 37:28, test: IsOutlivedByAnyRegionIn(['_#2r]) }\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:37:23\n+   |\n+37 |     with_signature(x, |y| y)\n+   |                       ^^^^^\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:26:1\n+   |\n+26 | / fn no_region<'a, T>(x: Box<T>) -> Box<dyn Debug + 'a>\n+27 | | where\n+28 | |     T: Debug,\n+29 | | {\n+...  |\n+39 | |     //~| ERROR failed type test\n+40 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:5 ~ ty_param_closure_outlives_from_return_type[317d]::no_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+error: failed type test: TypeTest { generic_kind: T/#2, lower_bound: '_#4r, point: bb0[3], span: $DIR/ty-param-closure-outlives-from-return-type.rs:53:5: 53:6, test: IsOutlivedByAnyRegionIn(['_#2r, '_#3r]) }\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:53:5\n+   |\n+53 |     x\n+   |     ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "54f7b4fa50dfb5d5747da2b3221c5140ea95c2b6", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs?ref=85e1d4749e5ba14ff89073f5812974ec8fdbffd4", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can propagate `T: 'a` obligations to our caller.  See\n+// `correct_region` for an explanation of how this test is setup; it's\n+// somewhat intricate.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+fn with_signature<'a, T, F>(a: Cell<&'a ()>, b: T, op: F)\n+where\n+    F: FnOnce(Cell<&'a ()>, T),\n+{\n+    op(a, b)\n+}\n+\n+fn require<'a, T>(_a: &Cell<&'a ()>, _b: &T)\n+where\n+    T: 'a,\n+{\n+}\n+\n+#[rustc_regions]\n+fn no_region<'a, T>(a: Cell<&'a ()>, b: T) {\n+    with_signature(a, b, |x, y| {\n+        //~^ ERROR failed type test\n+        //\n+        // See `correct_region`, which explains the point of this\n+        // test.  The only difference is that, in the case of this\n+        // function, there is no where clause *anywhere*, and hence we\n+        // get an error (but reported by the closure creator).\n+        require(&x, &y)\n+        //~^ WARNING not reporting region error due to -Znll\n+    })\n+}\n+\n+#[rustc_regions]\n+fn correct_region<'a, T>(a: Cell<&'a ()>, b: T)\n+where\n+    T: 'a,\n+{\n+    with_signature(a, b, |x, y| {\n+        // Key point of this test:\n+        //\n+        // The *closure* is being type-checked with all of its free\n+        // regions \"universalized\". In particular, it does not know\n+        // that `x` has the type `Cell<&'a ()>`, but rather treats it\n+        // as if the type of `x` is `Cell<&'A ()>`, where `'A` is some\n+        // fresh, independent region distinct from the `'a` which\n+        // appears in the environment. The call to `require` here\n+        // forces us then to prove that `T: 'A`, but the closure\n+        // cannot do it on its own. It has to surface this requirement\n+        // to its creator (which knows that `'a == 'A`).\n+        require(&x, &y)\n+    })\n+}\n+\n+#[rustc_regions]\n+fn wrong_region<'a, 'b, T>(a: Cell<&'a ()>, b: T)\n+where\n+    T: 'b,\n+{\n+    with_signature(a, b, |x, y| {\n+        //~^ ERROR failed type test\n+        // See `correct_region`\n+        require(&x, &y)\n+        //~^ WARNING not reporting region error due to -Znll\n+    })\n+}\n+\n+#[rustc_regions]\n+fn outlives_region<'a, 'b, T>(a: Cell<&'a ()>, b: T)\n+where\n+    T: 'b,\n+    'b: 'a,\n+{\n+    with_signature(a, b, |x, y| {\n+        // See `correct_region`\n+        require(&x, &y)\n+    })\n+}\n+\n+fn main() {}"}, {"sha": "748333badce806a6429d2e29aeffe983bfa578b1", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.stderr", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85e1d4749e5ba14ff89073f5812974ec8fdbffd4/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr?ref=85e1d4749e5ba14ff89073f5812974ec8fdbffd4", "patch": "@@ -0,0 +1,191 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:45:9\n+   |\n+45 |         require(&x, &y)\n+   |         ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:79:9\n+   |\n+79 |         require(&x, &y)\n+   |         ^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:38:26\n+   |\n+38 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+39 | |         //~^ ERROR failed type test\n+40 | |         //\n+41 | |         // See `correct_region`, which explains the point of this\n+...  |\n+46 | |         //~^ WARNING not reporting region error due to -Znll\n+47 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:16 ~ ty_param_closure_outlives_from_where_clause[317d]::no_region[0]::{{closure}}[0]) with closure substs [\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#1r ()>, T))\n+           ]\n+   = note: number of external vids: 2\n+   = note: where T: '_#1r\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:55:26\n+   |\n+55 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+56 | |         // Key point of this test:\n+57 | |         //\n+58 | |         // The *closure* is being type-checked with all of its free\n+...  |\n+67 | |         require(&x, &y)\n+68 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:19 ~ ty_param_closure_outlives_from_where_clause[317d]::correct_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where T: '_#2r\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:76:26\n+   |\n+76 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+77 | |         //~^ ERROR failed type test\n+78 | |         // See `correct_region`\n+79 | |         require(&x, &y)\n+80 | |         //~^ WARNING not reporting region error due to -Znll\n+81 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:23 ~ ty_param_closure_outlives_from_where_clause[317d]::wrong_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where T: '_#2r\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:90:26\n+   |\n+90 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+91 | |         // See `correct_region`\n+92 | |         require(&x, &y)\n+93 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ ty_param_closure_outlives_from_where_clause[317d]::outlives_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where T: '_#3r\n+\n+error: failed type test: TypeTest { generic_kind: T/#0, lower_bound: '_#3r, point: bb0[5], span: $DIR/ty-param-closure-outlives-from-where-clause.rs:38:26: 47:6, test: IsOutlivedByAnyRegionIn(['_#2r]) }\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:38:26\n+   |\n+38 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+39 | |         //~^ ERROR failed type test\n+40 | |         //\n+41 | |         // See `correct_region`, which explains the point of this\n+...  |\n+46 | |         //~^ WARNING not reporting region error due to -Znll\n+47 | |     })\n+   | |_____^\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:37:1\n+   |\n+37 | / fn no_region<'a, T>(a: Cell<&'a ()>, b: T) {\n+38 | |     with_signature(a, b, |x, y| {\n+39 | |         //~^ ERROR failed type test\n+40 | |         //\n+...  |\n+47 | |     })\n+48 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ ty_param_closure_outlives_from_where_clause[317d]::no_region[0]) with substs [\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:51:1\n+   |\n+51 | / fn correct_region<'a, T>(a: Cell<&'a ()>, b: T)\n+52 | | where\n+53 | |     T: 'a,\n+54 | | {\n+...  |\n+68 | |     })\n+69 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:7 ~ ty_param_closure_outlives_from_where_clause[317d]::correct_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+error: failed type test: TypeTest { generic_kind: T/#1, lower_bound: '_#5r, point: bb0[5], span: $DIR/ty-param-closure-outlives-from-where-clause.rs:76:26: 81:6, test: IsOutlivedByAnyRegionIn(['_#1r, '_#3r]) }\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:76:26\n+   |\n+76 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+77 | |         //~^ ERROR failed type test\n+78 | |         // See `correct_region`\n+79 | |         require(&x, &y)\n+80 | |         //~^ WARNING not reporting region error due to -Znll\n+81 | |     })\n+   | |_____^\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:72:1\n+   |\n+72 | / fn wrong_region<'a, 'b, T>(a: Cell<&'a ()>, b: T)\n+73 | | where\n+74 | |     T: 'b,\n+75 | | {\n+...  |\n+81 | |     })\n+82 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ ty_param_closure_outlives_from_where_clause[317d]::wrong_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:85:1\n+   |\n+85 | / fn outlives_region<'a, 'b, T>(a: Cell<&'a ()>, b: T)\n+86 | | where\n+87 | |     T: 'b,\n+88 | |     'b: 'a,\n+...  |\n+93 | |     })\n+94 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ ty_param_closure_outlives_from_where_clause[317d]::outlives_region[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+error: aborting due to 2 previous errors\n+"}]}