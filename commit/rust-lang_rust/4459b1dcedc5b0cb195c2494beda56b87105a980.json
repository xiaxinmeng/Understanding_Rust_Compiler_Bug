{"sha": "4459b1dcedc5b0cb195c2494beda56b87105a980", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NTliMWRjZWRjNWIwY2IxOTVjMjQ5NGJlZGE1NmI4NzEwNWE5ODA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-02T18:58:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-02T19:13:05Z"}, "message": "rollup merge of #20341: nikomatsakis/impl-trait-for-trait-2\n\nConflicts:\n\tsrc/librustc/middle/traits/mod.rs\n\tsrc/libstd/io/mod.rs\n\tsrc/test/run-pass/builtin-superkinds-self-type.rs", "tree": {"sha": "8de1b3e206541d31e6697aa5466e9fabff223cbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8de1b3e206541d31e6697aa5466e9fabff223cbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4459b1dcedc5b0cb195c2494beda56b87105a980", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4459b1dcedc5b0cb195c2494beda56b87105a980", "html_url": "https://github.com/rust-lang/rust/commit/4459b1dcedc5b0cb195c2494beda56b87105a980", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4459b1dcedc5b0cb195c2494beda56b87105a980/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e921e3f04513ffb094208a538a2835d4dc77b991", "url": "https://api.github.com/repos/rust-lang/rust/commits/e921e3f04513ffb094208a538a2835d4dc77b991", "html_url": "https://github.com/rust-lang/rust/commit/e921e3f04513ffb094208a538a2835d4dc77b991"}, {"sha": "704ed4c7d00d256b783086a682fbcfd7a4ac5c5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/704ed4c7d00d256b783086a682fbcfd7a4ac5c5a", "html_url": "https://github.com/rust-lang/rust/commit/704ed4c7d00d256b783086a682fbcfd7a4ac5c5a"}], "stats": {"total": 1506, "additions": 1114, "deletions": 392}, "files": [{"sha": "159c2a505d51b89c1b06b062b4b7d6ab70e41872", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -25,7 +25,7 @@ use kinds::Sized;\n \n /// A common trait for cloning an object.\n #[stable]\n-pub trait Clone {\n+pub trait Clone : Sized {\n     /// Returns a copy of the value.\n     #[stable]\n     fn clone(&self) -> Self;"}, {"sha": "13fbf5232f8dc58dc41a0e96bae6ed5d7d2d3f36", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -74,7 +74,26 @@ pub trait Writer {\n     ///\n     /// This method should generally not be invoked manually, but rather through\n     /// the `write!` macro itself.\n-    fn write_fmt(&mut self, args: Arguments) -> Result { write(self, args) }\n+    fn write_fmt(&mut self, args: Arguments) -> Result {\n+        // This Adapter is needed to allow `self` (of type `&mut\n+        // Self`) to be cast to a FormatWriter (below) without\n+        // requiring a `Sized` bound.\n+        struct Adapter<'a,Sized? T:'a>(&'a mut T);\n+\n+        impl<'a, Sized? T> Writer for Adapter<'a, T>\n+            where T: Writer\n+        {\n+            fn write_str(&mut self, s: &str) -> Result {\n+                self.0.write_str(s)\n+            }\n+\n+            fn write_fmt(&mut self, args: Arguments) -> Result {\n+                self.0.write_fmt(args)\n+            }\n+        }\n+\n+        write(&mut Adapter(self), args)\n+    }\n }\n \n /// A struct to represent both where to emit formatting strings to and how they\n@@ -579,9 +598,6 @@ impl<'a, Sized? T: Show> Show for &'a T {\n impl<'a, Sized? T: Show> Show for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n-impl<'a> Show for &'a (Show+'a) {\n-    fn fmt(&self, f: &mut Formatter) -> Result { (*self).fmt(f) }\n-}\n \n impl Show for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {"}, {"sha": "53b5c61730041d5427add3d99adba55727ce9461", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -65,6 +65,7 @@ use num::{ToPrimitive, Int};\n use ops::{Add, Deref, FnMut};\n use option::Option;\n use option::Option::{Some, None};\n+use std::kinds::Sized;\n use uint;\n \n #[deprecated = \"renamed to Extend\"] pub use self::Extend as Extendable;\n@@ -109,7 +110,7 @@ pub trait Extend<A> {\n \n #[unstable = \"new convention for extension traits\"]\n /// An extension trait providing numerous methods applicable to all iterators.\n-pub trait IteratorExt<A>: Iterator<A> {\n+pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// Chain this iterator with another, returning a new iterator that will\n     /// finish iterating over the current iterator, and then iterate\n     /// over the other specified iterator.\n@@ -692,7 +693,7 @@ impl<A, I> IteratorExt<A> for I where I: Iterator<A> {}\n \n /// Extention trait for iterators of pairs.\n #[unstable = \"newly added trait, likely to be merged with IteratorExt\"]\n-pub trait IteratorPairExt<A, B>: Iterator<(A, B)> {\n+pub trait IteratorPairExt<A, B>: Iterator<(A, B)> + Sized {\n     /// Converts an iterator of pairs into a pair of containers.\n     ///\n     /// Loops through the entire iterator, collecting the first component of\n@@ -738,7 +739,7 @@ pub trait DoubleEndedIterator<A>: Iterator<A> {\n \n /// Extension methods for double-ended iterators.\n #[unstable = \"new extension trait convention\"]\n-pub trait DoubleEndedIteratorExt<A>: DoubleEndedIterator<A> {\n+pub trait DoubleEndedIteratorExt<A>: DoubleEndedIterator<A> + Sized {\n     /// Change the direction of the iterator\n     ///\n     /// The flipped iterator swaps the ends on an iterator that can already"}, {"sha": "d16478dd6cc7ee290f5187dabff5905c3f9de72f", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -980,7 +980,7 @@ impl_to_primitive_float! { f64 }\n \n /// A generic trait for converting a number to a value.\n #[experimental = \"trait is likely to be removed\"]\n-pub trait FromPrimitive {\n+pub trait FromPrimitive : ::kinds::Sized {\n     /// Convert an `int` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n     #[inline]"}, {"sha": "38e47a5ad334e92acd22f83c1ed9b045268103d0", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -92,7 +92,7 @@ use mem;\n use clone::Clone;\n use intrinsics;\n use option::Option::{mod, Some, None};\n-use kinds::{Send, Sync};\n+use kinds::{Send, Sized, Sync};\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd, Equiv};\n use cmp::Ordering::{mod, Less, Equal, Greater};\n@@ -243,7 +243,7 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n \n /// Methods on raw pointers\n #[stable]\n-pub trait PtrExt<T> {\n+pub trait PtrExt<T> : Sized {\n     /// Returns the null pointer.\n     #[deprecated = \"call ptr::null instead\"]\n     fn null() -> Self;"}, {"sha": "bbcd99afdea9331330a1349e565f19964ada79f4", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -52,14 +52,14 @@ pub mod reseeding;\n mod rand_impls;\n \n /// A type that can be randomly generated using an `Rng`.\n-pub trait Rand {\n+pub trait Rand : Sized {\n     /// Generates a random instance of this type using the specified source of\n     /// randomness.\n     fn rand<R: Rng>(rng: &mut R) -> Self;\n }\n \n /// A random number generator.\n-pub trait Rng {\n+pub trait Rng : Sized {\n     /// Return the next random u32.\n     ///\n     /// This rarely needs to be called directly, prefer `r.gen()` to"}, {"sha": "ab6f6b601f6d039c4afbee04ec68dd5e0cb5d802", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -57,7 +57,7 @@ use syntax::ast;\n use syntax::abi;\n use syntax::codemap::Span;\n \n-pub trait Combine<'tcx> {\n+pub trait Combine<'tcx> : Sized {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx>;\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n     fn tag(&self) -> String;"}, {"sha": "97e74b9f6bbb9ecb8987db0c2534da9a5ba10e32", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -519,7 +519,7 @@ impl<'a,T> Iterator<(ParamSpace, uint, &'a T)> for EnumeratedItems<'a,T> {\n // `foo`. Or use `foo.subst_spanned(tcx, substs, Some(span))` when\n // there is more information available (for better errors).\n \n-pub trait Subst<'tcx> {\n+pub trait Subst<'tcx> : Sized {\n     fn subst(&self, tcx: &ty::ctxt<'tcx>, substs: &Substs<'tcx>) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }"}, {"sha": "c83898bcd8ade03d40abe184647606cf88ddef70", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -31,20 +31,27 @@ pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::normalize;\n pub use self::project::Normalized;\n+pub use self::object_safety::is_object_safe;\n+pub use self::object_safety::object_safety_violations;\n+pub use self::object_safety::ObjectSafetyViolation;\n+pub use self::object_safety::MethodViolationCode;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::util::elaborate_predicates;\n+pub use self::util::get_vtable_index_of_object_method;\n pub use self::util::trait_ref_for_builtin_bound;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n pub use self::util::transitive_bounds;\n+pub use self::util::upcast;\n \n mod coherence;\n mod error_reporting;\n mod fulfill;\n mod project;\n+mod object_safety;\n mod select;\n mod util;\n \n@@ -212,6 +219,9 @@ pub enum Vtable<'tcx, N> {\n     /// for some type parameter.\n     VtableParam,\n \n+    /// Virtual calls through an object\n+    VtableObject(VtableObjectData<'tcx>),\n+\n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n \n@@ -247,6 +257,13 @@ pub struct VtableBuiltinData<N> {\n     pub nested: subst::VecPerParamSpace<N>\n }\n \n+/// A vtable for some object-safe trait `Foo` automatically derived\n+/// for the object type `Foo`.\n+#[deriving(PartialEq,Eq,Clone)]\n+pub struct VtableObjectData<'tcx> {\n+    pub object_ty: Ty<'tcx>,\n+}\n+\n /// True if there exist types that satisfy both of the two given impls.\n pub fn overlapping_impls(infcx: &InferCtxt,\n                          impl1_def_id: ast::DefId,\n@@ -358,6 +375,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableFnPointer(..) => (&[]).iter(),\n             VtableUnboxedClosure(..) => (&[]).iter(),\n             VtableParam => (&[]).iter(),\n+            VtableObject(_) => (&[]).iter(),\n             VtableBuiltin(ref i) => i.iter_nested(),\n         }\n     }\n@@ -368,6 +386,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableFnPointer(ref sig) => VtableFnPointer((*sig).clone()),\n             VtableUnboxedClosure(d, ref s) => VtableUnboxedClosure(d, s.clone()),\n             VtableParam => VtableParam,\n+            VtableObject(ref p) => VtableObject(p.clone()),\n             VtableBuiltin(ref b) => VtableBuiltin(b.map_nested(op)),\n         }\n     }\n@@ -380,6 +399,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableFnPointer(sig) => VtableFnPointer(sig),\n             VtableUnboxedClosure(d, s) => VtableUnboxedClosure(d, s),\n             VtableParam => VtableParam,\n+            VtableObject(p) => VtableObject(p),\n             VtableBuiltin(no) => VtableBuiltin(no.map_move_nested(op)),\n         }\n     }"}, {"sha": "6b7bf82af929355c76e38504f6aa9d95ba192b1f", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -0,0 +1,301 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! \"Object safety\" refers to the ability for a trait to be converted\n+//! to an object. In general, traits may only be converted to an\n+//! object if all of their methods meet certain criteria. In particular,\n+//! they must:\n+//!\n+//!   - have a suitable receiver from which we can extract a vtable;\n+//!   - not reference the erased type `Self` except for in this receiver;\n+//!   - not have generic type parameters\n+\n+use super::supertraits;\n+use super::elaborate_predicates;\n+\n+use middle::subst::{mod, SelfSpace};\n+use middle::traits;\n+use middle::ty::{mod, Ty};\n+use std::rc::Rc;\n+use syntax::ast;\n+use util::ppaux::Repr;\n+\n+pub enum ObjectSafetyViolation<'tcx> {\n+    /// Self : Sized declared on the trait\n+    SizedSelf,\n+\n+    /// Method has someting illegal\n+    Method(Rc<ty::Method<'tcx>>, MethodViolationCode),\n+}\n+\n+/// Reasons a method might not be object-safe.\n+#[deriving(Copy,Clone,Show)]\n+pub enum MethodViolationCode {\n+    /// e.g., `fn(self)`\n+    ByValueSelf,\n+\n+    /// e.g., `fn foo()`\n+    StaticMethod,\n+\n+    /// e.g., `fn foo(&self, x: Self)` or `fn foo(&self) -> Self`\n+    ReferencesSelf,\n+\n+    /// e.g., `fn foo<A>()`\n+    Generic,\n+}\n+\n+pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                            trait_ref: ty::PolyTraitRef<'tcx>)\n+                            -> bool\n+{\n+    // Because we query yes/no results frequently, we keep a cache:\n+    let cached_result =\n+        tcx.object_safety_cache.borrow().get(&trait_ref.def_id()).map(|&r| r);\n+\n+    let result =\n+        cached_result.unwrap_or_else(|| {\n+            let result = object_safety_violations(tcx, trait_ref.clone()).is_empty();\n+\n+            // Record just a yes/no result in the cache; this is what is\n+            // queried most frequently. Note that this may overwrite a\n+            // previous result, but always with the same thing.\n+            tcx.object_safety_cache.borrow_mut().insert(trait_ref.def_id(), result);\n+\n+            result\n+        });\n+\n+    debug!(\"is_object_safe({}) = {}\", trait_ref.repr(tcx), result);\n+\n+    result\n+}\n+\n+pub fn object_safety_violations<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      sub_trait_ref: ty::PolyTraitRef<'tcx>)\n+                                      -> Vec<ObjectSafetyViolation<'tcx>>\n+{\n+    supertraits(tcx, sub_trait_ref)\n+        .flat_map(|tr| object_safety_violations_for_trait(tcx, tr.def_id()).into_iter())\n+        .collect()\n+}\n+\n+fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                            trait_def_id: ast::DefId)\n+                                            -> Vec<ObjectSafetyViolation<'tcx>>\n+{\n+    // Check methods for violations.\n+    let mut violations: Vec<_> =\n+        ty::trait_items(tcx, trait_def_id).iter()\n+        .flat_map(|item| {\n+            match *item {\n+                ty::MethodTraitItem(ref m) => {\n+                    object_safety_violations_for_method(tcx, trait_def_id, &**m)\n+                        .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n+                        .into_iter()\n+                }\n+                ty::TypeTraitItem(_) => {\n+                    None.into_iter()\n+                }\n+            }\n+        })\n+        .collect();\n+\n+    // Check the trait itself.\n+    if trait_has_sized_self(tcx, trait_def_id) {\n+        violations.push(ObjectSafetyViolation::SizedSelf);\n+    }\n+\n+    debug!(\"object_safety_violations_for_trait(trait_def_id={}) = {}\",\n+           trait_def_id.repr(tcx),\n+           violations.repr(tcx));\n+\n+    violations\n+}\n+\n+fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              trait_def_id: ast::DefId)\n+                              -> bool\n+{\n+    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let param_env = ty::construct_parameter_environment(tcx,\n+                                                        &trait_def.generics,\n+                                                        ast::DUMMY_NODE_ID);\n+    let predicates = param_env.caller_bounds.predicates.as_slice().to_vec();\n+    let sized_def_id = match tcx.lang_items.sized_trait() {\n+        Some(def_id) => def_id,\n+        None => { return false; /* No Sized trait, can't require it! */ }\n+    };\n+\n+    // Search for a predicate like `Self : Sized` amongst the trait bounds.\n+    elaborate_predicates(tcx, predicates)\n+        .any(|predicate| {\n+            match predicate {\n+                ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n+                    let self_ty = trait_pred.0.self_ty();\n+                    match self_ty.sty {\n+                        ty::ty_param(ref data) => data.space == subst::SelfSpace,\n+                        _ => false,\n+                    }\n+                }\n+                ty::Predicate::Projection(..) |\n+                ty::Predicate::Trait(..) |\n+                ty::Predicate::Equate(..) |\n+                ty::Predicate::RegionOutlives(..) |\n+                ty::Predicate::TypeOutlives(..) => {\n+                    false\n+                }\n+            }\n+        })\n+}\n+\n+fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                             trait_def_id: ast::DefId,\n+                                             method: &ty::Method<'tcx>)\n+                                             -> Option<MethodViolationCode>\n+{\n+    // The method's first parameter must be something that derefs to\n+    // `&self`. For now, we only accept `&self` and `Box<Self>`.\n+    match method.explicit_self {\n+        ty::ByValueExplicitSelfCategory => {\n+            return Some(MethodViolationCode::ByValueSelf);\n+        }\n+\n+        ty::StaticExplicitSelfCategory => {\n+            return Some(MethodViolationCode::StaticMethod);\n+        }\n+\n+        ty::ByReferenceExplicitSelfCategory(..) |\n+        ty::ByBoxExplicitSelfCategory => {\n+        }\n+    }\n+\n+    // The `Self` type is erased, so it should not appear in list of\n+    // arguments or return type apart from the receiver.\n+    let ref sig = method.fty.sig;\n+    for &input_ty in sig.0.inputs[1..].iter() {\n+        if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n+            return Some(MethodViolationCode::ReferencesSelf);\n+        }\n+    }\n+    if let ty::FnConverging(result_type) = sig.0.output {\n+        if contains_illegal_self_type_reference(tcx, trait_def_id, result_type) {\n+            return Some(MethodViolationCode::ReferencesSelf);\n+        }\n+    }\n+\n+    // We can't monomorphize things like `fn foo<A>(...)`.\n+    if !method.generics.types.is_empty_in(subst::FnSpace) {\n+        return Some(MethodViolationCode::Generic);\n+    }\n+\n+    None\n+}\n+\n+fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                              trait_def_id: ast::DefId,\n+                                              ty: Ty<'tcx>)\n+                                              -> bool\n+{\n+    // This is somewhat subtle. In general, we want to forbid\n+    // references to `Self` in the argument and return types,\n+    // since the value of `Self` is erased. However, there is one\n+    // exception: it is ok to reference `Self` in order to access\n+    // an associated type of the current trait, since we retain\n+    // the value of those associated types in the object type\n+    // itself.\n+    //\n+    // ```rust\n+    // trait SuperTrait {\n+    //     type X;\n+    // }\n+    //\n+    // trait Trait : SuperTrait {\n+    //     type Y;\n+    //     fn foo(&self, x: Self) // bad\n+    //     fn foo(&self) -> Self // bad\n+    //     fn foo(&self) -> Option<Self> // bad\n+    //     fn foo(&self) -> Self::Y // OK, desugars to next example\n+    //     fn foo(&self) -> <Self as Trait>::Y // OK\n+    //     fn foo(&self) -> Self::X // OK, desugars to next example\n+    //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n+    // }\n+    // ```\n+    //\n+    // However, it is not as simple as allowing `Self` in a projected\n+    // type, because there are illegal ways to use `Self` as well:\n+    //\n+    // ```rust\n+    // trait Trait : SuperTrait {\n+    //     ...\n+    //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n+    // }\n+    // ```\n+    //\n+    // Here we will not have the type of `X` recorded in the\n+    // object type, and we cannot resolve `Self as SomeOtherTrait`\n+    // without knowing what `Self` is.\n+\n+    let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n+    let mut error = false;\n+    ty::maybe_walk_ty(ty, |ty| {\n+        match ty.sty {\n+            ty::ty_param(ref param_ty) => {\n+                if param_ty.space == SelfSpace {\n+                    error = true;\n+                }\n+\n+                false // no contained types to walk\n+            }\n+\n+            ty::ty_projection(ref data) => {\n+                // This is a projected type `<Foo as SomeTrait>::X`.\n+\n+                // Compute supertraits of current trait lazilly.\n+                if supertraits.is_none() {\n+                    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+                    let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n+                    supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n+                }\n+\n+                // Determine whether the trait reference `Foo as\n+                // SomeTrait` is in fact a supertrait of the\n+                // current trait. In that case, this type is\n+                // legal, because the type `X` will be specified\n+                // in the object type.  Note that we can just use\n+                // direct equality here because all of these types\n+                // are part of the formal parameter listing, and\n+                // hence there should be no inference variables.\n+                let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n+                let is_supertrait_of_current_trait =\n+                    supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n+\n+                if is_supertrait_of_current_trait {\n+                    false // do not walk contained types, do not report error, do collect $200\n+                } else {\n+                    true // DO walk contained types, POSSIBLY reporting an error\n+                }\n+            }\n+\n+            _ => true, // walk contained types, if any\n+        }\n+    });\n+\n+    error\n+}\n+\n+impl<'tcx> Repr<'tcx> for ObjectSafetyViolation<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            ObjectSafetyViolation::SizedSelf =>\n+                format!(\"SizedSelf\"),\n+            ObjectSafetyViolation::Method(ref m, code) =>\n+                format!(\"Method({},{})\", m.repr(tcx), code),\n+        }\n+    }\n+}"}, {"sha": "0544e32b62c6a7846bf165011c35886a67cdf448", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -377,20 +377,14 @@ fn project_type<'cx,'tcx>(\n         ambiguous: false,\n     };\n \n-    assemble_candidates_from_object_type(selcx,\n-                                         obligation,\n-                                         &mut candidates);\n-\n-    if candidates.vec.is_empty() {\n-        assemble_candidates_from_param_env(selcx,\n-                                           obligation,\n-                                           &mut candidates);\n-\n-        if let Err(e) = assemble_candidates_from_impls(selcx,\n-                                                       obligation,\n-                                                       &mut candidates) {\n-            return Err(ProjectionTyError::TraitSelectionError(e));\n-        }\n+    assemble_candidates_from_param_env(selcx,\n+                                       obligation,\n+                                       &mut candidates);\n+\n+    if let Err(e) = assemble_candidates_from_impls(selcx,\n+                                                   obligation,\n+                                                   &mut candidates) {\n+        return Err(ProjectionTyError::TraitSelectionError(e));\n     }\n \n     debug!(\"{} candidates, ambiguous={}\",\n@@ -467,18 +461,22 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n fn assemble_candidates_from_object_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    object_ty: Ty<'tcx>)\n {\n     let infcx = selcx.infcx();\n-    let trait_ref = infcx.resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n-    debug!(\"assemble_candidates_from_object_type(trait_ref={})\",\n-           trait_ref.repr(infcx.tcx));\n-    let self_ty = trait_ref.self_ty();\n-    let data = match self_ty.sty {\n+    debug!(\"assemble_candidates_from_object_type(object_ty={})\",\n+           object_ty.repr(infcx.tcx));\n+    let data = match object_ty.sty {\n         ty::ty_trait(ref data) => data,\n-        _ => { return; }\n+        _ => {\n+            selcx.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"assemble_candidates_from_object_type called with non-object: {}\",\n+                        object_ty.repr(selcx.tcx()))[]);\n+        }\n     };\n-    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), self_ty);\n+    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n     let env_predicates = projection_bounds.iter()\n                                           .map(|p| p.as_predicate())\n                                           .collect();\n@@ -515,6 +513,10 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             candidate_set.vec.push(\n                 ProjectionTyCandidate::Impl(data));\n         }\n+        super::VtableObject(data) => {\n+            assemble_candidates_from_object_type(\n+                selcx, obligation, candidate_set, data.object_ty);\n+        }\n         super::VtableParam(..) => {\n             // This case tell us nothing about the value of an\n             // associated type. Consider:"}, {"sha": "ca4bf7863be4fe7129965a57f8f389fe681e1d33", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 120, "deletions": 9, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -24,8 +24,10 @@ use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n-use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure, VtableFnPointer};\n-use super::{VtableImplData, VtableBuiltinData};\n+use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure,\n+            VtableFnPointer, VtableObject};\n+use super::{VtableImplData, VtableObjectData, VtableBuiltinData};\n+use super::object_safety;\n use super::{util};\n \n use middle::fast_reject;\n@@ -147,6 +149,8 @@ enum SelectionCandidate<'tcx> {\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n     FnPointerCandidate,\n \n+    ObjectCandidate,\n+\n     ErrorCandidate,\n }\n \n@@ -717,6 +721,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 try!(self.assemble_unboxed_closure_candidates(obligation, &mut candidates));\n                 try!(self.assemble_fn_pointer_candidates(obligation, &mut candidates));\n                 try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n+                self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n             }\n         }\n \n@@ -878,7 +883,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let matching_bounds =\n             all_bounds.filter(\n                 |bound| self.infcx.probe(\n-                    |_| self.match_where_clause(obligation, bound.clone())).is_ok());\n+                    |_| self.match_poly_trait_ref(obligation, bound.clone())).is_ok());\n \n         let param_candidates =\n             matching_bounds.map(|bound| ParamCandidate(bound));\n@@ -945,7 +950,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         match self_ty.sty {\n-            ty::ty_infer(..) => {\n+            ty::ty_infer(ty::TyVar(_)) => {\n                 candidates.ambiguous = true; // could wind up being a fn() type\n             }\n \n@@ -991,6 +996,62 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(())\n     }\n \n+    /// Search for impls that might apply to `obligation`.\n+    fn assemble_candidates_from_object_ty(&mut self,\n+                                          obligation: &TraitObligation<'tcx>,\n+                                          candidates: &mut SelectionCandidateSet<'tcx>)\n+    {\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+\n+        debug!(\"assemble_candidates_from_object_ty(self_ty={})\",\n+               self_ty.repr(self.tcx()));\n+\n+        // Object-safety candidates are only applicable to object-safe\n+        // traits. Including this check is useful because it helps\n+        // inference in cases of traits like `BorrowFrom`, which are\n+        // not object-safe, and which rely on being able to infer the\n+        // self-type from one of the other inputs. Without this check,\n+        // these cases wind up being considered ambiguous due to a\n+        // (spurious) ambiguity introduced here.\n+        if !object_safety::is_object_safe(self.tcx(), obligation.predicate.to_poly_trait_ref()) {\n+            return;\n+        }\n+\n+        let poly_trait_ref = match self_ty.sty {\n+            ty::ty_trait(ref data) => {\n+                data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+            }\n+            ty::ty_infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n+                candidates.ambiguous = true; // could wind up being an object type\n+                return;\n+            }\n+            _ => {\n+                return;\n+            }\n+        };\n+\n+        debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n+               poly_trait_ref.repr(self.tcx()));\n+\n+        // see whether the object trait can be upcast to the trait we are looking for\n+        let obligation_def_id = obligation.predicate.def_id();\n+        let upcast_trait_ref = match util::upcast(self.tcx(), poly_trait_ref, obligation_def_id) {\n+            Some(r) => r,\n+            None => { return; }\n+        };\n+\n+        debug!(\"assemble_candidates_from_object_ty: upcast_trait_ref={}\",\n+               upcast_trait_ref.repr(self.tcx()));\n+\n+        // check whether the upcast version of the trait-ref matches what we are looking for\n+        if let Ok(()) = self.infcx.probe(|_| self.match_poly_trait_ref(obligation,\n+                                                                       upcast_trait_ref.clone())) {\n+            debug!(\"assemble_candidates_from_object_ty: matched, pushing candidate\");\n+            candidates.vec.push(ObjectCandidate);\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // WINNOW\n     //\n@@ -1544,6 +1605,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(VtableUnboxedClosure(closure_def_id, substs))\n             }\n \n+            ObjectCandidate => {\n+                let data = self.confirm_object_candidate(obligation);\n+                Ok(VtableObject(data))\n+            }\n+\n             FnPointerCandidate => {\n                 let fn_type =\n                     try!(self.confirm_fn_pointer_candidate(obligation));\n@@ -1727,6 +1793,48 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          nested: impl_predicates }\n     }\n \n+    fn confirm_object_candidate(&mut self,\n+                                obligation: &TraitObligation<'tcx>)\n+                                -> VtableObjectData<'tcx>\n+    {\n+        debug!(\"confirm_object_candidate({})\",\n+               obligation.repr(self.tcx()));\n+\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        let poly_trait_ref = match self_ty.sty {\n+            ty::ty_trait(ref data) => {\n+                data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+            }\n+            _ => {\n+                self.tcx().sess.span_bug(obligation.cause.span,\n+                                         \"object candidate with non-object\");\n+            }\n+        };\n+\n+        let obligation_def_id = obligation.predicate.def_id();\n+        let upcast_trait_ref = match util::upcast(self.tcx(),\n+                                                  poly_trait_ref.clone(),\n+                                                  obligation_def_id) {\n+            Some(r) => r,\n+            None => {\n+                self.tcx().sess.span_bug(obligation.cause.span,\n+                                         format!(\"unable to upcast from {} to {}\",\n+                                                 poly_trait_ref.repr(self.tcx()),\n+                                                 obligation_def_id.repr(self.tcx())).as_slice());\n+            }\n+        };\n+\n+        match self.match_poly_trait_ref(obligation, upcast_trait_ref) {\n+            Ok(()) => { }\n+            Err(()) => {\n+                self.tcx().sess.span_bug(obligation.cause.span,\n+                                         \"failed to match trait refs\");\n+            }\n+        }\n+\n+        VtableObjectData { object_ty: self_ty }\n+    }\n+\n     fn confirm_fn_pointer_candidate(&mut self,\n                                     obligation: &TraitObligation<'tcx>)\n                                     -> Result<ty::Ty<'tcx>,SelectionError<'tcx>>\n@@ -1962,12 +2070,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n     }\n \n-    fn match_where_clause(&mut self,\n-                          obligation: &TraitObligation<'tcx>,\n-                          where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n-                        -> Result<(),()>\n+    fn match_poly_trait_ref(&mut self,\n+                            obligation: &TraitObligation<'tcx>,\n+                            where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n+                            -> Result<(),()>\n     {\n-        debug!(\"match_where_clause: obligation={} where_clause_trait_ref={}\",\n+        debug!(\"match_poly_trait_ref: obligation={} where_clause_trait_ref={}\",\n                obligation.repr(self.tcx()),\n                where_clause_trait_ref.repr(self.tcx()));\n \n@@ -2161,6 +2269,9 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n             ProjectionCandidate => format!(\"ProjectionCandidate\"),\n             FnPointerCandidate => format!(\"FnPointerCandidate\"),\n+            ObjectCandidate => {\n+                format!(\"ObjectCandidate\")\n+            }\n             UnboxedClosureCandidate(c, ref s) => {\n                 format!(\"UnboxedClosureCandidate({},{})\", c, s.repr(tcx))\n             }"}, {"sha": "41a59d6a5d84679b63d9a3c056bb9463a457bb87", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -238,6 +238,12 @@ impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n     }\n }\n \n+impl<'tcx> fmt::Show for super::VtableObjectData<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableObject(...)\")\n+    }\n+}\n+\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,\n@@ -291,6 +297,58 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     })\n }\n \n+/// Cast a trait reference into a reference to one of its super\n+/// traits; returns `None` if `target_trait_def_id` is not a\n+/// supertrait.\n+pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                    source_trait_ref: ty::PolyTraitRef<'tcx>,\n+                    target_trait_def_id: ast::DefId)\n+                    -> Option<ty::PolyTraitRef<'tcx>>\n+{\n+    if source_trait_ref.def_id() == target_trait_def_id {\n+        return Some(source_trait_ref); // shorcut the most common case\n+    }\n+\n+    for super_trait_ref in supertraits(tcx, source_trait_ref) {\n+        if super_trait_ref.def_id() == target_trait_def_id {\n+            return Some(super_trait_ref);\n+        }\n+    }\n+\n+    None\n+}\n+\n+/// Given an object of type `object_trait_ref`, returns the index of\n+/// the method `n_method` found in the trait `trait_def_id` (which\n+/// should be a supertrait of `object_trait_ref`) within the vtable\n+/// for `object_trait_ref`.\n+pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                               object_trait_ref: ty::PolyTraitRef<'tcx>,\n+                                               trait_def_id: ast::DefId,\n+                                               method_index_in_trait: uint) -> uint {\n+    // We need to figure the \"real index\" of the method in a\n+    // listing of all the methods of an object. We do this by\n+    // iterating down the supertraits of the object's trait until\n+    // we find the trait the method came from, counting up the\n+    // methods from them.\n+    let mut method_count = 0;\n+    ty::each_bound_trait_and_supertraits(tcx, &[object_trait_ref], |bound_ref| {\n+        if bound_ref.def_id() == trait_def_id {\n+            false\n+        } else {\n+            let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n+            for trait_item in trait_items.iter() {\n+                match *trait_item {\n+                    ty::MethodTraitItem(_) => method_count += 1,\n+                    ty::TypeTraitItem(_) => {}\n+                }\n+            }\n+            true\n+        }\n+    });\n+    method_count + method_index_in_trait\n+}\n+\n impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Obligation(predicate={},depth={})\",\n@@ -314,6 +372,10 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n                 format!(\"VtableFnPointer({})\",\n                         d.repr(tcx)),\n \n+            super::VtableObject(ref d) =>\n+                format!(\"VtableObject({})\",\n+                        d.repr(tcx)),\n+\n             super::VtableParam =>\n                 format!(\"VtableParam\"),\n \n@@ -339,6 +401,13 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableBuiltinData<N> {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for super::VtableObjectData<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"VtableObject(object_ty={})\",\n+                self.object_ty.repr(tcx))\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {"}, {"sha": "0a03a8e836b9221d73dc2475a484bf81af3baa60", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -828,6 +828,9 @@ pub struct ctxt<'tcx> {\n     /// parameters are never placed into this cache, because their\n     /// results are dependent on the parameter environment.\n     pub type_impls_sized_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n+\n+    /// Caches whether traits are object safe\n+    pub object_safety_cache: RefCell<DefIdMap<bool>>,\n }\n \n // Flags that we track on types. These flags are propagated upwards\n@@ -2385,6 +2388,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         repr_hint_cache: RefCell::new(DefIdMap::new()),\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n+        object_safety_cache: RefCell::new(DefIdMap::new()),\n    }\n }\n "}, {"sha": "abbf530529bb2fd41959cb259c4dc90e5a04db15", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -56,7 +56,7 @@ pub trait TypeFoldable<'tcx> {\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n-pub trait TypeFolder<'tcx> {\n+pub trait TypeFolder<'tcx> : Sized {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n \n     /// Invoked by the `super_*` routines when we enter a region\n@@ -503,6 +503,15 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n             }\n             traits::VtableParam => traits::VtableParam,\n             traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n+            traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n+        traits::VtableObjectData {\n+            object_ty: self.object_ty.fold_with(folder)\n         }\n     }\n }"}, {"sha": "a046d9d5d39c5e5323fc2c4e5fbfc6383173f269", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -154,7 +154,7 @@ trait PrinterSupport<'ast>: pprust::PpAnn {\n     ///\n     /// (Rust does not yet support upcasting from a trait object to\n     /// an object for one of its super-traits.)\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn;\n }\n \n struct NoAnn<'ast> {\n@@ -168,6 +168,8 @@ impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n@@ -183,6 +185,8 @@ impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n@@ -232,6 +236,8 @@ impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n@@ -265,6 +271,8 @@ impl<'tcx> PrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'tcx>> {\n         Some(&self.analysis.ty_cx.map)\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {"}, {"sha": "99624f1b1e7d8197a36e4a12e91a161a35c9c621", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 147, "deletions": 4, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use arena::TypedArena;\n use back::abi;\n-use llvm;\n-use llvm::ValueRef;\n+use back::link;\n+use llvm::{mod, ValueRef, get_param};\n use metadata::csearch;\n-use middle::subst::{Substs};\n+use middle::subst::{Subst, Substs};\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n@@ -370,6 +370,10 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llfn = trans_fn_pointer_shim(bcx.ccx(), fn_ty);\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n+        traits::VtableObject(ref data) => {\n+            let llfn = trans_object_shim(bcx.ccx(), data.object_ty, trait_id, n_method);\n+            Callee { bcx: bcx, data: Fn(llfn) }\n+        }\n         traits::VtableBuiltin(..) |\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n@@ -503,6 +507,137 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n }\n \n+/// Generate a shim function that allows an object type like `SomeTrait` to\n+/// implement the type `SomeTrait`. Imagine a trait definition:\n+///\n+///    trait SomeTrait { fn get(&self) -> int; ... }\n+///\n+/// And a generic bit of code:\n+///\n+///    fn foo<T:SomeTrait>(t: &T) {\n+///        let x = SomeTrait::get;\n+///        x(t)\n+///    }\n+///\n+/// What is the value of `x` when `foo` is invoked with `T=SomeTrait`?\n+/// The answer is that it it is a shim function generate by this\n+/// routine:\n+///\n+///    fn shim(t: &SomeTrait) -> int {\n+///        // ... call t.get() virtually ...\n+///    }\n+///\n+/// In fact, all virtual calls can be thought of as normal trait calls\n+/// that go through this shim function.\n+pub fn trans_object_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    object_ty: Ty<'tcx>,\n+    trait_id: ast::DefId,\n+    method_offset_in_trait: uint)\n+    -> ValueRef\n+{\n+    let _icx = push_ctxt(\"trans_object_shim\");\n+    let tcx = ccx.tcx();\n+\n+    debug!(\"trans_object_shim(object_ty={}, trait_id={}, n_method={})\",\n+           object_ty.repr(tcx),\n+           trait_id.repr(tcx),\n+           method_offset_in_trait);\n+\n+    let object_trait_ref =\n+        match object_ty.sty {\n+            ty::ty_trait(ref data) => {\n+                data.principal_trait_ref_with_self_ty(tcx, object_ty)\n+            }\n+            _ => {\n+                tcx.sess.bug(format!(\"trans_object_shim() called on non-object: {}\",\n+                                     object_ty.repr(tcx)).as_slice());\n+            }\n+        };\n+\n+    // Upcast to the trait in question and extract out the substitutions.\n+    let upcast_trait_ref = traits::upcast(ccx.tcx(), object_trait_ref.clone(), trait_id).unwrap();\n+    let object_substs = upcast_trait_ref.substs().clone().erase_regions();\n+    debug!(\"trans_object_shim: object_substs={}\", object_substs.repr(tcx));\n+\n+    // Lookup the type of this method as deeclared in the trait and apply substitutions.\n+    let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n+        ty::MethodTraitItem(method) => method,\n+        ty::TypeTraitItem(_) => {\n+            tcx.sess.bug(\"can't create a method shim for an associated type\")\n+        }\n+    };\n+    let fty = method_ty.fty.subst(tcx, &object_substs);\n+    let fty = tcx.mk_bare_fn(fty);\n+    debug!(\"trans_object_shim: fty={}\", fty.repr(tcx));\n+\n+    //\n+    let method_bare_fn_ty =\n+        ty::mk_bare_fn(tcx, None, fty);\n+    let function_name =\n+        link::mangle_internal_name_by_type_and_seq(ccx, method_bare_fn_ty, \"object_shim\");\n+    let llfn =\n+        decl_internal_rust_fn(ccx, method_bare_fn_ty, function_name.as_slice());\n+\n+    //\n+    let block_arena = TypedArena::new();\n+    let empty_substs = Substs::trans_empty();\n+    let fcx = new_fn_ctxt(ccx,\n+                          llfn,\n+                          ast::DUMMY_NODE_ID,\n+                          false,\n+                          fty.sig.0.output,\n+                          &empty_substs,\n+                          None,\n+                          &block_arena);\n+    let mut bcx = init_function(&fcx, false, fty.sig.0.output);\n+\n+    // the first argument (`self`) will be a trait object\n+    let llobject = get_param(fcx.llfn, fcx.arg_pos(0) as u32);\n+\n+    debug!(\"trans_object_shim: llobject={}\",\n+           bcx.val_to_string(llobject));\n+\n+    // the remaining arguments will be, well, whatever they are\n+    let llargs: Vec<_> =\n+        fty.sig.0.inputs[1..].iter()\n+        .enumerate()\n+        .map(|(i, _)| {\n+            let llarg = get_param(fcx.llfn, fcx.arg_pos(i+1) as u32);\n+            debug!(\"trans_object_shim: input #{} == {}\",\n+                   i, bcx.val_to_string(llarg));\n+            llarg\n+        })\n+        .collect();\n+    assert!(!fcx.needs_ret_allocas);\n+\n+    let dest =\n+        fcx.llretslotptr.get().map(\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, fty.sig.0.output, \"ret_slot\")));\n+\n+    let method_offset_in_vtable =\n+        traits::get_vtable_index_of_object_method(bcx.tcx(),\n+                                                  object_trait_ref.clone(),\n+                                                  trait_id,\n+                                                  method_offset_in_trait);\n+    debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n+           method_offset_in_vtable);\n+\n+    bcx = trans_call_inner(bcx,\n+                           None,\n+                           method_bare_fn_ty,\n+                           |bcx, _| trans_trait_callee_from_llval(bcx,\n+                                                                  method_bare_fn_ty,\n+                                                                  method_offset_in_vtable,\n+                                                                  llobject),\n+                           ArgVals(llargs.as_slice()),\n+                           dest).bcx;\n+\n+    finish_fn(&fcx, bcx, fty.sig.0.output);\n+\n+    llfn\n+}\n+\n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n ///\n@@ -560,6 +695,14 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let llfn = vec![trans_fn_pointer_shim(bcx.ccx(), bare_fn_ty)];\n                 llfn.into_iter()\n             }\n+            traits::VtableObject(ref data) => {\n+                // this would imply that the Self type being erased is\n+                // an object type; this cannot happen because we\n+                // cannot cast an unsized type into a trait object\n+                bcx.sess().bug(\n+                    format!(\"cannot get vtable for an object type: {}\",\n+                            data.repr(bcx.tcx())).as_slice());\n+            }\n             traits::VtableParam => {\n                 bcx.sess().bug(\n                     format!(\"resolved vtable for {} to bad vtable {} in trans\","}, {"sha": "ee859bbe8f52da9d88d5bec1cad4f9113df6f9dc", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -633,17 +633,16 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n               target_trait_def_id: ast::DefId)\n               -> ty::PolyTraitRef<'tcx>\n     {\n-        for super_trait_ref in traits::supertraits(self.tcx(), source_trait_ref.clone()) {\n-            if super_trait_ref.def_id() == target_trait_def_id {\n-                return super_trait_ref;\n+        match traits::upcast(self.tcx(), source_trait_ref.clone(), target_trait_def_id) {\n+            Some(super_trait_ref) => super_trait_ref,\n+            None => {\n+                self.tcx().sess.span_bug(\n+                    self.span,\n+                    format!(\"cannot upcast `{}` to `{}`\",\n+                            source_trait_ref.repr(self.tcx()),\n+                            target_trait_def_id.repr(self.tcx()))[]);\n             }\n         }\n-\n-        self.tcx().sess.span_bug(\n-            self.span,\n-            format!(\"cannot upcast `{}` to `{}`\",\n-                    source_trait_ref.repr(self.tcx()),\n-                    target_trait_def_id.repr(self.tcx()))[]);\n     }\n \n     fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T"}, {"sha": "52860abb6f938acbfd7e0be106e7774625bd1139", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -310,7 +310,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n         self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n             let vtable_index =\n-                get_method_index(tcx, &new_trait_ref, trait_ref.clone(), method_num);\n+                traits::get_vtable_index_of_object_method(tcx,\n+                                                          trait_ref.clone(),\n+                                                          new_trait_ref.def_id(),\n+                                                          method_num);\n \n             let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs());\n \n@@ -999,35 +1002,6 @@ fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n }\n \n-// Determine the index of a method in the list of all methods belonging\n-// to a trait and its supertraits.\n-fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                          trait_ref: &ty::PolyTraitRef<'tcx>,\n-                          subtrait: ty::PolyTraitRef<'tcx>,\n-                          n_method: uint) -> uint {\n-    // We need to figure the \"real index\" of the method in a\n-    // listing of all the methods of an object. We do this by\n-    // iterating down the supertraits of the object's trait until\n-    // we find the trait the method came from, counting up the\n-    // methods from them.\n-    let mut method_count = n_method;\n-    ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n-        if bound_ref.def_id() == trait_ref.def_id() {\n-            false\n-        } else {\n-            let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n-            for trait_item in trait_items.iter() {\n-                match *trait_item {\n-                    ty::MethodTraitItem(_) => method_count += 1,\n-                    ty::TypeTraitItem(_) => {}\n-                }\n-            }\n-            true\n-        }\n-    });\n-    method_count\n-}\n-\n impl<'tcx> Candidate<'tcx> {\n     fn to_unadjusted_pick(&self) -> Pick<'tcx> {\n         Pick {"}, {"sha": "1ef6c1140321846dc53f24970f355a5f0c57af51", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 76, "deletions": 200, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use check::{FnCtxt, structurally_resolved_type};\n-use middle::subst::{FnSpace, SelfSpace};\n-use middle::traits;\n+use middle::traits::{mod, ObjectSafetyViolation, MethodViolationCode};\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n use middle::ty::{mod, Ty, AsPredicate};\n@@ -133,217 +132,56 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  object_trait: &ty::TyTrait<'tcx>,\n                                  span: Span)\n {\n-    // Also check that the type `object_trait` specifies all\n-    // associated types for all supertraits.\n-    let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> = FnvHashSet::new();\n-\n     let object_trait_ref =\n         object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n-    for tr in traits::supertraits(tcx, object_trait_ref.clone()) {\n-        check_object_safety_inner(tcx, &tr, span);\n-\n-        let trait_def = ty::lookup_trait_def(tcx, object_trait_ref.def_id());\n-        for &associated_type_name in trait_def.associated_type_names.iter() {\n-            associated_types.insert((object_trait_ref.def_id(), associated_type_name));\n-        }\n-    }\n \n-    for projection_bound in object_trait.bounds.projection_bounds.iter() {\n-        let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n-                    projection_bound.0.projection_ty.item_name);\n-        associated_types.remove(&pair);\n+    if traits::is_object_safe(tcx, object_trait_ref.clone()) {\n+        return;\n     }\n \n-    for (trait_def_id, name) in associated_types.into_iter() {\n-        tcx.sess.span_err(\n-            span,\n-            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n-                    name.user_string(tcx),\n-                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n-    }\n-}\n-\n-fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                   object_trait: &ty::PolyTraitRef<'tcx>,\n-                                   span: Span) {\n-    let trait_items = ty::trait_items(tcx, object_trait.def_id());\n-\n-    let mut errors = Vec::new();\n-    for item in trait_items.iter() {\n-        match *item {\n-            ty::MethodTraitItem(ref m) => {\n-                errors.push(check_object_safety_of_method(tcx, object_trait, &**m))\n+    span_err!(tcx.sess, span, E0038,\n+              \"cannot convert to a trait object because trait `{}` is not object-safe\",\n+              ty::item_path_str(tcx, object_trait_ref.def_id()));\n+\n+    let violations = traits::object_safety_violations(tcx, object_trait_ref.clone());\n+    for violation in violations.into_iter() {\n+        match violation {\n+            ObjectSafetyViolation::SizedSelf => {\n+                tcx.sess.span_note(\n+                    span,\n+                    \"the trait cannot require that `Self : Sized`\");\n             }\n-            ty::TypeTraitItem(_) => {}\n-        }\n-    }\n-\n-    let mut errors = errors.iter().flat_map(|x| x.iter()).peekable();\n-    if errors.peek().is_some() {\n-        let trait_name = ty::item_path_str(tcx, object_trait.def_id());\n-        span_err!(tcx.sess, span, E0038,\n-            \"cannot convert to a trait object because trait `{}` is not object-safe\",\n-            trait_name);\n-\n-        for msg in errors {\n-            tcx.sess.note(msg[]);\n-        }\n-    }\n \n-    /// Returns a vec of error messages. If the vec is empty - no errors!\n-    ///\n-    /// There are some limitations to calling functions through an object, because (a) the self\n-    /// type is not known (that's the whole point of a trait instance, after all, to obscure the\n-    /// self type), (b) the call must go through a vtable and hence cannot be monomorphized and\n-    /// (c) the trait contains static methods which can't be called because we don't know the\n-    /// concrete type.\n-    fn check_object_safety_of_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                           object_trait: &ty::PolyTraitRef<'tcx>,\n-                                           method: &ty::Method<'tcx>)\n-                                           -> Vec<String> {\n-        let mut msgs = Vec::new();\n-\n-        let method_name = method.name.repr(tcx);\n-\n-        match method.explicit_self {\n-            ty::ByValueExplicitSelfCategory => { // reason (a) above\n-                msgs.push(format!(\"cannot call a method (`{}`) with a by-value \\\n-                                   receiver through a trait object\", method_name))\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::ByValueSelf) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` has a receiver type of `Self`, \\\n+                             which cannot be used with a trait object\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n \n-            ty::StaticExplicitSelfCategory => {\n-                // Static methods are never object safe (reason (c)).\n-                msgs.push(format!(\"cannot call a static method (`{}`) \\\n-                                   through a trait object\",\n-                                  method_name));\n-                return msgs;\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::StaticMethod) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` has no receiver\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n-            ty::ByReferenceExplicitSelfCategory(..) |\n-            ty::ByBoxExplicitSelfCategory => {}\n-        }\n \n-        // reason (a) above\n-        let check_for_self_ty = |&: ty| {\n-            if contains_illegal_self_type_reference(tcx, object_trait.def_id(), ty) {\n-                Some(format!(\n-                    \"cannot call a method (`{}`) whose type contains \\\n-                     a self-type (`{}`) through a trait object\",\n-                    method_name, ty.user_string(tcx)))\n-            } else {\n-                None\n-            }\n-        };\n-        let ref sig = method.fty.sig;\n-        for &input_ty in sig.0.inputs[1..].iter() {\n-            if let Some(msg) = check_for_self_ty(input_ty) {\n-                msgs.push(msg);\n-            }\n-        }\n-        if let ty::FnConverging(result_type) = sig.0.output {\n-            if let Some(msg) = check_for_self_ty(result_type) {\n-                msgs.push(msg);\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::ReferencesSelf) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` references the `Self` type \\\n+                             in its arguments or return type\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n-        }\n-\n-        if method.generics.has_type_params(FnSpace) {\n-            // reason (b) above\n-            msgs.push(format!(\"cannot call a generic method (`{}`) through a trait object\",\n-                              method_name));\n-        }\n-\n-        msgs\n-    }\n \n-    fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                                  trait_def_id: ast::DefId,\n-                                                  ty: Ty<'tcx>)\n-                                                  -> bool\n-    {\n-        // This is somewhat subtle. In general, we want to forbid\n-        // references to `Self` in the argument and return types,\n-        // since the value of `Self` is erased. However, there is one\n-        // exception: it is ok to reference `Self` in order to access\n-        // an associated type of the current trait, since we retain\n-        // the value of those associated types in the object type\n-        // itself.\n-        //\n-        // ```rust\n-        // trait SuperTrait {\n-        //     type X;\n-        // }\n-        //\n-        // trait Trait : SuperTrait {\n-        //     type Y;\n-        //     fn foo(&self, x: Self) // bad\n-        //     fn foo(&self) -> Self // bad\n-        //     fn foo(&self) -> Option<Self> // bad\n-        //     fn foo(&self) -> Self::Y // OK, desugars to next example\n-        //     fn foo(&self) -> <Self as Trait>::Y // OK\n-        //     fn foo(&self) -> Self::X // OK, desugars to next example\n-        //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n-        // }\n-        // ```\n-        //\n-        // However, it is not as simple as allowing `Self` in a projected\n-        // type, because there are illegal ways to use `Self` as well:\n-        //\n-        // ```rust\n-        // trait Trait : SuperTrait {\n-        //     ...\n-        //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n-        // }\n-        // ```\n-        //\n-        // Here we will not have the type of `X` recorded in the\n-        // object type, and we cannot resolve `Self as SomeOtherTrait`\n-        // without knowing what `Self` is.\n-\n-        let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n-        let mut error = false;\n-        ty::maybe_walk_ty(ty, |ty| {\n-            match ty.sty {\n-                ty::ty_param(ref param_ty) => {\n-                    if param_ty.space == SelfSpace {\n-                        error = true;\n-                    }\n-\n-                    false // no contained types to walk\n-                }\n-\n-                ty::ty_projection(ref data) => {\n-                    // This is a projected type `<Foo as SomeTrait>::X`.\n-\n-                    // Compute supertraits of current trait lazilly.\n-                    if supertraits.is_none() {\n-                        let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n-                        let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n-                        supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n-                    }\n-\n-                    // Determine whether the trait reference `Foo as\n-                    // SomeTrait` is in fact a supertrait of the\n-                    // current trait. In that case, this type is\n-                    // legal, because the type `X` will be specified\n-                    // in the object type.  Note that we can just use\n-                    // direct equality here because all of these types\n-                    // are part of the formal parameter listing, and\n-                    // hence there should be no inference variables.\n-                    let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n-                    let is_supertrait_of_current_trait =\n-                        supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n-\n-                    if is_supertrait_of_current_trait {\n-                        false // do not walk contained types, do not report error, do collect $200\n-                    } else {\n-                        true // DO walk contained types, POSSIBLY reporting an error\n-                    }\n-                }\n-\n-                _ => true, // walk contained types, if any\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::Generic) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` has generic type parameters\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n-        });\n-\n-        error\n+        }\n     }\n }\n \n@@ -392,7 +230,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             cause.clone());\n     }\n \n-    // Finally, create obligations for the projection predicates.\n+    // Create obligations for the projection predicates.\n     let projection_bounds =\n         object_trait.projection_bounds_with_self_ty(fcx.tcx(), referent_ty);\n     for projection_bound in projection_bounds.iter() {\n@@ -401,9 +239,47 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.register_predicate(projection_obligation);\n     }\n \n+    // Finally, check that there IS a projection predicate for every associated type.\n+    check_object_type_binds_all_associated_types(fcx.tcx(),\n+                                                 span,\n+                                                 object_trait);\n+\n     object_trait_ref\n }\n \n+fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                      span: Span,\n+                                                      object_trait: &ty::TyTrait<'tcx>)\n+{\n+    let object_trait_ref =\n+        object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n+\n+    let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> =\n+        traits::supertraits(tcx, object_trait_ref.clone())\n+        .flat_map(|tr| {\n+            let trait_def = ty::lookup_trait_def(tcx, tr.def_id());\n+            trait_def.associated_type_names\n+                .clone()\n+                .into_iter()\n+                .map(move |associated_type_name| (tr.def_id(), associated_type_name))\n+        })\n+        .collect();\n+\n+    for projection_bound in object_trait.bounds.projection_bounds.iter() {\n+        let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n+                    projection_bound.0.projection_ty.item_name);\n+        associated_types.remove(&pair);\n+    }\n+\n+    for (trait_def_id, name) in associated_types.into_iter() {\n+        tcx.sess.span_err(\n+            span,\n+            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n+                    name.user_string(tcx),\n+                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n+    }\n+}\n+\n pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     debug!(\"select_all_fcx_obligations_or_error\");\n "}, {"sha": "fe61b3de2cf6f0c5253620ed5521236c7466b87f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -843,6 +843,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let bounds = compute_bounds(ccx,\n                                 self_param_ty.to_ty(ccx.tcx),\n                                 bounds.as_slice(),\n+                                SizedByDefault::No,\n                                 it.span);\n \n     let associated_type_names: Vec<_> =\n@@ -1098,6 +1099,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let bounds = compute_bounds(ccx,\n                                             assoc_ty,\n                                             assoc_type_def.bounds.as_slice(),\n+                                            SizedByDefault::Yes,\n                                             assoc_type_def.span);\n \n                 ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n@@ -1306,6 +1308,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n     let bounds = compute_bounds(this,\n                                 param_ty.to_ty(this.tcx()),\n                                 param.bounds[],\n+                                SizedByDefault::Yes,\n                                 param.span);\n     let default = match param.default {\n         None => None,\n@@ -1342,29 +1345,35 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n     def\n }\n \n+enum SizedByDefault { Yes, No }\n+\n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n fn compute_bounds<'tcx,AC>(this: &AC,\n                            param_ty: ty::Ty<'tcx>,\n                            ast_bounds: &[ast::TyParamBound],\n+                           sized_by_default: SizedByDefault,\n                            span: Span)\n                            -> ty::ParamBounds<'tcx>\n-                           where AC: AstConv<'tcx> {\n+                           where AC: AstConv<'tcx>\n+{\n     let mut param_bounds = conv_param_bounds(this,\n                                              span,\n                                              param_ty,\n                                              ast_bounds);\n \n-    add_unsized_bound(this,\n-                      &mut param_bounds.builtin_bounds,\n-                      ast_bounds,\n-                      span);\n+    if let SizedByDefault::Yes = sized_by_default {\n+        add_unsized_bound(this,\n+                          &mut param_bounds.builtin_bounds,\n+                          ast_bounds,\n+                          span);\n \n-    check_bounds_compatible(this.tcx(),\n-                            param_ty,\n-                            &param_bounds,\n-                            span);\n+        check_bounds_compatible(this.tcx(),\n+                                param_ty,\n+                                &param_bounds,\n+                                span);\n+    }\n \n     param_bounds.trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n "}, {"sha": "4f277cc868a1a04873ed3abbcbc2a04e57e689ae", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -12,7 +12,7 @@ use clean::*;\n use std::iter::Extend;\n use std::mem::{replace, swap};\n \n-pub trait DocFolder {\n+pub trait DocFolder : Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         self.fold_item_recur(item)\n     }"}, {"sha": "8f7de1c4dca8cab65c32a5e1169d03906bf9f591", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -232,6 +232,7 @@ use error::{FromError, Error};\n use fmt;\n use int;\n use iter::{Iterator, IteratorExt};\n+use kinds::Sized;\n use mem::transmute;\n use ops::FnOnce;\n use option::Option;\n@@ -1030,11 +1031,25 @@ pub trait Writer {\n     fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> {\n         // Create a shim which translates a Writer to a fmt::Writer and saves\n         // off I/O errors. instead of discarding them\n-        struct Adaptor<'a, T:'a> {\n+        struct Adaptor<'a, Sized? T:'a> {\n             inner: &'a mut T,\n             error: IoResult<()>,\n         }\n \n+        #[cfg(not(stage0))]\n+        impl<'a, Sized? T: Writer> fmt::Writer for Adaptor<'a, T> {\n+            fn write_str(&mut self, s: &str) -> fmt::Result {\n+                match self.inner.write(s.as_bytes()) {\n+                    Ok(()) => Ok(()),\n+                    Err(e) => {\n+                        self.error = Err(e);\n+                        Err(fmt::Error)\n+                    }\n+                }\n+            }\n+        }\n+\n+        #[cfg(stage0)]\n         impl<'a, T: Writer> fmt::Writer for Adaptor<'a, T> {\n             fn write_str(&mut self, s: &str) -> fmt::Result {\n                 match self.inner.write(s.as_bytes()) {\n@@ -1629,16 +1644,24 @@ pub trait Acceptor<T> {\n /// `Some`. The `Some` contains the `IoResult` representing whether the\n /// connection attempt was successful.  A successful connection will be wrapped\n /// in `Ok`. A failed connection is represented as an `Err`.\n-pub struct IncomingConnections<'a, A:'a> {\n+pub struct IncomingConnections<'a, Sized? A:'a> {\n     inc: &'a mut A,\n }\n \n+#[cfg(stage0)]\n impl<'a, T, A: Acceptor<T>> Iterator<IoResult<T>> for IncomingConnections<'a, A> {\n     fn next(&mut self) -> Option<IoResult<T>> {\n         Some(self.inc.accept())\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a, T, Sized? A: Acceptor<T>> Iterator<IoResult<T>> for IncomingConnections<'a, A> {\n+    fn next(&mut self) -> Option<IoResult<T>> {\n+        Some(self.inc.accept())\n+    }\n+}\n+\n /// Creates a standard error for a commonly used flavor of error. The `detail`\n /// field of the returned error will always be `None`.\n ///"}, {"sha": "3d3068f6868c6a3c5c850a542e8a2445e5f55f1b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -53,7 +53,7 @@ impl<T> MoveMap<T> for OwnedSlice<T> {\n     }\n }\n \n-pub trait Folder {\n+pub trait Folder : Sized {\n     // Any additions to this trait should happen in form\n     // of a call to a public `noop_*` function that only calls\n     // out to the folder again, not other `noop_*` functions."}, {"sha": "a1fe63e3f6fcd27af7d9fb981c0f5d2bd7432f8e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -54,8 +54,7 @@ pub enum FnKind<'a> {\n /// explicitly, you need to override each method.  (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n-pub trait Visitor<'v> {\n-\n+pub trait Visitor<'v> : Sized {\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }"}, {"sha": "eb4d62b01ad1a07189e9ef766b199ae1f156e1eb", "filename": "src/test/auxiliary/method_self_arg2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -32,7 +32,7 @@ impl Foo {\n     }\n }\n \n-pub trait Bar {\n+pub trait Bar : Sized {\n     fn foo1(&self);\n     fn foo2(self);\n     fn foo3(self: Box<Self>);"}, {"sha": "ea5becbf229c0e0aca0c1602e6e953783ac0b467", "filename": "src/test/compile-fail/dst-sized-trait-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fdst-sized-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fdst-sized-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-sized-trait-param.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -12,7 +12,7 @@\n // parameter, the corresponding value must be sized. Also that the\n // self type must be sized if appropriate.\n \n-trait Foo<T> { fn take(self, x: &T) { } } // Note: T is sized\n+trait Foo<T> : Sized { fn take(self, x: &T) { } } // Note: T is sized\n \n impl Foo<[int]> for uint { }\n //~^ ERROR the trait `core::kinds::Sized` is not implemented for the type `[int]`"}, {"sha": "1a792eb6e76aedacc37ded3d389835d73f060221", "filename": "src/test/compile-fail/issue-18959.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -21,6 +21,6 @@ impl Foo for Thing {\n \n fn main() {\n     let mut thing = Thing;\n-    let test: &Bar = &mut thing; //~ ERROR cannot convert to a trait object because trait `Foo`\n+    let test: &Bar = &mut thing; //~ ERROR cannot convert to a trait object\n     foo(test);\n }"}, {"sha": "f970cdb1b8304c6b797ae3f3333ea231d9331470", "filename": "src/test/compile-fail/issue-5543.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -15,5 +15,4 @@ fn main() {\n     let r: Box<Foo> = box 5;\n     let _m: Box<Foo> = r as Box<Foo>;\n     //~^ ERROR `core::kinds::Sized` is not implemented for the type `Foo`\n-    //~| ERROR `Foo` is not implemented for the type `Foo`\n }"}, {"sha": "5ebcc8516ca0516610c34ab2d470b2674c8c7136", "filename": "src/test/compile-fail/object-safety-by-value-self.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we correctly prevent users from making trait objects\n+// from traits with a `fn(self)` method.\n+\n+trait Bar {\n+    fn bar(self);\n+}\n+\n+trait Baz {\n+    fn baz(self: Self);\n+}\n+\n+fn make_bar<T:Bar>(t: &T) -> &Bar {\n+    t\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` has a receiver type of `Self`\n+}\n+\n+fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    t as &Bar\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` has a receiver type of `Self`\n+}\n+\n+fn make_baz<T:Baz>(t: &T) -> &Baz {\n+    t\n+        //~^ ERROR `Baz` is not object-safe\n+        //~| NOTE method `baz` has a receiver type of `Self`\n+}\n+\n+fn make_baz_explicit<T:Baz>(t: &T) -> &Baz {\n+    t as &Baz\n+        //~^ ERROR `Baz` is not object-safe\n+        //~| NOTE method `baz` has a receiver type of `Self`\n+}\n+\n+fn main() {\n+}"}, {"sha": "0ca706404c1f309028b36775d7d3d16daa237841", "filename": "src/test/compile-fail/object-safety-generics.rs", "status": "renamed", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -8,11 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Check that we correctly prevent users from making trait objects\n+// from traits with generic methods.\n \n-trait Foo {\n-    fn foo(self: Box<Self>) { bar(self as Box<Foo>); }\n+trait Bar {\n+    fn bar<T>(&self, t: T);\n }\n \n-fn bar(_b: Box<Foo>) { }\n+fn make_bar<T:Bar>(t: &T) -> &Bar {\n+    t\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` has generic type parameters\n+}\n+\n+fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    t as &Bar\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` has generic type parameters\n+}\n \n-fn main() {}\n+fn main() {\n+}", "previous_filename": "src/test/run-pass/issue-7320.rs"}, {"sha": "df0f44c1391580898084e7484bf3d06e75686225", "filename": "src/test/compile-fail/object-safety-mentions-Self.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we correctly prevent users from making trait objects\n+// form traits that make use of `Self` in an argument or return position.\n+\n+trait Bar {\n+    fn bar(&self, x: &Self);\n+}\n+\n+trait Baz {\n+    fn bar(&self) -> Self;\n+}\n+\n+fn make_bar<T:Bar>(t: &T) -> &Bar {\n+    t\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+}\n+\n+fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    t as &Bar\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+}\n+\n+fn make_baz<T:Baz>(t: &T) -> &Baz {\n+    t\n+        //~^ ERROR `Baz` is not object-safe\n+        //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+}\n+\n+fn make_baz_explicit<T:Baz>(t: &T) -> &Baz {\n+    t as &Baz\n+        //~^ ERROR `Baz` is not object-safe\n+        //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+}\n+\n+fn main() {\n+}"}, {"sha": "6a010d49692d26450a4d95225eb3695c4509b0cd", "filename": "src/test/compile-fail/object-safety-no-static.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we correctly prevent users from making trait objects\n+// from traits with static methods.\n+\n+trait Foo {\n+    fn foo();\n+}\n+\n+fn foo_implicit<T:Foo+'static>(b: Box<T>) -> Box<Foo+'static> {\n+    b\n+        //~^ ERROR cannot convert to a trait object\n+        //~| NOTE method `foo` has no receiver\n+}\n+\n+fn foo_explicit<T:Foo+'static>(b: Box<T>) -> Box<Foo+'static> {\n+    b as Box<Foo>\n+        //~^ ERROR cannot convert to a trait object\n+        //~| NOTE method `foo` has no receiver\n+}\n+\n+fn main() {\n+}"}, {"sha": "3a02461bbb223c177d43599f8d74abf380e1cb01", "filename": "src/test/compile-fail/object-safety-sized-2.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we correctly prevent users from making trait objects\n+// from traits where `Self : Sized`.\n+\n+trait Bar\n+    where Self : Sized\n+{\n+    fn bar<T>(&self, t: T);\n+}\n+\n+fn make_bar<T:Bar>(t: &T) -> &Bar {\n+    t\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE the trait cannot require that `Self : Sized`\n+}\n+\n+fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    t as &Bar\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE the trait cannot require that `Self : Sized`\n+}\n+\n+fn main() {\n+}"}, {"sha": "bc214f6f3d9623ca30c1fcc8257b5cb68143c810", "filename": "src/test/compile-fail/object-safety-sized.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we correctly prevent users from making trait objects\n+// from traits where `Self : Sized`.\n+\n+trait Bar : Sized {\n+    fn bar<T>(&self, t: T);\n+}\n+\n+fn make_bar<T:Bar>(t: &T) -> &Bar {\n+    t\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE the trait cannot require that `Self : Sized`\n+}\n+\n+fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    t as &Bar\n+        //~^ ERROR `Bar` is not object-safe\n+        //~| NOTE the trait cannot require that `Self : Sized`\n+}\n+\n+fn main() {\n+}"}, {"sha": "aeb003ca5d091047daa90fbc0e7bb007c9bfb46a", "filename": "src/test/compile-fail/regions-infer-bound-from-trait-self.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fregions-infer-bound-from-trait-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Fregions-infer-bound-from-trait-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-bound-from-trait-self.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -23,12 +23,12 @@ fn check_bound<'a,A:'a>(x: Inv<'a>, a: A) { }\n \n // In these case, `Self` inherits `'static`.\n \n-trait InheritsFromStatic : 'static {\n+trait InheritsFromStatic : Sized + 'static {\n     fn foo1<'a>(self, x: Inv<'a>) {\n         check_bound(x, self)\n     }\n }\n-trait InheritsFromStaticIndirectly : Static {\n+trait InheritsFromStaticIndirectly : Sized + Static {\n     fn foo1<'a>(self, x: Inv<'a>) {\n         check_bound(x, self)\n     }\n@@ -37,21 +37,21 @@ trait InheritsFromStaticIndirectly : Static {\n \n // In these case, `Self` inherits `'a`.\n \n-trait InheritsFromIs<'a> : 'a {\n+trait InheritsFromIs<'a> : Sized + 'a {\n     fn foo(self, x: Inv<'a>) {\n         check_bound(x, self)\n     }\n }\n \n-trait InheritsFromIsIndirectly<'a> : Is<'a> {\n+trait InheritsFromIsIndirectly<'a> : Sized + Is<'a> {\n     fn foo(self, x: Inv<'a>) {\n         check_bound(x, self)\n     }\n }\n \n // In this case, `Self` inherits nothing.\n \n-trait InheritsFromNothing<'a> {\n+trait InheritsFromNothing<'a> : Sized {\n     fn foo(self, x: Inv<'a>) {\n         check_bound(x, self)\n             //~^ ERROR parameter type `Self` may not live long enough"}, {"sha": "333730e0c4b802c62bf7d3a341a2f6ea17594cfe", "filename": "src/test/compile-fail/trait-matching-lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Ftrait-matching-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Ftrait-matching-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-matching-lifetimes.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -16,7 +16,7 @@ struct Foo<'a,'b> {\n     y: &'b int,\n }\n \n-trait Tr {\n+trait Tr : Sized {\n     fn foo(x: Self) {}\n }\n "}, {"sha": "88b907a5cb965538e59ece6e7977b932861b1016", "filename": "src/test/compile-fail/trait-objects.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e921e3f04513ffb094208a538a2835d4dc77b991/src%2Ftest%2Fcompile-fail%2Ftrait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921e3f04513ffb094208a538a2835d4dc77b991/src%2Ftest%2Fcompile-fail%2Ftrait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-objects.rs?ref=e921e3f04513ffb094208a538a2835d4dc77b991", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait Foo {\n-    fn foo(self);\n-}\n-\n-trait Bar {\n-    fn bar(&self, x: &Self);\n-}\n-\n-trait Baz {\n-    fn baz<T>(&self, x: &T);\n-}\n-\n-impl Foo for int {\n-    fn foo(self) {}\n-}\n-\n-impl Bar for int {\n-    fn bar(&self, _x: &int) {}\n-}\n-\n-impl Baz for int {\n-    fn baz<T>(&self, _x: &T) {}\n-}\n-\n-fn main() {\n-    let _: &Foo = &42i; //~ ERROR cannot convert to a trait object\n-    let _: &Bar = &42i; //~ ERROR cannot convert to a trait object\n-    let _: &Baz = &42i; //~ ERROR cannot convert to a trait object\n-\n-    let _ = &42i as &Foo; //~ ERROR cannot convert to a trait object\n-    let _ = &42i as &Bar; //~ ERROR cannot convert to a trait object\n-    let _ = &42i as &Baz; //~ ERROR cannot convert to a trait object\n-}"}, {"sha": "f894e2ee28e2f9327fa8ae8eb3ec522d99bd3f46", "filename": "src/test/compile-fail/trait-safety-fn-body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Ftrait-safety-fn-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Ftrait-safety-fn-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-safety-fn-body.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -11,7 +11,7 @@\n // Check that an unsafe impl does not imply that unsafe actions are\n // legal in the methods.\n \n-unsafe trait UnsafeTrait {\n+unsafe trait UnsafeTrait : Sized {\n     fn foo(self) { }\n }\n "}, {"sha": "3a4cc9e874e7d2d0f91da799ebfb9f2d4cc570dd", "filename": "src/test/compile-fail/type-params-in-different-spaces-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -11,7 +11,7 @@\n // Test static calls to make sure that we align the Self and input\n // type parameters on a trait correctly.\n \n-trait Tr<T> {\n+trait Tr<T> : Sized {\n     fn op(T) -> Self;\n }\n "}, {"sha": "c113e1b7815212a6f39bd9433095aee0d77c91c8", "filename": "src/test/compile-fail/type-params-in-different-spaces-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-3.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Tr {\n+trait Tr : Sized {\n     fn test<X>(u: X) -> Self {\n         u   //~ ERROR mismatched types\n     }"}, {"sha": "f9ece8e6843db8756d0c6cbd4a80d4d28d229577", "filename": "src/test/compile-fail/unsized4.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized4.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -10,8 +10,7 @@\n \n // Test that bounds are sized-compatible.\n \n-trait T {}\n-\n+trait T : Sized {}\n fn f<Sized? Y: T>() {\n //~^ERROR incompatible bounds on `Y`, bound `T` does not allow unsized type\n }"}, {"sha": "94458a7fb4bccbce7c95a7d20f8d1fb78dc27502", "filename": "src/test/debuginfo/issue7712.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fdebuginfo%2Fissue7712.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fdebuginfo%2Fissue7712.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue7712.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -11,7 +11,7 @@\n // compile-flags:--debuginfo=1\n // min-lldb-version: 310\n \n-pub trait TraitWithDefaultMethod {\n+pub trait TraitWithDefaultMethod : Sized {\n     fn method(self) {\n         ()\n     }"}, {"sha": "87884d2f95629b41ae0afa6ea0451e2fcf9bff01", "filename": "src/test/debuginfo/self-in-default-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -118,7 +118,7 @@ struct Struct {\n     x: int\n }\n \n-trait Trait {\n+trait Trait : Sized {\n     fn self_by_ref(&self, arg1: int, arg2: int) -> int {\n         zzz(); // #break\n         arg1 + arg2"}, {"sha": "62b5e6872ee4986d567b0525a21a185210262507", "filename": "src/test/debuginfo/self-in-generic-default-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -118,7 +118,7 @@ struct Struct {\n     x: int\n }\n \n-trait Trait {\n+trait Trait : Sized {\n \n     fn self_by_ref<T>(&self, arg1: int, arg2: T) -> int {\n         zzz(); // #break"}, {"sha": "ce7f5dde2ad194e355052db804eef23f90ccde09", "filename": "src/test/run-pass/associated-types-impl-redirect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fassociated-types-impl-redirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fassociated-types-impl-redirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-impl-redirect.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -19,6 +19,7 @@\n #![feature(associated_types, lang_items, unboxed_closures)]\n #![no_implicit_prelude]\n \n+use std::kinds::Sized;\n use std::option::Option::{None, Some, mod};\n \n trait Iterator {\n@@ -27,7 +28,7 @@ trait Iterator {\n     fn next(&mut self) -> Option<Self::Item>;\n }\n \n-trait IteratorExt: Iterator {\n+trait IteratorExt: Iterator + Sized {\n     fn by_ref(&mut self) -> ByRef<Self> {\n         ByRef(self)\n     }"}, {"sha": "92daee5225d01729edcd8fc88f28e658fa65f47c", "filename": "src/test/run-pass/associated-types-projection-bound-in-supertraits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fassociated-types-projection-bound-in-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fassociated-types-projection-bound-in-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-projection-bound-in-supertraits.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -21,7 +21,7 @@ trait Not {\n     fn not(self) -> Self::Result;\n }\n \n-trait Int: Not<Result=Self> {\n+trait Int: Not<Result=Self> + Sized {\n     fn count_ones(self) -> uint;\n     fn count_zeros(self) -> uint {\n         // neither works"}, {"sha": "7afaf290424af80ee490be278535a62b3eecf59d", "filename": "src/test/run-pass/associated-types-where-clause-impl-ambiguity.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fassociated-types-where-clause-impl-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fassociated-types-where-clause-impl-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-where-clause-impl-ambiguity.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -19,6 +19,7 @@\n #![feature(associated_types, lang_items, unboxed_closures)]\n #![no_implicit_prelude]\n \n+use std::kinds::Sized;\n use std::option::Option::{None, Some, mod};\n \n trait Iterator {\n@@ -27,7 +28,7 @@ trait Iterator {\n     fn next(&mut self) -> Option<Self::Item>;\n }\n \n-trait IteratorExt: Iterator {\n+trait IteratorExt: Iterator + Sized {\n     fn by_ref(&mut self) -> ByRef<Self> {\n         ByRef(self)\n     }"}, {"sha": "bf8d303f34174941d2281a97bb9f5abafd77a654", "filename": "src/test/run-pass/bug-7183-generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Speak {\n+trait Speak : Sized {\n     fn say(&self, s:&str) -> String;\n     fn hi(&self) -> String { hello(self) }\n }"}, {"sha": "d0db2542ccc60593c19bce89d0386bc5ff12c327", "filename": "src/test/run-pass/builtin-superkinds-self-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -13,7 +13,7 @@\n \n use std::sync::mpsc::{Sender, channel};\n \n-trait Foo : Send {\n+trait Foo : Send + Sized {\n     fn foo(self, tx: Sender<Self>) {\n         tx.send(self).unwrap();\n     }"}, {"sha": "727cada21fa66549304cf788e1fbed9b4c3841d5", "filename": "src/test/run-pass/default-method-supertrait-vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fdefault-method-supertrait-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fdefault-method-supertrait-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault-method-supertrait-vtable.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -21,7 +21,7 @@ trait Y {\n }\n \n \n-trait Z: Y {\n+trait Z: Y + Sized {\n     fn x(self) -> int {\n         require_y(self)\n     }"}, {"sha": "3238c24163e17578ae572e570ae4ad02a3e779b6", "filename": "src/test/run-pass/issue-8171-default-method-self-inherit-builtin-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fissue-8171-default-method-self-inherit-builtin-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fissue-8171-default-method-self-inherit-builtin-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8171-default-method-self-inherit-builtin-trait.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -16,7 +16,7 @@\n \n fn require_send<T: Send>(_: T){}\n \n-trait TragicallySelfIsNotSend: Send {\n+trait TragicallySelfIsNotSend: Send + Sized {\n     fn x(self) {\n         require_send(self);\n     }"}, {"sha": "29d100beb064f7c2161b9f69f59c2a044fb6e3b2", "filename": "src/test/run-pass/method-self-arg-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fmethod-self-arg-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fmethod-self-arg-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-self-arg-trait.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -16,7 +16,7 @@ struct Foo;\n \n impl Copy for Foo {}\n \n-trait Bar {\n+trait Bar : Sized {\n     fn foo1(&self);\n     fn foo2(self);\n     fn foo3(self: Box<Self>);"}, {"sha": "bced8012b683245de468dd792897230d304dffa8", "filename": "src/test/run-pass/self-in-mut-slot-default-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-default-method.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -13,7 +13,7 @@ struct X {\n     a: int\n }\n \n-trait Changer {\n+trait Changer : Sized {\n     fn change(mut self) -> Self {\n         self.set_to(55);\n         self"}, {"sha": "2dec53cc13afb8a216a3474f49c81e3b6646a6f3", "filename": "src/test/run-pass/unboxed-closures-call-sugar-object.rs", "status": "renamed", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Funboxed-closures-call-sugar-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459b1dcedc5b0cb195c2494beda56b87105a980/src%2Ftest%2Frun-pass%2Funboxed-closures-call-sugar-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-call-sugar-object.rs?ref=4459b1dcedc5b0cb195c2494beda56b87105a980", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,19 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Check that object-safe methods are identified as such.\n+#![feature(unboxed_closures)]\n \n-trait Tr {\n-    fn foo(&self);\n-}\n-\n-struct St;\n+use std::ops::FnMut;\n \n-impl Tr for St {\n-    fn foo(&self) {}\n+fn make_adder(x: int) -> Box<FnMut(int)->int + 'static> {\n+    box move |y| { x + y }\n }\n \n-fn main() {\n-    let s: &Tr = &St;\n-    s.foo();\n+pub fn main() {\n+    let mut adder = make_adder(3);\n+    let z = (*adder)(2);\n+    println!(\"{}\", z);\n+    assert_eq!(z, 5);\n }\n+", "previous_filename": "src/test/run-pass/trait-object-safety.rs"}]}