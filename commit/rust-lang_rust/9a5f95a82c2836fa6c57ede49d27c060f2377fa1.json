{"sha": "9a5f95a82c2836fa6c57ede49d27c060f2377fa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNWY5NWE4MmMyODM2ZmE2YzU3ZWRlNDlkMjdjMDYwZjIzNzdmYTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-28T09:22:45Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-12T07:36:54Z"}, "message": "Implement a format_args!() macro\n\nThe purpose of this macro is to further reduce the number of allocations which\noccur when dealing with formatting strings. This macro will perform all of the\nstatic analysis necessary to validate that a format string is safe, and then it\nwill wrap up the \"format string\" into an opaque struct which can then be passed\naround.\n\nTwo safe functions are added (write/format) which take this opaque argument\nstructure, unwrap it, and then call the unsafe version of write/format (in an\nunsafe block). Other than these two functions, it is not intended for anyone to\never look inside this opaque struct.\n\nThe macro looks a bit odd, but mostly because of rvalue lifetimes this is the\nonly way for it to be safe that I know of.\n\nExample use-cases of this are:\n\n* third-party libraries can use the default formatting syntax without any\n  forced allocations\n* the fail!() macro can avoid allocating the format string\n* the logging macros can avoid allocation any strings", "tree": {"sha": "a6548120a917b0a1eaa9afe5cb9595e5c96c377c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6548120a917b0a1eaa9afe5cb9595e5c96c377c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a5f95a82c2836fa6c57ede49d27c060f2377fa1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a5f95a82c2836fa6c57ede49d27c060f2377fa1", "html_url": "https://github.com/rust-lang/rust/commit/9a5f95a82c2836fa6c57ede49d27c060f2377fa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62166611e7510b86f395dbf19973e442fd43c403", "url": "https://api.github.com/repos/rust-lang/rust/commits/62166611e7510b86f395dbf19973e442fd43c403", "html_url": "https://github.com/rust-lang/rust/commit/62166611e7510b86f395dbf19973e442fd43c403"}], "stats": {"total": 316, "additions": 234, "deletions": 82}, "files": [{"sha": "c7ab508ea6ec67dbf0a318989bd698008a64d8d3", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 75, "deletions": 16, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=9a5f95a82c2836fa6c57ede49d27c060f2377fa1", "patch": "@@ -36,7 +36,7 @@ Some examples of the `format!` extension are:\n format!(\"Hello\")                  // => ~\"Hello\"\n format!(\"Hello, {:s}!\", \"world\")  // => ~\"Hello, world!\"\n format!(\"The number is {:d}\", 1)  // => ~\"The number is 1\"\n-format!(\"{}\", ~[3, 4])            // => ~\"~[3, 4]\"\n+format!(\"{:?}\", ~[3, 4])          // => ~\"~[3, 4]\"\n format!(\"{value}\", value=4)       // => ~\"4\"\n format!(\"{} {}\", 1, 2)            // => ~\"1 2\"\n ~~~\n@@ -363,6 +363,32 @@ pub struct Argument<'self> {\n     priv value: &'self util::Void,\n }\n \n+impl<'self> Arguments<'self> {\n+    /// When using the format_args!() macro, this function is used to generate the\n+    /// Arguments structure. The compiler inserts an `unsafe` block to call this,\n+    /// which is valid because the compiler performs all necessary validation to\n+    /// ensure that the resulting call to format/write would be safe.\n+    #[doc(hidden)] #[inline]\n+    pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],\n+                          args: &'a [Argument<'a>]) -> Arguments<'a> {\n+        Arguments{ fmt: cast::transmute(fmt), args: args }\n+    }\n+}\n+\n+/// This structure represents a safely precompiled version of a format string\n+/// and its arguments. This cannot be generated at runtime because it cannot\n+/// safely be done so, so no constructors are given and the fields are private\n+/// to prevent modification.\n+///\n+/// The `format_args!` macro will safely create an instance of this structure\n+/// and pass it to a user-supplied function. The macro validates the format\n+/// string at compile-time so usage of the `write` and `format` functions can\n+/// be safely performed.\n+pub struct Arguments<'self> {\n+    priv fmt: &'self [rt::Piece<'self>],\n+    priv args: &'self [Argument<'self>],\n+}\n+\n /// When a format is not otherwise specified, types are formatted by ascribing\n /// to this trait. There is not an explicit way of selecting this trait to be\n /// used for formatting, it is only if no other format is specified.\n@@ -410,6 +436,26 @@ pub trait Float { fn fmt(&Self, &mut Formatter); }\n /// and a list of arguments. The arguments will be formatted according to the\n /// specified format string into the output stream provided.\n ///\n+/// # Arguments\n+///\n+///   * output - the buffer to write output to\n+///   * args - the precompiled arguments generated by `format_args!`\n+///\n+/// # Example\n+///\n+/// ~~~{.rust}\n+/// use std::fmt;\n+/// let w: &mut io::Writer = ...;\n+/// format_args!(|args| { fmt::write(w, args) }, \"Hello, {}!\", \"world\");\n+/// ~~~\n+pub fn write(output: &mut io::Writer, args: &Arguments) {\n+    unsafe { write_unsafe(output, args.fmt, args.args) }\n+}\n+\n+/// The `write_unsafe` function takes an output stream, a precompiled format\n+/// string, and a list of arguments. The arguments will be formatted according\n+/// to the specified format string into the output stream provided.\n+///\n /// See the documentation for `format` for why this function is unsafe and care\n /// should be taken if calling it manually.\n ///\n@@ -426,8 +472,9 @@ pub trait Float { fn fmt(&Self, &mut Formatter); }\n ///\n /// Note that this function assumes that there are enough arguments for the\n /// format string.\n-pub unsafe fn write(output: &mut io::Writer,\n-                    fmt: &[rt::Piece], args: &[Argument]) {\n+pub unsafe fn write_unsafe(output: &mut io::Writer,\n+                           fmt: &[rt::Piece],\n+                           args: &[Argument]) {\n     let mut formatter = Formatter {\n         flags: 0,\n         width: None,\n@@ -446,6 +493,25 @@ pub unsafe fn write(output: &mut io::Writer,\n /// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n ///\n+/// # Arguments\n+///\n+///   * args - a structure of arguments generated via the `format_args!` macro.\n+///            Because this structure can only be safely generated at\n+///            compile-time, this function is safe.\n+///\n+/// # Example\n+///\n+/// ~~~{.rust}\n+/// use std::fmt;\n+/// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n+/// assert_eq!(s, \"Hello, world!\");\n+/// ~~~\n+pub fn format(args: &Arguments) -> ~str {\n+    unsafe { format_unsafe(args.fmt, args.args) }\n+}\n+\n+/// The unsafe version of the formatting function.\n+///\n /// This is currently an unsafe function because the types of all arguments\n /// aren't verified by immediate callers of this function. This currently does\n /// not validate that the correct types of arguments are specified for each\n@@ -465,9 +531,9 @@ pub unsafe fn write(output: &mut io::Writer,\n ///\n /// Note that this function assumes that there are enough arguments for the\n /// format string.\n-pub unsafe fn format(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n+pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n     let mut output = MemWriter::new();\n-    write(&mut output as &mut io::Writer, fmt, args);\n+    write_unsafe(&mut output as &mut io::Writer, fmt, args);\n     return str::from_utf8_owned(output.inner());\n }\n \n@@ -740,7 +806,7 @@ impl<'self> Formatter<'self> {\n \n /// This is a function which calls are emitted to by the compiler itself to\n /// create the Argument structures that are passed into the `format` function.\n-#[doc(hidden)]\n+#[doc(hidden)] #[inline]\n pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter),\n                        t: &'a T) -> Argument<'a> {\n     unsafe {\n@@ -753,14 +819,14 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter),\n \n /// When the compiler determines that the type of an argument *must* be a string\n /// (such as for select), then it invokes this method.\n-#[doc(hidden)]\n+#[doc(hidden)] #[inline]\n pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n     argument(String::fmt, s)\n }\n \n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for plural), then it invokes this method.\n-#[doc(hidden)]\n+#[doc(hidden)] #[inline]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n     argument(Unsigned::fmt, s)\n }\n@@ -899,14 +965,8 @@ impl<T> Pointer for *T {\n         }\n     }\n }\n-\n impl<T> Pointer for *mut T {\n-    fn fmt(t: &*mut T, f: &mut Formatter) {\n-        f.flags |= 1 << (parse::FlagAlternate as uint);\n-        do ::uint::to_str_bytes(*t as uint, 16) |buf| {\n-            f.pad_integral(buf, \"0x\", true);\n-        }\n-    }\n+    fn fmt(t: &*mut T, f: &mut Formatter) { Pointer::fmt(&(*t as *T), f) }\n }\n \n // Implementation of Default for various core types\n@@ -940,7 +1000,6 @@ delegate!(f64 to Float)\n impl<T> Default for *T {\n     fn fmt(me: &*T, f: &mut Formatter) { Pointer::fmt(me, f) }\n }\n-\n impl<T> Default for *mut T {\n     fn fmt(me: &*mut T, f: &mut Formatter) { Pointer::fmt(me, f) }\n }"}, {"sha": "284801ab123c923f7e038b92742b466e656f58bf", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9a5f95a82c2836fa6c57ede49d27c060f2377fa1", "patch": "@@ -161,6 +161,8 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                             builtin_normal_tt_no_ctxt(ext::ifmt::expand_write));\n     syntax_expanders.insert(intern(&\"writeln\"),\n                             builtin_normal_tt_no_ctxt(ext::ifmt::expand_writeln));\n+    syntax_expanders.insert(intern(&\"format_args\"),\n+                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_format_args));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));"}, {"sha": "2f040ef251923583e737c5f8c3115e569449e637", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 106, "deletions": 61, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=9a5f95a82c2836fa6c57ede49d27c060f2377fa1", "patch": "@@ -60,7 +60,7 @@ impl Context {\n         let p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n                                              self.ecx.cfg(),\n                                              tts.to_owned());\n-        // If we want a leading expression (for ifmtf), parse it here\n+        // If we want a leading expression, parse it here\n         let extra = if leading_expr {\n             let e = Some(p.parse_expr());\n             if !p.eat(&token::COMMA) {\n@@ -341,12 +341,18 @@ impl Context {\n             ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n               self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n         };\n-        let none = || {\n-            let p = self.ecx.path(sp, ~[self.ecx.ident_of(\"None\")]);\n-            self.ecx.expr_path(p)\n-        };\n+        let none = self.ecx.path_global(sp, ~[\n+                self.ecx.ident_of(\"std\"),\n+                self.ecx.ident_of(\"option\"),\n+                self.ecx.ident_of(\"None\")]);\n+        let none = self.ecx.expr_path(none);\n         let some = |e: @ast::Expr| {\n-            self.ecx.expr_call_ident(sp, self.ecx.ident_of(\"Some\"), ~[e])\n+            let p = self.ecx.path_global(sp, ~[\n+                self.ecx.ident_of(\"std\"),\n+                self.ecx.ident_of(\"option\"),\n+                self.ecx.ident_of(\"Some\")]);\n+            let p = self.ecx.expr_path(p);\n+            self.ecx.expr_call(sp, p, ~[e])\n         };\n         let trans_count = |c: parse::Count| {\n             match c {\n@@ -397,7 +403,7 @@ impl Context {\n                 parse::Plural(offset, ref arms, ref default) => {\n                     let offset = match offset {\n                         Some(i) => { some(self.ecx.expr_uint(sp, i)) }\n-                        None => { none() }\n+                        None => { none.clone() }\n                     };\n                     let arms = arms.iter().map(|arm| {\n                         let p = self.ecx.path_global(sp, rtpath(\"PluralArm\"));\n@@ -522,7 +528,7 @@ impl Context {\n \n                 // Translate the method (if any)\n                 let method = match arg.method {\n-                    None => { none() }\n+                    None => { none.clone() }\n                     Some(ref m) => {\n                         let m = trans_method(*m);\n                         some(self.ecx.expr_addr_of(sp, m))\n@@ -541,7 +547,7 @@ impl Context {\n \n     /// Actually builds the expression which the ifmt! block will be expanded\n     /// to\n-    fn to_expr(&self, extra: Option<@ast::Expr>, f: &str) -> @ast::Expr {\n+    fn to_expr(&self, extra: Option<@ast::Expr>, f: Option<&str>) -> @ast::Expr {\n         let mut lets = ~[];\n         let mut locals = ~[];\n         let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n@@ -556,21 +562,19 @@ impl Context {\n         // Next, build up the static array which will become our precompiled\n         // format \"string\"\n         let fmt = self.ecx.expr_vec(self.fmtsp, self.pieces.clone());\n+        let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n+                self.fmtsp,\n+                true, ~[\n+                    self.ecx.ident_of(\"std\"),\n+                    self.ecx.ident_of(\"fmt\"),\n+                    self.ecx.ident_of(\"rt\"),\n+                    self.ecx.ident_of(\"Piece\"),\n+                ],\n+                Some(self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\"))),\n+                ~[]\n+            ), None);\n         let ty = ast::ty_fixed_length_vec(\n-            self.ecx.ty_mt(\n-                self.ecx.ty_path(self.ecx.path_all(\n-                    self.fmtsp,\n-                    true, ~[\n-                        self.ecx.ident_of(\"std\"),\n-                        self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"rt\"),\n-                        self.ecx.ident_of(\"Piece\"),\n-                    ],\n-                    Some(self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\"))),\n-                    ~[]\n-                ), None),\n-                ast::MutImmutable\n-            ),\n+            self.ecx.ty_mt(piece_ty.clone(), ast::MutImmutable),\n             self.ecx.expr_uint(self.fmtsp, self.pieces.len())\n         );\n         let ty = self.ecx.ty(self.fmtsp, ty);\n@@ -596,7 +600,8 @@ impl Context {\n             let name = self.ecx.ident_of(fmt!(\"__arg%u\", i));\n             let e = self.ecx.expr_addr_of(e.span, e);\n             lets.push(self.ecx.stmt_let(e.span, false, name, e));\n-            locals.push(self.format_arg(e.span, Left(i), name));\n+            locals.push(self.format_arg(e.span, Left(i),\n+                                        self.ecx.expr_ident(e.span, name)));\n         }\n         for (&name, &e) in self.names.iter() {\n             if !self.name_types.contains_key(&name) { loop }\n@@ -605,48 +610,83 @@ impl Context {\n             let e = self.ecx.expr_addr_of(e.span, e);\n             lets.push(self.ecx.stmt_let(e.span, false, lname, e));\n             names[*self.name_positions.get(&name)] =\n-                Some(self.format_arg(e.span, Right(name), lname));\n+                Some(self.format_arg(e.span, Right(name),\n+                                     self.ecx.expr_ident(e.span, lname)));\n         }\n \n         let args = names.move_iter().map(|a| a.unwrap());\n         let mut args = locals.move_iter().chain(args);\n \n-        let mut fmt_args = match extra {\n-            Some(e) => ~[e], None => ~[]\n-        };\n-        fmt_args.push(self.ecx.expr_ident(self.fmtsp, static_name));\n-        fmt_args.push(self.ecx.expr_vec(self.fmtsp, args.collect()));\n+        let result = match f {\n+            // Invocation of write!()/format!(), call the function and we're\n+            // done.\n+            Some(f) => {\n+                let mut fmt_args = match extra {\n+                    Some(e) => ~[e], None => ~[]\n+                };\n+                fmt_args.push(self.ecx.expr_ident(self.fmtsp, static_name));\n+                fmt_args.push(self.ecx.expr_vec_slice(self.fmtsp,\n+                                                      args.collect()));\n \n-        // Next, build up the actual call to the {s,f}printf function.\n-        let result = self.ecx.expr_call_global(self.fmtsp, ~[\n-                self.ecx.ident_of(\"std\"),\n-                self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(f),\n-            ], fmt_args);\n-\n-        // sprintf is unsafe, but we just went through a lot of work to\n-        // validate that our call is save, so inject the unsafe block for the\n-        // user.\n-        let result = self.ecx.expr_block(ast::Block {\n-           view_items: ~[],\n-           stmts: ~[],\n-           expr: Some(result),\n-           id: ast::DUMMY_NODE_ID,\n-           rules: ast::UnsafeBlock(ast::CompilerGenerated),\n-           span: self.fmtsp,\n-        });\n-\n-        self.ecx.expr_block(self.ecx.block(self.fmtsp, lets, Some(result)))\n+                let result = self.ecx.expr_call_global(self.fmtsp, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(f),\n+                    ], fmt_args);\n+\n+                // sprintf is unsafe, but we just went through a lot of work to\n+                // validate that our call is save, so inject the unsafe block\n+                // for the user.\n+                self.ecx.expr_block(ast::Block {\n+                   view_items: ~[],\n+                   stmts: ~[],\n+                   expr: Some(result),\n+                   id: ast::DUMMY_NODE_ID,\n+                   rules: ast::UnsafeBlock(ast::CompilerGenerated),\n+                   span: self.fmtsp,\n+                })\n+            }\n+\n+            // Invocation of format_args!()\n+            None => {\n+                let fmt = self.ecx.expr_ident(self.fmtsp, static_name);\n+                let args = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n+                let result = self.ecx.expr_call_global(self.fmtsp, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(\"Arguments\"),\n+                        self.ecx.ident_of(\"new\"),\n+                    ], ~[fmt, args]);\n+\n+                // We did all the work of making sure that the arguments\n+                // structure is safe, so we can safely have an unsafe block.\n+                let result = self.ecx.expr_block(ast::Block {\n+                   view_items: ~[],\n+                   stmts: ~[],\n+                   expr: Some(result),\n+                   id: ast::DUMMY_NODE_ID,\n+                   rules: ast::UnsafeBlock(ast::CompilerGenerated),\n+                   span: self.fmtsp,\n+                });\n+                let extra = extra.unwrap();\n+                let resname = self.ecx.ident_of(\"__args\");\n+                lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n+                let res = self.ecx.expr_ident(self.fmtsp, resname);\n+                self.ecx.expr_call(extra.span, extra, ~[\n+                        self.ecx.expr_addr_of(extra.span, res)])\n+            }\n+        };\n+        self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n+                                           Some(result)))\n     }\n \n-    fn format_arg(&self, sp: Span, arg: Either<uint, @str>,\n-                  ident: ast::Ident) -> @ast::Expr {\n-        let ty = match arg {\n+    fn format_arg(&self, sp: Span, argno: Either<uint, @str>,\n+                  arg: @ast::Expr) -> @ast::Expr {\n+        let ty = match argno {\n             Left(i) => self.arg_types[i].unwrap(),\n             Right(s) => *self.name_types.get(&s)\n         };\n \n-        let argptr = self.ecx.expr_ident(sp, ident);\n         let fmt_trait = match ty {\n             Unknown => \"Default\",\n             Known(tyname) => {\n@@ -675,14 +715,14 @@ impl Context {\n                         self.ecx.ident_of(\"std\"),\n                         self.ecx.ident_of(\"fmt\"),\n                         self.ecx.ident_of(\"argumentstr\"),\n-                    ], ~[argptr])\n+                    ], ~[arg])\n             }\n             Unsigned => {\n                 return self.ecx.expr_call_global(sp, ~[\n                         self.ecx.ident_of(\"std\"),\n                         self.ecx.ident_of(\"fmt\"),\n                         self.ecx.ident_of(\"argumentuint\"),\n-                    ], ~[argptr])\n+                    ], ~[arg])\n             }\n         };\n \n@@ -696,28 +736,33 @@ impl Context {\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n                 self.ecx.ident_of(\"argument\"),\n-            ], ~[self.ecx.expr_path(format_fn), argptr])\n+            ], ~[self.ecx.expr_path(format_fn), arg])\n     }\n }\n \n pub fn expand_format(ecx: @ExtCtxt, sp: Span,\n                      tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, false, false, \"format\")\n+    expand_ifmt(ecx, sp, tts, false, false, Some(\"format_unsafe\"))\n }\n \n pub fn expand_write(ecx: @ExtCtxt, sp: Span,\n                     tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, true, false, \"write\")\n+    expand_ifmt(ecx, sp, tts, true, false, Some(\"write_unsafe\"))\n }\n \n pub fn expand_writeln(ecx: @ExtCtxt, sp: Span,\n                       tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, true, true, \"write\")\n+    expand_ifmt(ecx, sp, tts, true, true, Some(\"write_unsafe\"))\n+}\n+\n+pub fn expand_format_args(ecx: @ExtCtxt, sp: Span,\n+                          tts: &[ast::token_tree]) -> base::MacResult {\n+    expand_ifmt(ecx, sp, tts, true, false, None)\n }\n \n fn expand_ifmt(ecx: @ExtCtxt, sp: Span, tts: &[ast::token_tree],\n                leading_arg: bool, append_newline: bool,\n-               function: &str) -> base::MacResult {\n+               function: Option<&str>) -> base::MacResult {\n     let mut cx = Context {\n         ecx: ecx,\n         args: ~[],"}, {"sha": "d2a3fe2a9b1c2c9230f555d9ab328b5fb517423b", "filename": "src/test/compile-fail/ifmt-bad-format-args.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args.rs?ref=9a5f95a82c2836fa6c57ede49d27c060f2377fa1", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    format_args!(\"test\"); //~ ERROR: expected token\n+    format_args!(\"\", || {}); //~ ERROR: must be a string literal\n+}"}, {"sha": "7bb8365bc128ed4c2a1b459a25948ba61ab5c196", "filename": "src/test/compile-fail/ifmt-bad-format-args2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args2.rs?ref=9a5f95a82c2836fa6c57ede49d27c060f2377fa1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    format_args!(\"{}\", \"\"); //~ ERROR: expected function\n+}"}, {"sha": "08d5ac5c1fb8e1b6d478c09c8f8b1ebef2d075ca", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5f95a82c2836fa6c57ede49d27c060f2377fa1/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=9a5f95a82c2836fa6c57ede49d27c060f2377fa1", "patch": "@@ -13,6 +13,11 @@\n #[deny(warnings)];\n \n use std::fmt;\n+use std::rt::io::Decorator;\n+use std::rt::io::mem::MemWriter;\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::str;\n \n struct A;\n struct B;\n@@ -235,16 +240,13 @@ pub fn main() {\n         let a: int = ::std::cast::transmute(3u);\n         format!(\"{}\", a);\n     }\n+\n+    test_format_args();\n }\n \n // Basic test to make sure that we can invoke the `write!` macro with an\n // io::Writer instance.\n fn test_write() {\n-    use std::rt::io::Decorator;\n-    use std::rt::io::mem::MemWriter;\n-    use std::rt::io;\n-    use std::str;\n-\n     let mut buf = MemWriter::new();\n     write!(&mut buf as &mut io::Writer, \"{}\", 3);\n     {\n@@ -268,3 +270,20 @@ fn test_print() {\n     println!(\"this is a {}\", \"test\");\n     println!(\"{foo}\", foo=\"bar\");\n }\n+\n+// Just make sure that the macros are defined, there's not really a lot that we\n+// can do with them just yet (to test the output)\n+fn test_format_args() {\n+    let mut buf = MemWriter::new();\n+    {\n+        let w = &mut buf as &mut io::Writer;\n+        format_args!(|args| { fmt::write(w, args) }, \"{}\", 1);\n+        format_args!(|args| { fmt::write(w, args) }, \"test\");\n+        format_args!(|args| { fmt::write(w, args) }, \"{test}\", test=3);\n+    }\n+    let s = str::from_utf8_owned(buf.inner());\n+    t!(s, \"1test3\");\n+\n+    let s = format_args!(fmt::format, \"hello {}\", \"world\");\n+    t!(s, \"hello world\");\n+}"}]}