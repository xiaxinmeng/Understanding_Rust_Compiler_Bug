{"sha": "c04ec2c3f966f989b2d1ce80846fca5dbd00b174", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNGVjMmMzZjk2NmY5ODliMmQxY2U4MDg0NmZjYTVkYmQwMGIxNzQ=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-02-10T06:23:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-10T06:23:58Z"}, "message": "Rollup merge of #48047 - etaoins:fix-ice-for-mismatched-args-on-target-without-span, r=estebank\n\nFix ICE for mismatched args on target without span\n\nCommit 7ed00caacc improved our error reporting by including the target function in our error messages when there is an argument count mismatch. A simple example from the UI tests is:\n\n```\nerror[E0593]: function is expected to take a single 2-tuple as argument, but it takes 0 arguments\n  --> $DIR/closure-arg-count.rs:32:53\n   |\n32 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(foo);\n   |                                                     ^^^ expected function that takes a single 2-tuple as argument\n...\n44 | fn foo() {}\n   | -------- takes 0 arguments\n```\n\nHowever, this assumed the target span was always available. This does not hold true if the target function is in `std` or another crate. A simple example from #48046 is assigning `str::split` to a function type with a different number of arguments.\n\nFix by omitting all of the labels and suggestions related to the target span when it's not found.\n\nFixes #48046\n\nr? @estebank", "tree": {"sha": "bfd4d5ef13dae8ee135e4992ba303b794362076f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfd4d5ef13dae8ee135e4992ba303b794362076f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c04ec2c3f966f989b2d1ce80846fca5dbd00b174", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJafo/+CRBK7hj4Ov3rIwAAdHIIADEMTP1v5HvhqgueuQQNCBLt\nxWnmy/Cex6rWNAfwCKT6Sveka7AAH8g6B1py0j2+oejQYpjJyJgVpmItPwef6xz3\nbGp01k0cYvZuOIJe9T+pX07E7DVa4kQvbPOjHOPeFm3xka9xzDyeuvSFVdTv8nn8\nC5hhD4axMQvaS/sBz6fR/x0MZk7VJi08Xw9wfYz2TmDm4qBIxptArHDLtJvbEAyA\nWzSEI68zBT4lR/ln0ihenoQkcPGxxl3PrLPb7jg0ERh6R29s5ZjeaHl5uRPtpeoH\nc8RpzaGESiKXihzMEBJNaUHht8/JFJXj5oYUnl0VAXt0bYZ0VpjUMKcvnECuGDc=\n=VpxB\n-----END PGP SIGNATURE-----\n", "payload": "tree bfd4d5ef13dae8ee135e4992ba303b794362076f\nparent 077979f4a284ff6d3725a6933896330692b9d468\nparent daaa9a440ccbdcf12165165ca38eb80bdb9a6eff\nauthor kennytm <kennytm@gmail.com> 1518243838 +0800\ncommitter GitHub <noreply@github.com> 1518243838 +0800\n\nRollup merge of #48047 - etaoins:fix-ice-for-mismatched-args-on-target-without-span, r=estebank\n\nFix ICE for mismatched args on target without span\n\nCommit 7ed00caacc improved our error reporting by including the target function in our error messages when there is an argument count mismatch. A simple example from the UI tests is:\n\n```\nerror[E0593]: function is expected to take a single 2-tuple as argument, but it takes 0 arguments\n  --> $DIR/closure-arg-count.rs:32:53\n   |\n32 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(foo);\n   |                                                     ^^^ expected function that takes a single 2-tuple as argument\n...\n44 | fn foo() {}\n   | -------- takes 0 arguments\n```\n\nHowever, this assumed the target span was always available. This does not hold true if the target function is in `std` or another crate. A simple example from #48046 is assigning `str::split` to a function type with a different number of arguments.\n\nFix by omitting all of the labels and suggestions related to the target span when it's not found.\n\nFixes #48046\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c04ec2c3f966f989b2d1ce80846fca5dbd00b174", "html_url": "https://github.com/rust-lang/rust/commit/c04ec2c3f966f989b2d1ce80846fca5dbd00b174", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c04ec2c3f966f989b2d1ce80846fca5dbd00b174/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "077979f4a284ff6d3725a6933896330692b9d468", "url": "https://api.github.com/repos/rust-lang/rust/commits/077979f4a284ff6d3725a6933896330692b9d468", "html_url": "https://github.com/rust-lang/rust/commit/077979f4a284ff6d3725a6933896330692b9d468"}, {"sha": "daaa9a440ccbdcf12165165ca38eb80bdb9a6eff", "url": "https://api.github.com/repos/rust-lang/rust/commits/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff", "html_url": "https://github.com/rust-lang/rust/commit/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff"}], "stats": {"total": 108, "additions": 61, "deletions": 47}, "files": [{"sha": "a290839425ebe2051947c32eeaf4ae0d23560a39", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c04ec2c3f966f989b2d1ce80846fca5dbd00b174/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04ec2c3f966f989b2d1ce80846fca5dbd00b174/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c04ec2c3f966f989b2d1ce80846fca5dbd00b174", "patch": "@@ -764,8 +764,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     let (closure_span, found) = found_did\n                         .and_then(|did| self.tcx.hir.get_if_local(did))\n-                        .map(|node| self.get_fn_like_arguments(node))\n-                        .unwrap_or((found_span.unwrap(), found));\n+                        .map(|node| {\n+                            let (found_span, found) = self.get_fn_like_arguments(node);\n+                            (Some(found_span), found)\n+                        }).unwrap_or((found_span, found));\n \n                     self.report_arg_count_mismatch(span,\n                                                    closure_span,\n@@ -875,7 +877,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn report_arg_count_mismatch(\n         &self,\n         span: Span,\n-        found_span: Span,\n+        found_span: Option<Span>,\n         expected_args: Vec<ArgKind>,\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n@@ -913,48 +915,51 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         err.span_label(span, format!( \"expected {} that takes {}\", kind, expected_str));\n-        err.span_label(found_span, format!(\"takes {}\", found_str));\n-\n-        if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n-            if fields.len() == expected_args.len() {\n-                let sugg = fields.iter()\n-                    .map(|(name, _)| name.to_owned())\n-                    .collect::<Vec<String>>().join(\", \");\n-                err.span_suggestion(found_span,\n-                                    \"change the closure to take multiple arguments instead of \\\n-                                     a single tuple\",\n-                                    format!(\"|{}|\", sugg));\n+\n+        if let Some(found_span) = found_span {\n+            err.span_label(found_span, format!(\"takes {}\", found_str));\n+\n+            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+                if fields.len() == expected_args.len() {\n+                    let sugg = fields.iter()\n+                        .map(|(name, _)| name.to_owned())\n+                        .collect::<Vec<String>>().join(\", \");\n+                    err.span_suggestion(found_span,\n+                                        \"change the closure to take multiple arguments instead of \\\n+                                         a single tuple\",\n+                                        format!(\"|{}|\", sugg));\n+                }\n             }\n-        }\n-        if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n-            if fields.len() == found_args.len() && is_closure {\n-                let sugg = format!(\n-                    \"|({}){}|\",\n-                    found_args.iter()\n-                        .map(|arg| match arg {\n-                            ArgKind::Arg(name, _) => name.to_owned(),\n-                            _ => \"_\".to_owned(),\n-                        })\n-                        .collect::<Vec<String>>()\n-                        .join(\", \"),\n-                    // add type annotations if available\n-                    if found_args.iter().any(|arg| match arg {\n-                        ArgKind::Arg(_, ty) => ty != \"_\",\n-                        _ => false,\n-                    }) {\n-                        format!(\": ({})\",\n-                                fields.iter()\n-                                    .map(|(_, ty)| ty.to_owned())\n-                                    .collect::<Vec<String>>()\n-                                    .join(\", \"))\n-                    } else {\n-                        \"\".to_owned()\n-                    },\n-                );\n-                err.span_suggestion(found_span,\n-                                    \"change the closure to accept a tuple instead of individual \\\n-                                     arguments\",\n-                                    sugg);\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n+                if fields.len() == found_args.len() && is_closure {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        found_args.iter()\n+                            .map(|arg| match arg {\n+                                ArgKind::Arg(name, _) => name.to_owned(),\n+                                _ => \"_\".to_owned(),\n+                            })\n+                            .collect::<Vec<String>>()\n+                            .join(\", \"),\n+                        // add type annotations if available\n+                        if found_args.iter().any(|arg| match arg {\n+                            ArgKind::Arg(_, ty) => ty != \"_\",\n+                            _ => false,\n+                        }) {\n+                            format!(\": ({})\",\n+                                    fields.iter()\n+                                        .map(|(_, ty)| ty.to_owned())\n+                                        .collect::<Vec<String>>()\n+                                        .join(\", \"))\n+                        } else {\n+                            \"\".to_owned()\n+                        },\n+                    );\n+                    err.span_suggestion(found_span,\n+                                        \"change the closure to accept a tuple instead of \\\n+                                         individual arguments\",\n+                                        sugg);\n+                }\n             }\n         }\n "}, {"sha": "34232e81cbdeef0a5a5bff568fc08d9a383850c0", "filename": "src/test/ui/mismatched_types/closure-arg-count.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c04ec2c3f966f989b2d1ce80846fca5dbd00b174/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04ec2c3f966f989b2d1ce80846fca5dbd00b174/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs?ref=c04ec2c3f966f989b2d1ce80846fca5dbd00b174", "patch": "@@ -36,6 +36,9 @@ fn main() {\n     //~^ ERROR closure is expected to take\n     let _it = vec![1, 2, 3].into_iter().enumerate().map(qux);\n     //~^ ERROR function is expected to take\n+\n+    let _it = vec![1, 2, 3].into_iter().map(usize::checked_add);\n+    //~^ ERROR function is expected to take\n }\n \n fn foo() {}"}, {"sha": "d2a6d6da814ca1afc29856b384fc2c5c84e4de06", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c04ec2c3f966f989b2d1ce80846fca5dbd00b174/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c04ec2c3f966f989b2d1ce80846fca5dbd00b174/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=c04ec2c3f966f989b2d1ce80846fca5dbd00b174", "patch": "@@ -90,7 +90,7 @@ error[E0593]: function is expected to take a single 2-tuple as argument, but it\n 32 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(foo);\n    |                                                     ^^^ expected function that takes a single 2-tuple as argument\n ...\n-41 | fn foo() {}\n+44 | fn foo() {}\n    | -------- takes 0 arguments\n \n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 3 distinct arguments\n@@ -107,8 +107,14 @@ error[E0593]: function is expected to take a single 2-tuple as argument, but it\n 37 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(qux);\n    |                                                     ^^^ expected function that takes a single 2-tuple as argument\n ...\n-42 | fn qux(x: usize, y: usize) {}\n+45 | fn qux(x: usize, y: usize) {}\n    | -------------------------- takes 2 distinct arguments\n \n-error: aborting due to 11 previous errors\n+error[E0593]: function is expected to take 1 argument, but it takes 2 arguments\n+  --> $DIR/closure-arg-count.rs:40:41\n+   |\n+40 |     let _it = vec![1, 2, 3].into_iter().map(usize::checked_add);\n+   |                                         ^^^ expected function that takes 1 argument\n+\n+error: aborting due to 12 previous errors\n "}]}