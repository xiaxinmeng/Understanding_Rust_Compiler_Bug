{"sha": "90f345df94ffa92760ce338208a034d0a3785a2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZjM0NWRmOTRmZmE5Mjc2MGNlMzM4MjA4YTAzNGQwYTM3ODVhMmQ=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2017-09-05T00:16:34Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-09-05T10:56:26Z"}, "message": "Add lint to detect manual slice copies", "tree": {"sha": "226a063d5925332a1277f1ff479ebd31f4d4140c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/226a063d5925332a1277f1ff479ebd31f4d4140c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90f345df94ffa92760ce338208a034d0a3785a2d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmugtwACgkQpp+NIls6\n19nY9g//QD4+o5mZfnH2KOIQfQX7bnjly6/bf58bhFvrEOFKXkXQjwYG31Pe1RZ7\nWuMPa9cgVxvUxzPO+jHUrlBFgpsz4/zFTy6czXlYTuTylMDniKXhvRAE1rcZRCS1\nT3ViZPbtTdTpEeHCMU318+aXOJECvVj2MFPzLnaG+R+PGxyrRmiuB55z8++Ano+3\nbez2VVyNzIJIr8FvORk3aSCxQ2uk7Kv5Bcjoxj4oXNclwWVl5FG9B99cRUSKkqAZ\nSDu6QkAgdz33zcuZVAQJvWeNeNXQdBeSAo9wmwsut/8YenAcLQp9KuSA4OYoA3ZR\n9bRAcvi4UCZcCzaGKM6SmK9WD9OejBqCcmZPdFfMYpnSh5VFAdhX5m1DZBeYs9p3\nXoMyr8BjlMCUZyHOUIydws5tGOT0iQoy00lDVHh0mdQf84Z5eDzd/3T0rCirQ/YB\nbIBso/PMxD4uTtDjtjlu3hLC5R6zMyDEvgXoI1EZrtEtv5pNihaCl1NPBBU5jwpp\nsyVM3W9fKeLaKbPssUXnJ14neKyclboEKej64Zc9H01BOjrELsFt/QLD5jps7mm4\n3iHHakdqIKDYHzm3yzoaZfMEFT7CRq0hRIfX+vn8ArHM7mYYPpQS8J8fVpuWrays\ncdxLkzMRcQ6A7ymFkL26rYoKfVXuU4A7aA8JmDlFewVl6ioszdQ=\n=f5Tq\n-----END PGP SIGNATURE-----", "payload": "tree 226a063d5925332a1277f1ff479ebd31f4d4140c\nparent b32631794a413cea7ce29abd9f194fff59f05fa1\nauthor Marcus Klaas <mail@marcusklaas.nl> 1504570594 -0400\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1504608986 +0200\n\nAdd lint to detect manual slice copies\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90f345df94ffa92760ce338208a034d0a3785a2d", "html_url": "https://github.com/rust-lang/rust/commit/90f345df94ffa92760ce338208a034d0a3785a2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90f345df94ffa92760ce338208a034d0a3785a2d/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b32631794a413cea7ce29abd9f194fff59f05fa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b32631794a413cea7ce29abd9f194fff59f05fa1", "html_url": "https://github.com/rust-lang/rust/commit/b32631794a413cea7ce29abd9f194fff59f05fa1"}], "stats": {"total": 425, "additions": 368, "deletions": 57}, "files": [{"sha": "6cf2b1d9fedc32ec1a4f65088ac61526410a96ec", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 318, "deletions": 28, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/90f345df94ffa92760ce338208a034d0a3785a2d/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f345df94ffa92760ce338208a034d0a3785a2d/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=90f345df94ffa92760ce338208a034d0a3785a2d", "patch": "@@ -1,3 +1,4 @@\n+use itertools::Itertools;\n use reexport::*;\n use rustc::hir::*;\n use rustc::hir::def::Def;\n@@ -15,10 +16,29 @@ use syntax::ast;\n use utils::sugg;\n \n use utils::{get_enclosing_block, get_parent_expr, higher, in_external_macro, is_integer_literal, is_refutable,\n-            last_path_segment, match_trait_method, match_type, multispan_sugg, snippet, span_help_and_lint, span_lint,\n-            span_lint_and_sugg, span_lint_and_then};\n+            last_path_segment, match_trait_method, match_type, multispan_sugg, snippet, snippet_opt,\n+            span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then};\n use utils::paths;\n \n+/// **What it does:** Checks for for loops that manually copy items between\n+/// slices that could be optimized by having a memcpy.\n+///\n+/// **Why is this bad?** It is not as fast as a memcpy.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// for i in 0..src.len() {\n+///     dst[i + 64] = src[i];\n+/// }\n+/// ```\n+declare_lint! {\n+    pub MANUAL_MEMCPY,\n+    Warn,\n+    \"manually copying items between slices\"\n+}\n+\n /// **What it does:** Checks for looping over the range of `0..len` of some\n /// collection just to get the values by index.\n ///\n@@ -314,6 +334,7 @@ pub struct Pass;\n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n+            MANUAL_MEMCPY,\n             NEEDLESS_RANGE_LOOP,\n             EXPLICIT_ITER_LOOP,\n             EXPLICIT_INTO_ITER_LOOP,\n@@ -570,6 +591,249 @@ fn check_for_loop<'a, 'tcx>(\n     check_for_loop_arg(cx, pat, arg, expr);\n     check_for_loop_explicit_counter(cx, arg, body, expr);\n     check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n+    detect_manual_memcpy(cx, pat, arg, body, expr);\n+}\n+\n+fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: DefId) -> bool {\n+    if_let_chain! {[\n+        let ExprPath(ref qpath) = expr.node,\n+        let QPath::Resolved(None, ref path) = *qpath,\n+        path.segments.len() == 1,\n+        // our variable!\n+        cx.tables.qpath_def(qpath, expr.hir_id).def_id() == var\n+    ], {\n+        return true;\n+    }}\n+\n+    false\n+}\n+\n+struct Offset {\n+    value: String,\n+    negate: bool,\n+}\n+\n+impl Offset {\n+    fn negative(s: String) -> Self {\n+        Self {\n+            value: s,\n+            negate: true,\n+        }\n+    }\n+\n+    fn positive(s: String) -> Self {\n+        Self {\n+            value: s,\n+            negate: false,\n+        }\n+    }\n+}\n+\n+struct FixedOffsetVar {\n+    var_name: String,\n+    offset: Offset,\n+}\n+\n+fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty) -> bool {\n+    let is_slice = match ty.sty {\n+        ty::TyRef(_, ref subty) => is_slice_like(cx, subty.ty),\n+        ty::TySlice(..) | ty::TyArray(..) => true,\n+        _ => false,\n+    };\n+\n+    is_slice || match_type(cx, ty, &paths::VEC) || match_type(cx, ty, &paths::VEC_DEQUE)\n+}\n+\n+fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: DefId) -> Option<FixedOffsetVar> {\n+    fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: DefId) -> Option<String> {\n+        match e.node {\n+            ExprLit(ref l) => match l.node {\n+                ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n+                _ => None,\n+            },\n+            ExprPath(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n+            _ => None,\n+        }\n+    }\n+\n+    if let ExprIndex(ref seqexpr, ref idx) = expr.node {\n+        let ty = cx.tables.expr_ty(seqexpr);\n+        if !is_slice_like(cx, ty) {\n+            return None;\n+        }\n+\n+        let offset = match idx.node {\n+            ExprBinary(op, ref lhs, ref rhs) => match op.node {\n+                BinOp_::BiAdd => {\n+                    let offset_opt = if same_var(cx, lhs, var) {\n+                        extract_offset(cx, rhs, var)\n+                    } else if same_var(cx, rhs, var) {\n+                        extract_offset(cx, lhs, var)\n+                    } else {\n+                        None\n+                    };\n+\n+                    offset_opt.map(Offset::positive)\n+                },\n+                BinOp_::BiSub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n+                _ => None,\n+            },\n+            ExprPath(..) => if same_var(cx, idx, var) {\n+                Some(Offset::positive(\"0\".into()))\n+            } else {\n+                None\n+            },\n+            _ => None,\n+        };\n+\n+        offset.map(|o| {\n+            FixedOffsetVar {\n+                var_name: snippet_opt(cx, seqexpr.span).unwrap_or_else(|| \"???\".into()),\n+                offset: o,\n+            }\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n+fn get_indexed_assignments<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    body: &Expr,\n+    var: DefId,\n+) -> Vec<(FixedOffsetVar, FixedOffsetVar)> {\n+    fn get_assignment<'a, 'tcx>(\n+        cx: &LateContext<'a, 'tcx>,\n+        e: &Expr,\n+        var: DefId,\n+    ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n+        if let Expr_::ExprAssign(ref lhs, ref rhs) = e.node {\n+            match (get_fixed_offset_var(cx, lhs, var), get_fixed_offset_var(cx, rhs, var)) {\n+                (Some(offset_left), Some(offset_right)) => Some((offset_left, offset_right)),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    if let Expr_::ExprBlock(ref b) = body.node {\n+        let Block {\n+            ref stmts,\n+            ref expr,\n+            ..\n+        } = **b;\n+\n+        stmts\n+            .iter()\n+            .map(|stmt| match stmt.node {\n+                Stmt_::StmtDecl(..) => None,\n+                Stmt_::StmtExpr(ref e, _node_id) | Stmt_::StmtSemi(ref e, _node_id) => Some(get_assignment(cx, e, var)),\n+            })\n+            .chain(\n+                expr.as_ref()\n+                    .into_iter()\n+                    .map(|e| Some(get_assignment(cx, &*e, var))),\n+            )\n+            .filter_map(|op| op)\n+            .collect::<Option<Vec<_>>>()\n+            .unwrap_or_else(|| vec![])\n+    } else {\n+        get_assignment(cx, body, var).into_iter().collect()\n+    }\n+}\n+\n+/// Check for for loops that sequentially copy items from one slice-like\n+/// object to another.\n+fn detect_manual_memcpy<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr,\n+) {\n+    if let Some(higher::Range {\n+        start: Some(start),\n+        ref end,\n+        limits,\n+    }) = higher::range(arg)\n+    {\n+        // the var must be a single name\n+        if let PatKind::Binding(_, def_id, _, _) = pat.node {\n+            let print_sum = |arg1: &Offset, arg2: &Offset| -> String {\n+                match (&arg1.value[..], arg1.negate, &arg2.value[..], arg2.negate) {\n+                    (\"0\", _, \"0\", _) => \"\".into(),\n+                    (\"0\", _, x, false) | (x, false, \"0\", false) => x.into(),\n+                    (\"0\", _, x, true) | (x, false, \"0\", true) => format!(\"-{}\", x),\n+                    (x, false, y, false) => format!(\"({} + {})\", x, y),\n+                    (x, false, y, true) => format!(\"({} - {})\", x, y),\n+                    (x, true, y, false) => format!(\"({} - {})\", y, x),\n+                    (x, true, y, true) => format!(\"-({} + {})\", x, y),\n+                }\n+            };\n+\n+            let print_limit = |end: &Option<&Expr>, offset: Offset, var_name: &str| if let Some(end) = *end {\n+                if_let_chain! {[\n+                    let ExprMethodCall(ref method, _, ref len_args) = end.node,\n+                    method.name == \"len\",\n+                    len_args.len() == 1,\n+                    let Some(arg) = len_args.get(0),\n+                    snippet(cx, arg.span, \"??\") == var_name,\n+                ], {\n+                    return if offset.negate {\n+                        format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value)\n+                    } else {\n+                        \"\".to_owned()\n+                    };\n+                }}\n+\n+                let end_str = match limits {\n+                    ast::RangeLimits::Closed => {\n+                        let end = sugg::Sugg::hir(cx, end, \"<count>\");\n+                        format!(\"{}\", end + sugg::ONE)\n+                    },\n+                    ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n+                };\n+\n+                print_sum(&Offset::positive(end_str), &offset)\n+            } else {\n+                \"..\".into()\n+            };\n+\n+            // The only statements in the for loops can be indexed assignments from\n+            // indexed retrievals.\n+            let manual_copies = get_indexed_assignments(cx, body, def_id);\n+\n+            let big_sugg = manual_copies\n+                .into_iter()\n+                .map(|(dst_var, src_var)| {\n+                    let start_str = Offset::positive(snippet_opt(cx, start.span).unwrap_or_else(|| \"\".into()));\n+                    let dst_offset = print_sum(&start_str, &dst_var.offset);\n+                    let dst_limit = print_limit(end, dst_var.offset, &dst_var.var_name);\n+                    let src_offset = print_sum(&start_str, &src_var.offset);\n+                    let src_limit = print_limit(end, src_var.offset, &src_var.var_name);\n+                    let dst = if dst_offset == \"\" && dst_limit == \"\" {\n+                        dst_var.var_name\n+                    } else {\n+                        format!(\"{}[{}..{}]\", dst_var.var_name, dst_offset, dst_limit)\n+                    };\n+\n+                    format!(\"{}.clone_from_slice(&{}[{}..{}])\", dst, src_var.var_name, src_offset, src_limit)\n+                })\n+                .join(\"\\n    \");\n+\n+            if !big_sugg.is_empty() {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MANUAL_MEMCPY,\n+                    expr.span,\n+                    \"it looks like you're manually copying between slices\",\n+                    \"try replacing the loop by\",\n+                    big_sugg,\n+                );\n+            }\n+        }\n+    }\n }\n \n /// Check for looping over a range and then indexing a sequence with it.\n@@ -1024,9 +1288,29 @@ impl<'tcx> Visitor<'tcx> for UsedVisitor {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if match_var(expr, self.var) {\n             self.used = true;\n-            return;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+struct DefIdUsedVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    def_id: DefId,\n+    used: bool,\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for DefIdUsedVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if same_var(self.cx, expr, self.def_id) {\n+            self.used = true;\n+        } else {\n+            walk_expr(self, expr);\n         }\n-        walk_expr(self, expr);\n     }\n \n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n@@ -1054,40 +1338,46 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         if_let_chain! {[\n             // an index op\n             let ExprIndex(ref seqexpr, ref idx) = expr.node,\n-            // directly indexing a variable\n-            let ExprPath(ref qpath) = idx.node,\n-            let QPath::Resolved(None, ref path) = *qpath,\n-            path.segments.len() == 1,\n-            // our variable!\n-            self.cx.tables.qpath_def(qpath, expr.hir_id).def_id() == self.var,\n             // the indexed container is referenced by a name\n             let ExprPath(ref seqpath) = seqexpr.node,\n             let QPath::Resolved(None, ref seqvar) = *seqpath,\n             seqvar.segments.len() == 1,\n         ], {\n-            let def = self.cx.tables.qpath_def(seqpath, seqexpr.hir_id);\n-            match def {\n-                Def::Local(..) | Def::Upvar(..) => {\n-                    let def_id = def.def_id();\n-                    let node_id = self.cx.tcx.hir.as_local_node_id(def_id).expect(\"local/upvar are local nodes\");\n-                    let hir_id = self.cx.tcx.hir.node_to_hir_id(node_id);\n-\n-                    let parent_id = self.cx.tcx.hir.get_parent(expr.id);\n-                    let parent_def_id = self.cx.tcx.hir.local_def_id(parent_id);\n-                    let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n-                    self.indexed.insert(seqvar.segments[0].name, Some(extent));\n-                    return;  // no need to walk further\n-                }\n-                Def::Static(..) | Def::Const(..) => {\n-                    self.indexed.insert(seqvar.segments[0].name, None);\n-                    return;  // no need to walk further\n+            let index_used = same_var(self.cx, idx, self.var) || {\n+                let mut used_visitor = DefIdUsedVisitor {\n+                    cx: self.cx,\n+                    def_id: self.var,\n+                    used: false,\n+                };\n+                walk_expr(&mut used_visitor, idx);\n+                used_visitor.used\n+            };\n+\n+            if index_used {\n+                let def = self.cx.tables.qpath_def(seqpath, seqexpr.hir_id);\n+                match def {\n+                    Def::Local(..) | Def::Upvar(..) => {\n+                        let def_id = def.def_id();\n+                        let node_id = self.cx.tcx.hir.as_local_node_id(def_id).expect(\"local/upvar are local nodes\");\n+                        let hir_id = self.cx.tcx.hir.node_to_hir_id(node_id);\n+\n+                        let parent_id = self.cx.tcx.hir.get_parent(expr.id);\n+                        let parent_def_id = self.cx.tcx.hir.local_def_id(parent_id);\n+                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n+                        self.indexed.insert(seqvar.segments[0].name, Some(extent));\n+                        return;  // no need to walk further *on the variable*\n+                    }\n+                    Def::Static(..) | Def::Const(..) => {\n+                        self.indexed.insert(seqvar.segments[0].name, None);\n+                        return;  // no need to walk further *on the variable*\n+                    }\n+                    _ => (),\n                 }\n-                _ => (),\n             }\n         }}\n \n         if_let_chain! {[\n-            // directly indexing a variable\n+            // directly using a variable\n             let ExprPath(ref qpath) = expr.node,\n             let QPath::Resolved(None, ref path) = *qpath,\n             path.segments.len() == 1,"}, {"sha": "721b2833dec26307622b3816bbf29a70d70a1b34", "filename": "tests/ui/for_loop.stderr", "status": "modified", "additions": 50, "deletions": 29, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/90f345df94ffa92760ce338208a034d0a3785a2d/tests%2Fui%2Ffor_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90f345df94ffa92760ce338208a034d0a3785a2d/tests%2Fui%2Ffor_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.stderr?ref=90f345df94ffa92760ce338208a034d0a3785a2d", "patch": "@@ -505,57 +505,78 @@ help: use the corresponding method\n 409 |     for k in rm.keys() {\n     |         ^\n \n-error: the loop variable `i` is used to index `src`\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:462:5\n+    |\n+462 | /     for i in 0..src.len() {\n+463 | |         dst[i] = src[i];\n+464 | |     }\n+    | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..])`\n+    |\n+    = note: `-D manual-memcpy` implied by `-D warnings`\n+\n+error: it looks like you're manually copying between slices\n    --> $DIR/for_loop.rs:467:5\n     |\n 467 | /     for i in 0..src.len() {\n 468 | |         dst[i + 10] = src[i];\n 469 | |     }\n-    | |_____^\n-    |\n-help: consider using an iterator\n-    |\n-467 |     for (i, <item>) in src.iter().enumerate() {\n-    |         ^^^^^^^^^^^\n+    | |_____^ help: try replacing the loop by: `dst[10..(src.len() + 10)].clone_from_slice(&src[..])`\n \n-error: the loop variable `i` is used to index `dst`\n+error: it looks like you're manually copying between slices\n    --> $DIR/for_loop.rs:472:5\n     |\n 472 | /     for i in 0..src.len() {\n 473 | |         dst[i] = src[i + 10];\n 474 | |     }\n-    | |_____^\n-    |\n-help: consider using an iterator\n-    |\n-472 |     for (i, <item>) in dst.iter().enumerate().take(src.len()) {\n-    |         ^^^^^^^^^^^\n+    | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[10..])`\n \n-error: the loop variable `i` is used to index `dst`\n+error: it looks like you're manually copying between slices\n    --> $DIR/for_loop.rs:477:5\n     |\n 477 | /     for i in 11..src.len() {\n 478 | |         dst[i] = src[i - 10];\n 479 | |     }\n-    | |_____^\n-    |\n-help: consider using an iterator\n+    | |_____^ help: try replacing the loop by: `dst[11..src.len()].clone_from_slice(&src[(11 - 10)..(src.len() - 10)])`\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:482:5\n     |\n-477 |     for (i, <item>) in dst.iter().enumerate().take(src.len()).skip(11) {\n-    |         ^^^^^^^^^^^\n+482 | /     for i in 0..dst.len() {\n+483 | |         dst[i] = src[i];\n+484 | |     }\n+    | |_____^ help: try replacing the loop by: `dst.clone_from_slice(&src[..dst.len()])`\n \n-error: the loop variable `i` is used to index `src`\n-   --> $DIR/for_loop.rs:512:5\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:495:5\n     |\n-512 | /     for i in 0..10 {\n-513 | |         dst[i + i] = src[i];\n-514 | |     }\n+495 | /     for i in 10..256 {\n+496 | |         dst[i] = src[i - 5];\n+497 | |         dst2[i + 500] = src[i]\n+498 | |     }\n     | |_____^\n     |\n-help: consider using an iterator\n+help: try replacing the loop by\n     |\n-512 |     for (i, <item>) in src.iter().enumerate().take(10) {\n-    |         ^^^^^^^^^^^\n+495 |     dst[10..256].clone_from_slice(&src[(10 - 5)..(256 - 5)])\n+496 |     dst2[(10 + 500)..(256 + 500)].clone_from_slice(&src[10..256])\n+    |\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:507:5\n+    |\n+507 | /     for i in 10..LOOP_OFFSET {\n+508 | |         dst[i + LOOP_OFFSET] = src[i - some_var];\n+509 | |     }\n+    | |_____^ help: try replacing the loop by: `dst[(10 + LOOP_OFFSET)..(LOOP_OFFSET + LOOP_OFFSET)].clone_from_slice(&src[(10 - some_var)..(LOOP_OFFSET - some_var)])`\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:520:5\n+    |\n+520 | /     for i in 0..src_vec.len() {\n+521 | |         dst_vec[i] = src_vec[i];\n+522 | |     }\n+    | |_____^ help: try replacing the loop by: `dst_vec[..src_vec.len()].clone_from_slice(&src_vec[..])`\n \n-error: aborting due to 54 previous errors\n+error: aborting due to 58 previous errors\n "}]}