{"sha": "0b653ab9539140bb04941de9a36c03cf10bfc28b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNjUzYWI5NTM5MTQwYmIwNDk0MWRlOWEzNmMwM2NmMTBiZmMyOGI=", "commit": {"author": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-06-30T10:54:54Z"}, "committer": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-06-30T10:54:54Z"}, "message": "initial draft of fix for issue #2498:\n1. make /// ... and //! ... and /** ... */ and /*! ... */ into sugar for #[doc = ...] attributes.\n2. add a script in etc/ to help converting doc-attributes to doc-comments\n3. add some functions to core::str to help with (1)", "tree": {"sha": "491d1b3f128a281ffb3a12240e6858a919f5f3dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/491d1b3f128a281ffb3a12240e6858a919f5f3dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b653ab9539140bb04941de9a36c03cf10bfc28b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b653ab9539140bb04941de9a36c03cf10bfc28b", "html_url": "https://github.com/rust-lang/rust/commit/0b653ab9539140bb04941de9a36c03cf10bfc28b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b653ab9539140bb04941de9a36c03cf10bfc28b/comments", "author": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7823de5e2bfc749c2fb4fcfe4d65d54b28e3a92", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7823de5e2bfc749c2fb4fcfe4d65d54b28e3a92", "html_url": "https://github.com/rust-lang/rust/commit/d7823de5e2bfc749c2fb4fcfe4d65d54b28e3a92"}], "stats": {"total": 513, "additions": 454, "deletions": 59}, "files": [{"sha": "04c8a4ebff25e611d8674f1eae03ef7b9b87f0ac", "filename": "src/etc/sugarise-doc-comments.py", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Fetc%2Fsugarise-doc-comments.py", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Fetc%2Fsugarise-doc-comments.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsugarise-doc-comments.py?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -0,0 +1,82 @@\n+#!/usr/bin/python\n+\n+#\n+# this script attempts to turn doc comment attributes (#[doc = \"...\"])\n+# into sugared-doc-comments (/** ... */ and /// ...)\n+#\n+# it sugarises all .rs/.rc files underneath the working directory\n+#\n+\n+import sys, os, fnmatch, re\n+\n+\n+DOC_PATTERN = '^(?P<indent>[\\\\t ]*)#\\\\[(\\\\s*)doc(\\\\s*)=' + \\\n+              '(\\\\s*)\"(?P<text>(\\\\\"|[^\"])*?)\"(\\\\s*)\\\\]' + \\\n+              '(?P<semi>;)?'\n+\n+ESCAPES = [(\"\\\\'\", \"'\"),\n+           ('\\\\\"', '\"'),\n+           (\"\\\\n\", \"\\n\"),\n+           (\"\\\\r\", \"\\r\"),\n+           (\"\\\\t\", \"\\t\")]\n+\n+\n+def unescape(s):\n+    for (find, repl) in ESCAPES:\n+        s = s.replace(find, repl)\n+    return s\n+\n+\n+def block_trim(s):\n+    lns = s.splitlines()\n+\n+    # remove leading/trailing whitespace-lines\n+    while lns and not lns[0].strip():\n+        lns = lns[1:]\n+    while lns and not lns[-1].strip():\n+        lns = lns[:-1]\n+\n+    # remove leading horizontal whitespace\n+    n = sys.maxint\n+    for ln in lns:\n+        if ln.strip():\n+            n = min(n, len(re.search('^\\s*', ln).group()))\n+    if n != sys.maxint:\n+        lns = [ln[n:] for ln in lns]\n+\n+    # strip trailing whitespace\n+    lns = [ln.rstrip() for ln in lns]\n+\n+    return lns\n+\n+\n+def replace_doc(m):\n+    indent = m.group('indent')\n+    text = block_trim(unescape(m.group('text')))\n+\n+    if len(text) > 1:\n+        inner = '!' if m.group('semi') else '*'\n+        starify = lambda s: indent + ' *' + (' ' + s if s else '')\n+        text = '\\n'.join(map(starify, text))\n+        repl = indent + '/*' + inner + '\\n' + text + '\\n' + indent + ' */'\n+    else:\n+        inner = '!' if m.group('semi') else '/'\n+        repl = indent + '//' + inner + ' ' + text[0]\n+\n+    return repl\n+\n+\n+def sugarise_file(path):\n+    s = open(path).read()\n+\n+    r = re.compile(DOC_PATTERN, re.MULTILINE | re.DOTALL)\n+    ns = re.sub(r, replace_doc, s)\n+\n+    if s != ns:\n+        open(path, 'w').write(ns)\n+\n+\n+for (dirpath, dirnames, filenames) in os.walk('.'):\n+    for name in fnmatch.filter(filenames, '*.r[sc]'):\n+        sugarise_file(os.path.join(dirpath, name))\n+"}, {"sha": "8d98e39791c6247cb7ccd3c4b16fd234e59af9d8", "filename": "src/libcore/str.rs", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -58,8 +58,8 @@ export\n    all, any,\n    all_between, any_between,\n    map,\n-   each,\n-   each_char,\n+   each, eachi,\n+   each_char, each_chari,\n    bytes_iter,\n    chars_iter,\n    split_char_iter,\n@@ -73,7 +73,7 @@ export\n    find_char, find_char_from, find_char_between,\n    rfind_char, rfind_char_from, rfind_char_between,\n    find_str, find_str_from, find_str_between,\n-   contains,\n+   contains, contains_char,\n    starts_with,\n    ends_with,\n \n@@ -672,22 +672,35 @@ pure fn bytes_iter(ss: str/&, it: fn(u8)) {\n #[doc = \"Iterate over the bytes in a string\"]\n #[inline(always)]\n pure fn each(s: str/&, it: fn(u8) -> bool) {\n+    eachi(s, {|_i, b| it(b)})\n+}\n+\n+#[doc = \"Iterate over the bytes in a string, with indices\"]\n+#[inline(always)]\n+pure fn eachi(s: str/&, it: fn(uint, u8) -> bool) {\n     let mut i = 0u, l = len(s);\n     while (i < l) {\n-        if !it(s[i]) { break; }\n+        if !it(i, s[i]) { break; }\n         i += 1u;\n     }\n }\n \n #[doc = \"Iterates over the chars in a string\"]\n #[inline(always)]\n pure fn each_char(s: str/&, it: fn(char) -> bool) {\n-    let mut pos = 0u;\n+    each_chari(s, {|_i, c| it(c)})\n+}\n+\n+#[doc = \"Iterates over the chars in a string, with indices\"]\n+#[inline(always)]\n+pure fn each_chari(s: str/&, it: fn(uint, char) -> bool) {\n+    let mut pos = 0u, ch_pos = 0u;\n     let len = len(s);\n     while pos < len {\n         let {ch, next} = char_range_at(s, pos);\n         pos = next;\n-        if !it(ch) { break; }\n+        if !it(ch_pos, ch) { break; }\n+        ch_pos += 1u;\n     }\n }\n \n@@ -1146,6 +1159,18 @@ pure fn contains(haystack: str/&a, needle: str/&b) -> bool {\n     option::is_some(find_str(haystack, needle))\n }\n \n+#[doc = \"\n+Returns true if a string contains a char.\n+\n+# Arguments\n+\n+* haystack - The string to look in\n+* needle - The char to look for\n+\"]\n+pure fn contains_char(haystack: str/&, needle: char) -> bool {\n+    option::is_some(find_char(haystack, needle))\n+}\n+\n #[doc = \"\n Returns true if one string starts with another\n \n@@ -1879,12 +1904,21 @@ impl extensions/& for str/& {\n     #[doc = \"Returns true if one string contains another\"]\n     #[inline]\n     fn contains(needle: str/&a) -> bool { contains(self, needle) }\n+    #[doc = \"Returns true if a string contains a char\"]\n+    #[inline]\n+    fn contains_char(needle: char) -> bool { contains_char(self, needle) }\n     #[doc = \"Iterate over the bytes in a string\"]\n     #[inline]\n     fn each(it: fn(u8) -> bool) { each(self, it) }\n+    #[doc = \"Iterate over the bytes in a string, with indices\"]\n+    #[inline]\n+    fn eachi(it: fn(uint, u8) -> bool) { eachi(self, it) }\n     #[doc = \"Iterate over the chars in a string\"]\n     #[inline]\n     fn each_char(it: fn(char) -> bool) { each_char(self, it) }\n+    #[doc = \"Iterate over the chars in a string, with indices\"]\n+    #[inline]\n+    fn each_chari(it: fn(uint, char) -> bool) { each_chari(self, it) }\n     #[doc = \"Returns true if one string ends with another\"]\n     #[inline]\n     fn ends_with(needle: str/&) -> bool { ends_with(self, needle) }\n@@ -2644,6 +2678,14 @@ mod tests {\n         assert !contains(data, \"\u0e44\u0e17\u534e\");\n     }\n \n+    #[test]\n+    fn test_contains_char() {\n+        assert contains_char(\"abc\", 'b');\n+        assert contains_char(\"a\", 'a');\n+        assert !contains_char(\"abc\", 'd');\n+        assert !contains_char(\"\", 'a');\n+    }\n+\n     #[test]\n     fn test_chars_iter() {\n         let mut i = 0;"}, {"sha": "d0876dd1062d1685550112cf0eb27b19b4416549", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -652,8 +652,9 @@ type attribute = spanned<attribute_>;\n #[auto_serialize]\n enum attr_style { attr_outer, attr_inner, }\n \n+// doc-comments are promoted to attributes that have is_sugared_doc = true\n #[auto_serialize]\n-type attribute_ = {style: attr_style, value: meta_item};\n+type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n \n /*\n   iface_refs appear in both impls and in classes that implement ifaces."}, {"sha": "64aacf8f0427b3ba9645dda5d9ea7dcd07d2f4ee", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -4,18 +4,21 @@ import std::map;\n import std::map::hashmap;\n import either::either;\n import diagnostic::span_handler;\n-import ast_util::dummy_spanned;\n+import ast_util::{spanned, dummy_spanned};\n+import parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n \n // Constructors\n export mk_name_value_item_str;\n export mk_name_value_item;\n export mk_list_item;\n export mk_word_item;\n export mk_attr;\n+export mk_sugared_doc_attr;\n \n // Conversion\n export attr_meta;\n export attr_metas;\n+export desugar_doc_attr;\n \n // Accessors\n export get_attr_name;\n@@ -66,9 +69,19 @@ fn mk_word_item(+name: ast::ident) -> @ast::meta_item {\n }\n \n fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n-    ret dummy_spanned({style: ast::attr_inner, value: *item});\n+    ret dummy_spanned({style: ast::attr_inner, value: *item,\n+                       is_sugared_doc: false});\n }\n \n+fn mk_sugared_doc_attr(text: str, lo: uint, hi: uint) -> ast::attribute {\n+    let lit = spanned(lo, hi, ast::lit_str(@text));\n+    let attr = {\n+        style: doc_comment_style(text),\n+        value: spanned(lo, hi, ast::meta_name_value(@\"doc\", lit)),\n+        is_sugared_doc: true\n+    };\n+    ret spanned(lo, hi, attr);\n+}\n \n /* Conversion */\n \n@@ -81,6 +94,16 @@ fn attr_metas(attrs: [ast::attribute]/~) -> [@ast::meta_item]/~ {\n     ret mitems;\n }\n \n+fn desugar_doc_attr(attr: ast::attribute) -> ast::attribute {\n+    if attr.node.is_sugared_doc {\n+        let comment = get_meta_item_value_str(@attr.node.value).get();\n+        let meta = mk_name_value_item_str(@\"doc\",\n+                                     strip_doc_comment_decoration(*comment));\n+        ret mk_attr(meta);\n+    } else {\n+        attr\n+    }\n+}\n \n /* Accessors */\n "}, {"sha": "1a2b19509b75dab705fe2337163f1f100ed6b077", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -102,7 +102,8 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n fn fold_attribute_(at: attribute, fld: ast_fold) ->\n    attribute {\n     ret {node: {style: at.node.style,\n-                value: *fold_meta_item_(@at.node.value, fld)},\n+                value: *fold_meta_item_(@at.node.value, fld),\n+                is_sugared_doc: at.node.is_sugared_doc },\n          span: fld.new_span(at.span)};\n }\n //used in noop_fold_foreign_item and noop_fold_fn_decl"}, {"sha": "3b7f31fb79fb2f734334b95a67aa554ce0dd71b3", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 66, "deletions": 20, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -15,7 +15,8 @@ impl parser_attr for parser {\n         -> attr_or_ext\n     {\n         let expect_item_next = vec::is_not_empty(first_item_attrs);\n-        if self.token == token::POUND {\n+        alt self.token {\n+          token::POUND {\n             let lo = self.span.lo;\n             if self.look_ahead(1u) == token::LBRACKET {\n                 self.bump();\n@@ -30,15 +31,40 @@ impl parser_attr for parser {\n                 self.bump();\n                 ret some(right(self.parse_syntax_ext_naked(lo)));\n             } else { ret none; }\n-        } else { ret none; }\n+        }\n+        token::DOC_COMMENT(_) {\n+          ret some(left(self.parse_outer_attributes()));\n+        }\n+        _ {\n+          ret none;\n+        }\n+      }\n     }\n \n     // Parse attributes that appear before an item\n     fn parse_outer_attributes() -> [ast::attribute]/~ {\n         let mut attrs: [ast::attribute]/~ = []/~;\n-        while self.token == token::POUND\n-            && self.look_ahead(1u) == token::LBRACKET {\n-            vec::push(attrs, self.parse_attribute(ast::attr_outer));\n+        loop {\n+            alt copy self.token {\n+              token::POUND {\n+                if self.look_ahead(1u) != token::LBRACKET {\n+                    break;\n+                }\n+                attrs += [self.parse_attribute(ast::attr_outer)]/~;\n+              }\n+              token::DOC_COMMENT(s) {\n+                let attr = ::attr::mk_sugared_doc_attr(\n+                        *self.get_str(s), self.span.lo, self.span.hi);\n+                if attr.node.style != ast::attr_outer {\n+                  self.fatal(\"expected outer comment\");\n+                }\n+                attrs += [attr]/~;\n+                self.bump();\n+              }\n+              _ {\n+                break;\n+              }\n+            }\n         }\n         ret attrs;\n     }\n@@ -55,7 +81,8 @@ impl parser_attr for parser {\n         let meta_item = self.parse_meta_item();\n         self.expect(token::RBRACKET);\n         let mut hi = self.span.hi;\n-        ret spanned(lo, hi, {style: style, value: *meta_item});\n+        ret spanned(lo, hi, {style: style, value: *meta_item,\n+                             is_sugared_doc: false});\n     }\n \n     // Parse attributes that appear after the opening of an item, each\n@@ -68,22 +95,41 @@ impl parser_attr for parser {\n         {inner: [ast::attribute]/~, next: [ast::attribute]/~} {\n         let mut inner_attrs: [ast::attribute]/~ = []/~;\n         let mut next_outer_attrs: [ast::attribute]/~ = []/~;\n-        while self.token == token::POUND {\n-            if self.look_ahead(1u) != token::LBRACKET {\n-                // This is an extension\n-                break;\n-            }\n-            let attr = self.parse_attribute(ast::attr_inner);\n-            if self.token == token::SEMI {\n+        loop {\n+            alt copy self.token {\n+              token::POUND {\n+                if self.look_ahead(1u) != token::LBRACKET {\n+                    // This is an extension\n+                    break;\n+                }\n+                let attr = self.parse_attribute(ast::attr_inner);\n+                if self.token == token::SEMI {\n+                    self.bump();\n+                    inner_attrs += [attr]/~;\n+                } else {\n+                    // It's not really an inner attribute\n+                    let outer_attr =\n+                        spanned(attr.span.lo, attr.span.hi,\n+                            {style: ast::attr_outer, value: attr.node.value,\n+                             is_sugared_doc: false});\n+                    next_outer_attrs += [outer_attr]/~;\n+                    break;\n+                }\n+              }\n+              token::DOC_COMMENT(s) {\n+                let attr = ::attr::mk_sugared_doc_attr(\n+                        *self.get_str(s), self.span.lo, self.span.hi);\n                 self.bump();\n-                vec::push(inner_attrs, attr);\n-            } else {\n-                // It's not really an inner attribute\n-                let outer_attr =\n-                    spanned(attr.span.lo, attr.span.hi,\n-                            {style: ast::attr_outer, value: attr.node.value});\n-                vec::push(next_outer_attrs, outer_attr);\n+                if attr.node.style == ast::attr_inner {\n+                  inner_attrs += [attr]/~;\n+                } else {\n+                  next_outer_attrs += [attr]/~;\n+                  break;\n+                }\n+              }\n+              _ {\n                 break;\n+              }\n             }\n         }\n         ret {inner: inner_attrs, next: next_outer_attrs};"}, {"sha": "7a6a9f0f3d7670c4d29a9a5c36a77d3e45f6769c", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 115, "deletions": 13, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -8,6 +8,7 @@ export cmnt;\n export lit;\n export cmnt_style;\n export gather_comments_and_literals;\n+export is_doc_comment, doc_comment_style, strip_doc_comment_decoration;\n \n enum cmnt_style {\n     isolated, // No code on either side of each line of the comment\n@@ -18,6 +19,81 @@ enum cmnt_style {\n \n type cmnt = {style: cmnt_style, lines: [str]/~, pos: uint};\n \n+fn is_doc_comment(s: str) -> bool {\n+    s.starts_with(\"///\") ||\n+    s.starts_with(\"//!\") ||\n+    s.starts_with(\"/**\") ||\n+    s.starts_with(\"/*!\")\n+}\n+\n+fn doc_comment_style(comment: str) -> ast::attr_style {\n+    assert is_doc_comment(comment);\n+    if comment.starts_with(\"//!\") || comment.starts_with(\"/*!\") {\n+        ast::attr_inner\n+    } else {\n+        ast::attr_outer\n+    }\n+}\n+\n+fn strip_doc_comment_decoration(comment: str) -> str {\n+\n+    /// remove whitespace-only lines from the start/end of lines\n+    fn vertical_trim(lines: [str]/~) -> [str]/~ {\n+        let mut i = 0u, j = lines.len();\n+        while i < j && lines[i].trim().is_empty() {\n+            i += 1u;\n+        }\n+        while j > i && lines[j - 1u].trim().is_empty() {\n+            j -= 1u;\n+        }\n+        ret lines.slice(i, j);\n+    }\n+\n+    // drop leftmost columns that contain only values in chars\n+    fn block_trim(lines: [str]/~, chars: str, max: option<uint>) -> [str]/~ {\n+\n+        let mut i = max.get_default(uint::max_value);\n+        for lines.each {|line|\n+            if line.trim().is_empty() {\n+                cont;\n+            }\n+            for line.each_chari {|j, c|\n+                if j >= i {\n+                    break;\n+                }\n+                if !chars.contains_char(c) {\n+                    i = j;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        ret lines.map {|line|\n+            let chars = str::chars(line);\n+            if i > chars.len() {\n+                \"\"\n+            } else {\n+                str::from_chars(chars.slice(i, chars.len()))\n+            }\n+        };\n+    }\n+\n+    if comment.starts_with(\"//\") {\n+        ret comment.slice(3u, comment.len()).trim();\n+    }\n+\n+    if comment.starts_with(\"/*\") {\n+        let lines = str::lines_any(comment.slice(3u, comment.len() - 2u));\n+        let lines = vertical_trim(lines);\n+        let lines = block_trim(lines, \"\\t \", none);\n+        let lines = block_trim(lines, \"*\", some(1u));\n+        let lines = block_trim(lines, \"\\t \", none);\n+        ret str::connect(lines, \"\\n\");\n+    }\n+\n+    fail \"not a doc-comment: \" + comment;\n+}\n+\n fn read_to_eol(rdr: string_reader) -> str {\n     let mut val = \"\";\n     while rdr.curr != '\\n' && !is_eof(rdr) {\n@@ -57,29 +133,41 @@ fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n     }\n }\n \n-fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool) -> cmnt {\n+\n+fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n+                                                        &comments: [cmnt]/~) {\n     #debug(\">>> shebang comment\");\n     let p = rdr.chpos;\n     #debug(\"<<< shebang comment\");\n-    ret {style: if code_to_the_left { trailing } else { isolated },\n-         lines: [read_one_line_comment(rdr)]/~,\n-         pos: p};\n+    vec::push(comments, {\n+        style: if code_to_the_left { trailing } else { isolated },\n+        lines: [read_one_line_comment(rdr)]/~,\n+        pos: p\n+    });\n }\n \n-fn read_line_comments(rdr: string_reader, code_to_the_left: bool) -> cmnt {\n+fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n+                                                        &comments: [cmnt]/~) {\n     #debug(\">>> line comments\");\n     let p = rdr.chpos;\n     let mut lines: [str]/~ = []/~;\n     while rdr.curr == '/' && nextch(rdr) == '/' {\n         let line = read_one_line_comment(rdr);\n         log(debug, line);\n+        if is_doc_comment(line) { // doc-comments are not put in comments\n+            break;\n+        }\n         vec::push(lines, line);\n         consume_non_eol_whitespace(rdr);\n     }\n     #debug(\"<<< line comments\");\n-    ret {style: if code_to_the_left { trailing } else { isolated },\n-         lines: lines,\n-         pos: p};\n+    if !lines.is_empty() {\n+        vec::push(comments, {\n+            style: if code_to_the_left { trailing } else { isolated },\n+            lines: lines,\n+            pos: p\n+        });\n+    }\n }\n \n fn all_whitespace(s: str, begin: uint, end: uint) -> bool {\n@@ -101,13 +189,27 @@ fn trim_whitespace_prefix_and_push_line(&lines: [str]/~,\n     vec::push(lines, s1);\n }\n \n-fn read_block_comment(rdr: string_reader, code_to_the_left: bool) -> cmnt {\n+fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n+                                                        &comments: [cmnt]/~) {\n     #debug(\">>> block comment\");\n     let p = rdr.chpos;\n     let mut lines: [str]/~ = []/~;\n     let mut col: uint = rdr.col;\n     bump(rdr);\n     bump(rdr);\n+\n+    // doc-comments are not really comments, they are attributes\n+    if rdr.curr == '*' || rdr.curr == '!' {\n+        while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n+            bump(rdr);\n+        }\n+        if !is_eof(rdr) {\n+            bump(rdr);\n+            bump(rdr);\n+        }\n+        ret;\n+    }\n+\n     let mut curr_line = \"/*\";\n     let mut level: int = 1;\n     while level > 0 {\n@@ -143,7 +245,7 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool) -> cmnt {\n         style = mixed;\n     }\n     #debug(\"<<< block comment\");\n-    ret {style: style, lines: lines, pos: p};\n+    vec::push(comments, {style: style, lines: lines, pos: p});\n }\n \n fn peeking_at_comment(rdr: string_reader) -> bool {\n@@ -156,11 +258,11 @@ fn consume_comment(rdr: string_reader, code_to_the_left: bool,\n                    &comments: [cmnt]/~) {\n     #debug(\">>> consume comment\");\n     if rdr.curr == '/' && nextch(rdr) == '/' {\n-        vec::push(comments, read_line_comments(rdr, code_to_the_left));\n+        read_line_comments(rdr, code_to_the_left, comments);\n     } else if rdr.curr == '/' && nextch(rdr) == '*' {\n-        vec::push(comments, read_block_comment(rdr, code_to_the_left));\n+        read_block_comment(rdr, code_to_the_left, comments);\n     } else if rdr.curr == '#' && nextch(rdr) == '!' {\n-        vec::push(comments, read_shebang_comment(rdr, code_to_the_left));\n+        read_shebang_comment(rdr, code_to_the_left, comments);\n     } else { fail; }\n     #debug(\"<<< consume comment\");\n }"}, {"sha": "fec6d23a03b15897a1539fb57ef5b7ec2d3cb6c3", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 57, "deletions": 9, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -161,7 +161,11 @@ impl tt_reader_as_reader of reader for tt_reader {\n }\n \n fn string_advance_token(&&r: string_reader) {\n-    consume_whitespace_and_comments(r);\n+    for consume_whitespace_and_comments(r).each {|comment|\n+        r.peek_tok = comment.tok;\n+        r.peek_span = comment.sp;\n+        ret;\n+    }\n \n     if is_eof(r) {\n         r.peek_tok = token::EOF;\n@@ -277,22 +281,41 @@ fn is_hex_digit(c: char) -> bool {\n \n fn is_bin_digit(c: char) -> bool { ret c == '0' || c == '1'; }\n \n-fn consume_whitespace_and_comments(rdr: string_reader) {\n+// might return a sugared-doc-attr\n+fn consume_whitespace_and_comments(rdr: string_reader)\n+                                -> option<{tok: token::token, sp: span}> {\n     while is_whitespace(rdr.curr) { bump(rdr); }\n     ret consume_any_line_comment(rdr);\n }\n \n-fn consume_any_line_comment(rdr: string_reader) {\n+// might return a sugared-doc-attr\n+fn consume_any_line_comment(rdr: string_reader)\n+                                -> option<{tok: token::token, sp: span}> {\n     if rdr.curr == '/' {\n         alt nextch(rdr) {\n           '/' {\n-            while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n-            // Restart whitespace munch.\n-\n-            ret consume_whitespace_and_comments(rdr);\n+            bump(rdr);\n+            bump(rdr);\n+            // line comments starting with \"///\" or \"//!\" are doc-comments\n+            if rdr.curr == '/' || rdr.curr == '!' {\n+                let start_chpos = rdr.chpos - 2u;\n+                let mut acc = \"//\";\n+                while rdr.curr != '\\n' && !is_eof(rdr) {\n+                    str::push_char(acc, rdr.curr);\n+                    bump(rdr);\n+                }\n+                ret some({\n+                    tok: token::DOC_COMMENT(intern(*rdr.interner, @acc)),\n+                    sp: ast_util::mk_sp(start_chpos, rdr.chpos)\n+                });\n+            } else {\n+                while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n+                // Restart whitespace munch.\n+                ret consume_whitespace_and_comments(rdr);\n+            }\n           }\n           '*' { bump(rdr); bump(rdr); ret consume_block_comment(rdr); }\n-          _ { ret; }\n+          _ {}\n         }\n     } else if rdr.curr == '#' {\n         if nextch(rdr) == '!' {\n@@ -305,9 +328,34 @@ fn consume_any_line_comment(rdr: string_reader) {\n             }\n         }\n     }\n+    ret none;\n }\n \n-fn consume_block_comment(rdr: string_reader) {\n+// might return a sugared-doc-attr\n+fn consume_block_comment(rdr: string_reader)\n+                                -> option<{tok: token::token, sp: span}> {\n+\n+    // block comments starting with \"/**\" or \"/*!\" are doc-comments\n+    if rdr.curr == '*' || rdr.curr == '!' {\n+        let start_chpos = rdr.chpos - 2u;\n+        let mut acc = \"/*\";\n+        while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n+            str::push_char(acc, rdr.curr);\n+            bump(rdr);\n+        }\n+        if is_eof(rdr) {\n+            rdr.fatal(\"unterminated block doc-comment\");\n+        } else {\n+            acc += \"*/\";\n+            bump(rdr);\n+            bump(rdr);\n+            ret some({\n+                tok: token::DOC_COMMENT(intern(*rdr.interner, @acc)),\n+                sp: ast_util::mk_sp(start_chpos, rdr.chpos)\n+            });\n+        }\n+    }\n+\n     let mut level: int = 1;\n     while level > 0 {\n         if is_eof(rdr) { rdr.fatal(\"unterminated block comment\"); }"}, {"sha": "b3db69b5be65e528bae002915d2b7cb8e09a042d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -80,6 +80,7 @@ enum token {\n \n     //ACTUALLY(whole_nonterminal),\n \n+    DOC_COMMENT(str_num),\n     EOF,\n }\n \n@@ -170,11 +171,15 @@ fn to_str(in: interner<@str>, t: token) -> str {\n             + str::escape_default(*interner::get(in, s))\n             + \"\\\"\"\n       }\n+\n       /* Name components */\n       IDENT(s, _) {\n         *interner::get(in, s)\n       }\n       UNDERSCORE { \"_\" }\n+\n+      /* Other */\n+      DOC_COMMENT(s) { *interner::get(in, s) }\n       EOF { \"<eof>\" }\n     }\n }"}, {"sha": "02e9b8931f2832ea8e696a6f3054b97eec51fa01", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -647,7 +647,9 @@ fn print_inner_attributes(s: ps, attrs: [ast::attribute]/~) {\n         alt attr.node.style {\n           ast::attr_inner {\n             print_attribute(s, attr);\n-            word(s.s, \";\");\n+            if !attr.node.is_sugared_doc {\n+                word(s.s, \";\");\n+            }\n             count += 1;\n           }\n           _ {/* fallthrough */ }\n@@ -659,9 +661,15 @@ fn print_inner_attributes(s: ps, attrs: [ast::attribute]/~) {\n fn print_attribute(s: ps, attr: ast::attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n-    word(s.s, \"#[\");\n-    print_meta_item(s, @attr.node.value);\n-    word(s.s, \"]\");\n+    if attr.node.is_sugared_doc {\n+        let meta = attr::attr_meta(attr);\n+        let comment = attr::get_meta_item_value_str(meta).get();\n+        word(s.s, *comment);\n+    } else {\n+        word(s.s, \"#[\");\n+        print_meta_item(s, @attr.node.value);\n+        word(s.s, \"]\");\n+    }\n }\n \n "}, {"sha": "4308a986efd9db2302d9ea5c9717f1104f7ee610", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -233,7 +233,8 @@ mod test {\n                 ast::meta_name_value(\n                     @\"crate_type\",\n                     ast_util::respan(ast_util::dummy_sp(),\n-                                     ast::lit_str(@t))))\n+                                     ast::lit_str(@t)))),\n+            is_sugared_doc: false\n         })\n     }\n "}, {"sha": "300b8be8e28d0dfdd2612f68d9f02552cc56b0ba", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -612,7 +612,8 @@ fn get_attributes(md: ebml::doc) -> [ast::attribute]/~ {\n             assert (vec::len(meta_items) == 1u);\n             let meta_item = meta_items[0];\n             vec::push(attrs,\n-                      {node: {style: ast::attr_outer, value: *meta_item},\n+                      {node: {style: ast::attr_outer, value: *meta_item,\n+                              is_sugared_doc: false},\n                        span: ast_util::dummy_sp()});\n         };\n       }"}, {"sha": "e0a3b12c07cbebd995b28010830f87caa0489783", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -44,7 +44,10 @@ fn doc_meta(\n        doc attribute\"];\n \n     let doc_attrs = attr::find_attrs_by_name(attrs, \"doc\");\n-    let doc_metas = attr::attr_metas(doc_attrs);\n+    let doc_metas = doc_attrs.map {|attr|\n+        attr::attr_meta(attr::desugar_doc_attr(attr))\n+    };\n+\n     if vec::is_not_empty(doc_metas) {\n         if vec::len(doc_metas) != 1u {\n             #warn(\"ignoring %u doc attributes\", vec::len(doc_metas) - 1u);"}, {"sha": "835c1d9640a0f433c0106740214c924fa89bd470", "filename": "src/test/pretty/doc-comments.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Ftest%2Fpretty%2Fdoc-comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b653ab9539140bb04941de9a36c03cf10bfc28b/src%2Ftest%2Fpretty%2Fdoc-comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdoc-comments.rs?ref=0b653ab9539140bb04941de9a36c03cf10bfc28b", "patch": "@@ -0,0 +1,32 @@\n+// pp-exact\n+\n+// some single-line non-doc comment\n+\n+/// some single line outer-docs\n+fn a() { }\n+\n+fn b() {\n+    //! some single line inner-docs\n+}\n+\n+/*\n+ * some multi-line non-doc comment\n+ */\n+\n+/**\n+ * some multi-line outer-docs\n+ */\n+fn c() { }\n+\n+fn d() {\n+    /*!\n+     * some multi-line inner-docs\n+     */\n+}\n+\n+#[doc = \"unsugared outer doc-comments work also\"]\n+fn e() { }\n+\n+fn f() {\n+    #[doc = \"as do inner ones\"];\n+}"}]}