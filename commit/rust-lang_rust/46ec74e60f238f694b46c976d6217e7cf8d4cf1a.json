{"sha": "46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZWM3NGU2MGYyMzhmNjk0YjQ2Yzk3NmQ2MjE3ZTdjZjhkNGNmMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-27T10:00:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-27T10:00:05Z"}, "message": "Auto merge of #71268 - estebank:devectorize, r=eddyb\n\nRemove some `Vec` allocations to improve performance\n\nThis claws back most of the performance lost in https://github.com/rust-lang/rust/pull/69745.\nr? @eddyb", "tree": {"sha": "ee71729ded06b584aac6ffbb4e721b38e3864966", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee71729ded06b584aac6ffbb4e721b38e3864966"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "html_url": "https://github.com/rust-lang/rust/commit/46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d81f5597ac081707346ac68f6938ad6282fc2fee", "url": "https://api.github.com/repos/rust-lang/rust/commits/d81f5597ac081707346ac68f6938ad6282fc2fee", "html_url": "https://github.com/rust-lang/rust/commit/d81f5597ac081707346ac68f6938ad6282fc2fee"}, {"sha": "e7e3001557cc9a2e13bce599e374b474392eb779", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e3001557cc9a2e13bce599e374b474392eb779", "html_url": "https://github.com/rust-lang/rust/commit/e7e3001557cc9a2e13bce599e374b474392eb779"}], "stats": {"total": 301, "additions": 132, "deletions": 169}, "files": [{"sha": "5020dc4132cc34a3d017767339feaf2e66f7cefa", "filename": "src/librustc_infer/infer/outlives/verify.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -223,7 +223,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         // like `T` and `T::Item`. It may not work as well for things\n         // like `<T as Foo<'a>>::Item`.\n         let c_b = self.param_env.caller_bounds;\n-        let param_bounds = self.collect_outlives_from_predicate_list(&compare_ty, c_b);\n+        let param_bounds = self.collect_outlives_from_predicate_list(&compare_ty, c_b.into_iter());\n \n         // Next, collect regions we scraped from the well-formedness\n         // constraints in the fn signature. To do that, we walk the list\n@@ -315,15 +315,12 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         let tcx = self.tcx;\n         let assoc_item = tcx.associated_item(assoc_item_def_id);\n         let trait_def_id = assoc_item.container.assert_trait();\n-        let trait_predicates =\n-            tcx.predicates_of(trait_def_id).predicates.iter().map(|(p, _)| *p).collect();\n+        let trait_predicates = tcx.predicates_of(trait_def_id).predicates.iter().map(|(p, _)| *p);\n         let identity_substs = InternalSubsts::identity_for_item(tcx, assoc_item_def_id);\n         let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n         self.collect_outlives_from_predicate_list(\n             move |ty| ty == identity_proj,\n-            traits::elaborate_predicates(tcx, trait_predicates)\n-                .map(|o| o.predicate)\n-                .collect::<Vec<_>>(),\n+            traits::elaborate_predicates(tcx, trait_predicates).map(|o| o.predicate),\n         )\n         .map(|b| b.1)\n     }\n@@ -337,10 +334,9 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     fn collect_outlives_from_predicate_list(\n         &self,\n         compare_ty: impl Fn(Ty<'tcx>) -> bool,\n-        predicates: impl IntoIterator<Item = impl AsRef<ty::Predicate<'tcx>>>,\n+        predicates: impl Iterator<Item = impl AsRef<ty::Predicate<'tcx>>>,\n     ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         predicates\n-            .into_iter()\n             .filter_map(|p| p.as_ref().to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())\n             .filter(move |p| compare_ty(p.0))"}, {"sha": "55bea57f3e24330d1af5f106954d38bee589d6ab", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -97,24 +97,22 @@ pub fn elaborate_trait_ref<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> Elaborator<'tcx> {\n-    elaborate_predicates(tcx, vec![trait_ref.without_const().to_predicate()])\n+    elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate()))\n }\n \n pub fn elaborate_trait_refs<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n ) -> Elaborator<'tcx> {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate()).collect();\n+    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate());\n     elaborate_predicates(tcx, predicates)\n }\n \n pub fn elaborate_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    mut predicates: Vec<ty::Predicate<'tcx>>,\n+    predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n ) -> Elaborator<'tcx> {\n-    let mut visited = PredicateSet::new(tcx);\n-    predicates.retain(|pred| visited.insert(pred));\n-    let obligations: Vec<_> =\n+    let obligations =\n         predicates.into_iter().map(|predicate| predicate_obligation(predicate, None)).collect();\n     elaborate_obligations(tcx, obligations)\n }\n@@ -151,21 +149,20 @@ impl Elaborator<'tcx> {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n-                let obligations = predicates.predicates.iter().map(|(pred, span)| {\n+                let obligations = predicates.predicates.into_iter().map(|(pred, span)| {\n                     predicate_obligation(\n                         pred.subst_supertrait(tcx, &data.to_poly_trait_ref()),\n                         Some(*span),\n                     )\n                 });\n-                debug!(\"super_predicates: data={:?} predicates={:?}\", data, &obligations);\n+                debug!(\"super_predicates: data={:?}\", data);\n \n                 // Only keep those bounds that we haven't already seen.\n                 // This is necessary to prevent infinite recursion in some\n                 // cases. One common case is when people define\n                 // `trait Sized: Sized { }` rather than `trait Sized { }`.\n                 let visited = &mut self.visited;\n-                let obligations =\n-                    obligations.filter(|obligation| visited.insert(&obligation.predicate));\n+                let obligations = obligations.filter(|o| visited.insert(&o.predicate));\n \n                 self.stack.extend(obligations);\n             }"}, {"sha": "72dfebd8ccd44e79c8e4eca565324162e73031c6", "filename": "src/librustc_middle/ty/trait_def.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -168,15 +168,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns a vector containing all impls\n-    pub fn all_impls(self, def_id: DefId) -> Vec<DefId> {\n-        let impls = self.trait_impls_of(def_id);\n+    pub fn all_impls(self, def_id: DefId) -> impl Iterator<Item = DefId> + 'tcx {\n+        let TraitImpls { blanket_impls, non_blanket_impls } = self.trait_impls_of(def_id);\n \n-        impls\n-            .blanket_impls\n-            .iter()\n-            .chain(impls.non_blanket_impls.values().flatten())\n+        blanket_impls\n+            .into_iter()\n+            .chain(non_blanket_impls.into_iter().map(|(_, v)| v).flatten())\n             .cloned()\n-            .collect()\n     }\n }\n "}, {"sha": "abe9249ec3766136a92d69110fcbed1d19c70eca", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -116,8 +116,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             .predicates_of(source.def_id())\n             .predicates\n             .iter()\n-            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None })\n-            .collect();\n+            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n         if !traits::normalize_and_test_predicates(\n             tcx,\n             traits::elaborate_predicates(tcx, predicates).map(|o| o.predicate).collect(),"}, {"sha": "e208698e962f9d30eb0b230e47d73f74ad592dab", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -418,7 +418,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let opaque_type = tcx.mk_opaque(def_id, opaque_defn.substs);\n \n             let required_region_bounds =\n-                required_region_bounds(tcx, opaque_type, bounds.predicates);\n+                required_region_bounds(tcx, opaque_type, bounds.predicates.into_iter());\n             debug_assert!(!required_region_bounds.is_empty());\n \n             for required_region in required_region_bounds {\n@@ -1137,7 +1137,8 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n         debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n \n-        let required_region_bounds = required_region_bounds(tcx, ty, bounds.predicates.clone());\n+        let required_region_bounds =\n+            required_region_bounds(tcx, ty, bounds.predicates.iter().cloned());\n         debug!(\"instantiate_opaque_types: required_region_bounds={:?}\", required_region_bounds);\n \n         // Make sure that we are in fact defining the *entire* type\n@@ -1259,17 +1260,15 @@ pub fn may_define_opaque_type(\n crate fn required_region_bounds(\n     tcx: TyCtxt<'tcx>,\n     erased_self_ty: Ty<'tcx>,\n-    predicates: Vec<ty::Predicate<'tcx>>,\n+    predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n ) -> Vec<ty::Region<'tcx>> {\n-    debug!(\n-        \"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n-        erased_self_ty, predicates\n-    );\n+    debug!(\"required_region_bounds(erased_self_ty={:?})\", erased_self_ty);\n \n     assert!(!erased_self_ty.has_escaping_bound_vars());\n \n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|obligation| {\n+            debug!(\"required_region_bounds(obligation={:?})\", obligation);\n             match obligation.predicate {\n                 ty::Predicate::Projection(..)\n                 | ty::Predicate::Trait(..)"}, {"sha": "6326a87c5edc366014692dc5aeb4ab8f3254347f", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -281,7 +281,7 @@ impl AutoTraitFinder<'tcx> {\n             },\n         }));\n \n-        let mut computed_preds: FxHashSet<_> = param_env.caller_bounds.iter().cloned().collect();\n+        let computed_preds = param_env.caller_bounds.iter().cloned();\n         let mut user_computed_preds: FxHashSet<_> =\n             user_env.caller_bounds.iter().cloned().collect();\n \n@@ -358,10 +358,11 @@ impl AutoTraitFinder<'tcx> {\n                 _ => panic!(\"Unexpected error for '{:?}': {:?}\", ty, result),\n             };\n \n-            computed_preds.extend(user_computed_preds.iter().cloned());\n-            let normalized_preds =\n-                elaborate_predicates(tcx, computed_preds.iter().cloned().collect())\n-                    .map(|o| o.predicate);\n+            let normalized_preds = elaborate_predicates(\n+                tcx,\n+                computed_preds.clone().chain(user_computed_preds.iter().cloned()),\n+            )\n+            .map(|o| o.predicate);\n             new_env =\n                 ty::ParamEnv::new(tcx.mk_predicates(normalized_preds), param_env.reveal, None);\n         }\n@@ -739,7 +740,7 @@ impl AutoTraitFinder<'tcx> {\n                             if p.ty().skip_binder().has_infer_types() {\n                                 if !self.evaluate_nested_obligations(\n                                     ty,\n-                                    v.clone().iter().cloned(),\n+                                    v.into_iter(),\n                                     computed_preds,\n                                     fresh_preds,\n                                     predicates,"}, {"sha": "fa2af24c9453464b1aec30a9dbee0c3eba8a2a0f", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -1017,7 +1017,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        for obligation in super::elaborate_predicates(self.tcx, vec![*cond]) {\n+        for obligation in super::elaborate_predicates(self.tcx, std::iter::once(*cond)) {\n             if let ty::Predicate::Trait(implication, _) = obligation.predicate {\n                 let error = error.to_poly_trait_ref();\n                 let implication = implication.to_poly_trait_ref();\n@@ -1218,22 +1218,18 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         match simp {\n             Some(simp) => all_impls\n-                .iter()\n-                .filter_map(|&def_id| {\n+                .filter_map(|def_id| {\n                     let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n                     let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n                     if let Some(imp_simp) = imp_simp {\n                         if simp != imp_simp {\n                             return None;\n                         }\n                     }\n-\n                     Some(imp)\n                 })\n                 .collect(),\n-            None => {\n-                all_impls.iter().map(|&def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect()\n-            }\n+            None => all_impls.map(|def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect(),\n         }\n     }\n "}, {"sha": "c5dbe816295504c7d391b03b0c27ebe35d4fce50", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -110,8 +110,8 @@ pub enum TraitQueryMode {\n pub fn predicates_for_generics<'tcx>(\n     cause: ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n-) -> PredicateObligations<'tcx> {\n+    generic_bounds: ty::InstantiatedPredicates<'tcx>,\n+) -> impl Iterator<Item = PredicateObligation<'tcx>> {\n     util::predicates_for_generics(cause, 0, param_env, generic_bounds)\n }\n \n@@ -297,7 +297,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     );\n \n     let mut predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec())\n+        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.into_iter().cloned())\n             .map(|obligation| obligation.predicate)\n             .collect();\n "}, {"sha": "96b2b904e65436fe26709ffc06e8c388da38b5ef", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -302,7 +302,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n-    elaborate_predicates(tcx, predicates).any(|obligation| match obligation.predicate {\n+    elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| match obligation.predicate {\n         ty::Predicate::Trait(ref trait_pred, _) => {\n             trait_pred.def_id() == sized_def_id && trait_pred.skip_binder().self_ty().is_param(0)\n         }"}, {"sha": "2b4a0409fd1e23a2e90f95d3e34f6ad318259e8e", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -900,7 +900,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     // If so, extract what we know from the trait and try to come up with a good answer.\n     let trait_predicates = tcx.predicates_of(def_id);\n     let bounds = trait_predicates.instantiate(tcx, substs);\n-    let bounds = elaborate_predicates(tcx, bounds.predicates).map(|o| o.predicate);\n+    let bounds = elaborate_predicates(tcx, bounds.predicates.into_iter()).map(|o| o.predicate);\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n@@ -911,16 +911,14 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     )\n }\n \n-fn assemble_candidates_from_predicates<'cx, 'tcx, I>(\n+fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n-    env_predicates: I,\n-) where\n-    I: IntoIterator<Item = ty::Predicate<'tcx>>,\n-{\n+    env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n+) {\n     debug!(\"assemble_candidates_from_predicates(obligation={:?})\", obligation);\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n@@ -1153,10 +1151,8 @@ fn confirm_object_candidate<'cx, 'tcx>(\n             object_ty\n         ),\n     };\n-    let env_predicates = data\n-        .projection_bounds()\n-        .map(|p| p.with_self_ty(selcx.tcx(), object_ty).to_predicate())\n-        .collect();\n+    let env_predicates =\n+        data.projection_bounds().map(|p| p.with_self_ty(selcx.tcx(), object_ty).to_predicate());\n     let env_predicate = {\n         let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n "}, {"sha": "dfbb07424487d43a786ec1c62a117a8fb71cb62f", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -1443,7 +1443,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             bounds\n         );\n \n-        let elaborated_predicates = util::elaborate_predicates(self.tcx(), bounds.predicates);\n+        let elaborated_predicates =\n+            util::elaborate_predicates(self.tcx(), bounds.predicates.into_iter());\n         let matching_bound = elaborated_predicates.filter_to_traits().find(|bound| {\n             self.infcx.probe(|_| {\n                 self.match_projection("}, {"sha": "897ac0d736e08fb1858b92d6339171f7f042a590", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -189,26 +189,22 @@ fn fulfill_implication<'a, 'tcx>(\n \n     let selcx = &mut SelectionContext::new(&infcx);\n     let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n-    let (target_trait_ref, mut obligations) =\n+    let (target_trait_ref, obligations) =\n         impl_trait_ref_and_oblig(selcx, param_env, target_impl, target_substs);\n-    debug!(\n-        \"fulfill_implication: target_trait_ref={:?}, obligations={:?}\",\n-        target_trait_ref, obligations\n-    );\n \n     // do the impls unify? If not, no specialization.\n-    match infcx.at(&ObligationCause::dummy(), param_env).eq(source_trait_ref, target_trait_ref) {\n-        Ok(InferOk { obligations: o, .. }) => {\n-            obligations.extend(o);\n-        }\n-        Err(_) => {\n-            debug!(\n-                \"fulfill_implication: {:?} does not unify with {:?}\",\n-                source_trait_ref, target_trait_ref\n-            );\n-            return Err(());\n-        }\n-    }\n+    let more_obligations =\n+        match infcx.at(&ObligationCause::dummy(), param_env).eq(source_trait_ref, target_trait_ref)\n+        {\n+            Ok(InferOk { obligations, .. }) => obligations,\n+            Err(_) => {\n+                debug!(\n+                    \"fulfill_implication: {:?} does not unify with {:?}\",\n+                    source_trait_ref, target_trait_ref\n+                );\n+                return Err(());\n+            }\n+        };\n \n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n@@ -226,7 +222,7 @@ fn fulfill_implication<'a, 'tcx>(\n         // we already make a mockery out of the region system, so\n         // why not ignore them a bit earlier?\n         let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n-        for oblig in obligations.into_iter() {\n+        for oblig in obligations.chain(more_obligations) {\n             fulfill_cx.register_predicate_obligation(&infcx, oblig);\n         }\n         match fulfill_cx.select_all_or_error(infcx) {\n@@ -261,7 +257,7 @@ pub(super) fn specialization_graph_provider(\n ) -> &specialization_graph::Graph {\n     let mut sg = specialization_graph::Graph::new();\n \n-    let mut trait_impls = tcx.all_impls(trait_id);\n+    let mut trait_impls: Vec<_> = tcx.all_impls(trait_id).collect();\n \n     // The coherence checking implementation seems to rely on impls being\n     // iterated over (roughly) in definition order, so we are sorting by"}, {"sha": "4aceccf64ce65156351dacf01680099a14fe6047", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -81,12 +81,10 @@ impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n \n pub fn expand_trait_aliases<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>,\n+    trait_refs: impl Iterator<Item = (ty::PolyTraitRef<'tcx>, Span)>,\n ) -> TraitAliasExpander<'tcx> {\n-    let items: Vec<_> = trait_refs\n-        .into_iter()\n-        .map(|(trait_ref, span)| TraitAliasExpansionInfo::new(trait_ref, span))\n-        .collect();\n+    let items: Vec<_> =\n+        trait_refs.map(|(trait_ref, span)| TraitAliasExpansionInfo::new(trait_ref, span)).collect();\n     TraitAliasExpander { tcx, stack: items }\n }\n \n@@ -199,7 +197,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     impl_def_id: DefId,\n     impl_substs: SubstsRef<'tcx>,\n-) -> (ty::TraitRef<'tcx>, Vec<PredicateObligation<'tcx>>) {\n+) -> (ty::TraitRef<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n     let impl_trait_ref = selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n     let impl_trait_ref = impl_trait_ref.subst(selcx.tcx(), impl_substs);\n     let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n@@ -210,13 +208,11 @@ pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n         super::normalize(selcx, param_env, ObligationCause::dummy(), &predicates);\n     let impl_obligations =\n-        predicates_for_generics(ObligationCause::dummy(), 0, param_env, &predicates);\n+        predicates_for_generics(ObligationCause::dummy(), 0, param_env, predicates);\n \n-    let impl_obligations: Vec<_> = impl_obligations\n-        .into_iter()\n-        .chain(normalization_obligations1)\n-        .chain(normalization_obligations2)\n-        .collect();\n+    let impl_obligations = impl_obligations\n+        .chain(normalization_obligations1.into_iter())\n+        .chain(normalization_obligations2.into_iter());\n \n     (impl_trait_ref, impl_obligations)\n }\n@@ -226,20 +222,16 @@ pub fn predicates_for_generics<'tcx>(\n     cause: ObligationCause<'tcx>,\n     recursion_depth: usize,\n     param_env: ty::ParamEnv<'tcx>,\n-    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n-) -> Vec<PredicateObligation<'tcx>> {\n+    generic_bounds: ty::InstantiatedPredicates<'tcx>,\n+) -> impl Iterator<Item = PredicateObligation<'tcx>> {\n     debug!(\"predicates_for_generics(generic_bounds={:?})\", generic_bounds);\n \n-    generic_bounds\n-        .predicates\n-        .iter()\n-        .map(|&predicate| Obligation {\n-            cause: cause.clone(),\n-            recursion_depth,\n-            param_env,\n-            predicate,\n-        })\n-        .collect()\n+    generic_bounds.predicates.into_iter().map(move |predicate| Obligation {\n+        cause: cause.clone(),\n+        recursion_depth,\n+        param_env,\n+        predicate,\n+    })\n }\n \n pub fn predicate_for_trait_ref<'tcx>("}, {"sha": "7eabdf706ef9f0941e0689cc9172ef7a7dba007c", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -140,7 +140,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n     item: Option<&hir::Item<'tcx>>,\n     cause: &mut traits::ObligationCause<'tcx>,\n     pred: &ty::Predicate<'_>,\n-    mut trait_assoc_items: impl Iterator<Item = ty::AssocItem>,\n+    mut trait_assoc_items: impl Iterator<Item = &'tcx ty::AssocItem>,\n ) {\n     debug!(\n         \"extended_cause_with_original_assoc_item_obligation {:?} {:?} {:?} {:?}\",\n@@ -232,35 +232,34 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n         let item = self.item;\n \n+        let extend = |obligation: traits::PredicateObligation<'tcx>| {\n+            let mut cause = cause.clone();\n+            if let Some(parent_trait_ref) = obligation.predicate.to_opt_poly_trait_ref() {\n+                let derived_cause = traits::DerivedObligationCause {\n+                    parent_trait_ref,\n+                    parent_code: Rc::new(obligation.cause.code.clone()),\n+                };\n+                cause.code = traits::ObligationCauseCode::DerivedObligation(derived_cause);\n+            }\n+            extend_cause_with_original_assoc_item_obligation(\n+                tcx,\n+                trait_ref,\n+                item,\n+                &mut cause,\n+                &obligation.predicate,\n+                tcx.associated_items(trait_ref.def_id).in_definition_order(),\n+            );\n+            traits::Obligation::new(cause, param_env, obligation.predicate)\n+        };\n+\n         if let Elaborate::All = elaborate {\n-            let implied_obligations = traits::util::elaborate_obligations(tcx, obligations.clone());\n-            let implied_obligations = implied_obligations.map(|obligation| {\n-                debug!(\"compute_trait_ref implied_obligation {:?}\", obligation);\n-                debug!(\"compute_trait_ref implied_obligation cause {:?}\", obligation.cause);\n-                let mut cause = cause.clone();\n-                if let Some(parent_trait_ref) = obligation.predicate.to_opt_poly_trait_ref() {\n-                    let derived_cause = traits::DerivedObligationCause {\n-                        parent_trait_ref,\n-                        parent_code: Rc::new(obligation.cause.code.clone()),\n-                    };\n-                    cause.code = traits::ObligationCauseCode::DerivedObligation(derived_cause);\n-                }\n-                extend_cause_with_original_assoc_item_obligation(\n-                    tcx,\n-                    trait_ref,\n-                    item,\n-                    &mut cause,\n-                    &obligation.predicate,\n-                    tcx.associated_items(trait_ref.def_id).in_definition_order().copied(),\n-                );\n-                debug!(\"compute_trait_ref new cause {:?}\", cause);\n-                traits::Obligation::new(cause, param_env, obligation.predicate)\n-            });\n+            let implied_obligations = traits::util::elaborate_obligations(tcx, obligations);\n+            let implied_obligations = implied_obligations.map(extend);\n             self.out.extend(implied_obligations);\n+        } else {\n+            self.out.extend(obligations);\n         }\n \n-        self.out.extend(obligations);\n-\n         self.out.extend(trait_ref.substs.types().filter(|ty| !ty.has_escaping_bound_vars()).map(\n             |ty| traits::Obligation::new(cause.clone(), param_env, ty::Predicate::WellFormed(ty)),\n         ));\n@@ -627,16 +626,13 @@ pub fn object_region_bounds<'tcx>(\n     // a placeholder type.\n     let open_ty = tcx.mk_ty_infer(ty::FreshTy(0));\n \n-    let predicates = existential_predicates\n-        .iter()\n-        .filter_map(|predicate| {\n-            if let ty::ExistentialPredicate::Projection(_) = *predicate.skip_binder() {\n-                None\n-            } else {\n-                Some(predicate.with_self_ty(tcx, open_ty))\n-            }\n-        })\n-        .collect();\n+    let predicates = existential_predicates.iter().filter_map(|predicate| {\n+        if let ty::ExistentialPredicate::Projection(_) = *predicate.skip_binder() {\n+            None\n+        } else {\n+            Some(predicate.with_self_ty(tcx, open_ty))\n+        }\n+    });\n \n     required_region_bounds(tcx, open_ty, predicates)\n }"}, {"sha": "64dc34ab3b0a7d0bec9a238e60b594a5b74ed2fc", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // a custom error in that case.\n         if illegal_sized_bound.is_none() {\n             let method_ty = self.tcx.mk_fn_ptr(ty::Binder::bind(method_sig));\n-            self.add_obligations(method_ty, all_substs, &method_predicates);\n+            self.add_obligations(method_ty, all_substs, method_predicates);\n         }\n \n         // Create the final `MethodCallee`.\n@@ -394,7 +394,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         &mut self,\n         fty: Ty<'tcx>,\n         all_substs: SubstsRef<'tcx>,\n-        method_predicates: &ty::InstantiatedPredicates<'tcx>,\n+        method_predicates: ty::InstantiatedPredicates<'tcx>,\n     ) {\n         debug!(\n             \"add_obligations: fty={:?} all_substs={:?} method_predicates={:?}\",\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             None => return None,\n         };\n \n-        traits::elaborate_predicates(self.tcx, predicates.predicates.clone())\n+        traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             .filter_map(|obligation| match obligation.predicate {\n                 ty::Predicate::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n                     let span = predicates"}, {"sha": "ae2061a2e3f3c96520bfb4406b5987d3dde39779", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -390,7 +390,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         assert!(!bounds.has_escaping_bound_vars());\n \n         let cause = traits::ObligationCause::misc(span, self.body_id);\n-        obligations.extend(traits::predicates_for_generics(cause.clone(), self.param_env, &bounds));\n+        obligations.extend(traits::predicates_for_generics(cause.clone(), self.param_env, bounds));\n \n         // Also add an obligation for the method type being well-formed.\n         let method_ty = tcx.mk_fn_ptr(ty::Binder::bind(fn_sig));"}, {"sha": "03e32c21a54ac846b2dd1d4ddf68a29a39898681", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -1342,7 +1342,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // clauses) that must be considered. Make sure that those\n             // match as well (or at least may match, sometimes we\n             // don't have enough information to fully evaluate).\n-            let candidate_obligations: Vec<_> = match probe.kind {\n+            match probe.kind {\n                 InherentImplCandidate(ref substs, ref ref_obligations) => {\n                     // Check whether the impl imposes obligations we have to worry about.\n                     let impl_def_id = probe.item.container.id();\n@@ -1353,19 +1353,23 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n                     // Convert the bounds into obligations.\n                     let impl_obligations =\n-                        traits::predicates_for_generics(cause, self.param_env, &impl_bounds);\n+                        traits::predicates_for_generics(cause, self.param_env, impl_bounds);\n \n-                    debug!(\"impl_obligations={:?}\", impl_obligations);\n-                    impl_obligations\n-                        .into_iter()\n+                    let candidate_obligations = impl_obligations\n                         .chain(norm_obligations.into_iter())\n-                        .chain(ref_obligations.iter().cloned())\n-                        .collect()\n+                        .chain(ref_obligations.iter().cloned());\n+                    // Evaluate those obligations to see if they might possibly hold.\n+                    for o in candidate_obligations {\n+                        let o = self.resolve_vars_if_possible(&o);\n+                        if !self.predicate_may_hold(&o) {\n+                            result = ProbeResult::NoMatch;\n+                            possibly_unsatisfied_predicates.push((o.predicate, None));\n+                        }\n+                    }\n                 }\n \n                 ObjectCandidate | WhereClauseCandidate(..) => {\n                     // These have no additional conditions to check.\n-                    vec![]\n                 }\n \n                 TraitCandidate(trait_ref) => {\n@@ -1412,17 +1416,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                             return ProbeResult::NoMatch;\n                         }\n                     }\n-                    vec![]\n                 }\n-            };\n-\n-            debug!(\n-                \"consider_probe - candidate_obligations={:?} sub_obligations={:?}\",\n-                candidate_obligations, sub_obligations\n-            );\n+            }\n \n             // Evaluate those obligations to see if they might possibly hold.\n-            for o in candidate_obligations.into_iter().chain(sub_obligations) {\n+            for o in sub_obligations {\n                 let o = self.resolve_vars_if_possible(&o);\n                 if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;"}, {"sha": "fc96a26a2c7eec2be910a97566434409ed952046", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -3460,7 +3460,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn add_obligations_for_parameters(\n         &self,\n         cause: traits::ObligationCause<'tcx>,\n-        predicates: &ty::InstantiatedPredicates<'tcx>,\n+        predicates: ty::InstantiatedPredicates<'tcx>,\n     ) {\n         assert!(!predicates.has_escaping_bound_vars());\n \n@@ -4411,7 +4411,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let (bounds, _) = self.instantiate_bounds(path_span, did, substs);\n             let cause =\n                 traits::ObligationCause::new(path_span, self.body_id, traits::ItemObligation(did));\n-            self.add_obligations_for_parameters(cause, &bounds);\n+            self.add_obligations_for_parameters(cause, bounds);\n \n             Some((variant, ty))\n         } else {\n@@ -5681,9 +5681,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for (i, mut obligation) in traits::predicates_for_generics(\n             traits::ObligationCause::new(span, self.body_id, traits::ItemObligation(def_id)),\n             self.param_env,\n-            &bounds,\n+            bounds,\n         )\n-        .into_iter()\n         .enumerate()\n         {\n             // This makes the error point at the bound, but we want to point at the argument"}, {"sha": "7eb8bf7c6be97803a89daffbd07b1263444cffb0", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -1233,7 +1233,7 @@ fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, span: Span, id: hir::HirId) {\n     let empty_env = ty::ParamEnv::empty();\n \n     let def_id = fcx.tcx.hir().local_def_id(id);\n-    let predicates = fcx.tcx.predicates_of(def_id).predicates.iter().map(|(p, _)| *p).collect();\n+    let predicates = fcx.tcx.predicates_of(def_id).predicates.iter().map(|(p, _)| *p);\n     // Check elaborated bounds.\n     let implied_obligations = traits::elaborate_predicates(fcx.tcx, predicates);\n "}, {"sha": "8b12535b3a2cf2c57873f29a9319bca9c35ae26b", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "patch": "@@ -329,7 +329,7 @@ fn check_predicates<'tcx>(\n     // which is sound because we forbid impls like the following\n     //\n     // impl<D: Debug> AlwaysApplicable for D { }\n-    let always_applicable_traits: Vec<_> = impl1_predicates\n+    let always_applicable_traits = impl1_predicates\n         .predicates\n         .iter()\n         .filter(|predicate| {\n@@ -338,8 +338,7 @@ fn check_predicates<'tcx>(\n                 Some(TraitSpecializationKind::AlwaysApplicable)\n             )\n         })\n-        .copied()\n-        .collect();\n+        .copied();\n \n     // Include the well-formed predicates of the type parameters of the impl.\n     for ty in tcx.impl_trait_ref(impl1_def_id).unwrap().substs.types() {"}]}