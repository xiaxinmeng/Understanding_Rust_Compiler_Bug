{"sha": "5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "node_id": "C_kwDOAAsO6NoAKDVkOWY1MTQ1YWM5Y2UwN2Q3OWFlYjc1YWQwNDljYWI5NTdiMGZiOTI", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2021-06-16T05:46:56Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2023-02-07T09:37:55Z"}, "message": "Rm allocation in candidate\n\nInstead of storing an extra array for discriminant values, create an allocation there and store\nthose in an allocation immediately.", "tree": {"sha": "39d1ba31d7bce333c72c25c6c3158f5cb5c02e16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39d1ba31d7bce333c72c25c6c3158f5cb5c02e16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "html_url": "https://github.com/rust-lang/rust/commit/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e97cef7e5696a57f1b528b2bf551a2e3721100d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e97cef7e5696a57f1b528b2bf551a2e3721100d", "html_url": "https://github.com/rust-lang/rust/commit/3e97cef7e5696a57f1b528b2bf551a2e3721100d"}], "stats": {"total": 1027, "additions": 746, "deletions": 281}, "files": [{"sha": "51bf880313a63b9375da3204882b8282aeff12bc", "filename": "compiler/rustc_mir/src/transform/large_enums.rs", "status": "removed", "additions": 0, "deletions": 278, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/3e97cef7e5696a57f1b528b2bf551a2e3721100d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flarge_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e97cef7e5696a57f1b528b2bf551a2e3721100d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flarge_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flarge_enums.rs?ref=3e97cef7e5696a57f1b528b2bf551a2e3721100d", "patch": "@@ -1,278 +0,0 @@\n-use crate::transform::MirPass;\n-use rustc_data_structures::stable_map::FxHashMap;\n-use rustc_middle::mir::*;\n-use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n-use rustc_span::def_id::DefId;\n-use rustc_target::abi::{HasDataLayout, Size, TagEncoding, Variants};\n-use std::array::IntoIter;\n-\n-/// A pass that seeks to optimize unnecessary moves of large enum types, if there is a large\n-/// enough discrepanc between them\n-pub struct EnumSizeOpt<const DISCREPANCY: u64>;\n-\n-impl<'tcx, const D: u64> MirPass<'tcx> for EnumSizeOpt<D> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        self.optim(tcx, body);\n-    }\n-}\n-\n-impl<const D: u64> EnumSizeOpt<D> {\n-    fn candidate<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        ty: Ty<'tcx>,\n-        body_did: DefId,\n-    ) -> Option<(u64, Vec<Size>)> {\n-        match ty.kind() {\n-            ty::Adt(adt_def, _substs) if adt_def.is_enum() => {\n-                let p_e = tcx.param_env(body_did);\n-                let layout =\n-                    if let Ok(layout) = tcx.layout_of(p_e.and(ty)) { layout } else { return None };\n-                let variants = &layout.variants;\n-                match variants {\n-                    Variants::Single { .. } => None,\n-                    Variants::Multiple { variants, .. } if variants.len() <= 1 => None,\n-                    Variants::Multiple { tag_encoding, .. }\n-                        if matches!(tag_encoding, TagEncoding::Niche { .. }) =>\n-                    {\n-                        None\n-                    }\n-                    Variants::Multiple { variants, .. } => {\n-                        let min = variants.iter().map(|v| v.size).min().unwrap();\n-                        let max = variants.iter().map(|v| v.size).max().unwrap();\n-                        if max.bytes() - min.bytes() < D {\n-                            return None;\n-                        }\n-                        let mut discr_sizes = vec![Size::ZERO; adt_def.discriminants(tcx).count()];\n-                        for (var_idx, layout) in variants.iter_enumerated() {\n-                            let disc_idx =\n-                                adt_def.discriminant_for_variant(tcx, var_idx).val as usize;\n-                            assert_eq!(discr_sizes[disc_idx], Size::ZERO);\n-                            discr_sizes[disc_idx] = layout.size;\n-                        }\n-                        Some((variants.len() as u64, discr_sizes))\n-                    }\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n-    fn optim(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let mut alloc_cache = FxHashMap::default();\n-        let body_did = body.source.def_id();\n-        let (bbs, local_decls) = body.basic_blocks_and_local_decls_mut();\n-        for bb in bbs {\n-            bb.expand_statements(|st| {\n-                match &st.kind {\n-                    StatementKind::Assign(box (\n-                        lhs,\n-                        Rvalue::Use(Operand::Copy(rhs) | Operand::Move(rhs)),\n-                    )) => {\n-                        let ty = lhs.ty(local_decls, tcx).ty;\n-\n-                        let source_info = st.source_info;\n-                        let span = source_info.span;\n-\n-                        let (num_variants, sizes) =\n-                            if let Some(cand) = Self::candidate(tcx, ty, body_did) {\n-                                cand\n-                            } else {\n-                                return None;\n-                            };\n-                        let adt_def = ty.ty_adt_def().unwrap();\n-                        let alloc = if let Some(alloc) = alloc_cache.get(ty) {\n-                            alloc\n-                        } else {\n-                            let data_layout = tcx.data_layout();\n-                            let ptr_sized_int = data_layout.ptr_sized_integer();\n-                            let target_bytes = ptr_sized_int.size().bytes() as usize;\n-                            let mut data = vec![0; target_bytes * num_variants as usize];\n-                            let mut curr = 0;\n-                            macro_rules! encode_store {\n-                                ($endian: expr, $bytes: expr) => {\n-                                    let bytes = match $endian {\n-                                        rustc_target::abi::Endian::Little => $bytes.to_le_bytes(),\n-                                        rustc_target::abi::Endian::Big => $bytes.to_be_bytes(),\n-                                    };\n-                                    for b in bytes {\n-                                        data[curr] = b;\n-                                        curr += 1;\n-                                    }\n-                                };\n-                            }\n-\n-                            for sz in sizes {\n-                                match ptr_sized_int {\n-                                    rustc_target::abi::Integer::I32 => {\n-                                        encode_store!(data_layout.endian, sz.bytes() as u32);\n-                                    }\n-                                    rustc_target::abi::Integer::I64 => {\n-                                        encode_store!(data_layout.endian, sz.bytes());\n-                                    }\n-                                    _ => unreachable!(),\n-                                };\n-                            }\n-                            let alloc = interpret::Allocation::from_bytes(\n-                                data,\n-                                tcx.data_layout.ptr_sized_integer().align(&tcx.data_layout).abi,\n-                                Mutability::Not,\n-                            );\n-                            let alloc = tcx.intern_const_alloc(alloc);\n-                            alloc_cache.insert(ty, alloc);\n-                            // FIXME(jknodt) use entry API\n-                            alloc_cache.get(ty).unwrap()\n-                        };\n-\n-                        let tmp_ty = tcx.mk_ty(ty::Array(\n-                            tcx.types.usize,\n-                            Const::from_usize(tcx, num_variants),\n-                        ));\n-\n-                        let size_array_local = local_decls.push(LocalDecl::new(tmp_ty, span));\n-                        let store_live = Statement {\n-                            source_info,\n-                            kind: StatementKind::StorageLive(size_array_local),\n-                        };\n-\n-                        let place = Place::from(size_array_local);\n-                        let constant_vals = Constant {\n-                            span,\n-                            user_ty: None,\n-                            literal: ConstantKind::Val(\n-                                interpret::ConstValue::ByRef { alloc, offset: Size::ZERO },\n-                                tmp_ty,\n-                            ),\n-                        };\n-                        let rval = Rvalue::Use(Operand::Constant(box (constant_vals)));\n-\n-                        let const_assign = Statement {\n-                            source_info,\n-                            kind: StatementKind::Assign(box (place, rval)),\n-                        };\n-\n-                        let discr_place = Place::from(\n-                            local_decls\n-                                .push(LocalDecl::new(adt_def.repr.discr_type().to_ty(tcx), span)),\n-                        );\n-\n-                        let store_discr = Statement {\n-                            source_info,\n-                            kind: StatementKind::Assign(box (\n-                                discr_place,\n-                                Rvalue::Discriminant(*rhs),\n-                            )),\n-                        };\n-\n-                        let discr_cast_place =\n-                            Place::from(local_decls.push(LocalDecl::new(tcx.types.usize, span)));\n-\n-                        let cast_discr = Statement {\n-                            source_info,\n-                            kind: StatementKind::Assign(box (\n-                                discr_cast_place,\n-                                Rvalue::Cast(\n-                                    CastKind::Misc,\n-                                    Operand::Copy(discr_place),\n-                                    tcx.types.usize,\n-                                ),\n-                            )),\n-                        };\n-\n-                        let size_place =\n-                            Place::from(local_decls.push(LocalDecl::new(tcx.types.usize, span)));\n-\n-                        let store_size = Statement {\n-                            source_info,\n-                            kind: StatementKind::Assign(box (\n-                                size_place,\n-                                Rvalue::Use(Operand::Copy(Place {\n-                                    local: size_array_local,\n-                                    projection: tcx.intern_place_elems(&[PlaceElem::Index(\n-                                        discr_cast_place.local,\n-                                    )]),\n-                                })),\n-                            )),\n-                        };\n-\n-                        let dst =\n-                            Place::from(local_decls.push(LocalDecl::new(tcx.mk_mut_ptr(ty), span)));\n-\n-                        let dst_ptr = Statement {\n-                            source_info,\n-                            kind: StatementKind::Assign(box (\n-                                dst,\n-                                Rvalue::AddressOf(Mutability::Mut, *lhs),\n-                            )),\n-                        };\n-\n-                        let dst_cast_ty = tcx.mk_mut_ptr(tcx.types.u8);\n-                        let dst_cast_place =\n-                            Place::from(local_decls.push(LocalDecl::new(dst_cast_ty, span)));\n-\n-                        let dst_cast = Statement {\n-                            source_info,\n-                            kind: StatementKind::Assign(box (\n-                                dst_cast_place,\n-                                Rvalue::Cast(CastKind::Misc, Operand::Copy(dst), dst_cast_ty),\n-                            )),\n-                        };\n-\n-                        let src =\n-                            Place::from(local_decls.push(LocalDecl::new(tcx.mk_imm_ptr(ty), span)));\n-\n-                        let src_ptr = Statement {\n-                            source_info,\n-                            kind: StatementKind::Assign(box (\n-                                src,\n-                                Rvalue::AddressOf(Mutability::Not, *rhs),\n-                            )),\n-                        };\n-\n-                        let src_cast_ty = tcx.mk_imm_ptr(tcx.types.u8);\n-                        let src_cast_place =\n-                            Place::from(local_decls.push(LocalDecl::new(src_cast_ty, span)));\n-\n-                        let src_cast = Statement {\n-                            source_info,\n-                            kind: StatementKind::Assign(box (\n-                                src_cast_place,\n-                                Rvalue::Cast(CastKind::Misc, Operand::Copy(src), src_cast_ty),\n-                            )),\n-                        };\n-\n-                        let copy_bytes = Statement {\n-                            source_info,\n-                            kind: StatementKind::CopyNonOverlapping(box CopyNonOverlapping {\n-                                src: Operand::Copy(src_cast_place),\n-                                dst: Operand::Copy(dst_cast_place),\n-                                count: Operand::Copy(size_place),\n-                            }),\n-                        };\n-\n-                        let store_dead = Statement {\n-                            source_info,\n-                            kind: StatementKind::StorageDead(size_array_local),\n-                        };\n-                        let iter = IntoIter::new([\n-                            store_live,\n-                            const_assign,\n-                            store_discr,\n-                            cast_discr,\n-                            store_size,\n-                            dst_ptr,\n-                            dst_cast,\n-                            src_ptr,\n-                            src_cast,\n-                            copy_bytes,\n-                            store_dead,\n-                        ]);\n-\n-                        st.make_nop();\n-                        Some(iter)\n-                    }\n-                    _ => return None,\n-                }\n-            });\n-        }\n-    }\n-}"}, {"sha": "1919720de4996a145670ff763cc93ed526656be3", "filename": "compiler/rustc_mir_transform/src/large_enums.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -0,0 +1,283 @@\n+use crate::rustc_middle::ty::util::IntTypeExt;\n+use crate::MirPass;\n+use rustc_data_structures::stable_map::FxHashMap;\n+use rustc_middle::mir::interpret::AllocId;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, AdtDef, Const, ParamEnv, Ty, TyCtxt};\n+use rustc_target::abi::{HasDataLayout, Size, TagEncoding, Variants};\n+\n+/// A pass that seeks to optimize unnecessary moves of large enum types, if there is a large\n+/// enough discrepancy between them.\n+///\n+/// i.e. If there is are two variants:\n+/// ```\n+/// enum Example {\n+///   Small,\n+///   Large([u32; 1024]),\n+/// }\n+/// ```\n+/// Instead of emitting moves of the large variant,\n+/// Perform a memcpy instead.\n+/// Based off of [this HackMD](https://hackmd.io/@ft4bxUsFT5CEUBmRKYHr7w/rJM8BBPzD).\n+pub struct EnumSizeOpt {\n+    pub(crate) discrepancy: u64,\n+}\n+\n+impl<'tcx> MirPass<'tcx> for EnumSizeOpt {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let sess = tcx.sess;\n+        if (!sess.opts.debugging_opts.unsound_mir_opts) || sess.mir_opt_level() < 3 {\n+            return;\n+        }\n+        self.optim(tcx, body);\n+    }\n+}\n+\n+impl EnumSizeOpt {\n+    fn candidate<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        alloc_cache: &mut FxHashMap<Ty<'tcx>, AllocId>,\n+    ) -> Option<(AdtDef<'tcx>, usize, AllocId)> {\n+        let adt_def = match ty.kind() {\n+            ty::Adt(adt_def, _substs) if adt_def.is_enum() => adt_def,\n+            _ => return None,\n+        };\n+        let layout = tcx.layout_of(param_env.and(ty)).ok()?;\n+        let variants = match &layout.variants {\n+            Variants::Single { .. } => return None,\n+            Variants::Multiple { tag_encoding, .. }\n+                if matches!(tag_encoding, TagEncoding::Niche { .. }) =>\n+            {\n+                return None;\n+            }\n+            Variants::Multiple { variants, .. } if variants.len() <= 1 => return None,\n+            Variants::Multiple { variants, .. } => variants,\n+        };\n+        let min = variants.iter().map(|v| v.size()).min().unwrap();\n+        let max = variants.iter().map(|v| v.size()).max().unwrap();\n+        if max.bytes() - min.bytes() < self.discrepancy {\n+            return None;\n+        }\n+\n+        let num_discrs = adt_def.discriminants(tcx).count();\n+        if variants.iter_enumerated().any(|(var_idx, _)| {\n+            let discr_for_var = adt_def.discriminant_for_variant(tcx, var_idx).val;\n+            (discr_for_var > usize::MAX as u128) || (discr_for_var as usize >= num_discrs)\n+        }) {\n+            return None;\n+        }\n+        if let Some(alloc_id) = alloc_cache.get(&ty) {\n+            return Some((*adt_def, num_discrs, *alloc_id));\n+        }\n+\n+        let data_layout = tcx.data_layout();\n+        let ptr_sized_int = data_layout.ptr_sized_integer();\n+        let target_bytes = ptr_sized_int.size().bytes() as usize;\n+        let mut data = vec![0; target_bytes * num_discrs];\n+        macro_rules! encode_store {\n+            ($curr_idx: expr, $endian: expr, $bytes: expr) => {\n+                let bytes = match $endian {\n+                    rustc_target::abi::Endian::Little => $bytes.to_le_bytes(),\n+                    rustc_target::abi::Endian::Big => $bytes.to_be_bytes(),\n+                };\n+                for (i, b) in bytes.into_iter().enumerate() {\n+                    data[$curr_idx + i] = b;\n+                }\n+            };\n+        }\n+\n+        for (var_idx, layout) in variants.iter_enumerated() {\n+            let curr_idx =\n+                target_bytes * adt_def.discriminant_for_variant(tcx, var_idx).val as usize;\n+            let sz = layout.size();\n+            match ptr_sized_int {\n+                rustc_target::abi::Integer::I32 => {\n+                    encode_store!(curr_idx, data_layout.endian, sz.bytes() as u32);\n+                }\n+                rustc_target::abi::Integer::I64 => {\n+                    encode_store!(curr_idx, data_layout.endian, sz.bytes());\n+                }\n+                _ => unreachable!(),\n+            };\n+        }\n+        let alloc = interpret::Allocation::from_bytes(\n+            data,\n+            tcx.data_layout.ptr_sized_integer().align(&tcx.data_layout).abi,\n+            Mutability::Not,\n+        );\n+        let alloc = tcx.create_memory_alloc(tcx.intern_const_alloc(alloc));\n+        Some((*adt_def, num_discrs, *alloc_cache.entry(ty).or_insert(alloc)))\n+    }\n+    fn optim<'tcx>(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let mut alloc_cache = FxHashMap::default();\n+        let body_did = body.source.def_id();\n+        let param_env = tcx.param_env(body_did);\n+        let (bbs, local_decls) = body.basic_blocks_and_local_decls_mut();\n+        for bb in bbs {\n+            bb.expand_statements(|st| {\n+                if let StatementKind::Assign(box (\n+                    lhs,\n+                    Rvalue::Use(Operand::Copy(rhs) | Operand::Move(rhs)),\n+                )) = &st.kind\n+                {\n+                    let ty = lhs.ty(local_decls, tcx).ty;\n+\n+                    let source_info = st.source_info;\n+                    let span = source_info.span;\n+\n+                    let (adt_def, num_variants, alloc_id) =\n+                        self.candidate(tcx, param_env, ty, &mut alloc_cache)?;\n+                    let alloc = tcx.global_alloc(alloc_id).unwrap_memory();\n+\n+                    let tmp_ty = tcx.mk_ty(ty::Array(\n+                        tcx.types.usize,\n+                        Const::from_usize(tcx, num_variants as u64),\n+                    ));\n+\n+                    let size_array_local = local_decls.push(LocalDecl::new(tmp_ty, span));\n+                    let store_live = Statement {\n+                        source_info,\n+                        kind: StatementKind::StorageLive(size_array_local),\n+                    };\n+\n+                    let place = Place::from(size_array_local);\n+                    let constant_vals = Constant {\n+                        span,\n+                        user_ty: None,\n+                        literal: ConstantKind::Val(\n+                            interpret::ConstValue::ByRef { alloc, offset: Size::ZERO },\n+                            tmp_ty,\n+                        ),\n+                    };\n+                    let rval = Rvalue::Use(Operand::Constant(box (constant_vals)));\n+\n+                    let const_assign =\n+                        Statement { source_info, kind: StatementKind::Assign(box (place, rval)) };\n+\n+                    let discr_place = Place::from(\n+                        local_decls\n+                            .push(LocalDecl::new(adt_def.repr().discr_type().to_ty(tcx), span)),\n+                    );\n+\n+                    let store_discr = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (discr_place, Rvalue::Discriminant(*rhs))),\n+                    };\n+\n+                    let discr_cast_place =\n+                        Place::from(local_decls.push(LocalDecl::new(tcx.types.usize, span)));\n+\n+                    let cast_discr = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            discr_cast_place,\n+                            Rvalue::Cast(\n+                                CastKind::Misc,\n+                                Operand::Copy(discr_place),\n+                                tcx.types.usize,\n+                            ),\n+                        )),\n+                    };\n+\n+                    let size_place =\n+                        Place::from(local_decls.push(LocalDecl::new(tcx.types.usize, span)));\n+\n+                    let store_size = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            size_place,\n+                            Rvalue::Use(Operand::Copy(Place {\n+                                local: size_array_local,\n+                                projection: tcx.intern_place_elems(&[PlaceElem::Index(\n+                                    discr_cast_place.local,\n+                                )]),\n+                            })),\n+                        )),\n+                    };\n+\n+                    let dst =\n+                        Place::from(local_decls.push(LocalDecl::new(tcx.mk_mut_ptr(ty), span)));\n+\n+                    let dst_ptr = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            dst,\n+                            Rvalue::AddressOf(Mutability::Mut, *lhs),\n+                        )),\n+                    };\n+\n+                    let dst_cast_ty = tcx.mk_mut_ptr(tcx.types.u8);\n+                    let dst_cast_place =\n+                        Place::from(local_decls.push(LocalDecl::new(dst_cast_ty, span)));\n+\n+                    let dst_cast = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            dst_cast_place,\n+                            Rvalue::Cast(CastKind::Misc, Operand::Copy(dst), dst_cast_ty),\n+                        )),\n+                    };\n+\n+                    let src =\n+                        Place::from(local_decls.push(LocalDecl::new(tcx.mk_imm_ptr(ty), span)));\n+\n+                    let src_ptr = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            src,\n+                            Rvalue::AddressOf(Mutability::Not, *rhs),\n+                        )),\n+                    };\n+\n+                    let src_cast_ty = tcx.mk_imm_ptr(tcx.types.u8);\n+                    let src_cast_place =\n+                        Place::from(local_decls.push(LocalDecl::new(src_cast_ty, span)));\n+\n+                    let src_cast = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            src_cast_place,\n+                            Rvalue::Cast(CastKind::Misc, Operand::Copy(src), src_cast_ty),\n+                        )),\n+                    };\n+\n+                    let copy_bytes = Statement {\n+                        source_info,\n+                        kind: StatementKind::CopyNonOverlapping(box CopyNonOverlapping {\n+                            src: Operand::Copy(src_cast_place),\n+                            dst: Operand::Copy(dst_cast_place),\n+                            count: Operand::Copy(size_place),\n+                        }),\n+                    };\n+\n+                    let store_dead = Statement {\n+                        source_info,\n+                        kind: StatementKind::StorageDead(size_array_local),\n+                    };\n+                    let iter = [\n+                        store_live,\n+                        const_assign,\n+                        store_discr,\n+                        cast_discr,\n+                        store_size,\n+                        dst_ptr,\n+                        dst_cast,\n+                        src_ptr,\n+                        src_cast,\n+                        copy_bytes,\n+                        store_dead,\n+                    ]\n+                    .into_iter();\n+\n+                    st.make_nop();\n+                    Some(iter)\n+                } else {\n+                    None\n+                }\n+            });\n+        }\n+    }\n+}"}, {"sha": "8cd268eb6ce1323fdddb593aa656c7f7a7f221e2", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -3,7 +3,6 @@\n #![feature(drain_filter)]\n #![feature(let_chains)]\n #![feature(let_else)]\n-#![feature(entry_insert)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n@@ -75,6 +74,7 @@ mod function_item_references;\n mod generator;\n mod inline;\n mod instcombine;\n+mod large_enums;\n mod lower_intrinsics;\n mod lower_slice_len;\n mod match_branches;\n@@ -547,6 +547,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         tcx,\n         body,\n         &[\n+            &large_enums::EnumSizeOpt { discrepancy: 128 },\n             &reveal_all::RevealAll, // has to be done before inlining, since inlined code is in RevealAll mode.\n             &lower_slice_len::LowerSliceLenCalls, // has to be done before inlining, otherwise actual call will be almost always inlined. Also simple, so can just do first\n             &unreachable_prop::UnreachablePropagation,"}, {"sha": "260d9de867087696af0675fb36d1dab22c2aa68c", "filename": "tests/codegen/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fconsts.rs?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -C no-prepopulate-passes -Zmir-opt-level=0\n+// compile-flags: -C no-prepopulate-passes\n // min-llvm-version: 14.0\n \n #![crate_type = \"lib\"]"}, {"sha": "96dfde18683e34b2c3ab452a79920edd040a72a1", "filename": "tests/codegen/function-arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ffunction-arguments.rs?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -O -C no-prepopulate-passes -Zmir-opt-level=0\n+// compile-flags: -O -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n "}, {"sha": "d9923ec7cba7d556d52aa15e49574abc09886761", "filename": "tests/mir-opt/enum_opt.cand.EnumSizeOpt.32bit.diff", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.32bit.diff?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -0,0 +1,55 @@\n+- // MIR for `cand` before EnumSizeOpt\n++ // MIR for `cand` after EnumSizeOpt\n+  \n+  fn cand() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum_opt.rs:49:15: 49:15\n+      let mut _1: Candidate;               // in scope 0 at $DIR/enum_opt.rs:50:7: 50:12\n+      let mut _2: Candidate;               // in scope 0 at $DIR/enum_opt.rs:51:7: 51:34\n+      let mut _3: [u64; 1024];             // in scope 0 at $DIR/enum_opt.rs:51:24: 51:33\n++     let mut _4: [usize; 2];              // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _5: isize;                   // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _6: usize;                   // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _7: usize;                   // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _8: *mut Candidate;          // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _9: *mut u8;                 // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _10: *const Candidate;       // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _11: *const u8;              // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:50:7: 50:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:50:7: 50:12\n+          Deinit(_1);                      // scope 0 at $DIR/enum_opt.rs:50:15: 50:34\n+          ((_1 as Small).0: u8) = const 1_u8; // scope 0 at $DIR/enum_opt.rs:50:15: 50:34\n+          discriminant(_1) = 0;            // scope 0 at $DIR/enum_opt.rs:50:15: 50:34\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:51:7: 51:34\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:51:24: 51:33\n+          _3 = [const 1_u64; 1024];        // scope 1 at $DIR/enum_opt.rs:51:24: 51:33\n+          Deinit(_2);                      // scope 1 at $DIR/enum_opt.rs:51:7: 51:34\n+          ((_2 as Large).0: [u64; 1024]) = move _3; // scope 1 at $DIR/enum_opt.rs:51:7: 51:34\n+          discriminant(_2) = 1;            // scope 1 at $DIR/enum_opt.rs:51:7: 51:34\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:51:33: 51:34\n+-         _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _4 = const [2_usize, 8196_usize]; // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _5 = discriminant(_2);           // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _6 = _5 as usize (Misc);         // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _7 = _4[_6];                     // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _8 = &raw mut _1;                // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _9 = _8 as *mut u8 (Misc);       // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _10 = &raw const _2;             // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _11 = _10 as *const u8 (Misc);   // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         copy_nonoverlapping(src=_11, dst=_9, count=_7); // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:51:33: 51:34\n+          _0 = const ();                   // scope 0 at $DIR/enum_opt.rs:49:15: 52:2\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:52:1: 52:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:52:2: 52:2\n+      }\n+  \n+      bb1 (cleanup): {\n+          resume;                          // scope 0 at $DIR/enum_opt.rs:49:1: 52:2\n+      }\n+  }\n+  "}, {"sha": "e79d2f67a8398df4f9d2745e3380d7f0bae39cb3", "filename": "tests/mir-opt/enum_opt.cand.EnumSizeOpt.64bit.diff", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.64bit.diff?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -0,0 +1,55 @@\n+- // MIR for `cand` before EnumSizeOpt\n++ // MIR for `cand` after EnumSizeOpt\n+  \n+  fn cand() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum_opt.rs:49:15: 49:15\n+      let mut _1: Candidate;               // in scope 0 at $DIR/enum_opt.rs:50:7: 50:12\n+      let mut _2: Candidate;               // in scope 0 at $DIR/enum_opt.rs:51:7: 51:34\n+      let mut _3: [u64; 1024];             // in scope 0 at $DIR/enum_opt.rs:51:24: 51:33\n++     let mut _4: [usize; 2];              // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _5: isize;                   // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _6: usize;                   // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _7: usize;                   // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _8: *mut Candidate;          // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _9: *mut u8;                 // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _10: *const Candidate;       // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n++     let mut _11: *const u8;              // in scope 0 at $DIR/enum_opt.rs:51:3: 51:34\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:50:7: 50:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:50:7: 50:12\n+          Deinit(_1);                      // scope 0 at $DIR/enum_opt.rs:50:15: 50:34\n+          ((_1 as Small).0: u8) = const 1_u8; // scope 0 at $DIR/enum_opt.rs:50:15: 50:34\n+          discriminant(_1) = 0;            // scope 0 at $DIR/enum_opt.rs:50:15: 50:34\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:51:7: 51:34\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:51:24: 51:33\n+          _3 = [const 1_u64; 1024];        // scope 1 at $DIR/enum_opt.rs:51:24: 51:33\n+          Deinit(_2);                      // scope 1 at $DIR/enum_opt.rs:51:7: 51:34\n+          ((_2 as Large).0: [u64; 1024]) = move _3; // scope 1 at $DIR/enum_opt.rs:51:7: 51:34\n+          discriminant(_2) = 1;            // scope 1 at $DIR/enum_opt.rs:51:7: 51:34\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:51:33: 51:34\n+-         _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _4 = const [2_usize, 8200_usize]; // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _5 = discriminant(_2);           // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _6 = _5 as usize (Misc);         // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _7 = _4[_6];                     // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _8 = &raw mut _1;                // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _9 = _8 as *mut u8 (Misc);       // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _10 = &raw const _2;             // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         _11 = _10 as *const u8 (Misc);   // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         copy_nonoverlapping(src=_11, dst=_9, count=_7); // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n++         StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:51:3: 51:34\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:51:33: 51:34\n+          _0 = const ();                   // scope 0 at $DIR/enum_opt.rs:49:15: 52:2\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:52:1: 52:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:52:2: 52:2\n+      }\n+  \n+      bb1 (cleanup): {\n+          resume;                          // scope 0 at $DIR/enum_opt.rs:49:1: 52:2\n+      }\n+  }\n+  "}, {"sha": "d8b6a7940151873eb80d0265b7679b5353927846", "filename": "tests/mir-opt/enum_opt.invalid.EnumSizeOpt.32bit.diff", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.32bit.diff?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -0,0 +1,35 @@\n+- // MIR for `invalid` before EnumSizeOpt\n++ // MIR for `invalid` after EnumSizeOpt\n+  \n+  fn invalid() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum_opt.rs:55:18: 55:18\n+      let mut _1: InvalidIdxs;             // in scope 0 at $DIR/enum_opt.rs:56:7: 56:12\n+      let mut _2: InvalidIdxs;             // in scope 0 at $DIR/enum_opt.rs:57:7: 57:36\n+      let mut _3: [u64; 1024];             // in scope 0 at $DIR/enum_opt.rs:57:26: 57:35\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:56:7: 56:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:56:7: 56:12\n+          Deinit(_1);                      // scope 0 at $DIR/enum_opt.rs:56:15: 56:29\n+          discriminant(_1) = 0;            // scope 0 at $DIR/enum_opt.rs:56:15: 56:29\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:57:7: 57:36\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:57:26: 57:35\n+          _3 = [const 0_u64; 1024];        // scope 1 at $DIR/enum_opt.rs:57:26: 57:35\n+          Deinit(_2);                      // scope 1 at $DIR/enum_opt.rs:57:7: 57:36\n+          ((_2 as Large).0: [u64; 1024]) = move _3; // scope 1 at $DIR/enum_opt.rs:57:7: 57:36\n+          discriminant(_2) = 1;            // scope 1 at $DIR/enum_opt.rs:57:7: 57:36\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:57:35: 57:36\n+          _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:57:3: 57:36\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:57:35: 57:36\n+          _0 = const ();                   // scope 0 at $DIR/enum_opt.rs:55:18: 58:2\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:58:1: 58:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:58:2: 58:2\n+      }\n+  \n+      bb1 (cleanup): {\n+          resume;                          // scope 0 at $DIR/enum_opt.rs:55:1: 58:2\n+      }\n+  }\n+  "}, {"sha": "d8b6a7940151873eb80d0265b7679b5353927846", "filename": "tests/mir-opt/enum_opt.invalid.EnumSizeOpt.64bit.diff", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.64bit.diff?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -0,0 +1,35 @@\n+- // MIR for `invalid` before EnumSizeOpt\n++ // MIR for `invalid` after EnumSizeOpt\n+  \n+  fn invalid() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum_opt.rs:55:18: 55:18\n+      let mut _1: InvalidIdxs;             // in scope 0 at $DIR/enum_opt.rs:56:7: 56:12\n+      let mut _2: InvalidIdxs;             // in scope 0 at $DIR/enum_opt.rs:57:7: 57:36\n+      let mut _3: [u64; 1024];             // in scope 0 at $DIR/enum_opt.rs:57:26: 57:35\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:56:7: 56:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:56:7: 56:12\n+          Deinit(_1);                      // scope 0 at $DIR/enum_opt.rs:56:15: 56:29\n+          discriminant(_1) = 0;            // scope 0 at $DIR/enum_opt.rs:56:15: 56:29\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:57:7: 57:36\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:57:26: 57:35\n+          _3 = [const 0_u64; 1024];        // scope 1 at $DIR/enum_opt.rs:57:26: 57:35\n+          Deinit(_2);                      // scope 1 at $DIR/enum_opt.rs:57:7: 57:36\n+          ((_2 as Large).0: [u64; 1024]) = move _3; // scope 1 at $DIR/enum_opt.rs:57:7: 57:36\n+          discriminant(_2) = 1;            // scope 1 at $DIR/enum_opt.rs:57:7: 57:36\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:57:35: 57:36\n+          _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:57:3: 57:36\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:57:35: 57:36\n+          _0 = const ();                   // scope 0 at $DIR/enum_opt.rs:55:18: 58:2\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:58:1: 58:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:58:2: 58:2\n+      }\n+  \n+      bb1 (cleanup): {\n+          resume;                          // scope 0 at $DIR/enum_opt.rs:55:1: 58:2\n+      }\n+  }\n+  "}, {"sha": "bc72c93da09f33dc7d1620cebc1d7be879a1881f", "filename": "tests/mir-opt/enum_opt.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.rs?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -0,0 +1,79 @@\n+// EMIT_MIR_FOR_EACH_BIT_WIDTH\n+// compile-flags: -Zunsound-mir-opts -Zmir-opt-level=3\n+#![feature(arbitrary_enum_discriminant, repr128)]\n+\n+// Tests that an enum with a variant with no data gets correctly transformed.\n+pub enum NoData {\n+  None,\n+  Large([u64; 1024]),\n+}\n+\n+// Tests that an enum with a variant with data that is a valid candidate gets transformed.\n+pub enum Candidate {\n+  Small(u8),\n+  Large([u64; 1024]),\n+}\n+\n+// Tests that an enum which has a discriminant much higher than the variant does not get\n+// tformed.\n+#[repr(u32)]\n+pub enum InvalidIdxs {\n+  A = 302,\n+  Large([u64; 1024]),\n+}\n+\n+// Tests that an enum with too high of a discriminant index (not in bounds of usize) does not\n+// get tformed.\n+#[repr(u128)]\n+pub enum Truncatable {\n+    A = 0,\n+    B([u8; 1024]) = 1,\n+    C([u8; 4096]) = 0x10000000000000001,\n+}\n+\n+// Tests that an enum with discriminants in random order still gets tformed correctly.\n+#[repr(u32)]\n+pub enum RandOrderDiscr {\n+  A = 13,\n+  B([u8; 1024]) = 5,\n+  C = 7,\n+}\n+\n+// EMIT_MIR enum_opt.unin.EnumSizeOpt.diff\n+pub fn unin() {\n+  let mut a = NoData::None;\n+  a = NoData::Large([1; 1024]);\n+}\n+\n+// EMIT_MIR enum_opt.cand.EnumSizeOpt.diff\n+pub fn cand() {\n+  let mut a = Candidate::Small(1);\n+  a = Candidate::Large([1; 1024]);\n+}\n+\n+// EMIT_MIR enum_opt.invalid.EnumSizeOpt.diff\n+pub fn invalid() {\n+  let mut a = InvalidIdxs::A;\n+  a = InvalidIdxs::Large([0; 1024]);\n+}\n+\n+// EMIT_MIR enum_opt.trunc.EnumSizeOpt.diff\n+pub fn trunc() {\n+  let mut a = Truncatable::A;\n+  a = Truncatable::B([0; 1024]);\n+  a = Truncatable::C([0; 4096]);\n+}\n+\n+pub fn rand_order() {\n+  let mut a = RandOrderDiscr::A;\n+  a = RandOrderDiscr::B([0; 1024]);\n+  a = RandOrderDiscr::C;\n+}\n+\n+pub fn main() {\n+  unin();\n+  cand();\n+  invalid();\n+  trunc();\n+  rand_order();\n+}"}, {"sha": "650c6695f3f0063ddd46084c07245069047773ab", "filename": "tests/mir-opt/enum_opt.trunc.EnumSizeOpt.32bit.diff", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.32bit.diff?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -0,0 +1,46 @@\n+- // MIR for `trunc` before EnumSizeOpt\n++ // MIR for `trunc` after EnumSizeOpt\n+  \n+  fn trunc() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum_opt.rs:61:16: 61:16\n+      let mut _1: Truncatable;             // in scope 0 at $DIR/enum_opt.rs:62:7: 62:12\n+      let mut _2: Truncatable;             // in scope 0 at $DIR/enum_opt.rs:63:7: 63:32\n+      let mut _3: [u8; 1024];              // in scope 0 at $DIR/enum_opt.rs:63:22: 63:31\n+      let mut _4: Truncatable;             // in scope 0 at $DIR/enum_opt.rs:64:7: 64:32\n+      let mut _5: [u8; 4096];              // in scope 0 at $DIR/enum_opt.rs:64:22: 64:31\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:62:7: 62:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:62:7: 62:12\n+          Deinit(_1);                      // scope 0 at $DIR/enum_opt.rs:62:15: 62:29\n+          discriminant(_1) = 0;            // scope 0 at $DIR/enum_opt.rs:62:15: 62:29\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:63:7: 63:32\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:63:22: 63:31\n+          _3 = [const 0_u8; 1024];         // scope 1 at $DIR/enum_opt.rs:63:22: 63:31\n+          Deinit(_2);                      // scope 1 at $DIR/enum_opt.rs:63:7: 63:32\n+          ((_2 as B).0: [u8; 1024]) = move _3; // scope 1 at $DIR/enum_opt.rs:63:7: 63:32\n+          discriminant(_2) = 1;            // scope 1 at $DIR/enum_opt.rs:63:7: 63:32\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:63:31: 63:32\n+          _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:63:3: 63:32\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:63:31: 63:32\n+          StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:64:7: 64:32\n+          StorageLive(_5);                 // scope 1 at $DIR/enum_opt.rs:64:22: 64:31\n+          _5 = [const 0_u8; 4096];         // scope 1 at $DIR/enum_opt.rs:64:22: 64:31\n+          Deinit(_4);                      // scope 1 at $DIR/enum_opt.rs:64:7: 64:32\n+          ((_4 as C).0: [u8; 4096]) = move _5; // scope 1 at $DIR/enum_opt.rs:64:7: 64:32\n+          discriminant(_4) = 2;            // scope 1 at $DIR/enum_opt.rs:64:7: 64:32\n+          StorageDead(_5);                 // scope 1 at $DIR/enum_opt.rs:64:31: 64:32\n+          _1 = move _4;                    // scope 1 at $DIR/enum_opt.rs:64:3: 64:32\n+          StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:64:31: 64:32\n+          _0 = const ();                   // scope 0 at $DIR/enum_opt.rs:61:16: 65:2\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:65:1: 65:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:65:2: 65:2\n+      }\n+  \n+      bb1 (cleanup): {\n+          resume;                          // scope 0 at $DIR/enum_opt.rs:61:1: 65:2\n+      }\n+  }\n+  "}, {"sha": "650c6695f3f0063ddd46084c07245069047773ab", "filename": "tests/mir-opt/enum_opt.trunc.EnumSizeOpt.64bit.diff", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.64bit.diff?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -0,0 +1,46 @@\n+- // MIR for `trunc` before EnumSizeOpt\n++ // MIR for `trunc` after EnumSizeOpt\n+  \n+  fn trunc() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum_opt.rs:61:16: 61:16\n+      let mut _1: Truncatable;             // in scope 0 at $DIR/enum_opt.rs:62:7: 62:12\n+      let mut _2: Truncatable;             // in scope 0 at $DIR/enum_opt.rs:63:7: 63:32\n+      let mut _3: [u8; 1024];              // in scope 0 at $DIR/enum_opt.rs:63:22: 63:31\n+      let mut _4: Truncatable;             // in scope 0 at $DIR/enum_opt.rs:64:7: 64:32\n+      let mut _5: [u8; 4096];              // in scope 0 at $DIR/enum_opt.rs:64:22: 64:31\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:62:7: 62:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:62:7: 62:12\n+          Deinit(_1);                      // scope 0 at $DIR/enum_opt.rs:62:15: 62:29\n+          discriminant(_1) = 0;            // scope 0 at $DIR/enum_opt.rs:62:15: 62:29\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:63:7: 63:32\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:63:22: 63:31\n+          _3 = [const 0_u8; 1024];         // scope 1 at $DIR/enum_opt.rs:63:22: 63:31\n+          Deinit(_2);                      // scope 1 at $DIR/enum_opt.rs:63:7: 63:32\n+          ((_2 as B).0: [u8; 1024]) = move _3; // scope 1 at $DIR/enum_opt.rs:63:7: 63:32\n+          discriminant(_2) = 1;            // scope 1 at $DIR/enum_opt.rs:63:7: 63:32\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:63:31: 63:32\n+          _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:63:3: 63:32\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:63:31: 63:32\n+          StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:64:7: 64:32\n+          StorageLive(_5);                 // scope 1 at $DIR/enum_opt.rs:64:22: 64:31\n+          _5 = [const 0_u8; 4096];         // scope 1 at $DIR/enum_opt.rs:64:22: 64:31\n+          Deinit(_4);                      // scope 1 at $DIR/enum_opt.rs:64:7: 64:32\n+          ((_4 as C).0: [u8; 4096]) = move _5; // scope 1 at $DIR/enum_opt.rs:64:7: 64:32\n+          discriminant(_4) = 2;            // scope 1 at $DIR/enum_opt.rs:64:7: 64:32\n+          StorageDead(_5);                 // scope 1 at $DIR/enum_opt.rs:64:31: 64:32\n+          _1 = move _4;                    // scope 1 at $DIR/enum_opt.rs:64:3: 64:32\n+          StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:64:31: 64:32\n+          _0 = const ();                   // scope 0 at $DIR/enum_opt.rs:61:16: 65:2\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:65:1: 65:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:65:2: 65:2\n+      }\n+  \n+      bb1 (cleanup): {\n+          resume;                          // scope 0 at $DIR/enum_opt.rs:61:1: 65:2\n+      }\n+  }\n+  "}, {"sha": "c034c127ecad03433b78b755eedcf633d41c8499", "filename": "tests/mir-opt/enum_opt.unin.EnumSizeOpt.32bit.diff", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.32bit.diff?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -0,0 +1,54 @@\n+- // MIR for `unin` before EnumSizeOpt\n++ // MIR for `unin` after EnumSizeOpt\n+  \n+  fn unin() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum_opt.rs:43:15: 43:15\n+      let mut _1: NoData;                  // in scope 0 at $DIR/enum_opt.rs:44:7: 44:12\n+      let mut _2: NoData;                  // in scope 0 at $DIR/enum_opt.rs:45:7: 45:31\n+      let mut _3: [u64; 1024];             // in scope 0 at $DIR/enum_opt.rs:45:21: 45:30\n++     let mut _4: [usize; 2];              // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _5: isize;                   // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _6: usize;                   // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _7: usize;                   // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _8: *mut NoData;             // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _9: *mut u8;                 // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _10: *const NoData;          // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _11: *const u8;              // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:44:7: 44:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:44:7: 44:12\n+          Deinit(_1);                      // scope 0 at $DIR/enum_opt.rs:44:15: 44:27\n+          discriminant(_1) = 0;            // scope 0 at $DIR/enum_opt.rs:44:15: 44:27\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:45:7: 45:31\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:45:21: 45:30\n+          _3 = [const 1_u64; 1024];        // scope 1 at $DIR/enum_opt.rs:45:21: 45:30\n+          Deinit(_2);                      // scope 1 at $DIR/enum_opt.rs:45:7: 45:31\n+          ((_2 as Large).0: [u64; 1024]) = move _3; // scope 1 at $DIR/enum_opt.rs:45:7: 45:31\n+          discriminant(_2) = 1;            // scope 1 at $DIR/enum_opt.rs:45:7: 45:31\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:45:30: 45:31\n+-         _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _4 = const [4_usize, 8196_usize]; // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _5 = discriminant(_2);           // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _6 = _5 as usize (Misc);         // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _7 = _4[_6];                     // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _8 = &raw mut _1;                // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _9 = _8 as *mut u8 (Misc);       // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _10 = &raw const _2;             // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _11 = _10 as *const u8 (Misc);   // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         copy_nonoverlapping(src=_11, dst=_9, count=_7); // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:45:30: 45:31\n+          _0 = const ();                   // scope 0 at $DIR/enum_opt.rs:43:15: 46:2\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:46:1: 46:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:46:2: 46:2\n+      }\n+  \n+      bb1 (cleanup): {\n+          resume;                          // scope 0 at $DIR/enum_opt.rs:43:1: 46:2\n+      }\n+  }\n+  "}, {"sha": "9389c0f12a048bd9e3848367d66dd13651506184", "filename": "tests/mir-opt/enum_opt.unin.EnumSizeOpt.64bit.diff", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f5145ac9ce07d79aeb75ad049cab957b0fb92/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.64bit.diff?ref=5d9f5145ac9ce07d79aeb75ad049cab957b0fb92", "patch": "@@ -0,0 +1,54 @@\n+- // MIR for `unin` before EnumSizeOpt\n++ // MIR for `unin` after EnumSizeOpt\n+  \n+  fn unin() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum_opt.rs:43:15: 43:15\n+      let mut _1: NoData;                  // in scope 0 at $DIR/enum_opt.rs:44:7: 44:12\n+      let mut _2: NoData;                  // in scope 0 at $DIR/enum_opt.rs:45:7: 45:31\n+      let mut _3: [u64; 1024];             // in scope 0 at $DIR/enum_opt.rs:45:21: 45:30\n++     let mut _4: [usize; 2];              // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _5: isize;                   // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _6: usize;                   // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _7: usize;                   // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _8: *mut NoData;             // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _9: *mut u8;                 // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _10: *const NoData;          // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n++     let mut _11: *const u8;              // in scope 0 at $DIR/enum_opt.rs:45:3: 45:31\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:44:7: 44:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:44:7: 44:12\n+          Deinit(_1);                      // scope 0 at $DIR/enum_opt.rs:44:15: 44:27\n+          discriminant(_1) = 0;            // scope 0 at $DIR/enum_opt.rs:44:15: 44:27\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:45:7: 45:31\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:45:21: 45:30\n+          _3 = [const 1_u64; 1024];        // scope 1 at $DIR/enum_opt.rs:45:21: 45:30\n+          Deinit(_2);                      // scope 1 at $DIR/enum_opt.rs:45:7: 45:31\n+          ((_2 as Large).0: [u64; 1024]) = move _3; // scope 1 at $DIR/enum_opt.rs:45:7: 45:31\n+          discriminant(_2) = 1;            // scope 1 at $DIR/enum_opt.rs:45:7: 45:31\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:45:30: 45:31\n+-         _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _4 = const [8_usize, 8200_usize]; // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _5 = discriminant(_2);           // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _6 = _5 as usize (Misc);         // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _7 = _4[_6];                     // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _8 = &raw mut _1;                // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _9 = _8 as *mut u8 (Misc);       // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _10 = &raw const _2;             // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         _11 = _10 as *const u8 (Misc);   // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         copy_nonoverlapping(src=_11, dst=_9, count=_7); // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n++         StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:45:3: 45:31\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:45:30: 45:31\n+          _0 = const ();                   // scope 0 at $DIR/enum_opt.rs:43:15: 46:2\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:46:1: 46:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:46:2: 46:2\n+      }\n+  \n+      bb1 (cleanup): {\n+          resume;                          // scope 0 at $DIR/enum_opt.rs:43:1: 46:2\n+      }\n+  }\n+  "}]}