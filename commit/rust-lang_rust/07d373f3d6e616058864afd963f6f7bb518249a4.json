{"sha": "07d373f3d6e616058864afd963f6f7bb518249a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZDM3M2YzZDZlNjE2MDU4ODY0YWZkOTYzZjZmN2JiNTE4MjQ5YTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-05-10T21:17:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-05-19T22:32:03Z"}, "message": "rustc: Add a new crate type, cdylib\n\nThis commit is an implementation of [RFC 1510] which adds a new crate type,\n`cdylib`, to the compiler. This new crate type differs from the existing `dylib`\ncrate type in a few key ways:\n\n* No metadata is present in the final artifact\n* Symbol visibility rules are the same as executables, that is only reachable\n  `extern` functions are visible symbols\n* LTO is allowed\n* All libraries are always linked statically\n\nThis commit is relatively simple by just plubming the compiler with another\ncrate type which takes different branches here and there. The only major change\nis an implementation of the `Linker::export_symbols` function on Unix which now\nactually does something. This helps restrict the public symbols from a cdylib on\nUnix.\n\nWith this PR a \"hello world\" `cdylib` is 7.2K while the same `dylib` is 2.4MB,\nwhich is some nice size savings!\n\n[RFC 1510]: https://github.com/rust-lang/rfcs/pull/1510\n\nCloses #33132", "tree": {"sha": "38c6c7587341326aa9a16201144211a66b55c71a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38c6c7587341326aa9a16201144211a66b55c71a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07d373f3d6e616058864afd963f6f7bb518249a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07d373f3d6e616058864afd963f6f7bb518249a4", "html_url": "https://github.com/rust-lang/rust/commit/07d373f3d6e616058864afd963f6f7bb518249a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07d373f3d6e616058864afd963f6f7bb518249a4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "html_url": "https://github.com/rust-lang/rust/commit/9743c661b0e768997cf4af1c8da8d5838e1c2c2f"}], "stats": {"total": 363, "additions": 272, "deletions": 91}, "files": [{"sha": "0b398fd0d47c510c61502a6dd1b4afa1955f00f7", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -115,9 +115,10 @@ fn calculate_type(sess: &session::Session,\n         // got long ago), so don't bother with anything.\n         config::CrateTypeRlib => return Vec::new(),\n \n-        // Staticlibs must have all static dependencies. If any fail to be\n-        // found, we generate some nice pretty errors.\n-        config::CrateTypeStaticlib => {\n+        // Staticlibs and cdylibs must have all static dependencies. If any fail\n+        // to be found, we generate some nice pretty errors.\n+        config::CrateTypeStaticlib |\n+        config::CrateTypeCdylib => {\n             match attempt_static(sess) {\n                 Some(v) => return v,\n                 None => {}"}, {"sha": "55d75ace081517281366339dc5088f55daee4e3f", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Creates a new reachability computation context.\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ReachableContext<'a, 'tcx> {\n         let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n-            *ty != config::CrateTypeExecutable\n+            *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib\n         });\n         ReachableContext {\n             tcx: tcx,"}, {"sha": "325887684914bdf9174183bfe970f40ab0764fcf", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -70,6 +70,7 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n     let needs_check = sess.crate_types.borrow().iter().any(|kind| {\n         match *kind {\n             config::CrateTypeDylib |\n+            config::CrateTypeCdylib |\n             config::CrateTypeExecutable |\n             config::CrateTypeStaticlib => true,\n             config::CrateTypeRlib => false,"}, {"sha": "c4aa1a71152432d07a103e04a5e0180531520ed0", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -300,6 +300,7 @@ pub enum CrateType {\n     CrateTypeDylib,\n     CrateTypeRlib,\n     CrateTypeStaticlib,\n+    CrateTypeCdylib,\n }\n \n #[derive(Clone)]\n@@ -1326,6 +1327,7 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateTy\n                 \"rlib\"      => CrateTypeRlib,\n                 \"staticlib\" => CrateTypeStaticlib,\n                 \"dylib\"     => CrateTypeDylib,\n+                \"cdylib\"    => CrateTypeCdylib,\n                 \"bin\"       => CrateTypeExecutable,\n                 _ => {\n                     return Err(format!(\"unknown crate type: `{}`\",\n@@ -1413,7 +1415,8 @@ impl fmt::Display for CrateType {\n             CrateTypeExecutable => \"bin\".fmt(f),\n             CrateTypeDylib => \"dylib\".fmt(f),\n             CrateTypeRlib => \"rlib\".fmt(f),\n-            CrateTypeStaticlib => \"staticlib\".fmt(f)\n+            CrateTypeStaticlib => \"staticlib\".fmt(f),\n+            CrateTypeCdylib => \"cdylib\".fmt(f),\n         }\n     }\n }"}, {"sha": "05d84d9fd7846da7c8587c9ce4875db45f6c4fef", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -1175,6 +1175,9 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                          Some(ref n) if *n == \"dylib\" => {\n                              Some(config::CrateTypeDylib)\n                          }\n+                         Some(ref n) if *n == \"cdylib\" => {\n+                             Some(config::CrateTypeCdylib)\n+                         }\n                          Some(ref n) if *n == \"lib\" => {\n                              Some(config::default_lib_output())\n                          }"}, {"sha": "29d2b7dab4388783d31ea1c4846a9f0c5e1b957b", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -743,6 +743,7 @@ impl<'a> CrateReader<'a> {\n             match *ct {\n                 config::CrateTypeExecutable => need_exe_alloc = true,\n                 config::CrateTypeDylib |\n+                config::CrateTypeCdylib |\n                 config::CrateTypeStaticlib => need_lib_alloc = true,\n                 config::CrateTypeRlib => {}\n             }"}, {"sha": "f91f29192690944556fcdf6ae1ec2b3336ccf031", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -228,6 +228,7 @@ pub fn invalid_output_for_target(sess: &Session,\n                                  crate_type: config::CrateType) -> bool {\n     match (sess.target.target.options.dynamic_linking,\n            sess.target.target.options.executables, crate_type) {\n+        (false, _, config::CrateTypeCdylib) |\n         (false, _, config::CrateTypeDylib) => true,\n         (_, false, config::CrateTypeExecutable) => true,\n         _ => false\n@@ -250,6 +251,7 @@ pub fn filename_for_input(sess: &Session,\n         config::CrateTypeRlib => {\n             outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n         }\n+        config::CrateTypeCdylib |\n         config::CrateTypeDylib => {\n             let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n                                     &sess.target.target.options.dll_suffix);\n@@ -278,9 +280,10 @@ pub fn each_linked_rlib(sess: &Session,\n                         f: &mut FnMut(ast::CrateNum, &Path)) {\n     let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();\n     let fmts = sess.dependency_formats.borrow();\n-    let fmts = fmts.get(&config::CrateTypeExecutable).or_else(|| {\n-        fmts.get(&config::CrateTypeStaticlib)\n-    }).unwrap_or_else(|| {\n+    let fmts = fmts.get(&config::CrateTypeExecutable)\n+                   .or_else(|| fmts.get(&config::CrateTypeStaticlib))\n+                   .or_else(|| fmts.get(&config::CrateTypeCdylib));\n+    let fmts = fmts.unwrap_or_else(|| {\n         bug!(\"could not find formats for rlibs\")\n     });\n     for (cnum, path) in crates {\n@@ -335,13 +338,9 @@ fn link_binary_output(sess: &Session,\n         config::CrateTypeStaticlib => {\n             link_staticlib(sess, &objects, &out_filename, tmpdir.path());\n         }\n-        config::CrateTypeExecutable => {\n-            link_natively(sess, false, &objects, &out_filename, trans, outputs,\n-                          tmpdir.path());\n-        }\n-        config::CrateTypeDylib => {\n-            link_natively(sess, true, &objects, &out_filename, trans, outputs,\n-                          tmpdir.path());\n+        _ => {\n+            link_natively(sess, crate_type, &objects, &out_filename, trans,\n+                          outputs, tmpdir.path());\n         }\n     }\n \n@@ -609,13 +608,14 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n //\n // This will invoke the system linker/cc to create the resulting file. This\n // links to all upstream files as well.\n-fn link_natively(sess: &Session, dylib: bool,\n-                 objects: &[PathBuf], out_filename: &Path,\n+fn link_natively(sess: &Session,\n+                 crate_type: config::CrateType,\n+                 objects: &[PathBuf],\n+                 out_filename: &Path,\n                  trans: &CrateTranslation,\n                  outputs: &OutputFilenames,\n                  tmpdir: &Path) {\n-    info!(\"preparing dylib? ({}) from {:?} to {:?}\", dylib, objects,\n-          out_filename);\n+    info!(\"preparing {:?} from {:?} to {:?}\", crate_type, objects, out_filename);\n \n     // The invocations of cc share some flags across platforms\n     let (pname, mut cmd) = get_linker(sess);\n@@ -624,10 +624,10 @@ fn link_natively(sess: &Session, dylib: bool,\n     let root = sess.target_filesearch(PathKind::Native).get_lib_path();\n     cmd.args(&sess.target.target.options.pre_link_args);\n \n-    let pre_link_objects = if dylib {\n-        &sess.target.target.options.pre_link_objects_dll\n-    } else {\n+    let pre_link_objects = if crate_type == config::CrateTypeExecutable {\n         &sess.target.target.options.pre_link_objects_exe\n+    } else {\n+        &sess.target.target.options.pre_link_objects_dll\n     };\n     for obj in pre_link_objects {\n         cmd.arg(root.join(obj));\n@@ -639,7 +639,7 @@ fn link_natively(sess: &Session, dylib: bool,\n         } else {\n             Box::new(GnuLinker { cmd: &mut cmd, sess: &sess }) as Box<Linker>\n         };\n-        link_args(&mut *linker, sess, dylib, tmpdir,\n+        link_args(&mut *linker, sess, crate_type, tmpdir,\n                   objects, out_filename, trans, outputs);\n         if !sess.target.target.options.no_compiler_rt {\n             linker.link_staticlib(\"compiler-rt\");\n@@ -705,7 +705,7 @@ fn link_natively(sess: &Session, dylib: bool,\n \n fn link_args(cmd: &mut Linker,\n              sess: &Session,\n-             dylib: bool,\n+             crate_type: config::CrateType,\n              tmpdir: &Path,\n              objects: &[PathBuf],\n              out_filename: &Path,\n@@ -727,26 +727,28 @@ fn link_args(cmd: &mut Linker,\n \n     // If we're building a dynamic library then some platforms need to make sure\n     // that all symbols are exported correctly from the dynamic library.\n-    if dylib {\n-        cmd.export_symbols(sess, trans, tmpdir);\n+    if crate_type != config::CrateTypeExecutable {\n+        cmd.export_symbols(sess, trans, tmpdir, crate_type);\n     }\n \n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n-    if dylib {\n+    if crate_type == config::CrateTypeDylib {\n         cmd.add_object(&outputs.with_extension(\"metadata.o\"));\n     }\n \n     // Try to strip as much out of the generated object by removing unused\n     // sections if possible. See more comments in linker.rs\n     if !sess.opts.cg.link_dead_code {\n-        cmd.gc_sections(dylib);\n+        let keep_metadata = crate_type == config::CrateTypeDylib;\n+        cmd.gc_sections(keep_metadata);\n     }\n \n     let used_link_args = sess.cstore.used_link_args();\n \n-    if !dylib && t.options.position_independent_executables {\n+    if crate_type == config::CrateTypeExecutable &&\n+       t.options.position_independent_executables {\n         let empty_vec = Vec::new();\n         let empty_str = String::new();\n         let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n@@ -801,12 +803,12 @@ fn link_args(cmd: &mut Linker,\n     // in this DAG so far because they're only dylibs and dylibs can only depend\n     // on other dylibs (e.g. other native deps).\n     add_local_native_libraries(cmd, sess);\n-    add_upstream_rust_crates(cmd, sess, dylib, tmpdir);\n+    add_upstream_rust_crates(cmd, sess, crate_type, tmpdir);\n     add_upstream_native_libraries(cmd, sess);\n \n     // # Telling the linker what we're doing\n \n-    if dylib {\n+    if crate_type != config::CrateTypeExecutable {\n         cmd.build_dylib(out_filename);\n     }\n \n@@ -904,8 +906,10 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n-                            dylib: bool, tmpdir: &Path) {\n+fn add_upstream_rust_crates(cmd: &mut Linker,\n+                            sess: &Session,\n+                            crate_type: config::CrateType,\n+                            tmpdir: &Path) {\n     // All of the heavy lifting has previously been accomplished by the\n     // dependency_format module of the compiler. This is just crawling the\n     // output of that module, adding crates as necessary.\n@@ -915,11 +919,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n     // involves just passing the right -l flag.\n \n     let formats = sess.dependency_formats.borrow();\n-    let data = if dylib {\n-        formats.get(&config::CrateTypeDylib).unwrap()\n-    } else {\n-        formats.get(&config::CrateTypeExecutable).unwrap()\n-    };\n+    let data = formats.get(&crate_type).unwrap();\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n     // crates.\n@@ -934,7 +934,8 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n-                add_static_crate(cmd, sess, tmpdir, dylib, &src.rlib.unwrap().0)\n+                add_static_crate(cmd, sess, tmpdir, crate_type,\n+                                 &src.rlib.unwrap().0)\n             }\n             Linkage::Dynamic => {\n                 add_dynamic_crate(cmd, sess, &src.dylib.unwrap().0)\n@@ -979,9 +980,12 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n     // (aka we're making an executable), we can just pass the rlib blindly to\n     // the linker (fast) because it's fine if it's not actually included as\n     // we're at the end of the dependency chain.\n-    fn add_static_crate(cmd: &mut Linker, sess: &Session, tmpdir: &Path,\n-                        dylib: bool, cratepath: &Path) {\n-        if !sess.lto() && !dylib {\n+    fn add_static_crate(cmd: &mut Linker,\n+                        sess: &Session,\n+                        tmpdir: &Path,\n+                        crate_type: config::CrateType,\n+                        cratepath: &Path) {\n+        if !sess.lto() && crate_type != config::CrateTypeDylib {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n             return\n         }\n@@ -1017,7 +1021,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n \n             if any_objects {\n                 archive.build();\n-                if dylib {\n+                if crate_type == config::CrateTypeDylib {\n                     cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n                 } else {\n                     cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));"}, {"sha": "50f6366e85c8680f8a9608146b99d190e729ec4e", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 91, "deletions": 34, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -18,7 +18,7 @@ use std::process::Command;\n use back::archive;\n use middle::dependency_format::Linkage;\n use session::Session;\n-use session::config::CrateTypeDylib;\n+use session::config::CrateType;\n use session::config;\n use syntax::ast;\n use CrateTranslation;\n@@ -42,7 +42,7 @@ pub trait Linker {\n     fn framework_path(&mut self, path: &Path);\n     fn output_filename(&mut self, path: &Path);\n     fn add_object(&mut self, path: &Path);\n-    fn gc_sections(&mut self, is_dylib: bool);\n+    fn gc_sections(&mut self, keep_metadata: bool);\n     fn position_independent_executable(&mut self);\n     fn optimize(&mut self);\n     fn debuginfo(&mut self);\n@@ -53,8 +53,11 @@ pub trait Linker {\n     fn hint_dynamic(&mut self);\n     fn whole_archives(&mut self);\n     fn no_whole_archives(&mut self);\n-    fn export_symbols(&mut self, sess: &Session, trans: &CrateTranslation,\n-                      tmpdir: &Path);\n+    fn export_symbols(&mut self,\n+                      sess: &Session,\n+                      trans: &CrateTranslation,\n+                      tmpdir: &Path,\n+                      crate_type: CrateType);\n }\n \n pub struct GnuLinker<'a> {\n@@ -113,7 +116,7 @@ impl<'a> Linker for GnuLinker<'a> {\n         }\n     }\n \n-    fn gc_sections(&mut self, is_dylib: bool) {\n+    fn gc_sections(&mut self, keep_metadata: bool) {\n         // The dead_strip option to the linker specifies that functions and data\n         // unreachable by the entry point will be removed. This is quite useful\n         // with Rust's compilation model of compiling libraries at a time into\n@@ -139,7 +142,7 @@ impl<'a> Linker for GnuLinker<'a> {\n         // eliminate the metadata. If we're building an executable, however,\n         // --gc-sections drops the size of hello world from 1.8MB to 597K, a 67%\n         // reduction.\n-        } else if !is_dylib {\n+        } else if !keep_metadata {\n             self.cmd.arg(\"-Wl,--gc-sections\");\n         }\n     }\n@@ -198,8 +201,46 @@ impl<'a> Linker for GnuLinker<'a> {\n         self.cmd.arg(\"-Wl,-Bdynamic\");\n     }\n \n-    fn export_symbols(&mut self, _: &Session, _: &CrateTranslation, _: &Path) {\n-        // noop, visibility in object files takes care of this\n+    fn export_symbols(&mut self,\n+                      sess: &Session,\n+                      trans: &CrateTranslation,\n+                      tmpdir: &Path,\n+                      crate_type: CrateType) {\n+        // If we're compiling a dylib, then we let symbol visibility in object\n+        // files to take care of whether they're exported or not.\n+        //\n+        // If we're compiling a cdylib, however, we manually create a list of\n+        // exported symbols to ensure we don't expose any more. The object files\n+        // have far more public symbols than we actually want to export, so we\n+        // hide them all here.\n+        if crate_type == CrateType::CrateTypeDylib {\n+            return\n+        }\n+\n+        let path = tmpdir.join(\"list\");\n+        let prefix = if self.sess.target.target.options.is_like_osx {\n+            \"_\"\n+        } else {\n+            \"\"\n+        };\n+        let res = (|| -> io::Result<()> {\n+            let mut f = BufWriter::new(File::create(&path)?);\n+            for sym in exported_symbols(sess, trans, crate_type) {\n+                writeln!(f, \"{}{}\", prefix, sym)?;\n+            }\n+            Ok(())\n+        })();\n+        if let Err(e) = res {\n+            sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n+        }\n+        let mut arg = OsString::new();\n+        if self.sess.target.target.options.is_like_osx {\n+            arg.push(\"-Wl,-exported_symbols_list,\");\n+        } else {\n+            arg.push(\"-Wl,--retain-symbols-file=\");\n+        }\n+        arg.push(&path);\n+        self.cmd.arg(arg);\n     }\n }\n \n@@ -220,7 +261,9 @@ impl<'a> Linker for MsvcLinker<'a> {\n         self.cmd.arg(arg);\n     }\n \n-    fn gc_sections(&mut self, _is_dylib: bool) { self.cmd.arg(\"/OPT:REF,ICF\"); }\n+    fn gc_sections(&mut self, _keep_metadata: bool) {\n+        self.cmd.arg(\"/OPT:REF,ICF\");\n+    }\n \n     fn link_dylib(&mut self, lib: &str) {\n         self.cmd.arg(&format!(\"{}.lib\", lib));\n@@ -322,8 +365,11 @@ impl<'a> Linker for MsvcLinker<'a> {\n     // crates. Upstream rlibs may be linked statically to this dynamic library,\n     // in which case they may continue to transitively be used and hence need\n     // their symbols exported.\n-    fn export_symbols(&mut self, sess: &Session, trans: &CrateTranslation,\n-                      tmpdir: &Path) {\n+    fn export_symbols(&mut self,\n+                      sess: &Session,\n+                      trans: &CrateTranslation,\n+                      tmpdir: &Path,\n+                      crate_type: CrateType) {\n         let path = tmpdir.join(\"lib.def\");\n         let res = (|| -> io::Result<()> {\n             let mut f = BufWriter::new(File::create(&path)?);\n@@ -333,32 +379,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n             writeln!(f, \"LIBRARY\")?;\n             writeln!(f, \"EXPORTS\")?;\n \n-            // Write out all our local symbols\n-            for sym in trans.reachable.iter() {\n+            for sym in exported_symbols(sess, trans, crate_type) {\n                 writeln!(f, \"  {}\", sym)?;\n             }\n \n-            // Take a look at how all upstream crates are linked into this\n-            // dynamic library. For all statically linked libraries we take all\n-            // their reachable symbols and emit them as well.\n-            let cstore = &sess.cstore;\n-            let formats = sess.dependency_formats.borrow();\n-            let symbols = formats[&CrateTypeDylib].iter();\n-            let symbols = symbols.enumerate().filter_map(|(i, f)| {\n-                if *f == Linkage::Static {\n-                    Some((i + 1) as ast::CrateNum)\n-                } else {\n-                    None\n-                }\n-            }).flat_map(|cnum| {\n-                cstore.reachable_ids(cnum)\n-            }).map(|did| {\n-                cstore.item_symbol(did)\n-            });\n-            for symbol in symbols {\n-                writeln!(f, \"  {}\", symbol)?;\n-            }\n-\n             Ok(())\n         })();\n         if let Err(e) = res {\n@@ -369,3 +393,36 @@ impl<'a> Linker for MsvcLinker<'a> {\n         self.cmd.arg(&arg);\n     }\n }\n+\n+fn exported_symbols(sess: &Session,\n+                    trans: &CrateTranslation,\n+                    crate_type: CrateType) -> Vec<String> {\n+    let mut symbols = trans.reachable.iter().cloned().collect::<Vec<_>>();\n+\n+    // If we're producing anything other than a dylib then the `reachable` array\n+    // above is the exhaustive set of symbols we should be exporting.\n+    //\n+    // For dylibs, however, we need to take a look at how all upstream crates\n+    // are linked into this dynamic library. For all statically linked\n+    // libraries we take all their reachable symbols and emit them as well.\n+    if crate_type != CrateType::CrateTypeDylib {\n+        return symbols\n+    }\n+\n+    let cstore = &sess.cstore;\n+    let formats = sess.dependency_formats.borrow();\n+    let upstream_symbols = formats[&crate_type].iter();\n+    symbols.extend(upstream_symbols.enumerate().filter_map(|(i, f)| {\n+        if *f == Linkage::Static {\n+            Some((i + 1) as ast::CrateNum)\n+        } else {\n+            None\n+        }\n+    }).flat_map(|cnum| {\n+        cstore.reachable_ids(cnum)\n+    }).map(|did| {\n+        cstore.item_symbol(did)\n+    }));\n+\n+    return symbols\n+}"}, {"sha": "31bc11fb215b08fa4298ee84964058d4d07cd06a", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -30,15 +30,18 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n            output_names: &config::OutputFilenames) {\n     if sess.opts.cg.prefer_dynamic {\n         sess.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n-            .note(\"only 'staticlib' and 'bin' outputs are supported with LTO\")\n+            .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n+                   supported with LTO\")\n             .emit();\n         sess.abort_if_errors();\n     }\n \n     // Make sure we actually can run LTO\n     for crate_type in sess.crate_types.borrow().iter() {\n         match *crate_type {\n-            config::CrateTypeExecutable | config::CrateTypeStaticlib => {}\n+            config::CrateTypeExecutable |\n+            config::CrateTypeCdylib |\n+            config::CrateTypeStaticlib => {}\n             _ => {\n                 sess.fatal(\"lto can only be run for executables and \\\n                             static library outputs\");"}, {"sha": "21aba6fcb53d7aeb1edd130de53dac6854b81ece", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -2812,18 +2812,21 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         reachable_symbols.push(\"main\".to_string());\n     }\n \n-    // For the purposes of LTO, we add to the reachable set all of the upstream\n-    // reachable extern fns. These functions are all part of the public ABI of\n-    // the final product, so LTO needs to preserve them.\n-    if sess.lto() {\n-        for cnum in sess.cstore.crates() {\n-            let syms = sess.cstore.reachable_ids(cnum);\n-            reachable_symbols.extend(syms.into_iter().filter(|did| {\n-                sess.cstore.is_extern_item(shared_ccx.tcx(), *did)\n-            }).map(|did| {\n-                sess.cstore.item_symbol(did)\n-            }));\n-        }\n+    // For the purposes of LTO or when creating a cdylib, we add to the\n+    // reachable set all of the upstream reachable extern fns. These functions\n+    // are all part of the public ABI of the final product, so we need to\n+    // preserve them.\n+    //\n+    // Note that this happens even if LTO isn't requested or we're not creating\n+    // a cdylib. In those cases, though, we're not even reading the\n+    // `reachable_symbols` list later on so it should be ok.\n+    for cnum in sess.cstore.crates() {\n+        let syms = sess.cstore.reachable_ids(cnum);\n+        reachable_symbols.extend(syms.into_iter().filter(|did| {\n+            sess.cstore.is_extern_item(shared_ccx.tcx(), *did)\n+        }).map(|did| {\n+            sess.cstore.item_symbol(did)\n+        }));\n     }\n \n     if codegen_unit_count > 1 {"}, {"sha": "a3d0222a14c97ec7782e41df968de16c5ed4e727", "filename": "src/test/compile-fail/auxiliary/cdylib-dep.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fcdylib-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fcdylib-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fcdylib-dep.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"dylib\"]"}, {"sha": "4b160f26e92ca1b327fbc077ea2f91d67ee8f269", "filename": "src/test/compile-fail/cdylib-deps-must-be-static.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Fcompile-fail%2Fcdylib-deps-must-be-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Fcompile-fail%2Fcdylib-deps-must-be-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcdylib-deps-must-be-static.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: dependency `cdylib_dep` not found in rlib format\n+// aux-build:cdylib-dep.rs\n+// ignore-musl\n+\n+#![crate_type = \"cdylib\"]\n+\n+extern crate cdylib_dep;"}, {"sha": "ae3b82537db52ccb4d456dfde6b0d5d89d8b49ed", "filename": "src/test/run-make/cdylib/Makefile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Frun-make%2Fcdylib%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Frun-make%2Fcdylib%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcdylib%2FMakefile?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -0,0 +1,19 @@\n+include ../tools.mk\n+\n+all: $(call RUN_BINFILE,foo)\n+\t$(call RUN,foo)\n+\trm $(call DYLIB,foo)\n+\t$(RUSTC) foo.rs -C lto\n+\t$(call RUN,foo)\n+\n+ifdef IS_MSVC\n+$(call RUN_BINFILE,foo): $(call DYLIB,foo)\n+\t$(CC) $(CFLAGS) foo.c $(TMPDIR)/foo.dll.lib -Fe:`cygpath -w $@`\n+else\n+$(call RUN_BINFILE,foo): $(call DYLIB,foo)\n+\t$(CC) $(CFLAGS) foo.c -lfoo -o $(call RUN_BINFILE,foo) -L $(TMPDIR)\n+endif\n+\n+$(call DYLIB,foo):\n+\t$(RUSTC) bar.rs\n+\t$(RUSTC) foo.rs"}, {"sha": "2c97298604cbc27953659e677409816c07635d4d", "filename": "src/test/run-make/cdylib/bar.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Frun-make%2Fcdylib%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Frun-make%2Fcdylib%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcdylib%2Fbar.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+pub fn bar() {\n+    println!(\"hello!\");\n+}"}, {"sha": "1c950427c658b94f0bc61c52fbc322956def0827", "filename": "src/test/run-make/cdylib/foo.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Frun-make%2Fcdylib%2Ffoo.c", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Frun-make%2Fcdylib%2Ffoo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcdylib%2Ffoo.c?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <assert.h>\n+\n+extern void foo();\n+extern unsigned bar(unsigned a, unsigned b);\n+\n+int main() {\n+  foo();\n+  assert(bar(1, 2) == 3);\n+  return 0;\n+}"}, {"sha": "cdac6d19035251ca91f1a92ebf56ee0535fef392", "filename": "src/test/run-make/cdylib/foo.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Frun-make%2Fcdylib%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d373f3d6e616058864afd963f6f7bb518249a4/src%2Ftest%2Frun-make%2Fcdylib%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcdylib%2Ffoo.rs?ref=07d373f3d6e616058864afd963f6f7bb518249a4", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"cdylib\"]\n+\n+extern crate bar;\n+\n+#[no_mangle]\n+pub extern fn foo() {\n+    bar::bar();\n+}\n+\n+#[no_mangle]\n+pub extern fn bar(a: u32, b: u32) -> u32 {\n+    a + b\n+}"}]}