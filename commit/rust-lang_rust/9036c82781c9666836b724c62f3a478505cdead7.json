{"sha": "9036c82781c9666836b724c62f3a478505cdead7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMzZjODI3ODFjOTY2NjgzNmI3MjRjNjJmM2E0Nzg1MDVjZGVhZDc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-13T22:52:19Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-14T05:34:41Z"}, "message": "Rollup merge of #30823 - pnkfelix:put-back-alloca-zeroing-for-issue-30530, r=dotdash\n\nPut back alloca zeroing for issues #29092, #30018, #30530; inject zeroing for #30822.\n\n----\n\nBackground context: `fn alloca_zeroed` was removed in PR #22969, so we haven't been \"zero'ing\" (\\*) the alloca's since at least that point, but the logic behind that PR seems sound, so its not entirely obvious how *long* the underlying bug has actually been present.  In other words, I have not yet done a survey to see when the new `alloc_ty` and `lvalue_scratch_datum` calls were introduced that should have had \"zero'ing\" the alloca's.\n\n----\n\nI first fixed #30018, then decided to do a survey of `alloc_ty` calls to see if they needed similar treatment, which quickly led to a rediscovery of #30530.\n\nWhile making the regression test for the latter, I discovered #30822, which is a slightly different bug (in terms of where the \"zero'ing\" needs to go), but still relevant.\n\nI haven't finished the aforementioned survey of `fn alloc_ty` calls, but I decided I wanted to get this up for review in its current state (namely to see if my attempt to force developers to include a justification for passing `Uninit` can possibly fly, or if I should abandon that path of action).\n\n----\n\n(*): I am putting quotation marks around \"zero'ing\" because we no longer use zero as our \"dropped\" marker value.\n\nFix #29092\nFix #30018\nFix #30530\nFix #30822", "tree": {"sha": "0cd9472a47fb80777b6be3a9e80d8ade0732d6ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cd9472a47fb80777b6be3a9e80d8ade0732d6ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9036c82781c9666836b724c62f3a478505cdead7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9036c82781c9666836b724c62f3a478505cdead7", "html_url": "https://github.com/rust-lang/rust/commit/9036c82781c9666836b724c62f3a478505cdead7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9036c82781c9666836b724c62f3a478505cdead7/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e248aa09ff211e76bb0a8ca53267c5a903c23ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e248aa09ff211e76bb0a8ca53267c5a903c23ce", "html_url": "https://github.com/rust-lang/rust/commit/3e248aa09ff211e76bb0a8ca53267c5a903c23ce"}, {"sha": "decc2867577c65682c6a73c89c550d34b5b270ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/decc2867577c65682c6a73c89c550d34b5b270ad", "html_url": "https://github.com/rust-lang/rust/commit/decc2867577c65682c6a73c89c550d34b5b270ad"}], "stats": {"total": 436, "additions": 392, "deletions": 44}, "files": [{"sha": "f46a7ea67b5f23aa7aadb72d978806d1163a9ce3", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=9036c82781c9666836b724c62f3a478505cdead7", "patch": "@@ -1760,6 +1760,9 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let lvalue = Lvalue::new_with_hint(caller_name, bcx, p_id, HintKind::DontZeroJustUse);\n     let datum = Datum::new(llval, var_ty, lvalue);\n \n+    debug!(\"mk_binding_alloca cleanup_scope={:?} llval={} var_ty={:?}\",\n+           cleanup_scope, bcx.ccx().tn().val_to_string(llval), var_ty);\n+\n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n     call_lifetime_start(bcx, llval);"}, {"sha": "d22d619b9622754002c18d29f3b14a9c8eb92bee", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=9036c82781c9666836b724c62f3a478505cdead7", "patch": "@@ -55,6 +55,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::attr::IntType;\n use trans::_match;\n+use trans::base::InitAlloca;\n use trans::build::*;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n@@ -1279,7 +1280,12 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n             let scratch = unpack_datum!(bcx, datum::lvalue_scratch_datum(\n                 bcx, tcx.dtor_type(), \"drop_flag\",\n-                cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| bcx\n+                InitAlloca::Uninit(\"drop flag itself has no dtor\"),\n+                cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| {\n+                    debug!(\"no-op populate call for trans_drop_flag_ptr on dtor_type={:?}\",\n+                           tcx.dtor_type());\n+                    bcx\n+                }\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n                 let ptr = struct_field_ptr(variant_cx, st, MaybeSizedValue::sized(value),"}, {"sha": "5f2fe98727fa1266dda200c28b9d2c4b22ef8190", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 135, "deletions": 35, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9036c82781c9666836b724c62f3a478505cdead7", "patch": "@@ -1147,48 +1147,63 @@ pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>, val: ValueRef, f: F) ->\n     next_cx\n }\n \n-pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n-    if cx.sess().opts.optimize == config::No {\n+enum Lifetime { Start, End }\n+\n+// If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n+// on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n+// and the intrinsic for `lt` and passes them to `emit`, which is in\n+// charge of generating code to call the passed intrinsic on whatever\n+// block of generated code is targetted for the intrinsic.\n+//\n+// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n+// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n+fn core_lifetime_emit<'blk, 'tcx, F>(ccx: &'blk CrateContext<'blk, 'tcx>,\n+                                     ptr: ValueRef,\n+                                     lt: Lifetime,\n+                                     emit: F)\n+    where F: FnOnce(&'blk CrateContext<'blk, 'tcx>, machine::llsize, ValueRef)\n+{\n+    if ccx.sess().opts.optimize == config::No {\n         return;\n     }\n \n-    let _icx = push_ctxt(\"lifetime_start\");\n-    let ccx = cx.ccx();\n+    let _icx = push_ctxt(match lt {\n+        Lifetime::Start => \"lifetime_start\",\n+        Lifetime::End => \"lifetime_end\"\n+    });\n \n     let size = machine::llsize_of_alloc(ccx, val_ty(ptr).element_type());\n     if size == 0 {\n         return;\n     }\n \n-    let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n-    let lifetime_start = ccx.get_intrinsic(&\"llvm.lifetime.start\");\n-    Call(cx,\n-         lifetime_start,\n-         &[C_u64(ccx, size), ptr],\n-         None,\n-         DebugLoc::None);\n+    let lifetime_intrinsic = ccx.get_intrinsic(match lt {\n+        Lifetime::Start => \"llvm.lifetime.start\",\n+        Lifetime::End => \"llvm.lifetime.end\"\n+    });\n+    emit(ccx, size, lifetime_intrinsic)\n }\n \n-pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n-    if cx.sess().opts.optimize == config::No {\n-        return;\n-    }\n-\n-    let _icx = push_ctxt(\"lifetime_end\");\n-    let ccx = cx.ccx();\n-\n-    let size = machine::llsize_of_alloc(ccx, val_ty(ptr).element_type());\n-    if size == 0 {\n-        return;\n-    }\n+pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n+    core_lifetime_emit(cx.ccx(), ptr, Lifetime::Start, |ccx, size, lifetime_start| {\n+        let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n+        Call(cx,\n+             lifetime_start,\n+             &[C_u64(ccx, size), ptr],\n+             None,\n+             DebugLoc::None);\n+    })\n+}\n \n-    let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n-    let lifetime_end = ccx.get_intrinsic(&\"llvm.lifetime.end\");\n-    Call(cx,\n-         lifetime_end,\n-         &[C_u64(ccx, size), ptr],\n-         None,\n-         DebugLoc::None);\n+pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n+    core_lifetime_emit(cx.ccx(), ptr, Lifetime::End, |ccx, size, lifetime_end| {\n+        let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n+        Call(cx,\n+             lifetime_end,\n+             &[C_u64(ccx, size), ptr],\n+             None,\n+             DebugLoc::None);\n+    })\n }\n \n // Generates code for resumption of unwind at the end of a landing pad.\n@@ -1285,12 +1300,81 @@ fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte:\n            None);\n }\n \n-pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, name: &str) -> ValueRef {\n+/// In general, when we create an scratch value in an alloca, the\n+/// creator may not know if the block (that initializes the scratch\n+/// with the desired value) actually dominates the cleanup associated\n+/// with the scratch value.\n+///\n+/// To deal with this, when we do an alloca (at the *start* of whole\n+/// function body), we optionally can also set the associated\n+/// dropped-flag state of the alloca to \"dropped.\"\n+#[derive(Copy, Clone, Debug)]\n+pub enum InitAlloca {\n+    /// Indicates that the state should have its associated drop flag\n+    /// set to \"dropped\" at the point of allocation.\n+    Dropped,\n+    /// Indicates the value of the associated drop flag is irrelevant.\n+    /// The embedded string literal is a programmer provided argument\n+    /// for why. This is a safeguard forcing compiler devs to\n+    /// document; it might be a good idea to also emit this as a\n+    /// comment with the alloca itself when emitting LLVM output.ll.\n+    Uninit(&'static str),\n+}\n+\n+\n+pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                            t: Ty<'tcx>,\n+                            name: &str) -> ValueRef {\n+    // pnkfelix: I do not know why alloc_ty meets the assumptions for\n+    // passing Uninit, but it was never needed (even back when we had\n+    // the original boolean `zero` flag on `lvalue_scratch_datum`).\n+    alloc_ty_init(bcx, t, InitAlloca::Uninit(\"all alloc_ty are uninit\"), name)\n+}\n+\n+/// This variant of `fn alloc_ty` does not necessarily assume that the\n+/// alloca should be created with no initial value. Instead the caller\n+/// controls that assumption via the `init` flag.\n+///\n+/// Note that if the alloca *is* initialized via `init`, then we will\n+/// also inject an `llvm.lifetime.start` before that initialization\n+/// occurs, and thus callers should not call_lifetime_start\n+/// themselves.  But if `init` says \"uninitialized\", then callers are\n+/// in charge of choosing where to call_lifetime_start and\n+/// subsequently populate the alloca.\n+///\n+/// (See related discussion on PR #30823.)\n+pub fn alloc_ty_init<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             t: Ty<'tcx>,\n+                             init: InitAlloca,\n+                             name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n     assert!(!t.has_param_types());\n-    alloca(bcx, ty, name)\n+    match init {\n+        InitAlloca::Dropped => alloca_dropped(bcx, t, name),\n+        InitAlloca::Uninit(_) => alloca(bcx, ty, name),\n+    }\n+}\n+\n+pub fn alloca_dropped<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ty: Ty<'tcx>, name: &str) -> ValueRef {\n+    let _icx = push_ctxt(\"alloca_dropped\");\n+    let llty = type_of::type_of(cx.ccx(), ty);\n+    if cx.unreachable.get() {\n+        unsafe { return llvm::LLVMGetUndef(llty.ptr_to().to_ref()); }\n+    }\n+    let p = alloca(cx, llty, name);\n+    let b = cx.fcx.ccx.builder();\n+    b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n+\n+    // This is just like `call_lifetime_start` (but latter expects a\n+    // Block, which we do not have for `alloca_insert_pt`).\n+    core_lifetime_emit(cx.ccx(), p, Lifetime::Start, |ccx, size, lifetime_start| {\n+        let ptr = b.pointercast(p, Type::i8p(ccx));\n+        b.call(lifetime_start, &[C_u64(ccx, size), ptr], None);\n+    });\n+    memfill(&b, p, ty, adt::DTOR_DONE);\n+    p\n }\n \n pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n@@ -1639,6 +1723,8 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n     let fcx = bcx.fcx;\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n \n+    debug!(\"create_datums_for_fn_args\");\n+\n     // Return an array wrapping the ValueRefs that we get from `get_param` for\n     // each argument into datums.\n     //\n@@ -1650,6 +1736,7 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n     // This alloca should be optimized away by LLVM's mem-to-reg pass in\n     // the event it's not truly needed.\n     let mut idx = fcx.arg_offset() as c_uint;\n+    let uninit_reason = InitAlloca::Uninit(\"fn_arg populate dominates dtor\");\n     for (i, &arg_ty) in arg_tys.iter().enumerate() {\n         let arg_datum = if !has_tupled_arg || i < arg_tys.len() - 1 {\n             if type_of::arg_is_indirect(bcx.ccx(), arg_ty) &&\n@@ -1669,9 +1756,12 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                 let data = get_param(fcx.llfn, idx);\n                 let extra = get_param(fcx.llfn, idx + 1);\n                 idx += 2;\n-                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n+                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\", uninit_reason,\n                                                         arg_scope_id, (data, extra),\n                                                         |(data, extra), bcx, dst| {\n+                    debug!(\"populate call for create_datum_for_fn_args \\\n+                            early fat arg, on arg[{}] ty={:?}\", i, arg_ty);\n+\n                     Store(bcx, data, expr::get_dataptr(bcx, dst));\n                     Store(bcx, extra, expr::get_meta(bcx, dst));\n                     bcx\n@@ -1684,9 +1774,16 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                               datum::lvalue_scratch_datum(bcx,\n                                                           arg_ty,\n                                                           \"\",\n+                                                          uninit_reason,\n                                                           arg_scope_id,\n                                                           tmp,\n-                                                          |tmp, bcx, dst| tmp.store_to(bcx, dst)))\n+                                                          |tmp, bcx, dst| {\n+\n+                        debug!(\"populate call for create_datum_for_fn_args \\\n+                                early thin arg, on arg[{}] ty={:?}\", i, arg_ty);\n+\n+                                                              tmp.store_to(bcx, dst)\n+                                                          }))\n             }\n         } else {\n             // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n@@ -1696,11 +1793,14 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                                   datum::lvalue_scratch_datum(bcx,\n                                                               arg_ty,\n                                                               \"tupled_args\",\n+                                                              uninit_reason,\n                                                               arg_scope_id,\n                                                               (),\n                                                               |(),\n                                                                mut bcx,\n-                                                               llval| {\n+                                                              llval| {\n+                        debug!(\"populate call for create_datum_for_fn_args \\\n+                                tupled_args, on arg[{}] ty={:?}\", i, arg_ty);\n                         for (j, &tupled_arg_ty) in\n                                     tupled_arg_tys.iter().enumerate() {\n                             let lldest = StructGEP(bcx, llval, j);"}, {"sha": "32f263746d31e04158742f0abcf12395ad1d44c4", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=9036c82781c9666836b724c62f3a478505cdead7", "patch": "@@ -288,20 +288,31 @@ pub fn immediate_rvalue_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     return DatumBlock::new(bcx, immediate_rvalue(val, ty))\n }\n \n-\n /// Allocates temporary space on the stack using alloca() and returns a by-ref Datum pointing to\n /// it. The memory will be dropped upon exit from `scope`. The callback `populate` should\n /// initialize the memory.\n+///\n+/// The flag `zero` indicates how the temporary space itself should be\n+/// initialized at the outset of the function; the only time that\n+/// `InitAlloca::Uninit` is a valid value for `zero` is when the\n+/// caller can prove that either (1.) the code injected by `populate`\n+/// onto `bcx` always dominates the end of `scope`, or (2.) the data\n+/// being allocated has no associated destructor.\n pub fn lvalue_scratch_datum<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                               ty: Ty<'tcx>,\n                                               name: &str,\n+                                              zero: InitAlloca,\n                                               scope: cleanup::ScopeId,\n                                               arg: A,\n                                               populate: F)\n                                               -> DatumBlock<'blk, 'tcx, Lvalue> where\n     F: FnOnce(A, Block<'blk, 'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n {\n-    let scratch = alloc_ty(bcx, ty, name);\n+    // Very subtle: potentially initialize the scratch memory at point where it is alloca'ed.\n+    // (See discussion at Issue 30530.)\n+    let scratch = alloc_ty_init(bcx, ty, zero, name);\n+    debug!(\"lvalue_scratch_datum scope={:?} scratch={} ty={:?}\",\n+           scope, bcx.ccx().tn().val_to_string(scratch), ty);\n \n     // Subtle. Populate the scratch memory *before* scheduling cleanup.\n     let bcx = populate(arg, bcx, scratch);\n@@ -340,6 +351,8 @@ fn add_rvalue_clean<'a, 'tcx>(mode: RvalueMode,\n                               scope: cleanup::ScopeId,\n                               val: ValueRef,\n                               ty: Ty<'tcx>) {\n+    debug!(\"add_rvalue_clean scope={:?} val={} ty={:?}\",\n+           scope, fcx.ccx.tn().val_to_string(val), ty);\n     match mode {\n         ByValue => { fcx.schedule_drop_immediate(scope, val, ty); }\n         ByRef => {\n@@ -496,9 +509,13 @@ impl<'tcx> Datum<'tcx, Rvalue> {\n \n             ByValue => {\n                 lvalue_scratch_datum(\n-                    bcx, self.ty, name, scope, self,\n+                    bcx, self.ty, name, InitAlloca::Dropped, scope, self,\n                     |this, bcx, llval| {\n-                        call_lifetime_start(bcx, llval);\n+                        debug!(\"populate call for Datum::to_lvalue_datum_in_scope \\\n+                                self.ty={:?}\", this.ty);\n+                        // do not call_lifetime_start here; the\n+                        // `InitAlloc::Dropped` will start scratch\n+                        // value's lifetime at open of function body.\n                         let bcx = this.store_to(bcx, llval);\n                         bcx.fcx.schedule_lifetime_end(scope, llval);\n                         bcx"}, {"sha": "57afd0b580f177d40906cf3022e3d2e62b955638", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=9036c82781c9666836b724c62f3a478505cdead7", "patch": "@@ -1487,6 +1487,8 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n+    debug!(\"trans_adt\");\n+\n     // This scope holds intermediates that must be cleaned should\n     // panic occur before the ADT as a whole is ready.\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();"}, {"sha": "3a1568a70c9922d8d8804c8daa75b0c6b402a090", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036c82781c9666836b724c62f3a478505cdead7/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=9036c82781c9666836b724c62f3a478505cdead7", "patch": "@@ -111,8 +111,15 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Always create an alloca even if zero-sized, to preserve\n     // the non-null invariant of the inner slice ptr\n-    let llfixed = base::alloc_ty(bcx, fixed_ty, \"\");\n-    call_lifetime_start(bcx, llfixed);\n+    let llfixed;\n+    // Issue 30018: ensure state is initialized as dropped if necessary.\n+    if fcx.type_needs_drop(vt.unit_ty) {\n+        llfixed = base::alloc_ty_init(bcx, fixed_ty, InitAlloca::Dropped, \"\");\n+    } else {\n+        let uninit = InitAlloca::Uninit(\"fcx says vt.unit_ty is non-drop\");\n+        llfixed = base::alloc_ty_init(bcx, fixed_ty, uninit, \"\");\n+        call_lifetime_start(bcx, llfixed);\n+    };\n \n     if count > 0 {\n         // Arrange for the backing array to be cleaned up.\n@@ -212,8 +219,8 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         bcx = expr::trans_into(bcx, &**element,\n                                                SaveIn(lleltptr));\n                         let scope = cleanup::CustomScope(temp_scope);\n-                        fcx.schedule_lifetime_end(scope, lleltptr);\n-                        fcx.schedule_drop_mem(scope, lleltptr, vt.unit_ty, None);\n+                        // Issue #30822: mark memory as dropped after running destructor\n+                        fcx.schedule_drop_and_fill_mem(scope, lleltptr, vt.unit_ty, None);\n                     }\n                     fcx.pop_custom_cleanup_scope(temp_scope);\n                 }"}, {"sha": "c55cc91cc928fa66e96dfa4e79b60f48e1d505d9", "filename": "src/test/run-pass/issue-29092.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9036c82781c9666836b724c62f3a478505cdead7/src%2Ftest%2Frun-pass%2Fissue-29092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036c82781c9666836b724c62f3a478505cdead7/src%2Ftest%2Frun-pass%2Fissue-29092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29092.rs?ref=9036c82781c9666836b724c62f3a478505cdead7", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue #29092.\n+//\n+// (Possibly redundant with regression test run-pass/issue-30530.rs)\n+\n+use self::Term::*;\n+\n+#[derive(Clone)]\n+pub enum Term {\n+    Dummy,\n+    A(Box<Term>),\n+    B(Box<Term>),\n+}\n+\n+// a small-step evaluator\n+pub fn small_eval(v: Term) -> Term {\n+    match v {\n+        A(t) => *t.clone(),\n+        B(t) => *t.clone(),\n+        _ => Dummy,\n+    }\n+}\n+\n+fn main() {\n+    small_eval(Dummy);\n+}"}, {"sha": "25eff9def9dfc83e3c0d396262779c0599058907", "filename": "src/test/run-pass/issue-30018-nopanic.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/9036c82781c9666836b724c62f3a478505cdead7/src%2Ftest%2Frun-pass%2Fissue-30018-nopanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036c82781c9666836b724c62f3a478505cdead7/src%2Ftest%2Frun-pass%2Fissue-30018-nopanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-30018-nopanic.rs?ref=9036c82781c9666836b724c62f3a478505cdead7", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// More thorough regression test for Issues #30018 and #30822. This\n+// attempts to explore different ways that array element construction\n+// (for both scratch arrays and non-scratch ones) interacts with\n+// breaks in the control-flow, in terms of the order of evaluation of\n+// the destructors (which may change; see RFC Issue 744) and the\n+// number of times that the destructor evaluates for each value (which\n+// should never exceed 1; this latter case is what #30822 is about).\n+\n+use std::cell::RefCell;\n+\n+struct D<'a>(&'a RefCell<Vec<i32>>, i32);\n+\n+impl<'a> Drop for D<'a> {\n+    fn drop(&mut self) {\n+        println!(\"Dropping D({})\", self.1);\n+        (self.0).borrow_mut().push(self.1);\n+    }\n+}\n+\n+fn main() {\n+    println!(\"Start\");\n+    break_during_elem();\n+    break_after_whole();\n+    println!(\"Finis\");\n+}\n+\n+fn break_during_elem() {\n+    let log = &RefCell::new(Vec::new());\n+\n+    // CASE 1: Fixed-size array itself is stored in _r slot.\n+    loop {\n+        let _r = [D(log, 10),\n+                  D(log, 11),\n+                  { D(log, 12); break; },\n+                  D(log, 13)];\n+    }\n+    assert_eq!(&log.borrow()[..], &[12, 11, 10]);\n+    log.borrow_mut().clear();\n+\n+    // CASE 2: Slice (borrow of array) is stored in _r slot.\n+    // This is the case that is actually being reported in #30018.\n+    loop {\n+        let _r = &[D(log, 20),\n+                   D(log, 21),\n+                   { D(log, 22); break; },\n+                   D(log, 23)];\n+    }\n+    assert_eq!(&log.borrow()[..], &[22, 21, 20]);\n+    log.borrow_mut().clear();\n+\n+    // CASE 3: (Borrow of) slice-index of array is stored in _r slot.\n+    loop {\n+        let _r = &[D(log, 30),\n+                  D(log, 31),\n+                  { D(log, 32); break; },\n+                  D(log, 33)][..];\n+    }\n+    assert_eq!(&log.borrow()[..], &[32, 31, 30]);\n+    log.borrow_mut().clear();\n+}\n+\n+// The purpose of these functions is to test what happens when we\n+// panic after an array has been constructed in its entirety.\n+//\n+// It is meant to act as proof that we still need to continue\n+// scheduling the destruction of an array even after we've scheduling\n+// drop for its elements during construction; the latter is tested by\n+// `fn break_during_elem()`.\n+fn break_after_whole() {\n+    let log = &RefCell::new(Vec::new());\n+\n+    // CASE 1: Fixed-size array itself is stored in _r slot.\n+    loop {\n+        let _r = [D(log, 10),\n+                  D(log, 11),\n+                  D(log, 12)];\n+        break;\n+    }\n+    assert_eq!(&log.borrow()[..], &[10, 11, 12]);\n+    log.borrow_mut().clear();\n+\n+    // CASE 2: Slice (borrow of array) is stored in _r slot.\n+    loop {\n+        let _r = &[D(log, 20),\n+                   D(log, 21),\n+                   D(log, 22)];\n+        break;\n+    }\n+    assert_eq!(&log.borrow()[..], &[20, 21, 22]);\n+    log.borrow_mut().clear();\n+\n+    // CASE 3: (Borrow of) slice-index of array is stored in _r slot.\n+    loop {\n+        let _r = &[D(log, 30),\n+                   D(log, 31),\n+                   D(log, 32)][..];\n+        break;\n+    }\n+    assert_eq!(&log.borrow()[..], &[30, 31, 32]);\n+    log.borrow_mut().clear();\n+}"}, {"sha": "da4d5f19d4a2e9b585f825c93d539602e531fd6f", "filename": "src/test/run-pass/issue-30018-panic.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9036c82781c9666836b724c62f3a478505cdead7/src%2Ftest%2Frun-pass%2Fissue-30018-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036c82781c9666836b724c62f3a478505cdead7/src%2Ftest%2Frun-pass%2Fissue-30018-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-30018-panic.rs?ref=9036c82781c9666836b724c62f3a478505cdead7", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue #30018. This is very similar to the\n+// original reported test, except that the panic is wrapped in a\n+// spawned thread to isolate the expected error result from the\n+// SIGTRAP injected by the drop-flag consistency checking.\n+\n+struct Foo;\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+fn foo() -> Foo {\n+    panic!();\n+}\n+\n+fn main() {\n+    use std::thread;\n+    let handle = thread::spawn(|| {\n+        let _ = &[foo()];\n+    });\n+    let _ = handle.join();\n+}"}, {"sha": "d5139c908bdac2ea2b743c7e354c398a5c7ec399", "filename": "src/test/run-pass/issue-30530.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9036c82781c9666836b724c62f3a478505cdead7/src%2Ftest%2Frun-pass%2Fissue-30530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036c82781c9666836b724c62f3a478505cdead7/src%2Ftest%2Frun-pass%2Fissue-30530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-30530.rs?ref=9036c82781c9666836b724c62f3a478505cdead7", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue #30530: alloca's created for storing\n+// intermediate scratch values during brace-less match arms need to be\n+// initialized with their drop-flag set to \"dropped\" (or else we end\n+// up running the destructors on garbage data at the end of the\n+// function).\n+\n+pub enum Handler {\n+    Default,\n+    #[allow(dead_code)]\n+    Custom(*mut Box<Fn()>),\n+}\n+\n+fn main() {\n+    take(Handler::Default, Box::new(main));\n+}\n+\n+#[inline(never)]\n+pub fn take(h: Handler, f: Box<Fn()>) -> Box<Fn()> {\n+    unsafe {\n+        match h {\n+            Handler::Custom(ptr) => *Box::from_raw(ptr),\n+            Handler::Default => f,\n+        }\n+    }\n+}"}]}